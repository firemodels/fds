MODULE INIT      
 
! Allocate numerous arrays and perform miscellaneous initializations

USE PRECISION_PARAMETERS
USE MESH_VARIABLES
USE MESH_POINTERS
USE GLOBAL_CONSTANTS
USE OUTPUT_DATA
USE TRAN
USE MEMORY_FUNCTIONS, ONLY : CHKMEMERR 
USE DEVICE_VARIABLES
IMPLICIT NONE

PRIVATE
INTEGER IZERO
CHARACTER(255), PARAMETER :: initid='$Id$'
CHARACTER(255), PARAMETER :: initrev='$Revision$'
CHARACTER(255), PARAMETER :: initdate='$Date$'

PUBLIC INITIALIZE_MESH_VARIABLES,INITIALIZE_GLOBAL_VARIABLES,OPEN_AND_CLOSE,INITIAL_NOISE,UVW_INIT, &
       INITIALIZE_DEVICES,INITIALIZE_PROFILES,GET_REV_init

TYPE (MESH_TYPE), POINTER :: M
TYPE (OBSTRUCTION_TYPE), POINTER :: OB
TYPE (SURFACE_TYPE), POINTER :: SF
TYPE (MATERIAL_TYPE), POINTER :: ML
 
 
CONTAINS
 
 
SUBROUTINE INITIALIZE_MESH_VARIABLES(NM)

USE PHYSICAL_FUNCTIONS, ONLY: GET_VISCOSITY,GET_SPECIFIC_GAS_CONSTANT,GET_SPECIFIC_HEAT
USE MEMORY_FUNCTIONS, ONLY: COMPUTE_ONE_D_STORAGE_DIMENSIONS,COMPUTE_PARTICLE_STORAGE_DIMENSIONS
USE GEOMETRY_FUNCTIONS, ONLY: ASSIGN_PRESSURE_ZONE
USE RADCONS, ONLY: UIIDIM
USE CONTROL_VARIABLES
USE GLOBAL_CONSTANTS, ONLY: NRA=>NUMBER_RADIATION_ANGLES,NSB=>NUMBER_SPECTRAL_BANDS
INTEGER :: N,I,J,K,II,JJ,KK,IPTS,JPTS,KPTS,N_EDGES_DIM,N_TOTAL_WALL_CELLS,IW,IWE,IWG,IC,SURF_INDEX,IOR,IOPZ, &
           IERR,IB,JB,KB,IPZ
INTEGER, INTENT(IN) :: NM
REAL(EB) :: MU_N,ZZ_GET(0:N_TRACKED_SPECIES),VC,RTRM,CP,CS,DELTA
INTEGER, POINTER :: IBP1, JBP1, KBP1,IBAR, JBAR, KBAR, N_EDGES
REAL(EB),POINTER :: XS,XF,YS,YF,ZS,ZF
TYPE (INITIALIZATION_TYPE), POINTER :: IN
TYPE (P_ZONE_TYPE), POINTER :: PZ
TYPE (VENTS_TYPE), POINTER :: VT
 
IERR = 0
M => MESHES(NM)
IBP1 =>M%IBP1
JBP1 =>M%JBP1
KBP1 =>M%KBP1
IBAR =>M%IBAR
JBAR =>M%JBAR
KBAR =>M%KBAR
N_EDGES=>M%N_EDGES
XS=>M%XS 
YS=>M%YS 
ZS=>M%ZS
XF=>M%XF 
YF=>M%YF 
ZF=>M%ZF
ALLOCATE(M%RHO(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','RHO',IZERO)
ALLOCATE(M%RHOS(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','RHOS',IZERO)
M%RHOS = RHOA
ALLOCATE(M%TMP(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','TMP',IZERO)
ALLOCATE(M%FRHO(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','FRHO',IZERO)
ALLOCATE(M%U(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','U',IZERO)
ALLOCATE(M%V(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','V',IZERO)
ALLOCATE(M%W(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','W',IZERO)
ALLOCATE(M%US(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','US',IZERO)
ALLOCATE(M%VS(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','VS',IZERO)
ALLOCATE(M%WS(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WS',IZERO)
ALLOCATE(M%FVX(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','FVX',IZERO)
ALLOCATE(M%FVY(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','FVY',IZERO)
ALLOCATE(M%FVZ(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','FVZ',IZERO)
ALLOCATE(M%H(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','H',IZERO)
ALLOCATE(M%HS(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','HS',IZERO)
ALLOCATE(M%KRES(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','KRES',IZERO)
ALLOCATE(M%DDDT(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','DDDT',IZERO)
ALLOCATE(M%D(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','D',IZERO)
ALLOCATE(M%DS(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','DS',IZERO)
ALLOCATE(M%MU(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','MU',IZERO)
ALLOCATE(M%STRAIN_RATE(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','STRAIN_RATE',IZERO)
ALLOCATE(M%CSD2(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','CS',IZERO)

IF (.NOT.EVACUATION_ONLY(NM)) THEN
   ALLOCATE(M%Q(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','Q',IZERO)
ENDIF

ALLOCATE(M%MIX_TIME(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','MIX_TIME',IZERO)
M%MIX_TIME=M%DT

! Background pressure, temperature, density as a function of height (Z coordinate)

ALLOCATE(  M%PBAR(0:KBP1,0:N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','PBAR',IZERO)
ALLOCATE(  M%PBAR_S(0:KBP1,0:N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','PBAR_S',IZERO)
ALLOCATE(  M%R_PBAR(0:KBP1,0:N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','R_PBAR',IZERO)
ALLOCATE(  M%D_PBAR_DT(0:N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','D_PBAR_DT',IZERO)
ALLOCATE(  M%D_PBAR_DT_S(0:N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','D_PBAR_DT_S',IZERO)
ALLOCATE(M%P_0(0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','P_0',IZERO)
ALLOCATE(M%TMP_0(0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','TMP_0',IZERO)
ALLOCATE(M%RHO_0(0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','RHO_0',IZERO)

! Leaks

ALLOCATE(  M%U_LEAK(0:N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','U_LEAK',IZERO)
M%U_LEAK = 0._EB

! Allocate species arrays

IF (N_TRACKED_SPECIES>0 .AND. .NOT.EVACUATION_ONLY(NM)) THEN
   ALLOCATE( M%ZZ(0:IBP1,0:JBP1,0:KBP1,N_TRACKED_SPECIES),STAT=IZERO)
   CALL ChkMemErr('INIT','ZZ',IZERO)
   M%ZZ = 0._EB
   ALLOCATE(M%ZZS(0:IBP1,0:JBP1,0:KBP1,N_TRACKED_SPECIES),STAT=IZERO)
   CALL ChkMemErr('INIT','ZZS',IZERO)
   M%ZZS = 0._EB   
   ALLOCATE(M%DEL_RHO_D_DEL_Z(0:IBP1,0:JBP1,0:KBP1,N_TRACKED_SPECIES),STAT=IZERO)
   CALL ChkMemErr('INIT','DEL_RHO_D_DEL_Z',IZERO)
   M%DEL_RHO_D_DEL_Z = 0._EB     
ENDIF

ALLOCATE(M%RSUM(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','RSUM',IZERO)
M%RSUM = RSUM0

! Allocate reaction divergence

IF (N_REACTIONS > 0) THEN
   ALLOCATE(M%D_REACTION(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','D_REACTION',IZERO) 
   M%D_REACTION = 0._EB
ENDIF

! Enthalpy arrays (experimental)

IF (ENTHALPY_TRANSPORT) THEN
   ALLOCATE(M%RHO_H_S_OVER_PBAR(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','RHO_H_S_OVER_PBAR',IZERO) 
   M%RHO_H_S_OVER_PBAR = 0._EB ! initialized in DENSITY
   ALLOCATE(M%D_RHSOP_DT(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','D_RHSOP_DT',IZERO) 
   M%D_RHSOP_DT = 0._EB 
   ALLOCATE(M%D_RHSOP_DT_S(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','D_RHSOP_DT_S',IZERO) 
   M%D_RHSOP_DT_S = 0._EB 
ENDIF

! Allocate water mass arrays if sprinklers are present
 
IF (PARTICLE_FILE) PARTICLE_TAG = NM

IF (N_LAGRANGIAN_CLASSES >0 .AND. .NOT. EVACUATION_ONLY(NM)) THEN
   ALLOCATE(M%AVG_DROP_DEN_ALL(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','AVG_DROP_DEN_ALL',IZERO) 
   M%AVG_DROP_DEN_ALL=0._EB
ENDIF

IF (N_LP_ARRAY_INDICES>0 .AND. .NOT.EVACUATION_ONLY(NM)) THEN
   ALLOCATE(M%QR_W(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','QR_W',IZERO) 
   M%QR_W = 0._EB
   ALLOCATE(M%AVG_DROP_DEN(0:IBP1,0:JBP1,0:KBP1,N_LP_ARRAY_INDICES),STAT=IZERO)
   CALL ChkMemErr('INIT','AVG_DROP_DEN',IZERO) 
   M%AVG_DROP_DEN=0._EB
   ALLOCATE(M%AVG_DROP_AREA(0:IBP1,0:JBP1,0:KBP1,N_LP_ARRAY_INDICES),STAT=IZERO)
   CALL ChkMemErr('INIT','AVG_DROP_AREA',IZERO) 
   M%AVG_DROP_AREA=0._EB
   ALLOCATE(M%AVG_DROP_TMP(0:IBP1,0:JBP1,0:KBP1,N_LP_ARRAY_INDICES),STAT=IZERO)
   CALL ChkMemErr('INIT','AVG_DROP_TMP',IZERO) 
   M%AVG_DROP_TMP=TMPM
   ALLOCATE(M%AVG_DROP_RAD(0:IBP1,0:JBP1,0:KBP1,N_LP_ARRAY_INDICES),STAT=IZERO)
   CALL ChkMemErr('INIT','AVG_DROP_RAD',IZERO) 
   M%AVG_DROP_RAD=0._EB
   ALLOCATE(M%D_LAGRANGIAN(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','D_LAGRANGIAN',IZERO) 
   M%D_LAGRANGIAN = 0._EB
ENDIF
 
! If radiation absorption desired allocate arrays
 
IF (.NOT.EVACUATION_ONLY(NM)) THEN
   ALLOCATE(M%QR(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','QR',IZERO)
   M%QR = 0._EB
   ALLOCATE(M%KAPPA(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','KAPPA',IZERO) 
   M%KAPPA = KAPPA0
   ALLOCATE(M%UII(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','UII',IZERO)
   M%UII = 0._EB
   ALLOCATE(M%KFST4(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','KFST4',IZERO)
   M%KFST4 = 0._EB
ELSE
   ALLOCATE(M%QR(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','QR',IZERO)
   M%QR = 0._EB
ENDIF

! Work arrays

ALLOCATE(M%WORK1(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK1',IZERO)
ALLOCATE(M%WORK2(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK2',IZERO)
ALLOCATE(M%WORK3(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK3',IZERO)
ALLOCATE(M%WORK4(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK4',IZERO)
ALLOCATE(M%WORK5(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK5',IZERO)
ALLOCATE(M%WORK6(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK6',IZERO)
ALLOCATE(M%WORK7(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK7',IZERO)
ALLOCATE(M%WORK8(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK8',IZERO)

IF (IMMERSED_BOUNDARY_METHOD==2) THEN
   ALLOCATE(M%IBM_SAVE1(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','IBM_SAVE1',IZERO)
   ALLOCATE(M%IBM_SAVE2(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','IBM_SAVE2',IZERO)
   ALLOCATE(M%IBM_SAVE3(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','IBM_SAVE3',IZERO)
   ALLOCATE(M%IBM_SAVE4(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','IBM_SAVE4',IZERO)
   ALLOCATE(M%IBM_SAVE5(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','IBM_SAVE5',IZERO)
   ALLOCATE(M%IBM_SAVE6(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','IBM_SAVE6',IZERO)
ENDIF

! Boundary file patch counter
 
ALLOCATE(M%INC(-3:3,0:M%N_OBST),STAT=IZERO)
CALL ChkMemErr('INIT','INC',IZERO)

! Initialize background pressure, temperature and density

M%D_PBAR_DT   = 0._EB
M%D_PBAR_DT_S = 0._EB

IF (STRATIFICATION .AND. .NOT.EVACUATION_ONLY(NM)) THEN
   DO K=0,M%KBP1
      M%TMP_0(K) = TMPA + LAPSE_RATE*(M%ZC(K)-GROUND_LEVEL)
      IF (ABS(LAPSE_RATE)>ZERO_P) THEN
         M%P_0(K) = P_INF*(M%TMP_0(K)/M%TMP_0(0))**(GVEC(3)/RSUM0/LAPSE_RATE)
      ELSE
         M%P_0(K) = P_INF*EXP(GVEC(3)*(M%ZC(K)-GROUND_LEVEL)/(RSUM0*TMPA))
      ENDIF
   ENDDO
ELSE
   M%TMP_0(:) = TMPA
   M%P_0(:)   = P_INF
ENDIF
DO K=0,M%KBP1
   M%PBAR(K,:)   = M%P_0(K)
   M%PBAR_S(K,:) = M%P_0(K)
   M%RHO_0(K)    = M%P_0(K)/(M%TMP_0(K)*RSUM0)
ENDDO

! Initialize various time step variables
 
M%DT_PREV = M%DT
M%DT_NEXT = M%DT
M%DT_INIT = M%DT

! Initialize major arrays

DO K=0,M%KBP1
   M%RHO(:,:,K) = M%RHO_0(K)
   M%TMP(:,:,K) = M%TMP_0(K)
ENDDO
IF (.NOT.EVACUATION_ONLY(NM)) M%FRHO    = 0._EB
M%U       = U0
M%V       = V0
M%W       = W0
M%US      = U0
M%VS      = V0
M%WS      = W0
M%FVX   = 0._EB
M%FVY   = 0._EB
M%FVZ   = 0._EB
M%H     = H0
M%HS    = H0
M%KRES  = 0._EB

M%DDDT  = 0._EB
M%D     = 0._EB
M%DS    = 0._EB
IF (.NOT.EVACUATION_ONLY(NM)) THEN
   M%Q     = 0._EB
ENDIF
IF (EVACUATION_ONLY(NM)) THEN
   M%U       = 0._EB
   M%V       = 0._EB
   M%W       = 0._EB
   M%US      = 0._EB
   M%VS      = 0._EB
   M%WS      = 0._EB
   M%H       = 0._EB
   M%HS      = 0._EB
ENDIF
IF (N_TRACKED_SPECIES > 0 .AND. .NOT.EVACUATION_ONLY(NM)) M%DEL_RHO_D_DEL_Z = 0._EB

! Viscosity

IF (N_TRACKED_SPECIES>0) ZZ_GET(1:N_TRACKED_SPECIES) = SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
CALL GET_VISCOSITY(ZZ_GET,MU_N,TMPA)
M%MU = MU_N

CS = C_SMAGORINSKY
IF (EVACUATION_ONLY(NM)) CS=0.9_EB
DO K=0,KBP1
   DO J=0,JBP1
      DO I=0,IBP1
         IF (TWO_D) THEN
            DELTA = MAX(M%DX(I),M%DZ(K))
         ELSE
            DELTA = MAX(M%DX(I),M%DY(J),M%DZ(K))
         ENDIF
         M%CSD2(I,J,K) = (CS*DELTA)**2
      ENDDO
   ENDDO
ENDDO
 
! Initialize mass fraction arrays

IF (N_TRACKED_SPECIES > 0 .AND. .NOT.EVACUATION_ONLY(NM)) THEN
   DO N=1,N_TRACKED_SPECIES
      M%ZZ(:,:,:,N)  = SPECIES_MIXTURE(N)%ZZ0
      M%ZZS(:,:,:,N) = SPECIES_MIXTURE(N)%ZZ0
   ENDDO
ENDIF

! Initialize pressure ZONEs
 
ALLOCATE(M%PRESSURE_ZONE(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','PRESSURE_ZONE',IZERO)
M%PRESSURE_ZONE = 0
ZONE_LOOP: DO N=1,N_ZONE
   IF (EVACUATION_ONLY(NM)) CYCLE ZONE_LOOP
   PZ => P_ZONE(N)
   DO K=0,KBP1
      DO J=0,JBP1
         DO I=0,IBP1
            IF (M%PRESSURE_ZONE(I,J,K)==N) CYCLE
            IF (M%XC(I) > PZ%X1 .AND. M%XC(I) < PZ%X2 .AND. &
                M%YC(J) > PZ%Y1 .AND. M%YC(J) < PZ%Y2 .AND. &
                M%ZC(K) > PZ%Z1 .AND. M%ZC(K) < PZ%Z2) THEN 
                M%PRESSURE_ZONE(I,J,K) = N
                DO IOPZ=0,N_ZONE
                   IF (PZ%LEAK_AREA(IOPZ) > 0._EB) ACTUAL_LEAK_AREA(N,IOPZ) = PZ%LEAK_AREA(IOPZ)
                   IF (PZ%LEAK_AREA(IOPZ) > 0._EB) ACTUAL_LEAK_AREA(IOPZ,N) = PZ%LEAK_AREA(IOPZ)
                ENDDO
                IF (.NOT.M%SOLID(M%CELL_INDEX(I,J,K))) CALL ASSIGN_PRESSURE_ZONE(NM,M%XC(I),M%YC(J),M%ZC(K),N)
            ENDIF
         ENDDO
      ENDDO
   ENDDO
ENDDO ZONE_LOOP


! Over-ride default ambient conditions with user-prescribed INITializations
 
DO N=1,N_INIT
   IF (EVACUATION_ONLY(NM)) CYCLE
   IN => INITIALIZATION(N)
   DO K=0,KBP1
      DO J=0,JBP1
         DO I=0,IBP1
            IF (M%XC(I) > IN%X1 .AND. M%XC(I) < IN%X2 .AND. &
                M%YC(J) > IN%Y1 .AND. M%YC(J) < IN%Y2 .AND. &
                M%ZC(K) > IN%Z1 .AND. M%ZC(K) < IN%Z2) THEN
               M%TMP(I,J,K)            = IN%TEMPERATURE
               M%RHO(I,J,K)            = IN%DENSITY
               IF (N_TRACKED_SPECIES>0) M%ZZ(I,J,K,1:N_TRACKED_SPECIES) = IN%MASS_FRACTION(1:N_TRACKED_SPECIES)
               IF (IN%ADJUST_DENSITY)     M%RHO(I,J,K) = M%RHO(I,J,K)*M%P_0(K)/P_INF
               IF (IN%ADJUST_TEMPERATURE) M%TMP(I,J,K) = M%TMP(I,J,K)*M%P_0(K)/P_INF
               M%Q(I,J,K) = IN%HRRPUV
            ENDIF
         ENDDO
      ENDDO
   ENDDO
ENDDO

! Compute molecular weight term RSUM=R0*SUM(Y_i/M_i)

IF (N_TRACKED_SPECIES>0 .AND. .NOT.EVACUATION_ONLY(NM)) THEN
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            ZZ_GET(1:N_TRACKED_SPECIES) = M%ZZ(I,J,K,1:N_TRACKED_SPECIES)
            CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,M%RSUM(I,J,K))
         ENDDO
      ENDDO
   ENDDO
ENDIF

! Allocate and Initialize Mesh-Dependent Radiation Arrays

M%QR    = 0._EB
IF (.NOT.EVACUATION_ONLY(NM)) THEN
   M%KAPPA = KAPPA0
   M%UII   = 4._EB*SIGMA*TMPA4
ENDIF
M%ANGLE_INC_COUNTER = 0
M%RAD_CALL_COUNTER  = 0
IF (RADIATION .AND. .NOT.EVACUATION_ONLY(NM)) THEN
   ALLOCATE(M%UIID(0:M%IBP1,0:M%JBP1,0:M%KBP1,1:UIIDIM),STAT=IZERO)
   CALL ChkMemErr('INIT','UIID',IZERO)
   M%UIID = 0.
ENDIF

! General work arrays

M%WORK1 = 0._EB
M%WORK2 = 0._EB
M%WORK3 = 0._EB
M%WORK4 = 0._EB
M%WORK5 = 0._EB
M%WORK6 = 0._EB
IF (.NOT.EVACUATION_ONLY(NM)) M%WORK7 = 0._EB

! Immersed Boundary Method

IF (IMMERSED_BOUNDARY_METHOD==2) THEN
   M%IBM_SAVE1 = 0._EB
   M%IBM_SAVE2 = 0._EB
   M%IBM_SAVE3 = 0._EB
   M%IBM_SAVE4 = 0._EB
   M%IBM_SAVE5 = 0._EB
   M%IBM_SAVE6 = 0._EB
ENDIF

IF (IMMERSED_BOUNDARY_METHOD>=0) THEN
   ALLOCATE(M%U_MASK(0:M%IBP1,0:M%JBP1,0:M%KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT_IBM','U_MASK',IZERO)
   ALLOCATE(M%V_MASK(0:M%IBP1,0:M%JBP1,0:M%KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT_IBM','V_MASK',IZERO)
   ALLOCATE(M%W_MASK(0:M%IBP1,0:M%JBP1,0:M%KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT_IBM','W_MASK',IZERO)
   ALLOCATE(M%P_MASK(0:M%IBP1,0:M%JBP1,0:M%KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT_IBM','P_MASK',IZERO)
   M%U_MASK=1
   M%V_MASK=1
   M%W_MASK=1
   M%P_MASK=1
ENDIF

! Allocate ONE_D data storage array and compute the dimensions of its components

ALLOCATE(M%ONE_D_WALL_STORAGE(0:N_SURF))

DO N=0,N_SURF
   CALL COMPUTE_ONE_D_STORAGE_DIMENSIONS(N)
ENDDO

! Allocate lagrangian particle storage array and compute the dimensions of its components

M%NLP = 0
M%NLPDIM = 1000
IF (PARTICLE_FILE .AND. .NOT.EVACUATION_ONLY(NM)) THEN
   ALLOCATE(M%LAGRANGIAN_PARTICLE(M%NLPDIM),STAT=IZERO)
   CALL ChkMemErr('INIT','PARTICLE',IZERO)
   ALLOCATE(M%PARTICLE_STORAGE(N_LAGRANGIAN_CLASSES))
   DO N=1,N_LAGRANGIAN_CLASSES
      CALL COMPUTE_PARTICLE_STORAGE_DIMENSIONS(N)
   ENDDO
ENDIF

! Determine the total number of wall cells to allocate
 
M%N_INTERNAL_WALL_CELLS = 0

OBST_LOOP_1: DO N=1,M%N_OBST
   OB=>M%OBSTRUCTION(N)
   IF (OB%CONSUMABLE .AND. .NOT.EVACUATION_ONLY(NM)) THEN
      IB   = OB%I2-OB%I1
      JB   = OB%J2-OB%J1
      KB   = OB%K2-OB%K1
      M%N_INTERNAL_WALL_CELLS = M%N_INTERNAL_WALL_CELLS + 2*(MAX(1,IB)*JB*KB + MAX(1,JB)*IB*KB + MAX(1,KB)*IB*JB)
   ELSE
      DO K=OB%K1+1,OB%K2
         DO J=OB%J1+1,OB%J2
            IC = M%CELL_INDEX(OB%I1  ,J,K)
            IF (.NOT.M%SOLID(IC).OR.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE) M%N_INTERNAL_WALL_CELLS = M%N_INTERNAL_WALL_CELLS+1
            IC = M%CELL_INDEX(OB%I2+1,J,K)
            IF (.NOT.M%SOLID(IC).OR.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE) M%N_INTERNAL_WALL_CELLS = M%N_INTERNAL_WALL_CELLS+1
         ENDDO 
      ENDDO
      DO K=OB%K1+1,OB%K2
         DO I=OB%I1+1,OB%I2
            IC = M%CELL_INDEX(I,OB%J1  ,K)
            IF (.NOT.M%SOLID(IC).OR.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE) M%N_INTERNAL_WALL_CELLS = M%N_INTERNAL_WALL_CELLS+1
            IC = M%CELL_INDEX(I,OB%J2+1,K)
            IF (.NOT.M%SOLID(IC).OR.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE) M%N_INTERNAL_WALL_CELLS = M%N_INTERNAL_WALL_CELLS+1
         ENDDO 
      ENDDO
      DO J=OB%J1+1,OB%J2
         DO I=OB%I1+1,OB%I2
            IC = M%CELL_INDEX(I,J,OB%K1  )
            IF (.NOT.M%SOLID(IC).OR.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE) M%N_INTERNAL_WALL_CELLS = M%N_INTERNAL_WALL_CELLS+1
            IC = M%CELL_INDEX(I,J,OB%K2+1)
            IF (.NOT.M%SOLID(IC).OR.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE) M%N_INTERNAL_WALL_CELLS = M%N_INTERNAL_WALL_CELLS+1
         ENDDO 
      ENDDO
   ENDIF
ENDDO OBST_LOOP_1

! Compute the number of ghost wall cells (external wall cells outside the computational domain)

M%N_GHOST_WALL_CELLS = 8*(IBP1+JBP1+KBP1)

! Allocate arrays indexed by wall cells (IW). Note the order of the cells in the overall array.

N_TOTAL_WALL_CELLS = M%N_EXTERNAL_WALL_CELLS + M%N_INTERNAL_WALL_CELLS + M%N_GHOST_WALL_CELLS

ALLOCATE(M%WALL(0:N_TOTAL_WALL_CELLS),STAT=IZERO)
CALL ChkMemErr('INIT','WALL',IZERO)

NOT_EVAC_IF_1: IF (.NOT.EVACUATION_ONLY(NM)) THEN 

   ALLOCATE(M%D_CORR(M%N_EXTERNAL_WALL_CELLS),STAT=IZERO)
   CALL ChkMemErr('INIT','D_CORR',IZERO) 
   ALLOCATE(M%DS_CORR(M%N_EXTERNAL_WALL_CELLS),STAT=IZERO)
   CALL ChkMemErr('INIT','DS_CORR',IZERO) 
   M%D_CORR = 0._EB
   M%DS_CORR = 0._EB
   ALLOCATE(M%UVW_SAVE(M%N_EXTERNAL_WALL_CELLS),STAT=IZERO)
   CALL ChkMemErr('INIT','UVW_SAVE',IZERO) 
   M%UVW_SAVE = 0._EB

   ALLOCATE(M%U_GHOST(M%N_EXTERNAL_WALL_CELLS),STAT=IZERO)
   CALL ChkMemErr('INIT','U_GHOST',IZERO) 
   ALLOCATE(M%V_GHOST(M%N_EXTERNAL_WALL_CELLS),STAT=IZERO)
   CALL ChkMemErr('INIT','V_GHOST',IZERO) 
   ALLOCATE(M%W_GHOST(M%N_EXTERNAL_WALL_CELLS),STAT=IZERO)
   CALL ChkMemErr('INIT','W_GHOST',IZERO) 
   M%U_GHOST = 0._EB
   M%V_GHOST = 0._EB
   M%W_GHOST = 0._EB
   
ENDIF NOT_EVAC_IF_1

! Allocate arrays for turbulent inflow boundary conditions (experimental)
 
VENT_LOOP: DO N=1,M%N_VENT
   VT => M%VENTS(N)    
   EDDY_IF: IF (VT%N_EDDY>0) THEN
      SELECT CASE(ABS(VT%IOR))
         CASE(1)
            ALLOCATE(VT%U_EDDY(VT%J1+1:VT%J2,VT%K1+1:VT%K2),STAT=IZERO)
            CALL ChkMemErr('READ_VENT','U_EDDY',IZERO)
            ALLOCATE(VT%V_EDDY(VT%J1+1:VT%J2,VT%K1+1:VT%K2),STAT=IZERO)
            CALL ChkMemErr('READ_VENT','V_EDDY',IZERO)
            ALLOCATE(VT%W_EDDY(VT%J1+1:VT%J2,VT%K1+1:VT%K2),STAT=IZERO)
            CALL ChkMemErr('READ_VENT','W_EDDY',IZERO)
         CASE(2)
            ALLOCATE(VT%U_EDDY(VT%I1+1:VT%I2,VT%K1+1:VT%K2),STAT=IZERO)
            CALL ChkMemErr('READ_VENT','U_EDDY',IZERO)
            ALLOCATE(VT%V_EDDY(VT%I1+1:VT%I2,VT%K1+1:VT%K2),STAT=IZERO)
            CALL ChkMemErr('READ_VENT','V_EDDY',IZERO)
            ALLOCATE(VT%W_EDDY(VT%I1+1:VT%I2,VT%K1+1:VT%K2),STAT=IZERO)
            CALL ChkMemErr('READ_VENT','W_EDDY',IZERO)
         CASE(3)
            ALLOCATE(VT%U_EDDY(VT%I1+1:VT%I2,VT%J1+1:VT%J2),STAT=IZERO)
            CALL ChkMemErr('READ_VENT','U_EDDY',IZERO)
            ALLOCATE(VT%V_EDDY(VT%I1+1:VT%I2,VT%J1+1:VT%J2),STAT=IZERO)
            CALL ChkMemErr('READ_VENT','V_EDDY',IZERO)
            ALLOCATE(VT%W_EDDY(VT%I1+1:VT%I2,VT%J1+1:VT%J2),STAT=IZERO)
            CALL ChkMemErr('READ_VENT','W_EDDY',IZERO)
      END SELECT
      ALLOCATE(VT%X_EDDY(VT%N_EDDY),STAT=IZERO)
      CALL ChkMemErr('READ_VENT','X_EDDY',IZERO)
      ALLOCATE(VT%Y_EDDY(VT%N_EDDY),STAT=IZERO)
      CALL ChkMemErr('READ_VENT','Y_EDDY',IZERO)
      ALLOCATE(VT%Z_EDDY(VT%N_EDDY),STAT=IZERO)
      CALL ChkMemErr('READ_VENT','Z_EDDY',IZERO)
      ALLOCATE(VT%CU_EDDY(VT%N_EDDY),STAT=IZERO)
      CALL ChkMemErr('READ_VENT','CU_EDDY',IZERO)
      ALLOCATE(VT%CV_EDDY(VT%N_EDDY),STAT=IZERO)
      CALL ChkMemErr('READ_VENT','CV_EDDY',IZERO)
      ALLOCATE(VT%CW_EDDY(VT%N_EDDY),STAT=IZERO)
      CALL ChkMemErr('READ_VENT','CW_EDDY',IZERO)
      VT%U_EDDY=0._EB
      VT%V_EDDY=0._EB
      VT%W_EDDY=0._EB
      VT%X_EDDY=0._EB
      VT%Y_EDDY=0._EB
      VT%Z_EDDY=0._EB
      VT%CU_EDDY=0._EB
      VT%CV_EDDY=0._EB
      VT%CW_EDDY=0._EB
   ENDIF EDDY_IF
ENDDO VENT_LOOP

ALLOCATE(M%DUWDT(N_TOTAL_WALL_CELLS),STAT=IZERO)
CALL ChkMemErr('INIT','DUWDT',IZERO) 
M%DUWDT = 0._EB

ALLOCATE(M%PRESSURE_BC_INDEX (0:M%N_EXTERNAL_WALL_CELLS),STAT=IZERO)
CALL ChkMemErr('INIT','PRESSURE_BC_INDEX ',IZERO) 
M%PRESSURE_BC_INDEX = NEUMANN

ALLOCATE(M%WALL_INDEX(0:M%CELL_COUNT,-3:3),STAT=IZERO)
CALL ChkMemErr('INIT','WALL_INDEX',IZERO) 
M%WALL_INDEX = 0

ALLOCATE(M%EDGE_INDEX(0:M%CELL_COUNT,1:12),STAT=IZERO)
CALL ChkMemErr('INIT','EDGE_INDEX',IZERO) 
M%EDGE_INDEX = 0

ALLOCATE(M%UVW_GHOST(0:M%CELL_COUNT,3),STAT=IZERO)
CALL ChkMemErr('INIT','UVW_GHOST',IZERO) 
M%UVW_GHOST = 0

! Surface work arrays

ALLOCATE(M%WALL_WORK1(N_TOTAL_WALL_CELLS),STAT=IZERO)
CALL ChkMemErr('INIT','WALL_WORK1',IZERO) 
ALLOCATE(M%WALL_WORK2(N_TOTAL_WALL_CELLS),STAT=IZERO)
CALL ChkMemErr('INIT','WALL_WORK2',IZERO) 

! Vegetation surface drag

ALLOCATE(M%VEG_DRAG(0:IBP1,0:JBP1),STAT=IZERO)
CALL ChkMemErr('INIT','VEG_DRAG',IZERO) 
M%VEG_DRAG = 0._EB
 
! Set up boundary arrays for external boundaries of the current mesh

IWE = 0
IWG = M%N_EXTERNAL_WALL_CELLS + M%N_INTERNAL_WALL_CELLS 

DO K=0,KBP1
   DO J=0,JBP1
      I   = 0
      SURF_INDEX = DEFAULT_SURF_INDEX
      IOR = 1
      IF (J==0 .OR. J==JBP1 .OR. K==0 .OR. K==KBP1) THEN
         IWG = IWG + 1
         IW  = IWG
      ELSE
         IWE = IWE + 1
         IW  = IWE
      ENDIF
      CALL INIT_WALL_CELL(NM,I,J,K,0,IW,IOR,SURF_INDEX,IERR)
      IF (IERR>0) RETURN
   ENDDO
ENDDO
DO K=0,KBP1
   DO J=0,JBP1
      I   = IBP1
      SURF_INDEX = DEFAULT_SURF_INDEX
      IOR = -1
      IF (J==0 .OR. J==JBP1 .OR. K==0 .OR. K==KBP1) THEN
         IWG = IWG + 1
         IW  = IWG
      ELSE
         IWE = IWE + 1
         IW  = IWE
      ENDIF
      CALL INIT_WALL_CELL(NM,I,J,K,0,IW,IOR,SURF_INDEX,IERR)
      IF (IERR>0) RETURN
   ENDDO
ENDDO
 
DO K=0,KBP1
   DO I=0,IBP1
      J   = 0
      SURF_INDEX = DEFAULT_SURF_INDEX
      IOR = 2
      IF (I==0 .OR. I==IBP1 .OR. K==0 .OR. K==KBP1) THEN
         IWG = IWG + 1
         IW  = IWG
      ELSE
         IWE = IWE + 1
         IW  = IWE
      ENDIF
      CALL INIT_WALL_CELL(NM,I,J,K,0,IW,IOR,SURF_INDEX,IERR)
      IF (IERR>0) RETURN
   ENDDO
ENDDO
DO K=0,KBP1
   DO I=0,IBP1
      J   = JBP1
      SURF_INDEX = DEFAULT_SURF_INDEX
      IOR = -2
      IF (I==0 .OR. I==IBP1 .OR. K==0 .OR. K==KBP1) THEN
         IWG = IWG + 1
         IW  = IWG
      ELSE
         IWE = IWE + 1
         IW  = IWE
      ENDIF
      CALL INIT_WALL_CELL(NM,I,J,K,0,IW,IOR,SURF_INDEX,IERR)
      IF (IERR>0) RETURN
   ENDDO
ENDDO
 
NOT_EVAC_IF_2: IF (.NOT.EVACUATION_ONLY(NM)) THEN
DO J=0,JBP1
   DO I=0,IBP1
      K   = 0
      SURF_INDEX = DEFAULT_SURF_INDEX
      IOR = 3
      IF (I==0 .OR. I==IBP1 .OR. J==0 .OR. J==JBP1) THEN
         IWG = IWG + 1
         IW  = IWG
      ELSE
         IWE = IWE + 1
         IW  = IWE
      ENDIF
      CALL INIT_WALL_CELL(NM,I,J,K,0,IW,IOR,SURF_INDEX,IERR)
      IF (IERR>0) RETURN
   ENDDO
ENDDO
DO J=0,JBP1
   DO I=0,IBP1
      K   = KBP1
      SURF_INDEX = DEFAULT_SURF_INDEX
      IOR = -3
      IF (I==0 .OR. I==IBP1 .OR. J==0 .OR. J==JBP1) THEN
         IWG = IWG + 1
         IW  = IWG
      ELSE
         IWE = IWE + 1
         IW  = IWE
      ENDIF
      CALL INIT_WALL_CELL(NM,I,J,K,0,IW,IOR,SURF_INDEX,IERR)
      IF (IERR>0) RETURN
   ENDDO
ENDDO
ENDIF NOT_EVAC_IF_2

! Go through all obstructions and decide which cell faces ought to be given a wall cell index and initialized

M%N_INTERNAL_WALL_CELLS = 0
 
OBST_LOOP_2: DO N=1,M%N_OBST
   OB=>M%OBSTRUCTION(N)
 
   DO K=OB%K1+1,OB%K2
      DO J=OB%J1+1,OB%J2
         I = OB%I1+1 
         IF (I==1) CYCLE   ! Don't assign wall cell index to obstruction face pointing out of the computational domain
         IC = M%CELL_INDEX(I-1,J,K)
         IF (M%SOLID(IC) .AND. .NOT.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE) CYCLE   ! Permanently covered face
         IOR = -1 
         SURF_INDEX = OB%SURF_INDEX(IOR)
         IW  = M%WALL_INDEX(IC,-IOR)
         IF (IW==0) THEN
            M%N_INTERNAL_WALL_CELLS = M%N_INTERNAL_WALL_CELLS + 1
            IW  = M%N_EXTERNAL_WALL_CELLS + M%N_INTERNAL_WALL_CELLS
         ENDIF
         CALL INIT_WALL_CELL(NM,I,J,K,N,IW,IOR,SURF_INDEX,IERR)
         IF (IERR>0) RETURN
      ENDDO
   ENDDO
 
   DO K=OB%K1+1,OB%K2
      DO J=OB%J1+1,OB%J2
         I = OB%I2
         IF (I==M%IBAR) CYCLE  ! Don't assign wall cell index to obstruction face pointing out of the computational domain
         IC = M%CELL_INDEX(I+1,J,K)
         IF (M%SOLID(IC) .AND. .NOT.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE) CYCLE   ! Permanently covered face
         IOR = 1
         SURF_INDEX = OB%SURF_INDEX(IOR)
         IW  = M%WALL_INDEX(IC,-IOR)
         IF (IW==0) THEN
            M%N_INTERNAL_WALL_CELLS = M%N_INTERNAL_WALL_CELLS + 1
            IW  = M%N_EXTERNAL_WALL_CELLS + M%N_INTERNAL_WALL_CELLS
         ENDIF
         CALL INIT_WALL_CELL(NM,I,J,K,N,IW,IOR,SURF_INDEX,IERR)
         IF (IERR>0) RETURN
      ENDDO 
   ENDDO
 
   DO K=OB%K1+1,OB%K2
      DO I=OB%I1+1,OB%I2
         J = OB%J1+1
         IF (J==1) CYCLE   ! Don't assign wall cell index to obstruction face pointing out of the computational domain
         IC = M%CELL_INDEX(I,J-1,K)
         IF (M%SOLID(IC) .AND. .NOT.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE) CYCLE   ! Permanently covered face
         IOR = -2
         SURF_INDEX = OB%SURF_INDEX(IOR)
         IW  = M%WALL_INDEX(IC,-IOR)
         IF (IW==0) THEN
            M%N_INTERNAL_WALL_CELLS = M%N_INTERNAL_WALL_CELLS + 1
            IW  = M%N_EXTERNAL_WALL_CELLS + M%N_INTERNAL_WALL_CELLS
         ENDIF
         CALL INIT_WALL_CELL(NM,I,J,K,N,IW,IOR,SURF_INDEX,IERR)
         IF (IERR>0) RETURN
      ENDDO
   ENDDO   
 
   DO K=OB%K1+1,OB%K2
      DO I=OB%I1+1,OB%I2
         J = OB%J2
         IF (J==M%JBAR) CYCLE  ! Don't assign wall cell index to obstruction face pointing out of the computational domain
         IC = M%CELL_INDEX(I,J+1,K)
         IF (M%SOLID(IC) .AND. .NOT.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE) CYCLE   ! Permanently covered face
         IOR = 2
         SURF_INDEX = OB%SURF_INDEX(IOR)
         IW  = M%WALL_INDEX(IC,-IOR)
         IF (IW==0) THEN
            M%N_INTERNAL_WALL_CELLS = M%N_INTERNAL_WALL_CELLS + 1
            IW  = M%N_EXTERNAL_WALL_CELLS + M%N_INTERNAL_WALL_CELLS
         ENDIF
         CALL INIT_WALL_CELL(NM,I,J,K,N,IW,IOR,SURF_INDEX,IERR)
         IF (IERR>0) RETURN
      ENDDO
   ENDDO   
 
   DO J=OB%J1+1,OB%J2
      DO I=OB%I1+1,OB%I2
         K = OB%K1+1
         IF (K==1) CYCLE   ! Don't assign wall cell index to obstruction face pointing out of the computational domain
         IC = M%CELL_INDEX(I,J,K-1)
         IF (M%SOLID(IC) .AND. .NOT.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE) CYCLE   ! Permanently covered face
         IOR = -3
         SURF_INDEX = OB%SURF_INDEX(IOR)
         IW  = M%WALL_INDEX(IC,-IOR)
         IF (IW==0) THEN
            M%N_INTERNAL_WALL_CELLS = M%N_INTERNAL_WALL_CELLS + 1
            IW  = M%N_EXTERNAL_WALL_CELLS + M%N_INTERNAL_WALL_CELLS
         ENDIF
         CALL INIT_WALL_CELL(NM,I,J,K,N,IW,IOR,SURF_INDEX,IERR)
         IF (IERR>0) RETURN
      ENDDO
   ENDDO   
 
   DO J=OB%J1+1,OB%J2
      DO I=OB%I1+1,OB%I2
         K = OB%K2
         IF (K==M%KBAR) CYCLE  ! Don't assign wall cell index to obstruction face pointing out of the computational domain
         IC = M%CELL_INDEX(I,J,K+1)
         IF (M%SOLID(IC) .AND. .NOT.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE) CYCLE   ! Permanently covered face
         IOR = 3 
         SURF_INDEX = OB%SURF_INDEX(IOR)
         IW  = M%WALL_INDEX(IC,-IOR)
         IF (IW==0) THEN
            M%N_INTERNAL_WALL_CELLS = M%N_INTERNAL_WALL_CELLS + 1
            IW  = M%N_EXTERNAL_WALL_CELLS + M%N_INTERNAL_WALL_CELLS
         ENDIF
         CALL INIT_WALL_CELL(NM,I,J,K,N,IW,IOR,SURF_INDEX,IERR)
         IF (IERR>0) RETURN
      ENDDO
   ENDDO   
 
ENDDO OBST_LOOP_2

! Initialize PSUM for zone cases

IF (N_ZONE > 0) THEN
   N_ZONE_LOOP: DO IPZ = 1,N_ZONE
      PSUM(IPZ,NM) = 0._EB
      IF (EVACUATION_ONLY(NM)) EXIT N_ZONE_LOOP
      DO K=1,M%KBAR
         DO J=1,M%JBAR
            DO I=1,M%IBAR
               IF (M%PRESSURE_ZONE(I,J,K) /= IPZ) CYCLE
               IF (M%SOLID(M%CELL_INDEX(I,J,K)))    CYCLE
               VC   = M%DX(I)*M%RC(I)*M%DY(J)*M%DZ(K)               
               IF (N_TRACKED_SPECIES>0) ZZ_GET(1:N_TRACKED_SPECIES) = M%ZZ(I,J,K,1:N_TRACKED_SPECIES)
               CALL GET_SPECIFIC_HEAT(ZZ_GET,CP,M%TMP(I,J,K))
               RTRM = M%RSUM(I,J,K)/(CP*M%PBAR(K,IPZ))
               PSUM(IPZ,NM) = PSUM(IPZ,NM) + VC*(1._EB/M%PBAR(K,IPZ)-RTRM)
            ENDDO
         ENDDO
      ENDDO
   ENDDO N_ZONE_LOOP
ENDIF

! Determine back wall index for exposed surfaces

DO IW=M%N_EXTERNAL_WALL_CELLS+1,M%N_EXTERNAL_WALL_CELLS+M%N_INTERNAL_WALL_CELLS
   IF (EVACUATION_ONLY(NM)) CYCLE
   ! Only assign BACK_INDEX to wall cells that are not attached to the exterior boundary of the computational domain
   SF=>SURFACE(M%WALL(IW)%SURF_INDEX)
   IF (SF%BACKING==EXPOSED) THEN
      II = M%WALL(IW)%ONE_D%II
      JJ = M%WALL(IW)%ONE_D%JJ
      KK = M%WALL(IW)%ONE_D%KK
      IC = M%CELL_INDEX(II,JJ,KK)
      IOR = M%WALL(IW)%ONE_D%IOR
      IF (.NOT.M%SOLID(IC)) M%WALL(IW)%BACK_INDEX = M%WALL_INDEX(IC,IOR)
      IF (     M%SOLID(IC)) THEN
         SELECT CASE(IOR)
            CASE(-1)
               II=II+1
            CASE( 1)
               II=II-1
            CASE(-2)
               JJ=JJ+1
            CASE( 2)
               JJ=JJ-1
            CASE(-3)
               KK=KK+1
            CASE( 3)
               KK=KK-1
         END SELECT
         IC = M%CELL_INDEX(II,JJ,KK)
         M%WALL(IW)%BACK_INDEX = M%WALL_INDEX(IC,IOR)
      ENDIF
   ENDIF
ENDDO

! Set clocks and counters related to frequency of solid phase conduction updates

M%BC_CLOCK     = T_BEGIN
M%WALL_COUNTER = 0

! Set clock for boudary fuel vegetation model

M%VEG_CLOCK_BC = T_BEGIN
 
! Allocate arrays for storing velocity boundary condition info
 
N_EDGES_DIM = 4*(IBP1*JBP1+IBP1*KBP1+JBP1*KBP1)
IF (EVACUATION_ONLY(NM)) N_EDGES_DIM = 4*(IBP1*KBP1+JBP1*KBP1)
DO N=1,M%N_OBST
   OB=>M%OBSTRUCTION(N)
   IPTS = OB%I2-OB%I1
   JPTS = OB%J2-OB%J1
   KPTS = OB%K2-OB%K1
   IF (EVACUATION_ONLY(NM)) THEN
      N_EDGES_DIM = N_EDGES_DIM + 4*(IPTS*KPTS+JPTS*KPTS)
   ELSE
      N_EDGES_DIM = N_EDGES_DIM + 4*(IPTS*JPTS+IPTS*KPTS+JPTS*KPTS)
   ENDIF
ENDDO

ALLOCATE(M%IJKE(16,N_EDGES_DIM),STAT=IZERO)
CALL ChkMemErr('INIT','IJKE',IZERO)   
M%IJKE  = 0
ALLOCATE(M%OME_E(0:N_EDGES_DIM,-2:2),STAT=IZERO)
CALL ChkMemErr('INIT','OME_E',IZERO)  
M%OME_E = 0._EB
ALLOCATE(M%TAU_E(0:N_EDGES_DIM,-2:2),STAT=IZERO)
CALL ChkMemErr('INIT','TAU_E',IZERO)  
M%TAU_E = 0._EB
ALLOCATE(M%EDGE_TYPE(N_EDGES_DIM,2),STAT=IZERO)
CALL ChkMemErr('INIT','EDGE_TYPE',IZERO)  
M%EDGE_TYPE = SOLID_EDGE
ALLOCATE(M%EDGE_INTERPOLATION_FACTOR(N_EDGES_DIM,2),STAT=IZERO)
CALL ChkMemErr('INIT','EDGE_INTERPOLATION_FACTOR',IZERO)  
M%EDGE_INTERPOLATION_FACTOR = 1._EB
 
! Allocate array to hold character strings for Smokeview file
 
M%N_STRINGS     =   0
M%N_STRINGS_MAX = 100
ALLOCATE(M%STRING(M%N_STRINGS_MAX),STAT=IZERO)
CALL ChkMemErr('INIT','STRING',IZERO)
 
! Set up arrays to hold velocity boundary condition info
 
CALL INITIALIZE_EDGES

! Initialize Pressure solver
 
CALL INITIALIZE_POISSON_SOLVER
IF (IERR/=0) RETURN

! Initialize Mesh Exchange
 
CALL INITIALIZE_INTERPOLATION


CONTAINS
 
 
SUBROUTINE INITIALIZE_EDGES
 
! Set up edge arrays for velocity boundary conditions
 
INTEGER I,J,K,N
 
CALL POINT_TO_MESH(NM)
 
N_EDGES = 0
 
! Arguments for DEFINE_EDGE(I,J,K,IOR,IEC,NM,I_OBST)
 
DO K=0,KBAR
   DO J=0,JBAR
      IF (J>0) CALL DEFINE_EDGE(   0,J,K, 1,2,NM,0,IERR)
      IF (J>0) CALL DEFINE_EDGE(IBAR,J,K,-1,2,NM,0,IERR)
      IF (K>0) CALL DEFINE_EDGE(   0,J,K, 1,3,NM,0,IERR)
      IF (K>0) CALL DEFINE_EDGE(IBAR,J,K,-1,3,NM,0,IERR)
   ENDDO
ENDDO
DO K=0,KBAR
   DO I=0,IBAR
      IF (I>0) CALL DEFINE_EDGE(I,   0,K, 2,1,NM,0,IERR)
      IF (I>0) CALL DEFINE_EDGE(I,JBAR,K,-2,1,NM,0,IERR)
      IF (K>0) CALL DEFINE_EDGE(I,   0,K, 2,3,NM,0,IERR)
      IF (K>0) CALL DEFINE_EDGE(I,JBAR,K,-2,3,NM,0,IERR)
   ENDDO
ENDDO
DO J=0,JBAR
   DO I=0,IBAR
      IF (I>0) CALL DEFINE_EDGE(I,J,   0, 3,1,NM,0,IERR)
      IF (I>0) CALL DEFINE_EDGE(I,J,KBAR,-3,1,NM,0,IERR)
      IF (J>0) CALL DEFINE_EDGE(I,J,   0, 3,2,NM,0,IERR)
      IF (J>0) CALL DEFINE_EDGE(I,J,KBAR,-3,2,NM,0,IERR)
   ENDDO
ENDDO

IF (IERR/=0) RETURN

OBST_LOOP_3: DO N=1,N_OBST
   OB => OBSTRUCTION(N)
   DO K=OB%K1,OB%K2
      DO J=OB%J1,OB%J2
         IF (J>OB%J1) CALL DEFINE_EDGE(OB%I1,J,K,-1,2,NM,N,IERR)
         IF (J>OB%J1) CALL DEFINE_EDGE(OB%I2,J,K, 1,2,NM,N,IERR)
         IF (K>OB%K1) CALL DEFINE_EDGE(OB%I1,J,K,-1,3,NM,N,IERR)
         IF (K>OB%K1) CALL DEFINE_EDGE(OB%I2,J,K, 1,3,NM,N,IERR)
      ENDDO
   ENDDO
   DO K=OB%K1,OB%K2
      DO I=OB%I1,OB%I2
         IF (I>OB%I1) CALL DEFINE_EDGE(I,OB%J1,K,-2,1,NM,N,IERR)
         IF (I>OB%I1) CALL DEFINE_EDGE(I,OB%J2,K, 2,1,NM,N,IERR)
         IF (K>OB%K1) CALL DEFINE_EDGE(I,OB%J1,K,-2,3,NM,N,IERR)
         IF (K>OB%K1) CALL DEFINE_EDGE(I,OB%J2,K, 2,3,NM,N,IERR)
      ENDDO
   ENDDO
   DO J=OB%J1,OB%J2
      DO I=OB%I1,OB%I2
         IF (I>OB%I1) CALL DEFINE_EDGE(I,J,OB%K1,-3,1,NM,N,IERR)
         IF (I>OB%I1) CALL DEFINE_EDGE(I,J,OB%K2, 3,1,NM,N,IERR)
         IF (J>OB%J1) CALL DEFINE_EDGE(I,J,OB%K1,-3,2,NM,N,IERR)
         IF (J>OB%J1) CALL DEFINE_EDGE(I,J,OB%K2, 3,2,NM,N,IERR)
      ENDDO
   ENDDO
ENDDO OBST_LOOP_3

IF (N_EDGES>N_EDGES_DIM .AND. EVACUATION_ONLY(NM)) THEN
   WRITE(LU_ERR,'(A,I2,A,2I8)') 'ERROR: Edges memory; Mesh: ',NM,', n_edges, n_edges_dim ',N_EDGES, N_EDGES_DIM
   PROCESS_STOP_STATUS = SETUP_STOP
   IERR = 1
ENDIF
 
END SUBROUTINE INITIALIZE_EDGES
 
 
SUBROUTINE INITIALIZE_POISSON_SOLVER

USE POIS, ONLY: H3CZIS,H2CZIS,H3CSIS,H2CYIS
REAL(EB) :: XLM,XMU
INTEGER  :: N
INTEGER, POINTER :: ITRN,JTRN,KTRN,LBC,MBC,NBC
INTEGER, POINTER, DIMENSION(:) :: NOC
TYPE (VENTS_TYPE), POINTER :: VT
 
! Allocate major arrays
 
ITRN =>M%ITRN 
JTRN =>M%JTRN
KTRN =>M%KTRN
LBC =>M%LBC
MBC =>M%MBC
NBC =>M%NBC
NOC=>TRANS(NM)%NOC
IF (NOC(1)==0 .AND. NOC(2)==0 .AND. NOC(3)==0) M%IPS=0
IF (NOC(1)/=0 .AND. NOC(2)==0 .AND. NOC(3)==0) M%IPS=1
IF (NOC(1)==0 .AND. NOC(2)/=0 .AND. NOC(3)==0) M%IPS=2
IF (NOC(1)==0 .AND. NOC(2)==0 .AND. NOC(3)/=0) M%IPS=3
IF (NOC(1)/=0 .AND. NOC(2)/=0 .AND. NOC(3)==0) M%IPS=4
IF (NOC(1)/=0 .AND. NOC(2)==0 .AND. NOC(3)/=0) M%IPS=5
IF (NOC(1)==0 .AND. NOC(2)/=0 .AND. NOC(3)/=0) M%IPS=6
IF (EVACUATION_ONLY(NM)                      ) M%IPS=7
IF (NOC(1)/=0 .AND. NOC(2)/=0 .AND. NOC(3)/=0) THEN
   WRITE(LU_ERR,'(A,I3)') 'ERROR: Stretch at most 2 coordinate directions in MESH ',NM
   PROCESS_STOP_STATUS = SETUP_STOP
   IERR = 1
   RETURN
ENDIF
 
IF (M%IPS<=1 .OR. M%IPS==4) THEN
   ITRN = IBP1
   IF (JBAR>1) JTRN = JBP1
   IF (JBAR==1) JTRN = 1
   KTRN = KBP1
ENDIF
 
IF (M%IPS==2) THEN
   ITRN = JBP1
   JTRN = IBP1
   KTRN = KBP1
   ALLOCATE(M%BZST(JBP1,IBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BZST',IZERO)
   ALLOCATE(M%BZFT(JBP1,IBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BZFT',IZERO)
ENDIF
 
IF (M%IPS==3 .OR. M%IPS==6) THEN
   ITRN = KBP1
   IF (JBAR>1) JTRN = JBP1
   IF (JBAR==1) JTRN = 1
   KTRN = IBP1
   ALLOCATE(M%BXST(KBP1,JTRN),STAT=IZERO)
   CALL ChkMemErr('INIT','BXST',IZERO)
   ALLOCATE(M%BXFT(KBP1,JTRN),STAT=IZERO)
   CALL ChkMemErr('INIT','BXFT',IZERO)
   ALLOCATE(M%BYST(KBP1,IBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BYST',IZERO)
   ALLOCATE(M%BYFT(KBP1,IBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BYFT',IZERO)
   ALLOCATE(M%BZST(JTRN,IBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BZST',IZERO)
   ALLOCATE(M%BZFT(JTRN,IBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BZFT',IZERO)
ENDIF
 
IF (M%IPS==5) THEN
   ITRN = IBP1
   JTRN = KBP1
   KTRN = JBP1
   ALLOCATE(M%BXST(KBP1,JBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BXST',IZERO)
   ALLOCATE(M%BXFT(KBP1,JBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BXFT',IZERO)
ENDIF
 
IF (M%IPS==7) THEN
   ITRN = IBP1
   JTRN = JBP1
   KTRN = 1
ENDIF
 
IF (M%IPS<=3 .OR. M%IPS==7) THEN
   M%LSAVE = (ITRN+1)*JTRN*KTRN+7*ITRN+5*JTRN+6*KTRN+56
   M%LWORK = (ITRN+1)*JTRN*KTRN
ELSE
   N_LOOP: DO N=1,50
      IF ((JTRN+1)<=2**N) EXIT N_LOOP
   ENDDO N_LOOP
   M%LSAVE = KTRN*(6*N*(2**N)+2*N+19)+8*ITRN+7*JTRN+38
   M%LWORK = JTRN*(ITRN*(KTRN+1)+1)
ENDIF
 
ALLOCATE(M%SAVE1(-3:M%LSAVE),STAT=IZERO)
CALL ChkMemErr('INIT','SAVE1',IZERO)
ALLOCATE(M%WORK(M%LWORK),STAT=IZERO)
CALL ChkMemErr('INIT','WORK',IZERO)
ALLOCATE(M%PRHS(ITRN,JTRN,KTRN),STAT=IZERO)
CALL ChkMemErr('INIT','PRHS',IZERO)
IF (KBAR>1) THEN
   IF (JBAR>1) ALLOCATE(M%BXS(JBP1,KBP1),STAT=IZERO)
   IF (JBAR==1) ALLOCATE(M%BXS(1,KBP1)   ,STAT=IZERO)
ELSE
               ALLOCATE(M%BXS(JBP1,1)   ,STAT=IZERO)
ENDIF
CALL ChkMemErr('INIT','BXS',IZERO)
IF (KBAR>1) THEN
   IF (JBAR>1) ALLOCATE(M%BXF(JBP1,KBP1),STAT=IZERO)
   IF (JBAR==1) ALLOCATE(M%BXF(1,KBP1)   ,STAT=IZERO)
ELSE
               ALLOCATE(M%BXF(JBP1,1)   ,STAT=IZERO)
ENDIF
CALL ChkMemErr('INIT','BXF',IZERO)
IF (KBAR>1) THEN
   ALLOCATE(M%BYS(IBP1,KBP1),STAT=IZERO)
ELSE
   ALLOCATE(M%BYS(IBP1,1),STAT=IZERO)
ENDIF
CALL ChkMemErr('INIT','BYS',IZERO)
IF (KBAR>1) THEN
   ALLOCATE(M%BYF(IBP1,KBP1),STAT=IZERO)
ELSE
   ALLOCATE(M%BYF(IBP1,1),STAT=IZERO)
ENDIF
CALL ChkMemErr('INIT','BYF',IZERO)
IF (JBAR>1) ALLOCATE(M%BZS(IBP1,JBP1),STAT=IZERO)
IF (JBAR==1) ALLOCATE(M%BZS(IBP1,1)   ,STAT=IZERO)
CALL ChkMemErr('INIT','BZS',IZERO)
IF (JBAR>1) ALLOCATE(M%BZF(IBP1,JBP1),STAT=IZERO)
IF (JBAR==1) ALLOCATE(M%BZF(IBP1,1)   ,STAT=IZERO)
CALL ChkMemErr('INIT','BZF',IZERO)
 
M%SAVE1  = 0._EB
M%WORK  = 0._EB
M%PRHS  = 0._EB
M%BXS   = 0._EB
M%BXF   = 0._EB
M%BYS   = 0._EB
M%BYF   = 0._EB
M%BZS   = 0._EB
M%BZF   = 0._EB
 
! Initialize pressure solver   
 
XLM = 0._EB         ! No Helmholtz equation
XMU = 0._EB         ! No Helmholtz equation
LBC = 3
MBC = 3
NBC = 3

! Look for OPEN vents -- this will change the entire face to DIRICHLET BCs
 
VENT_LOOP: DO N=1,M%N_VENT
   VT => M%VENTS(N)
   IF (VT%BOUNDARY_TYPE /= OPEN_BOUNDARY .OR. VT%GHOST_CELLS_ONLY) CYCLE VENT_LOOP
   IF (VT%I1==0 .AND. VT%I2==0) THEN
      IF (LBC==3) LBC = 2
      IF (LBC==4) LBC = 1
   ENDIF
   IF (VT%I1==M%IBAR .AND. VT%I2==M%IBAR) THEN
      IF (LBC==3) LBC = 4
      IF (LBC==2) LBC = 1
   ENDIF
   IF (VT%J1==0 .AND. VT%J2==0) THEN
      IF (MBC==3) MBC = 2
      IF (MBC==4) MBC = 1
   ENDIF
   IF (VT%J1==M%JBAR .AND. VT%J2==M%JBAR) THEN
      IF (MBC==3) MBC = 4
      IF (MBC==2) MBC = 1
   ENDIF
   IF (VT%K1==0 .AND. VT%K2==0) THEN
      IF (NBC==3) NBC = 2
      IF (NBC==4) NBC = 1
   ENDIF
   IF (VT%K1==M%KBAR .AND. VT%K2==M%KBAR) THEN
      IF (NBC==3) NBC = 4
      IF (NBC==2) NBC = 1
   ENDIF
ENDDO VENT_LOOP
 
DO IW=1,M%N_EXTERNAL_WALL_CELLS
   IF (M%WALL(IW)%NOM>0) THEN
      SELECT CASE(M%WALL(IW)%ONE_D%IOR)
         CASE( 1)
            IF (LBC==3) LBC = 2
            IF (LBC==4) LBC = 1
         CASE(-1)
            IF (LBC==3) LBC = 4
            IF (LBC==2) LBC = 1
         CASE( 2)
            IF (MBC==3) MBC = 2
            IF (MBC==4) MBC = 1
         CASE(-2)
            IF (MBC==3) MBC = 4
            IF (MBC==2) MBC = 1
         CASE( 3)
            IF (NBC==3) NBC = 2
            IF (NBC==4) NBC = 1
         CASE(-3)
            IF (NBC==3) NBC = 4
            IF (NBC==2) NBC = 1
      END SELECT
   ENDIF
ENDDO
 
! Poisson solver with stretching in the 1st coordinate
 
SELECT_POISSON_SOLVER: SELECT CASE(M%IPS)

   CASE (0:1) SELECT_POISSON_SOLVER
      IF (.NOT.TWO_D) CALL H3CZIS(XS,XF,IBAR,LBC,YS,YF,JBAR,MBC,ZS,ZF,KBAR,NBC,M%HX,XLM,ITRN,JTRN,IERR,M%SAVE1)
      IF (TWO_D .AND. .NOT.CYLINDRICAL) CALL H2CZIS(XS,XF,IBAR,LBC,ZS,ZF,KBAR,NBC,M%HX,XLM,ITRN,IERR,M%SAVE1)
      IF (TWO_D .AND. CYLINDRICAL) THEN
         IF (ABS(XS)<=ZERO_P .AND. LBC==1) LBC = 5
         IF (ABS(XS)<=ZERO_P .AND. LBC==2) LBC = 6
         IF (ABS(XS)<=ZERO_P .AND. LBC==3) LBC = 6
         IF (ABS(XS)<=ZERO_P .AND. LBC==4) LBC = 5
         CALL H2CYIS(XS,XF,IBAR,LBC,ZS,ZF,KBAR,NBC,XLM,XMU,ITRN,IERR,M%SAVE1)
      ENDIF
   CASE (2) SELECT_POISSON_SOLVER
      CALL H3CZIS(YS,YF,JBAR,MBC,XS,XF,IBAR,LBC,ZS,ZF,KBAR,NBC,M%HY,XLM,ITRN,JTRN,IERR,M%SAVE1)
   CASE (3) SELECT_POISSON_SOLVER
      IF (TWO_D) THEN
         CALL H2CZIS(ZS,ZF,KBAR,NBC,XS,XF,IBAR,LBC,M%HZ,XLM,ITRN,IERR,M%SAVE1)
      ELSE
         CALL H3CZIS(ZS,ZF,KBAR,NBC,YS,YF,JBAR,MBC,XS,XF,IBAR,LBC,M%HZ,XLM,ITRN,JTRN,IERR,M%SAVE1)
      ENDIF
   CASE (4) SELECT_POISSON_SOLVER
      CALL H3CSIS(XS,XF,IBAR,LBC,YS,YF,JBAR,MBC,ZS,ZF,KBAR,NBC,XLM,ITRN,JTRN,IERR,M%SAVE1,M%WORK,M%HX,M%HY)
   CASE (5) SELECT_POISSON_SOLVER
      IF (TWO_D) THEN
         CALL H2CZIS(ZS,ZF,KBAR,NBC,XS,XF,IBAR,LBC,M%HZ,XLM,ITRN,IERR,M%SAVE1)
      ELSE
         CALL H3CSIS(XS,XF,IBAR,LBC,ZS,ZF,KBAR,NBC,YS,YF,JBAR,MBC,XLM,ITRN,JTRN,IERR,M%SAVE1,M%WORK,M%HX,M%HZ)
      ENDIF
   CASE (6) SELECT_POISSON_SOLVER
      CALL H3CSIS(ZS,ZF,KBAR,NBC,YS,YF,JBAR,MBC,XS,XF,IBAR,LBC,XLM,ITRN,JTRN,IERR,M%SAVE1,M%WORK,M%HZ,M%HY)
   CASE (7) SELECT_POISSON_SOLVER
      CALL H2CZIS(XS,XF,IBAR,LBC,YS,YF,JBAR,MBC,M%HX,XLM,ITRN,IERR,M%SAVE1)

END SELECT SELECT_POISSON_SOLVER
 
! Specify the pressure boundary condition for each wall cell

WALL_CELL_LOOP: DO IW=1,M%N_EXTERNAL_WALL_CELLS
   IOR = M%WALL(IW)%ONE_D%IOR
   SELECT CASE(IOR)
      CASE( 1)
         IF (LBC==3 .OR. LBC==4 .OR. LBC==6) M%WALL(IW)%PRESSURE_BC_INDEX = NEUMANN
         IF (LBC==1 .OR. LBC==2 .OR. LBC==5) M%WALL(IW)%PRESSURE_BC_INDEX = DIRICHLET
      CASE(-1)
         IF (LBC==2 .OR. LBC==3 .OR. LBC==6) M%WALL(IW)%PRESSURE_BC_INDEX = NEUMANN
         IF (LBC==1 .OR. LBC==4 .OR. LBC==5) M%WALL(IW)%PRESSURE_BC_INDEX = DIRICHLET
      CASE( 2)
         IF (MBC==3 .OR. MBC==4) M%WALL(IW)%PRESSURE_BC_INDEX = NEUMANN
         IF (MBC==1 .OR. MBC==2) M%WALL(IW)%PRESSURE_BC_INDEX = DIRICHLET
      CASE(-2)
         IF (MBC==3 .OR. MBC==2) M%WALL(IW)%PRESSURE_BC_INDEX = NEUMANN
         IF (MBC==1 .OR. MBC==4) M%WALL(IW)%PRESSURE_BC_INDEX = DIRICHLET
      CASE( 3)
         IF (NBC==3 .OR. NBC==4) M%WALL(IW)%PRESSURE_BC_INDEX = NEUMANN
         IF (NBC==1 .OR. NBC==2) M%WALL(IW)%PRESSURE_BC_INDEX = DIRICHLET
      CASE(-3)
         IF (NBC==3 .OR. NBC==2) M%WALL(IW)%PRESSURE_BC_INDEX = NEUMANN
         IF (NBC==1 .OR. NBC==4) M%WALL(IW)%PRESSURE_BC_INDEX = DIRICHLET
   END SELECT
   M%PRESSURE_BC_INDEX(IW) = M%WALL(IW)%PRESSURE_BC_INDEX 
ENDDO WALL_CELL_LOOP

! Check for errors with Poisson solver initialization
 
IF (IERR/=0) THEN
   WRITE(LU_ERR,'(A,I2,A,I3)') 'ERROR: Poisson initialization error, Number=',IERR, ', Mesh=',NM
   PROCESS_STOP_STATUS = SETUP_STOP
   RETURN
ENDIF
 
END SUBROUTINE INITIALIZE_POISSON_SOLVER
 
 
SUBROUTINE INITIALIZE_INTERPOLATION
 
! Create arrays by which info is to exchanged across meshes
 
INTEGER :: NOM,I,J,K
TYPE (MESH_TYPE), POINTER :: M2
 
IF (NM==1) RETURN
IF (EVACUATION_ONLY(NM)) RETURN
 
ALLOCATE(M%INTERPOLATED_MESH(1:M%IBAR,1:M%JBAR,1:M%KBAR),  STAT=IZERO)
CALL ChkMemErr('INIT','INTERPOLATED_MESH',IZERO)  
M%INTERPOLATED_MESH = 0
 
DO K=1,M%KBAR
   DO J=1,M%JBAR
      DO I=1,M%IBAR
         OTHER_MESH_LOOP: DO NOM=1,NM-1
            M2=>MESHES(NOM)
            IF (M%X(I-1)>=M2%XS .AND. M%X(I)<=M2%XF .AND.  M%Y(J-1)>=M2%YS .AND. M%Y(J)<=M2%YF .AND. &
                M%Z(K-1)>=M2%ZS .AND. M%Z(K)<=M2%ZF) THEN 
               M%INTERPOLATED_MESH(I,J,K) = NOM
               EXIT OTHER_MESH_LOOP
            ENDIF
         ENDDO OTHER_MESH_LOOP
      ENDDO
   ENDDO
ENDDO
 
END SUBROUTINE INITIALIZE_INTERPOLATION
 
END SUBROUTINE INITIALIZE_MESH_VARIABLES
 
 
 
SUBROUTINE INITIALIZE_DEVICES(NM)

! Find the WALL_INDEX for a device that is near a solid wall

INTEGER, INTENT(IN) :: NM
INTEGER :: III,N,II,JJ,KK,IOR,IW,SURF_INDEX
TYPE (DEVICE_TYPE), POINTER :: DV
TYPE (MESH_TYPE), POINTER :: M
 
M => MESHES(NM)

DEVICE_LOOP: DO N=1,N_DEVC

   DV => DEVICE(N)
   IF (DV%OUTPUT_INDEX>=0) CYCLE DEVICE_LOOP

   IF (DV%INIT_ID=='null') THEN ! Assume the device is tied to a wall cell

      IF (NM/=DV%MESH) CYCLE DEVICE_LOOP
      II  = GINV(DV%X-M%XS,1,NM)*M%RDXI   + 1._EB
      JJ  = GINV(DV%Y-M%YS,2,NM)*M%RDETA  + 1._EB
      KK  = GINV(DV%Z-M%ZS,3,NM)*M%RDZETA + 1._EB
      IOR = DV%IOR
      CALL GET_WALL_INDEX(NM,II,JJ,KK,IOR,IW)

      IF (IW==0 .AND. DV%STATISTICS=='null') THEN
         WRITE(LU_ERR,'(A,I4,A)') 'ERROR: Reposition DEVC No.',DV%ORDINAL, '. FDS cannot determine which boundary cell to assign'
         PROCESS_STOP_STATUS = SETUP_STOP
         RETURN
      ELSE 
         DV%WALL_INDEX = IW
         SURF_INDEX = M%WALL(IW)%SURF_INDEX
      ENDIF
      IF (IW==0) SURF_INDEX = DV%SURF_INDEX

   ELSE ! Assume the device is tied to a particle

      IF (DV%PART_INDEX<1) CYCLE DEVICE_LOOP
      SURF_INDEX = LAGRANGIAN_PARTICLE_CLASS(DV%PART_INDEX)%SURF_INDEX

   ENDIF

   ! Make sure that thermally-thick output is appropriate

   IF (OUTPUT_QUANTITY(DV%OUTPUT_INDEX)%INSIDE_SOLID) THEN
      IF (SURFACE(SURF_INDEX)%THERMAL_BC_INDEX /= THERMALLY_THICK) THEN
         WRITE(LU_ERR,'(A,I3,A)') 'ERROR: DEViCe ',N, ' must be associated with a heat-conducting surface'
         PROCESS_STOP_STATUS = SETUP_STOP
         RETURN
      ENDIF
      DV%I_DEPTH = SURFACE(SURF_INDEX)%N_CELLS
      DO III=SURFACE(SURF_INDEX)%N_CELLS,1,-1
         IF (DV%DEPTH<=SURFACE(SURF_INDEX)%X_S(III)) DV%I_DEPTH = III
      ENDDO
   ENDIF

ENDDO DEVICE_LOOP
 
END SUBROUTINE INITIALIZE_DEVICES
 
 
SUBROUTINE INITIALIZE_PROFILES(NM)

INTEGER, INTENT(IN) :: NM
INTEGER :: NN,N,II,JJ,KK,IW,IOR
LOGICAL :: SUCCESS
TYPE (PROFILE_TYPE), POINTER :: PF
TYPE (MESH_TYPE), POINTER :: M

IF (EVACUATION_ONLY(NM)) RETURN

M => MESHES(NM)

PROF_LOOP: DO N=1,N_PROF
   PF => PROFILE(N)
   IF (NM/=PF%MESH) CYCLE PROF_LOOP
   II  = GINV(PF%X-M%XS,1,NM)*M%RDXI   + 1._EB
   JJ  = GINV(PF%Y-M%YS,2,NM)*M%RDETA  + 1._EB
   KK  = GINV(PF%Z-M%ZS,3,NM)*M%RDZETA + 1._EB
   IOR = PF%IOR
   CALL GET_WALL_INDEX(NM,II,JJ,KK,IOR,IW)
   IF (IW>0) THEN
      PF%IW = IW
      SF => SURFACE(WALL(IW)%SURF_INDEX)
      IF (.NOT.SF%THERMALLY_THICK) THEN
         WRITE(LU_ERR,'(A,I3,A)') 'ERROR: PROFile ',N, ' must be associated with a heat-conducting surface'
         PROCESS_STOP_STATUS = SETUP_STOP
         RETURN
      ENDIF
      IF (PF%QUANTITY /= 'TEMPERATURE' .AND. PF%QUANTITY /= 'DENSITY') THEN
         SUCCESS = .FALSE.
         DO NN=1,SF%N_MATL
            IF (PF%QUANTITY==SF%MATL_NAME(NN)) SUCCESS = .TRUE.
         ENDDO
         IF (.NOT.SUCCESS) THEN
            WRITE(LU_ERR,'(A,A,A)') 'ERROR: QUANTITY ',TRIM(PF%QUANTITY), ' is not appropriate for the designated location'
            PROCESS_STOP_STATUS = SETUP_STOP
            RETURN
         ENDIF
      ENDIF
   ELSE
      WRITE(LU_ERR,'(A,I4,A)') 'ERROR: Reposition PROF No.',PF%ORDINAL, '. FDS cannot determine which boundary cell to assign'
      PROCESS_STOP_STATUS = SETUP_STOP
      RETURN
   ENDIF
ENDDO PROF_LOOP
 
END SUBROUTINE INITIALIZE_PROFILES


SUBROUTINE GET_WALL_INDEX(NM,II,JJ,KK,IOR,IW)

! Find the wall index corresponding to the -IOR face of cell (II,JJ,KK) 

INTEGER, INTENT(IN) :: NM,IOR
INTEGER, INTENT(OUT) :: IW
INTEGER :: IC,II,JJ,KK

M => MESHES(NM)
IC  = M%CELL_INDEX(II,JJ,KK)
 
IF (M%SOLID(IC)) THEN
   SELECT CASE(IOR)
      CASE(-1)
         IF (II>0)      II = II-1
      CASE( 1)
         IF (II<M%IBP1) II = II+1
      CASE(-2)
         IF (JJ>0)      JJ = JJ-1
      CASE( 2)
         IF (JJ<M%JBP1) JJ = JJ+1
      CASE(-3)
         IF (KK>0)      KK = KK-1
      CASE( 3)
         IF (KK<M%KBP1) KK = KK+1
   END SELECT
ENDIF
 
IC  = M%CELL_INDEX(II,JJ,KK)
IW  = M%WALL_INDEX(IC,-IOR)
 
IF (IW<=0) THEN
   SELECT CASE(IOR)
      CASE(-1)
         IF (II>0)      IC = M%CELL_INDEX(II-1,JJ,KK)
      CASE( 1)
         IF (II<M%IBP1) IC = M%CELL_INDEX(II+1,JJ,KK)
      CASE(-2)
         IF (JJ>0)      IC = M%CELL_INDEX(II,JJ-1,KK)
      CASE( 2)
         IF (JJ<M%JBP1) IC = M%CELL_INDEX(II,JJ+1,KK)
      CASE(-3)
         IF (KK>0)      IC = M%CELL_INDEX(II,JJ,KK-1)
      CASE( 3)
         IF (KK<M%KBP1) IC = M%CELL_INDEX(II,JJ,KK+1)
   END SELECT
   IW = M%WALL_INDEX(IC,-IOR)
ENDIF

END SUBROUTINE GET_WALL_INDEX



SUBROUTINE INITIALIZE_GLOBAL_VARIABLES
USE CONTROL_VARIABLES, ONLY: N_CTRL

! Initialize time, printout and plot clocks
 
ALLOCATE(PART_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','PART_CLOCK',IZERO) 
ALLOCATE(ISOF_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','ISOF_CLOCK',IZERO)
ALLOCATE(BNDF_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','BNDF_CLOCK',IZERO) 
ALLOCATE(SLCF_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','SLCF_CLOCK',IZERO)
ALLOCATE(SL3D_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','SLCF_CLOCK',IZERO) 
ALLOCATE(CORE_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','CORE_CLOCK',IZERO) 
ALLOCATE(PL3D_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','PL3D_CLOCK',IZERO) 
ALLOCATE(PROF_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','PROF_CLOCK',IZERO) 
 
ICYC              = 0
PART_CLOCK        = T_BEGIN
DEVC_CLOCK        = T_BEGIN      
CTRL_CLOCK        = T_BEGIN      
PROF_CLOCK        = T_BEGIN      
PL3D_CLOCK        = T_BEGIN + DT_PL3D
ISOF_CLOCK        = T_BEGIN      
SLCF_CLOCK        = T_BEGIN
SL3D_CLOCK        = T_BEGIN + DT_SL3D
GEOM_CLOCK        = T_BEGIN
BNDE_CLOCK        = T_BEGIN
BNDF_CLOCK        = T_BEGIN     
CORE_CLOCK        = T_BEGIN + DT_RESTART
FLUSH_CLOCK       = T_BEGIN + DT_FLUSH
HRR_CLOCK         = T_BEGIN
MINT_CLOCK        = T_BEGIN      
VEG_CLOCK         = T_BEGIN

IF (N_DEVC==0)      DEVC_CLOCK = 1.E10_EB
IF (N_CTRL==0)      CTRL_CLOCK = 1.E10_EB
IF (N_PROF==0)      PROF_CLOCK = 1.E10_EB
IF (N_ISOF==0)      ISOF_CLOCK = 1.E10_EB
IF (N_FACE==0)      GEOM_CLOCK = 1.E10_EB
IF (N_BNDE==0)      BNDE_CLOCK = 1.E10_EB
IF (N_BNDF==0)      BNDF_CLOCK = 1.E10_EB
IF (.NOT.MASS_FILE) MINT_CLOCK = 1.E10_EB

ALLOCATE(SPECIFIC_ENTHALPY_SUM(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','SPECIFIC_ENTHALPY_SUM',IZERO) 
SPECIFIC_ENTHALPY_SUM = 0._EB
ALLOCATE(Q_DOT(N_Q_DOT,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','Q_DOT',IZERO) 
Q_DOT = 0._EB
ALLOCATE(Q_DOT_SUM(N_Q_DOT,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','Q_DOT_SUM',IZERO) 
Q_DOT_SUM = 0._EB
ALLOCATE(M_DOT(N_M_DOT,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','M_DOT',IZERO) 
M_DOT = 0._EB
ALLOCATE(M_DOT_SUM(N_M_DOT,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','M_DOT_SUM',IZERO)  
M_DOT_SUM=0._EB

ALLOCATE(HRR_TIME_INTERVAL(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','HRR_TIME_INTERVAL',IZERO)  
HRR_TIME_INTERVAL=0._EB
ALLOCATE(MINT(0:MAX_SPECIES,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','MINT',IZERO) 
ALLOCATE(MINT_SUM(0:MAX_SPECIES,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','MINT_SUM',IZERO) 
MINT_SUM=0._EB
ALLOCATE(MINT_TIME_INTERVAL(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','MINT_TIME_INTERVAL',IZERO) 
MINT_TIME_INTERVAL=0._EB
ALLOCATE(T_PER_STEP(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','T_PER_STEP',IZERO) 
T_PER_STEP = 0._EB
ALLOCATE(T_ACCUM(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','T_ACCUM',IZERO) 
T_ACCUM = 0._EB
ALLOCATE(NTCYC(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','NTCYC',IZERO) 
NTCYC = 0
ALLOCATE(NCYC(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','NCYC',IZERO) 
NCYC = 0

ALLOCATE(DSUM(N_ZONE,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','DSUM',IZERO) 
DSUM = 0._EB
ALLOCATE(PSUM(N_ZONE,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','PSUM',IZERO) 
PSUM = 0._EB
ALLOCATE(USUM(N_ZONE,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','USUM',IZERO) 
USUM = 0._EB
ALLOCATE(ACTUAL_LEAK_AREA(0:N_ZONE,0:N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','ACTUAL_LEAK_AREA',IZERO) 
ACTUAL_LEAK_AREA = 0._EB
ALLOCATE(FDS_LEAK_AREA(0:N_ZONE,0:N_ZONE,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','FDS_LEAK_AREA',IZERO) 
FDS_LEAK_AREA = 0._EB
ALLOCATE(FDS_LEAK_AREA_RATIO(0:N_ZONE,0:N_ZONE,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','FDS_LEAK_AREA_RATIO',IZERO) 
FDS_LEAK_AREA_RATIO = 1._EB

ALLOCATE(VELOCITY_ERROR_MAX(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','VELOCITY_ERROR_MAX',IZERO) 
ALLOCATE(VELOCITY_ERROR_MAX_I(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','VELOCITY_ERROR_MAX_I',IZERO) 
ALLOCATE(VELOCITY_ERROR_MAX_J(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','VELOCITY_ERROR_MAX_J',IZERO) 
ALLOCATE(VELOCITY_ERROR_MAX_K(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','VELOCITY_ERROR_MAX_K',IZERO) 
VELOCITY_ERROR_MAX   = 0._EB
VELOCITY_ERROR_MAX_I = 0
VELOCITY_ERROR_MAX_J = 0
VELOCITY_ERROR_MAX_K = 0

IF (N_REACTIONS>0) THEN
   ALLOCATE(MAX_CHEM_SUBIT(NMESHES),STAT=IZERO)
   CALL ChkMemErr('INIT','MAX_CHEM_SUBIT',IZERO)
   MAX_CHEM_SUBIT=0
ENDIF

! Vegetation arrays

ALLOCATE(VEG_TOTAL_DRY_MASS(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','VEG_TOTAL_DRY_MASS',IZERO)  
VEG_TOTAL_DRY_MASS=0._EB
ALLOCATE(VEG_TOTAL_MOIST_MASS(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','VEG_TOTAL_MOIST_MASS',IZERO)  
VEG_TOTAL_MOIST_MASS=0._EB

 
END SUBROUTINE INITIALIZE_GLOBAL_VARIABLES
 
 

SUBROUTINE INIT_WALL_CELL(NM,I,J,K,I_OBST,IW,IOR,SURF_INDEX,IERR)

! Initialize wall cell variables at external and obstruction boundaries
 
USE MEMORY_FUNCTIONS, ONLY: ALLOCATE_STORAGE
USE GEOMETRY_FUNCTIONS, ONLY : SEARCH_OTHER_MESHES
INTEGER, INTENT(IN) :: I,J,K,NM,I_OBST,IW,IOR
INTEGER  :: NOM_FOUND,NOM=0,NOM_IB(6)=0,SURF_INDEX,ITER,IIO_MIN,IIO_MAX,JJO_MIN,JJO_MAX,KKO_MIN,KKO_MAX,I_VENT
INTEGER, INTENT(OUT) :: IERR
REAL(EB) :: PX,PY,PZ,X1,X2,Y1,Y2,Z1,Z2,T_ACTIVATE,XIN,YIN,ZIN,DIST,XW,YW,ZW,UW,RDN,AW
INTEGER  :: N,SURF_INDEXX,IIG,JJG,KKG,IIO,JJO,KKO,IC,ICG,NOM_CHECK(0:1),BOUNDARY_TYPE
INTEGER :: NSLICE
LOGICAL :: VENT_FOUND,ALIGNED
TYPE (MESH_TYPE), POINTER :: MM=>NULL()
TYPE (OBSTRUCTION_TYPE), POINTER :: OBX=>NULL()
TYPE (VENTS_TYPE), POINTER :: VT=>NULL()
TYPE (WALL_TYPE), POINTER :: WC=>NULL()
 
IERR = 0
M=>MESHES(NM)
WC => M%WALL(IW)

! Determine if a VENT covers the surface

I_VENT = 0
SURF_INDEXX   = SURF_INDEX
VENT_FOUND = .FALSE.

VENT_SEARCH_LOOP: DO N=1,M%N_VENT

   VT => M%VENTS(N)
   IF (I_OBST>0) THEN
      IF (VT%BOUNDARY_TYPE==OPEN_BOUNDARY)       CYCLE VENT_SEARCH_LOOP
      IF (.NOT.M%OBSTRUCTION(I_OBST)%ALLOW_VENT) CYCLE VENT_SEARCH_LOOP
   ENDIF
   IF (VT%IOR/=IOR) CYCLE VENT_SEARCH_LOOP

   IF (ABS(IOR)==1) THEN
      IF (IOR== 1 .AND. I/=VT%I1  ) CYCLE VENT_SEARCH_LOOP
      IF (IOR==-1 .AND. I/=VT%I1+1) CYCLE VENT_SEARCH_LOOP
      IF (J<VT%J1+1 .OR. J>VT%J2)   CYCLE VENT_SEARCH_LOOP
      IF (K<VT%K1+1 .OR. K>VT%K2)   CYCLE VENT_SEARCH_LOOP
   ENDIF
   IF (ABS(IOR)==2) THEN
      IF (IOR== 2 .AND. J/=VT%J1  ) CYCLE VENT_SEARCH_LOOP
      IF (IOR==-2 .AND. J/=VT%J1+1) CYCLE VENT_SEARCH_LOOP
      IF (I<VT%I1+1 .OR. I>VT%I2)   CYCLE VENT_SEARCH_LOOP
      IF (K<VT%K1+1 .OR. K>VT%K2)   CYCLE VENT_SEARCH_LOOP
   ENDIF
   IF (ABS(IOR)==3) THEN
      IF (IOR== 3 .AND. K/=VT%K1  ) CYCLE VENT_SEARCH_LOOP
      IF (IOR==-3 .AND. K/=VT%K1+1) CYCLE VENT_SEARCH_LOOP
      IF (I<VT%I1+1 .OR. I>VT%I2)   CYCLE VENT_SEARCH_LOOP
      IF (J<VT%J1+1 .OR. J>VT%J2)   CYCLE VENT_SEARCH_LOOP
   ENDIF

   ! Check if there are over-lapping VENTs

   IF (VENT_FOUND) THEN
      WRITE(LU_ERR,'(A,I0,A,3(I0,1X),A,I0,A)') 'WARNING: Two VENTs overlap in MESH ',NM,', Cell ',I,J,K,'. VENT ', &
                                           VT%ORDINAL,' rejected for that cell'
      EXIT VENT_SEARCH_LOOP
   ENDIF

   VENT_FOUND = .TRUE.

   ! Reassign the SURF index to be that of the VENT

   I_VENT = N
   SURF_INDEXX   = VT%SURF_INDEX

ENDDO VENT_SEARCH_LOOP

! Compute boundary cell physical coords (XW,YW,ZW) and area (AW)

IF (ABS(IOR)==1) THEN
   IF (IOR== 1) THEN
      XW     = M%X(I)
      IIG    = I+1
      RDN    = M%RDXN(I) 
      AW     = M%R(I)*M%DY(J)*M%DZ(K)
      UW     = -U0
   ENDIF
   IF (IOR==-1) THEN
      XW     = M%X(I-1)
      IIG    = I-1
      RDN    = M%RDXN(I-1) 
      AW     = M%R(I-1)*M%DY(J)*M%DZ(K)
      UW     = U0
   ENDIF
   JJG    = J
   KKG    = K   
   YW = M%YC(J)
   ZW = M%ZC(K)
ENDIF
IF (ABS(IOR)==2) THEN
   IF (IOR== 2) THEN
      YW     = M%Y(J)
      JJG    = J+1
      RDN    = M%RDYN(J) 
      UW     = -V0
   ENDIF
   IF (IOR==-2) THEN
      YW     = M%Y(J-1)
      JJG    = J-1
      RDN    = M%RDYN(J-1) 
      UW     = V0
   ENDIF
   IIG    = I
   KKG    = K   
   XW = M%XC(I)
   ZW = M%ZC(K)
   AW = M%DX(I)*M%DZ(K)
ENDIF
IF (ABS(IOR)==3) THEN
   IF (IOR== 3) THEN
      ZW     = M%Z(K)
      KKG    = K+1
      RDN    = M%RDZN(K) 
      UW     = -W0
   ENDIF
   IF (IOR==-3) THEN
      ZW     = M%Z(K-1)
      KKG    = K-1
      RDN    = M%RDZN(K-1) 
      UW     = W0
   ENDIF
   IIG    = I
   JJG    = J   
   XW = M%XC(I)
   YW = M%YC(J)
   AW = M%DX(I)*M%RC(I)*M%DY(J)
ENDIF
 
IF (IOR==0) THEN
   IIG = I
   JJG = J
   KKG = K
ENDIF

! Save the wall index

IC  = M%CELL_INDEX(I  ,J  ,K  )
ICG = M%CELL_INDEX(IIG,JJG,KKG)
M%WALL_INDEX(ICG,-IOR) = IW

! Use BOUNDARY_TYPE to indicate whether the boundary cell is blocked or on an obstruction that is HIDDEN

BOUNDARY_TYPE = NULL_BOUNDARY

IF (IW<=M%N_EXTERNAL_WALL_CELLS .AND. I_OBST==0) BOUNDARY_TYPE = SOLID_BOUNDARY

IF (I_OBST>0) THEN
   BOUNDARY_TYPE = SOLID_BOUNDARY
   IF (IW<=M%N_EXTERNAL_WALL_CELLS) M%SOLID(IC) = .TRUE.
ENDIF

IF (M%SOLID(ICG)) BOUNDARY_TYPE = NULL_BOUNDARY

! Check for neighboring meshes in a multiple mesh calculation

NOM_FOUND = 0
NOM_IB = 0
 
CHECK_MESHES: IF (IW<=M%N_EXTERNAL_WALL_CELLS .AND.  .NOT.EVACUATION_ONLY(NM)) THEN
 
   IIO_MIN =  1000000
   IIO_MAX = -1000000
   JJO_MIN =  1000000
   JJO_MAX = -1000000
   KKO_MIN =  1000000
   KKO_MAX = -1000000
   NOM_CHECK = 0
   DO ITER=0,1
      XIN = XW
      YIN = YW
      ZIN = ZW
      IF (SURF_INDEXX==PERIODIC_SURF_INDEX .AND. IOR== 1) XIN = XF_MAX
      IF (SURF_INDEXX==PERIODIC_SURF_INDEX .AND. IOR==-1) XIN = XS_MIN
      IF (SURF_INDEXX==PERIODIC_SURF_INDEX .AND. IOR== 2) YIN = YF_MAX
      IF (SURF_INDEXX==PERIODIC_SURF_INDEX .AND. IOR==-2) YIN = YS_MIN
      IF (SURF_INDEXX==PERIODIC_SURF_INDEX .AND. IOR== 3) ZIN = ZF_MAX
      IF (SURF_INDEXX==PERIODIC_SURF_INDEX .AND. IOR==-3) ZIN = ZS_MIN
      IF (ABS(IOR)/=1) XIN = XW + (ITER*0.95_EB-0.475_EB)*(M%X(I)-M%X(I-1))
      IF (ABS(IOR)/=2) YIN = YW + (ITER*0.95_EB-0.475_EB)*(M%Y(J)-M%Y(J-1))
      IF (ABS(IOR)/=3) ZIN = ZW + (ITER*0.95_EB-0.475_EB)*(M%Z(K)-M%Z(K-1))
      IF (IOR== 1) XIN = XIN - 0.05*M%DX(0)
      IF (IOR==-1) XIN = XIN + 0.05*M%DX(M%IBP1)
      IF (IOR== 2) YIN = YIN - 0.05*M%DY(0)
      IF (IOR==-2) YIN = YIN + 0.05*M%DY(M%JBP1)
      IF (IOR== 3) ZIN = ZIN - 0.05*M%DZ(0)
      IF (IOR==-3) ZIN = ZIN + 0.05*M%DZ(M%KBP1)
      CALL SEARCH_OTHER_MESHES(XIN,YIN,ZIN,NOM,IIO,JJO,KKO) 
      NOM_CHECK(ITER) = NOM
      IF (NOM/=0) THEN
         IIO_MIN = MIN(IIO_MIN,IIO)
         IIO_MAX = MAX(IIO_MAX,IIO)
         JJO_MIN = MIN(JJO_MIN,JJO)
         JJO_MAX = MAX(JJO_MAX,JJO)
         KKO_MIN = MIN(KKO_MIN,KKO)
         KKO_MAX = MAX(KKO_MAX,KKO)
      ENDIF
   ENDDO
  
   ! Check to see if the current interpolated cell face spans more than one other mesh

   IF (NOM_CHECK(0)/=NOM_CHECK(1)) THEN
      WRITE(LU_ERR,'(A,I3,A,I3)') 'ERROR: MESH ',NM,' is not in alignment with MESH ',MAXVAL(NOM_CHECK)
      PROCESS_STOP_STATUS = SETUP_STOP
      IERR = 1
      RETURN
   ENDIF

   FOUND_OTHER_MESH: IF (NOM>0) THEN 
      MM=>MESHES(NOM)
      ALIGNED = .TRUE.
      IF ( (ABS(IOR)==2 .OR. ABS(IOR)==3) .AND. MM%DX(IIO_MIN)<=M%DX(I) .AND. &
            ABS( ((MM%X(IIO_MAX)-MM%X(IIO_MIN-1))-M%DX(I)) / MM%DX(IIO_MIN))>0.01 ) ALIGNED = .FALSE.
      IF ( (ABS(IOR)==1 .OR. ABS(IOR)==3) .AND. MM%DY(JJO_MIN)<=M%DY(J) .AND. &
            ABS( ((MM%Y(JJO_MAX)-MM%Y(JJO_MIN-1))-M%DY(J)) / MM%DY(JJO_MIN))>0.01 ) ALIGNED = .FALSE.
      IF ( (ABS(IOR)==1 .OR. ABS(IOR)==2) .AND. MM%DZ(KKO_MIN)<=M%DZ(K) .AND. &
            ABS( ((MM%Z(KKO_MAX)-MM%Z(KKO_MIN-1))-M%DZ(K)) / MM%DZ(KKO_MIN))>0.01 ) ALIGNED = .FALSE.
      IF (.NOT.ALIGNED) THEN
         WRITE(LU_ERR,'(A,I3,A,I3)') 'ERROR: MESH ',NM,' is out of alignment with MESH ',NOM
         PROCESS_STOP_STATUS = SETUP_STOP
         IERR = 1
         RETURN
      ENDIF

      SELECT CASE(ABS(IOR))
         CASE(1)
            IF ( (M%DY(J)<0.99_EB*MM%DY(JJO_MIN)) .AND. (M%DZ(K)>1.01_EB*MM%DZ(KKO_MIN)) ) ALIGNED = .FALSE.
            IF ( (M%DY(J)>1.01_EB*MM%DY(JJO_MIN)) .AND. (M%DZ(K)<0.99_EB*MM%DZ(KKO_MIN)) ) ALIGNED = .FALSE.
         CASE(2)
            IF ( (M%DX(I)<0.99_EB*MM%DX(IIO_MIN)) .AND. (M%DZ(K)>1.01_EB*MM%DZ(KKO_MIN)) ) ALIGNED = .FALSE.
            IF ( (M%DX(I)>1.01_EB*MM%DX(IIO_MIN)) .AND. (M%DZ(K)<0.99_EB*MM%DZ(KKO_MIN)) ) ALIGNED = .FALSE.
         CASE(3)
            IF ( (M%DY(J)<0.99_EB*MM%DY(JJO_MIN)) .AND. (M%DX(I)>1.01_EB*MM%DX(IIO_MIN)) ) ALIGNED = .FALSE.
            IF ( (M%DY(J)>1.01_EB*MM%DY(JJO_MIN)) .AND. (M%DX(I)<0.99_EB*MM%DX(IIO_MIN)) ) ALIGNED = .FALSE.
      END SELECT
      IF (.NOT.ALIGNED) THEN
         WRITE(LU_ERR,'(A,I3,A,I3)') 'ERROR: MESH ',NM,' is finer in one direction and coarser in the other than MESH ',NOM
         PROCESS_STOP_STATUS = SETUP_STOP
         IERR = 1
         RETURN
      ENDIF

      NOM_FOUND = NOM
      NOM_IB(1) = IIO_MIN
      NOM_IB(2) = JJO_MIN
      NOM_IB(3) = KKO_MIN
      NOM_IB(4) = IIO_MAX
      NOM_IB(5) = JJO_MAX
      NOM_IB(6) = KKO_MAX
      
      IF (I_OBST==0) THEN
         IF (.NOT.M%SOLID(ICG)) BOUNDARY_TYPE = INTERPOLATED_BOUNDARY
         SURF_INDEXX = INTERPOLATED_SURF_INDEX
      ENDIF
      IF (BOUNDARY_TYPE == INTERPOLATED_BOUNDARY) M%SOLID(M%CELL_INDEX(I,J,K)) = .FALSE.
      I_VENT = 0

   ENDIF FOUND_OTHER_MESH
 
ENDIF CHECK_MESHES

! Initialize solid properties included in the WALL derived type variable

CALL ALLOCATE_STORAGE(NM,SURF_INDEXX,WALL_INDEX=IW)

! Initialize wall cell (WC) variables

WC%ONE_D%II = I
WC%ONE_D%JJ = J
WC%ONE_D%KK = K
WC%ONE_D%IOR = IOR
WC%SURF_INDEX = SURF_INDEXX
WC%OBST_INDEX = I_OBST
WC%BOUNDARY_TYPE = BOUNDARY_TYPE

WC%XW     = XW
WC%YW     = YW
WC%ZW     = ZW
WC%ONE_D%IIG    = IIG
WC%ONE_D%JJG    = JJG
WC%ONE_D%KKG    = KKG
WC%RDN    = RDN
WC%AW     = AW
IF (WC%AW>0._EB) WC%RAW = 1._EB/WC%AW
WC%ONE_D%UW     = UW

WC%NOM       = NOM_FOUND
WC%NOM_IB(:) = NOM_IB(:)

WC%RHO_F = RHOA
WC%U_TAU = 0._EB

ALLOCATE(WC%ZZ_F(N_TRACKED_SPECIES),STAT=IZERO)
CALL ChkMemErr('INIT','ZZ_F',IZERO)
WC%ZZ_F(1:N_TRACKED_SPECIES) = SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0

WC%EW = 0._EB
WC%KW = 0._EB

ALLOCATE(WC%RHODW(N_TRACKED_SPECIES),STAT=IZERO)
CALL ChkMemErr('INIT','RHODW',IZERO)
WC%RHODW = 0.1_EB ! Do not initialize to zero to avoid divide by zero in the first time step

WC%NPPCW = 1
WC%BACK_INDEX = 0
WC%VENT_INDEX = 0
WC%PRESSURE_BC_INDEX = NEUMANN

! Assign the ZONE number to all boundary cells

IF (.NOT.EVACUATION_ONLY(NM)) WC%PRESSURE_ZONE_WALL = M%PRESSURE_ZONE(IIG,JJG,KKG)

! Fill array containing K index of terrain following slice, used in dump slice

DO NSLICE = 1, M%N_TERRAIN_SLCF
   IF (IOR==3) M%K_AGL_SLICE(I,J,NSLICE) = M%K_AGL_SLICE(I,J,NSLICE) + WC%ONE_D%KKG
ENDDO

! Fill arrays containing K index and physical height of terrain for use in level set firespread
IF (VEG_LEVEL_SET .AND. IOR==3) THEN
  M%LS_Z_TERRAIN(WC%ONE_D%IIG,WC%ONE_D%JJG) = M%Z(WC%ONE_D%KKG-1)
ENDIF

! Surface soot array

IF (N_SURFACE_DENSITY_SPECIES > 0 .AND. .NOT.EVACUATION_ONLY(NM)) THEN
   ALLOCATE(WC%AWM_AEROSOL(N_SURFACE_DENSITY_SPECIES),STAT=IZERO)
   CALL ChkMemErr('INIT','WALL(IW)%AWM_AEROSOL',IZERO)
   WC%AWM_AEROSOL = 0._EB
ENDIF

! Surface water arrays

IF (ACCUMULATE_WATER .AND. .NOT.EVACUATION_ONLY(NM)) THEN
   ALLOCATE(WC%A_LP_MPUA(N_LP_ARRAY_INDICES),STAT=IZERO)
   CALL ChkMemErr('INIT','A_LP_MPUA',IZERO)
   WC%A_LP_MPUA = 0._EB
ENDIF

ALLOCATE(WC%LP_MPUA(N_LP_ARRAY_INDICES),STAT=IZERO)
CALL ChkMemErr('INIT','LP_MPUA',IZERO)
WC%LP_MPUA = 0._EB
ALLOCATE(WC%LP_CPUA(N_LP_ARRAY_INDICES),STAT=IZERO)
CALL ChkMemErr('INIT','WALL(IW)%LP_CPUA',IZERO)
WC%LP_CPUA = 0._EB

! Do not assign normal velocities at boundaries of evacuation meshes

IF (EVACUATION_ONLY(NM)) WC%ONE_D%UW = 0._EB

! Assign internal values of temp, density, and mass fraction
 
IF (N_TRACKED_SPECIES>0 .AND. .NOT.EVACUATION_ONLY(NM) .AND. (M%SOLID(M%CELL_INDEX(I,J,K)).OR.IW<=M%N_EXTERNAL_WALL_CELLS)) THEN
   M%RSUM(I,J,K) = M%RSUM(IIG,JJG,KKG)
   WC%ZZ_F(1:N_TRACKED_SPECIES)  = M%ZZ(IIG,JJG,KKG,1:N_TRACKED_SPECIES)
   M%ZZ(I,J,K,1:N_TRACKED_SPECIES) = M%ZZ(IIG,JJG,KKG,1:N_TRACKED_SPECIES)
ENDIF
 
WC%RHO_F = M%RHO(IIG,JJG,KKG)
 
! Assign various other quantities to the cell
 
IF (I_OBST>0 .AND. .NOT.EVACUATION_ONLY(NM)) THEN
   OBX=>M%OBSTRUCTION(I_OBST)
   WC%ONE_D%AREA_ADJUST = OBX%INPUT_AREA(ABS(IOR))/OBX%FDS_AREA(ABS(IOR))
   IF (WC%ONE_D%AREA_ADJUST<=ZERO_P) WC%ONE_D%AREA_ADJUST = 1._EB
   OBX%MASS = SURFACE(SURF_INDEX)%SURFACE_DENSITY*WC%AW*WC%ONE_D%AREA_ADJUST
   IF (OBX%BULK_DENSITY>0._EB) OBX%MASS = OBX%BULK_DENSITY*(OBX%X2-OBX%X1)*(OBX%Y2-OBX%Y1)*(OBX%Z2-OBX%Z1)/OBX%VOLUME_ADJUST
ENDIF
 
! Prescribe exit velocity for surface cell
 
WC%UW0 = SURFACE(SURF_INDEXX)%VEL

IF (I_OBST>0 .AND. ABS(SURFACE(SURF_INDEXX)%VOLUME_FLUX)>=ZERO_P .AND. .NOT.EVACUATION_ONLY(NM)) THEN
   OBX=>M%OBSTRUCTION(I_OBST)
   WC%UW0 = SURFACE(SURF_INDEXX)%VOLUME_FLUX/OBX%FDS_AREA(ABS(IOR))
ENDIF
IF (I_OBST>0 .AND. ABS(SURFACE(SURF_INDEXX)%MASS_FLUX_TOTAL)>=ZERO_P .AND. .NOT.EVACUATION_ONLY(NM)) THEN
   OBX=>M%OBSTRUCTION(I_OBST)
   WC%UW0 = SURFACE(SURF_INDEXX)%MASS_FLUX_TOTAL / RHOA * WC%ONE_D%AREA_ADJUST
ENDIF
 
T_ACTIVATE = T_BEGIN-1._EB
 
! Do VENT-specific set-ups
 
PROCESS_VENT: IF (I_VENT>0) THEN
 
   VT => M%VENTS(I_VENT)

   WC%VENT_INDEX = I_VENT
   IF (.NOT.EVACUATION_ONLY(NM)) THEN
   WC%ONE_D%AREA_ADJUST = VT%INPUT_AREA/VT%FDS_AREA
   IF (WC%ONE_D%AREA_ADJUST<=ZERO_P) WC%ONE_D%AREA_ADJUST = 1._EB
   ENDIF
 
   ! Set the velocity at each surface cell
 
   WC%UW0 = SURFACE(SURF_INDEXX)%VEL
 
   IF (ABS(SURFACE(SURF_INDEXX)%VOLUME_FLUX)    >=ZERO_P)   THEN
      WC%UW0 = SURFACE(SURF_INDEXX)%VOLUME_FLUX/VT%FDS_AREA
   ENDIF
   IF (ABS(SURFACE(SURF_INDEXX)%MASS_FLUX_TOTAL)>=ZERO_P .AND. .NOT.EVACUATION_ONLY(NM)) THEN
      WC%UW0 = SURFACE(SURF_INDEXX)%MASS_FLUX_TOTAL/RHOA*WC%ONE_D%AREA_ADJUST
   ENDIF
 
   ! Special velocity profiles
 
   IF (SURFACE(SURF_INDEXX)%PROFILE==PARABOLIC) THEN 
      SELECT CASE(ABS(IOR))
         CASE(1)
            Y1 = M%Y(VT%J1)
            Y2 = M%Y(VT%J2)
            Z1 = M%Z(VT%K1)
            Z2 = M%Z(VT%K2)
            PY = 4._EB*(M%YC(J)-Y1)*(Y2-M%YC(J))/(Y2-Y1)**2
            PZ = 4._EB*(M%ZC(K)-Z1)*(Z2-M%ZC(K))/(Z2-Z1)**2
            WC%UW0 = WC%UW0*PY*PZ
         CASE(2)
            X1 = M%X(VT%I1)
            X2 = M%X(VT%I2)
            Z1 = M%Z(VT%K1)
            Z2 = M%Z(VT%K2)
            PX = 4._EB*(M%XC(I)-X1)*(X2-M%XC(I))/(X2-X1)**2
            PZ = 4._EB*(M%ZC(K)-Z1)*(Z2-M%ZC(K))/(Z2-Z1)**2
            WC%UW0 = WC%UW0*PX*PZ
         CASE(3)
            X1 = M%X(VT%I1)
            X2 = M%X(VT%I2)
            IF (CYLINDRICAL .AND. ABS(X1)<=ZERO_P) X1 = -X2
            Y1 = M%Y(VT%J1)
            Y2 = M%Y(VT%J2)
            PX = 4._EB*(M%XC(I)-X1)*(X2-M%XC(I))/(X2-X1)**2
            PY = 4._EB*(M%YC(J)-Y1)*(Y2-M%YC(J))/(Y2-Y1)**2
            IF (CYLINDRICAL) THEN
               WC%UW0 = WC%UW0*PX
            ELSE
               WC%UW0 = WC%UW0*PX*PY
            ENDIF
      END SELECT
   ENDIF
 
   IF (SURFACE(SURF_INDEXX)%PROFILE==ATMOSPHERIC) THEN
      IF (M%ZC(K)<GROUND_LEVEL) THEN
         WRITE(LU_ERR,'(A,A,A)') 'ERROR: SURF ',TRIM(SURFACE(SURF_INDEXX)%ID),' cannot be applied below GROUND_LEVEL'
         PROCESS_STOP_STATUS = SETUP_STOP
         IERR = 1
         RETURN
      ENDIF
      WC%UW0 =  WC%UW0*((M%ZC(K)-GROUND_LEVEL)/SURFACE(SURF_INDEXX)%Z0)**SURFACE(SURF_INDEXX)%PLE
   ENDIF
 
   IF (SURFACE(SURF_INDEXX)%PROFILE==ONED_PARABOLIC) THEN 
      SELECT CASE(ABS(IOR))
         CASE(1)
            Y1 = M%Y(VT%J1)
            Y2 = M%Y(VT%J2)
            PY = 4._EB*(M%YC(J)-Y1)*(Y2-M%YC(J))/(Y2-Y1)**2
            WC%UW0 =  WC%UW0*PY
         CASE(2)
            X1 = M%X(VT%I1)
            X2 = M%X(VT%I2)
            PX = 4._EB*(M%XC(I)-X1)*(X2-M%XC(I))/(X2-X1)**2
            WC%UW0 =  WC%UW0*PX
         CASE(3)
            X1 = M%X(VT%I1)
            X2 = M%X(VT%I2)
            Y1 = M%Y(VT%J1)
            Y2 = M%Y(VT%J2)
            PX = 4._EB*(M%XC(I)-X1)*(X2-M%XC(I))/(X2-X1)**2
            PY = 4._EB*(M%YC(J)-Y1)*(Y2-M%YC(J))/(Y2-Y1)**2
            WC%UW0 =  WC%UW0*PX*PY
      END SELECT
   ENDIF
 
   ! Check if fire spreads radially over this vent
 
   IF (VT%X0>-1.E5_EB) THEN
      DIST = SQRT((WC%XW-VT%X0)**2 +(WC%YW-VT%Y0)**2 +(WC%ZW-VT%Z0)**2)
      T_ACTIVATE = T_BEGIN + DIST/VT%FIRE_SPREAD_RATE
   ENDIF

   ! Miscellaneous settings
 
   IF (VT%BOUNDARY_TYPE==OPEN_BOUNDARY   .AND. .NOT.M%SOLID(ICG)) WC%BOUNDARY_TYPE = OPEN_BOUNDARY
   IF (VT%BOUNDARY_TYPE==MIRROR_BOUNDARY .AND. .NOT.M%SOLID(ICG)) WC%BOUNDARY_TYPE = MIRROR_BOUNDARY

ENDIF PROCESS_VENT

! Assign the SURFace type for the boundary cell

SF => SURFACE(SURF_INDEXX)
 
! Check if fire spreads radially over this surface type

IF (SF%XYZ(1)>-1.E5_EB) THEN
   DIST = SQRT((WC%XW-SF%XYZ(1))**2 +(WC%YW-SF%XYZ(2))**2 +(WC%ZW-SF%XYZ(3))**2)
   T_ACTIVATE = T_BEGIN + DIST/SF%FIRE_SPREAD_RATE
ENDIF

! Set ignition time of each boundary cell
 
IF (T_ACTIVATE < T_BEGIN) THEN
   WC%ONE_D%T = SF%T_IGN
ELSE
   WC%ONE_D%T = T_ACTIVATE
ENDIF
 
! Miscellaneous initializations

IF (.NOT.EVACUATION_ONLY(NM)) WC%NPPCW  = SF%NPPC      ! Number of particles per cell

! Allocate vegetation arrays

IF (SF%VEGETATION .AND. .NOT.EVACUATION_ONLY(NM)) THEN

   ALLOCATE(WC%VEG_FUELMASS_L(SF%NVEG_L),STAT=IZERO)
   CALL ChkMemErr('FUNC','VEG_FUELMASS_L',IZERO)
   ALLOCATE(WC%VEG_MOISTMASS_L(SF%NVEG_L),STAT=IZERO)
   CALL ChkMemErr('FUNC','VEG_MOISTMASS_L',IZERO)
   ALLOCATE(WC%VEG_TMP_L(0:SF%NVEG_L),STAT=IZERO)
   CALL ChkMemErr('FUNC','VEG_TMP_L',IZERO)

   WC%VEG_FUELMASS_L(:)  = SF%VEG_LOAD / SF%NVEG_L
   WC%VEG_MOISTMASS_L(:) = SF%VEG_MOISTURE*WC%VEG_FUELMASS_L(:)
   WC%VEG_TMP_L(:)       = SF%VEG_INITIAL_TEMP + 273.15_EB
   WC%ONE_D%TMP_F        = SF%VEG_INITIAL_TEMP + 273.15_EB
   IF(SF%VEG_NO_BURN) WC%ONE_D%TMP_F = TMPA

ENDIF

! Record original boundary condition index for exterior wall cells that might get covered up

IF (I_OBST==0) WC%SURF_INDEX_ORIG = SURF_INDEXX

WC%ALREADY_ALLOCATED = .TRUE.

END SUBROUTINE INIT_WALL_CELL
 
 
SUBROUTINE OPEN_AND_CLOSE(T,NM)

! Check to see if a cell or OBSTruction is to be created or removed, or a VENT activated of deactivated

USE MEMORY_FUNCTIONS, ONLY : RE_ALLOCATE_STRINGS
USE CONTROL_VARIABLES, ONLY : CONTROL
USE DEVICE_VARIABLES, ONLY : DEVICE
USE EVAC, ONLY: EVAC_FDS6
REAL(EB), INTENT(IN) :: T
REAL(EB) :: T_TMP
INTEGER  :: N,II,JJ,KK,IW,IC
INTEGER, INTENT(IN) :: NM
LOGICAL :: CREATE_OBST,REMOVE_OBST,ACTIVATE_VENT,DEACTIVATE_VENT
CHARACTER(12) :: SV_LABEL
TYPE (VENTS_TYPE), POINTER :: VT

CALL POINT_TO_MESH(NM)

T_TMP = T

! Check to see if an obstacle is to be removed or created

OBST_LOOP: DO N=1,N_OBST

   OB=>OBSTRUCTION(N)
   IF (.NOT. OB%REMOVABLE) CYCLE OBST_LOOP
   CREATE_OBST = .FALSE.
   REMOVE_OBST = .FALSE.

   ! Over-ride DEVICE/CONTROL logic

   IF (OB%CONSUMABLE .AND. OB%MASS <= 0._EB) REMOVE_OBST = .TRUE.
   IF (OB%HIDDEN .AND. T<=T_BEGIN) THEN
      REMOVE_OBST = .TRUE.
      OB%HIDDEN = .FALSE.   ! The obstruction will not be removed if FDS thinks it is already HIDDEN
   ENDIF

   ! Decide if a DEVICE/CONTROL action is needed

   IF (.NOT.CREATE_OBST .AND. .NOT.REMOVE_OBST) THEN
      IF (OB%DEVC_INDEX > 0) THEN
         IF (DEVICE(OB%DEVC_INDEX)%CURRENT_STATE .EQV. DEVICE(OB%DEVC_INDEX)%PRIOR_STATE) CYCLE OBST_LOOP
         IF (DEVICE(OB%DEVC_INDEX)%CURRENT_STATE) THEN
            IF (.NOT.OB%HOLE_FILLER) CREATE_OBST = .TRUE.
            IF (     OB%HOLE_FILLER) REMOVE_OBST = .TRUE.
         ELSE
            IF (.NOT.OB%HOLE_FILLER) REMOVE_OBST = .TRUE.      
            IF (     OB%HOLE_FILLER) CREATE_OBST = .TRUE.      
         ENDIF
      ELSEIF (OB%CTRL_INDEX > 0) THEN
         IF (CONTROL(OB%CTRL_INDEX)%CURRENT_STATE .EQV. CONTROL(OB%CTRL_INDEX)%PRIOR_STATE) CYCLE OBST_LOOP
         IF (CONTROL(OB%CTRL_INDEX)%CURRENT_STATE) THEN
            IF (.NOT.OB%HOLE_FILLER) CREATE_OBST = .TRUE.
            IF (     OB%HOLE_FILLER) REMOVE_OBST = .TRUE.
         ELSE
            IF (.NOT.OB%HOLE_FILLER) REMOVE_OBST = .TRUE.      
            IF (     OB%HOLE_FILLER) CREATE_OBST = .TRUE.      
         ENDIF
      ENDIF
   ENDIF

   SV_LABEL  = 'null'

   IF (CREATE_OBST .AND. OB%HIDDEN) THEN
      OB%HIDDEN = .FALSE.
      SV_LABEL  = 'SHOW_OBST'
      CALL CREATE_OR_REMOVE_OBST(NM,OB%I1,OB%I2,OB%J1,OB%J2,OB%K1,OB%K2,1,N,T)
   ENDIF

   IF (REMOVE_OBST .AND. (.NOT. OB%HIDDEN)) THEN
      OB%HIDDEN = .TRUE.
      SV_LABEL  = 'HIDE_OBST'
      CALL CREATE_OR_REMOVE_OBST(NM,OB%I1,OB%I2,OB%J1,OB%J2,OB%K1,OB%K2,0,N,T)
   ENDIF

   ! The evacuation flow field calculation is done before T_BEGIN

   IF (OB%DEVC_INDEX>0) THEN
      IF (EVACUATION_GRID(NM) .AND. DEVICE(OB%DEVC_INDEX)%QUANTITY=='TIME' .AND. DEVICE(OB%DEVC_INDEX)%SETPOINT<=T_BEGIN) &
         T_TMP = T - EVAC_DT_FLOWFIELD*EVAC_TIME_ITERATIONS
   ENDIF

   ! Write a message to the Smokeview .smv file that the obstruction has been created or removed

   IF (SV_LABEL /= 'null') THEN
      IF (N_STRINGS+2>N_STRINGS_MAX) THEN
         CALL RE_ALLOCATE_STRINGS(NM)
         STRING => MESHES(NM)%STRING
      ENDIF
      N_STRINGS = N_STRINGS + 1
      WRITE(STRING(N_STRINGS),'(A,I3)') SV_LABEL,NM
      N_STRINGS = N_STRINGS + 1
      WRITE(STRING(N_STRINGS),'(I6,F10.2)') N,T_TMP
   ENDIF

ENDDO OBST_LOOP
 
! Check to see if a vent should be activated or deactivated
 
VENT_LOOP: DO N=1,N_VENT
   VT => VENTS(N)

   ACTIVATE_VENT   = .FALSE.
   DEACTIVATE_VENT = .FALSE.

   ! Over-ride DEVICE/CONTROL logic

   IF (.NOT.VT%ACTIVATED .AND. T<=T_BEGIN) DEACTIVATE_VENT = .TRUE.

   ! Decide if a VENT is to activate or de-activate based on a DEVICE or CONTROLLER

   IF (.NOT.ACTIVATE_VENT .AND. .NOT.DEACTIVATE_VENT) THEN
      IF (VT%DEVC_INDEX > 0) THEN
         IF (DEVICE(VT%DEVC_INDEX)%CURRENT_STATE .EQV. DEVICE(VT%DEVC_INDEX)%PRIOR_STATE) CYCLE VENT_LOOP
         IF (DEVICE(VT%DEVC_INDEX)%CURRENT_STATE) THEN
            ACTIVATE_VENT   = .TRUE.
         ELSE
            DEACTIVATE_VENT = .TRUE.
         ENDIF
      ELSEIF (VT%CTRL_INDEX > 0) THEN
         IF (CONTROL(VT%CTRL_INDEX)%CURRENT_STATE .EQV. CONTROL(VT%CTRL_INDEX)%PRIOR_STATE) CYCLE VENT_LOOP
         IF (CONTROL(VT%CTRL_INDEX)%CURRENT_STATE) THEN
            ACTIVATE_VENT   = .TRUE.
         ELSE
            DEACTIVATE_VENT = .TRUE.
         ENDIF
      ENDIF
   ENDIF

   IF (.NOT.ACTIVATE_VENT .AND. .NOT.DEACTIVATE_VENT) CYCLE VENT_LOOP

   ! Find the wall indices (IW) for the vent and set the activation time (TW) for each one

   DO KK=VT%K1+1,MAX(VT%K1+1,VT%K2)
      DO JJ=VT%J1+1,MAX(VT%J1+1,VT%J2)
         DO II=VT%I1+1,MAX(VT%I1+1,VT%I2)
            SELECT CASE(VT%IOR)
               CASE(1:)
                  IC = CELL_INDEX(II,JJ,KK)
               CASE(-1)
                  IC = CELL_INDEX(II-1,JJ,KK)
               CASE(-2)
                  IC = CELL_INDEX(II,JJ-1,KK)
               CASE(-3)
                  IC = CELL_INDEX(II,JJ,KK-1)
            END SELECT
            IW = WALL_INDEX(IC,-VT%IOR)
            IF (IW==0) CYCLE

            IF (ACTIVATE_VENT) THEN
               IF (VT%X0>-1.E5_EB) THEN
                  WALL(IW)%ONE_D%T = T + SQRT((WALL(IW)%XW-VT%X0)**2 +(WALL(IW)%YW-VT%Y0)**2 +&
                                              (WALL(IW)%ZW-VT%Z0)**2)/VT%FIRE_SPREAD_RATE
               ELSE
                  WALL(IW)%ONE_D%T = T        
               ENDIF
            ELSE
               WALL(IW)%ONE_D%T = 1000000._EB
            ENDIF
         ENDDO
      ENDDO
   ENDDO

   ! Write message to .smv file

   IF (ACTIVATE_VENT)   SV_LABEL = 'OPEN_VENT'
   IF (DEACTIVATE_VENT) SV_LABEL = 'CLOSE_VENT'

   IF (N_STRINGS+2>N_STRINGS_MAX) THEN
      CALL RE_ALLOCATE_STRINGS(NM)
      STRING => MESHES(NM)%STRING
   ENDIF
   N_STRINGS = N_STRINGS + 1
   WRITE(STRING(N_STRINGS),'(A,I3)') SV_LABEL,NM
   N_STRINGS = N_STRINGS + 1
   WRITE(STRING(N_STRINGS),'(I6,F10.2)') N,T

ENDDO VENT_LOOP
 
END SUBROUTINE OPEN_AND_CLOSE
 

 
SUBROUTINE CREATE_OR_REMOVE_OBST(NM,I1,I2,J1,J2,K1,K2,CR_INDEX,OBST_INDEX,T)

! Create or remove the obstruction whose NODES (not cells) are given by I1, I2, etc.

USE GEOMETRY_FUNCTIONS, ONLY : BLOCK_CELL
INTEGER :: I1,I2,J1,J2,K1,K2,I,J,K,IW,ICG,IC
INTEGER, INTENT(IN) :: NM,CR_INDEX,OBST_INDEX
REAL(EB) :: T
LOGICAL :: CREATE,REMOVE
 
CALL POINT_TO_MESH(NM)

REMOVE = .FALSE.
CREATE = .FALSE.
IF (CR_INDEX==0) REMOVE = .TRUE.
IF (CR_INDEX==1) CREATE = .TRUE.
 
! Blank or unblank cells that make up the OBSTruction
 
CALL BLOCK_CELL(NM,I1+1,I2,J1+1,J2,K1+1,K2,CR_INDEX,OBST_INDEX)
 
! If the OBSTruction is to be removed, set density and mass fractions to ambient value

IF (REMOVE) THEN
   DO K=K1+1,K2
      DO J=J1+1,J2
         DO I=I1+1,I2
            RHOS(I,J,K) = RHOA
            RHO(I,J,K)  = RHOA
            IF (N_TRACKED_SPECIES>0) THEN
               ZZ(I,J,K,1:N_TRACKED_SPECIES)  = SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
               ZZS(I,J,K,1:N_TRACKED_SPECIES) = SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
            ENDIF
         ENDDO
      ENDDO
   ENDDO
ENDIF

! Process the x boundaries of the OBSTruction

DO K=K1+1,K2
   DO J=J1+1,J2
      IC  = CELL_INDEX(I1+1,J,K)
      ICG = CELL_INDEX(I1  ,J,K)
      IW  = WALL_INDEX(ICG,1)
      IF (I1>0)    CALL GET_BOUNDARY_TYPE
      IC  = CELL_INDEX(I1  ,J,K)
      ICG = CELL_INDEX(I1+1,J,K)
      IW  = WALL_INDEX(ICG,-1)
      IF (I1<IBAR) CALL GET_BOUNDARY_TYPE
      IC  = CELL_INDEX(I2  ,J,K)
      ICG = CELL_INDEX(I2+1,J,K)
      IW  = WALL_INDEX(ICG,-1)
      IF (I2<IBAR) CALL GET_BOUNDARY_TYPE
      IC  = CELL_INDEX(I2+1,J,K)
      ICG = CELL_INDEX(I2  ,J,K)
      IW  = WALL_INDEX(ICG, 1)
      IF (I2>0)    CALL GET_BOUNDARY_TYPE
   ENDDO
ENDDO

! Process the y boundaries of the OBSTruction

DO K=K1+1,K2
   DO I=I1+1,I2
      IC  = CELL_INDEX(I,J1+1,K)
      ICG = CELL_INDEX(I,J1  ,K)
      IW  = WALL_INDEX(ICG, 2)
      IF (J1>0)    CALL GET_BOUNDARY_TYPE
      IC  = CELL_INDEX(I,J1  ,K)
      ICG = CELL_INDEX(I,J1+1,K)
      IW  = WALL_INDEX(ICG,-2)
      IF (J1<JBAR) CALL GET_BOUNDARY_TYPE
      IC  = CELL_INDEX(I,J2  ,K)
      ICG = CELL_INDEX(I,J2+1,K)
      IW  = WALL_INDEX(ICG,-2)
      IF (J2<JBAR) CALL GET_BOUNDARY_TYPE
      IC  = CELL_INDEX(I,J2+1,K)
      ICG = CELL_INDEX(I,J2  ,K)
      IW  = WALL_INDEX(ICG, 2)
      IF (J2>0)    CALL GET_BOUNDARY_TYPE
   ENDDO
ENDDO

! Process the z boundaries of the OBSTruction

DO J=J1+1,J2
   DO I=I1+1,I2
      IC  = CELL_INDEX(I,J,K1+1)
      ICG = CELL_INDEX(I,J,K1  )
      IW  = WALL_INDEX(ICG, 3)
      IF (K1>0)    CALL GET_BOUNDARY_TYPE
      IC  = CELL_INDEX(I,J,K1  )
      ICG = CELL_INDEX(I,J,K1+1)
      IW  = WALL_INDEX(ICG,-3)
      IF (K1<KBAR) CALL GET_BOUNDARY_TYPE
      IC  = CELL_INDEX(I,J,K2  )
      ICG = CELL_INDEX(I,J,K2+1)
      IW  = WALL_INDEX(ICG,-3)
      IF (K2<KBAR) CALL GET_BOUNDARY_TYPE
      IC  = CELL_INDEX(I,J,K2+1)
      ICG = CELL_INDEX(I,J,K2  )
      IW  = WALL_INDEX(ICG, 3)
      IF (K2>0)    CALL GET_BOUNDARY_TYPE
   ENDDO
ENDDO


! Nullify block edges on blockage that is to be removed
 
DO K=K1,K2
   DO J=J1,J2
      IF (J>J1) CALL REDEFINE_EDGE(I1,J,K,2)
      IF (J>J1) CALL REDEFINE_EDGE(I2,J,K,2)
      IF (K>K1) CALL REDEFINE_EDGE(I1,J,K,3)
      IF (K>K1) CALL REDEFINE_EDGE(I2,J,K,3)
   ENDDO
ENDDO

DO K=K1,K2
   DO I=I1,I2
      IF (I>I1) CALL REDEFINE_EDGE(I,J1,K,1)
      IF (I>I1) CALL REDEFINE_EDGE(I,J2,K,1)
      IF (K>K1) CALL REDEFINE_EDGE(I,J1,K,3)
      IF (K>K1) CALL REDEFINE_EDGE(I,J2,K,3)
   ENDDO
ENDDO

DO J=J1,J2
   DO I=I1,I2
      IF (I>I1) CALL REDEFINE_EDGE(I,J,K1,1)
      IF (I>I1) CALL REDEFINE_EDGE(I,J,K2,1)
      IF (J>J1) CALL REDEFINE_EDGE(I,J,K1,2)
      IF (J>J1) CALL REDEFINE_EDGE(I,J,K2,2)
   ENDDO
ENDDO

CONTAINS

SUBROUTINE GET_BOUNDARY_TYPE

USE MEMORY_FUNCTIONS, ONLY: ALLOCATE_STORAGE
INTEGER :: I_OBST,SURF_INDEX,IOR,IIG,JJG,KKG,IW_OLD

IF (IW==0) RETURN

SURF_INDEX = WALL(IW)%SURF_INDEX

IF (IW<=N_EXTERNAL_WALL_CELLS .AND. REMOVE) THEN
   WALL(IW)%BOUNDARY_TYPE = SOLID_BOUNDARY
   IF (WALL(IW)%SURF_INDEX_ORIG==MIRROR_SURF_INDEX) THEN
      WALL(IW)%BOUNDARY_TYPE = MIRROR_BOUNDARY
      WALL(IW)%SURF_INDEX = WALL(IW)%SURF_INDEX_ORIG
   ENDIF
   IF (WALL(IW)%SURF_INDEX_ORIG==OPEN_SURF_INDEX) THEN
      WALL(IW)%BOUNDARY_TYPE = OPEN_BOUNDARY
      WALL(IW)%SURF_INDEX = WALL(IW)%SURF_INDEX_ORIG
   ENDIF
   IF (WALL(IW)%SURF_INDEX_ORIG==INTERPOLATED_SURF_INDEX) THEN
      WALL(IW)%BOUNDARY_TYPE = INTERPOLATED_BOUNDARY
      WALL(IW)%SURF_INDEX = WALL(IW)%SURF_INDEX_ORIG
   ENDIF
ENDIF

IF (IW>N_EXTERNAL_WALL_CELLS) THEN
   I_OBST = WALL(IW)%OBST_INDEX
   IF (I_OBST>0 .AND.      OBSTRUCTION(I_OBST)%HIDDEN .AND. .NOT.SOLID(IC) ) WALL(IW)%BOUNDARY_TYPE = NULL_BOUNDARY
   IF (I_OBST>0 .AND. .NOT.OBSTRUCTION(I_OBST)%HIDDEN .AND. .NOT.SOLID(ICG)) WALL(IW)%BOUNDARY_TYPE = SOLID_BOUNDARY
   IF (     SOLID(ICG)) WALL(IW)%BOUNDARY_TYPE = NULL_BOUNDARY
ENDIF

IF (CREATE) THEN
   IF (SOLID(ICG)) THEN
      WALL(IW)%BOUNDARY_TYPE = NULL_BOUNDARY
   ELSE
      WALL(IW)%BOUNDARY_TYPE = SOLID_BOUNDARY
      IF (WALL(IW)%ONE_D%T<T) WALL(IW)%ONE_D%T = T
   ENDIF
ENDIF

! Make the ghost cell either solid or not depending on the boundary type

IF (IW<=N_EXTERNAL_WALL_CELLS .AND. &
   (WALL(IW)%BOUNDARY_TYPE==OPEN_BOUNDARY .OR. WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY)) SOLID(IC) = .FALSE.
IF (IW<=N_EXTERNAL_WALL_CELLS .AND. &
   (WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY .OR. WALL(IW)%BOUNDARY_TYPE==SOLID_BOUNDARY))        SOLID(IC) = .TRUE.

! Initialize solid properties included in the WALL derived type variable
 
!!! CALL ALLOCATE_STORAGE(NM,SURF_INDEX,WALL_INDEX=IW)

! Inherit ignition time from BURNed_AWAY obstruction

IF (REMOVE .AND. SURFACE(SURF_INDEX)%PYROLYSIS_MODEL==PYROLYSIS_SPECIFIED) THEN
   IIG = WALL(IW)%ONE_D%IIG
   JJG = WALL(IW)%ONE_D%JJG
   KKG = WALL(IW)%ONE_D%KKG
   IOR = WALL(IW)%ONE_D%IOR
   IW_OLD = 0
   IC     = 0
   SELECT CASE(IOR)
      CASE(-1)
         IF (IIG>1)    IC = CELL_INDEX(IIG-1,JJG,KKG)
      CASE( 1)
         IF (IIG<IBAR) IC = CELL_INDEX(IIG+1,JJG,KKG)
      CASE(-2)
         IF (JJG>1)    IC = CELL_INDEX(IIG,JJG-1,KKG)
      CASE( 2)
         IF (JJG<JBAR) IC = CELL_INDEX(IIG,JJG+1,KKG)
      CASE(-3)
         IF (KKG>1)    IC = CELL_INDEX(IIG,JJG,KKG-1)
      CASE( 3)
         IF (KKG<KBAR) IC = CELL_INDEX(IIG,JJG,KKG+1)
   END SELECT
   IW_OLD = WALL_INDEX(IC,-IOR)
   IF (IW_OLD>0) THEN
      IF (SURF_INDEX==WALL(IW)%SURF_INDEX) WALL(IW)%ONE_D%T =  WALL(IW_OLD)%ONE_D%T
   ENDIF
ENDIF

END SUBROUTINE GET_BOUNDARY_TYPE

SUBROUTINE REDEFINE_EDGE(II,JJ,KK,IEC)

! Change a few properties of the EDGEs that have been exposed or covered up by a blockage

INTEGER :: IE,II,JJ,KK,IEC

SELECT CASE(IEC)
   CASE(1)
      IE = EDGE_INDEX(CELL_INDEX(II,JJ,KK), 4)
   CASE(2)
      IE = EDGE_INDEX(CELL_INDEX(II,JJ,KK), 8)
   CASE(3)
      IE = EDGE_INDEX(CELL_INDEX(II,JJ,KK),12)
END SELECT

IF (IE>0) THEN
   IF (REMOVE .AND. IJKE( 9,IE)/=0) EDGE_TYPE(IE,1) = INTERPOLATED_EDGE
   IF (REMOVE .AND. IJKE(13,IE)/=0) EDGE_TYPE(IE,2) = INTERPOLATED_EDGE
   IF (CREATE .AND. IJKE( 9,IE)/=0) EDGE_TYPE(IE,1) = SOLID_EDGE
   IF (CREATE .AND. IJKE(13,IE)/=0) EDGE_TYPE(IE,2) = SOLID_EDGE
ENDIF

END SUBROUTINE REDEFINE_EDGE

END SUBROUTINE CREATE_OR_REMOVE_OBST


SUBROUTINE DEFINE_EDGE(II,JJ,KK,IOR,IEC,NM,I_OBST,IERR)
 
! Set up edge arrays for velocity boundary conditions
 
INTEGER, INTENT(IN) :: II,JJ,KK,IOR,IEC,NM
INTEGER :: NOM,ICMM,ICMP,ICPM,ICPP,I_OBST,IE,IW,IIO,JJO,KKO,IW1,IW2,IERR
REAL(EB) :: XI,YJ,ZK
TYPE (MESH_TYPE), POINTER :: MM
 
IF (I_OBST>0) OB=>OBSTRUCTION(I_OBST)
 
! Find the wall cells on each side of the edge 

IW1 = -1
IW2 = -1
 
EDGE_DIRECTION_1: SELECT CASE(IEC)
   CASE(1) EDGE_DIRECTION_1
      SELECT CASE(IOR)
         CASE(-2)
            IW1 = WALL_INDEX(CELL_INDEX(II,JJ,KK)  ,2)
            IW2 = WALL_INDEX(CELL_INDEX(II,JJ,KK+1),2)
         CASE( 2)
            IW1 = WALL_INDEX(CELL_INDEX(II,JJ+1,KK)  ,-2)
            IW2 = WALL_INDEX(CELL_INDEX(II,JJ+1,KK+1),-2)
         CASE(-3)
            IW1 = WALL_INDEX(CELL_INDEX(II,JJ  ,KK),3)
            IW2 = WALL_INDEX(CELL_INDEX(II,JJ+1,KK),3)
         CASE( 3)
            IW1 = WALL_INDEX(CELL_INDEX(II,JJ  ,KK+1),-3)
            IW2 = WALL_INDEX(CELL_INDEX(II,JJ+1,KK+1),-3)
      END SELECT
   CASE(2) EDGE_DIRECTION_1
      SELECT CASE(IOR)
         CASE(-1)
            IW1 = WALL_INDEX(CELL_INDEX(II,JJ,KK)  ,1)
            IW2 = WALL_INDEX(CELL_INDEX(II,JJ,KK+1),1)
         CASE( 1)
            IW1 = WALL_INDEX(CELL_INDEX(II+1,JJ,KK)  ,-1)
            IW2 = WALL_INDEX(CELL_INDEX(II+1,JJ,KK+1),-1)
         CASE(-3)
            IW1 = WALL_INDEX(CELL_INDEX(II  ,JJ,KK),3)
            IW2 = WALL_INDEX(CELL_INDEX(II+1,JJ,KK),3)
         CASE( 3)
            IW1 = WALL_INDEX(CELL_INDEX(II  ,JJ,KK+1),-3)
            IW2 = WALL_INDEX(CELL_INDEX(II+1,JJ,KK+1),-3)
      END SELECT
   CASE(3) EDGE_DIRECTION_1
      SELECT CASE(IOR)
         CASE(-1)
            IW1 = WALL_INDEX(CELL_INDEX(II,JJ  ,KK),1)
            IW2 = WALL_INDEX(CELL_INDEX(II,JJ+1,KK),1)
         CASE( 1)
            IW1 = WALL_INDEX(CELL_INDEX(II+1,JJ  ,KK),-1)
            IW2 = WALL_INDEX(CELL_INDEX(II+1,JJ+1,KK),-1)
         CASE(-2)
            IW1 = WALL_INDEX(CELL_INDEX(II  ,JJ,KK),2)
            IW2 = WALL_INDEX(CELL_INDEX(II+1,JJ,KK),2)
         CASE( 2)
            IW1 = WALL_INDEX(CELL_INDEX(II  ,JJ+1,KK),-2)
            IW2 = WALL_INDEX(CELL_INDEX(II+1,JJ+1,KK),-2)
      END SELECT
END SELECT EDGE_DIRECTION_1

! Decide what to do based on whether or not adjacent tiles exist

IF (IW1==-1 .OR. IW2==-1) THEN
   WRITE(LU_ERR,'(A,I2,A,3I3)') 'ERROR: Edge initialization failed; Mesh: ',NM,', Cell: ',II,JJ,KK
   PROCESS_STOP_STATUS = SETUP_STOP
   IERR = 1
   RETURN
ENDIF
IF (IW1==0 .AND. IW2==0) RETURN
IF (IW1> 0 .AND. IW2==0) IW = IW1
IF (IW1==0 .AND. IW2> 0) IW = IW2
IF (IW1> 0 .AND. IW2> 0) THEN
   IW = IW2 
   IF (WALL(IW1)%NOM>0) IW = IW1
   IF (WALL(IW2)%NOM>0) IW = IW2
ENDIF
 
! Assign the Index of the Edge (IE) and add to the list

ICMM = CELL_INDEX(II,JJ,KK)
SELECT CASE(IEC)
   CASE(1)
      IE = EDGE_INDEX(ICMM,4)
   CASE(2)
      IE = EDGE_INDEX(ICMM,8)
   CASE(3)
      IE = EDGE_INDEX(ICMM,12)
END SELECT
 
IF (IE==0) THEN
   N_EDGES = N_EDGES + 1
   IE = N_EDGES
ENDIF
 
! Determine the wall index of the adjacent wall tile
 
NOM = 0
IIO = 0
JJO = 0
KKO = 0
 
IF (WALL(IW)%NOM>0) THEN
   NOM = WALL(IW)%NOM
   IIO = WALL(IW)%NOM_IB(1)
   JJO = WALL(IW)%NOM_IB(2)
   KKO = WALL(IW)%NOM_IB(3)
ENDIF

! Fill up array IJKE with edge parameters
 
IJKE(1,IE) = II
IJKE(2,IE) = JJ
IJKE(3,IE) = KK
IJKE(4,IE) = IEC
 
! Fill in EDGE_INDEX and the rest of IJKE

EDGE_DIRECTION_2: SELECT CASE(IEC)
 
   CASE (1) EDGE_DIRECTION_2
 
      IF (ABS(IOR)==2 .AND. WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) EDGE_TYPE(IE,1) = INTERPOLATED_EDGE
      IF (ABS(IOR)==3 .AND. WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) EDGE_TYPE(IE,2) = INTERPOLATED_EDGE
      ICPM = CELL_INDEX(II,JJ+1,KK)
      ICPP = CELL_INDEX(II,JJ+1,KK+1)
      ICMP = CELL_INDEX(II,JJ,KK+1)
      IJKE(5,IE) = ICMM
      IJKE(6,IE) = ICPM
      IJKE(7,IE) = ICMP
      IJKE(8,IE) = ICPP
      EDGE_INDEX(ICPP,1) = IE
      EDGE_INDEX(ICMP,2) = IE
      EDGE_INDEX(ICPM,3) = IE
      EDGE_INDEX(ICMM,4) = IE
      IF (NOM/=0) THEN
         SELECT CASE(ABS(IOR))
            CASE(2)
               IF (IOR>0) IJKE( 9,IE) = -NOM
               IF (IOR<0) IJKE( 9,IE) =  NOM
               IJKE(10,IE) = IIO
               IJKE(11,IE) = JJO
               MM => MESHES(NOM)
               ZK  = MIN( REAL(MM%KBAR,EB)+ALMOST_ONE , MM%CELLSK(NINT((Z(KK)-MM%ZS)*MM%RDZINT))+1._EB )
               KKO = MAX(1,FLOOR(ZK))
               M%EDGE_INTERPOLATION_FACTOR(IE,1) = ZK-KKO
               IJKE(12,IE) = KKO
   
            CASE(3)
               IF (IOR>0) IJKE(13,IE) = -NOM
               IF (IOR<0) IJKE(13,IE) =  NOM
               IJKE(14,IE) = IIO
               MM => MESHES(NOM)
               YJ  = MIN( REAL(MM%JBAR,EB)+ALMOST_ONE , MM%CELLSJ(NINT((Y(JJ)-MM%YS)*MM%RDYINT))+1._EB )
               JJO = MAX(1,FLOOR(YJ))
               M%EDGE_INTERPOLATION_FACTOR(IE,2) = YJ-JJO
               IJKE(15,IE) = JJO
               IJKE(16,IE) = KKO
         END SELECT
      ENDIF
 
   CASE (2) EDGE_DIRECTION_2
    
      IF (ABS(IOR)==3 .AND. WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) EDGE_TYPE(IE,1) = INTERPOLATED_EDGE
      IF (ABS(IOR)==1 .AND. WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) EDGE_TYPE(IE,2) = INTERPOLATED_EDGE
      ICMP = CELL_INDEX(II+1,JJ,KK)
      ICPP = CELL_INDEX(II+1,JJ,KK+1)
      ICPM = CELL_INDEX(II,JJ,KK+1)
      IJKE(5,IE) = ICMM
      IJKE(6,IE) = ICPM
      IJKE(7,IE) = ICMP
      IJKE(8,IE) = ICPP
      EDGE_INDEX(ICPP,5) = IE
      EDGE_INDEX(ICPM,6) = IE
      EDGE_INDEX(ICMP,7) = IE
      EDGE_INDEX(ICMM,8) = IE
      IF (NOM/=0) THEN
         SELECT CASE(ABS(IOR))
            CASE( 1)
               IF (IOR>0) IJKE(13,IE) = -NOM
               IF (IOR<0) IJKE(13,IE) =  NOM
               IJKE(14,IE) = IIO
               IJKE(15,IE) = JJO
               MM => MESHES(NOM)
               ZK  = MIN( REAL(MM%KBAR,EB)+ALMOST_ONE , MM%CELLSK(NINT((Z(KK)-MM%ZS)*MM%RDZINT))+1._EB )
               KKO = MAX(1,FLOOR(ZK))
               M%EDGE_INTERPOLATION_FACTOR(IE,2) = ZK-KKO
               IJKE(16,IE) = KKO
            CASE( 3)
               IF (IOR>0) IJKE( 9,IE) = -NOM
               IF (IOR<0) IJKE( 9,IE) =  NOM
               MM => MESHES(NOM)
               XI  = MIN( REAL(MM%IBAR,EB)+ALMOST_ONE , MM%CELLSI(NINT((X(II)-MM%XS)*MM%RDXINT))+1._EB )
               IIO = MAX(1,FLOOR(XI))
               M%EDGE_INTERPOLATION_FACTOR(IE,1) = XI-IIO
               IJKE(10,IE) = IIO
               IJKE(11,IE) = JJO
               IJKE(12,IE) = KKO
         END SELECT 
      ENDIF
    
   CASE (3) EDGE_DIRECTION_2
 
      IF (ABS(IOR)==1 .AND. WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) EDGE_TYPE(IE,1) = INTERPOLATED_EDGE
      IF (ABS(IOR)==2 .AND. WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) EDGE_TYPE(IE,2) = INTERPOLATED_EDGE
      ICPM = CELL_INDEX(II+1,JJ,KK)
      ICPP = CELL_INDEX(II+1,JJ+1,KK)
      ICMP = CELL_INDEX(II,JJ+1,KK)
      IJKE(5,IE) = ICMM
      IJKE(6,IE) = ICPM
      IJKE(7,IE) = ICMP
      IJKE(8,IE) = ICPP
      EDGE_INDEX(ICPP, 9) = IE
      EDGE_INDEX(ICMP,10) = IE
      EDGE_INDEX(ICPM,11) = IE
      EDGE_INDEX(ICMM,12) = IE
      IF (NOM/=0) THEN
         SELECT CASE(ABS(IOR))
            CASE( 1)
               IF (IOR>0) IJKE( 9,IE) = -NOM
               IF (IOR<0) IJKE( 9,IE) =  NOM
               IJKE(10,IE) = IIO
               MM => MESHES(NOM)
               YJ  = MIN( REAL(MM%JBAR,EB)+ALMOST_ONE , MM%CELLSJ(NINT((Y(JJ)-MM%YS)*MM%RDYINT))+1._EB )
               JJO = MAX(1,FLOOR(YJ))
               M%EDGE_INTERPOLATION_FACTOR(IE,1) = YJ-JJO
               IJKE(11,IE) = JJO
               IJKE(12,IE) = KKO
            CASE( 2)
               IF (IOR>0) IJKE(13,IE) = -NOM
               IF (IOR<0) IJKE(13,IE) =  NOM
               MM => MESHES(NOM)
               XI  = MIN( REAL(MM%IBAR,EB)+ALMOST_ONE , MM%CELLSI(NINT((X(II)-MM%XS)*MM%RDXINT))+1._EB )
               IIO = MAX(1,FLOOR(XI))
               M%EDGE_INTERPOLATION_FACTOR(IE,2) = XI-IIO
               IJKE(14,IE) = IIO
               IJKE(15,IE) = JJO
               IJKE(16,IE) = KKO
         END SELECT
      ENDIF
 
END SELECT EDGE_DIRECTION_2

! Special "free-slip" cases

IF (I_OBST>0) THEN
   IF (.NOT.OB%SAWTOOTH) EDGE_TYPE(IE,:) = SMOOTH_EDGE
ENDIF

IF (EVACUATION_ONLY(NM)) EDGE_TYPE(IE,:) = SMOOTH_EDGE

END SUBROUTINE DEFINE_EDGE



SUBROUTINE INITIAL_NOISE(NM)

! Generate random noise at the start of the simulation
 
REAL     :: RN2
REAL(EB) :: VFAC,RN
INTEGER  :: I,J,K
INTEGER, INTENT(IN) :: NM
 
IF (EVACUATION_ONLY(NM)) RETURN
 
! Waste a few calls to RANDOM_NUMBER to avoid generating the exact same sequence on each mesh

DO I=1,NM
   IF (EVACUATION_ONLY(NM)) CYCLE
   CALL RANDOM_NUMBER(RN2)
ENDDO

! Point to local mesh variables

CALL POINT_TO_MESH(NM)

! Add random vorticity to cells that are not bounding solid surfaces

VFAC = 0.005_EB
 
DO K=1,KBM1
   DO J=1,JBM1
      DO I=1,IBAR
         IF (SOLID(CELL_INDEX(I,J,K))   .OR. SOLID(CELL_INDEX(I,J,K+1)) .OR. &
             SOLID(CELL_INDEX(I,J+1,K)) .OR. SOLID(CELL_INDEX(I,J+1,K+1)))  CYCLE 
         CALL RANDOM_NUMBER(RN2)
         RN=REAL(RN2,EB)
         RN = VFAC*(-1._EB + 2._EB*RN)*CELL_SIZE
         W(I,J,K)   = W(I,J,K)   - RN*RDY(J)
         W(I,J+1,K) = W(I,J+1,K) + RN*RDY(J+1)
         V(I,J,K)   = V(I,J,K)   + RN*RDZ(K)
         V(I,J,K+1) = V(I,J,K+1) - RN*RDZ(K+1)
      ENDDO
   ENDDO
ENDDO
DO K=1,KBM1
   DO J=1,JBAR
      DO I=1,IBM1
         IF (SOLID(CELL_INDEX(I,J,K))   .OR. SOLID(CELL_INDEX(I,J,K+1)) .OR. &
             SOLID(CELL_INDEX(I+1,J,K)) .OR. SOLID(CELL_INDEX(I+1,J,K+1)))  CYCLE 
         CALL RANDOM_NUMBER(RN2)
         RN=REAL(RN2,EB)         
         RN = VFAC*(-1._EB + 2._EB*RN)*CELL_SIZE
         W(I,J,K)   = W(I,J,K)   - RN*RDX(I)*R(I)*RRN(I)
         W(I+1,J,K) = W(I+1,J,K) + RN*RDX(I+1)*R(I)*RRN(I+1)
         U(I,J,K)   = U(I,J,K)   + RN*RDZ(K)
         U(I,J,K+1) = U(I,J,K+1) - RN*RDZ(K+1)
      ENDDO 
   ENDDO
ENDDO
DO K=1,KBAR
   DO J=1,JBM1
      DO I=1,IBM1
         IF (SOLID(CELL_INDEX(I,J,K))   .OR. SOLID(CELL_INDEX(I,J+1,K)) .OR. &
             SOLID(CELL_INDEX(I+1,J,K)) .OR. SOLID(CELL_INDEX(I+1,J+1,K)))  CYCLE
         CALL RANDOM_NUMBER(RN2)
         RN=REAL(RN2,EB)         
         RN = VFAC*(-1._EB + 2._EB*RN)*CELL_SIZE
         V(I,J,K)   = V(I,J,K)   - RN*RDX(I)
         V(I+1,J,K) = V(I+1,J,K) + RN*RDX(I+1)
         U(I,J,K)   = U(I,J,K)   + RN*RDY(J)
         U(I,J+1,K) = U(I,J+1,K) - RN*RDY(J+1)
      ENDDO 
   ENDDO
ENDDO

END SUBROUTINE INITIAL_NOISE
 

SUBROUTINE UVW_INIT(NM,FN_UVW)

! Read UVW file

USE COMP_FUNCTIONS, ONLY: GET_FILE_NUMBER,SHUTDOWN
INTEGER  :: I,J,K,II,JJ,KK,IW,IOR,LU_UVW,IERROR,IMIN,IMAX,JMIN,JMAX,KMIN,KMAX
INTEGER, INTENT(IN) :: NM
CHARACTER(256), INTENT(IN) :: FN_UVW
CHARACTER(100) :: MESSAGE
CHARACTER(3) :: STR
TYPE(WALL_TYPE), POINTER :: WC=>NULL()
 
CALL POINT_TO_MESH(NM)

LU_UVW = GET_FILE_NUMBER()
OPEN(UNIT=LU_UVW,FILE=FN_UVW,FORM='FORMATTED',STATUS='OLD',IOSTAT=IERROR)

IF (IERROR/=0) THEN
   WRITE(STR,'(I3)') NM
   MESSAGE = 'Problem with MESH '//TRIM(ADJUSTL(STR))//': UVW_FILE '//TRIM(FN_UVW)//' does not exist.'
   CALL SHUTDOWN(MESSAGE)
ENDIF

IF (PERIODIC_TEST==2) THEN
   IMIN = 1
   IMAX = IBAR
   JMIN = 1
   JMAX = JBAR
   KMIN = 1
   KMAX = KBAR
ELSE
   READ(LU_UVW,*) IMIN,IMAX,JMIN,JMAX,KMIN,KMAX
   IMIN = MAX(0,IMIN)
   IMAX = MIN(IBAR,IMAX)
   JMIN = MAX(0,JMIN)
   JMAX = MIN(JBAR,JMAX)
   KMIN = MAX(0,KMIN)
   KMAX = MIN(KBAR,KMAX)
ENDIF
DO K=KMIN,KMAX
   DO J=JMIN,JMAX
      DO I=IMIN,IMAX
         READ(LU_UVW,*,IOSTAT=IERROR) U(I,J,K),V(I,J,K),W(I,J,K)
         IF (IERROR/=0) THEN
            U(I,J,K)=0._EB
            V(I,J,K)=0._EB
            W(I,J,K)=0._EB
         ENDIF
      ENDDO
   ENDDO
ENDDO

CLOSE(LU_UVW)

IF (PERIODIC_TEST==2) THEN
   U(0,:,:) = U(IBAR,:,:)
   V(:,0,:) = V(:,JBAR,:)
   W(:,:,0) = W(:,:,KBAR)
ENDIF

US=U
VS=V
WS=W

! Set normal velocity on external and internal boundaries (follows divg)

DO IW=1,N_EXTERNAL_WALL_CELLS+N_INTERNAL_WALL_CELLS
   WC  => WALL(IW)
   IOR = WC%ONE_D%IOR
   II  = WC%ONE_D%II
   JJ  = WC%ONE_D%JJ
   KK  = WC%ONE_D%KK
   SELECT CASE(IOR)
      CASE( 1)
         WC%ONE_D%UWS = -U(II,JJ,KK)
      CASE(-1)
         WC%ONE_D%UWS =  U(II-1,JJ,KK)
      CASE( 2)
         WC%ONE_D%UWS = -V(II,JJ,KK)
      CASE(-2)
         WC%ONE_D%UWS =  V(II,JJ-1,KK)
      CASE( 3)
         WC%ONE_D%UWS = -W(II,JJ,KK)
      CASE(-3)
         WC%ONE_D%UWS =  W(II,JJ,KK-1)
   END SELECT
   WALL(IW)%ONE_D%UW = WALL(IW)%ONE_D%UWS
ENDDO

END SUBROUTINE UVW_INIT
 

SUBROUTINE GET_REV_init(MODULE_REV,MODULE_DATE)
INTEGER,INTENT(INOUT) :: MODULE_REV
CHARACTER(255),INTENT(INOUT) :: MODULE_DATE

WRITE(MODULE_DATE,'(A)') initrev(INDEX(initrev,':')+2:LEN_TRIM(initrev)-2)
READ (MODULE_DATE,'(I5)') MODULE_REV
WRITE(MODULE_DATE,'(A)') initdate

END SUBROUTINE GET_REV_init

 
END MODULE INIT
