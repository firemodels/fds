MODULE HVAC_ROUTINES
 
! Compute the HVAC mass and energy transport
 
USE PRECISION_PARAMETERS
USE GLOBAL_CONSTANTS
USE MESH_POINTERS
USE DEVICE_VARIABLES
USE CONTROL_VARIABLES
USE COMP_FUNCTIONS, ONLY: SECOND, CHECKREAD, SHUTDOWN
USE MEMORY_FUNCTIONS, ONLY: ChkMemErr
 
IMPLICIT NONE

REAL(EB), ALLOCATABLE, DIMENSION(:,:):: NODE_AREA,NODE_AREA_EX,NODE_H,NODE_P,NODE_RHO,NODE_X,NODE_Y,NODE_Z,&
                                        NODE_TMP,NODE_TMP_EX,DUCT_MF
REAL(EB), ALLOCATABLE, DIMENSION(:,:,:):: NODE_ZZ,NODE_ZZ_EX
INTEGER, ALLOCATABLE, DIMENSION(:,:) :: NODE_ZONE
CHARACTER(LABEL_LENGTH), ALLOCATABLE, DIMENSION(:,:) :: NODE_DUCT_A,DUCT_NODE_A
CHARACTER(LABEL_LENGTH), ALLOCATABLE, DIMENSION(:) :: NODE_FILTER_A,DUCT_FAN_A,DUCT_AIRCOIL_A
INTEGER :: LEAK_DUCTS = 0
INTEGER, ALLOCATABLE, DIMENSION(:,:):: LEAK_PATH
CHARACTER(255), PARAMETER :: hvacid='$Id$'
CHARACTER(255), PARAMETER :: hvacrev='$Revision$'
CHARACTER(255), PARAMETER :: hvacdate='$Date$'
CHARACTER(255) :: MESSAGE
REAL(EB), ALLOCATABLE, DIMENSION(:,:) :: LHS
REAL(EB), ALLOCATABLE, DIMENSION(:) :: RHS,DPSTAR
INTEGER :: ITER,ITER_MAX=10

PUBLIC HVAC_CALC,GET_REV_hvac,READ_HVAC,PROC_HVAC,HVAC_BC_IN,FIND_NETWORKS,COLLAPSE_HVAC_BC,SET_INIT_HVAC
 
CONTAINS


SUBROUTINE READ_HVAC

! Read and process HVAC networks

USE MATH_FUNCTIONS, ONLY: GET_RAMP_INDEX,GET_TABLE_INDEX
USE MISC_FUNCTIONS, ONLY: SEARCH_CONTROLLER
INTEGER , PARAMETER :: MAX_DUCTS = 20
INTEGER :: IOS,IZERO,N_HVAC_READ,NS,N,ND,NN,I_AIRCOIL=0,I_DUCT=0,I_DUCTNODE=0,I_FAN=0 ,I_FILTER=0
REAL(EB) :: AREA,DIAMETER,XYZ(3),LOSS(MAX_DUCTS,MAX_DUCTS),VOLUME_FLOW,MAX_FLOW,MAX_PRESSURE,ROUGHNESS,LENGTH,TNOW,TAU_AC,&
            TAU_FAN,TAU_VF,FIXED_Q,CLEAN_LOSS,&
            COOLANT_MASS_FLOW,COOLANT_SPECIFIC_HEAT,COOLANT_TEMPERATURE,PERIMETER,MASS_FLOW
REAL(EB) :: LOADING(MAX_SPECIES),EFFICIENCY(MAX_SPECIES),LOADING_MULTIPLIER(MAX_SPECIES)
LOGICAL :: ROUND, SQUARE, DAMPER, REVERSE, AMBIENT,LEAK_ENTHALPY
CHARACTER(LABEL_LENGTH) :: TYPE_ID,DEVC_ID,CTRL_ID,DUCT_ID(MAX_DUCTS),NODE_ID(2),VENT_ID,VENT2_ID,FAN_ID,AIRCOIL_ID,RAMP_ID,ID,&
                           FILTER_ID
CHARACTER(LABEL_LENGTH) :: SPEC_ID(MAX_SPECIES)
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
NAMELIST /HVAC/ AIRCOIL_ID,AMBIENT,AREA,CLEAN_LOSS,COOLANT_SPECIFIC_HEAT,COOLANT_MASS_FLOW,COOLANT_TEMPERATURE,CTRL_ID,DAMPER,&
                DEVC_ID,DIAMETER,&
                DUCT_ID,EFFICIENCY,FAN_ID,FILTER_ID,FIXED_Q,ID,LEAK_ENTHALPY,LENGTH,LOADING,LOADING_MULTIPLIER,LOSS,&
                MASS_FLOW,MAX_FLOW,MAX_PRESSURE,NODE_ID,PERIMETER,&
                RAMP_ID,REVERSE,ROUGHNESS,SPEC_ID,TAU_AC,TAU_FAN,TAU_VF,TYPE_ID,VENT_ID,VENT2_ID,VOLUME_FLOW,XYZ

TNOW=SECOND()

N_HVAC_READ = 0
 
REWIND(LU_INPUT) ; INPUT_FILE_LINE_NUMBER = 0
COUNT_HVAC_LOOP: DO
   CALL CHECKREAD('HVAC',LU_INPUT,IOS)
   IF (IOS==1) EXIT COUNT_HVAC_LOOP
   READ(LU_INPUT,HVAC,END=15,ERR=16,IOSTAT=IOS)
   N_HVAC_READ = N_HVAC_READ + 1
   16 IF (IOS>0) THEN
         WRITE(MESSAGE,'(A,I5,A,I5)') &
            'ERROR: Problem with HVAC line number ',N_HVAC_READ+1,', input line number',INPUT_FILE_LINE_NUMBER
         CALL SHUTDOWN(MESSAGE); RETURN
      ENDIF
   IF (TRIM(ID)=='null') THEN
      WRITE(MESSAGE,'(A,I5,A,I5)') &
         'ERROR: No ID provided for HVAC line number ',N_HVAC_READ+1,', input line number',INPUT_FILE_LINE_NUMBER
      CALL SHUTDOWN(MESSAGE); RETURN
   ENDIF
   SELECT CASE(TYPE_ID)
      CASE ('DUCT')
         N_DUCTS = N_DUCTS + 1
      CASE ('NODE')
         N_DUCTNODES = N_DUCTNODES + 1
      CASE ('FILTER')
         N_FILTERS = N_FILTERS + 1
      CASE ('FAN')
         N_FANS = N_FANS + 1
      CASE ('AIRCOIL')
         N_AIRCOILS = N_AIRCOILS + 1
      CASE ('LEAK')
         N_DUCTS = N_DUCTS + 1
         N_DUCTNODES = N_DUCTNODES + 2      
   END SELECT
ENDDO COUNT_HVAC_LOOP
15 CONTINUE

LEAK_DUCTS = 0
IF (ANY(SURFACE%LEAK_PATH(1)>0).OR.ANY(SURFACE%LEAK_PATH(2)>0)) THEN 
   ALLOCATE(LEAK_PATH(0:N_ZONE,0:N_ZONE),STAT=IZERO)
   CALL ChkMemErr('HVAC','LEAK_PATH',IZERO)
   LEAK_PATH = 0
   DO NS=1,N_SURF
      IF (SURFACE(NS)%LEAK_PATH(1)>0 .OR. SURFACE(NS)%LEAK_PATH(2)>0) &
         LEAK_PATH(MINVAL(SURFACE(NS)%LEAK_PATH),MAXVAL(SURFACE(NS)%LEAK_PATH))=1
   ENDDO
   LEAK_DUCTS = SUM(LEAK_PATH)
   N_DUCTS = N_DUCTS + LEAK_DUCTS
   N_DUCTNODES = N_DUCTNODES + 2 * LEAK_DUCTS
ENDIF

IF (N_HVAC_READ > 0) HVAC_SOLVE = .TRUE.

IF ((N_DUCTS > 0 .AND. N_DUCTNODES <= 0) .OR. (N_DUCTS <= 0 .AND. N_DUCTNODES > 0)) THEN
   WRITE(MESSAGE,'(A)') 'ERROR: Must have both DUCTs and DUCTNODEs in the input file'
   CALL SHUTDOWN(MESSAGE); RETURN
ENDIF

ALLOCATE(DUCT(N_DUCTS),STAT=IZERO)
CALL ChkMemErr('HVAC','DUCT',IZERO)
ALLOCATE(DUCT_NE(N_DUCTS),STAT=IZERO)
CALL ChkMemErr('HVAC','DUCT_NE',IZERO)
DUCT_NE = 0
ALLOCATE(DUCTNODE(N_DUCTNODES),STAT=IZERO)
CALL ChkMemErr('HVAC','DUCTNODE',IZERO)
ALLOCATE(DUCTNODE_NE(N_DUCTNODES),STAT=IZERO)
CALL ChkMemErr('HVAC','DUCTNODE_NE',IZERO)
DUCTNODE_NE = 0
ALLOCATE(FILTER(N_FILTERS),STAT=IZERO)
CALL ChkMemErr('HVAC','FILTER',IZERO)
ALLOCATE(FAN(N_FANS),STAT=IZERO)
CALL ChkMemErr('HVAC','FAN',IZERO)
ALLOCATE(AIRCOIL(N_AIRCOILS),STAT=IZERO)
CALL ChkMemErr('HVAC','AIRCOIL',IZERO)

!Temp arrays for input processing
ALLOCATE(DUCT_NODE_A(N_DUCTS,2),STAT=IZERO)
CALL ChkMemErr('HVAC','NODE_DUCTS',IZERO)
ALLOCATE(NODE_DUCT_A(N_DUCTNODES,MAX_DUCTS),STAT=IZERO)
CALL ChkMemErr('HVAC','NODE_DUCTS',IZERO)
ALLOCATE(NODE_FILTER_A(N_DUCTNODES),STAT=IZERO)
CALL ChkMemErr('HVAC','NODE_DUCTS',IZERO)
ALLOCATE(DUCT_FAN_A(N_DUCTS),STAT=IZERO)
CALL ChkMemErr('HVAC','DUCT_FAN',IZERO)
ALLOCATE(DUCT_AIRCOIL_A(N_DUCTS),STAT=IZERO)
CALL ChkMemErr('HVAC','DUCT_AIRCOIL',IZERO)

REWIND(LU_INPUT) ; INPUT_FILE_LINE_NUMBER = 0
DO NN=1,N_HVAC_READ
   CALL SET_HVAC_DEFAULTS
   READ(LU_INPUT,HVAC)
   SELECT CASE (TYPE_ID)
      CASE('DUCT')
         I_DUCT = I_DUCT + 1
         DU=> DUCT(I_DUCT)
         DU%ID   = ID
         IF (DIAMETER <= 0._EB .AND. AREA <= 0._EB .AND. PERIMETER <= 0._EB) THEN
            WRITE(MESSAGE,'(A,I5)') 'ERROR: Duct has no AREA, DIAMETER, or PERIMTER, HVAC line number ',NN
            CALL SHUTDOWN(MESSAGE); RETURN
         ENDIF
         IF (DIAMETER > 0._EB) THEN
            IF (PERIMETER > 0._EB) THEN
              WRITE(MESSAGE,'(A,I5)') 'ERROR: Duct cannot input both PERIMETER and DIAMETER, HVAC line number ',NN
              CALL SHUTDOWN(MESSAGE); RETURN
            ENDIF
            AREA = 0.5_EB*PIO2*DIAMETER**2
         ENDIF
         IF (AREA > 0._EB) THEN
            IF (DIAMETER >  0._EB .AND. PERIMETER >  0._EB) THEN               
              WRITE(MESSAGE,'(A,I5)') 'ERROR: Duct cannot input both PERIMETER and DIAMETER with AREA, HVAC line number ',NN
              CALL SHUTDOWN(MESSAGE); RETURN
            ENDIF
            IF (PERIMETER <= 0._EB) DIAMETER = SQRT(2._EB*AREA/PIO2)
            IF (PERIMETER >  0._EB) DIAMETER = 4._EB*AREA/PERIMETER
         ENDIF  
         IF (PERIMETER > 0._EB .AND. AREA <= 0._EB) THEN
            WRITE(MESSAGE,'(A,I5)') 'ERROR: Duct cannot have PERIMETER without AREA, HVAC line number ',NN
            CALL SHUTDOWN(MESSAGE); RETURN
         ENDIF
         DU%AREA_INITIAL = AREA
         DU%AREA = AREA
         DU%DIAMETER = DIAMETER
         DU%LENGTH = LENGTH         
         DU%REVERSE = REVERSE
         ALLOCATE(DU%ZZ(N_TRACKED_SPECIES))
         DU%ZZ(1:N_TRACKED_SPECIES) = SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
         DU%LOSS(1:2) = MAX(0._EB,LOSS(1:2,1))
         IF (CTRL_ID /='null' .AND. DEVC_ID /='null') THEN
            WRITE(MESSAGE,'(A,I5)') 'ERROR: Can only specify one of CTRL_ID or DEVC_ID, HVAC line number ',NN
            CALL SHUTDOWN(MESSAGE); RETURN
         ENDIF
         IF (DAMPER .AND. (FAN_ID /='null' .OR. AIRCOIL_ID /='null') .OR. &
             FAN_ID/='null' .AND. (DAMPER .OR. AIRCOIL_ID /='null') .OR. &
             AIRCOIL_ID/='null' .AND. (DAMPER .OR. FAN_ID /='null')) THEN
            WRITE(MESSAGE,'(A,I5)') 'ERROR: Duct can only have one of damper, fan or aircoil, HVAC line number ',NN
            CALL SHUTDOWN(MESSAGE); RETURN
         ENDIF
         IF (FAN_ID/='null' .AND. N_FANS<=0) THEN
            WRITE(MESSAGE,'(A,I5)') 'ERROR: Duct has fan specied but no fans have been defined, HVAC line number ',NN
            CALL SHUTDOWN(MESSAGE); RETURN
         ENDIF
         DU%DAMPER = DAMPER
         DUCT_AIRCOIL_A(I_DUCT) = AIRCOIL_ID
         DUCT_FAN_A(I_DUCT) = FAN_ID
         IF (CTRL_ID /= 'null' .OR. DEVC_ID /= 'null') &
            CALL SEARCH_CONTROLLER('HVAC',CTRL_ID,DEVC_ID,DU%DEVC_INDEX,DU%CTRL_INDEX,NN)
         IF (DAMPER) THEN
            IF (DU%DEVC_INDEX > 0) THEN
                DU%DAMPER_OPEN = DEVICE(DU%DEVC_INDEX)%INITIAL_STATE                
            ELSEIF (DU%CTRL_INDEX > 0) THEN
                DU%DAMPER_OPEN = CONTROL(DU%CTRL_INDEX)%INITIAL_STATE                
            ELSE
                DU%DAMPER_OPEN = .TRUE.
            ENDIF
            IF (.NOT. DU%DAMPER_OPEN) DU%AREA = 0._EB
         ELSEIF (FAN_ID /='null') THEN
            IF (DU%DEVC_INDEX > 0) THEN
                DU%FAN_OPERATING = DEVICE(DU%DEVC_INDEX)%INITIAL_STATE                
            ELSEIF (DU%CTRL_INDEX > 0) THEN
                DU%FAN_OPERATING = CONTROL(DU%CTRL_INDEX)%INITIAL_STATE                
            ELSE
                DU%FAN_OPERATING = .TRUE.
            ENDIF
            IF (DU%FAN_OPERATING) DU%FAN_ON_TIME = T_BEGIN
            IF (.NOT. DU%FAN_OPERATING) DU%DP_FAN = 0._EB
         ELSEIF (AIRCOIL_ID /='null') THEN
            IF (DU%DEVC_INDEX > 0) THEN
                DU%COIL_OPERATING = DEVICE(DU%DEVC_INDEX)%INITIAL_STATE                
            ELSEIF (DU%CTRL_INDEX > 0) THEN
                DU%COIL_OPERATING = CONTROL(DU%CTRL_INDEX)%INITIAL_STATE                
            ELSE
                DU%COIL_OPERATING = .TRUE.
            ENDIF
            IF (DU%COIL_OPERATING) DU%COIL_ON_TIME = T_BEGIN
         ENDIF  
         DUCT_NODE_A(I_DUCT,:) = NODE_ID
         IF (VOLUME_FLOW < 1.E7_EB .AND. MASS_FLOW < 1.E7_EB) THEN
            WRITE(MESSAGE,'(A,A)') 'ERROR: Duct has both MASS_FLOW and VOLUME_FLOW defined.  DUCT ID:',TRIM(DU%ID)
            CALL SHUTDOWN(MESSAGE); RETURN
         ENDIF
         DU%MASS_FLOW_INITIAL = MASS_FLOW
         DU%VOLUME_FLOW_INITIAL = VOLUME_FLOW
         DU%ROUGHNESS = ROUGHNESS
         DU%TAU = TAU_VF
         IF (TAU_VF > 0._EB) DU%RAMP_INDEX = TANH_RAMP 
         IF (TAU_VF < 0._EB) DU%RAMP_INDEX = TSQR_RAMP
         IF (RAMP_ID /= 'null') CALL GET_RAMP_INDEX(RAMP_ID,'DUCT',DU%RAMP_INDEX)
         
      CASE('NODE')
         I_DUCTNODE = I_DUCTNODE + 1
         NODE_DUCT_A(I_DUCTNODE,:) = DUCT_ID   
         NODE_FILTER_A(I_DUCTNODE) = FILTER_ID      
         DN => DUCTNODE(I_DUCTNODE)
         DN%ID = ID
         DN%VENT_ID = VENT_ID
         DN%READ_IN = .TRUE.
         IF (TRIM(VENT_ID)/='null') DN%VENT=.TRUE.
         IF (.NOT. DN%VENT .AND. XYZ(3)<-1.E9) THEN
            WRITE(MESSAGE,'(A,A)') 'ERROR: Ambient or internal ductnode requires an elevation, XYZ(3). Ductnode ID: ',TRIM(DN%ID)
            CALL SHUTDOWN(MESSAGE); RETURN         
         ENDIF
         DN%XYZ      = XYZ
         DN%AMBIENT  = AMBIENT
         DO ND = 1, MAX_DUCTS
            IF (NODE_DUCT_A(I_DUCTNODE,ND) == 'null') EXIT
            DN%N_DUCTS=ND
         ENDDO
         IF (DN%N_DUCTS > 2 .AND. TRIM(FILTER_ID)/='null') THEN
            WRITE(MESSAGE,'(A,A)') 'ERROR: Ductnode with a filter must have <=2 ducts. Ductnode ID: ',TRIM(DN%ID)
            CALL SHUTDOWN(MESSAGE); RETURN         
         ENDIF
         ALLOCATE(DN%LOSS_ARRAY(MAX(2,DN%N_DUCTS),MAX(2,DN%N_DUCTS)))
         DN%LOSS_ARRAY = 0._EB
         IF (DN%N_DUCTS >=2) THEN
            DN%LOSS_ARRAY = LOSS(1:DN%N_DUCTS,1:DN%N_DUCTS)
         ELSE
            DN%LOSS_ARRAY(1,2) = LOSS(1,1)
            DN%LOSS_ARRAY(2,1) = LOSS(2,1)
         ENDIF
         IF (TRIM(FILTER_ID)/='null') THEN
            ALLOCATE(DN%FILTER_LOADING(1:N_TRACKED_SPECIES,3))
            DN%FILTER_LOADING = 0._EB
            SPEC_LOOP1: DO N=1,N_TRACKED_SPECIES
               IF (TRIM(SPEC_ID(N))=='null') EXIT SPEC_LOOP1
               DO NS = 1,N_TRACKED_SPECIES
                  IF (TRIM(SPECIES_MIXTURE(NS)%ID)==TRIM(SPEC_ID(N))) THEN
                     DN%FILTER_LOADING(NS,1) = LOADING(N)
                     EXIT
                  ENDIF
                  IF (NS==N_TRACKED_SPECIES) THEN
                     WRITE(MESSAGE,'(A,A,A,A,A)') 'ERROR: Problem with DUCTNODE:',TRIM(ID),' SPEC ',TRIM(SPEC_ID(N)),' not found'
                     CALL SHUTDOWN(MESSAGE); RETURN
                  ENDIF   
               ENDDO         
            ENDDO SPEC_LOOP1
         ENDIF
         
      CASE('FAN')
         I_FAN = I_FAN + 1
         FAN(I_FAN)%ID = ID
         FAN(I_FAN)%OFF_LOSS = LOSS(1,1)
         FAN(I_FAN)%FAN_RAMP = RAMP_ID
         FAN(I_FAN)%VOL_FLOW = VOLUME_FLOW
         FAN(I_FAN)%MAX_PRES = MAX_PRESSURE
         FAN(I_FAN)%MAX_FLOW = MAX_FLOW
         FAN(I_FAN)%TAU = TAU_FAN
         IF (TAU_FAN > 0._EB) FAN(I_FAN)%SPIN_INDEX = TANH_RAMP 
         IF (TAU_FAN < 0._EB) FAN(I_FAN)%SPIN_INDEX = TSQR_RAMP
         IF (RAMP_ID /= 'null') CALL GET_RAMP_INDEX(RAMP_ID,'FAN',FAN(I_FAN)%RAMP_INDEX)
         IF(( (MAX_FLOW<1.E6_EB .OR. MAX_PRESSURE<1.E6_EB) .AND. (VOLUME_FLOW<1.E6_EB .OR. RAMP_ID/='null')))THEN !.OR. &
            WRITE(MESSAGE,'(A,I5)') 'ERROR: FAN can only be one of constant volume, quadratic or ramp, HVAC line number ',NN
            CALL SHUTDOWN(MESSAGE); RETURN
         ENDIF
         IF ((MAX_PRESSURE<1.E6_EB .AND. MAX_FLOW>1.E6_EB) .OR. (MAX_PRESSURE>1.E6_EB .AND. MAX_FLOW<1.E6_EB)) THEN
            WRITE(MESSAGE,'(A,I5)') 'ERROR: IF one of MAX_PRESSURE or MAX_FLOW given, both must be specified, HVAC line number '&
                                    ,NN
            CALL SHUTDOWN(MESSAGE); RETURN
         ENDIF
         IF (VOLUME_FLOW < 1.E6_EB) THEN
            FAN(I_FAN)%FAN_TYPE = 1
         ELSEIF(RAMP_ID/='null') THEN
            FAN(I_FAN)%FAN_TYPE = 3
         ELSE
            FAN(I_FAN)%FAN_TYPE = 2            
         ENDIF
                
      CASE('FILTER')         
         I_FILTER = I_FILTER + 1
         FILTER(I_FILTER)%ID = ID
         FILTER(I_FILTER)%CLEAN_LOSS = CLEAN_LOSS
         IF (TRIM(RAMP_ID)/='null') CALL GET_RAMP_INDEX(RAMP_ID,'FILTER',FILTER(I_FILTER)%RAMP_INDEX)
         ALLOCATE(FILTER(I_FILTER)%EFFICIENCY(1:N_TRACKED_SPECIES))
         FILTER(I_FILTER)%EFFICIENCY = 0._EB
         ALLOCATE(FILTER(I_FILTER)%MULTIPLIER(1:N_TRACKED_SPECIES))
         FILTER(I_FILTER)%MULTIPLIER = 0._EB                  
         FILTER(I_FILTER)%LOADING_LOSS = LOSS(1,1)
         SPEC_LOOP2: DO N=1,N_TRACKED_SPECIES
            IF (TRIM(SPEC_ID(N))=='null') EXIT SPEC_LOOP2
            DO NS = 1,N_TRACKED_SPECIES
               IF (TRIM(SPECIES_MIXTURE(NS)%ID)==TRIM(SPEC_ID(N))) THEN
                  FILTER(I_FILTER)%EFFICIENCY(NS)   = EFFICIENCY(N)
                  FILTER(I_FILTER)%MULTIPLIER(NS) = LOADING_MULTIPLIER(N)                  
                  EXIT
               ENDIF
               IF (NS==N_TRACKED_SPECIES) THEN
                  WRITE(MESSAGE,'(A,A,A,A,A)') 'ERROR: Problem with FILTER:',TRIM(ID),' SPEC ',TRIM(SPEC_ID(N)),' not found'
                  CALL SHUTDOWN(MESSAGE); RETURN
               ENDIF   
            ENDDO         
         ENDDO SPEC_LOOP2         
      CASE('AIRCOIL')
         I_AIRCOIL = I_AIRCOIL+1
         AIRCOIL(I_AIRCOIL)%COOLANT_SPECIFIC_HEAT   = COOLANT_SPECIFIC_HEAT*1000._EB
         AIRCOIL(I_AIRCOIL)%COOLANT_MASS_FLOW = COOLANT_MASS_FLOW
         AIRCOIL(I_AIRCOIL)%COOLANT_TEMPERATURE = COOLANT_TEMPERATURE+TMPM
         AIRCOIL(I_AIRCOIL)%EFFICIENCY   = EFFICIENCY(1)
         AIRCOIL(I_AIRCOIL)%FIXED_Q      = FIXED_Q*1000._EB
         AIRCOIL(I_AIRCOIL)%ID           = ID
         AIRCOIL(I_AIRCOIL)%TAU          = TAU_AC
         IF (TAU_AC > 0._EB) AIRCOIL(I_AIRCOIL)%RAMP_INDEX = TANH_RAMP 
         IF (TAU_AC < 0._EB) AIRCOIL(I_AIRCOIL)%RAMP_INDEX = TSQR_RAMP         
         AIRCOIL(I_AIRCOIL)%RAMP_ID      = RAMP_ID         
         IF (RAMP_ID /= 'null') CALL GET_RAMP_INDEX(RAMP_ID,'DUCT',AIRCOIL(I_AIRCOIL)%RAMP_INDEX)      
      CASE('LEAK')
         I_DUCTNODE = I_DUCTNODE + 1
         NODE_DUCT_A(I_DUCTNODE,1) = ID   
         NODE_FILTER_A(I_DUCTNODE) = 'null'
         DN => DUCTNODE(I_DUCTNODE)
         DN%ID = VENT_ID
         DN%VENT_ID = VENT_ID
         DN%VENT=.TRUE.
         DN%READ_IN = .FALSE.
         IF (TRIM(DN%VENT_ID)=='null') THEN
            WRITE(MESSAGE,'(A,A)') 'ERROR: Leakage path must have VENT_ID defined. Ductnode ID: ',TRIM(DN%ID)
            CALL SHUTDOWN(MESSAGE); RETURN         
         ENDIF
         IF (TRIM(DN%VENT_ID)=='AMBIENT') THEN
            WRITE(MESSAGE,'(A,A)') 'ERROR: Leakage to AMBIENT must have VENT2_ID for the AMBIENT node. Ductnode ID: ',TRIM(DN%ID)
            CALL SHUTDOWN(MESSAGE); RETURN         
         ENDIF          
         DN%XYZ      = XYZ
         DN%AMBIENT  = .FALSE.
         DN%N_DUCTS=1
         ALLOCATE(DN%LOSS_ARRAY(2,2))
         DN%LOSS_ARRAY = 0._EB
         
         I_DUCTNODE = I_DUCTNODE + 1
         NODE_DUCT_A(I_DUCTNODE,1) = ID   
         NODE_FILTER_A(I_DUCTNODE) = 'null'
         DN => DUCTNODE(I_DUCTNODE)
         DN%ID = VENT2_ID
         DN%VENT_ID = VENT2_ID
         DN%VENT=.TRUE.
         DN%READ_IN = .FALSE.         
         IF (TRIM(VENT2_ID)=='null') THEN
            WRITE(MESSAGE,'(A,A)') 'ERROR: Leakage path must have VENT2_ID defined. Ductnode ID: ',TRIM(DN%ID)
            CALL SHUTDOWN(MESSAGE); RETURN         
         ENDIF
         DN%XYZ      = XYZ
         DN%AMBIENT  = .FALSE.
         IF (TRIM(DN%VENT_ID)=='AMBIENT') THEN
            DN%AMBIENT = .TRUE.
            DN%ID = TRIM(VENT_ID)//' AMB'
            VENT2_ID = DN%ID
            DN%VENT_ID ='null'
            DN%VENT = .FALSE.
         ENDIF          
         DN%N_DUCTS=1
         ALLOCATE(DN%LOSS_ARRAY(2,2))
         DN%LOSS_ARRAY = 0._EB

         I_DUCT = I_DUCT + 1
         DU=> DUCT(I_DUCT)
         DU%ID   = ID
         IF (AREA <= 0._EB) THEN
            WRITE(MESSAGE,'(A,I5,A,A)') 'ERROR: Leakage has no AREA, HVAC line number ',NN, 'Leak ID:',TRIM(ID)
            CALL SHUTDOWN(MESSAGE); RETURN
         ENDIF
         DU%AREA_INITIAL = AREA
         DU%AREA = AREA
         DU%DIAMETER = -1._EB
         DU%LENGTH = 0.1_EB
         DU%REVERSE = .FALSE.
         ALLOCATE(DU%ZZ(N_TRACKED_SPECIES))
         DU%ZZ(1:N_TRACKED_SPECIES) = SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
         IF (LOSS(1,1)==0._EB) LOSS(1,1)=1._EB
         DU%LOSS(1:2) = MAX(0._EB,LOSS(1,1))
         DU%DAMPER = .FALSE.
         DUCT_AIRCOIL_A(I_DUCT) = 'null'
         DUCT_FAN_A(I_DUCT) = 'null'
         DUCT_NODE_A(I_DUCT,1) = VENT_ID
         DUCT_NODE_A(I_DUCT,2) = VENT2_ID
         DU%MASS_FLOW_INITIAL = 1.E7_EB
         DU%VOLUME_FLOW_INITIAL = 1.E7_EB
         DU%ROUGHNESS = 0._EB
         DU%TAU = 1._EB
         DU%RAMP_INDEX = TANH_RAMP
         DU%LEAKAGE = .FALSE.
         DU%LEAK_ENTHALPY = LEAK_ENTHALPY         
   END SELECT   
ENDDO

TUSED(16,1)=TUSED(16,1)+SECOND()-TNOW

RETURN

CONTAINS

SUBROUTINE SET_HVAC_DEFAULTS

AIRCOIL_ID   = 'null'
AMBIENT      = .FALSE.
AREA         = -1._EB
COOLANT_SPECIFIC_HEAT   = 4186._EB
COOLANT_MASS_FLOW = -1.E10_EB
COOLANT_TEMPERATURE = 293.15_EB
EFFICIENCY   = 1.0_EB
CLEAN_LOSS   = 0._EB
CTRL_ID      = 'null'
DAMPER       = .FALSE.
DEVC_ID      = 'null'
DIAMETER     = -1._EB
DUCT_ID      = 'null'
FAN_ID       = 'null'
FIXED_Q      = -1.E10_EB
FILTER_ID    = 'null'
LEAK_ENTHALPY = .FALSE.
LENGTH       = 1._EB
LOADING      = 0._EB
LOADING_MULTIPLIER = 1._EB
LOSS         = 0._EB
MASS_FLOW    = 1.E7_EB
MAX_FLOW     = 1.E7_EB
MAX_PRESSURE = 1.E7_EB
NODE_ID      = 'null'
PERIMETER    = -1._EB
RAMP_ID      = 'null'
REVERSE      = .FALSE.
ROUGHNESS    = 0._EB
ROUND        = .TRUE.
SPEC_ID      = 'null'
SQUARE       = .FALSE.
TYPE_ID      = 'null'
TAU_AC       = 1._EB
TAU_FAN      = 1._EB
TAU_VF       = 1._EB
VENT_ID      = 'null'
VENT2_ID     = 'null'
VOLUME_FLOW  = 1.E7_EB
XYZ          = -1.E10_EB

RETURN

END SUBROUTINE SET_HVAC_DEFAULTS

END SUBROUTINE READ_HVAC


SUBROUTINE PROC_HVAC
USE PHYSICAL_FUNCTIONS, ONLY: GET_AVERAGE_SPECIFIC_HEAT
!INTEGER :: I1,I2,J1,J2,K1,K2,IOR
INTEGER :: N,ND,ND2,NM,NN,NF,NV
REAL(EB) :: ZZ_GET(1:N_TRACKED_SPECIES),TNOW
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
TYPE(SURFACE_TYPE), POINTER :: SF=>NULL()
TNOW=SECOND()

IF (LEAK_DUCTS > 0) THEN
   HVAC_SOLVE = .TRUE.
   CALL LEAKAGE_HVAC
ENDIF

DO ND = 1, N_DUCTS
   DU => DUCT(ND)
   IF (DU%LEAKAGE) CYCLE
   IF (TRIM(DUCT_NODE_A(ND,1))==TRIM(DUCT_NODE_A(ND,2))) THEN
      WRITE(MESSAGE,'(A,A)') 'ERROR: Both nodes have the same ID for DUCT ID:',TRIM(DU%ID)
      CALL SHUTDOWN(MESSAGE); RETURN      
   ENDIF
   DO N = 1, ND
      IF (N==ND) CYCLE
      IF (TRIM(DU%ID)==TRIM(DUCT(N)%ID)) THEN
         WRITE(MESSAGE,'(A,A)') 'ERROR: Two ducts with the same ID. DUCT ID:',TRIM(DU%ID)
         CALL SHUTDOWN(MESSAGE); RETURN
      ENDIF
   ENDDO
   DO NN = 1, N_DUCTNODES 
      IF(TRIM(DUCTNODE(NN)%ID) == TRIM(DUCT_NODE_A(ND,1))) DU%NODE_INDEX(1) = NN
      IF(TRIM(DUCTNODE(NN)%ID) == TRIM(DUCT_NODE_A(ND,2))) DU%NODE_INDEX(2) = NN
      IF (DU%NODE_INDEX(1) > 0 .AND. DU%NODE_INDEX(2) > 0) EXIT
   ENDDO
   IF (DU%NODE_INDEX(1) <= 0) THEN
      WRITE(MESSAGE,'(A,I3,A,A)') 'ERROR: Duct node 1 not located, DUCT ',ND,', DUCT ID:',TRIM(DU%ID)
      CALL SHUTDOWN(MESSAGE); RETURN
   ENDIF
   IF (DU%NODE_INDEX(2) <= 0) THEN
      WRITE(MESSAGE,'(A,I3,A,A)') 'ERROR: Duct node 2 not located, DUCT ',ND,', DUCT ID:',TRIM(DU%ID)
      CALL SHUTDOWN(MESSAGE); RETURN
   ENDIF
   IF (DUCT_FAN_A(ND)/='null') THEN
      DU%DP_FAN = 0._EB
      DO NF = 1, N_FANS
         IF(TRIM(FAN(NF)%ID) == TRIM(DUCT_FAN_A(ND))) THEN
            DU%FAN_INDEX = NF
            EXIT
         ENDIF
      ENDDO
      IF (DU%FAN_INDEX <= 0) THEN
         WRITE(MESSAGE,'(A,I3,A,A)') 'ERROR: Fan not located for DUCT ',ND,', DUCT ID:',TRIM(DU%ID)
         CALL SHUTDOWN(MESSAGE); RETURN
      ENDIF
   ENDIF   
   IF (DUCT_AIRCOIL_A(ND)/='null') THEN
      DU%COIL_Q = 0._EB
      DO NF = 1, N_AIRCOILS
         IF(TRIM(AIRCOIL(NF)%ID) == TRIM(DUCT_AIRCOIL_A(ND))) THEN
            DU%AIRCOIL_INDEX = NF
            EXIT
         ENDIF
      ENDDO
      IF (DU%AIRCOIL_INDEX <= 0) THEN
         WRITE(MESSAGE,'(A,I3,A,A)') 'ERROR: Aircoil not located for DUCT ',ND,', DUCT ID:',TRIM(DU%ID)
         CALL SHUTDOWN(MESSAGE); RETURN
      ENDIF
   ENDIF     
ENDDO

NODE_LOOP: DO NN = 1, N_DUCTNODES
   DN => DUCTNODE(NN)
   DO N = 1, NN
      IF (N==NN) CYCLE
      IF (TRIM(DN%ID)==TRIM(DUCTNODE(N)%ID)) THEN
         WRITE(MESSAGE,'(A,A)') 'ERROR: Two duct node with the same ID. DUCTNODE ID:',TRIM(DN%ID)
         CALL SHUTDOWN(MESSAGE); RETURN
      ENDIF
   ENDDO

   ALLOCATE(DN%ZZ(N_TRACKED_SPECIES))
   DN%ZZ(1:N_TRACKED_SPECIES) = SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
   ALLOCATE(DN%ZZ_V(N_TRACKED_SPECIES))            
   DN%ZZ_V(1:N_TRACKED_SPECIES) = SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
   ZZ_GET(1:N_TRACKED_SPECIES) = DN%ZZ_V(1:N_TRACKED_SPECIES)
   DN%RSUM   = RSUM0   
   
   IF (DN%LEAKAGE) THEN
      DN%TMP  = TMPA
      DN%RHO  = RHOA
      DN%P    = P_INF
      DN%P_OLD = DN%P
      CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,DN%CP,TMPA)      
      DN%TMP_V  = DN%TMP
      DN%RSUM_V = DN%RSUM
      DN%CP_V   = DN%CP
      DN%RHO_V  = DN%RHO
      CYCLE NODE_LOOP
   ENDIF   
   IF (DN%VENT_ID /= 'null') THEN
      ALLOCATE(DN%IN_MESH(NMESHES))
      DN%IN_MESH=.FALSE.
      MESH_LOOP: DO NM = 1, NMESHES
         NODE_VENT_LOOP:DO NV = 1, MESHES(NM)%N_VENT
            IF(MESHES(NM)%VENTS(NV)%ID == DN%VENT_ID) THEN
               IF (DN%MESH_INDEX > 0) THEN
                  WRITE(MESSAGE,'(A,A)') 'ERROR: VENT for DUCTNODE is split over more than one mesh for VENT ID ',&
                                          TRIM(MESHES(NM)%VENTS(NV)%ID)
                  CALL SHUTDOWN(MESSAGE); RETURN
               ENDIF                  
               IF (DN%READ_IN .AND. MESHES(NM)%VENTS(NV)%SURF_INDEX /= HVAC_SURF_INDEX) THEN
                  WRITE(MESSAGE,'(A,A)') 'ERROR: DUCTNODE attached to VENT without SURF_ID HVAC for VENT ID ',&
                                          TRIM(MESHES(NM)%VENTS(NV)%ID)
                  CALL SHUTDOWN(MESSAGE); RETURN
               ENDIF
               IF (MESHES(NM)%VENTS(NV)%BOUNDARY_TYPE/=HVAC_BOUNDARY) THEN
                  SF => SURFACE(MESHES(NM)%VENTS(NV)%SURF_INDEX)
                  IF (ABS(SF%VEL)>TWO_EPSILON_EB .OR. ABS(SF%VOLUME_FLOW)>TWO_EPSILON_EB .OR. &
                      ABS(SF%MASS_FLUX_TOTAL)>TWO_EPSILON_EB .OR. SF%PYROLYSIS_MODEL/= PYROLYSIS_NONE) THEN
                      WRITE(MESSAGE,'(A,A)') 'Cannot leak and specify flow or pyrolysis at the same time.  VENT ID ',&
                                             TRIM(MESHES(NM)%VENTS(NV)%ID)
                      CALL SHUTDOWN(MESSAGE); RETURN
                  ENDIF
                  IF (ANY(SF%LEAK_PATH>0)) THEN
                      WRITE(MESSAGE,'(A,A)') 'Cannot specify custom leakage and zone leakage with the same surface.  VENT ID ',&
                                             TRIM(MESHES(NM)%VENTS(NV)%ID)
                      CALL SHUTDOWN(MESSAGE); RETURN
                  ENDIF
               ENDIF
               DN%IN_MESH(NM) = .TRUE.
               MESHES(NM)%VENTS(NV)%NODE_INDEX=NN
               EXIT NODE_VENT_LOOP
            ENDIF
         ENDDO NODE_VENT_LOOP
      ENDDO MESH_LOOP
   ENDIF
   IF (DN%VENT .AND. DN%AMBIENT) THEN
      WRITE(MESSAGE,'(A,I5,A,A)') 'ERROR: DUCTNODE cannot be AMBIENT and have an assigned VENT_ID, DUCTNODE ',NN,&
                                  ', DUCTNODE ID:',TRIM(DN%ID)
      CALL SHUTDOWN(MESSAGE); RETURN
   ENDIF
   IF (DN%N_DUCTS == 1 .AND. .NOT. DN%VENT .AND. .NOT. DN%AMBIENT) THEN
      WRITE(MESSAGE,'(A,I5,A,A)') 'ERROR: Internal DUCTNODE must have at least two attached ducts, DUCTNODE ',NN,&
                                  ', DUCTNODE ID:',TRIM(DN%ID)
      CALL SHUTDOWN(MESSAGE); RETURN
   ENDIF  
   IF (DN%N_DUCTS> 1 .AND. (DN%AMBIENT .OR. DN%VENT) ) THEN
      WRITE(MESSAGE,'(A,I5,A,A)') 'ERROR: External DUCTNODE can only have one attached duct, DUCTNODE ',NN,&
                                  ', DUCTNODE ID:',TRIM(DN%ID)
      CALL SHUTDOWN(MESSAGE); RETURN
   ENDIF  
   ALLOCATE(DN%DUCT_INDEX(DN%N_DUCTS))
   ALLOCATE(DN%DIR(DN%N_DUCTS))
   DN%DUCT_INDEX = -1
   DO ND = 1,DN%N_DUCTS
      DO ND2 = 1, N_DUCTS
         IF (NODE_DUCT_A(NN,ND) == DUCT(ND2)%ID) THEN
            DN%DUCT_INDEX(ND) = ND2
            IF (DUCT(ND2)%NODE_INDEX(1)==NN) THEN
               DN%DIR(ND) = -1._EB
            ELSE
               DN%DIR(ND) = 1._EB
            ENDIF
            CYCLE
         ENDIF
      ENDDO
      IF (DN%DUCT_INDEX(ND)==-1) THEN
         WRITE(MESSAGE,'(A,I5,A,I5,A,A)') 'ERROR: DUCT ',ND,' not found for DUCTNODE ',NN,&
                                  ', DUCTNODE ID:',TRIM(DN%ID)
         CALL SHUTDOWN(MESSAGE); RETURN
      ENDIF  
   ENDDO

   !Initialize duct node properties
  
   IF (STRATIFICATION .AND. DN%XYZ(3) > -1.E9_EB) THEN      
      DN%TMP  = TMPA + LAPSE_RATE*DN%XYZ(3)    
      IF (ABS(LAPSE_RATE)>TWO_EPSILON_EB) THEN      
         DN%P = P_INF*(DN%TMP/TMPA)**(GVEC(3)/RSUM0/LAPSE_RATE)
      ELSE
         DN%P = P_INF*EXP(GVEC(3)*(DN%XYZ(3)-GROUND_LEVEL)/(RSUM0*TMPA))
      ENDIF      
      DN%RHO   =  DN%P/(DN%TMP*RSUM0)
   ELSE
      DN%TMP  = TMPA
      DN%P      = P_INF
      DN%RHO    = RHOA
   ENDIF
   DN%P_OLD = DN%P
   IF (DN%VENT) DN%P = -1.E10_EB
   ZZ_GET(1:N_TRACKED_SPECIES) = DN%ZZ_V(1:N_TRACKED_SPECIES)
   CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,DN%CP,DN%TMP)      
   DN%TMP_V  = DN%TMP
   DN%RSUM_V = DN%RSUM
   DN%CP_V   = DN%CP
   DN%RHO_V  = DN%RHO
   IF(TRIM(NODE_FILTER_A(NN))/='null') THEN
      DO N = 1,N_FILTERS
         IF(TRIM(NODE_FILTER_A(NN))==TRIM(FILTER(N)%ID)) THEN
            DN%FILTER_INDEX = N
            EXIT
         ENDIF
         IF (N==N_FILTERS) THEN
            WRITE(MESSAGE,'(A,A,A,A,A)') 'ERROR: Problem with DUCTNODE:',TRIM(DN%ID), &
                                         ',FILTER ',TRIM(NODE_FILTER_A(NN)),' not found'
            CALL SHUTDOWN(MESSAGE); RETURN
         ENDIF
      ENDDO
   ENDIF
ENDDO NODE_LOOP

!Temp arrays for input processing
IF (ALLOCATED(DUCT_NODE_A)) DEALLOCATE(DUCT_NODE_A)
IF (ALLOCATED(NODE_DUCT_A)) DEALLOCATE(NODE_DUCT_A)
IF (ALLOCATED(NODE_FILTER_A)) DEALLOCATE(NODE_FILTER_A)
IF (ALLOCATED(DUCT_FAN_A)) DEALLOCATE(DUCT_FAN_A)

CALL DETERMINE_FIXED_ELEMENTS(0._EB)

ALLOCATE(NODE_P(1:N_DUCTNODES,1:NMESHES))
ALLOCATE(NODE_TMP(1:N_DUCTNODES,1:NMESHES))
ALLOCATE(NODE_TMP_EX(1:N_DUCTNODES,1:NMESHES))
NODE_TMP_EX=0._EB
ALLOCATE(NODE_RHO(1:N_DUCTNODES,1:NMESHES))
ALLOCATE(NODE_H(1:N_DUCTNODES,1:NMESHES))
ALLOCATE(NODE_X(1:N_DUCTNODES,1:NMESHES))
ALLOCATE(NODE_Y(1:N_DUCTNODES,1:NMESHES))
ALLOCATE(NODE_Z(1:N_DUCTNODES,1:NMESHES))
ALLOCATE(NODE_ZONE(1:N_DUCTNODES,1:NMESHES))
ALLOCATE(NODE_AREA(1:N_DUCTNODES,1:NMESHES))
ALLOCATE(NODE_AREA_EX(1:N_DUCTNODES,1:NMESHES))
NODE_AREA_EX = 0._EB
ALLOCATE(NODE_ZZ(1:N_DUCTNODES,1:N_TRACKED_SPECIES,1:NMESHES))
ALLOCATE(NODE_ZZ_EX(1:N_DUCTNODES,1:N_TRACKED_SPECIES,1:NMESHES))
NODE_ZZ_EX = 0._EB

ALLOCATE(DUCT_MF(1:N_DUCTS,1:NMESHES))
DUCT_MF(1:N_DUCTS,1:NMESHES) = 0._EB

TUSED(16,1)=TUSED(16,1)+SECOND()-TNOW

RETURN

END SUBROUTINE PROC_HVAC

SUBROUTINE HVAC_CALC(T,FIRST_PASS)
!Solve for flows in the HVAC networks
INTEGER :: NNE,NN
REAL(EB), INTENT(INOUT) :: T
LOGICAL :: CHANGE=.TRUE.
LOGICAL, INTENT(IN):: FIRST_PASS
TYPE(NETWORK_TYPE), POINTER:: NE=>NULL()

IF (CORRECTOR) THEN
   DUCT%VEL(OLD) = DUCT%VEL(NEW)
   DO NN=1,N_DUCTNODES
      IF(DUCTNODE(NN)%FILTER_INDEX > 0) DUCTNODE(NN)%FILTER_LOADING(:,OLD)=DUCTNODE(NN)%FILTER_LOADING(:,NEW)
      DUCTNODE(NN)%P_OLD = DUCTNODE(NN)%P
   ENDDO
   RETURN
ENDIF

IF (FIRST_PASS) THEN
   CALL COLLAPSE_HVAC_BC
   CALL FIND_NETWORKS(CHANGE,T)
ENDIF

ITER = 0
DO NNE = 1, N_NETWORKS
   NE =>NETWORK(NNE)
   CALL SET_GUESS(NNE,T)  
ENDDO

IF (N_ZONE >0) ALLOCATE(DPSTAR(1:N_ZONE))

CALL DPSTARCALC
DUCTNODE%P = DUCTNODE%P - P_INF 

DO NNE = 1, N_NETWORKS
   NE =>NETWORK(NNE)
   IF (NE%N_MATRIX > 0) THEN 
      ITER = 0
      ALLOCATE(LHS(NE%N_MATRIX,NE%N_MATRIX))
      ALLOCATE(RHS(NE%N_MATRIX))
      DO WHILE (ITER < ITER_MAX)
         LHS = 0._EB
         RHS = 0._EB
         CALL SET_DONOR(NNE)
         CALL UPDATE_LOSS(NNE)
         IF (N_AIRCOILS > 0) CALL COIL_UPDATE(T)
         CALL RHSNODE(NNE)         
         CALL RHSDUCT(NNE)   
         CALL LHSNODE(NNE)
         CALL LHSDUCT(NNE)
         CALL MATRIX_SOLVE(NNE)
         CALL HVAC_UPDATE(NNE)
         CALL CONVERGENCE_CHECK(NNE)
         ITER = ITER + 1
         IF (ITER < ITER_MAX) CALL SET_GUESS(NNE,T)       
      ENDDO
      DEALLOCATE(LHS)
      DEALLOCATE(RHS)
   ELSE
      CALL SET_DONOR(NNE)
      IF (N_AIRCOILS > 0) CALL COIL_UPDATE(T)
      CALL HVAC_UPDATE(NNE)
   ENDIF
ENDDO

DUCTNODE%P = DUCTNODE%P + P_INF 

CALL UPDATE_NODE_BC

IF (ALLOCATED(DPSTAR)) DEALLOCATE(DPSTAR)

END SUBROUTINE HVAC_CALC


SUBROUTINE MATRIX_SOLVE(NNE)
USE MATH_FUNCTIONS,ONLY : GAUSSJ
INTEGER :: NNE,IERR,ND,NN
TYPE(NETWORK_TYPE), POINTER :: NE=>NULL()
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()

NE =>NETWORK(NNE)
CALL GAUSSJ(LHS,NE%N_MATRIX,NE%N_MATRIX,RHS,1,1,IERR)
DO ND = 1,NE%N_DUCTS
   DU=>DUCT(NE%DUCT_INDEX(ND))
   IF (DU%FIXED .OR. DU%AREA < TWO_EPSILON_EB) CYCLE
   DU%VEL(NEW) = RHS(NE%MATRIX_INDEX(ND))
ENDDO
DO NN = 1,NE%N_DUCTNODES
   DN=>DUCTNODE(NE%NODE_INDEX(NN))
   IF (DN%FIXED) CYCLE
   DN%P = RHS(NE%MATRIX_INDEX(NE%N_DUCTS+NN))
ENDDO

END SUBROUTINE MATRIX_SOLVE


SUBROUTINE HVAC_UPDATE(NNE)

!Iterate duct network to update all ducts and nodes

USE COMP_FUNCTIONS, ONLY: SECOND
USE PHYSICAL_FUNCTIONS, ONLY : GET_AVERAGE_SPECIFIC_HEAT,GET_SPECIFIC_GAS_CONSTANT
REAL(EB) :: TNOW,MTOT,ETOT,VTOT,ZZTOT(1:N_TRACKED_SPECIES),TGUESS,VFLOW,ZZ_GET(1:N_TRACKED_SPECIES),CP,CP2,DCPDT
INTEGER, INTENT(IN) :: NNE
INTEGER :: NN,ND,NS,ITMP,ITCOUNT
LOGICAL :: CYCLE_FLAG
TYPE (DUCTNODE_TYPE), POINTER :: DN=>NULL(),DN2=>NULL()
TYPE (DUCT_TYPE), POINTER :: DU=>NULL()
TYPE (NETWORK_TYPE), POINTER :: NE=>NULL()

TNOW=SECOND()
NE => NETWORK(NNE)
DUCT%UPDATED = .FALSE.
DO NN = 1,NE%N_DUCTNODES
   DN=>DUCTNODE(NE%NODE_INDEX(NN))
   DN%UPDATED = .FALSE.
   IF (DN%VENT .OR. DN%LEAKAGE) THEN   
      DU => DUCT(DN%DUCT_INDEX(1))
      IF (DU%VEL(NEW)*DN%DIR(1) < -TWO_EPSILON_EB) DN%UPDATED = .TRUE.
   ENDIF
ENDDO
DO ND = 1,NE%N_DUCTS
   DUCT(NE%DUCT_INDEX(ND))%UPDATED = .FALSE.
ENDDO

ITER_LOOP: DO
   CYCLE_FLAG = .FALSE.
   DUCT_LOOP:DO ND = 1,NE%N_DUCTS
      DU=>DUCT(NE%DUCT_INDEX(ND))
      IF (DU%UPDATED) CYCLE DUCT_LOOP
      CYCLE_FLAG = .TRUE.
      IF (DU%VEL(NEW) > TWO_EPSILON_EB) THEN
         DN => DUCTNODE(DU%NODE_INDEX(1))
      ELSEIF (DU%VEL(NEW) < -TWO_EPSILON_EB) THEN
         DN => DUCTNODE(DU%NODE_INDEX(2))
      ELSE
         DU%UPDATED = .TRUE.
         DU%VEL(NEW) = 0._EB
         DU%RHO_D = 0.5_EB*(DUCTNODE(DU%NODE_INDEX(1))%RHO+DUCTNODE(DU%NODE_INDEX(2))%RHO)
         CYCLE DUCT_LOOP
      ENDIF
      IF (DN%UPDATED) THEN
         DU%RHO_D  = DN%RHO
         DU%TMP_D  = DN%TMP
         DU%CP_D   = DN%CP         
         DU%UPDATED = .TRUE.
         DU%ZZ(:) = DN%ZZ(:)
      ENDIF
   ENDDO DUCT_LOOP

   NODE_LOOP:DO NN = 1,NE%N_DUCTNODES   
      DN=>DUCTNODE(NE%NODE_INDEX(NN))
      IF(DN%UPDATED) CYCLE NODE_LOOP
      CYCLE_FLAG = .TRUE.
      VTOT = 0._EB
      MTOT = 0._EB
      ETOT = 0._EB
      ZZTOT = 0._EB
      TGUESS = 0._EB
      DO ND = 1,DN%N_DUCTS
         DU => DUCT(DN%DUCT_INDEX(ND))   
         IF (DU%AREA<=TWO_EPSILON_EB) CYCLE
         IF (DU%VEL(NEW)*DN%DIR(ND) < 0._EB) CYCLE
         IF (DU%VEL(NEW)*DN%DIR(ND) > 0._EB .AND. .NOT. DU%UPDATED) CYCLE NODE_LOOP
         VFLOW = ABS(DU%VEL(NEW)*DU%AREA)
         VTOT = VTOT + VFLOW
         MTOT = MTOT + VFLOW * DU%RHO_D         
         ETOT = ETOT + VFLOW * DU%RHO_D * DU%TMP_D * DU%CP_D + DU%COIL_Q

         IF (STRATIFICATION .AND. .NOT. DN%VENT ) THEN
            IF (DU%NODE_INDEX(1)==NE%NODE_INDEX(NN)) THEN
               DN2=>DUCTNODE(DU%NODE_INDEX(2))
            ELSE
               DN2=>DUCTNODE(DU%NODE_INDEX(1))       
            ENDIF
            ETOT = ETOT + DU%RHO_D*VFLOW*GVEC(3)*(DN%XYZ(3)-DN2%XYZ(3))
         ENDIF
         ZZTOT = ZZTOT + VFLOW * DU%RHO_D * DU%ZZ
         TGUESS = TGUESS + VFLOW * DU%RHO_D * DU%TMP_D
         IF (DN%FILTER_INDEX > 0) THEN
            MTOT = MTOT - SUM(DN%FILTER_LOADING(:,3))
            ZZTOT = ZZTOT - DN%FILTER_LOADING(:,3)
            TGUESS = TGUESS - SUM(DN%FILTER_LOADING(:,3))*DU%TMP_D
            ITMP = MIN(5000,NINT(DU%TMP_D))
            DO NS = 1,N_TRACKED_SPECIES
               ETOT = ETOT - CPBAR_Z(ITMP,NS)*DU%TMP_D*DN%FILTER_LOADING(NS,3)
               IF (STRATIFICATION .AND. .NOT. DN%VENT) ETOT = ETOT - DN%FILTER_LOADING(NS,3)*GVEC(3)*(DN%XYZ(3)-DN2%XYZ(3))
            ENDDO
         ENDIF
      ENDDO

      DN%UPDATED = .TRUE.
      IF (ABS(MTOT)<=TWO_EPSILON_EB) CYCLE NODE_LOOP
      ZZ_GET = 0._EB
      DN%ZZ(:)  = ZZTOT/MTOT
      ZZ_GET(1:N_TRACKED_SPECIES) = DN%ZZ(1:N_TRACKED_SPECIES)
      CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,DN%RSUM)
      TGUESS = TGUESS / MTOT      
      ETOT = ETOT/ MTOT
      DN%TMP = TGUESS

      ITCOUNT = 0
      CP_LOOP: DO
         ITCOUNT = ITCOUNT + 1
         CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CP,TGUESS)
         IF (TGUESS>1._EB) THEN
            CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CP2,TGUESS-1._EB)
            DCPDT = CP - CP2
         ELSE
            CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CP2,TGUESS+1._EB)
            DCPDT = CP2- CP
         ENDIF

         DN%TMP =TGUESS+(ETOT-CP*TGUESS)/(CP+TGUESS*DCPDT)
         IF (ABS(DN%TMP - TGUESS) < TWO_EPSILON_EB) EXIT CP_LOOP
         IF ((DN%TMP - TGUESS)/DN%TMP < 0.0005_EB) EXIT CP_LOOP
         IF (ITCOUNT > 10) THEN
            DN%TMP = 0.5_EB*(DN%TMP+TGUESS)
            CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,DN%CP,DN%TMP)
            EXIT CP_LOOP
         ENDIF
         TGUESS = DN%TMP
      ENDDO CP_LOOP
      DN%CP = CP
      DN%RHO = (DN%P+P_INF)/(DN%RSUM*DN%TMP)
   ENDDO NODE_LOOP

   IF (.NOT. CYCLE_FLAG) EXIT ITER_LOOP

ENDDO ITER_LOOP

TUSED(16,1)=TUSED(16,1)+SECOND()-TNOW

END SUBROUTINE HVAC_UPDATE


SUBROUTINE RHSNODE(NETWORK_INDEX)
USE GLOBAL_CONSTANTS
INTEGER, INTENT(IN)::NETWORK_INDEX
INTEGER :: NN,ND, ARRAYLOC
TYPE(NETWORK_TYPE), POINTER::NE=>NULL()
TYPE(DUCT_TYPE), POINTER::DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER::DN=>NULL()

NE => NETWORK(NETWORK_INDEX)
DO NN = 1, NE%N_DUCTNODES
   DN => DUCTNODE(NE%NODE_INDEX(NN))
   IF (DN%FIXED .OR. DN%VENT .OR. DN%AMBIENT .OR. DN%LEAKAGE) CYCLE
   ARRAYLOC = NE%MATRIX_INDEX(NE%N_DUCTS+DUCTNODE_NE(NE%NODE_INDEX(NN)))
   DO ND = 1,DN%N_DUCTS
      DU => DUCT(DN%DUCT_INDEX(ND))
      IF (DU%FIXED) RHS(ARRAYLOC) = RHS(ARRAYLOC) + DN%DIR(ND)*DU%RHO_D*DU%VOLUME_FLOW
   END DO
   IF (DN%FILTER_INDEX > 0) RHS(ARRAYLOC) = RHS(ARRAYLOC) - SUM(DN%FILTER_LOADING(:,3))
   
ENDDO

END SUBROUTINE RHSNODE


SUBROUTINE LHSNODE(NETWORK_INDEX)
USE GLOBAL_CONSTANTS
INTEGER, INTENT(IN)::NETWORK_INDEX
INTEGER :: NN,ND, ARRAYLOC1,ARRAYLOC2
TYPE(NETWORK_TYPE), POINTER::NE=>NULL()
TYPE(DUCT_TYPE), POINTER::DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER::DN=>NULL()

NE => NETWORK(NETWORK_INDEX)
DO NN = 1, NE%N_DUCTNODES
   DN => DUCTNODE(NE%NODE_INDEX(NN))
   IF (DN%FIXED .OR. DN%VENT .OR. DN%LEAKAGE) CYCLE
   ARRAYLOC1 = NE%MATRIX_INDEX(NE%N_DUCTS+DUCTNODE_NE(NE%NODE_INDEX(NN)))
   DO ND = 1,DN%N_DUCTS
      DU => DUCT(DN%DUCT_INDEX(ND))
      IF (DU%FIXED .OR. DU%AREA <=TWO_EPSILON_EB) CYCLE
      ARRAYLOC2 = NE%MATRIX_INDEX(DUCT_NE(DN%DUCT_INDEX(ND)))
      LHS(ARRAYLOC1,ARRAYLOC2) = -DN%DIR(ND)*DU%RHO_D*DU%AREA      
   END DO
ENDDO

END SUBROUTINE LHSNODE


SUBROUTINE DPSTARCALC

USE GLOBAL_CONSTANTS
INTEGER :: NN,IPZ
TYPE(DUCT_TYPE), POINTER::DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER::DN=>NULL()
TYPE(P_ZONE_TYPE), POINTER::PZ=>NULL()

DO IPZ = 1,N_ZONE
   PZ => P_ZONE(IPZ)
   IF (PZ%N_DUCTNODES==0) CYCLE
   DPSTAR(IPZ) = P_ZONE(IPZ)%DPSTAR * DT
   DO NN = 1,PZ%N_DUCTNODES
      DN=>DUCTNODE(PZ%NODE_INDEX(NN))
      DU=>DUCT(DN%DUCT_INDEX(1))
      DPSTAR(IPZ) = DPSTAR(IPZ)  - DN%DIR(1) * DU%AREA * DU%VEL(OLD) * DT/PSUM(IPZ,1)
      IF (DU%FIXED) DPSTAR(IPZ) = DPSTAR(IPZ)  + DN%DIR(1) * DU%AREA * DU%VEL(NEW) * DT/PSUM(IPZ,1)
   ENDDO   
ENDDO

END SUBROUTINE DPSTARCALC


SUBROUTINE RHSDUCT(NETWORK_INDEX)

USE GLOBAL_CONSTANTS
INTEGER, INTENT(IN)::NETWORK_INDEX
INTEGER :: ND, ARRAYLOC,IPZ
REAL(EB) :: HEAD,XYZ(3)
TYPE(NETWORK_TYPE), POINTER::NE=>NULL()
TYPE(DUCT_TYPE), POINTER::DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER::DN=>NULL()

NE => NETWORK(NETWORK_INDEX)

DO ND = 1, NE%N_DUCTS
   DU => DUCT(NE%DUCT_INDEX(ND))
   IF (DU%FIXED .OR. DU%AREA < TWO_EPSILON_EB) CYCLE
   HEAD = 0._EB
   ARRAYLOC = NE%MATRIX_INDEX(DUCT_NE(NE%DUCT_INDEX(ND)))
   DN=>DUCTNODE(DU%NODE_INDEX(1))
   IF (DN%AMBIENT) THEN
      HEAD = HEAD + DN%P
   ELSEIF (DN%VENT .OR. DN%LEAKAGE) THEN
      HEAD = HEAD + DN%P   
      IF (N_ZONE > 0) THEN
         IPZ = DN%ZONE_INDEX
         IF (IPZ > 0) HEAD = HEAD + DPSTAR(IPZ)
      ENDIF
   ENDIF
   XYZ = DN%XYZ
   DN=>DUCTNODE(DU%NODE_INDEX(2))
   IF (DN%AMBIENT) THEN
      HEAD = HEAD - DN%P
   ELSEIF (DN%VENT .OR. DN%LEAKAGE) THEN
      HEAD = HEAD - DN%P   
      IF (N_ZONE > 0) THEN         
         IPZ = DN%ZONE_INDEX
         IF (IPZ > 0) HEAD = HEAD - DPSTAR(IPZ)
      ENDIF
   ENDIF
   
   XYZ = DN%XYZ - XYZ
   IF(.NOT. DU%LEAKAGE) THEN
     ! IF (STRATIFICATION) THEN

    !     HEAD = HEAD + (DN%P+P_INF)*(1._EB-EXP(-(GVEC(1)*XYZ(1)+GVEC(2)*XYZ(2)+GVEC(3)*XYZ(3))/(DU%RSUM_D*DU%TMP_D)))
    !  ELSE
         HEAD = HEAD + (GVEC(1)*XYZ(1)+GVEC(2)*XYZ(2)+GVEC(3)*XYZ(3))*DU%RHO_D
    !  ENDIF
   ENDIF
   RHS(ARRAYLOC) = DU%VEL(OLD)+DT/DU%LENGTH*(HEAD+DU%DP_FAN)/DU%RHO_D + &
                   0.5_EB*DU%TOTAL_LOSS*ABS(DU%VEL(NEW))*DU%VEL(GUESS)*DT/DU%LENGTH
ENDDO

END SUBROUTINE RHSDUCT


SUBROUTINE LHSDUCT(NETWORK_INDEX)
USE GLOBAL_CONSTANTS
INTEGER, INTENT(IN)::NETWORK_INDEX
INTEGER :: NN,ND, ARRAYLOC1,ARRAYLOC2
TYPE(NETWORK_TYPE), POINTER::NE=>NULL()
TYPE(DUCT_TYPE), POINTER::DU=>NULL(),DU2=>NULL()
TYPE(DUCTNODE_TYPE), POINTER::DN=>NULL(),DN2=>NULL()
TYPE(P_ZONE_TYPE), POINTER::PZ=>NULL()
NE => NETWORK(NETWORK_INDEX)
DUCT_LOOP: DO ND = 1, NE%N_DUCTS
   DU => DUCT(NE%DUCT_INDEX(ND))
   IF (DU%FIXED .OR. DU%AREA < TWO_EPSILON_EB) CYCLE DUCT_LOOP
   ARRAYLOC1 = NE%MATRIX_INDEX(DUCT_NE(NE%DUCT_INDEX(ND)))
   LHS(ARRAYLOC1,ARRAYLOC1) = 1._EB+0.5_EB*DU%TOTAL_LOSS*ABS(DU%VEL(NEW)+DU%VEL(GUESS))*DT/DU%LENGTH
   DN=>DUCTNODE(DU%NODE_INDEX(1))
   IF (.NOT. DN%VENT) THEN
      IF (.NOT. DN%AMBIENT .AND. .NOT. DN%LEAKAGE) THEN
         ARRAYLOC2 = NE%MATRIX_INDEX(NE%N_DUCTS+DUCTNODE_NE(DU%NODE_INDEX(1)))
         LHS(ARRAYLOC1,ARRAYLOC2) = -DT/(DU%RHO_D*DU%LENGTH)
      ENDIF
      IF (DN%LEAKAGE .AND. .NOT. DN%AMBIENT) THEN
         PZ => P_ZONE(DN%ZONE_INDEX)
         DO NN=1,PZ%N_DUCTNODES
            DN2=>DUCTNODE(PZ%NODE_INDEX(NN))
            DU2=>DUCT(DN2%DUCT_INDEX(1))
            IF (DU2%AREA < TWO_EPSILON_EB .OR. DU2%FIXED) CYCLE
            ARRAYLOC2 = NE%MATRIX_INDEX(DUCT_NE(DN2%DUCT_INDEX(1)))
            LHS(ARRAYLOC1,ARRAYLOC2) = LHS(ARRAYLOC1,ARRAYLOC2) - DN2%DIR(1)*DU2%AREA*DT**2 / &
                                       (PSUM(DN%ZONE_INDEX,1)*DU%RHO_D*DU%LENGTH)
         ENDDO
      ENDIF
   ELSE
      IF (DN%ZONE_INDEX >0) THEN
         PZ => P_ZONE(DN%ZONE_INDEX)
         DO NN=1,PZ%N_DUCTNODES
            DN2=>DUCTNODE(PZ%NODE_INDEX(NN))
            DU2=>DUCT(DN2%DUCT_INDEX(1))
            IF (DU2%AREA < TWO_EPSILON_EB .OR. DU2%FIXED) CYCLE
            ARRAYLOC2 = NE%MATRIX_INDEX(DUCT_NE(DN2%DUCT_INDEX(1)))
            LHS(ARRAYLOC1,ARRAYLOC2) = LHS(ARRAYLOC1,ARRAYLOC2) - DN2%DIR(1)*DU2%AREA*DT**2 / &
                                       (PSUM(DN%ZONE_INDEX,1)*DU%RHO_D*DU%LENGTH)
         ENDDO
      ENDIF
   ENDIF
   DN=>DUCTNODE(DU%NODE_INDEX(2))
   IF (.NOT. DN%VENT) THEN
      IF (.NOT. DN%AMBIENT .AND. .NOT. DN%LEAKAGE) THEN
         ARRAYLOC2 = NE%MATRIX_INDEX(NE%N_DUCTS+DUCTNODE_NE(DU%NODE_INDEX(2)))       
         LHS(ARRAYLOC1,ARRAYLOC2) = DT/(DU%RHO_D*DU%LENGTH)
      ENDIF
      IF (DN%LEAKAGE .AND. .NOT. DN%AMBIENT) THEN
         PZ => P_ZONE(DN%ZONE_INDEX)
         DO NN=1,PZ%N_DUCTNODES
            DN2=>DUCTNODE(PZ%NODE_INDEX(NN))
            DU2=>DUCT(DN2%DUCT_INDEX(1))
            IF (DU2%AREA < TWO_EPSILON_EB .OR. DU2%FIXED) CYCLE  
            ARRAYLOC2 = NE%MATRIX_INDEX(DUCT_NE(DN2%DUCT_INDEX(1)))
            LHS(ARRAYLOC1,ARRAYLOC2) = LHS(ARRAYLOC1,ARRAYLOC2) + DN2%DIR(1)*DU2%AREA*DT**2 / &
                                       (PSUM(DN%ZONE_INDEX,1)*DU%RHO_D*DU%LENGTH)
         ENDDO
      ENDIF
   ELSE
      IF (DN%ZONE_INDEX >0) THEN
         PZ => P_ZONE(DN%ZONE_INDEX)
         DO NN=1,PZ%N_DUCTNODES
            DN2=>DUCTNODE(PZ%NODE_INDEX(NN))
            DU2=>DUCT(DN2%DUCT_INDEX(1))
            IF (DU2%AREA < TWO_EPSILON_EB .OR. DU2%FIXED) CYCLE  
            ARRAYLOC2 = NE%MATRIX_INDEX(DUCT_NE(DN2%DUCT_INDEX(1)))
            LHS(ARRAYLOC1,ARRAYLOC2) = LHS(ARRAYLOC1,ARRAYLOC2) + DN2%DIR(1)*DU2%AREA*DT**2 / &
                                       (PSUM(DN%ZONE_INDEX,1)*DU%RHO_D*DU%LENGTH)
         ENDDO
      ENDIF
   ENDIF
ENDDO DUCT_LOOP

END SUBROUTINE LHSDUCT


SUBROUTINE UPDATE_FAN(T,DUCT_INDEX)
USE MATH_FUNCTIONS, ONLY : EVALUATE_RAMP
INTEGER, INTENT(IN) :: DUCT_INDEX
REAL(EB), INTENT(IN) :: T
REAL(EB) :: TSI
TYPE(DUCT_TYPE), POINTER::DU=>NULL()
TYPE(FAN_TYPE), POINTER::FA=>NULL()
REAL(EB) :: DEL_P,VDOT

DU=> DUCT(DUCT_INDEX)
FA=> FAN(DU%FAN_INDEX)
TSI = T - DU%FAN_ON_TIME
SELECT CASE (FA%FAN_TYPE)
   CASE(1) !Constant flow
      DU%VEL(NEW) = FA%VOL_FLOW/DU%AREA*EVALUATE_RAMP(TSI,FA%TAU,FA%SPIN_INDEX)
      IF (DU%REVERSE) DU%VEL(NEW)=-DU%VEL(NEW)
      DU%VOLUME_FLOW = DU%VEL(NEW)*DU%AREA 
      RETURN     
   CASE(2) !Quadratic
      VDOT = DU%VEL(NEW)*DU%AREA
      IF (DU%REVERSE) VDOT = -VDOT
      VDOT = MAX(0._EB,MIN(VDOT,FA%MAX_FLOW))
      DEL_P = FA%MAX_PRES - FA%MAX_PRES*(VDOT/FA%MAX_FLOW)**2
      DEL_P = DEL_P*EVALUATE_RAMP(TSI,FA%TAU,FA%SPIN_INDEX)            
   CASE(3) !Fan curve
      VDOT = DU%VEL(NEW)*DU%AREA
      IF (DU%REVERSE) VDOT = -VDOT
      DEL_P = EVALUATE_RAMP(VDOT,0._EB,FA%RAMP_INDEX)*EVALUATE_RAMP(TSI,FA%TAU,FA%SPIN_INDEX)      
END SELECT

IF (DU%REVERSE) DEL_P=-DEL_P
DU%DP_FAN = 0.2_EB*DEL_P+0.8_EB*DU%DP_FAN
END SUBROUTINE UPDATE_FAN


SUBROUTINE HVAC_BC_IN(NM)

! Average gas properties at VENTs connected to HVAC system

USE PHYSICAL_FUNCTIONS, ONLY : GET_SPECIFIC_GAS_CONSTANT,GET_AVERAGE_SPECIFIC_HEAT
INTEGER, INTENT(IN) :: NM
INTEGER :: II,JJ,KK,IW,IOR,IZ1,IZ2
REAL(EB) :: ZZ_GET(1:N_TRACKED_SPECIES),AREA,TNOW,P_AVE,CPBAR
REAL(EB), POINTER, DIMENSION(:,:,:) :: RHOP,UP,VP,WP,HP
REAL(EB), POINTER, DIMENSION(:,:) :: PBARP
TYPE (MESH_TYPE),POINTER :: M=>NULL()
TYPE (SURFACE_TYPE), POINTER :: SF=>NULL()
TYPE (WALL_TYPE), POINTER :: WC=>NULL()

IF (EVACUATION_ONLY(NM)) RETURN

TNOW=SECOND()

M => MESHES(NM)
CALL POINT_TO_MESH(NM)

NODE_X(:,NM) = 0._EB
NODE_Y(:,NM) = 0._EB
NODE_Z(:,NM) = 0._EB
NODE_ZONE(:,NM) = 0
NODE_H(:,NM) = 0._EB
NODE_P(:,NM) = 0._EB
NODE_TMP(:,NM)= 0._EB
NODE_RHO(:,NM) = 0._EB
NODE_AREA(:,NM) = 0._EB
NODE_ZZ(:,:,NM) = 0._EB
ZZ_GET = 0._EB

IF (PREDICTOR) THEN
   PBARP => PBAR
   RHOP  => RHO
   HP    => H
   UP    => U
   VP    => V
   WP    => W      
ELSE
   PBARP => PBAR_S
   RHOP  => RHOS
   HP    => HS
   UP    => US
   VP    => VS
   WP    => WS      
ENDIF

WALL_LOOP: DO IW = 1,N_EXTERNAL_WALL_CELLS+N_INTERNAL_WALL_CELLS
   WC=>WALL(IW)
   SF => SURFACE(WC%SURF_INDEX)
   ZONE_LEAK_IF: IF (ALL(SF%LEAK_PATH < 0)) THEN
      IF (WC%VENT_INDEX == 0) CYCLE WALL_LOOP
      IF (VENTS(WC%VENT_INDEX)%NODE_INDEX < 0) CYCLE WALL_LOOP
      WC%NODE_INDEX = VENTS(WC%VENT_INDEX)%NODE_INDEX
      IOR = WC%ONE_D%IOR
      II = WC%ONE_D%IIG
      JJ = WC%ONE_D%JJG
      KK = WC%ONE_D%KKG
      AREA = WC%AW
      IF (WC%PRESSURE_ZONE /= NODE_ZONE(WC%NODE_INDEX,NM)) THEN
         IF (NODE_ZONE(WC%NODE_INDEX,NM) == 0) THEN
            NODE_ZONE(WC%NODE_INDEX,NM) = WC%PRESSURE_ZONE
         ELSE
            WRITE(MESSAGE,'(A,A)') 'ERROR: DUCTNODE must lie with a single pressure zone. Node: ',TRIM(DUCTNODE(WC%NODE_INDEX)%ID)
            CALL SHUTDOWN(MESSAGE); RETURN
         ENDIF
      ENDIF
            
      NODE_AREA(WC%NODE_INDEX,NM) = NODE_AREA(WC%NODE_INDEX,NM) + AREA
      NODE_RHO(WC%NODE_INDEX,NM) = NODE_RHO(WC%NODE_INDEX,NM) + RHOP(II,JJ,KK)*AREA

      ZZ_GET(1:N_TRACKED_SPECIES) = ZZ(II,JJ,KK,1:N_TRACKED_SPECIES)
      NODE_ZZ(WC%NODE_INDEX,1:N_TRACKED_SPECIES,NM) = NODE_ZZ(WC%NODE_INDEX,1:N_TRACKED_SPECIES,NM) + &
                                                      ZZ_GET(1:N_TRACKED_SPECIES)*AREA*RHO(II,JJ,KK)
      CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CPBAR,TMP(II,JJ,KK))
      NODE_TMP(WC%NODE_INDEX,NM) = NODE_TMP(WC%NODE_INDEX,NM) + TMP(II,JJ,KK)*AREA
      NODE_H(WC%NODE_INDEX,NM) = NODE_H(WC%NODE_INDEX,NM) + CPBAR * TMP(II,JJ,KK) * RHOP(II,JJ,KK) * AREA
           
      SELECT CASE (IOR)
         CASE (1)
            P_AVE = PBARP(KK,WC%PRESSURE_ZONE)
            NODE_X(WC%NODE_INDEX,NM) = NODE_X(WC%NODE_INDEX,NM) + X(II-1)*AREA
            NODE_Y(WC%NODE_INDEX,NM) = NODE_Y(WC%NODE_INDEX,NM) + YC(JJ)*AREA            
            NODE_Z(WC%NODE_INDEX,NM) = NODE_Z(WC%NODE_INDEX,NM) + ZC(KK)*AREA
         CASE(-1)
            P_AVE = PBARP(KK,WC%PRESSURE_ZONE)
            NODE_X(WC%NODE_INDEX,NM) = NODE_X(WC%NODE_INDEX,NM) + X(II)*AREA
            NODE_Y(WC%NODE_INDEX,NM) = NODE_Y(WC%NODE_INDEX,NM) + YC(JJ)*AREA            
            NODE_Z(WC%NODE_INDEX,NM) = NODE_Z(WC%NODE_INDEX,NM) + ZC(KK)*AREA
         CASE (2)
            P_AVE = PBARP(KK,WC%PRESSURE_ZONE)
            NODE_X(WC%NODE_INDEX,NM) = NODE_X(WC%NODE_INDEX,NM) + XC(II)*AREA
            NODE_Y(WC%NODE_INDEX,NM) = NODE_Y(WC%NODE_INDEX,NM) + Y(JJ-1)*AREA            
            NODE_Z(WC%NODE_INDEX,NM) = NODE_Z(WC%NODE_INDEX,NM) + ZC(KK)*AREA
         CASE(-2)
            P_AVE = PBARP(KK,WC%PRESSURE_ZONE)
            NODE_X(WC%NODE_INDEX,NM) = NODE_X(WC%NODE_INDEX,NM) + XC(II)*AREA
            NODE_Y(WC%NODE_INDEX,NM) = NODE_Y(WC%NODE_INDEX,NM) + Y(JJ)*AREA            
            NODE_Z(WC%NODE_INDEX,NM) = NODE_Z(WC%NODE_INDEX,NM) + ZC(KK)*AREA
         CASE (3)
            P_AVE = 0.5_EB*(PBARP(KK-1,WC%PRESSURE_ZONE)+PBARP(KK,WC%PRESSURE_ZONE))
            NODE_X(WC%NODE_INDEX,NM) = NODE_X(WC%NODE_INDEX,NM) + XC(II)*AREA
            NODE_Y(WC%NODE_INDEX,NM) = NODE_Y(WC%NODE_INDEX,NM) + YC(JJ)*AREA            
            NODE_Z(WC%NODE_INDEX,NM) = NODE_Z(WC%NODE_INDEX,NM) + Z(KK-1)*AREA
         CASE (-3)
            P_AVE = 0.5_EB*(PBARP(KK,WC%PRESSURE_ZONE)+PBARP(KK+1,WC%PRESSURE_ZONE))
            NODE_X(WC%NODE_INDEX,NM) = NODE_X(WC%NODE_INDEX,NM) + XC(II)*AREA
            NODE_Y(WC%NODE_INDEX,NM) = NODE_Y(WC%NODE_INDEX,NM) + YC(JJ)*AREA            
            NODE_Z(WC%NODE_INDEX,NM) = NODE_Z(WC%NODE_INDEX,NM) + Z(KK)*AREA
      END SELECT
      NODE_P(WC%NODE_INDEX,NM) = NODE_P(WC%NODE_INDEX,NM) + (P_AVE+RHO(II,JJ,KK)*(HP(II,JJ,KK)-KRES(II,JJ,KK)))*AREA  
   ELSE ZONE_LEAK_IF
      IF (ALL(SF%LEAK_PATH/=WC%PRESSURE_ZONE)) CYCLE WALL_LOOP
      IF (SF%LEAK_PATH(1) == WC%PRESSURE_ZONE) THEN
         IZ1 = SF%LEAK_PATH(1)
         IZ2 = SF%LEAK_PATH(2)
         WC%NODE_INDEX = DUCT(LEAK_PATH(MIN(IZ1,IZ2),MAX(IZ1,IZ2)))%NODE_INDEX(1)
      ELSE
         IZ1 = SF%LEAK_PATH(2)
         IZ2 = SF%LEAK_PATH(1)
         WC%NODE_INDEX = DUCT(LEAK_PATH(MIN(IZ1,IZ2),MAX(IZ1,IZ2)))%NODE_INDEX(2)
      ENDIF
      IF (NODE_ZONE(WC%NODE_INDEX,NM) == 0) NODE_ZONE(WC%NODE_INDEX,NM) = WC%PRESSURE_ZONE         
      IOR = WC%ONE_D%IOR      
      II = WC%ONE_D%IIG
      JJ = WC%ONE_D%JJG
      KK = WC%ONE_D%KKG
      AREA = WC%AW

      NODE_AREA(WC%NODE_INDEX,NM) = NODE_AREA(WC%NODE_INDEX,NM) + AREA
      NODE_RHO(WC%NODE_INDEX,NM) = NODE_RHO(WC%NODE_INDEX,NM) + RHOP(II,JJ,KK)*AREA

      ZZ_GET(1:N_TRACKED_SPECIES) = ZZ(II,JJ,KK,1:N_TRACKED_SPECIES)
      NODE_ZZ(WC%NODE_INDEX,1:N_TRACKED_SPECIES,NM) = NODE_ZZ(WC%NODE_INDEX,1:N_TRACKED_SPECIES,NM) + &
                                                      ZZ_GET(1:N_TRACKED_SPECIES)*AREA*RHO(II,JJ,KK)
      CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CPBAR,TMP(II,JJ,KK))
      NODE_TMP(WC%NODE_INDEX,NM) = NODE_TMP(WC%NODE_INDEX,NM) + TMP(II,JJ,KK)*AREA
      NODE_H(WC%NODE_INDEX,NM) = NODE_H(WC%NODE_INDEX,NM) + CPBAR * TMP(II,JJ,KK) * RHOP(II,JJ,KK) * AREA
           
      SELECT CASE (IOR)
         CASE (3)
            P_AVE = 0.5_EB*(PBARP(KK-1,WC%PRESSURE_ZONE)+PBARP(KK,WC%PRESSURE_ZONE))
            NODE_Z(WC%NODE_INDEX,NM) = NODE_Z(WC%NODE_INDEX,NM) + Z(KK-1)*AREA
         CASE (-3)
            P_AVE = 0.5_EB*(PBARP(KK,WC%PRESSURE_ZONE)+PBARP(KK+1,WC%PRESSURE_ZONE))
            NODE_Z(WC%NODE_INDEX,NM) = NODE_Z(WC%NODE_INDEX,NM) + Z(KK)*AREA
         CASE DEFAULT
            P_AVE = PBARP(KK,WC%PRESSURE_ZONE)
            NODE_Z(WC%NODE_INDEX,NM) = NODE_Z(WC%NODE_INDEX,NM) + ZC(KK)*AREA
      END SELECT
      NODE_P(WC%NODE_INDEX,NM) = NODE_P(WC%NODE_INDEX,NM) + P_AVE*AREA        
   ENDIF ZONE_LEAK_IF
ENDDO WALL_LOOP

TUSED(16,:)=TUSED(16,:)+SECOND()-TNOW

END SUBROUTINE HVAC_BC_IN


SUBROUTINE DETERMINE_FIXED_ELEMENTS(T)
USE MATH_FUNCTIONS,ONLY:EVALUATE_RAMP
INTEGER:: NN,ND, COUNTER
REAL(EB), INTENT(IN):: T
LOGICAL :: CHANGE
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()

DUCTNODE%FIXED = .FALSE.
DUCT%FIXED = .FALSE.
DUCT%VOLUME_FLOW = 0._EB
CHANGE = .TRUE.

DUCT_LOOP: DO ND=1,N_DUCTS
   DU=>DUCT(ND)
   IF (DU%VOLUME_FLOW_INITIAL<1.E6_EB) THEN
      DU%VOLUME_FLOW = DU%VOLUME_FLOW_INITIAL*EVALUATE_RAMP(T,DU%TAU,DU%RAMP_INDEX)
      IF(DU%AREA > TWO_EPSILON_EB) DU%VEL(NEW) = DU%VOLUME_FLOW/DU%AREA
      DU%FIXED = .TRUE.   
      CYCLE DUCT_LOOP
   ENDIF
   IF (DU%MASS_FLOW_INITIAL<1.E6_EB) THEN
      IF (DU%MASS_FLOW_INITIAL >0._EB) THEN
         DU%VOLUME_FLOW = DU%MASS_FLOW_INITIAL/DUCTNODE(DU%NODE_INDEX(1))%RHO*EVALUATE_RAMP(T,DU%TAU,DU%RAMP_INDEX)
      ELSE
         DU%VOLUME_FLOW = DU%MASS_FLOW_INITIAL/DUCTNODE(DU%NODE_INDEX(2))%RHO*EVALUATE_RAMP(T,DU%TAU,DU%RAMP_INDEX)         
      ENDIF
      IF(DU%AREA > TWO_EPSILON_EB) DU%VEL(NEW) = DU%VOLUME_FLOW/DU%AREA
      DU%FIXED = .TRUE.   
      CYCLE DUCT_LOOP         
   ENDIF
   IF (DU%FAN_INDEX>0) THEN
      IF (DU%DEVC_INDEX > 0) THEN
         DU%FAN_OPERATING = DEVICE(DU%DEVC_INDEX)%CURRENT_STATE
         IF (DU%FAN_OPERATING .AND. (DEVICE(DU%DEVC_INDEX)%CURRENT_STATE .NEQV. DEVICE(DU%DEVC_INDEX)%PRIOR_STATE)) &
            DU%FAN_ON_TIME = T
      ELSEIF (DU%CTRL_INDEX > 0) THEN
         DU%FAN_OPERATING = CONTROL(DU%CTRL_INDEX)%CURRENT_STATE
         IF (DU%FAN_OPERATING .AND. (CONTROL(DU%CTRL_INDEX)%CURRENT_STATE .NEQV. CONTROL(DU%CTRL_INDEX)%PRIOR_STATE)) &
            DU%FAN_ON_TIME = T
      ENDIF
      IF (DU%FAN_OPERATING .AND. FAN(DU%FAN_INDEX)%FAN_TYPE==1) THEN
         DU%FIXED=.TRUE.
         CALL UPDATE_FAN(T,ND)
      ELSEIF (.NOT. DU%FAN_OPERATING .AND. FAN(DU%FAN_INDEX)%FAN_TYPE==1) THEN
         DU%FIXED = .FALSE.
         DU%VOLUME_FLOW = 0._EB
      ENDIF              
   ENDIF
ENDDO DUCT_LOOP

NODE_LOOP: DO NN = 1, N_DUCTNODES
      DN=>DUCTNODE(NN)
      IF (DN%VENT .OR. DN%AMBIENT .OR. DN%LEAKAGE) THEN
         DN%FIXED = .TRUE.
         CHANGE = .TRUE.
         CYCLE NODE_LOOP
      ENDIF
      COUNTER = 0
      DO ND = 1,DN%N_DUCTS
         DU=>DUCT(DN%DUCT_INDEX(ND))
         IF (DU%FIXED .OR. DU%AREA < TWO_EPSILON_EB) COUNTER = COUNTER + 1
      ENDDO      
      IF (COUNTER==DN%N_DUCTS) THEN
         WRITE(MESSAGE,'(A,A)') 'ERROR: Cannot specifiy fixed flows for all branches of internal DUCTNODE:',TRIM(DN%ID)
         CALL SHUTDOWN(MESSAGE); RETURN
      ENDIF     
ENDDO NODE_LOOP

END SUBROUTINE DETERMINE_FIXED_ELEMENTS


SUBROUTINE FIND_NETWORKS(CHANGEIN,T)
INTEGER:: NZ,NN,ND,DUCT_COUNTER(N_DUCTS),NODE_COUNTER(N_DUCTNODES),COUNTER,COUNTER2,ZONE_COUNTER(N_ZONE)
INTEGER, DIMENSION(:), ALLOCATABLE :: NETWORK_DCOUNTER,NETWORK_NCOUNTER,RENUMBER
LOGICAL, INTENT(INOUT) :: CHANGEIN
LOGICAL :: CHANGE
REAL(EB), INTENT(IN):: T
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()

CHANGE = CHANGEIN

IF (N_ZONE > 0) ZONE_COUNTER = 0

DO ND = 1, N_DUCTS
   DU => DUCT(ND)
   IF(.NOT. DU%DAMPER) CYCLE
   IF (DU%DEVC_INDEX > 0) THEN
      IF (DEVICE(DU%DEVC_INDEX)%CURRENT_STATE .NEQV. DU%DAMPER_OPEN) THEN
            DU%DAMPER_OPEN = DEVICE(DU%DEVC_INDEX)%CURRENT_STATE
            CHANGE = .TRUE.
      ENDIF
   ELSEIF(DU%CTRL_INDEX > 0) THEN
      IF (CONTROL(DU%CTRL_INDEX)%CURRENT_STATE .NEQV. DU%DAMPER_OPEN) THEN
            DU%DAMPER_OPEN = CONTROL(DU%CTRL_INDEX)%CURRENT_STATE
            CHANGE = .TRUE.
      ENDIF
   ENDIF
   IF (DU%DAMPER_OPEN) THEN
      DU%AREA = DU%AREA_INITIAL
   ELSE
      DU%AREA = 0._EB
      DU%VEL  = 0._EB
   ENDIF  
ENDDO

IF (CHANGE) THEN
   IF (ALLOCATED(NETWORK)) DEALLOCATE(NETWORK)
   DO NN = 1, N_DUCTNODES
      NZ = DUCTNODE(NN)%ZONE_INDEX
      IF (NZ>=1) THEN
         NODE_COUNTER(NN) = NZ
         ZONE_COUNTER(NZ) = ZONE_COUNTER(NZ) + 1
      ELSE
         NODE_COUNTER(NN) = NN+N_ZONE
      ENDIF
   ENDDO 
   IF (N_ZONE > 0) THEN
      DO NZ = 1, N_ZONE
         IF (ALLOCATED(P_ZONE(NZ)%NODE_INDEX)) DEALLOCATE(P_ZONE(NZ)%NODE_INDEX)
         ALLOCATE(P_ZONE(NZ)%NODE_INDEX(ZONE_COUNTER(NZ)))      
         P_ZONE(NZ)%N_DUCTNODES = ZONE_COUNTER(NZ)         
         COUNTER = 1
         DO NN = 1,N_DUCTNODES
            IF (DUCTNODE(NN)%ZONE_INDEX == NZ) THEN
               P_ZONE(NZ)%NODE_INDEX(COUNTER)=NN
               COUNTER = COUNTER + 1               
            ENDIF
         ENDDO   
      ENDDO      
   ENDIF  

   CHANGE = .TRUE.
   DO WHILE (CHANGE)
      CHANGE = .FALSE.
      DO ND = 1, N_DUCTS
         DU => DUCT(ND)
         IF (NODE_COUNTER(DU%NODE_INDEX(1)) /= NODE_COUNTER(DU%NODE_INDEX(2))) THEN
            CHANGE = .TRUE.
            COUNTER = MIN(NODE_COUNTER(DU%NODE_INDEX(1)),NODE_COUNTER(DU%NODE_INDEX(2)))
            DUCT_COUNTER(ND) = COUNTER
            NODE_COUNTER(DU%NODE_INDEX(1)) = COUNTER
            NODE_COUNTER(DU%NODE_INDEX(2)) = COUNTER
         ELSE
            DUCT_COUNTER(ND) = NODE_COUNTER(DU%NODE_INDEX(1))
         ENDIF
      ENDDO 

      IF (N_ZONE > 0) THEN   
         DO NZ = 1, N_ZONE
            COUNTER = 1
            COUNTER2 = 1
            DO NN = 1, P_ZONE(NZ)%N_DUCTNODES
               IF (NN==1) THEN
                  COUNTER = NODE_COUNTER(P_ZONE(NZ)%NODE_INDEX(NN))
                  COUNTER2 = COUNTER
               ELSE
                  IF (COUNTER /= NODE_COUNTER(P_ZONE(NZ)%NODE_INDEX(NN))) &
                     COUNTER2 = MAX(COUNTER2,NODE_COUNTER(P_ZONE(NZ)%NODE_INDEX(NN)))                     
                     COUNTER  = MIN(COUNTER,NODE_COUNTER(P_ZONE(NZ)%NODE_INDEX(NN)))                     
               ENDIF               
            ENDDO
            IF (COUNTER /= COUNTER2) THEN
               CHANGE = .TRUE.
               DO NN = 1, P_ZONE(NZ)%N_DUCTNODES   
                  NODE_COUNTER(P_ZONE(NZ)%NODE_INDEX(NN)) = COUNTER
               ENDDO
            ENDIF
         ENDDO
      ENDIF
   END DO
   
   ALLOCATE(RENUMBER(MAXVAL(NODE_COUNTER)))
   RENUMBER = 0
   N_NETWORKS = 0
   DO NN = 1,N_DUCTNODES
      IF (RENUMBER(NODE_COUNTER(NN)) == 0) THEN
         N_NETWORKS = N_NETWORKS + 1
         RENUMBER(NODE_COUNTER(NN)) = N_NETWORKS
      ENDIF
   ENDDO
   DO NN = 1,N_DUCTNODES
      NODE_COUNTER(NN) = RENUMBER(NODE_COUNTER(NN)) 
   ENDDO
   DO ND = 1,N_DUCTS
      DUCT_COUNTER(ND) = RENUMBER(DUCT_COUNTER(ND))       
   ENDDO
   DEALLOCATE(RENUMBER)
   
   ALLOCATE(NETWORK(N_NETWORKS))
   NETWORK%N_DUCTS=0
   NETWORK%N_DUCTNODES=0
   ALLOCATE(NETWORK_DCOUNTER(N_NETWORKS))
   NETWORK_DCOUNTER=0
   ALLOCATE(NETWORK_NCOUNTER(N_NETWORKS))
   NETWORK_NCOUNTER=0
   COUNTER = 0
   DO ND = 1, N_DUCTS
      NETWORK(DUCT_COUNTER(ND))%N_DUCTS = NETWORK(DUCT_COUNTER(ND))%N_DUCTS + 1
   ENDDO
   DO NN = 1, N_DUCTNODES
      NETWORK(NODE_COUNTER(NN))%N_DUCTNODES = NETWORK(NODE_COUNTER(NN))%N_DUCTNODES + 1
   ENDDO
   DO NN = 1, N_NETWORKS
      ALLOCATE(NETWORK(NN)%DUCT_INDEX(NETWORK(NN)%N_DUCTS))
      ALLOCATE(NETWORK(NN)%NODE_INDEX(NETWORK(NN)%N_DUCTNODES))
      ALLOCATE(NETWORK(NN)%MATRIX_INDEX(NETWORK(NN)%N_DUCTS+NETWORK(NN)%N_DUCTNODES))
      NETWORK(NN)%MATRIX_INDEX = 0
   ENDDO
   DO ND = 1, N_DUCTS
      NETWORK_DCOUNTER(DUCT_COUNTER(ND)) = NETWORK_DCOUNTER(DUCT_COUNTER(ND)) + 1
      NETWORK(DUCT_COUNTER(ND))%DUCT_INDEX(NETWORK_DCOUNTER(DUCT_COUNTER(ND))) = ND
      DUCT_NE(ND) = NETWORK_DCOUNTER(DUCT_COUNTER(ND))
   ENDDO
   DO NN = 1, N_DUCTNODES
      NETWORK_NCOUNTER(NODE_COUNTER(NN)) = NETWORK_NCOUNTER(NODE_COUNTER(NN)) + 1
      NETWORK(NODE_COUNTER(NN))%NODE_INDEX(NETWORK_NCOUNTER(NODE_COUNTER(NN))) = NN
      DUCTNODE_NE(NN) = NETWORK_NCOUNTER(NODE_COUNTER(NN))
   ENDDO
   DEALLOCATE(NETWORK_DCOUNTER)
   DEALLOCATE(NETWORK_NCOUNTER)
   CALL DETERMINE_FIXED_ELEMENTS(T)
   CALL SETUP_SOLUTION_POINTERS
ENDIF

END SUBROUTINE FIND_NETWORKS

SUBROUTINE SETUP_SOLUTION_POINTERS
INTEGER:: NNE,NN,ND,COUNTER
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()
TYPE(NETWORK_TYPE), POINTER :: NE=>NULL()

DO NNE = 1,N_NETWORKS
   COUNTER = 0
   NE => NETWORK(NNE)   
   DO ND=1,NE%N_DUCTS
      DU=>DUCT(NE%DUCT_INDEX(ND))
      IF (DU%FIXED .OR. DU%AREA<=TWO_EPSILON_EB) CYCLE
      COUNTER = COUNTER + 1
      NE%MATRIX_INDEX(ND)=COUNTER
   ENDDO
   DO NN=1,NE%N_DUCTNODES
      DN=>DUCTNODE(NE%NODE_INDEX(NN))      
      IF (DN%FIXED .OR. DN%VENT) CYCLE
      COUNTER = COUNTER + 1
      NE%MATRIX_INDEX(NE%N_DUCTS+NN)=COUNTER
   ENDDO
   NE%N_MATRIX=COUNTER
ENDDO

END SUBROUTINE SETUP_SOLUTION_POINTERS


SUBROUTINE UPDATE_LOSS(NNE)
USE PHYSICAL_FUNCTIONS,ONLY:GET_VISCOSITY
REAL(EB) :: FRICTION_FACTOR,LOSS_SUM,ZZ_GET(1:N_TRACKED_SPECIES),VISCOSITY
INTEGER, INTENT(IN) :: NNE
INTEGER :: ND,ND2, NN,NUM_OUT
TYPE(DUCT_TYPE), POINTER :: DU=>NULL(),DU2=>NULL()
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()
TYPE(NETWORK_TYPE), POINTER :: NE=>NULL()

NE => NETWORK(NNE)

DO ND = 1, NE%N_DUCTS
   DUCT(NE%DUCT_INDEX(ND))%TOTAL_LOSS=0._EB
ENDDO
NODELOOP : DO NN=1,NE%N_DUCTNODES
  DN => DUCTNODE(NE%NODE_INDEX(NN))  
  NODECLASS: IF (DN%FILTER_INDEX > 0) THEN
     CALL FILTER_UPDATE(NE%NODE_INDEX(NN))
     IF (DUCT(DN%DUCT_INDEX(1))%AREA < TWO_EPSILON_EB .OR. DUCT(DN%DUCT_INDEX(2))%AREA < TWO_EPSILON_EB) CYCLE
     IF(DUCT(DN%DUCT_INDEX(1))%VEL(GUESS)*DN%DIR(1) > 0._EB) THEN
           DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS + &
              DN%FILTER_LOSS*DUCT(DN%DUCT_INDEX(1))%AREA/DUCT(DN%DUCT_INDEX(2))%AREA
     ELSE
        DUCT(DN%DUCT_INDEX(2))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(2))%TOTAL_LOSS + DN%FILTER_LOSS
     ENDIF
  ELSEIF(DN%VENT) THEN NODECLASS
     IF (DUCT(DN%DUCT_INDEX(1))%AREA < TWO_EPSILON_EB) CYCLE
     IF(DUCT(DN%DUCT_INDEX(1))%VEL(GUESS)*DN%DIR(1) < 0._EB) THEN
        DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS + DN%LOSS_ARRAY(1,2)
     ELSE
        DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS + DN%LOSS_ARRAY(2,1)
     ENDIF  
  ELSEIF(DN%FILTER_INDEX <=0 .AND. DN%N_DUCTS==2) THEN
     IF (DUCT(DN%DUCT_INDEX(1))%AREA < TWO_EPSILON_EB .OR. DUCT(DN%DUCT_INDEX(2))%AREA < TWO_EPSILON_EB) CYCLE
     IF(ABS(DUCT(DN%DUCT_INDEX(1))%VEL(GUESS)) > 1.E-6_EB) THEN
        IF(DUCT(DN%DUCT_INDEX(1))%VEL(GUESS)*DN%DIR(1) > 0._EB) THEN
           DUCT(DN%DUCT_INDEX(2))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(2))%TOTAL_LOSS + DN%LOSS_ARRAY(1,2)
        ELSE
           DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS + DN%LOSS_ARRAY(1,2)
        ENDIF
     ELSE
        LOSS_SUM = 0.5_EB*(DN%LOSS_ARRAY(1,2) + DN%LOSS_ARRAY(2,1)*DUCT(DN%DUCT_INDEX(2))%AREA/DUCT(DN%DUCT_INDEX(1))%AREA)
        DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS + &
                                            LOSS_SUM*DUCT(DN%DUCT_INDEX(1))%AREA/DUCT(DN%DUCT_INDEX(2))%AREA
        DUCT(DN%DUCT_INDEX(2))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(2))%TOTAL_LOSS + LOSS_SUM
     ENDIF
  ELSE NODECLASS
     NUM_OUT = 0
     DO ND=1,DN%N_DUCTS
        DU => DUCT(DN%DUCT_INDEX(ND))
        IF (DU%VEL(GUESS)*DN%DIR(ND) < 0._EB .AND. ABS(DU%VEL(GUESS)) > 1.E-6_EB) NUM_OUT = NUM_OUT + 1
     ENDDO
     IF (NUM_OUT==0) THEN
        DO ND=1,DN%N_DUCTS
           DU => DUCT(DN%DUCT_INDEX(ND))
           DO ND2=1,DN%N_DUCTS
              IF (ND2==ND) CYCLE
              DU%TOTAL_LOSS = DU%TOTAL_LOSS + DN%LOSS_ARRAY(ND2,ND)/DN%N_DUCTS
           ENDDO
        ENDDO
     ELSEIF (NUM_OUT==1) THEN
        DO ND=1,DN%N_DUCTS
           DU => DUCT(DN%DUCT_INDEX(ND))
           IF (DU%VEL(GUESS)*DN%DIR(ND) < 0._EB .AND. ABS(DU%VEL(GUESS)) > 1.E-6_EB) THEN
              NUM_OUT = ND
              EXIT
           ENDIF
        ENDDO                
        DO ND=1,DN%N_DUCTS
           IF (ND==NUM_OUT) CYCLE           
           DUCT(DN%DUCT_INDEX(ND))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(ND))%TOTAL_LOSS + &
                                                DN%LOSS_ARRAY(ND,NUM_OUT)*DU%AREA/DUCT(DN%DUCT_INDEX(NUM_OUT))%AREA
        ENDDO
     ELSEIF (NUM_OUT == DN%N_DUCTS - 1) THEN
        DO ND=1,DN%N_DUCTS
           DU => DUCT(DN%DUCT_INDEX(ND))
           IF (DU%VEL(GUESS)*DN%DIR(ND) < 0._EB .AND. ABS(DU%VEL(GUESS)) > 1.E-6_EB) THEN
              CYCLE
           ELSE
              NUM_OUT = ND
              EXIT
           ENDIF
        ENDDO        
        DO ND=1,DN%N_DUCTS
           IF (ND==NUM_OUT) CYCLE
           DUCT(DN%DUCT_INDEX(ND))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(ND))%TOTAL_LOSS + DN%LOSS_ARRAY(NUM_OUT,ND)
        ENDDO
     ELSE
         LOSS_SUM = 0._EB
         DO ND=1,DN%N_DUCTS
            DU => DUCT(DN%DUCT_INDEX(ND))
            IF(DU%VEL(GUESS)*DN%DIR(ND) > 0._EB)  LOSS_SUM = LOSS_SUM + DU%VEL(GUESS)*DN%DIR(ND)*DU%AREA
         ENDDO
         DO ND=1,DN%N_DUCTS
            DU => DUCT(DN%DUCT_INDEX(ND))            
            IF (DU%VEL(GUESS)*DN%DIR(ND) < 0._EB .AND. ABS(DU%VEL(GUESS)) > 1.E-6_EB) THEN
               DO ND2=1,DN%N_DUCTS
                  DU2 => DUCT(DN%DUCT_INDEX(ND2))
                  IF (DU2%VEL(GUESS)*DN%DIR(ND2) > 0._EB) DU%TOTAL_LOSS = DU%TOTAL_LOSS + &
                                                          DU2%VEL(GUESS)*DN%DIR(ND2)*DU2%AREA*DN%LOSS_ARRAY(ND2,ND)/LOSS_SUM
               ENDDO
            ENDIF
         ENDDO
     ENDIF
  ENDIF NODECLASS
ENDDO NODELOOP

DO ND = 1, NE%N_DUCTS
   DU => DUCT(NE%DUCT_INDEX(ND))
   IF (DU%ROUGHNESS > TWO_EPSILON_EB) THEN
      ZZ_GET(1:N_TRACKED_SPECIES) = DU%ZZ(1:N_TRACKED_SPECIES)
      CALL GET_VISCOSITY(ZZ_GET,VISCOSITY,DU%TMP_D)
      FRICTION_FACTOR = COMPUTE_FRICTION_FACTOR(DU%RHO_D,VISCOSITY,ABS(DU%VEL(GUESS)),DU%DIAMETER,DU%ROUGHNESS)
   ELSE
      FRICTION_FACTOR = 0._EB
   ENDIF
   IF (DU%VEL(GUESS)>0._EB) THEN
      DU%TOTAL_LOSS = DU%LOSS(1)+DU%TOTAL_LOSS
   ELSEIF (DU%VEL(GUESS)<0._EB) THEN
      DU%TOTAL_LOSS = DU%LOSS(2)+DU%TOTAL_LOSS
   ELSE
      DU%TOTAL_LOSS = DU%TOTAL_LOSS+0.5_EB*(DU%LOSS(1)+DU%LOSS(2))
   ENDIF
   DU%TOTAL_LOSS = DU%TOTAL_LOSS + DU%LENGTH/DU%DIAMETER*FRICTION_FACTOR
   IF (DU%FAN_INDEX>0) THEN
      IF(.NOT. DU%FAN_OPERATING) DU%TOTAL_LOSS = DU%TOTAL_LOSS + FAN(DU%FAN_INDEX)%OFF_LOSS
   ENDIF
ENDDO

END SUBROUTINE UPDATE_LOSS


REAL(EB) FUNCTION COMPUTE_FRICTION_FACTOR(RHO,VISCOSITY,VEL,DIAM,ROUGHNESS)
REAL(EB), INTENT(IN) :: RHO,VISCOSITY,VEL,DIAM,ROUGHNESS
REAL(EB) :: EOD,RE_D

RE_D = MAX(100._EB,RHO*DIAM*VEL/VISCOSITY)
EOD = ROUGHNESS / DIAM
COMPUTE_FRICTION_FACTOR = LOG10(6.9_EB/RE_D+(EOD/3.7_EB)**1.11_EB)
COMPUTE_FRICTION_FACTOR = LOG10(EOD/3.7_EB-4.518_EB/RE_D*COMPUTE_FRICTION_FACTOR)
COMPUTE_FRICTION_FACTOR = (-0.5_EB/COMPUTE_FRICTION_FACTOR)**2

RETURN

END FUNCTION COMPUTE_FRICTION_FACTOR


SUBROUTINE SET_GUESS(NNE,T)
INTEGER, INTENT(IN) :: NNE
REAL(EB), INTENT(IN)::T
INTEGER :: ND
REAL(EB) :: VEL_TMP
TYPE(DUCT_TYPE),POINTER :: DU=>NULL()
TYPE(NETWORK_TYPE), POINTER :: NE=>NULL()

NE => NETWORK(NNE)

DO ND = 1,NE%N_DUCTS
   DU => DUCT(NE%DUCT_INDEX(ND))
   IF (DU%FAN_INDEX > 0 .AND. DU%FAN_OPERATING) THEN
      CALL UPDATE_FAN(T,NE%DUCT_INDEX(ND))     
   ELSEIF (DU%FAN_INDEX > 0 .AND. .NOT. DU%FAN_OPERATING) THEN
      DU%DP_FAN = 0._EB
   ENDIF  
   IF (DU%FAN_INDEX > 0 .AND. .NOT. DU%FAN_OPERATING) DU%DP_FAN = 0._EB
   IF (DU%FIXED) THEN
      DU%VEL(PREVIOUS)  = DU%VEL(NEW) 
      DU%VEL(GUESS)     = DU%VEL(NEW)
      CYCLE
   ENDIF
   IF (ITER == 0) THEN
      DU%VEL(GUESS)     = DU%VEL(OLD)
      DU%VEL(NEW)       = DU%VEL(OLD)
      DU%VEL(PREVIOUS)  = DU%VEL(OLD)  
   ELSE
      VEL_TMP = DU%VEL(NEW)
      IF (ABS(DU%VEL(GUESS)) < TWO_EPSILON_EB) THEN
         DU%VEL(GUESS)     = DU%VEL(NEW)         
         DU%VEL(NEW)       = DU%VEL(PREVIOUS)
      ELSEIF (SIGN(1._EB,DU%VEL(PREVIOUS))==SIGN(1._EB,DU%VEL(NEW))) THEN
         DU%VEL(GUESS)     = DU%VEL(NEW)         
         DU%VEL(NEW)       = DU%VEL(PREVIOUS)!0.6_EB*DU%VEL(PREVIOUS)+0.4_EB*DU%VEL(GUESS)
      ELSE
         DU%VEL(GUESS)     = DU%VEL(NEW)         
         DU%VEL(NEW)       = 0._EB
      ENDIF
      DU%VEL(PREVIOUS) = VEL_TMP
   ENDIF
ENDDO

END SUBROUTINE SET_GUESS


SUBROUTINE SET_DONOR(NNE)
USE MATH_FUNCTIONS, ONLY : EVALUATE_RAMP
INTEGER :: ND
INTEGER, INTENT(IN) :: NNE
REAL(EB) :: RHOLAST,TMPLAST,FVAL,OMFVAL,ITERFRAC
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()
TYPE(NETWORK_TYPE), POINTER :: NE=>NULL()

NE => NETWORK(NNE)
ITERFRAC = REAL(ITER,EB)/REAL(ITER_MAX,EB)
FVAL = MIN(1._EB,MAX(0._EB,(ITERFRAC-ONTH))/ONTH,1._EB)
OMFVAL = 1._EB - FVAL

DUCTLOOP: DO ND=1,NE%N_DUCTS
   DU=>DUCT(NE%DUCT_INDEX(ND))
   IF (DU%AREA < TWO_EPSILON_EB) CYCLE DUCTLOOP
   IF (DU%FIXED .AND. DU%FAN_INDEX < 0) THEN
      DU%VEL(PREVIOUS) = DU%VEL(NEW)
      DU%VEL(GUESS) = DU%VEL(NEW)
   ENDIF      
   RHOLAST = DU%RHO_D   
   TMPLAST = DU%TMP_D
   IF (DU%VEL(PREVIOUS)>0._EB) THEN
      DN=>DUCTNODE(DU%NODE_INDEX(1))
      IF(DN%VENT .OR. DN%AMBIENT .OR. DN%LEAKAGE) THEN
         DN%RHO= DN%RHO_V
         DN%TMP= DN%TMP_V
         DN%ZZ = DN%ZZ_V
         DN%RSUM = DN%RSUM_V
         DN%CP = DN%CP_V                  
      ENDIF
   ENDIF
   IF (DU%VEL(PREVIOUS)<0._EB) THEN
      DN=>DUCTNODE(DU%NODE_INDEX(2))
      IF(DN%VENT .OR. DN%AMBIENT .OR. DN%LEAKAGE) THEN
         DN%RHO= DN%RHO_V
         DN%TMP= DN%TMP_V
         DN%ZZ = DN%ZZ_V
         DN%RSUM = DN%RSUM_V
         DN%CP = DN%CP_V                  
      ENDIF
   ENDIF   
   IF (ABS(DU%VEL(PREVIOUS))>0._EB) THEN
      DU%CP_D = DN%CP
      DU%RHO_D = DN%RHO
      DU%TMP_D = DN%TMP
      DU%RSUM_D = DN%RSUM
   ELSE
      DU%CP_D = 0.5_EB*(DUCTNODE(DU%NODE_INDEX(1))%CP+DUCTNODE(DU%NODE_INDEX(2))%CP)
      DU%RHO_D = 0.5_EB*(DUCTNODE(DU%NODE_INDEX(1))%RHO+DUCTNODE(DU%NODE_INDEX(2))%RHO)
      DU%TMP_D = 0.5_EB*(DUCTNODE(DU%NODE_INDEX(1))%TMP+DUCTNODE(DU%NODE_INDEX(2))%TMP)
      DU%RSUM_D = 0.5_EB*(DUCTNODE(DU%NODE_INDEX(1))%RSUM+DUCTNODE(DU%NODE_INDEX(2))%RSUM)
   ENDIF
   IF (ITERFRAC > ONTH) THEN
      DU%RHO_D = FVAL*RHOLAST + OMFVAL*DU%RHO_D
      DU%TMP_D = FVAL*TMPLAST + OMFVAL*DU%TMP_D
   ENDIF   
ENDDO DUCTLOOP

END SUBROUTINE SET_DONOR


SUBROUTINE CONVERGENCE_CHECK(NNE)
INTEGER, INTENT(IN) :: NNE
INTEGER :: NN, ND
LOGICAL :: CONVERGED
REAL(EB) :: MSUM,MTOT,MFLOW,VEL
TYPE(NETWORK_TYPE), POINTER :: NE=>NULL()
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()

NE => NETWORK(NNE)
CONVERGED = .TRUE.
!Check duct velocity convergence
DO ND=1,NE%N_DUCTS
   DU => DUCT(NE%DUCT_INDEX(ND))
   IF (DU%AREA < TWO_EPSILON_EB) CYCLE
   IF (ABS(DU%VEL(PREVIOUS)) < 1.E-5_EB .AND. ABS(DU%VEL(NEW)) < 1.E-5_EB) CYCLE
   IF (DU%VEL(PREVIOUS) < 0._EB .EQV. DU%VEL(NEW) < 0._EB) THEN
        IF (ABS(DU%VEL(PREVIOUS))<=TWO_EPSILON_EB) THEN
           CONVERGED = .FALSE.
           EXIT
        ELSE
         IF (ABS(1._EB-DU%VEL(NEW)/DU%VEL(PREVIOUS)) > 0.05_EB) THEN
            CONVERGED = .FALSE.
            CYCLE
         ENDIF
        ENDIF
   ELSE
      CONVERGED = .FALSE.
   ENDIF
ENDDO
IF (.NOT. CONVERGED) RETURN

!Check node mass conservation convergence
DO NN=1,NE%N_DUCTNODES
   DN => DUCTNODE(NE%NODE_INDEX(NN))
   IF (DN%FIXED) CYCLE
   MSUM = 0._EB
   MTOT = 0._EB
   DO ND=1,DN%N_DUCTS
      DU=>DUCT(DN%DUCT_INDEX(ND))
      IF (ABS(DU%VEL(NEW))<1.E-7_EB) THEN
         VEL = 0._EB
      ELSE
         VEL = DU%VEL(NEW)
      ENDIF
      MFLOW = DN%DIR(ND)*VEL*DU%RHO_D*DU%AREA
      MSUM = MSUM + MFLOW
      MTOT = MTOT + ABS(MFLOW)
   ENDDO
   IF (DN%FILTER_INDEX > 0) THEN
      MFLOW = SUM(DN%FILTER_LOADING(:,3))*DT
      MSUM = MSUM - MFLOW
      MTOT = MTOT + MFLOW
   ENDIF
   IF(ABS(MSUM)< 1.E-6 * MTOT .OR. MTOT < TWO_EPSILON_EB) CYCLE
   CONVERGED = .FALSE.
ENDDO

IF (CONVERGED) ITER=ITER_MAX+1

END SUBROUTINE CONVERGENCE_CHECK


SUBROUTINE COLLAPSE_HVAC_BC

! Takes the MPI gathered mesh array of HVAC boundary conditions and updates the DUCTNODE boundary condition values.
USE PHYSICAL_FUNCTIONS, ONLY : GET_SPECIFIC_GAS_CONSTANT,GET_AVERAGE_SPECIFIC_HEAT
INTEGER:: NN,NS,ITCOUNT,ZONE_TEST(NMESHES)
REAL(EB) :: AREA,RHO_SUM,CPBAR,H_G,TMP_SUM,TMP_NEW,ZZ_GET(1:N_TRACKED_SPECIES),CPBAR2,DCPDT
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL(),DN2=>NULL()

VENT_CUSTOM_AMBIENT: DO NN=1,N_DUCTNODES
   DN => DUCTNODE(NN)
   IF (.NOT. DN%LEAKAGE) DN%ZONE_INDEX = MAXVAL(NODE_ZONE(NN,:))
   ZONE_TEST=-DN%ZONE_INDEX-1
   WHERE (NODE_ZONE(NN,:) < DN%ZONE_INDEX) ZONE_TEST=NODE_ZONE(NN,:)-DN%ZONE_INDEX
   IF (MAXVAL(ZONE_TEST)>-DN%ZONE_INDEX) THEN
      WRITE(MESSAGE,'(A,A)') 'ERROR: DUCTNODE must lie with a single pressure zone. Node: ',TRIM(DUCTNODE(NN)%ID)
      CALL SHUTDOWN(MESSAGE); RETURN   
   ENDIF
   
   INTERNAL_NODE_IF: IF (((DN%VENT .OR. DN%LEAKAGE) .AND. .NOT. DN%AMBIENT) .OR. &
                          (DN%AMBIENT .AND. SUM(NODE_AREA(NN,:)) > 0._EB)) THEN
      ZZ_GET = 0._EB
      AREA = SUM(NODE_AREA(NN,:))
      IF (AREA<=TWO_EPSILON_EB) THEN
         DUCT(DN%DUCT_INDEX(1))%AREA = 0._EB
         DUCT(DN%DUCT_INDEX(1))%VEL = 0._EB
         CYCLE VENT_CUSTOM_AMBIENT
      ELSE
         DUCT(DN%DUCT_INDEX(1))%AREA = DUCT(DN%DUCT_INDEX(1))%AREA_INITIAL
      ENDIF
      NODE_AREA_EX(NN,:) = AREA
      DN%XYZ(1) = SUM(NODE_X(NN,:))/AREA
      DN%XYZ(2) = SUM(NODE_Y(NN,:))/AREA
      DN%XYZ(3) = SUM(NODE_Z(NN,:))/AREA
      RHO_SUM = SUM(NODE_RHO(NN,:))
      DO NS=1,N_TRACKED_SPECIES
         DN%ZZ_V(NS) = SUM(NODE_ZZ(NN,NS,:))/RHO_SUM
      ENDDO
      ZZ_GET(1:N_TRACKED_SPECIES) = DN%ZZ_V(1:N_TRACKED_SPECIES)
      CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,DN%RSUM_V)
      
      DN%RHO_V = RHO_SUM/AREA
      
      !Initialize default values 
      IF (DN%P < -1.E9_EB) THEN
         IF (STRATIFICATION) THEN      
            DN%TMP  = TMPA + LAPSE_RATE*DN%XYZ(3)    
            IF (ABS(LAPSE_RATE)>TWO_EPSILON_EB) THEN      
               DN%P_OLD = P_INF*(DN%TMP/TMPA)**(GVEC(3)/RSUM0/LAPSE_RATE)
            ELSE
               DN%P_OLD = P_INF*EXP(GVEC(3)*(DN%XYZ(3)-GROUND_LEVEL)/(RSUM0*TMPA))
            ENDIF      
            DN%RHO   =  DN%P_OLD/(TMPA*RSUM0)            
         ELSE
            DN%P      = P_INF
            DN%RHO   =  DN%P/(DN%TMP*RSUM0)            
         ENDIF   
         CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,DN%CP,DN%TMP)      
      ENDIF
      
      DN%P = 0.3_EB*(SUM(NODE_P(NN,:))/AREA)+0.7_EB*DN%P_OLD
      TMP_SUM = SUM(NODE_TMP(NN,:))/AREA
      H_G = SUM(NODE_H(NN,:))/RHO_SUM
      ITCOUNT = 0
      DO
         ITCOUNT = ITCOUNT + 1
         CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CPBAR,TMP_SUM)      
         IF (TMP_SUM > 1._EB) THEN
            CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CPBAR2,TMP_SUM-1._EB)  
            DCPDT = CPBAR - CPBAR2
         ELSE
            CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CPBAR2,TMP_SUM+1._EB)  
            DCPDT = CPBAR2 - CPBAR
         ENDIF    
         TMP_NEW = TMP_SUM + (H_G - TMP_SUM*CPBAR)/(CPBAR+TMP_SUM*DCPDT)
         IF (ABS(TMP_SUM - TMP_NEW) < SPACING(TMP_NEW) .OR. ABS(TMP_SUM - TMP_NEW)/TMP_NEW < 0.0005_EB) EXIT
         IF (ITCOUNT>10) THEN
            TMP_NEW = 0.5_EB*(TMP_SUM+TMP_NEW)
            CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CPBAR,TMP_SUM)  
            EXIT
         ENDIF
         TMP_SUM = TMP_NEW
      ENDDO
      DN%TMP_V = TMP_NEW
      DN%CP_V = CPBAR
   ENDIF INTERNAL_NODE_IF
END DO VENT_CUSTOM_AMBIENT

AMBIENT_LEAK: DO NN=1,N_DUCTNODES
   DN => DUCTNODE(NN)  
    IF (DN%AMBIENT .AND. SUM(NODE_AREA(NN,:))<=TWO_EPSILON_EB) THEN
      !Initialize ambient nodes outside domain
      IF (DUCT(DN%DUCT_INDEX(1))%NODE_INDEX(1)==NN) THEN
         DN2 => DUCTNODE(DUCT(DN%DUCT_INDEX(1))%NODE_INDEX(2))
      ELSE
         DN2 => DUCTNODE(DUCT(DN%DUCT_INDEX(1))%NODE_INDEX(1))
      ENDIF
      IF (DN%LEAKAGE .OR. DN%XYZ(3) <-1.E9_EB) DN%XYZ = DN2%XYZ
      IF (DN%XYZ(3) <-1.E9_EB) CYCLE AMBIENT_LEAK
      DN%RSUM   = RSUM0
      IF (STRATIFICATION) THEN      
         DN%TMP  = TMPA + LAPSE_RATE*DN%XYZ(3)    
         IF (ABS(LAPSE_RATE)>TWO_EPSILON_EB) THEN      
            DN%P = P_INF*(DN%TMP/TMPA)**(GVEC(3)/RSUM0/LAPSE_RATE)
         ELSE
            DN%P = P_INF*EXP(GVEC(3)*(DN%XYZ(3)-GROUND_LEVEL)/(RSUM0*TMPA))
         ENDIF      
         DN%RHO   =  DN%P/(DN%TMP*RSUM0)
      ELSE
         DN%TMP  = TMPA
         DN%P      = P_INF
         DN%RHO    = RHOA
      ENDIF
      DN%P_OLD = DN%P
      ZZ_GET(1:N_TRACKED_SPECIES) = DN%ZZ_V(1:N_TRACKED_SPECIES)
      CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,DN%CP,DN%TMP)      
      DN%TMP_V  = DN%TMP
      DN%RSUM_V = DN%RSUM
      DN%CP_V   = DN%CP
      DN%RHO_V  = DN%RHO            
   ENDIF
ENDDO AMBIENT_LEAK

END SUBROUTINE COLLAPSE_HVAC_BC

SUBROUTINE SET_INIT_HVAC
INTEGER:: NN
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()

DO NN=1,N_DUCTNODES
   DN=>DUCTNODE(NN)
   IF (.NOT. DN%VENT .AND. .NOT. DN%LEAKAGE) CYCLE
   DN%CP = DN%CP_V
   DN%TMP = DN%TMP_V
   DN%RHO = DN%RHO_V
   DN%RSUM = DN%RSUM_V
   DN%ZZ = DN%ZZ_V
ENDDO

END SUBROUTINE SET_INIT_HVAC

SUBROUTINE UPDATE_NODE_BC
!Takes the MPI gathered mesh array of HVAC boundary conditions and updates the DUCTNODE boundary condition values.
INTEGER:: NN, NS, ND
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()

DO NN=1,N_DUCTNODES
   DN => DUCTNODE(NN)
   NODE_TMP_EX(NN,:) = DN%TMP
   DO NS=1,N_TRACKED_SPECIES
      NODE_ZZ_EX(NN,NS,:) = DN%ZZ(NS)
   ENDDO
END DO

DO ND=1,N_DUCTS
   DUCT_MF(ND,:) = DUCT(ND)%VEL(NEW)*DUCT(ND)%AREA*DUCT(ND)%RHO_D
ENDDO

END SUBROUTINE UPDATE_NODE_BC


SUBROUTINE LEAKAGE_HVAC

USE PHYSICAL_FUNCTIONS, ONLY: GET_AVERAGE_SPECIFIC_HEAT
REAL(EB) :: ZZ_GET(1:N_TRACKED_SPECIES)
INTEGER :: I_DUCT,I_DUCTNODE,NZ1,NZ2
TYPE (DUCTNODE_TYPE), POINTER:: DN1=>NULL(),DN2=>NULL()
TYPE (DUCT_TYPE), POINTER:: DU=>NULL()

I_DUCT = N_DUCTS - LEAK_DUCTS
I_DUCTNODE = N_DUCTNODES - 2 * LEAK_DUCTS

DO NZ1 = 0, N_ZONE
   DO NZ2 = 0, N_ZONE
      IF (LEAK_PATH(NZ1,NZ2) == 1) THEN
         I_DUCT = I_DUCT + 1
         LEAK_PATH(NZ1,NZ2) = I_DUCT
         I_DUCTNODE = I_DUCTNODE + 1
         DU => DUCT(I_DUCT)
         DU%AREA_INITIAL = P_ZONE(NZ2)%LEAK_AREA(NZ1)
         DU%AREA = P_ZONE(NZ2)%LEAK_AREA(NZ1)
         DU%DIAMETER = SQRT(DU%AREA / PI)*2._EB
         DU%LEAKAGE = .TRUE.
         WRITE(DU%ID,'(A,1X,I0,1X,I0)') 'LEAK',NZ1,NZ2 
         DU%LENGTH = 0.1_EB         
         DU%LOSS(1) = 1._EB                  
         DU%LOSS(2) = 1._EB
         DU%NODE_INDEX(1) = I_DUCTNODE
         DU%NODE_INDEX(2) = I_DUCTNODE+1
         DU%RHO_D = RHOA
         DU%TMP_D = TMPA
         DU%ROUGHNESS = 0._EB
         DU%VEL = 0._EB
         ALLOCATE(DU%ZZ(N_TRACKED_SPECIES))
         ZZ_GET(1:N_TRACKED_SPECIES) = SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
         DU%ZZ(1:N_TRACKED_SPECIES) = ZZ_GET(1:N_TRACKED_SPECIES)
         CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,DU%CP_D,TMPA)
         DN1=>DUCTNODE(I_DUCTNODE)
         IF (NZ1==0) DN1%AMBIENT = .TRUE.
         ALLOCATE(DN1%DUCT_INDEX(1))
         ALLOCATE(DN1%DIR(1))
         ALLOCATE(DN1%LOSS_ARRAY(2,2))            
         DN1%LOSS_ARRAY = 0._EB
         DN1%DIR = -1._EB
         DN1%DUCT_INDEX = I_DUCT
         DN1%LEAKAGE = .TRUE.
         DN1%ZONE_INDEX=NZ1
         DN1%MESH_INDEX = 1         
         DN1%N_DUCTS = 1
         DN1%RSUM = RSUM0
         DN1%TMP = TMPA                
         DN1%XYZ = (/0._EB,0._EB,0._EB/)
         WRITE(DN1%ID,'(A,1X,I0,1X,I0)') 'LEAK',NZ1,NZ2
         I_DUCTNODE = I_DUCTNODE + 1
         DN2=>DUCTNODE(I_DUCTNODE)
         IF (NZ2==0) DN2%AMBIENT = .TRUE.
         ALLOCATE(DN2%DUCT_INDEX(1))
         ALLOCATE(DN2%DIR(1))
         ALLOCATE(DN2%LOSS_ARRAY(2,2))            
         DN2%LOSS_ARRAY = 0._EB
         DN2%DIR = 1._EB
         DN2%DUCT_INDEX = I_DUCT
         DN2%LEAKAGE = .TRUE.
         DN2%ZONE_INDEX=NZ2
         DN2%XYZ = (/0._EB,0._EB,0._EB/)
         DN2%MESH_INDEX = 1
         DN2%N_DUCTS = 1
         DN2%RSUM = RSUM0
         DN2%TMP = TMPA         
         WRITE(DN2%ID,'(A,1X,I0,1X,I0)') 'LEAK',NZ2,NZ1
      ENDIF
   ENDDO
ENDDO

END SUBROUTINE LEAKAGE_HVAC


SUBROUTINE FILTER_UPDATE(NODE_INDEX)
!Updates filter loss and loading solution
USE MATH_FUNCTIONS,ONLY:EVALUATE_RAMP
INTEGER,INTENT(IN)::NODE_INDEX
REAL(EB) :: TOTAL_LOADING
TYPE(DUCTNODE_TYPE),POINTER::DN,DN2
TYPE(DUCT_TYPE),POINTER::DU
TYPE(FILTER_TYPE),POINTER:: FI

DN => DUCTNODE(NODE_INDEX)
FI => FILTER(DN%FILTER_INDEX)

TOTAL_LOADING = DOT_PRODUCT(FI%MULTIPLIER,DN%FILTER_LOADING(:,1))
IF (FI%RAMP_INDEX > 0) THEN
   DN%FILTER_LOSS = EVALUATE_RAMP(TOTAL_LOADING,0._EB,FI%RAMP_INDEX)
ELSE
   DN%FILTER_LOSS = FI%CLEAN_LOSS + FI%LOADING_LOSS*TOTAL_LOADING
ENDIF

DU=>DUCT(DN%DUCT_INDEX(1))
IF (DU%VEL(GUESS) >= 0._EB .AND. DU%NODE_INDEX(2)==NODE_INDEX) THEN
  DN2 => DUCTNODE(DU%NODE_INDEX(1))
ELSEIF (DU%VEL(GUESS) <= 0._EB .AND. DU%NODE_INDEX(1)==NODE_INDEX) THEN
  DN2 => DUCTNODE(DU%NODE_INDEX(2))
ELSE
   DU=>DUCT(DN%DUCT_INDEX(2))
   IF (DU%VEL(GUESS) >= 0._EB .AND. DU%NODE_INDEX(2)==NODE_INDEX) THEN
   DN2 => DUCTNODE(DU%NODE_INDEX(1))
   ELSE
   DN2 => DUCTNODE(DU%NODE_INDEX(2))
   ENDIF
ENDIF

!Ultimately add in logic for condensible gases
DN%FILTER_LOADING(:,3) = DU%AREA*ABS(DU%VEL(GUESS))*DN2%RHO*DOT_PRODUCT(DN2%ZZ,FI%EFFICIENCY)
DN%FILTER_LOADING(:,2) = DN%FILTER_LOADING(:,1) + DN%FILTER_LOADING(:,3) * DT

END SUBROUTINE FILTER_UPDATE


SUBROUTINE COIL_UPDATE(T)
USE MATH_FUNCTIONS, ONLY : EVALUATE_RAMP
REAL(EB), INTENT(IN) :: T
REAL(EB) :: TMP_IN,TMP_OUT,MDOT_DU,E_IN_G,CP,TSI
INTEGER :: ND
TYPE(DUCT_TYPE),POINTER::DU
TYPE(AIRCOIL_TYPE),POINTER:: AC

COIL_LOOP: DO ND = 1,N_DUCTS
   DU => DUCT(ND)
   IF (DU%AIRCOIL_INDEX < 0) CYCLE COIL_LOOP
   IF (DU%DEVC_INDEX > 0) THEN
      DU%COIL_OPERATING = DEVICE(DU%DEVC_INDEX)%CURRENT_STATE
      IF (DU%COIL_OPERATING .AND. (DEVICE(DU%DEVC_INDEX)%CURRENT_STATE .NEQV. DEVICE(DU%DEVC_INDEX)%PRIOR_STATE)) &
            DU%COIL_ON_TIME = T
   ENDIF
   IF (DU%CTRL_INDEX > 0) THEN
      DU%COIL_OPERATING = CONTROL(DU%CTRL_INDEX)%CURRENT_STATE
      IF (DU%COIL_OPERATING .AND. (CONTROL(DU%CTRL_INDEX)%CURRENT_STATE .NEQV. CONTROL(DU%CTRL_INDEX)%PRIOR_STATE)) &
            DU%COIL_ON_TIME = T
   ENDIF

   DU%COIL_Q = 0._EB
   IF (.NOT. DU%COIL_OPERATING) CYCLE COIL_LOOP

   AC => AIRCOIL(DU%AIRCOIL_INDEX)
   IF (AC%FIXED_Q > -1.E9_EB) THEN
      TSI = T - DU%COIL_ON_TIME
      DU%COIL_Q = AC%FIXED_Q*EVALUATE_RAMP(TSI,AC%TAU,AC%RAMP_INDEX)      
   ELSE
      TMP_IN = DU%TMP_D
      CP = DU%CP_D
      MDOT_DU = DU%RHO_D*ABS(DU%VEL(GUESS))*DU%AREA
      E_IN_G = MDOT_DU*TMP_IN*CP
      TMP_OUT = (CP*MDOT_DU*TMP_IN + AC%COOLANT_TEMPERATURE*AC%COOLANT_MASS_FLOW*AC%COOLANT_SPECIFIC_HEAT)/&
                (CP*MDOT_DU + AC%COOLANT_MASS_FLOW*AC%COOLANT_SPECIFIC_HEAT)          
      DU%COIL_Q = AC%COOLANT_MASS_FLOW * AC%COOLANT_SPECIFIC_HEAT*(AC%COOLANT_TEMPERATURE - TMP_OUT)*AC%EFFICIENCY
   ENDIF
END DO COIL_LOOP

END SUBROUTINE COIL_UPDATE


SUBROUTINE GET_REV_HVAC(MODULE_REV,MODULE_DATE)
INTEGER,INTENT(INOUT) :: MODULE_REV
CHARACTER(255),INTENT(INOUT) :: MODULE_DATE
WRITE(MODULE_DATE,'(A)') hvacrev(INDEX(hvacrev,':')+2:LEN_TRIM(hvacrev)-2)
READ (MODULE_DATE,'(I5)') MODULE_REV
WRITE(MODULE_DATE,'(A)') hvacdate
END SUBROUTINE GET_REV_HVAC
 
END MODULE HVAC_ROUTINES
