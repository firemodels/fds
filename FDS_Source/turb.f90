! This set of modules is useful for verification tests and development of
! turbulence models.

MODULE nrutil
! Numerical Recipes in Fortran 90 Utilities (obtained on-line)
	USE nrtype
	IMPLICIT NONE
	
	PRIVATE
	
	INTEGER(I4B), PARAMETER :: NPAR_ARTH=16,NPAR2_ARTH=8
	INTEGER(I4B), PARAMETER :: NPAR_GEOP=4,NPAR2_GEOP=2
	INTEGER(I4B), PARAMETER :: NPAR_CUMSUM=16
	INTEGER(I4B), PARAMETER :: NPAR_CUMPROD=8
	INTEGER(I4B), PARAMETER :: NPAR_POLY=8
	INTEGER(I4B), PARAMETER :: NPAR_POLYTERM=8
	
	INTERFACE swap
		MODULE PROCEDURE swap_i,swap_r,swap_rv,swap_c, &
			swap_cv,swap_cm,swap_z,swap_zv,swap_zm, &
			masked_swap_rs,masked_swap_rv,masked_swap_rm
	END INTERFACE
	
	INTERFACE assert
		MODULE PROCEDURE assert1,assert2,assert3,assert4,assert_v
	END INTERFACE
	
	PUBLIC :: swap,assert

CONTAINS

	SUBROUTINE swap_i(a,b)
	INTEGER(I4B), INTENT(INOUT) :: a,b
	INTEGER(I4B) :: dum
	dum=a
	a=b
	b=dum
	END SUBROUTINE swap_i

	SUBROUTINE swap_r(a,b)
	REAL(SP), INTENT(INOUT) :: a,b
	REAL(SP) :: dum
	dum=a
	a=b
	b=dum
	END SUBROUTINE swap_r

	SUBROUTINE swap_rv(a,b)
	REAL(SP), DIMENSION(:), INTENT(INOUT) :: a,b
	REAL(SP), DIMENSION(SIZE(a)) :: dum
	dum=a
	a=b
	b=dum
	END SUBROUTINE swap_rv

	SUBROUTINE swap_c(a,b)
	COMPLEX(SPC), INTENT(INOUT) :: a,b
	COMPLEX(SPC) :: dum
	dum=a
	a=b
	b=dum
	END SUBROUTINE swap_c

	SUBROUTINE swap_cv(a,b)
	COMPLEX(SPC), DIMENSION(:), INTENT(INOUT) :: a,b
	COMPLEX(SPC), DIMENSION(SIZE(a)) :: dum
	dum=a
	a=b
	b=dum
	END SUBROUTINE swap_cv

	SUBROUTINE swap_cm(a,b)
	COMPLEX(SPC), DIMENSION(:,:), INTENT(INOUT) :: a,b
	COMPLEX(SPC), DIMENSION(size(a,1),size(a,2)) :: dum
	dum=a
	a=b
	b=dum
	END SUBROUTINE swap_cm

	SUBROUTINE swap_z(a,b)
	COMPLEX(DPC), INTENT(INOUT) :: a,b
	COMPLEX(DPC) :: dum
	dum=a
	a=b
	b=dum
	END SUBROUTINE swap_z

	SUBROUTINE swap_zv(a,b)
	COMPLEX(DPC), DIMENSION(:), INTENT(INOUT) :: a,b
	COMPLEX(DPC), DIMENSION(SIZE(a)) :: dum
	dum=a
	a=b
	b=dum
	END SUBROUTINE swap_zv

	SUBROUTINE swap_zm(a,b)
	COMPLEX(DPC), DIMENSION(:,:), INTENT(INOUT) :: a,b
	COMPLEX(DPC), DIMENSION(size(a,1),size(a,2)) :: dum
	dum=a
	a=b
	b=dum
	END SUBROUTINE swap_zm

	SUBROUTINE masked_swap_rs(a,b,mask)
	REAL(SP), INTENT(INOUT) :: a,b
	LOGICAL(LGT), INTENT(IN) :: mask
	REAL(SP) :: swp
	if (mask) then
		swp=a
		a=b
		b=swp
	end if
	END SUBROUTINE masked_swap_rs

	SUBROUTINE masked_swap_rv(a,b,mask)
	REAL(SP), DIMENSION(:), INTENT(INOUT) :: a,b
	LOGICAL(LGT), DIMENSION(:), INTENT(IN) :: mask
	REAL(SP), DIMENSION(size(a)) :: swp
	where (mask)
		swp=a
		a=b
		b=swp
	end where
	END SUBROUTINE masked_swap_rv

	SUBROUTINE masked_swap_rm(a,b,mask)
	REAL(SP), DIMENSION(:,:), INTENT(INOUT) :: a,b
	LOGICAL(LGT), DIMENSION(:,:), INTENT(IN) :: mask
	REAL(SP), DIMENSION(size(a,1),size(a,2)) :: swp
	where (mask)
		swp=a
		a=b
		b=swp
	end where
	END SUBROUTINE masked_swap_rm

	SUBROUTINE assert1(n1,string)
	CHARACTER(LEN=*), INTENT(IN) :: string
	LOGICAL, INTENT(IN) :: n1
	if (.not. n1) then
		write (*,*) 'nrerror: an assertion failed with this tag:', &
			string
		STOP 'program terminated by assert1'
	end if
	END SUBROUTINE assert1

	SUBROUTINE assert2(n1,n2,string)
	CHARACTER(LEN=*), INTENT(IN) :: string
	LOGICAL, INTENT(IN) :: n1,n2
	if (.not. (n1 .and. n2)) then
		write (*,*) 'nrerror: an assertion failed with this tag:', &
			string
		STOP 'program terminated by assert2'
	end if
	END SUBROUTINE assert2

	SUBROUTINE assert3(n1,n2,n3,string)
	CHARACTER(LEN=*), INTENT(IN) :: string
	LOGICAL, INTENT(IN) :: n1,n2,n3
	if (.not. (n1 .and. n2 .and. n3)) then
		write (*,*) 'nrerror: an assertion failed with this tag:', &
			string
		STOP 'program terminated by assert3'
	end if
	END SUBROUTINE assert3

	SUBROUTINE assert4(n1,n2,n3,n4,string)
	CHARACTER(LEN=*), INTENT(IN) :: string
	LOGICAL, INTENT(IN) :: n1,n2,n3,n4
	if (.not. (n1 .and. n2 .and. n3 .and. n4)) then
		write (*,*) 'nrerror: an assertion failed with this tag:', &
			string
		STOP 'program terminated by assert4'
	end if
	END SUBROUTINE assert4

	SUBROUTINE assert_v(n,string)
	CHARACTER(LEN=*), INTENT(IN) :: string
	LOGICAL, DIMENSION(:), INTENT(IN) :: n
	if (.not. all(n)) then
		write (*,*) 'nrerror: an assertion failed with this tag:', &
			string
		STOP 'program terminated by assert_v'
	end if
	END SUBROUTINE assert_v


END MODULE nrutil

!======================================================================

MODULE TURBULENCE

USE PRECISION_PARAMETERS
USE GLOBAL_CONSTANTS
USE MESH_POINTERS
USE MESH_VARIABLES
USE nrtype
USE COMP_FUNCTIONS

IMPLICIT NONE

PRIVATE
PUBLIC :: ANALYTICAL_SOLUTION, sandia_dat, init_spectral_data, spectral_output
 
CONTAINS


SUBROUTINE SANDIA_DAT(NM)
IMPLICIT NONE

! This routine reads the file 'iso_ini.dat', which is generated by
! turb_init.  This exe generates a random velocity field with a 
! spectrum that matches the Comte-Bellot/Corrsin 1971 experimental data.

REAL :: XXX
INTEGER :: I,J,K,II,JJ,KK,FILE_NUM
INTEGER, INTENT(IN) :: NM

CALL POINT_TO_MESH(NM)

FILE_NUM = GET_FILE_NUMBER()
OPEN (UNIT=FILE_NUM,FILE='iso_ini.dat',FORM='formatted',STATUS='old')
     
READ (FILE_NUM,*) II, JJ, KK	! reads number of points in each direction

IF (II/=IBAR .OR. JJ/=JBAR .OR. KK/=KBAR) THEN
   WRITE(LU_ERR,'(A)') 'Error in SANDIA_DAT!'
   STOP
ENDIF

READ (FILE_NUM,*) XXX, XXX, XXX	! reads lower physical dimension limit
READ (FILE_NUM,*) XXX, XXX, XXX	! reads upper physical dimension limit

DO K = 1,KBAR
   DO J = 1,JBAR
      DO I = 1,IBAR

         READ (FILE_NUM,*) U(I,J,K), V(I,J,K), W(I,J,K), XXX, XXX
         
         U(I,J,K) = 0.01*U(I,J,K)	! scale from cm/s
         V(I,J,K) = 0.01*V(I,J,K)
         W(I,J,K) = 0.01*W(I,J,K)
         
      ENDDO
   ENDDO
ENDDO

CLOSE (UNIT=FILE_NUM)

! subtract mean
U(1:IBAR,1:JBAR,1:KBAR) = U(1:IBAR,1:JBAR,1:KBAR) - SUM(U(1:IBAR,1:JBAR,1:KBAR))/REAL(IBAR*JBAR*KBAR,EB)
V(1:IBAR,1:JBAR,1:KBAR) = V(1:IBAR,1:JBAR,1:KBAR) - SUM(V(1:IBAR,1:JBAR,1:KBAR))/REAL(IBAR*JBAR*KBAR,EB)
W(1:IBAR,1:JBAR,1:KBAR) = W(1:IBAR,1:JBAR,1:KBAR) - SUM(W(1:IBAR,1:JBAR,1:KBAR))/REAL(IBAR*JBAR*KBAR,EB)

! apply periodic b.c.
U(0,:,:) = U(IBAR,:,:)
V(:,0,:) = V(:,JBAR,:)
W(:,:,0) = W(:,:,KBAR)

END SUBROUTINE SANDIA_DAT


SUBROUTINE init_spectral_data(NM)
USE MEMORY_FUNCTIONS, ONLY: ChkMemErr
IMPLICIT NONE
INTEGER, INTENT(IN) :: NM
INTEGER :: IZERO
INTEGER, POINTER :: n
TYPE (MESH_TYPE), POINTER :: M

CALL POINT_TO_MESH(NM)
M => MESHES(NM)
n => M%IBAR

ALLOCATE(M%tkeht(n,n,n),STAT=IZERO)
CALL ChkMemErr('init_spectral_data','tkeht',IZERO)
ALLOCATE(M%upht(n,n,n),STAT=IZERO)
CALL ChkMemErr('init_spectral_data','upht',IZERO)
ALLOCATE(M%vpht(n,n,n),STAT=IZERO)
CALL ChkMemErr('init_spectral_data','vpht',IZERO)
ALLOCATE(M%wpht(n,n,n),STAT=IZERO)
CALL ChkMemErr('init_spectral_data','wpht',IZERO)

M%tkeht = 0._EB
M%upht = 0._EB
M%vpht = 0._EB
M%wpht = 0._EB

END SUBROUTINE init_spectral_data


SUBROUTINE spectral_output(TT,NM)
IMPLICIT NONE
INTEGER, INTENT(IN) :: NM
REAL(EB), INTENT(IN) :: TT
INTEGER :: nn(3)

call POINT_TO_MESH(NM)
nn = IBAR

! take fourier transform of velocities in 3d...
call fft3d(U, upht, nn)
call fft3d(V, vpht, nn)
call fft3d(W, wpht, nn) 

! calc the spectral kinetic energy
call complex_tke(tkeht, upht, vpht, wpht, nn(1))

! total up the spectral energy for each mode and integrate over
! the resolved modes...
call spectrum(tkeht, nn(1), XF-XS, nint(100._EB*TT))
      
IF (TURB_INIT) call sandia_out(U(1:nn(1),1:nn(2),1:nn(3)), &
                               V(1:nn(1),1:nn(2),1:nn(3)), &
                               W(1:nn(1),1:nn(2),1:nn(3)), &
                               H(1:nn(1),1:nn(2),1:nn(3)), &
                               nn(1))
                      
spec_clock = spec_clock + dt_spec

END SUBROUTINE spectral_output


SUBROUTINE sandia_out(u,v,w,p,n)
IMPLICIT NONE

! Variable declarations

INTEGER, INTENT(IN) :: n
REAL(EB), INTENT(IN) :: u(n,n,n)
REAL(EB), INTENT(IN) :: v(n,n,n)
REAL(EB), INTENT(IN) :: w(n,n,n)
REAL(EB), INTENT(IN) :: p(n,n,n)
REAL(EB) :: uu,vv,ww,pp,ke

INTEGER :: i,j,k,file_num

! This subroutine writes out the velocity, relative pressure, and
! turbulent kinetic energy to the file 'ini_salsa.dat'.  This is
! then used as input to the 'turb_init' program.

file_num = GET_FILE_NUMBER()
OPEN (unit=file_num, file='ini_salsa.dat', form='formatted', status='unknown', position='rewind')

WRITE (file_num,997) n,n,n
WRITE (file_num,998) 0,0,0
WRITE (file_num,998) 2*pi,2*pi,2*pi

DO k = 1,n
   DO j = 1,n
      DO i = 1,n

         pp = 10._EB*p(i,j,k)  ! convert to dynes from pascals
         uu = 100._EB*u(i,j,k) ! convert to cm/s from m/s
         vv = 100._EB*v(i,j,k)
         ww = 100._EB*w(i,j,k)
         	
         ke = 0.5_EB*( uu**2 + vv**2 + ww**2 )

         WRITE (file_num,999) uu,vv,ww,pp,ke
         
      END DO
   END DO
END DO

CLOSE (unit=file_num)


997	FORMAT(3(i6,8x))
998	FORMAT(3(f12.6,2x))
999	FORMAT(5(f12.6,2x))


END SUBROUTINE sandia_out


SUBROUTINE complex_tke(tkeht, upht, vpht, wpht, n)
IMPLICIT NONE
INTEGER, INTENT(IN) :: n
COMPLEX(DPC), INTENT(OUT) :: tkeht(n,n,n)
COMPLEX(DPC), INTENT(IN) :: upht(n,n,n),vpht(n,n,n),wpht(n,n,n)
INTEGER i,j,k

do k = 1,n
   do j = 1,n
      do i = 1,n
         tkeht(i,j,k) = 0.5_DP*( upht(i,j,k)*conjg(upht(i,j,k)) + &
                                 vpht(i,j,k)*conjg(vpht(i,j,k)) + &
                                 wpht(i,j,k)*conjg(wpht(i,j,k)) )
      end do
   end do
end do

END SUBROUTINE complex_tke


SUBROUTINE fft3d(v, vht, nn)
IMPLICIT NONE
INTEGER, INTENT(IN) :: nn(3)
REAL(EB), INTENT(IN) :: v(0:nn(1),0:nn(2),0:nn(3))
COMPLEX(DPC), INTENT(INOUT) :: vht(nn(1),nn(2),nn(3))
!COMPLEX(DPC) :: z2(nn(1))

! This routine performs an FFT on the real array v and places the
! result in the complex array vht.
! Apparently, "z2" is just a working array needed by 'fourt.f'
! Please see 'fourt.f' for a description, but as far as the Sandia
! codes are concerned they just dimensioned it as z2(Nx), and so
! that is what we shall do...  Hence, better make sure that Nx is
! largest dimension.

INTEGER :: i,j,k
REAL(EB) :: tke

! convert v to spectral space

tke = 0._EB

do k = 1,nn(3)
   do j = 1,nn(2)
      do i = 1,nn(1)
      
         vht(i,j,k) = cmplx(v(i,j,k),0.0_EB,kind=DPC)
         tke = tke + 0.5_EB*v(i,j,k)**2

      end do
   end do
end do

tke = tke/real(nn(1)*nn(2)*nn(3),EB)

! print*, ' fft3d internal check-'
! print*, ' tkeave (physical) =', tke

!call fourt(vht,nn,3,-1,1,z2)
call four3(vht,-1)

do k = 1,nn(3)
   do j = 1,nn(2)
      do i = 1,nn(1)

         vht(i,j,k) = vht(i,j,k)/nn(1)/nn(2)/nn(3)

      end do
   end do
end do

tke = 0._EB

do k = 1,nn(3)
   do j = 1,nn(2)
      do i = 1,nn(1)

         tke = tke + 0.5_EB*real(vht(i,j,k)*conjg(vht(i,j,k)),kind=EB)

      end do
   end do
end do

! print*, ' tkeave (spectral) =', tke

END SUBROUTINE fft3d


SUBROUTINE spectrum(vht, n, Lm, iFVfilenum)
IMPLICIT NONE
INTEGER, INTENT(IN) :: n, iFVfilenum 
COMPLEX(DPC), INTENT(IN) :: vht(n,n,n)
REAL(DP), INTENT(IN) :: Lm

! This routine is copied from SNL and is intended to compute the
! kinetic energy spectrum in wavenumber space.

INTEGER :: kmax, kx, ky, kz, k, ksum, file_num
INTEGER :: num(0:n)

REAL(DP) :: rk, temp, vsum, rkx, rky, rkz, etot
REAL(DP) :: vt(0:n)

CHARACTER*6 :: ext
CHARACTER*18 :: filename

! for dimensional wavenumbers
REAL(DP) :: wn(0:n)
REAL(DP) :: L, k0
      
L = Lm

k0 = 2*PI_D/L
kmax = n/2
	
wn(0) = 0._DP
do k = 1,n
   wn(k) = k0*k
end do

do k = 0,n
   vt(k) = 0._DP
   num(k) = 0
end do

etot = 0._DP

do kx = 1,n

   rkx = real(kx-1,kind=DP)
   if (rkx .gt. kmax) then
      rkx = n - rkx
   end if

   do ky = 1,n

      rky = real(ky-1,kind=DP)
      if (rky .gt. kmax) then
         rky = n - rky
      end if

      do kz = 1,n

         rkz = real(kz-1,kind=DP)
         if (rkz .gt. kmax) then
            rkz = n - rkz
         end if

         rk     = sqrt(rkx*rkx + rky*rky + rkz*rkz)
         k      = nint(rk)

         num(k) = num(k) + 1
         temp   = real(vht(kx,ky,kz)*conjg(vht(kx,ky,kz)),kind=DP)
         etot   = etot + sqrt(temp)
         vt(k)  = vt(k) + sqrt(temp)*(L/(2*PI_D))

      end do
   end do
end do

write(6,*) ' '
write(6,*) ' Spectrum Internal Check-'
write(6,*) ' Total Energy (-) in 3D field = ', etot
write(6,*) ' k(-), Num(k), k(1/cm), E(cm3/s2) '
ksum = 0
vsum = 0._DP
do k = 0,n
   write(6,*) k, num(k), wn(k), vt(k)
   ksum = ksum + num(k)
   vsum = vsum + vt(k)
end do

write(6,*) ' ksum: ', ksum
write(6,*) ' Total Energy (-) in spectrum: ', vsum
write(6,*) ' '

! write the spectral data to a file
! units are (1/cm) for wavenumber and (cm3/s2) for energy
! this matches the Comte-Bellot/Corrsin units

write(ext,1) iFVfilenum
filename = 'spec' // TRIM(ext) // '.dat'

file_num = GET_FILE_NUMBER()
open (unit=file_num, file=filename, status='unknown', form='formatted')

do k = 0,n
   write (file_num,*) wn(k), vt(k)
end do

close (unit = file_num)

1	format (i3.3)

END SUBROUTINE spectrum


SUBROUTINE four3(data,isign)
! Manually copied from Numerical Recipes in Fortran 90, p. 1246, by RJM
IMPLICIT NONE
COMPLEX(DPC), DIMENSION(:,:,:), INTENT(INOUT) :: data
INTEGER(I4B), INTENT(IN) :: isign
! Replaces a 3-d complex array (data) by its discrete 3-d Fourier transform, if isign is input
! as 1; or replaces data by its inverse 3-d dicrete Fourier transform times the product of its
! three sizes, if isign in input as -1.  All three of data's sizes must be integer powers of 2
! (this is checked in fourrow_3d). Parallelism is by use of fourrow_3d.
COMPLEX(DPC), DIMENSION(:,:,:), ALLOCATABLE :: dat2,dat3
call fourrow_3d_dp(data,isign) ! Transform the third dimension.
allocate(dat2(size(data,2),size(data,3),size(data,1)))
dat2 = reshape(data,shape=shape(dat2),order=(/3,1,2/)) ! Transpose.
call fourrow_3d_dp(dat2,isign) ! Transform in (original) first dimension.
allocate(dat3(size(data,3),size(data,1),size(data,2)))
dat3 = reshape(dat2,shape=shape(dat3),order=(/3,1,2/)) ! Transpose.
deallocate(dat2)
call fourrow_3d_dp(dat3,isign) ! Transform in (original) second dimension.
data = reshape(dat3,shape=shape(data),order=(/3,1,2/)) ! Transpose back to output order.
deallocate(dat3)
END SUBROUTINE four3


SUBROUTINE fourrow_3d_dp(data,isign)
! Manually copied from Numerical Recipes in Fortran 90, p. 1236, by RJM
USE nrutil, ONLY: assert,swap
IMPLICIT NONE
COMPLEX(DPC), DIMENSION(:,:,:), INTENT(INOUT) :: data
INTEGER(I4B), INTENT(IN) :: isign
! If isign is input at 1, replaces each third-index section (constant first and second indices)
! of data(1:L,1:M,1:N) by its discrete Fourier transform (transform on third index); or
! replaces each third-index section of data by N times its inverse discrete Fourier transform,
! if sign is input as -1. N must be an integer power of 2. Parallelism is LxM-fold on
! the first and second indices of data.
INTEGER(I4B) :: n,i,istep,j,m,mmax,n2
REAL(DP) :: theta
COMPLEX(DPC), DIMENSION(size(data,1),size(data,2)) :: temp
COMPLEX(DPC) :: w,wp ! Double precision for trigonometric recurrences.
COMPLEX(DPC) :: ws
n=size(data,3)
call assert(iand(n,n-1)==0,'n must be a power of 2 in fourrow_3d_dp')
n2=n/2
j=n2
! This is the bit-reversal section of the routine.
do i=1,n-2
   if (j > i) call swap(data(:,:,j+1),data(:,:,i+1))
   m=n2
   do
      if (m < 2 .or. j < m) exit
      j=j-m
      m=m/2
   end do
   j=j+m
end do
mmax=1
! Here begins the Danielson-Lanczos section of the routine.
do                            ! Outer loop executed log_2 N times
   if (n <= mmax) exit
   istep=2*mmax
   theta=PI_D/(isign*mmax)    ! Initialize for the trigonometric recurrence.
   wp=cmplx(-2.0_dp*sin(0.5_dp*theta)**2,sin(theta),kind=dpc)
   w=cmplx(1.0_dp,0.0_dp,kind=dpc)
   do m=1,mmax                ! Here are the two nested inner loops.
      ws=w
      do i=m,n,istep
         j=i+mmax
         temp=ws*data(:,:,j)  ! This is Danielson-Lanczos formula.
         data(:,:,j)=data(:,:,i)-temp
         data(:,:,i)=data(:,:,i)+temp
      end do
      w=w*wp+w                ! Trigonometric recurrence.
   end do
   mmax=istep
end do
END SUBROUTINE fourrow_3d_dp


SUBROUTINE ANALYTICAL_SOLUTION(NM)
IMPLICIT NONE
! Initialize flow variables with an analytical solution of the governing equations

INTEGER, INTENT(IN) :: NM
INTEGER :: I,J,K
REAL(EB) :: UU,WW

CALL POINT_TO_MESH(NM)

DO K=1,KBAR
   DO J=1,JBAR
      DO I=0,IBAR
         U(I,J,K) = 1._EB - 2._EB*COS(X(I))*SIN(ZC(K))
      ENDDO
   ENDDO
ENDDO
DO K=0,KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         W(I,J,K) = 1._EB + 2._EB*SIN(XC(I))*COS(Z(K))
      ENDDO
   ENDDO
ENDDO
DO K=0,KBP1
   DO J=0,JBP1
      DO I=0,IBP1
         UU = 1._EB - 2._EB*COS(XC(I))*SIN(ZC(K))
         WW = 1._EB + 2._EB*SIN(XC(I))*COS(ZC(K))
         H(I,J,K) = -( COS(2._EB*XC(I)) + COS(2._EB*ZC(K)) ) + 0.5_EB*(UU**2+WW**2)
      ENDDO
   ENDDO
ENDDO

H(1:IBAR,1:JBAR,1:KBAR) = H(1:IBAR,1:JBAR,1:KBAR) - SUM(H(1:IBAR,1:JBAR,1:KBAR))/REAL(IBAR*JBAR*KBAR,EB)

END SUBROUTINE ANALYTICAL_SOLUTION


END MODULE TURBULENCE

