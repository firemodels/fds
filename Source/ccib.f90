
!  +++++++++++++++++++++++ CC_SCALARS ++++++++++++++++++++++++++


! Routines related to cut-cells, scalar transport and immersed boundary methods
!
MODULE CC_SCALARS

USE COMPLEX_GEOMETRY
USE PRECISION_PARAMETERS
USE GLOBAL_CONSTANTS
USE MESH_VARIABLES
USE MESH_POINTERS
USE COMP_FUNCTIONS, ONLY: CURRENT_TIME, GET_FILE_NUMBER
USE MATH_FUNCTIONS, ONLY: GET_SCALAR_FACE_VALUE

IMPLICIT NONE (TYPE,EXTERNAL)

! Debug Flags:
LOGICAL, PARAMETER :: DEBUG_CC_INTERPOLATION=.FALSE. ! IBM interpolation and forcing scheme.
LOGICAL, PARAMETER :: DEBUG_MATVEC_DATA=.FALSE.  ! Cut-cell region indexing, construction of regular, rc faces for scalars, etc.
LOGICAL, PARAMETER :: DEBUG_CC_SCALAR_TRANSPORT=.FALSE. ! Time integration algorithms for scalar tranport in cut-cell region.
LOGICAL, PARAMETER :: TIME_CC_IBM=.FALSE. ! Enable timers for main CC_IBM routines. Time stepping wall times in CHID_cc_cpu.csv
INTEGER :: LU_DB_CCIB

! Forcing and Inseparable pressure residual computation parameters:
REAL(EB), PARAMETER:: A_THRESH_FORCING     = 0.05_EB
REAL(EB), PARAMETER:: STM_THRESH_EXTRP     = 0.005_EB
REAL(EB), PARAMETER:: V_THRESH_INSPRES     = 0.005_EB

! Local integers:
INTEGER, SAVE :: ILO_CELL,IHI_CELL,JLO_CELL,JHI_CELL,KLO_CELL,KHI_CELL
INTEGER, SAVE :: ILO_FACE,IHI_FACE,JLO_FACE,JHI_FACE,KLO_FACE,KHI_FACE
INTEGER, SAVE :: NXB, NYB, NZB

! Allocatable real arrays
! Grid position containers:
REAL(EB), SAVE, TARGET, ALLOCATABLE, DIMENSION(:) :: XFACE,YFACE,ZFACE,XCELL,YCELL,ZCELL, &
          DXFACE,DYFACE,DZFACE,DXCELL,DYCELL,DZCELL

REAL(EB), POINTER, DIMENSION(:) :: X1FACEP,X2FACEP,X3FACEP,  &
                   X2CELLP,X3CELLP ! X1CELLP,DX1FACEP,DX2FACEP,DX3FACEP,DX1CELLP,DX2CELLP,DX3CELLP not used.

! Scalar transport variables:
INTEGER, ALLOCATABLE, DIMENSION(:) :: NUNKZ_LOC, NUNKZ_TOT, UNKZ_IND, UNKZ_ILC
INTEGER :: NUNKZ_LOCAL,NUNKZ_TOTAL

INTEGER, PARAMETER :: NNZ_ROW_Z = 15 ! 7 point stencil + 8 (buffer in case of unstructured grid).

INTEGER, ALLOCATABLE, DIMENSION(:)    :: NNZ_D_MAT_Z
INTEGER, ALLOCATABLE, DIMENSION(:,:)  :: JD_MAT_Z

REAL(EB),ALLOCATABLE, DIMENSION(:)   :: M_MAT_Z
INTEGER, ALLOCATABLE, DIMENSION(:)   :: JM_MAT_Z

REAL(EB), ALLOCATABLE, DIMENSION(:)  :: F_Z, RZ_Z, RZ_ZS, P_0_CV, TMP_0_CV, RHO_0_CV, ZCEN_CV
REAL(EB), ALLOCATABLE, DIMENSION(:,:):: F_Z0, RZ_Z0

REAL(EB), DIMENSION(0:3,0:3,0:3) :: U_TEMP,Z_TEMP,F_TEMP

! Types of interpolation:
INTEGER, PARAMETER :: CC_LINEAR_INTERPOLATION    = 1
INTEGER, PARAMETER :: CC_QUADRATIC_INTERPOLATION = 2
INTEGER, PARAMETER :: CC_WLS_INTERPOLATION       = 3
INTEGER, SAVE      :: STENCIL_INTERPOLATION       = CC_LINEAR_INTERPOLATION ! Set to linear by default.

! IBEDGE stress definition stencil variables:
REAL(EB), SAVE :: THRES_FCT_EP = 0.49999_EB
INTEGER, PARAMETER  :: N_INT_EP_FVARS=1 ! Only INT_VEL_IND=1
INTEGER, PARAMETER  :: N_INT_EP_CVARS=1 ! Only INT_MU_IND =1


! Rotated Cube verification case wave number:
! 1 , SPEC ID=MY BACKGROUND
! 2 , SPEC ID=NEUMANN SPEC
INTEGER,  PARAMETER :: N_SPEC_BACKG = 1
INTEGER,  PARAMETER :: N_SPEC_NEUMN = 2
REAL(EB), PARAMETER :: GAM = PI/2._EB, AMP_Z=0.1_EB, MEAN_Z=0.15_EB
REAL(EB), PARAMETER :: NWAVE = 1._EB
REAL(EB), PARAMETER :: DISPXY(1:2,1) = RESHAPE((/ -PI/2._EB, -PI/2._EB /),(/2,1/))
REAL(EB), PARAMETER :: DISPL  = PI
REAL(EB) :: ROTANG, ROTMAT(2,2), TROTMAT(2,2)

TYPE(WALL_TYPE),           POINTER :: WC
TYPE(CFACE_TYPE),          POINTER :: CFA
TYPE(CC_CUTCELL_TYPE),     POINTER :: CC=>NULL()
TYPE(CC_CUTFACE_TYPE),     POINTER :: CF=>NULL()
TYPE(CC_RCFACE_TYPE),      POINTER :: RCF=>NULL()
TYPE(BOUNDARY_COORD_TYPE), POINTER :: BC
TYPE(EXTERNAL_WALL_TYPE),  POINTER :: EWC
TYPE(BOUNDARY_PROP1_TYPE), POINTER :: B1

! Baroclininc torque linking variables.
REAL(EB), SAVE, ALLOCATABLE, DIMENSION(:) :: F_LINK,A_LINK

PRIVATE

PUBLIC :: ADD_CUTCELL_D_PBAR_DT, ADD_LINKEDCELL_D_PBAR_DT,ADD_CUTCELL_PSUM,ADD_LINKEDCELL_PSUM,&
          ADD_INPLACE_NNZ_H_WHLDOM,CALL_FOR_GLMAT,CALL_FROM_GLMAT_SETUP,&
          CCCOMPUTE_RADIATION,CC_DIVERGENCE_PART_1,CC_VEL_FACE_TO_SOLID_NODE,CC_BAROCLINIC_CORRECTION,&
          CC_CHECK_DIVERGENCE,CC_COMPUTE_VELOCITY_ERROR, &
          CC_END_STEP,CC_H_INTERP,CC_NO_FLUX,CC_PROJECT_VELOCITY, &
          CC_RHO0W_INTERP,CC_SET_DATA,CC_VELOCITY_BC,&
          CC_VELOCITY_FLUX,CC_MATCH_VELOCITY,CC_MATCH_VELOCITY_FLUX, &
          CC_DENSITY,CC_COMPUTE_KRES,CC_COMPUTE_VISCOSITY,&
          CC_CUTFACE_VELOCITY,CC_RESTORE_UVW_UNLINKED,&
          CHECK_CFLVN_LINKED_CELLS,ADD_Q_DOT_CUTCELLS,CFACE_THERMAL_GASVARS,&
          CFACE_PREDICT_NORMAL_VELOCITY,COMPUTE_LINKED_CUTFACE_BAROCLINIC,&
          COPY_CC_UNKH_TO_HS, COPY_CC_HS_TO_UNKH, COPY_UNST_DM_TO_CART, CUTFACE_VELOCITIES, &
          GET_CFACE_OPEN_BC_COEF,GET_FN_DIVERGENCE_CUTCELL,GET_OPENBC_TANGENTIAL_CUTFACE_VEL,&
          GET_CUTCELL_DDDT,GET_H_CUTFACES,GET_H_MATRIX_CC,GET_H_GUARD_CUTCELL,GET_CRTCFCC_INT_STENCILS,GET_RCFACES_H, &
          GET_CC_MATRIXGRAPH_H,GET_CC_IROW,GET_CC_UNKH,GET_CUTCELL_HP, GET_LINKED_FV, GET_PRES_CFACE_BCS, &
          GET_PRES_CFACE, GET_PRES_CFACE_TEST, GET_UVWGAS_CFACE, GET_MUDNS_CFACE, GET_BOUNDFACE_GEOM_INFO_H, &
          GET_FH_FROM_PRHS_AND_BCS,GET_LINKED_VELOCITIES, &
          FINISH_CC, INIT_CUTCELL_DATA,MESH_CC_EXCHANGE,NUMBER_UNKH_CUTCELLS,&
          ROTATED_CUBE_ANN_SOLN,ROTATED_CUBE_VELOCITY_FLUX,ROTATED_CUBE_RHS_ZZ,&
          SET_EXIMADVFLX_3D,SET_EXIMDIFFLX_3D,SET_EXIMRHOHSLIM_3D,&
          SET_EXIMRHOZZLIM_3D,UNSTRUCTURED_POISSON_RESIDUAL,UNSTRUCTURED_POISSON_RESIDUAL_RC

CONTAINS

! ------------------------ COPY_UNST_DM_TO_CART -------------------------------------

SUBROUTINE COPY_UNST_DM_TO_CART(NM)
! Assumes POINT_TO_MESH(NM) has been called.
INTEGER, INTENT(IN) :: NM
INTEGER :: ICC,JCC,I,J,K,NS
REAL(EB) :: VOL

DO ICC=1,MESHES(NM)%N_CUTCELL_MESH+MESHES(NM)%N_GCCUTCELL_MESH
   CC => CUT_CELL(ICC);  I = CC%IJK(IAXIS); J = CC%IJK(JAXIS);  K = CC%IJK(KAXIS)
   IF(I < 0 .OR. I > IBP1) CYCLE
   IF(J < 0 .OR. J > JBP1) CYCLE
   IF(K < 0 .OR. K > KBP1) CYCLE
   IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE ! Cycle in case Cartesian cell inside OBSTS.
   IF (.NOT.ALLOCATED(MESHES(NM)%D_SOURCE)) CYCLE
   VOL=DX(I)*DY(J)*DZ(K); D_SOURCE(I,J,K) =0._EB; M_DOT_PPP(I,J,K,1:N_TRACKED_SPECIES)=0._EB
   DO JCC=1,CC%NCELL
      D_SOURCE(I,J,K) = D_SOURCE(I,J,K) + CUT_CELL(ICC)%D_SOURCE(JCC)*CUT_CELL(ICC)%VOLUME(JCC)
      DO NS=1,N_TRACKED_SPECIES
        M_DOT_PPP(I,J,K,NS) = M_DOT_PPP(I,J,K,NS) + CUT_CELL(ICC)%M_DOT_PPP(NS,JCC)*CUT_CELL(ICC)%VOLUME(JCC)
      ENDDO
   ENDDO
   D_SOURCE(I,J,K) = D_SOURCE(I,J,K)/VOL
   M_DOT_PPP(I,J,K,1:N_TRACKED_SPECIES) = M_DOT_PPP(I,J,K,1:N_TRACKED_SPECIES)/VOL
ENDDO

RETURN
END SUBROUTINE COPY_UNST_DM_TO_CART

! --------------------- GET_OPENBC_TANGENTIAL_CUTFACE_VEL ---------------------------

SUBROUTINE GET_OPENBC_TANGENTIAL_CUTFACE_VEL(APPLY_TO_ESTIMATED_VARIABLES,UPWIND_BOUNDARY,INFLOW_BOUNDARY,&
                                             IEC,II,JJ,KK,IOR,UU,VV,WW)

LOGICAL, INTENT(IN) :: APPLY_TO_ESTIMATED_VARIABLES,UPWIND_BOUNDARY,INFLOW_BOUNDARY
INTEGER, INTENT(IN) :: IEC,II,JJ,KK,IOR
REAL(EB), INTENT(INOUT), POINTER, DIMENSION(:,:,:) :: UU,VV,WW

INTEGER :: I1,J1,K1,I2,J2,K2,AXIS
REAL(EB):: VWND
REAL(EB), POINTER, DIMENSION(:,:,:) :: VELOC

IF (.NOT.UPWIND_BOUNDARY .OR. .NOT.INFLOW_BOUNDARY) THEN  ! For regular OPEN boundary, (free-slip) BCs
   SELECT CASE(IEC)
      CASE(1)
         IF (JJ==0    .AND. IOR== 2) THEN; I1=  II; J1=   0; K1=  KK; I2=  II; J2=   1; K2=  KK; AXIS=KAXIS; VELOC=>WW; ENDIF
         IF (JJ==JBAR .AND. IOR==-2) THEN; I1=  II; J1=JBP1; K1=  KK; I2=  II; J2=JBAR; K2=  KK; AXIS=KAXIS; VELOC=>WW; ENDIF
         IF (KK==0    .AND. IOR== 3) THEN; I1=  II; J1=  JJ; K1=   0; I2=  II; J2=  JJ; K2=   1; AXIS=JAXIS; VELOC=>VV; ENDIF
         IF (KK==KBAR .AND. IOR==-3) THEN; I1=  II; J1=  JJ; K1=KBP1; I2=  II; J2=  JJ; K2=KBAR; AXIS=JAXIS; VELOC=>VV; ENDIF
      CASE(2)
         IF (II==0    .AND. IOR== 1) THEN; I1=   0; J1=  JJ; K1=  KK; I2=   1; J2=  JJ; K2=  KK; AXIS=KAXIS; VELOC=>WW; ENDIF
         IF (II==IBAR .AND. IOR==-1) THEN; I1=IBP1; J1=  JJ; K1=  KK; I2=IBAR; J2=  JJ; K2=  KK; AXIS=KAXIS; VELOC=>WW; ENDIF
         IF (KK==0    .AND. IOR== 3) THEN; I1=  II; J1=  JJ; K1=   0; I2=  II; J2=  JJ; K2=   1; AXIS=IAXIS; VELOC=>UU; ENDIF
         IF (KK==KBAR .AND. IOR==-3) THEN; I1=  II; J1=  JJ; K1=KBP1; I2=  II; J2=  JJ; K2=KBAR; AXIS=IAXIS; VELOC=>UU; ENDIF
      CASE(3)
         IF (II==0    .AND. IOR== 1) THEN; I1=   0; J1=  JJ; K1=  KK; I2=   1; J2=  JJ; K2=  KK; AXIS=JAXIS; VELOC=>VV; ENDIF
         IF (II==IBAR .AND. IOR==-1) THEN; I1=IBP1; J1=  JJ; K1=  KK; I2=IBAR; J2=  JJ; K2=  KK; AXIS=JAXIS; VELOC=>VV; ENDIF
         IF (JJ==0    .AND. IOR== 2) THEN; I1=  II; J1=   0; K1=  KK; I2=  II; J2=   1; K2=  KK; AXIS=IAXIS; VELOC=>UU; ENDIF
         IF (JJ==JBAR .AND. IOR==-2) THEN; I1=  II; J1=JBP1; K1=  KK; I2=  II; J2=JBAR; K2=  KK; AXIS=IAXIS; VELOC=>UU; ENDIF
   END SELECT
   CALL SET_GHOSTFACE_VEL_FREESLIP(I1,J1,K1,I2,J2,K2,AXIS,VELOC)
ELSE ! For upwind, inflow boundaries, use the specified wind field for tangential velocity components
   SELECT CASE(IEC)
      CASE(1)
         IF (JJ==0    .AND. IOR== 2) THEN; I1=  II; J1=   0; K1=  KK; AXIS=KAXIS; VWND=W_WIND(KK); VELOC=>WW; ENDIF
         IF (JJ==JBAR .AND. IOR==-2) THEN; I1=  II; J1=JBP1; K1=  KK; AXIS=KAXIS; VWND=W_WIND(KK); VELOC=>WW; ENDIF
         IF (KK==0    .AND. IOR== 3) THEN; I1=  II; J1=  JJ; K1=   0; AXIS=JAXIS; VWND=V_WIND(KK); VELOC=>VV; ENDIF
         IF (KK==KBAR .AND. IOR==-3) THEN; I1=  II; J1=  JJ; K1=KBP1; AXIS=JAXIS; VWND=V_WIND(KK); VELOC=>VV; ENDIF
      CASE(2)
         IF (II==0    .AND. IOR== 1) THEN; I1=   0; J1=  JJ; K1=  KK; AXIS=KAXIS; VWND=W_WIND(KK); VELOC=>WW; ENDIF
         IF (II==IBAR .AND. IOR==-1) THEN; I1=IBP1; J1=  JJ; K1=  KK; AXIS=KAXIS; VWND=W_WIND(KK); VELOC=>WW; ENDIF
         IF (KK==0    .AND. IOR== 3) THEN; I1=  II; J1=  JJ; K1=   0; AXIS=IAXIS; VWND=U_WIND(KK); VELOC=>UU; ENDIF
         IF (KK==KBAR .AND. IOR==-3) THEN; I1=  II; J1=  JJ; K1=KBP1; AXIS=IAXIS; VWND=U_WIND(KK); VELOC=>UU; ENDIF
      CASE(3)
         IF (II==0    .AND. IOR== 1) THEN; I1=   0; J1=  JJ; K1=  KK; AXIS=JAXIS; VWND=V_WIND(KK); VELOC=>VV; ENDIF
         IF (II==IBAR .AND. IOR==-1) THEN; I1=IBP1; J1=  JJ; K1=  KK; AXIS=JAXIS; VWND=V_WIND(KK); VELOC=>VV; ENDIF
         IF (JJ==0    .AND. IOR== 2) THEN; I1=  II; J1=   0; K1=  KK; AXIS=IAXIS; VWND=U_WIND(KK); VELOC=>UU; ENDIF
         IF (JJ==JBAR .AND. IOR==-2) THEN; I1=  II; J1=JBP1; K1=  KK; AXIS=IAXIS; VWND=U_WIND(KK); VELOC=>UU; ENDIF
   END SELECT
   CALL SET_GHOSTFACE_VEL_WIND(I1,J1,K1,AXIS,VWND,VELOC)
ENDIF

RETURN

CONTAINS

SUBROUTINE SET_GHOSTFACE_VEL_FREESLIP(I1,J1,K1,I2,J2,K2,AXIS,VELOC)
INTEGER, INTENT(IN) :: I1,J1,K1,I2,J2,K2,AXIS
REAL(EB), INTENT(INOUT), POINTER, DIMENSION(:,:,:) :: VELOC

TYPE(CC_CUTFACE_TYPE), POINTER :: CF1, CF2
INTEGER :: IFC1, IFC2
REAL(EB):: VEL_CF, AREAT

IFC1 = FCVAR(I1,J1,K1,CC_IDCF,AXIS); IFC2 = FCVAR(I2,J2,K2,CC_IDCF,AXIS)
IF(IFC1<1 .AND. IFC2<1) RETURN ! Both faces are Regular gas or solid.
IF (IFC1>0) THEN ! Ghost face is gas cut-face.
   IF(IFC2<1) THEN; VEL_CF = VELOC(I2,J2,K2) ! Donor is regular gasphase.
   ELSE; VEL_CF = VELOC(I2,J2,K2)/CUT_FACE(IFC2)%ALPHA_CF ! Donor face is gas cut-face.
   ENDIF
   CF1 => CUT_FACE(IFC1)
   IF(APPLY_TO_ESTIMATED_VARIABLES) THEN; CF1%VELS(1:CF1%NFACE) = VEL_CF
   ELSE; CF1%VEL(1:CF1%NFACE)  = VEL_CF
   ENDIF
   CF1%VEL_CF  = VEL_CF; CF1%VEL_CRT = VEL_CF*CF1%ALPHA_CF
   VELOC(I1,J1,K1) = CF1%VEL_CRT
ELSEIF(FCVAR(I1,J1,K1,CC_FGSC,AXIS)==CC_GASPHASE) THEN ! Ghost face is regular gasphase.
   CF2   => CUT_FACE(IFC2)
   AREAT = SUM(CF2%AREA(1:CF2%NFACE))
   ! Donor is cut-face:
   IF(APPLY_TO_ESTIMATED_VARIABLES) THEN; VELOC(I1,J1,K1)=DOT_PRODUCT(CF2%VELS(1:CF2%NFACE),CF2%AREA(1:CF2%NFACE))/AREAT
   ELSE; VELOC(I1,J1,K1) = DOT_PRODUCT(CF2%VEL(1:CF2%NFACE),CF2%AREA(1:CF2%NFACE))/AREAT
   ENDIF
ENDIF

END SUBROUTINE SET_GHOSTFACE_VEL_FREESLIP

SUBROUTINE SET_GHOSTFACE_VEL_WIND(I1,J1,K1,AXIS,VWND,VELOC)
INTEGER, INTENT(IN) :: I1,J1,K1,AXIS
REAL(EB),INTENT(IN) :: VWND
REAL(EB), INTENT(INOUT), POINTER, DIMENSION(:,:,:) :: VELOC

TYPE(CC_CUTFACE_TYPE), POINTER :: CF1
INTEGER :: IFC1

IFC1 = FCVAR(I1,J1,K1,CC_IDCF,AXIS); IF(IFC1<1) RETURN ! Ghost face is Regular gas or solid.
CF1 => CUT_FACE(IFC1)
IF(APPLY_TO_ESTIMATED_VARIABLES) THEN; CF1%VELS(1:CF1%NFACE) = VWND
ELSE; CF1%VEL(1:CF1%NFACE)  = VWND
ENDIF
CF1%VEL_CF  = VWND; CF1%VEL_CRT = VWND*CF1%ALPHA_CF
VELOC(I1,J1,K1) = CF1%VEL_CRT

END SUBROUTINE SET_GHOSTFACE_VEL_WIND

END SUBROUTINE GET_OPENBC_TANGENTIAL_CUTFACE_VEL

! --------------------------- GET_H_GUARD_CUTCELL -----------------------------------

SUBROUTINE GET_H_GUARD_CUTCELL(IPZ,HP)

! assumes POINT_TO_MESH(NM) has been called.
INTEGER, INTENT(IN) :: IPZ
REAL(EB), INTENT(IN), POINTER, DIMENSION(:,:,:) :: HP

! Local Variables:
INTEGER :: IW, ICC
TYPE (WALL_TYPE),  POINTER :: WC
TYPE (BOUNDARY_COORD_TYPE), POINTER :: BC

IF(PRES_FLAG==ULMAT_FLAG) THEN
  IF(ONE_UNKH_PER_CUTCELL) THEN
     ! To DO.
  ELSE
     WALL_CELL_LOOP_2 : DO IW=1,N_EXTERNAL_WALL_CELLS
        WC => WALL(IW); BC => BOUNDARY_COORD(WC%BC_INDEX); ICC = CCVAR(BC%II,BC%JJ,BC%KK,CC_IDCC)
        ! Gasphase cell indexes:
        IF(ZONE_MESH(PRESSURE_ZONE(BC%IIG,BC%JJG,BC%KKG))%CONNECTED_ZONE_PARENT/=IPZ .OR. ICC<1)CYCLE WALL_CELL_LOOP_2
        IF (PREDICTOR) THEN; CUT_CELL(ICC)%H(1:CUT_CELL(ICC)%NCELL) = HP(BC%II,BC%JJ,BC%KK)
        ELSE;                CUT_CELL(ICC)%HS(1:CUT_CELL(ICC)%NCELL)= HP(BC%II,BC%JJ,BC%KK)
        ENDIF
     ENDDO WALL_CELL_LOOP_2
  ENDIF
ELSE
   IF(ONE_UNKH_PER_CUTCELL) THEN
      ! To DO.
   ELSE
      WALL_CELL_LOOP_4 : DO IW=1,N_EXTERNAL_WALL_CELLS
         WC => WALL(IW); BC => BOUNDARY_COORD(WC%BC_INDEX); ICC = CCVAR(BC%II,BC%JJ,BC%KK,CC_IDCC)
         ! Gasphase cell indexes:
         IF(ICC<1) CYCLE WALL_CELL_LOOP_4
         IF (PREDICTOR) THEN; CUT_CELL(ICC)%H(1:CUT_CELL(ICC)%NCELL) = HP(BC%II,BC%JJ,BC%KK)
         ELSE;                CUT_CELL(ICC)%HS(1:CUT_CELL(ICC)%NCELL)= HP(BC%II,BC%JJ,BC%KK)
         ENDIF
      ENDDO WALL_CELL_LOOP_4
   ENDIF
ENDIF

END SUBROUTINE GET_H_GUARD_CUTCELL


! ------------------------ ADD_LINKEDCELL_D_PBAR_DT ---------------------------------

SUBROUTINE ADD_LINKEDCELL_D_PBAR_DT(I,J,K,PBAR_K,D_PBAR_DT_ZONE,RTRM_CV,DIVG)

! ASSUMES POINT_TO_MESH has been called and CCVAR(I,J,K,CC_UNKZ) > 0.

INTEGER, INTENT(IN)    :: I,J,K
REAL(EB),INTENT(IN)    :: PBAR_K,D_PBAR_DT_ZONE,RTRM_CV
REAL(EB),INTENT(INOUT) :: DIVG

REAL(EB):: P_BAR_CV
P_BAR_CV = PBAR_K - P_0(K) + P_0_CV(CCVAR(I,J,K,CC_UNKZ)-UNKZ_IND(NM_START))

DIVG = DIVG - (1._EB/P_BAR_CV-RTRM_CV)*D_PBAR_DT_ZONE

END SUBROUTINE ADD_LINKEDCELL_D_PBAR_DT

! ----------------------- ADD_CUTCELL_D_PBAR_DT -------------------------------------

SUBROUTINE ADD_CUTCELL_D_PBAR_DT(I,J,K,PBAR_K,D_PBAR_DT_ZONE)

! ASSUMES POINT_TO_MESH has been called and CCVAR(I,J,K,CC_UNKZ) > 0.

INTEGER, INTENT(IN)    :: I,J,K
REAL(EB),INTENT(IN)    :: PBAR_K,D_PBAR_DT_ZONE

INTEGER :: JCC
REAL(EB):: P_BAR_CV

CC => CUT_CELL(CCVAR(I,J,K,CC_IDCC))

IF(PREDICTOR) THEN
   DO JCC=1,CC%NCELL
      P_BAR_CV = PBAR_K - P_0(K) + P_0_CV(CC%UNKZ(JCC)-UNKZ_IND(NM_START))
      CC%DS(JCC) = CC%DS(JCC) - (1._EB/P_BAR_CV-CC%RTRM(JCC))*D_PBAR_DT_ZONE
   ENDDO
ELSE
   DO JCC=1,CC%NCELL
      P_BAR_CV = PBAR_K - P_0(K) + P_0_CV(CC%UNKZ(JCC)-UNKZ_IND(NM_START))
      CC%D(JCC)  = CC%D(JCC)  - (1._EB/P_BAR_CV-CC%RTRM(JCC))*D_PBAR_DT_ZONE
   ENDDO
ENDIF

END SUBROUTINE ADD_CUTCELL_D_PBAR_DT

! ------------------------- ADD_LINKEDCELL_PSUM -------------------------------------

SUBROUTINE ADD_LINKEDCELL_PSUM(I,J,K,VC,PBAR_K,RTRM_CV,PSUM_CV)

! ASSUMES POINT_TO_MESH has been called and CCVAR(I,J,K,CC_UNKZ) > 0.

INTEGER, INTENT(IN)    :: I,J,K
REAL(EB),INTENT(IN)    :: VC,PBAR_K,RTRM_CV
REAL(EB),INTENT(INOUT) :: PSUM_CV

REAL(EB):: P_BAR_CV
P_BAR_CV = PBAR_K - P_0(K) + P_0_CV(CCVAR(I,J,K,CC_UNKZ)-UNKZ_IND(NM_START))
PSUM_CV = PSUM_CV + VC*(1._EB/P_BAR_CV-RTRM_CV)

END SUBROUTINE ADD_LINKEDCELL_PSUM

! ------------------------- ADD_CUTCELL_PSUM ----------------------------------------

SUBROUTINE ADD_CUTCELL_PSUM(I,J,K,PBAR_K,PSUM_CV)

! ASSUMES POINT_TO_MESH has been called and CCVAR(I,J,K,CC_IDCC) > 0.

INTEGER, INTENT(IN)    :: I,J,K
REAL(EB),INTENT(IN)    :: PBAR_K
REAL(EB),INTENT(INOUT) :: PSUM_CV

INTEGER :: JCC
REAL(EB):: P_BAR_CV

CC  =>CUT_CELL(CCVAR(I,J,K,CC_IDCC))
DO JCC=1,CC%NCELL
   P_BAR_CV = PBAR_K - P_0(K) + P_0_CV(CC%UNKZ(JCC)-UNKZ_IND(NM_START))
   PSUM_CV = PSUM_CV + CC%VOLUME(JCC)*(1._EB/P_BAR_CV-CC%RTRM(JCC))
ENDDO

END SUBROUTINE ADD_CUTCELL_PSUM


! ------------------------------ CUTFACE_VELOCITIES --------------------------------

SUBROUTINE CUTFACE_VELOCITIES(NM,UU,VV,WW,CUTFACES)

INTEGER, INTENT(IN) :: NM
REAL(EB), POINTER, DIMENSION(:,:,:), INTENT(INOUT) :: UU,VV,WW
LOGICAL, INTENT(IN) :: CUTFACES
TYPE(CC_CUTFACE_TYPE), POINTER :: CF=>NULL()
TYPE(CFACE_TYPE), POINTER :: CFA=>NULL()
TYPE(BOUNDARY_COORD_TYPE), POINTER :: BC
TYPE(BOUNDARY_PROP1_TYPE), POINTER :: B1
INTEGER :: ICF,ICFA,JCF,I,J,K,X1AXIS
REAL(EB):: AREA,VELN(3),PREDFCT


CUTFACES_IF : IF (CUTFACES) THEN ! USE CUT_FACE(ICF)%VEL_CF
   DO ICF=1,MESHES(NM)%N_CUTFACE_MESH+MESHES(NM)%N_GCCUTFACE_MESH
      CF => CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE
      I      = CF%IJK(IAXIS); IF(I<0 .OR. I>MESHES(NM)%IBP1) CYCLE
      J      = CF%IJK(JAXIS); IF(J<0 .OR. J>MESHES(NM)%JBP1) CYCLE
      K      = CF%IJK(KAXIS); IF(K<0 .OR. K>MESHES(NM)%KBP1) CYCLE
      X1AXIS = CF%IJK(KAXIS+1)
      SELECT CASE(X1AXIS)
      CASE(IAXIS); UU(I,J,K) = CF%VEL_CF
      CASE(JAXIS); VV(I,J,K) = CF%VEL_CF
      CASE(KAXIS); WW(I,J,K) = CF%VEL_CF
      END SELECT
   ENDDO

   PREDFCT = 0._EB; IF(PREDICTOR) PREDFCT = 1._EB
   ! CFACEs, set velocity in underlaying solid cartesian faces to be used in VELOCITY_FLUX:
   DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      CF => CUT_FACE(ICF); IF(CF%STATUS/=CC_INBOUNDARY) CYCLE
      I = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS)
      ! Area Average velocity for boundary CFACEs:
      AREA = 0._EB; VELN(IAXIS:KAXIS) = 0._EB
      DO JCF=1,CF%NFACE
         ICFA=CF%CFACE_INDEX(JCF); IF(ICFA<1) CYCLE
         CFA => CFACE(ICFA)
         BC => BOUNDARY_COORD(CFA%BC_INDEX)
         B1 => BOUNDARY_PROP1(CFA%B1_INDEX)
         AREA = AREA+CFA%AREA
         VELN(IAXIS:KAXIS) = VELN(IAXIS:KAXIS) - &
                             (PREDFCT*B1%U_NORMAL+(1._EB-PREDFCT)*B1%U_NORMAL_S)*CFA%AREA*BC%NVEC(IAXIS:KAXIS)
      ENDDO
      VELN(IAXIS:KAXIS) = VELN(IAXIS:KAXIS)/(AREA+TWO_EPSILON_EB)
      ! Distribute into Solid cartesian faces:
      WHERE(FCVAR(I-1:I,J,K,CC_FGSC,IAXIS)==CC_SOLID) UU(I-1:I,J,K) = VELN(IAXIS)
      WHERE(FCVAR(I,J-1:J,K,CC_FGSC,JAXIS)==CC_SOLID) VV(I,J-1:J,K) = VELN(JAXIS)
      WHERE(FCVAR(I,J,K-1:K,CC_FGSC,KAXIS)==CC_SOLID) WW(I,J,K-1:K) = VELN(KAXIS)
   ENDDO

ELSE CUTFACES_IF ! USE CUT_FACE(ICF)%VEL_CRT
   DO ICF=1,MESHES(NM)%N_CUTFACE_MESH+MESHES(NM)%N_GCCUTFACE_MESH
      CF => CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE
      I      = CF%IJK(IAXIS); IF(I<0 .OR. I>MESHES(NM)%IBP1) CYCLE
      J      = CF%IJK(JAXIS); IF(J<0 .OR. J>MESHES(NM)%JBP1) CYCLE
      K      = CF%IJK(KAXIS); IF(K<0 .OR. K>MESHES(NM)%KBP1) CYCLE
      X1AXIS = CF%IJK(KAXIS+1)
      SELECT CASE(X1AXIS)
      CASE(IAXIS); UU(I,J,K) = CF%VEL_CRT
      CASE(JAXIS); VV(I,J,K) = CF%VEL_CRT
      CASE(KAXIS); WW(I,J,K) = CF%VEL_CRT
      END SELECT
   ENDDO

   DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      CF => CUT_FACE(ICF); IF(CF%STATUS/=CC_INBOUNDARY) CYCLE
      I = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS)
      WHERE(FCVAR(I-1:I,J,K,CC_FGSC,IAXIS)==CC_SOLID) UU(I-1:I,J,K) = 0._EB
      WHERE(FCVAR(I,J-1:J,K,CC_FGSC,JAXIS)==CC_SOLID) VV(I,J-1:J,K) = 0._EB
      WHERE(FCVAR(I,J,K-1:K,CC_FGSC,KAXIS)==CC_SOLID) WW(I,J,K-1:K) = 0._EB
   ENDDO

ENDIF CUTFACES_IF
RETURN
END SUBROUTINE CUTFACE_VELOCITIES


! --------------------------- CHECK_CFLVN_LINKED_CELLS --------------------------------

SUBROUTINE CHECK_CFLVN_LINKED_CELLS(NM,DT,UVWMAX,R_DX2,MUTRM)

! This routine assumes POINT_TO_MESH(NM) has been already called, and CFL,ICFL,JCFL,KCFL,VN,I_VN,J_VN,K_VN
! are aveilable.

INTEGER, INTENT(IN) :: NM
REAL(EB),INTENT(IN) :: DT
REAL(EB),INTENT(INOUT) :: UVWMAX,R_DX2,MUTRM

! Local variables:
INTEGER :: I,J,K,ICC,JCC,IROW,IMAX,X1AXIS,ILH,IRC,IFC,IFACE,IFC2,IFACE2,ICFA,LOWHIGH
REAL(EB):: MU_TMP,MURDN,AF,VELN,CFLMAX_TMP,VNMAX_TMP,TWOD_FCT
INTEGER,  ALLOCATABLE, DIMENSION(:,:) :: IJKT
REAL(EB), ALLOCATABLE, DIMENSION(:)   :: UVWA, MUV, MURA, VOL, DIVG

IF(NUNKZ_LOC(NM)<1) RETURN

! Average velocity components on linked cells:
ALLOCATE ( UVWA(UNKZ_ILC(NM)+1:UNKZ_ILC(NM)+NUNKZ_LOC(NM)) , &
           MUV(UNKZ_ILC(NM)+1:UNKZ_ILC(NM)+NUNKZ_LOC(NM))  , &
           MURA(UNKZ_ILC(NM)+1:UNKZ_ILC(NM)+NUNKZ_LOC(NM)) , &
           IJKT(IAXIS:KAXIS,UNKZ_ILC(NM)+1:UNKZ_ILC(NM)+NUNKZ_LOC(NM)) , &
           VOL(UNKZ_ILC(NM)+1:UNKZ_ILC(NM)+NUNKZ_LOC(NM)), &
           DIVG(UNKZ_ILC(NM)+1:UNKZ_ILC(NM)+NUNKZ_LOC(NM)) )
UVWA(:)       = 0._EB
MUV(:)        = 0._EB
MURA(:)       = 0._EB
IJKT(:,:)     = 0
VOL(:)        = 0._EB
DIVG(:)       = 0._EB

TWOD_FCT = 1._EB; IF(TWO_D) TWOD_FCT = 0._EB
MU_TMP   = 0._EB
! First Regular cells that have an UNKZ index:
DO K=1,KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         IF(CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
         IROW = CCVAR(I,J,K,CC_UNKZ) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
         IF (CHECK_VN) MU_TMP = MAX(D_Z_MAX(I,J,K),MU(I,J,K)/RHOS(I,J,K))
         ! X axis:
         X1AXIS = IAXIS
         DO ILH=-1,0
            IRC  = FCVAR(I+ILH,J,K,CC_IDRC,X1AXIS)
            MURDN = MU_TMP/DX(I)
            IF (IRC>0) THEN
               IF(RC_FACE(IRC)%SHAREDZ) CYCLE
               MURDN = MU_TMP/(RC_FACE(IRC)%XCEN(X1AXIS,HIGH_IND)-RC_FACE(IRC)%XCEN(X1AXIS,LOW_IND))
            ENDIF
            AF   = DY(J)*DZ(K); VELN = US(I+ILH,J,K)
            UVWA(IROW) = UVWA(IROW) + MAX(0._EB,REAL(2*ILH+1,EB)*VELN*AF) ! MAX(u.n A, 0), only positive values.
            MURA(IROW) = MURA(IROW) + MURDN * AF
         ENDDO
         ! Y axis:
         X1AXIS = JAXIS
         DO ILH=-1,0
            IRC  = FCVAR(I,J+ILH,K,CC_IDRC,X1AXIS)
            MURDN = TWOD_FCT * MU_TMP/DY(J)
            IF (IRC>0) THEN
               IF(RC_FACE(IRC)%SHAREDZ) CYCLE
               MURDN = TWOD_FCT*MU_TMP/(RC_FACE(IRC)%XCEN(X1AXIS,HIGH_IND)-RC_FACE(IRC)%XCEN(X1AXIS,LOW_IND))
            ENDIF
            AF   = DX(I)*DZ(K); VELN = VS(I,J+ILH,K)
            UVWA(IROW) = UVWA(IROW) + MAX(0._EB,REAL(2*ILH+1,EB)*VELN*AF)
            MURA(IROW) = MURA(IROW) + MURDN * AF
         ENDDO
         ! Z axis:
         X1AXIS = KAXIS
         DO ILH=-1,0
            IRC  = FCVAR(I,J,K+ILH,CC_IDRC,X1AXIS)
            MURDN = MU_TMP/DZ(K)
            IF (IRC>0) THEN
               IF(RC_FACE(IRC)%SHAREDZ) CYCLE
               MURDN = MU_TMP/(RC_FACE(IRC)%XCEN(X1AXIS,HIGH_IND)-RC_FACE(IRC)%XCEN(X1AXIS,LOW_IND))
            ENDIF
            AF   = DX(I)*DY(J); VELN = WS(I,J,K+ILH)
            UVWA(IROW) = UVWA(IROW) + MAX(0._EB,REAL(2*ILH+1,EB)*VELN*AF)
            MURA(IROW) = MURA(IROW) + MURDN * AF
         ENDDO
         ! Divergence:
         MUV(IROW)  = MUV(IROW)  + MU_TMP * (DX(I)*DY(J)*DZ(K))
         DIVG(IROW) = DIVG(IROW) + ABS(DS(I,J,K)) * (DX(I)*DY(J)*DZ(K))
         VOL(IROW)  = VOL(IROW)  + (DX(I)*DY(J)*DZ(K))
         IJKT(IAXIS:KAXIS,IROW) = (/ I, J, K /)
      ENDDO
   ENDDO
ENDDO
! Then add Cut-cell contributions:
CUTCELL_DO : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
   I = CUT_CELL(ICC)%IJK(IAXIS)
   J = CUT_CELL(ICC)%IJK(JAXIS)
   K = CUT_CELL(ICC)%IJK(KAXIS)
   IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
   IF (CHECK_VN) MU_TMP = MAX(D_Z_MAX(I,J,K),MU(I,J,K)/RHOS(I,J,K))
   DO JCC=1,CUT_CELL(ICC)%NCELL
      IROW = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
      IFC_LOOP : DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
         IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
         SELECT CASE(CUT_CELL(ICC)%FACE_LIST(1,IFACE))
         CASE(CC_FTYPE_RCGAS) ! REGULAR GASPHASE
            LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
            X1AXIS  = CUT_CELL(ICC)%FACE_LIST(3,IFACE)
            ILH     = LOWHIGH - 1
            SELECT CASE(X1AXIS)
            CASE(IAXIS)
               IRC  = FCVAR(I-1+ILH,J,K,CC_IDRC,X1AXIS)
               MURDN = MU_TMP/DX(I)
               IF (IRC>0) THEN
                  IF(RC_FACE(IRC)%SHAREDZ) CYCLE
                  MURDN = MU_TMP/(RC_FACE(IRC)%XCEN(X1AXIS,HIGH_IND)-RC_FACE(IRC)%XCEN(X1AXIS,LOW_IND))
               ENDIF
               AF   = DY(J)*DZ(K); VELN = US(I-1+ILH,J,K)
            CASE(JAXIS)
               IRC  = FCVAR(I,J-1+ILH,K,CC_IDRC,X1AXIS)
               MURDN = TWOD_FCT * MU_TMP/DY(J)
               IF (IRC>0) THEN
                  IF(RC_FACE(IRC)%SHAREDZ) CYCLE
                  MURDN=TWOD_FCT*MU_TMP/(RC_FACE(IRC)%XCEN(X1AXIS,HIGH_IND)-RC_FACE(IRC)%XCEN(X1AXIS,LOW_IND))
               ENDIF
               AF   = DX(I)*DZ(K); VELN = VS(I,J-1+ILH,K)
            CASE(KAXIS)
               IRC  = FCVAR(I,J,K-1+ILH,CC_IDRC,X1AXIS)
               MURDN = MU_TMP/DZ(K)
               IF (IRC>0) THEN
                  IF(RC_FACE(IRC)%SHAREDZ) CYCLE
                  MURDN = MU_TMP/(RC_FACE(IRC)%XCEN(X1AXIS,HIGH_IND)-RC_FACE(IRC)%XCEN(X1AXIS,LOW_IND))
               ENDIF
               AF   = DX(I)*DY(J); VELN = WS(I,J,K-1+ILH)
            END SELECT
            UVWA(IROW) = UVWA(IROW) + MAX(0._EB,REAL(2*ILH-1,EB)*VELN*AF)
            MURA(IROW) = MURA(IROW) + MURDN * AF
         CASE(CC_FTYPE_CFGAS) ! GASPHASE CUT FACE:
            LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
            ILH     = LOWHIGH - 1
            IFC2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
            IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
            IF(CUT_FACE(IFC2)%SHARED(IFACE2)) CYCLE ! If face shared by linked cells CYCLE.
            X1AXIS  = CUT_FACE(IFC2)%IJK(KAXIS+1)
            MURDN   = MU_TMP/(CUT_FACE(IFC2)%XCENHIGH(X1AXIS,IFACE2)-CUT_FACE(IFC2)%XCENLOW(X1AXIS,IFACE2))
            AF      = CUT_FACE(IFC2)%AREA(IFACE2)
            VELN    = CUT_FACE(IFC2)%VELS(IFACE2)
            UVWA(IROW) = UVWA(IROW) + MAX(0._EB,REAL(2*ILH-1,EB)*VELN*AF)
            IF(.NOT.(TWO_D .AND. X1AXIS==JAXIS)) MURA(IROW) = MURA(IROW) + MURDN * AF
         CASE(CC_FTYPE_CFINB) ! INBOUNDARY CUT FACE: Note here we add U_NORMAL with Transpiration velocity due to
                               ! Poisson solver velocity error.
            IFC2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
            IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
            ICFA    = CUT_FACE(IFC2)%CFACE_INDEX(IFACE2)
            AF      = CUT_FACE(IFC2)%AREA(IFACE2)
            VELN    = CUT_FACE(IFC2)%VELS(IFACE2)
            MURDN   = MU_TMP * BOUNDARY_PROP1(CFACE(ICFA)%B1_INDEX)%RDN
            ! - to use velocity into gasphase, projected area.
            UVWA(IROW) = UVWA(IROW) + MAX(0._EB,-VELN*AF)
            MURA(IROW) = MURA(IROW) + MURDN * AF
         END SELECT
      ENDDO IFC_LOOP
      ! Divergence:
      MUV(IROW)  = MUV(IROW)  + MU_TMP * CUT_CELL(ICC)%VOLUME(JCC)
      DIVG(IROW) = DIVG(IROW) + ABS(CUT_CELL(ICC)%DS(JCC)) * CUT_CELL(ICC)%VOLUME(JCC)
      VOL(IROW)  = VOL(IROW)  + CUT_CELL(ICC)%VOLUME(JCC)
      IJKT(IAXIS:KAXIS,IROW) = (/ I, J, K /) ! These might rewrite the I,J,K of some IROWs.
   ENDDO
ENDDO CUTCELL_DO

! Add convective term + divergence:
UVWA = UVWA + DIVG

! Average per linked cells control volume:
DO IROW=UNKZ_ILC(NM)+1,UNKZ_ILC(NM)+NUNKZ_LOC(NM)
   UVWA(IROW) = UVWA(IROW)/VOL(IROW)
ENDDO
IMAX = UNKZ_ILC(NM)+MAXLOC(UVWA,DIM=1)
CFLMAX_TMP = DT * UVWA(IMAX)
IF(CFLMAX_TMP > CFL) THEN
   UVWMAX = UVWA(IMAX)
   CFL = CFLMAX_TMP
   ICFL=IJKT(IAXIS,IMAX)
   JCFL=IJKT(JAXIS,IMAX)
   KCFL=IJKT(KAXIS,IMAX)
ENDIF

IF (CHECK_HT) THEN
   DO IFACE=1,N_EXTERNAL_CFACE_CELLS+N_INTWALL_CFACE_CELLS+N_INTERNAL_CFACE_CELLS
      CFA=>CFACE(IFACE)
      IF (CFA%BOUNDARY_TYPE/=SOLID_BOUNDARY) CYCLE
      BC=>BOUNDARY_COORD(CFA%BC_INDEX)
      B1=>BOUNDARY_PROP1(CFA%B1_INDEX)
      VELN = (ABS(B1%Q_CON_F)/B1%RHO_F)**ONTH * 2._EB*B1%RDN
      CFLMAX_TMP = DT * VELN
      IF (CFLMAX_TMP > CFL) THEN
         UVWMAX = VELN
         CFL = CFLMAX_TMP
         ICFL=BC%IIG
         JCFL=BC%JJG
         KCFL=BC%KKG
      ENDIF
   ENDDO
ENDIF

IF (CHECK_VN) THEN
   DO IROW=UNKZ_ILC(NM)+1,UNKZ_ILC(NM)+NUNKZ_LOC(NM)
      MURA(IROW) = MURA(IROW)/VOL(IROW)
   ENDDO
   IMAX = UNKZ_ILC(NM)+MAXLOC(MURA,DIM=1)
   VNMAX_TMP = DT * MURA(IMAX)
   IF(VNMAX_TMP > VN) THEN
      R_DX2 = MURA(IMAX)*VOL(IMAX)/(2._EB*MUV(IMAX))
      MUTRM = MUV(IMAX)/VOL(IMAX)
      VN    = VNMAX_TMP
      I_VN=IJKT(IAXIS,IMAX)
      J_VN=IJKT(JAXIS,IMAX)
      K_VN=IJKT(KAXIS,IMAX)
   ENDIF
ENDIF

DEALLOCATE ( UVWA,MUV,MURA,IJKT,VOL,DIVG )

RETURN
END SUBROUTINE CHECK_CFLVN_LINKED_CELLS


! ---------------------- UNSTRUCTURED_POISSON_RESIDUAL_RC ----------------------

SUBROUTINE UNSTRUCTURED_POISSON_RESIDUAL_RC(I,J,K,HP,RHOP,P,RES,DO_SEPARABLE)

! NOTE: Assumes POINT_TO_MESH(NM) has been called.

INTEGER, INTENT(IN) :: I,J,K
REAL(EB),INTENT(OUT):: RES
LOGICAL, INTENT(IN) :: DO_SEPARABLE
REAL(EB), POINTER, INTENT(IN), DIMENSION(:,:,:) :: HP,RHOP,P

! Local Dummy vars:
REAL(EB):: RHSS, LHSS

RES=0._EB; IF(CCVAR(I,J,K,CC_UNKZ)<=0) RETURN

CALL GET_RHSLHS_POISSON_RC(I,J,K,HP,RHOP,P,RHSS,LHSS,DO_SEPARABLE)
RES  = ABS(RHSS-LHSS)

RETURN
END SUBROUTINE UNSTRUCTURED_POISSON_RESIDUAL_RC

! --------------------------- GET_RHSLHS_POISSON_RC ----------------------------

SUBROUTINE GET_RHSLHS_POISSON_RC(I,J,K,HP,RHOP,P,RHSS,LHSS,DO_SEPARABLE)

! NOTE: Assumes POINT_TO_MESH(NM) has been called.

INTEGER, INTENT(IN) :: I,J,K
REAL(EB),INTENT(OUT):: RHSS,LHSS
LOGICAL, INTENT(IN) :: DO_SEPARABLE
REAL(EB), POINTER, INTENT(IN), DIMENSION(:,:,:) :: HP,RHOP,P

! Local Dummy vars:
INTEGER :: X1AXIS,IRC,ILH,FCT,ICC,JCC
REAL(EB):: PRFCT, AF, VOL, DIV_FN_VOL, RDN, H1, H2, P1, RHO1, KR1, P2, RHO2, KR2, RHOF, FBC, CCM1, CCP1, FN_B

VOL = DX(I)*DY(J)*DZ(K)
DIV_FN_VOL = 0._EB; LHSS = 0._EB
DO_SEPARABLE_IF : IF (DO_SEPARABLE) THEN

   ! X axis:
   X1AXIS = IAXIS; AF = DY(J)*DZ(K)
   DO ILH=-1,0
      FCT  = 2*ILH+1
      RDN  = RDXN(I+ILH)
      IRC  = FCVAR(I+ILH,J,K,CC_IDRC,X1AXIS)
      IF (IRC>0) RDN = 1._EB/(RC_FACE(IRC)%XCEN(X1AXIS,HIGH_IND) - RC_FACE(IRC)%XCEN(X1AXIS,LOW_IND))
      H1   = HP(I+ILH,J,K); H2 = HP(I+ILH+1,J,K)
      FBC = 1._EB; IF (WALL(CELL(CELL_INDEX(I,J,K))%WALL_INDEX(FCT*X1AXIS))%BOUNDARY_TYPE==SOLID_BOUNDARY) FBC = 0._EB
      DIV_FN_VOL = DIV_FN_VOL + REAL(FCT,EB)* FVX(I+ILH,J,K) * AF
      LHSS       = LHSS       + REAL(FCT,EB)* FBC*(H2-H1)*RDN * AF
   ENDDO
   ! Y axis:
   X1AXIS = JAXIS; AF = DX(I)*DZ(K)
   DO ILH=-1,0
      FCT  = 2*ILH+1
      RDN  = RDYN(J+ILH)
      IRC  = FCVAR(I,J+ILH,K,CC_IDRC,X1AXIS)
      IF (IRC>0) RDN = 1._EB/(RC_FACE(IRC)%XCEN(X1AXIS,HIGH_IND) - RC_FACE(IRC)%XCEN(X1AXIS,LOW_IND))
      H1   = HP(I,J+ILH,K); H2 = HP(I,J+ILH+1,K)
      FBC = 1._EB; IF (WALL(CELL(CELL_INDEX(I,J,K))%WALL_INDEX(FCT*X1AXIS))%BOUNDARY_TYPE==SOLID_BOUNDARY) FBC = 0._EB
      DIV_FN_VOL = DIV_FN_VOL + REAL(FCT,EB)* FVY(I,J+ILH,K) * AF
      LHSS       = LHSS       + REAL(FCT,EB)* FBC*(H2-H1)*RDN * AF
   ENDDO
   ! Z axis:
   X1AXIS = KAXIS; AF = DX(I)*DY(J)
   DO ILH=-1,0
      FCT  = 2*ILH+1
      RDN  = RDZN(K+ILH)
      IRC  = FCVAR(I,J,K+ILH,CC_IDRC,X1AXIS)
      IF (IRC>0) RDN = 1._EB/(RC_FACE(IRC)%XCEN(X1AXIS,HIGH_IND) - RC_FACE(IRC)%XCEN(X1AXIS,LOW_IND))
      H1   = HP(I,J,K+ILH); H2 = HP(I,J,K+ILH+1)
      FBC = 1._EB; IF (WALL(CELL(CELL_INDEX(I,J,K))%WALL_INDEX(FCT*X1AXIS))%BOUNDARY_TYPE==SOLID_BOUNDARY) FBC = 0._EB
      DIV_FN_VOL = DIV_FN_VOL + REAL(FCT,EB)* FVZ(I,J,K+ILH) * AF
      LHSS       = LHSS       + REAL(FCT,EB)* FBC*(H2-H1)*RDN * AF
   ENDDO

ELSE DO_SEPARABLE_IF

   PRFCT=0._EB; IF(PREDICTOR) PRFCT=1._EB

   ! X axis:
   X1AXIS = IAXIS; AF = DY(J)*DZ(K)
   DO ILH=-1,0
      FCT  = 2*ILH+1; FBC = 1._EB
      RDN  = RDXN(I+ILH); CCM1=0.5_EB; CCP1=0.5_EB

      P1   = P(   I+ILH,J,K); P2   = P(   I+ILH+1,J,K)
      KR1  = KRES(I+ILH,J,K); KR2  = KRES(I+ILH+1,J,K)
      RHO1 = RHOP(I+ILH,J,K); RHO2 = RHOP(I+ILH+1,J,K)

      IF (FCVAR(I+ILH,J,K,CC_UNKF,IAXIS)>0) THEN
         FN_B = F_LINK(FCVAR(I+ILH,J,K,CC_UNKF,IAXIS))
      ELSE
         FN_B = -(P(I+ILH,J,K)*RHOP(I+ILH+1,J,K)+P(I+ILH+1,J,K)*RHOP(I+ILH,J,K))*&
                 (1._EB/RHOP(I+ILH+1,J,K)-1._EB/RHOP(I+ILH,J,K))*RDXN(I+ILH)/(RHOP(I+ILH+1,J,K)+RHOP(I+ILH,J,K))
      ENDIF
      IRC  = FCVAR(I+ILH,J,K,CC_IDRC,X1AXIS)
      IF (IRC>0) THEN
         IF(RC_FACE(IRC)%IWC>0 .AND. &
            ANY(WALL(RC_FACE(IRC)%IWC)%BOUNDARY_TYPE==(/NULL_BOUNDARY,MIRROR_BOUNDARY,SOLID_BOUNDARY/))) THEN
            FN_B = 0._EB
         ELSE
            RDN = 1._EB/(RC_FACE(IRC)%XCEN(X1AXIS,HIGH_IND)-RC_FACE(IRC)%XCEN(X1AXIS,LOW_IND))
            CCM1= RDN*(RC_FACE(IRC)%XCEN(X1AXIS,HIGH_IND)-X(I+ILH))
            CCP1= RDN*(X(I+ILH)-RC_FACE(IRC)%XCEN(X1AXIS,LOW_IND) )
            IF(RC_FACE(IRC)%CELL_LIST(1,LOW_IND)==CC_FTYPE_CFGAS) THEN
               ICC  = RC_FACE(IRC)%CELL_LIST(2,LOW_IND)
               JCC  = RC_FACE(IRC)%CELL_LIST(3,LOW_IND)
               RHO1 = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT) *CUT_CELL(ICC)%RHOS(JCC)
            ENDIF
            IF(RC_FACE(IRC)%CELL_LIST(1,HIGH_IND)==CC_FTYPE_CFGAS) THEN
               ICC  = RC_FACE(IRC)%CELL_LIST(2,HIGH_IND)
               JCC  = RC_FACE(IRC)%CELL_LIST(3,HIGH_IND)
               RHO2 = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT) *CUT_CELL(ICC)%RHOS(JCC)
            ENDIF
            IF(RC_FACE(IRC)%UNKF>0) THEN
               FN_B = F_LINK(RC_FACE(IRC)%UNKF)
            ELSE
               CALL GET_RCFACE_BAROCLINIC_TORQUE(PRFCT,IRC,CCM1,CCP1,FN_B,HP,RHOP)
            ENDIF
         ENDIF
      ENDIF
      RHOF = CCM1*RHO1 + CCP1*RHO2

      IF ( (I+ILH>0 .AND. I+ILH<IBAR) .AND. &
            WALL(CELL(CELL_INDEX(I,J,K))%WALL_INDEX(FCT*X1AXIS))%BOUNDARY_TYPE==SOLID_BOUNDARY) FBC = 0._EB
      DIV_FN_VOL = DIV_FN_VOL + REAL(FCT,EB)* ( FVX(I+ILH,J,K) - FBC*FVX_B(I+ILH,J,K) ) * AF
      !LHSS       = LHSS       + REAL(FCT,EB)* FBC*( 1._EB/RHOF * (P2-P1) + (KR2-KR1) )*RDN * AF
      !LHSS       = LHSS       + REAL(FCT,EB)* FBC*( (P2/RHO2-P1/RHO1+KR2-KR1)*RDN + FVX_B(I+ILH,J,K) ) * AF
      LHSS       = LHSS       + REAL(FCT,EB)* FBC*( (P2/RHO2-P1/RHO1+KR2-KR1)*RDN + FN_B ) * AF
   ENDDO
   ! Y axis:
   X1AXIS = JAXIS; AF = DX(I)*DZ(K)
   DO ILH=-1,0
      FCT  = 2*ILH+1; FBC = 1._EB
      RDN  = RDYN(J+ILH); CCM1=0.5_EB; CCP1=0.5_EB

      P1   = P(   I,J+ILH,K); P2   = P(   I,J+ILH+1,K)
      KR1  = KRES(I,J+ILH,K); KR2  = KRES(I,J+ILH+1,K)
      RHO1 = RHOP(I,J+ILH,K); RHO2 = RHOP(I,J+ILH+1,K)

      IF (FCVAR(I,J+ILH,K,CC_UNKF,JAXIS)>0) THEN
         FN_B = F_LINK(FCVAR(I,J+ILH,K,CC_UNKF,JAXIS))
      ELSE
         FN_B = -(P(I,J+ILH,K)*RHOP(I,J+ILH+1,K)+P(I,J+ILH+1,K)*RHOP(I,J+ILH,K))*&
                 (1._EB/RHOP(I,J+ILH+1,K)-1._EB/RHOP(I,J+ILH,K))*RDYN(J+ILH)/ (RHOP(I,J+ILH+1,K)+RHOP(I,J+ILH,K))
      ENDIF
      IRC  = FCVAR(I,J+ILH,K,CC_IDRC,X1AXIS)
      IF (IRC>0) THEN
         IF(RC_FACE(IRC)%IWC>0 .AND. &
            ANY(WALL(RC_FACE(IRC)%IWC)%BOUNDARY_TYPE==(/NULL_BOUNDARY,MIRROR_BOUNDARY,SOLID_BOUNDARY/))) THEN
            FN_B = 0._EB
         ELSE
            RDN = 1._EB/(RC_FACE(IRC)%XCEN(X1AXIS,HIGH_IND)-RC_FACE(IRC)%XCEN(X1AXIS,LOW_IND))
            CCM1= RDN*(RC_FACE(IRC)%XCEN(X1AXIS,HIGH_IND)-Y(J+ILH))
            CCP1= RDN*(Y(J+ILH)-RC_FACE(IRC)%XCEN(X1AXIS,LOW_IND) )
            IF(RC_FACE(IRC)%CELL_LIST(1,LOW_IND)==CC_FTYPE_CFGAS) THEN
               ICC  = RC_FACE(IRC)%CELL_LIST(2,LOW_IND)
               JCC  = RC_FACE(IRC)%CELL_LIST(3,LOW_IND)
               RHO1 = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT) *CUT_CELL(ICC)%RHOS(JCC)
            ENDIF
            IF(RC_FACE(IRC)%CELL_LIST(1,HIGH_IND)==CC_FTYPE_CFGAS) THEN
               ICC  = RC_FACE(IRC)%CELL_LIST(2,HIGH_IND)
               JCC  = RC_FACE(IRC)%CELL_LIST(3,HIGH_IND)
               RHO2 = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT) *CUT_CELL(ICC)%RHOS(JCC)
            ENDIF
            IF(RC_FACE(IRC)%UNKF>0) THEN
               FN_B = F_LINK(RC_FACE(IRC)%UNKF)
            ELSE
               CALL GET_RCFACE_BAROCLINIC_TORQUE(PRFCT,IRC,CCM1,CCP1,FN_B,HP,RHOP)
            ENDIF
         ENDIF
      ENDIF
      RHOF = CCM1*RHO1 + CCP1*RHO2

      IF ( (J+ILH>0 .AND. J+ILH<JBAR) .AND. &
            WALL(CELL(CELL_INDEX(I,J,K))%WALL_INDEX(FCT*X1AXIS))%BOUNDARY_TYPE==SOLID_BOUNDARY) FBC = 0._EB
      DIV_FN_VOL = DIV_FN_VOL + REAL(FCT,EB)* ( FVY(I,J+ILH,K) - FBC*FVY_B(I,J+ILH,K) ) * AF
      !LHSS       = LHSS       + REAL(FCT,EB)* FBC*( 1._EB/RHOF * (P2-P1) + (KR2-KR1) )*RDN * AF
      !LHSS       = LHSS       + REAL(FCT,EB)* FBC*( (P2/RHO2-P1/RHO1+KR2-KR1)*RDN +FVY_B(I,J+ILH,K) ) * AF
      LHSS       = LHSS       + REAL(FCT,EB)* FBC*( (P2/RHO2-P1/RHO1+KR2-KR1)*RDN + FN_B ) * AF
   ENDDO
   ! Z axis:
   X1AXIS = KAXIS; AF = DX(I)*DY(J)
   DO ILH=-1,0
      FCT  = 2*ILH+1; FBC = 1._EB
      RDN  = RDZN(K+ILH); CCM1=0.5_EB; CCP1=0.5_EB

      P1   = P(   I,J,K+ILH); P2   = P(   I,J,K+ILH+1)
      KR1  = KRES(I,J,K+ILH); KR2  = KRES(I,J,K+ILH+1)
      RHO1 = RHOP(I,J,K+ILH); RHO2 = RHOP(I,J,K+ILH+1)

      IF (FCVAR(I,J,K+ILH,CC_UNKF,KAXIS)>0) THEN
         FN_B = F_LINK(FCVAR(I,J,K+ILH,CC_UNKF,KAXIS))
      ELSE
         FN_B = -(P(I,J,K+ILH)*RHOP(I,J,K+ILH+1)+P(I,J,K+ILH+1)*RHOP(I,J,K+ILH))*&
                 (1._EB/RHOP(I,J,K+ILH+1)-1._EB/RHOP(I,J,K+ILH))*RDZN(K+ILH)/ (RHOP(I,J,K+ILH+1)+RHOP(I,J,K+ILH))
      ENDIF
      IRC  = FCVAR(I,J,K+ILH,CC_IDRC,X1AXIS)
      IF (IRC>0) THEN
         IF(RC_FACE(IRC)%IWC>0 .AND. &
            ANY(WALL(RC_FACE(IRC)%IWC)%BOUNDARY_TYPE==(/NULL_BOUNDARY,MIRROR_BOUNDARY,SOLID_BOUNDARY/))) THEN
            FN_B = 0._EB
         ELSE
            RDN = 1._EB/(RC_FACE(IRC)%XCEN(X1AXIS,HIGH_IND)-RC_FACE(IRC)%XCEN(X1AXIS,LOW_IND))
            CCM1= RDN*(RC_FACE(IRC)%XCEN(X1AXIS,HIGH_IND)-Z(K+ILH))
            CCP1= RDN*(Z(K+ILH)-RC_FACE(IRC)%XCEN(X1AXIS,LOW_IND) )
            IF(RC_FACE(IRC)%CELL_LIST(1,LOW_IND)==CC_FTYPE_CFGAS) THEN
               ICC  = RC_FACE(IRC)%CELL_LIST(2,LOW_IND)
               JCC  = RC_FACE(IRC)%CELL_LIST(3,LOW_IND)
               RHO1 = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT) *CUT_CELL(ICC)%RHOS(JCC)
            ENDIF
            IF(RC_FACE(IRC)%CELL_LIST(1,HIGH_IND)==CC_FTYPE_CFGAS) THEN
               ICC  = RC_FACE(IRC)%CELL_LIST(2,HIGH_IND)
               JCC  = RC_FACE(IRC)%CELL_LIST(3,HIGH_IND)
               RHO2 = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT) *CUT_CELL(ICC)%RHOS(JCC)
            ENDIF
            IF(RC_FACE(IRC)%UNKF>0) THEN
               FN_B = F_LINK(RC_FACE(IRC)%UNKF)
            ELSE
               CALL GET_RCFACE_BAROCLINIC_TORQUE(PRFCT,IRC,CCM1,CCP1,FN_B,HP,RHOP)
            ENDIF
         ENDIF
      ENDIF
      RHOF = CCM1*RHO1 + CCP1*RHO2

      IF ( (K+ILH>1 .AND. K+ILH<KBAR) .AND.  &
            WALL(CELL(CELL_INDEX(I,J,K))%WALL_INDEX(FCT*X1AXIS))%BOUNDARY_TYPE==SOLID_BOUNDARY) FBC = 0._EB
      DIV_FN_VOL = DIV_FN_VOL + REAL(FCT,EB)* ( FVZ(I,J,K+ILH) - FBC*FVZ_B(I,J,K+ILH) ) * AF
      !LHSS       = LHSS       + REAL(FCT,EB)* FBC*( 1._EB/RHOF * (P2-P1) + (KR2-KR1) )*RDN * AF
      !LHSS       = LHSS       + REAL(FCT,EB)* FBC*( (P2/RHO2-P1/RHO1+KR2-KR1)*RDN + FVZ_B(I,J,K+ILH) ) * AF
      LHSS       = LHSS       + REAL(FCT,EB)* FBC*( (P2/RHO2-P1/RHO1+KR2-KR1)*RDN + FN_B ) * AF
   ENDDO

ENDIF DO_SEPARABLE_IF

LHSS = LHSS/VOL
RHSS = -(DDDT(I,J,K)*VOL + DIV_FN_VOL)/VOL ! Normalize to cartesian cell volume.

RETURN
END SUBROUTINE GET_RHSLHS_POISSON_RC


! ------------------------UNSTRUCTURED_POISSON_RESIDUAL ------------------------

SUBROUTINE UNSTRUCTURED_POISSON_RESIDUAL(I,J,K,HP,RHOP,P,RES,DO_SEPARABLE)

! NOTE: Assumes POINT_TO_MESH(NM) has been called.

INTEGER, INTENT(IN) :: I,J,K
REAL(EB),INTENT(OUT):: RES
LOGICAL, INTENT(IN) :: DO_SEPARABLE
REAL(EB), POINTER, INTENT(IN), DIMENSION(:,:,:) :: HP,RHOP,P

! Local Variables:
INTEGER :: ICC,JCC
REAL(EB):: RHSS,LHSS,DIV_FN,DIV_FN_VOL,LHSS_CC,PRFCT

PRFCT=0._EB
IF(PREDICTOR) PRFCT=1._EB
RES=0._EB; LHSS=0._EB; DIV_FN_VOL = 0._EB
! CUT_CELL entry:
ICC=CCVAR(I,J,K,CC_IDCC)
DO_SEPARABLE_IF : IF (DO_SEPARABLE) THEN
   IF(ONE_UNKH_PER_CUTCELL) THEN
      DO JCC=1,CUT_CELL(ICC)%NCELL
        ! Here we add div(F) in the cut-cell and DDDT:
        CALL GET_FN_DIVERGENCE_CUTCELL(ICC,JCC,DIV_FN,SUBSTRACT_BAROCLINIC=.FALSE.)

        ! Compute int(Grad H dot n) ds for cut-cell:
        CALL GET_LHS_CUTCELL(PRFCT,ICC,JCC,LHSS_CC,I,J,K,HP,RHOP,P,DO_SEPARABLE=.TRUE.)
        LHSS       =  LHSS_CC
        ! Add to RHSS:
        RHSS = -(CUT_CELL(ICC)%DDDTVOL(JCC) + DIV_FN*CUT_CELL(ICC)%VOLUME(JCC))
        RES  = RES + ABS(RHSS-LHSS)
      ENDDO
   ELSE
      DO JCC=1,CUT_CELL(ICC)%NCELL
        ! Here we add div(F) in the cut-cell and DDDT:
        CALL GET_FN_DIVERGENCE_CUTCELL(ICC,JCC,DIV_FN,SUBSTRACT_BAROCLINIC=.FALSE.)
        DIV_FN_VOL = DIV_FN_VOL + DIV_FN*CUT_CELL(ICC)%VOLUME(JCC)

        ! Compute int(Grad H dot n) ds for cut-cell:
        CALL GET_LHS_CUTCELL(PRFCT,ICC,JCC,LHSS_CC,I,J,K,HP,RHOP,P,DO_SEPARABLE=.TRUE.)
        LHSS       = LHSS       + LHSS_CC
      ENDDO
      ! Add to RHSS:
      RHSS = -(CUT_CELL(ICC)%DDDTVOL(1) + DIV_FN_VOL)
      RES  = ABS(RHSS-LHSS)
   ENDIF
ELSE DO_SEPARABLE_IF
   IF(SUM(CUT_CELL(ICC)%VOLUME(1:CUT_CELL(ICC)%NCELL))/(DX(I)*DY(J)*DZ(K)) < V_THRESH_INSPRES) RETURN
   IF(ONE_UNKH_PER_CUTCELL) THEN
      DO JCC=1,CUT_CELL(ICC)%NCELL
        ! Here we add div(F) in the cut-cell and DDDT:
        CALL GET_FN_DIVERGENCE_CUTCELL(ICC,JCC,DIV_FN,SUBSTRACT_BAROCLINIC=.TRUE.)

        ! Compute int(Grad H dot n) ds for cut-cell:
        CALL GET_LHS_CUTCELL(PRFCT,ICC,JCC,LHSS_CC,I,J,K,HP,RHOP,P,DO_SEPARABLE=.FALSE.)
        LHSS       =  LHSS_CC
        ! Add to RHSS:
        RHSS = -(CUT_CELL(ICC)%DDDTVOL(JCC) + DIV_FN*CUT_CELL(ICC)%VOLUME(JCC))
        RES  = RES + ABS(RHSS-LHSS)
      ENDDO
   ELSE
      DO JCC=1,CUT_CELL(ICC)%NCELL
        ! Here we add div(F) in the cut-cell and DDDT:
        CALL GET_FN_DIVERGENCE_CUTCELL(ICC,JCC,DIV_FN,SUBSTRACT_BAROCLINIC=.TRUE.)
        DIV_FN_VOL = DIV_FN_VOL + DIV_FN*CUT_CELL(ICC)%VOLUME(JCC)

        ! Compute (1/rho*Grad(p)-Grad(Kres)):
        CALL GET_LHS_CUTCELL(PRFCT,ICC,JCC,LHSS_CC,I,J,K,HP,RHOP,P,DO_SEPARABLE=.FALSE.)
        LHSS       = LHSS       + LHSS_CC
      ENDDO
      ! Add to RHSS:
      RHSS = -(CUT_CELL(ICC)%DDDTVOL(1) + DIV_FN_VOL)
      RES  = ABS(RHSS-LHSS)
   ENDIF

ENDIF DO_SEPARABLE_IF

RES  = RES/(DX(I)*DY(J)*DZ(K)) ! Normalize to cartesian cell volume.

! IF (DO_SEPARABLE) THEN
! !IF(I==38 .AND. J==10 .AND. K==2) THEN
! IF(RES>1.E-6_EB) &
! WRITE(LU_ERR,*) 'Cut-cell I,J,K,RES=',I,J,K,RHSS,LHSS,RES,SUM(CUT_CELL(ICC)%VOLUME(1:CUT_CELL(ICC)%NCELL)) !,':',&
! !MESHES(NM)%ZONE_MESH(0)%F_H(CUT_CELL(ICC)%UNKH(1))
! !ENDIF
! ENDIF

RETURN
END SUBROUTINE UNSTRUCTURED_POISSON_RESIDUAL


! --------------------------------- GET_LHS_CUTCELL --------------------------------


SUBROUTINE GET_LHS_CUTCELL(PRFCT,ICC,JCC,LHSS_CC,I,J,K,HP,RHOP,P,DO_SEPARABLE)

! NOTE: Assumes POINT_TO_MESH(NM) has been called.

REAL(EB),INTENT(IN) :: PRFCT
INTEGER, INTENT(IN) :: ICC,JCC,I,J,K
REAL(EB),INTENT(OUT):: LHSS_CC
LOGICAL, INTENT(IN) :: DO_SEPARABLE
REAL(EB), POINTER, INTENT(IN), DIMENSION(:,:,:) :: HP,RHOP,P


! Local Variables:
INTEGER :: IFC,IFACE,X1AXIS,LOWHIGH,ILH,ICFA,IFC2,IFACE2,ICLO,ICHI,JCLO,JCHI,IRC
REAL(EB):: HC1,HC2,X1,X2,XFC,AF,FN,FCT,P1,P2,KR1,KR2,RHO1,RHO2,RHOF,FN_B,CCM1,CCP1

LHSS_CC = 0._EB

DO_SEPARABLE_IF : IF (DO_SEPARABLE) THEN

   ! Compute int(Grad H dot n) ds for cut-cell:
   IFC_LOOP_1 : DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
      IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
      AF   = 0._EB
      FN   = 0._EB
      SELECT CASE(CUT_CELL(ICC)%FACE_LIST(1,IFACE))
      CASE(CC_FTYPE_RCGAS) ! REGULAR GASPHASE
         LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
         X1AXIS  = CUT_CELL(ICC)%FACE_LIST(3,IFACE)
         ILH     =        LOWHIGH - 1
         FCT     = REAL(2*LOWHIGH - 3, EB)
         HC1  = HP(I,J,K); HC2 = HC1
         SELECT CASE(X1AXIS)
         CASE(IAXIS)
            AF   = DY(J)*DZ(K)
            IF(LOWHIGH==HIGH_IND) THEN
               HC1  = PRFCT*CUT_CELL(ICC)%H(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%HS(JCC)
               HC2  = HP(I+1,J,K)
               X1   = CUT_CELL(ICC)%XYZCEN(X1AXIS,JCC)
               X2   = XC(I+1); IRC  = FCVAR(I,J,K,CC_IDRC,X1AXIS)
               IF(IRC>0) X2=RC_FACE(IRC)%XCEN(X1AXIS,LOWHIGH)
            ELSE
               HC1  = HP(I-1,J,K)
               HC2  = PRFCT*CUT_CELL(ICC)%H(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%HS(JCC)
               X1   = XC(I-1); IRC  = FCVAR(I-1,J,K,CC_IDRC,X1AXIS)
               IF(IRC>0) X1=RC_FACE(IRC)%XCEN(X1AXIS,LOWHIGH)
               X2   = CUT_CELL(ICC)%XYZCEN(X1AXIS,JCC)
            ENDIF
         CASE(JAXIS)
            AF   = DX(I)*DZ(K)
            IF(LOWHIGH==HIGH_IND) THEN
               HC1  = PRFCT*CUT_CELL(ICC)%H(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%HS(JCC)
               HC2  = HP(I,J+1,K)
               X1   = CUT_CELL(ICC)%XYZCEN(X1AXIS,JCC)
               X2   = YC(J+1); IRC  = FCVAR(I,J,K,CC_IDRC,X1AXIS)
               IF(IRC>0) X2=RC_FACE(IRC)%XCEN(X1AXIS,LOWHIGH)
            ELSE
               HC1  = HP(I,J-1,K)
               HC2  = PRFCT*CUT_CELL(ICC)%H(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%HS(JCC)
               X1   = YC(J-1); IRC  = FCVAR(I,J-1,K,CC_IDRC,X1AXIS)
               IF(IRC>0) X1=RC_FACE(IRC)%XCEN(X1AXIS,LOWHIGH)
               X2   = CUT_CELL(ICC)%XYZCEN(X1AXIS,JCC)
            ENDIF
         CASE(KAXIS)
            AF   = DX(I)*DY(J)
            IF(LOWHIGH==HIGH_IND) THEN
               HC1  = PRFCT*CUT_CELL(ICC)%H(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%HS(JCC)
               HC2  = HP(I,J,K+1)
               X1   = CUT_CELL(ICC)%XYZCEN(X1AXIS,JCC)
               X2   = ZC(K+1); IRC  = FCVAR(I,J,K,CC_IDRC,X1AXIS)
               IF(IRC>0) X2=RC_FACE(IRC)%XCEN(X1AXIS,LOWHIGH)
            ELSE
               HC1  = HP(I,J,K-1)
               HC2  = PRFCT*CUT_CELL(ICC)%H(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%HS(JCC)
               X1   = ZC(K-1); IRC  = FCVAR(I,J,K-1,CC_IDRC,X1AXIS)
               IF(IRC>0) X1=RC_FACE(IRC)%XCEN(X1AXIS,LOWHIGH)
               X2   = CUT_CELL(ICC)%XYZCEN(X1AXIS,JCC)
            ENDIF
         END SELECT
         IF(IRC>0) THEN
            IF( RC_FACE(IRC)%IWC>0 .AND. &
                ANY(WALL(RC_FACE(IRC)%IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/)) ) &
                CYCLE IFC_LOOP_1
         ENDIF
         FN   = FCT*(HC2-HC1)/(X2-X1) ! Grad H dot n
      CASE(CC_FTYPE_CFGAS) ! GASPHASE CUT FACE:
         LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
         FCT     = REAL(2*LOWHIGH - 3, EB)
         IFC2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
         IF(CUT_FACE(IFC2)%IWC>0 .AND. &
            ANY(WALL(CUT_FACE(IFC2)%IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/))) &
            CYCLE IFC_LOOP_1
         IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
         AF      = CUT_FACE(IFC2)%AREA(IFACE2)
         ! Low side H:
         ICLO = CUT_FACE(IFC2)%CELL_LIST(2,LOW_IND,IFACE2); JCLO = CUT_FACE(IFC2)%CELL_LIST(3,LOW_IND,IFACE2);
         !HC1  = HP(CUT_CELL(ICLO)%IJK(IAXIS),CUT_CELL(ICLO)%IJK(JAXIS),CUT_CELL(ICLO)%IJK(KAXIS))
         HC1  = PRFCT*CUT_CELL(ICLO)%H(JCLO)+(1._EB-PRFCT)*CUT_CELL(ICLO)%HS(JCLO)
         ! High side H:
         ICHI = CUT_FACE(IFC2)%CELL_LIST(2,HIGH_IND,IFACE2); JCHI = CUT_FACE(IFC2)%CELL_LIST(3,HIGH_IND,IFACE2);
         !HC2  = HP(CUT_CELL(ICHI)%IJK(IAXIS),CUT_CELL(ICHI)%IJK(JAXIS),CUT_CELL(ICHI)%IJK(KAXIS))
         HC2  = PRFCT*CUT_CELL(ICHI)%H(JCHI) + (1._EB-PRFCT)*CUT_CELL(ICHI)%HS(JCHI)

         X1AXIS = CUT_FACE(IFC2)%IJK(KAXIS+1)
         X1   = CUT_FACE(IFC2)%XCENLOW(X1AXIS,IFACE2)
         X2   = CUT_FACE(IFC2)%XCENHIGH(X1AXIS,IFACE2)
         FN   = FCT*(HC2-HC1)/(X2-X1) ! Grad H dot n
      CASE(CC_FTYPE_CFINB) ! INBOUNDARY CUT FACE
         FCT     = 1._EB    ! Normal vector defined into the body.
         IFC2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
         IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
         ICFA    = CUT_FACE(IFC2)%CFACE_INDEX(IFACE2)
         AF      = CUT_FACE(IFC2)%AREA(IFACE2)
         ! FN      = 0._EB
      END SELECT
      LHSS_CC = LHSS_CC + AF*FN
   ENDDO IFC_LOOP_1

ELSE DO_SEPARABLE_IF

   ! Compute (1/rho*Grad(p)+Grad(Kres)):
   CCM1 = 0.5_EB; CCP1 = 0.5_EB
   IFC_LOOP_2 : DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
      IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
      AF    = 0._EB; FN = 0._EB; FN_B = 0._EB
      SELECT CASE(CUT_CELL(ICC)%FACE_LIST(1,IFACE))
      CASE(CC_FTYPE_RCGAS) ! REGULAR GASPHASE
         LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
         X1AXIS  = CUT_CELL(ICC)%FACE_LIST(3,IFACE)
         ILH     =        LOWHIGH - 1
         FCT     = REAL(2*LOWHIGH - 3, EB)
         P1   = P(I,J,K); P2 = P1
         KR1  = KRES(I,J,K); KR2 = KR1
         RHO1 = PRFCT*CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC); RHO2=RHO1
         SELECT CASE(X1AXIS)
         CASE(IAXIS)
            AF   = DY(J)*DZ(K); XFC  = X(I-1+ILH)   ! Face location in face normal direction.
            !FN_B = FVX_B(I-1+ILH,J,K)
            IRC  = FCVAR(I-1+ILH,J,K,CC_IDRC,X1AXIS)
            IF(LOWHIGH==HIGH_IND) THEN
               P2   = P(I+1,J,K); KR2 = KRES(I+1,J,K)
               X1   = CUT_CELL(ICC)%XYZCEN(X1AXIS,JCC)
               X2   = XC(I+1); IF(IRC>0) X2=RC_FACE(IRC)%XCEN(X1AXIS,LOWHIGH)
               RHO2 = RHOP(I+1,J,K)
            ELSE
               P1   = P(I-1,J,K); KR1 = KRES(I-1,J,K)
               X1   = XC(I-1); IF(IRC>0) X1=RC_FACE(IRC)%XCEN(X1AXIS,LOWHIGH)
               X2   = CUT_CELL(ICC)%XYZCEN(X1AXIS,JCC)
               RHO1 = RHOP(I-1,J,K)
            ENDIF
         CASE(JAXIS)
            AF   = DX(I)*DZ(K); XFC  = Y(J-1+ILH)   ! Face location in face normal direction.
            !FN_B = FVY_B(I,J-1+ILH,K)
            IRC  = FCVAR(I,J-1+ILH,K,CC_IDRC,X1AXIS)
            IF(LOWHIGH==HIGH_IND) THEN
               P2   = P(I,J+1,K); KR2 = KRES(I,J+1,K)
               X1   = CUT_CELL(ICC)%XYZCEN(X1AXIS,JCC)
               X2   = YC(J+1); IF(IRC>0) X2=RC_FACE(IRC)%XCEN(X1AXIS,LOWHIGH)
               RHO2 = RHOP(I,J+1,K)
            ELSE
               P1   = P(I,J-1,K); KR1 = KRES(I,J-1,K)
               X1   = YC(J-1); IF(IRC>0) X1=RC_FACE(IRC)%XCEN(X1AXIS,LOWHIGH)
               X2   = CUT_CELL(ICC)%XYZCEN(X1AXIS,JCC)
               RHO1 = RHOP(I,J-1,K)
            ENDIF
         CASE(KAXIS)
            AF   = DX(I)*DY(J); XFC  = Z(K-1+ILH)   ! Face location in face normal direction.
            !FN_B = FVZ_B(I,J,K-1+ILH)
            IRC  = FCVAR(I,J,K-1+ILH,CC_IDRC,X1AXIS)
            IF(LOWHIGH==HIGH_IND) THEN
               P2   = P(I,J,K+1); KR2 = KRES(I,J,K+1)
               X1   = CUT_CELL(ICC)%XYZCEN(X1AXIS,JCC)
               X2   = ZC(K+1); IF(IRC>0) X2=RC_FACE(IRC)%XCEN(X1AXIS,LOWHIGH)
               RHO2 = RHOP(I,J,K+1)
            ELSE
               P1   = P(I,J,K-1); KR1 = KRES(I,J,K-1)
               X1   = ZC(K-1); IF(IRC>0) X1=RC_FACE(IRC)%XCEN(X1AXIS,LOWHIGH)
               X2   = CUT_CELL(ICC)%XYZCEN(X1AXIS,JCC)
               RHO1 = RHOP(I,J,K-1)
            ENDIF
         END SELECT
         IF(IRC>0) THEN
            IF( RC_FACE(IRC)%IWC>0 .AND. &
                ANY(WALL(RC_FACE(IRC)%IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/)) ) &
                CYCLE IFC_LOOP_2
         ENDIF
         IF(RC_FACE(IRC)%UNKF>0) THEN
            FN_B = F_LINK(RC_FACE(IRC)%UNKF)
         ELSE
            CALL GET_RCFACE_BAROCLINIC_TORQUE(PRFCT,IRC,CCM1,CCP1,FN_B,HP,RHOP)
         ENDIF
         CCM1 = (X2-XFC)/(X2-X1); CCP1 = (XFC-X1)/(X2-X1); RHOF = CCM1*RHO1 + CCP1*RHO2
         !FN   = FCT * ( 1._EB/RHOF * (P2-P1) + (KR2-KR1) )/(X2-X1) ! (1/rho*Grad(p)+Grad(Kres))
         FN   = FCT * ( (P2/RHO2-P1/RHO1+KR2-KR1)/(X2-X1) + FN_B )  ! (Grad(p/rho)-p*Grad(1/rho)+Grad(Kres))
      CASE(CC_FTYPE_CFGAS) ! GASPHASE CUT FACE:
         LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
         FCT     = REAL(2*LOWHIGH - 3, EB)
         IFC2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
         IF(CUT_FACE(IFC2)%IWC>0 .AND. &
            ANY(WALL(CUT_FACE(IFC2)%IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/))) &
            CYCLE IFC_LOOP_2
         IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
         AF      = CUT_FACE(IFC2)%AREA(IFACE2)
         ! Low side H:
         ICLO = CUT_FACE(IFC2)%CELL_LIST(2,LOW_IND,IFACE2); JCLO = CUT_FACE(IFC2)%CELL_LIST(3,LOW_IND,IFACE2);
         P1  = P(CUT_CELL(ICLO)%IJK(IAXIS),CUT_CELL(ICLO)%IJK(JAXIS),CUT_CELL(ICLO)%IJK(KAXIS))
         KR1 = KRES(CUT_CELL(ICLO)%IJK(IAXIS),CUT_CELL(ICLO)%IJK(JAXIS),CUT_CELL(ICLO)%IJK(KAXIS))
         RHO1= PRFCT*CUT_CELL(ICLO)%RHO(JCLO)+(1._EB-PRFCT)*CUT_CELL(ICLO)%RHOS(JCLO)
         ! High side H:
         ICHI = CUT_FACE(IFC2)%CELL_LIST(2,HIGH_IND,IFACE2); JCHI = CUT_FACE(IFC2)%CELL_LIST(3,HIGH_IND,IFACE2);
         P2  = P(CUT_CELL(ICHI)%IJK(IAXIS),CUT_CELL(ICHI)%IJK(JAXIS),CUT_CELL(ICHI)%IJK(KAXIS))
         KR2 = KRES(CUT_CELL(ICHI)%IJK(IAXIS),CUT_CELL(ICHI)%IJK(JAXIS),CUT_CELL(ICHI)%IJK(KAXIS))
         RHO2= PRFCT*CUT_CELL(ICHI)%RHO(JCHI)+(1._EB-PRFCT)*CUT_CELL(ICHI)%RHOS(JCHI)

         X1AXIS = CUT_FACE(IFC2)%IJK(KAXIS+1)
         XFC    = CUT_FACE(IFC2)%XYZCEN(X1AXIS,IFACE2)
         X1   = CUT_FACE(IFC2)%XCENLOW( X1AXIS,IFACE2)
         X2   = CUT_FACE(IFC2)%XCENHIGH(X1AXIS,IFACE2)
         RHOF = (X2-XFC)/(X2-X1)*RHO1 + (XFC-X1)/(X2-X1)*RHO2 ! CCM1*RHO1 + CCM2*RHO2
         !FN   = FCT * ( 1._EB/RHOF * (P2-P1) + (KR2-KR1) )/(X2-X1) ! (1/rho*Grad(p)+Grad(Kres))
         !FN   = FCT*((P2/RHO2-P1/RHO1+KR2-KR1)/(X2-X1)+CUT_FACE(IFC2)%FN_B(IFACE2)) ! (Grad(p/rho) -
                                                                                     !  p*Grad(1/rho)+Grad(Kres))
         IF(CUT_FACE(IFC2)%UNKF(IFACE2)>0) FN_B = F_LINK(CUT_FACE(IFC2)%UNKF(IFACE2))
         FN = FCT*( (P2/RHO2-P1/RHO1+KR2-KR1)/(X2-X1) + FN_B )
      CASE(CC_FTYPE_CFINB) ! INBOUNDARY CUT FACE
         FCT     = 1._EB    ! Normal vector defined into the body.
         IFC2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
         IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
         ICFA    = CUT_FACE(IFC2)%CFACE_INDEX(IFACE2)
         AF      = CUT_FACE(IFC2)%AREA(IFACE2)
         ! FN      = 0._EB
      END SELECT
      LHSS_CC = LHSS_CC + AF*FN
   ENDDO IFC_LOOP_2

ENDIF DO_SEPARABLE_IF

RETURN
END SUBROUTINE GET_LHS_CUTCELL

! --------------------------- CC_BAROCLINIC_CORRECTION --------------------------

SUBROUTINE CC_BAROCLINIC_CORRECTION(T,NM)

! This routine assumes POINT_TO_MESH(NM) has been called.

USE MATH_FUNCTIONS, ONLY: EVALUATE_RAMP

INTEGER, INTENT(IN) :: NM
REAL(EB),INTENT(IN) :: T

! Local variables:
INTEGER :: ICF,JCF,I,J,K,X1AXIS,II1,II2,JJ1,JJ2,KK1,KK2
REAL(EB):: PRFCT,WG1,WG2,IDX,AT,FRC_B,T_NOW
LOGICAL :: FLG
REAL(EB), POINTER, DIMENSION(:,:,:) :: HP,RHOP

T_NOW = CURRENT_TIME()
AT=T

IF (PREDICTOR) THEN
   PRFCT =  1._EB
   RHOP  => RHO
   HP    => H
ELSE
   PRFCT =  0._EB
   RHOP  => RHOS
   HP    => HS
ENDIF

! 1. Substract FV_B from FV coming from baroclinic:
FVX = FVX - FVX_B
FVY = FVY - FVY_B
FVZ = FVZ - FVZ_B

IF (BAROCLINIC_TERMS_ATTACHED) THEN
    DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
       CF => CUT_FACE(ICF); IF (CF%STATUS/=CC_GASPHASE) CYCLE
       CF%FN(1:CF%NFACE) = CF%FN(1:CF%NFACE) - CF%FN_B(1:CF%NFACE)
       CF%FV             = CF%FV - CF%FV_B
    ENDDO
ENDIF

! 2. Get Baroclinic torque terms for internal cut-faces:
WG1 = 0.5_EB; WG2 = 0.5_EB
CF_LOOP : DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
   CF => CUT_FACE(ICF); IF (CF%STATUS/=CC_GASPHASE) CYCLE CF_LOOP
   IF (ICF<=MESHES(NM)%N_BBCUTFACE_MESH) THEN
      ! Flags consistent with computation of FN=-DUDT in CC_NO_FLUX, SOLID boundaries keep F_B = 0.
      FLG = EXTERNAL_WALL(CF%IWC)%NOM/=0 .AND. &
            .NOT.( ANY(WALL(CF%IWC)%BOUNDARY_TYPE==(/INTERPOLATED_BOUNDARY,PERIODIC_BOUNDARY/)) )
      IF(FLG .OR. ANY(WALL(CF%IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/))) CYCLE CF_LOOP
   ELSEIF(CF%IWC>0) THEN
      IF(ANY(WALL(CF%IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/))) CYCLE CF_LOOP
   ENDIF

   I = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
   II1 = I; JJ1 = J; KK1 = K
   II2 = I; JJ2 = J; KK2 = K
   SELECT CASE(X1AXIS)
   CASE(IAXIS); IDX = RDXN(I); II2 = II2+1; AT = CF%ALPHA_CF * (DY(J)*DZ(K))
   CASE(JAXIS); IDX = RDYN(J); JJ2 = JJ2+1; AT = CF%ALPHA_CF * (DZ(K)*DX(I))
   CASE(KAXIS); IDX = RDZN(K); KK2 = KK2+1; AT = CF%ALPHA_CF * (DX(I)*DY(J))
   END SELECT
   DO JCF=1,CF%NFACE
      IF(CF%UNKF(JCF)<1) CYCLE
      CALL GET_CUTFACE_BAROCLINIC_TORQUE(PRFCT,CF,JCF,IDX,WG1,WG2,II1,JJ1,KK1,II2,JJ2,KK2,CF%FN_B(JCF),HP)
   ENDDO
   CF%FV_B = DOT_PRODUCT(CF%FN_B(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / AT
ENDDO CF_LOOP

! 2. Get Baroclinic torque terms for RC-faces:
RC_LOOP : DO ICF=1,MESHES(NM)%CC_NRCFACE_Z
   RCF => RC_FACE(ICF);
   SELECT CASE(RCF%IJK(KAXIS+1))
   CASE(IAXIS); FVX_B(RCF%IJK(IAXIS),RCF%IJK(JAXIS),RCF%IJK(KAXIS)) = 0._EB
   CASE(JAXIS); FVY_B(RCF%IJK(IAXIS),RCF%IJK(JAXIS),RCF%IJK(KAXIS)) = 0._EB
   CASE(KAXIS); FVZ_B(RCF%IJK(IAXIS),RCF%IJK(JAXIS),RCF%IJK(KAXIS)) = 0._EB
   END SELECT
   !IF(RCF%UNKF<1) CYCLE RC_LOOP
   IF (RCF%IWC>0) THEN
      IF(RCF%IWC<=N_EXTERNAL_WALL_CELLS) THEN
         ! Flags consistent with computation of FN=-DUDT, SOLID boundaries keep F_B = 0.
         FLG = EXTERNAL_WALL(RCF%IWC)%NOM/=0 .AND. &
               .NOT.( ANY(WALL(RCF%IWC)%BOUNDARY_TYPE==(/INTERPOLATED_BOUNDARY,PERIODIC_BOUNDARY/)) )
         IF(FLG .OR. ANY(WALL(RCF%IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/))) CYCLE RC_LOOP
      ELSEIF(ANY(WALL(RCF%IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/))) THEN; CYCLE RC_LOOP
      ENDIF
   ENDIF
   CALL GET_RCFACE_BAROCLINIC_TORQUE(PRFCT,ICF,WG1,WG2,FRC_B,HP,RHOP)

   ! Replace into FVX_B, FVY_B, FVZ_B:
   SELECT CASE(RCF%IJK(KAXIS+1))
   CASE(IAXIS); FVX_B(RCF%IJK(IAXIS),RCF%IJK(JAXIS),RCF%IJK(KAXIS))=FRC_B
   CASE(JAXIS); FVY_B(RCF%IJK(IAXIS),RCF%IJK(JAXIS),RCF%IJK(KAXIS))=FRC_B
   CASE(KAXIS); FVZ_B(RCF%IJK(IAXIS),RCF%IJK(JAXIS),RCF%IJK(KAXIS))=FRC_B
   ENDSELECT

ENDDO RC_LOOP

! 3. Get averaged FV_B in linked faces:
CALL GET_LINKED_FV(NM,DO_BAROCLINIC=.TRUE.)

! 4. Add back FV_B to FV:
FVX = FVX + FVX_B
FVY = FVY + FVY_B
FVZ = FVZ + FVZ_B

! Add to gas cut-faces (BAROCLINIC_TERMS_ATTACHED = .TRUE.):
DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
   CF => CUT_FACE(ICF); IF (CF%STATUS/=CC_GASPHASE) CYCLE
   CF%FN(1:CF%NFACE) = CF%FN(1:CF%NFACE) + CF%FN_B(1:CF%NFACE)
   CF%FV             = CF%FV + CF%FV_B
ENDDO


T_USED(14) = T_USED(14) + CURRENT_TIME() - T_NOW

RETURN
END SUBROUTINE CC_BAROCLINIC_CORRECTION


! --------------------------- GET_CUTFACE_BAROCLINIC_TORQUE ------------------------

SUBROUTINE GET_CUTFACE_BAROCLINIC_TORQUE(PRFCT,CF,JCF,IDX,WG1,WG2,II1,JJ1,KK1,II2,JJ2,KK2,FCF_B,HP)

! Assumes POINT_TO_MESH(NM) has been called.

REAL(EB),INTENT(IN) :: PRFCT
TYPE(CC_CUTFACE_TYPE), INTENT(IN), POINTER :: CF
INTEGER, INTENT(IN) :: JCF,II1,JJ1,KK1,II2,JJ2,KK2
REAL(EB),INTENT(INOUT) :: IDX,WG1,WG2
REAL(EB),INTENT(OUT):: FCF_B
REAL(EB), POINTER, DIMENSION(:,:,:), INTENT(IN) :: HP

INTEGER :: ICC,JCC,X1AXIS
REAL(EB):: X1F,RHO1,RHO2,P1,P2,RHOF

X1AXIS = CF%IJK(KAXIS+1)
IDX=1._EB/(CF%XCENHIGH(X1AXIS,JCF)-CF%XCENLOW(X1AXIS,JCF))
! Interpolation weights:
X1F = CF%XYZCEN(X1AXIS,JCF)
WG1 = IDX*(CF%XCENHIGH(X1AXIS,JCF)-X1F)
WG2 = IDX*(X1F-CF%XCENLOW(X1AXIS, JCF))
! Cut-cell pressure on low side:
ICC = CF%CELL_LIST(2,LOW_IND,JCF); JCC = CF%CELL_LIST(3,LOW_IND,JCF);
RHO1= PRFCT*CUT_CELL(ICC)%RHO(JCC)+(1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
P1  = RHO1*(HP(II1,JJ1,KK1)-KRES(II1,JJ1,KK1))
! Cut-cell pressure on high side:
ICC = CF%CELL_LIST(2,HIGH_IND,JCF); JCC = CF%CELL_LIST(3,HIGH_IND,JCF);
RHO2= PRFCT*CUT_CELL(ICC)%RHO(JCC)+(1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
P2  = RHO2*(HP(II2,JJ2,KK2)-KRES(II2,JJ2,KK2))
! Face density
RHOF= WG1*RHO1 + WG2*RHO2
! Baroclinic Term -p Grad(1/rho):
FCF_B = IDX * ( P2*(1._EB/RHOF-1._EB/RHO2) - P1*(1._EB/RHOF-1._EB/RHO1) )
!FCF_B = - (P1*RHO2+P2*RHO1)/(RHO1+RHO2) * IDX * (1._EB/RHO2-1._EB/RHO1)

RETURN
END SUBROUTINE GET_CUTFACE_BAROCLINIC_TORQUE

! -------------------------- GET_RCFACE_BAROCLINIC_TORQUE --------------------------

SUBROUTINE GET_RCFACE_BAROCLINIC_TORQUE(PRFCT,ICF,WG1,WG2,FRC_B,HP,RHOP)

! Assumes POINT_TO_MESH(NM) has been called.

REAL(EB),INTENT(IN)   :: PRFCT
INTEGER, INTENT(IN)   :: ICF
REAL(EB),INTENT(INOUT):: WG1,WG2
REAL(EB),INTENT(OUT)  :: FRC_B
REAL(EB), POINTER, DIMENSION(:,:,:), INTENT(IN) :: HP,RHOP

INTEGER :: ICC,JCC,I,J,K,X1AXIS,II1,II2,JJ1,JJ2,KK1,KK2
REAL(EB):: IDX,X1F,RHO1,RHO2,P1,P2,RHOF

I = RC_FACE(ICF)%IJK(IAXIS); J = RC_FACE(ICF)%IJK(JAXIS); K = RC_FACE(ICF)%IJK(KAXIS)
X1AXIS = RC_FACE(ICF)%IJK(KAXIS+1)
II1 = I; JJ1 = J; KK1 = K
II2 = I; JJ2 = J; KK2 = K
SELECT CASE(X1AXIS)
CASE(IAXIS); X1F=X(I); IDX = RDXN(I); II2 = II2+1
CASE(JAXIS); X1F=Y(J); IDX = RDYN(J); JJ2 = JJ2+1
CASE(KAXIS); X1F=Z(K); IDX = RDZN(K); KK2 = KK2+1
END SELECT
IDX=1._EB/(RC_FACE(ICF)%XCEN(X1AXIS,HIGH_IND)-RC_FACE(ICF)%XCEN(X1AXIS,LOW_IND))
! Interpolation weights:
WG1 = IDX*(RC_FACE(ICF)%XCEN(X1AXIS,HIGH_IND)-X1F)
WG2 = IDX*(X1F-RC_FACE(ICF)%XCEN(X1AXIS, LOW_IND))
RHO1 = RHOP(II1,JJ1,KK1); RHO2 = RHOP(II2,JJ2,KK2)
IF(RC_FACE(ICF)%CELL_LIST(1,LOW_IND)==CC_FTYPE_CFGAS) THEN
   ICC = RC_FACE(ICF)%CELL_LIST(2,LOW_IND); JCC = RC_FACE(ICF)%CELL_LIST(3,LOW_IND)
   RHO1= PRFCT*CUT_CELL(ICC)%RHO(JCC)+(1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
ENDIF
IF(RC_FACE(ICF)%CELL_LIST(1,HIGH_IND)==CC_FTYPE_CFGAS) THEN
   ICC = RC_FACE(ICF)%CELL_LIST(2,HIGH_IND); JCC = RC_FACE(ICF)%CELL_LIST(3,HIGH_IND)
   RHO2= PRFCT*CUT_CELL(ICC)%RHO(JCC)+(1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
ENDIF
P1   = RHO1*(HP(II1,JJ1,KK1)-KRES(II1,JJ1,KK1))
P2   = RHO2*(HP(II2,JJ2,KK2)-KRES(II2,JJ2,KK2))
! Face density
RHOF = WG1*RHO1 + WG2*RHO2
! Baroclinic torque:
FRC_B = IDX * ( P2*(1._EB/RHOF-1._EB/RHO2) - P1*(1._EB/RHOF-1._EB/RHO1) )
!FRC_B = - (P1*RHO2+P2*RHO1)/(RHO1+RHO2) * IDX * (1._EB/RHO2-1._EB/RHO1)

RETURN
END SUBROUTINE GET_RCFACE_BAROCLINIC_TORQUE

! ------------------------ COMPUTE_LINKED_CUTFACE_BAROCLINIC -----------------------

SUBROUTINE COMPUTE_LINKED_CUTFACE_BAROCLINIC(NM,HP,RHOP,P)

INTEGER, INTENT(IN) :: NM
REAL(EB), POINTER, DIMENSION(:,:,:), INTENT(IN) :: HP,RHOP,P


INTEGER :: IWC,ICF,JCF,I,J,K,X1AXIS,II1,II2,JJ1,JJ2,KK1,KK2
LOGICAL :: FLG
REAL(EB):: PRFCT,IDX,FN_B,WG1,WG2

IF(ALLOCATED(F_LINK)) DEALLOCATE(F_LINK,A_LINK)
ALLOCATE(F_LINK(MESHES(NM)%NUNK_F),A_LINK(MESHES(NM)%NUNK_F)); F_LINK = 0._EB; A_LINK = 0._EB

PRFCT =  0._EB; IF (PREDICTOR) PRFCT =  1._EB

! Regular faces:
DO K=0,KBAR
   DO J=0,JBAR
      DO I=0,IBAR
         ! X face:
         IF (FCVAR(I,J,K,CC_UNKF,IAXIS)>0) THEN
            FN_B = -(P(I,J,K)*RHOP(I+1,J,K)+P(I+1,J,K)*RHOP(I,J,K))*(1._EB/RHOP(I+1,J,K)-1._EB/RHOP(I,J,K))*RDXN(I)/ &
                             (RHOP(I+1,J,K)+RHOP(I,J,K))
            F_LINK(FCVAR(I,J,K,CC_UNKF,IAXIS)) = F_LINK(FCVAR(I,J,K,CC_UNKF,IAXIS)) + FN_B*DY(J)*DZ(K)
            A_LINK(FCVAR(I,J,K,CC_UNKF,IAXIS)) = A_LINK(FCVAR(I,J,K,CC_UNKF,IAXIS)) + DY(J)*DZ(K)
         ENDIF
         ! Y face:
         IF (FCVAR(I,J,K,CC_UNKF,JAXIS)>0) THEN
            FN_B = -(P(I,J,K)*RHOP(I,J+1,K)+P(I,J+1,K)*RHOP(I,J,K))*(1._EB/RHOP(I,J+1,K)-1._EB/RHOP(I,J,K))*RDYN(J)/ &
                             (RHOP(I,J+1,K)+RHOP(I,J,K))
            F_LINK(FCVAR(I,J,K,CC_UNKF,JAXIS)) = F_LINK(FCVAR(I,J,K,CC_UNKF,JAXIS)) + FN_B*DX(I)*DZ(K)
            A_LINK(FCVAR(I,J,K,CC_UNKF,JAXIS)) = A_LINK(FCVAR(I,J,K,CC_UNKF,JAXIS)) + DX(I)*DZ(K)
         ENDIF
         ! Z face:
         IF (FCVAR(I,J,K,CC_UNKF,KAXIS)>0) THEN
            FN_B = -(P(I,J,K)*RHOP(I,J,K+1)+P(I,J,K+1)*RHOP(I,J,K))*(1._EB/RHOP(I,J,K+1)-1._EB/RHOP(I,J,K))*RDZN(K)/ &
                             (RHOP(I,J,K+1)+RHOP(I,J,K))
            F_LINK(FCVAR(I,J,K,CC_UNKF,KAXIS)) = F_LINK(FCVAR(I,J,K,CC_UNKF,KAXIS)) + FN_B*DX(I)*DY(J)
            A_LINK(FCVAR(I,J,K,CC_UNKF,KAXIS)) = A_LINK(FCVAR(I,J,K,CC_UNKF,KAXIS)) + DX(I)*DY(J)
         ENDIF
      ENDDO
   ENDDO
ENDDO
! RC faces:
WG1 = 0.5_EB; WG2 = 0.5_EB
DO ICF=1,MESHES(NM)%CC_NRCFACE_Z
   IF(RC_FACE(ICF)%UNKF<1) CYCLE
   IWC=RC_FACE(ICF)%IWC
   IF (IWC>0) THEN
      IF(IWC<=N_EXTERNAL_WALL_CELLS) THEN
         ! Flags consistent with computation of FN=-DUDT, SOLID boundaries keep F_B = 0.
         FLG = EXTERNAL_WALL(IWC)%NOM/=0 .AND. &
               .NOT.( ANY(WALL(IWC)%BOUNDARY_TYPE==(/INTERPOLATED_BOUNDARY,PERIODIC_BOUNDARY/)) )
         IF(FLG .OR. ANY(WALL(IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/))) CYCLE
      ELSEIF(ANY(WALL(IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/))) THEN; CYCLE
      ENDIF
   ENDIF
   CALL GET_RCFACE_BAROCLINIC_TORQUE(PRFCT,ICF,WG1,WG2,FN_B,HP,RHOP)
   I = RC_FACE(ICF)%IJK(IAXIS); J = RC_FACE(ICF)%IJK(JAXIS); K = RC_FACE(ICF)%IJK(KAXIS)
   X1AXIS = RC_FACE(ICF)%IJK(KAXIS+1)
   SELECT CASE(X1AXIS)
   CASE(IAXIS)
      F_LINK(RC_FACE(ICF)%UNKF) = F_LINK(RC_FACE(ICF)%UNKF) + FN_B*DY(J)*DZ(K)
      A_LINK(RC_FACE(ICF)%UNKF) = A_LINK(RC_FACE(ICF)%UNKF) + DY(J)*DZ(K)
   CASE(JAXIS)
      F_LINK(RC_FACE(ICF)%UNKF) = F_LINK(RC_FACE(ICF)%UNKF) + FN_B*DX(I)*DZ(K)
      A_LINK(RC_FACE(ICF)%UNKF) = A_LINK(RC_FACE(ICF)%UNKF) + DX(I)*DZ(K)
   CASE(KAXIS)
      F_LINK(RC_FACE(ICF)%UNKF) = F_LINK(RC_FACE(ICF)%UNKF) + FN_B*DX(I)*DY(J)
      A_LINK(RC_FACE(ICF)%UNKF) = A_LINK(RC_FACE(ICF)%UNKF) + DX(I)*DY(J)
   END SELECT
ENDDO
! Cut-faces:
DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
   CF => CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE
   IF (ICF<=MESHES(NM)%N_BBCUTFACE_MESH) THEN
    ! Flags consistent with computation of FN=-DUDT in CC_NO_FLUX, SOLID boundaries keep F_B = 0.
    FLG = EXTERNAL_WALL(CF%IWC)%NOM/=0 .AND. &
         .NOT.( ANY(WALL(CF%IWC)%BOUNDARY_TYPE==(/INTERPOLATED_BOUNDARY,PERIODIC_BOUNDARY/)) )
    IF(FLG .OR. ANY(WALL(CF%IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/))) THEN
       ! Boundary cut-faces on wall cells of type solid get F_B = 0:
       DO JCF=1,CF%NFACE; IF(CF%UNKF(JCF)<1) CYCLE; F_LINK(CF%UNKF(JCF))=0._EB; A_LINK(CF%UNKF(JCF))=1._EB; ENDDO; CYCLE
    ENDIF
   ELSEIF(CF%IWC>0) THEN
    IF(ANY(WALL(CF%IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/))) CYCLE
   ENDIF
   I = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
   II1 = I; JJ1 = J; KK1 = K; II2 = I; JJ2 = J; KK2 = K
   SELECT CASE(X1AXIS)
   CASE(IAXIS); IDX = RDXN(I); II2 = II2+1
   CASE(JAXIS); IDX = RDYN(J); JJ2 = JJ2+1
   CASE(KAXIS); IDX = RDZN(K); KK2 = KK2+1
   END SELECT
   DO JCF=1,CF%NFACE
      IF(CF%UNKF(JCF)<1) CYCLE
      CALL GET_CUTFACE_BAROCLINIC_TORQUE(PRFCT,CF,JCF,IDX,WG1,WG2,II1,JJ1,KK1,II2,JJ2,KK2,FN_B,HP)
      F_LINK(CF%UNKF(JCF)) = F_LINK(CF%UNKF(JCF)) + FN_B*CF%AREA(JCF)
      A_LINK(CF%UNKF(JCF)) = A_LINK(CF%UNKF(JCF)) + CF%AREA(JCF)
   ENDDO
ENDDO

! Area Average F:
WHERE(A_LINK>TWO_EPSILON_EB) F_LINK = F_LINK / A_LINK

RETURN
END SUBROUTINE COMPUTE_LINKED_CUTFACE_BAROCLINIC

! --------------------------- CC_VEL_FACE_TO_SOLID_NODE ----------------------------

SUBROUTINE CC_VEL_FACE_TO_SOLID_NODE(NM,I,J,K,VAL)

! Routine to be called from REAL(EB) FUNCTION FACE_VALUE() in a block of the form:
! IF (CC_IBM) THEN
!    SELECT CASE(IND)
!    CASE(6,7,8) ! U,V,W.
!       IF(MESHES(NM)%VERTVAR(I,J,K,CC_VGSC)==CC_SOLID) THEN
!          CALL CC_VEL_FACE_TO_SOLID_NODE(NM,I,J,K,FACE_VALUE)
!          RETURN
!       ENDIF
!    END SELECT
! ENDIF

! Note: Routine assumes POINT_TO_MESH has been called and the node I,J,K is s.t VERTVAR(I,J,K,CC_VGSC)==CC_SOLID.
INTEGER, INTENT(IN) :: NM,I,J,K
REAL(EB),INTENT(OUT):: VAL

! Loval variables:
INTEGER :: DUMMY,II,JJ,KK

! Dummy assignments:
DUMMY=NM
II=I; JJ=J; KK=K

! For now set velocity in CC_SOLID node to zero:
VAL  = 0._EB

! Solid node velocity will depend on if node is inside the geometry or exactly on its boundary (FREE_SLIP).

END SUBROUTINE CC_VEL_FACE_TO_SOLID_NODE


! --------------------------- CC_CUTFACE_VELOCITY ---------------------------

SUBROUTINE CC_CUTFACE_VELOCITY(NM,UU,VV,WW,CF_VEL_FLAG)

! This routine applied at beginning and end of COMPUTE_VEISCOSITY will provide zero gradients and
! turbulent viscosity in cells next to cut-cells for uniform flow.

INTEGER, INTENT(IN) :: NM
LOGICAL, INTENT(IN) :: CF_VEL_FLAG
REAL(EB), POINTER, DIMENSION(:,:,:), INTENT(INOUT) :: UU,VV,WW

! Local Variables:
INTEGER :: ICF,I,J,K,X1AXIS

IF (CF_VEL_FLAG) THEN
   DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      IF(CUT_FACE(ICF)%STATUS /= CC_GASPHASE) CYCLE
      I = CUT_FACE(ICF)%IJK(IAXIS)
      J = CUT_FACE(ICF)%IJK(JAXIS)
      K = CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)
      SELECT CASE(X1AXIS)
      CASE(IAXIS); UU(I,J,K) = UU(I,J,K)/CUT_FACE(ICF)%ALPHA_CF
      CASE(JAXIS); VV(I,J,K) = VV(I,J,K)/CUT_FACE(ICF)%ALPHA_CF
      CASE(KAXIS); WW(I,J,K) = WW(I,J,K)/CUT_FACE(ICF)%ALPHA_CF
      END SELECT
   ENDDO
ELSE
   DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      IF(CUT_FACE(ICF)%STATUS /= CC_GASPHASE) CYCLE
      I = CUT_FACE(ICF)%IJK(IAXIS)
      J = CUT_FACE(ICF)%IJK(JAXIS)
      K = CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)
      SELECT CASE(X1AXIS)
      CASE(IAXIS); UU(I,J,K) = UU(I,J,K)*CUT_FACE(ICF)%ALPHA_CF
      CASE(JAXIS); VV(I,J,K) = VV(I,J,K)*CUT_FACE(ICF)%ALPHA_CF
      CASE(KAXIS); WW(I,J,K) = WW(I,J,K)*CUT_FACE(ICF)%ALPHA_CF
      END SELECT
   ENDDO
ENDIF

RETURN

END SUBROUTINE CC_CUTFACE_VELOCITY


! ----------------------------- GET_CFACE_OPEN_BC_COEF ------------------------------

SUBROUTINE GET_CFACE_OPEN_BC_COEF(ICF,IOR,IDX,BIJ)

! Computes the diagonal coefficient for Laplacian matrix given a Dirichlet BC.
! IDX is initially 1/DXN where DXN depends on IOR.

INTEGER, INTENT(IN) :: ICF,IOR
REAL(EB),INTENT(INOUT):: IDX
REAL(EB),INTENT(OUT):: BIJ

INTEGER :: JCF,X1AXIS

BIJ = 0._EB; X1AXIS=ABS(IOR)
DO JCF=1,CUT_FACE(ICF)%NFACE
   IDX = 1._EB/(CUT_FACE(ICF)%XCENHIGH(X1AXIS,JCF)-CUT_FACE(ICF)%XCENLOW(X1AXIS,JCF))
   BIJ = BIJ + IDX*CUT_FACE(ICF)%AREA(JCF)
ENDDO

RETURN
END SUBROUTINE GET_CFACE_OPEN_BC_COEF

! ----------------------------- GET_FH_FROM_PRHS_AND_BCS ----------------------------

SUBROUTINE GET_FH_FROM_PRHS_AND_BCS(NM,DT,CYL_FCT,UNKH,NUNKH,IPZ,F_H)

! NOTE : This routine assumes POINT_TO_MESH has been called and F_H has been ZEROED for the MPI process.

INTEGER, INTENT(IN) :: NM,NUNKH,UNKH,IPZ
REAL(EB),INTENT(IN) :: DT,CYL_FCT
REAL(EB),INTENT(OUT):: F_H(NUNKH)

! Local variables:
INTEGER :: I,J,K,IROW,IW,IIG,JJG,KKG,IOR,ICFACE,IFACE,JFACE,ILH,JLH,KLH,IRC
TYPE (WALL_TYPE), POINTER :: WC=>NULL()
TYPE (EXTERNAL_WALL_TYPE), POINTER :: EWC=>NULL()
TYPE(CFACE_TYPE), POINTER :: CFA=>NULL()
REAL(EB) :: IDX, AF, VAL, BCV

! Dummy Assignment.
VAL=DT

! First Source on Cartesian cells with CC_UNKH > 0:
DO K=1,KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         IF (CCVAR(I,J,K,UNKH)<=0 .OR. ZONE_SOLVE(PRESSURE_ZONE(I,J,K))%CONNECTED_ZONE_PARENT/=IPZ) CYCLE
         ! Row number:
         IROW = CCVAR(I,J,K,UNKH) - ZONE_SOLVE(IPZ)%UNKH_IND(NM_START) ! Local numeration.
         ! Add to F_H: If CYL_FCT=0. -> Cartesian coordinates volume (RC(I)=1.).
         !             If CYL_FCT=1. -> Cylindrical coords volume.
         F_H(IROW) = F_H(IROW) + PRHS(I,J,K) * ((1._EB-CYL_FCT)*DY(J) + CYL_FCT*RC(I))*DX(I)*DZ(K)
      ENDDO
   ENDDO
ENDDO

! Rebuild F_H for cut-cells using previously computed CFACE boundary conditions.
IF (CC_IBM) CALL GET_CUTCELL_FH(NM,NUNKH,IPZ,F_H) ! Note: CYL_FCT not used for cut-cells.

! Compute FV in boundary and external CFACEs with DIRICHLET external BCs:
CFACE_LOOP_1 : DO ICFACE=1,N_EXTERNAL_CFACE_CELLS

   CFA => CFACE(ICFACE)
   ! Global matrix solve, skip INTERPOLATED boundaries.
   IF (PRES_FLAG/=ULMAT_FLAG .AND. CFA%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) CYCLE
   ! Here case where SOLID and OPEN or interpolated are mixed on a boundary:
   IF( CFA%BOUNDARY_TYPE==NULL_BOUNDARY .OR. CFA%BOUNDARY_TYPE==SOLID_BOUNDARY) CYCLE

   IFACE= CFA%CUT_FACE_IND1
   JFACE= CFA%CUT_FACE_IND2
   WC  => WALL(CUT_FACE(IFACE)%IWC)
   EWC => EXTERNAL_WALL(CUT_FACE(IFACE)%IWC)

   ! DIRICHLET boundaries:
   IF_CFACE_DIRICHLET: IF (EWC%PRESSURE_BC_TYPE==DIRICHLET) THEN

      ! Gasphase cell indexes:
      BC => BOUNDARY_COORD(WC%BC_INDEX); IF(ZONE_SOLVE(PRESSURE_ZONE(BC%IIG,BC%JJG,BC%KKG))%CONNECTED_ZONE_PARENT/=IPZ) CYCLE
      IIG = BC%IIG; JJG = BC%JJG; KKG = BC%KKG; IOR = BC%IOR
      ! Define centroid to centroid distance, normal to WC:
      IDX=1._EB/(CUT_FACE(IFACE)%XCENHIGH(ABS(IOR),JFACE)-CUT_FACE(IFACE)%XCENLOW(ABS(IOR),JFACE))

      VAL = -2._EB*IDX * CFA%AREA * CFA%PRES_BXN

      ! Row number:
      IROW = CCVAR(IIG,JJG,KKG,UNKH) - ZONE_SOLVE(IPZ)%UNKH_IND(NM_START) ! Local numeration.
      IF (IROW <= 0 .AND. CC_IBM) CALL GET_CC_IROW(IIG,JJG,KKG,IPZ,IROW)
      IF (IROW <= 0) CYCLE

      ! Add to F_H:
      F_H(IROW) = F_H(IROW) + VAL

   ENDIF IF_CFACE_DIRICHLET

ENDDO CFACE_LOOP_1

! Finally add External Wall cell BCs:
WALL_CELL_LOOP_1: DO IW=1,N_EXTERNAL_WALL_CELLS

   WC => WALL(IW)
   EWC => EXTERNAL_WALL(IW)
   ! Drop if this is a cut-face or NULL Boundary. Dealt with external CFACE.
   IF (WC%CUT_FACE_INDEX>0 .OR. WC%BOUNDARY_TYPE==NULL_BOUNDARY) CYCLE
   ! Gasphase cell indexes:
   BC => BOUNDARY_COORD(WC%BC_INDEX); IF(ZONE_SOLVE(PRESSURE_ZONE(BC%IIG,BC%JJG,BC%KKG))%CONNECTED_ZONE_PARENT/=IPZ) CYCLE
   IIG = BC%IIG; JJG = BC%JJG; KKG = BC%KKG; IOR = BC%IOR

   ! NEUMANN boundaries:
   IF_NEUMANN: IF (EWC%PRESSURE_BC_TYPE==NEUMANN) THEN
      ! Define cell size, normal to WC:
      SELECT CASE (IOR)
      CASE(-1) ! -IAXIS oriented, high face of IIG cell.
         AF  =  ((1._EB-CYL_FCT)*DY(JJG) + CYL_FCT*R(IIG  )) * DZ(KKG)
         VAL = -BXF(JJG,KKG)*AF
      CASE( 1) ! +IAXIS oriented, low face of IIG cell.
         AF  =  ((1._EB-CYL_FCT)*DY(JJG) + CYL_FCT*R(IIG-1)) * DZ(KKG)
         VAL =  BXS(JJG,KKG)*AF
      CASE(-2) ! -JAXIS oriented, high face of JJG cell.
         AF  =  DX(IIG)*DZ(KKG)
         VAL = -BYF(IIG,KKG)*AF
      CASE( 2) ! +JAXIS oriented, low face of JJG cell.
         AF  =  DX(IIG)*DZ(KKG)
         VAL =  BYS(IIG,KKG)*AF
      CASE(-3) ! -KAXIS oriented, high face of KKG cell.
         AF  =  ((1._EB-CYL_FCT)*DY(JJG) + CYL_FCT*RC(IIG  ))* DX(IIG)
         VAL = -BZF(IIG,JJG)*AF
      CASE( 3) ! +KAXIS oriented, low face of KKG cell.
         AF  =  ((1._EB-CYL_FCT)*DY(JJG) + CYL_FCT*RC(IIG  ))* DX(IIG)
         VAL =  BZS(IIG,JJG)*AF
      END SELECT

      ! Row number:
      IROW = CCVAR(IIG,JJG,KKG,UNKH) - ZONE_SOLVE(IPZ)%UNKH_IND(NM_START) ! Local numeration.
      IF (IROW <= 0 .AND. CC_IBM) THEN
         CALL GET_CC_IROW(IIG,JJG,KKG,IPZ,IROW)
         IF (IROW <= 0) CYCLE
      ENDIF

      ! Add to F_H:
      F_H(IROW) = F_H(IROW) + VAL

   ENDIF IF_NEUMANN

   ! DIRICHLET boundaries:
   IF_DIRICHLET: IF (EWC%PRESSURE_BC_TYPE==DIRICHLET) THEN
      ! Global matrix solve, skip INTERPOLATED boundaries.
      IF (PRES_FLAG/=ULMAT_FLAG .AND. WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) CYCLE
      ! Here case where SOLID and OPEN or interpolated are mixed on a boundary:
      IF( WC%BOUNDARY_TYPE==NULL_BOUNDARY  .OR. &
          WC%BOUNDARY_TYPE==SOLID_BOUNDARY .OR. WC%BOUNDARY_TYPE==MIRROR_BOUNDARY ) CYCLE
      ! Define cell size, normal to WC:
      ILH    = 0; JLH = 0; KLH = 0
      SELECT CASE (IOR)
      CASE(-1) ! -IAXIS oriented, high face of IIG cell.
         IDX = RDXN(IIG+ILH); BCV = BXF(JJG,KKG)
         AF  = ((1._EB-CYL_FCT)*DY(JJG) + CYL_FCT*R(IIG  )) * DZ(KKG)
      CASE( 1) ! +IAXIS oriented, low face of IIG cell.
         ILH = -1; IDX = RDXN(IIG+ILH); BCV = BXS(JJG,KKG)
         AF  = ((1._EB-CYL_FCT)*DY(JJG) + CYL_FCT*R(IIG-1)) * DZ(KKG)
      CASE(-2) ! -JAXIS oriented, high face of JJG cell.
         IDX = RDYN(JJG+JLH); BCV = BYF(IIG,KKG)
         AF  = DX(IIG)*DZ(KKG)
      CASE( 2) ! +JAXIS oriented, low face of JJG cell.
         JLH = -1; IDX = RDYN(JJG+JLH); BCV = BYS(IIG,KKG)
         AF  = DX(IIG)*DZ(KKG)
      CASE(-3) ! -KAXIS oriented, high face of KKG cell.
         IDX = RDZN(KKG+KLH); BCV = BZF(IIG,JJG)
         AF  =  ((1._EB-CYL_FCT)*DY(JJG) + CYL_FCT*RC(IIG  ))* DX(IIG)
      CASE( 3) ! +KAXIS oriented, low face of KKG cell.
         KLH = -1; IDX = RDZN(KKG+KLH); BCV = BZS(IIG,JJG)
         AF  =  ((1._EB-CYL_FCT)*DY(JJG) + CYL_FCT*RC(IIG  ))* DX(IIG)
      END SELECT
      ! Address case of RC face in the boundary:
      IF (CC_IBM) THEN
         IRC = FCVAR(IIG+ILH,JJG+JLH,KKG+KLH,CC_IDRC,ABS(BC%IOR))
         IF(IRC > 0) IDX = 1._EB / ( RC_FACE(IRC)%XCEN(ABS(BC%IOR),HIGH_IND) - RC_FACE(IRC)%XCEN(ABS(BC%IOR),LOW_IND) )
      ENDIF
      ! Row number:
      IROW = CCVAR(IIG,JJG,KKG,UNKH) - ZONE_SOLVE(IPZ)%UNKH_IND(NM_START) ! Local numeration.
      IF (IROW <= 0 .AND. CC_IBM) CALL GET_CC_IROW(IIG,JJG,KKG,IPZ,IROW)
      IF (IROW <= 0) CYCLE
      ! Add to F_H:
      F_H(IROW) = F_H(IROW) + (-2._EB*IDX*AF*BCV)

   ENDIF IF_DIRICHLET

ENDDO WALL_CELL_LOOP_1


END SUBROUTINE GET_FH_FROM_PRHS_AND_BCS


! -------------------------------- GET_PRES_CFACE_BCS -------------------------------

SUBROUTINE GET_PRES_CFACE_BCS(NM,T,DT)

USE MATH_FUNCTIONS, ONLY: EVALUATE_RAMP

! NOTE : This routine assumes POINT_TO_MESH has been called.

INTEGER, INTENT(IN) :: NM
REAL(EB),INTENT(IN) :: T,DT

! Local Variables:
INTEGER :: ICF,I,J,K,IOR,IFACE,JFACE,NFACE
REAL(EB):: IDX,HN,TSI,VEL_EDDY,TIME_RAMP_FACTOR,P_EXTERNAL,H0,DX_1
REAL(EB), POINTER, DIMENSION(:,:,:) :: UU,VV,WW,HP
TYPE (VENTS_TYPE), POINTER :: VT
TYPE (WALL_TYPE), POINTER :: WC
TYPE (EXTERNAL_WALL_TYPE), POINTER :: EWC
TYPE (CFACE_TYPE), POINTER :: CFA
TYPE (BOUNDARY_PROP1_TYPE), POINTER :: CFA_B1
TYPE(MESH_TYPE), POINTER :: M2
TYPE (CC_CUTFACE_TYPE), POINTER :: CF2
INTEGER :: IIO,JJO,KKO,NOM,IW,ICFO,JCFO
REAL(EB):: H_OTHER,DA_OTHER,DX_OTHER,DY_OTHER,DZ_OTHER,A_FACE

! Dummy assignment.
I=NM; IDX=DT

IF (PREDICTOR) THEN
   UU => U
   VV => V
   WW => W
   HP => H
ELSE
   UU => US
   VV => VS
   WW => WS
   HP => HS
ENDIF

! Apply pressure boundary conditions at external cells.
! If Neumann, CFACE(ICF)%PRES_BXN contains dH/dx.
! If Dirichlet, CFACE(ICF)%PRES_BXN contains H.

! External mesh CFACEs:
CFACE_LOOP_1 : DO ICF=1,N_EXTERNAL_CFACE_CELLS+N_INTWALL_CFACE_CELLS+N_INTERNAL_CFACE_CELLS

   CFA => CFACE(ICF)
   BC  => BOUNDARY_COORD(CFA%BC_INDEX)
   I   = BC%II
   J   = BC%JJ
   K   = BC%KK
   IOR = BC%IOR

   IFACE=CFA%CUT_FACE_IND1
   JFACE=CFA%CUT_FACE_IND2
   NFACE=CUT_FACE(IFACE)%NFACE

   ! Apply pressure gradients at NEUMANN boundaries: dH/dn = -F_n - d(u_n)/dt

   IF_NEUMANN: IF (CFA%BOUNDARY_TYPE==SOLID_BOUNDARY) THEN
      HN    = 1._EB
      IF (ICF<=N_EXTERNAL_CFACE_CELLS) THEN
         SELECT CASE(IOR)
         CASE( 1); HN = HX(0)
         CASE(-1); HN = HX(IBP1)
         CASE( 2); HN = HY(0)
         CASE(-2); HN = HY(JBP1)
         CASE( 3); HN = HZ(0)
         CASE(-3); HN = HZ(KBP1)
         END SELECT
      ENDIF
      ! dH/Dn where n is pointing out of the gas region.
      CFA%PRES_BXN = -HN*(CUT_FACE(IFACE)%FN(JFACE) + CFA%DUNDT)
   ENDIF IF_NEUMANN

   ! Interpolated and OPEN BCs only in External wall cells:
   EXT_CFACE_IF : IF (ICF<=N_EXTERNAL_CFACE_CELLS) THEN

      IW = CUT_FACE(IFACE)%IWC
      WC=>WALL(IW)
      EWC=>EXTERNAL_WALL(IW)

      ! Interpolated boundary -- set boundary value of H to be average of neighboring cells from previous time step

      INTERPOLATED_ONLY:  IF(PRES_FLAG==ULMAT_FLAG .AND. CFA%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) THEN

         NOM     = EWC%NOM
         M2      =>MESHES(NOM)

         H_OTHER = 0._EB; DA_OTHER = 0._EB; DX_OTHER = 0._EB; DY_OTHER = 0._EB; DZ_OTHER = 0._EB
         DX_1 = CUT_FACE(IFACE)%XCENHIGH(ABS(IOR),JFACE)-CUT_FACE(IFACE)%XCENLOW(ABS(IOR),JFACE)
         SELECT CASE(IOR)
            CASE( 1)

               DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
                  DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                     DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                        IF(M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                        IF(M2%FCVAR(IIO,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE

                        ICFO = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,ABS(IOR))
                        IF (ICFO>0) THEN
                           CF2 => M2%CUT_FACE(ICFO); A_FACE = 0._EB
                           DO JCFO=1,CF2%NFACE
                              A_FACE   = A_FACE + CF2%AREA(JCFO)
                              DX_OTHER = DX_OTHER + &
                              (CF2%XCENHIGH(ABS(IOR),JCFO)-CF2%XCENLOW(ABS(IOR),JCFO))*CF2%AREA(JCFO)
                           ENDDO
                        ELSE
                           A_FACE   = M2%DY(JJO)*M2%DZ(KKO)
                           DX_OTHER = DX_OTHER + M2%DX(EWC%IIO_MIN)*A_FACE
                        ENDIF
                        DA_OTHER = DA_OTHER + A_FACE
                        IF (PREDICTOR) H_OTHER = H_OTHER + OMESH(NOM)%H(IIO,JJO,KKO)*A_FACE
                        IF (CORRECTOR) H_OTHER = H_OTHER + OMESH(NOM)%HS(IIO,JJO,KKO)*A_FACE
                     ENDDO
                  ENDDO
               ENDDO
               H_OTHER  = H_OTHER/DA_OTHER
               DX_OTHER = DX_OTHER/DA_OTHER
               CFA%PRES_BXN = (DX_OTHER*HP(1,J,K) + DX_1*H_OTHER)/(DX_1+DX_OTHER) + WALL_WORK1(IW)
               BXS(J,K) = CFA%PRES_BXN
            CASE(-1)

               DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
                  DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                     DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                        IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                        IF (M2%FCVAR(IIO-1,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE

                        ICFO = M2%FCVAR(IIO-1,JJO,KKO,CC_IDCF,ABS(IOR))
                        IF (ICFO>0) THEN
                           CF2 =>M2%CUT_FACE(ICFO); A_FACE = 0._EB
                           DO JCFO=1,CF2%NFACE
                              A_FACE   = A_FACE + CF2%AREA(JCFO)
                              DX_OTHER = DX_OTHER + &
                              (CF2%XCENHIGH(ABS(IOR),JCFO)-CF2%XCENLOW(ABS(IOR),JCFO))*CF2%AREA(JCFO)
                           ENDDO
                        ELSE
                           A_FACE   = M2%DY(JJO)*M2%DZ(KKO)
                           DX_OTHER = DX_OTHER + M2%DX(EWC%IIO_MIN)*A_FACE
                        ENDIF
                        DA_OTHER = DA_OTHER + A_FACE
                        IF (PREDICTOR) H_OTHER = H_OTHER + OMESH(NOM)%H(IIO,JJO,KKO)*A_FACE
                        IF (CORRECTOR) H_OTHER = H_OTHER + OMESH(NOM)%HS(IIO,JJO,KKO)*A_FACE
                     ENDDO
                  ENDDO
               ENDDO
               H_OTHER  = H_OTHER/DA_OTHER
               DX_OTHER = DX_OTHER/DA_OTHER
               CFA%PRES_BXN = (DX_OTHER*HP(IBAR,J,K) + DX_1*H_OTHER)/(DX_1+DX_OTHER) + WALL_WORK1(IW)
               BXF(J,K) = CFA%PRES_BXN
            CASE( 2)

               DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
                  DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                     DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                        IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                        IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE

                        ICFO = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,ABS(IOR))
                        IF (ICFO>0) THEN
                           CF2 =>M2%CUT_FACE(ICFO); A_FACE = 0._EB
                           DO JCFO=1,CF2%NFACE
                              A_FACE   = A_FACE + CF2%AREA(JCFO)
                              DY_OTHER = DY_OTHER + &
                              (CF2%XCENHIGH(ABS(IOR),JCFO)-CF2%XCENLOW(ABS(IOR),JCFO))*CF2%AREA(JCFO)
                           ENDDO
                        ELSE
                           A_FACE   = M2%DX(IIO)*M2%DZ(KKO)
                           DY_OTHER = DY_OTHER + M2%DY(EWC%JJO_MIN)*A_FACE
                        ENDIF
                        DA_OTHER = DA_OTHER + A_FACE
                        IF (PREDICTOR) H_OTHER = H_OTHER + OMESH(NOM)%H(IIO,JJO,KKO)*A_FACE
                        IF (CORRECTOR) H_OTHER = H_OTHER + OMESH(NOM)%HS(IIO,JJO,KKO)*A_FACE
                     ENDDO
                  ENDDO
               ENDDO
               H_OTHER = H_OTHER/DA_OTHER
               DY_OTHER = DY_OTHER/DA_OTHER
               CFA%PRES_BXN = (DY_OTHER*HP(I,1,K) + DX_1*H_OTHER)/(DX_1+DY_OTHER) + WALL_WORK1(IW)
               BYS(I,K) = CFA%PRES_BXN
            CASE(-2)

               DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
                  DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                     DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                        IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                        IF (M2%FCVAR(IIO,JJO-1,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE

                        ICFO = M2%FCVAR(IIO,JJO-1,KKO,CC_IDCF,ABS(IOR))
                        IF (ICFO>0) THEN
                           CF2 =>M2%CUT_FACE(ICFO); A_FACE = 0._EB
                           DO JCFO=1,CF2%NFACE
                              A_FACE   = A_FACE + CF2%AREA(JCFO)
                              DY_OTHER = DY_OTHER + &
                              (CF2%XCENHIGH(ABS(IOR),JCFO)-CF2%XCENLOW(ABS(IOR),JCFO))*CF2%AREA(JCFO)
                           ENDDO
                        ELSE
                           A_FACE   = M2%DX(IIO)*M2%DZ(KKO)
                           DY_OTHER = DY_OTHER + M2%DY(EWC%JJO_MIN)*A_FACE
                        ENDIF
                        DA_OTHER = DA_OTHER + A_FACE
                        IF (PREDICTOR) H_OTHER = H_OTHER + OMESH(NOM)%H(IIO,JJO,KKO)*A_FACE
                        IF (CORRECTOR) H_OTHER = H_OTHER + OMESH(NOM)%HS(IIO,JJO,KKO)*A_FACE
                     ENDDO
                  ENDDO
               ENDDO
               H_OTHER  = H_OTHER/DA_OTHER
               DY_OTHER = DY_OTHER/DA_OTHER
               CFA%PRES_BXN = (DY_OTHER*HP(I,JBAR,K) + DX_1*H_OTHER)/(DX_1+DY_OTHER) + WALL_WORK1(IW)
               BYF(I,K) = CFA%PRES_BXN
            CASE( 3)

               DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
                  DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                     DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                        IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                        IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE

                        ICFO = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,ABS(IOR))
                        IF (ICFO>0) THEN
                           CF2 =>M2%CUT_FACE(ICFO); A_FACE = 0._EB
                           DO JCFO=1,CF2%NFACE
                              A_FACE   = A_FACE + CF2%AREA(JCFO)
                              DZ_OTHER = DZ_OTHER + &
                              (CF2%XCENHIGH(ABS(IOR),JCFO)-CF2%XCENLOW(ABS(IOR),JCFO))*CF2%AREA(JCFO)
                           ENDDO
                        ELSE
                           A_FACE   = M2%DX(IIO)*M2%DY(JJO)
                           DZ_OTHER = DZ_OTHER + M2%DZ(EWC%KKO_MIN)*A_FACE
                        ENDIF
                        DA_OTHER = DA_OTHER + A_FACE
                        IF (PREDICTOR) H_OTHER = H_OTHER + OMESH(NOM)%H(IIO,JJO,KKO)*A_FACE
                        IF (CORRECTOR) H_OTHER = H_OTHER + OMESH(NOM)%HS(IIO,JJO,KKO)*A_FACE
                     ENDDO
                  ENDDO
               ENDDO
               H_OTHER  = H_OTHER/DA_OTHER
               DZ_OTHER = DZ_OTHER/DA_OTHER
               CFA%PRES_BXN = (DZ_OTHER*HP(I,J,1) + DX_1*H_OTHER)/(DX_1+DZ_OTHER) + WALL_WORK1(IW)
               BZS(I,J) = CFA%PRES_BXN
            CASE(-3)

               DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
                  DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                     DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                        IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                        IF (M2%FCVAR(IIO,JJO,KKO-1,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE

                        ICFO = M2%FCVAR(IIO,JJO,KKO-1,CC_IDCF,ABS(IOR))
                        IF (ICFO>0) THEN
                           CF2 =>M2%CUT_FACE(ICFO); A_FACE = 0._EB
                           DO JCFO=1,CF2%NFACE
                              A_FACE = A_FACE + CF2%AREA(JCFO)
                              DZ_OTHER = DZ_OTHER + &
                              (CF2%XCENHIGH(ABS(IOR),JCFO)-CF2%XCENLOW(ABS(IOR),JCFO))*CF2%AREA(JCFO)
                           ENDDO
                        ELSE
                           A_FACE   = M2%DX(IIO)*M2%DY(JJO)
                           DZ_OTHER = DZ_OTHER + M2%DZ(EWC%KKO_MIN)*A_FACE
                        ENDIF
                        DA_OTHER = DA_OTHER + A_FACE
                        IF (PREDICTOR) H_OTHER = H_OTHER + OMESH(NOM)%H(IIO,JJO,KKO)*A_FACE
                        IF (CORRECTOR) H_OTHER = H_OTHER + OMESH(NOM)%HS(IIO,JJO,KKO)*A_FACE
                     ENDDO
                  ENDDO
               ENDDO
               H_OTHER  = H_OTHER/DA_OTHER
               DZ_OTHER = DZ_OTHER/DA_OTHER
               CFA%PRES_BXN = (DZ_OTHER*HP(I,J,KBAR) + DX_1*H_OTHER)/(DX_1+DZ_OTHER) + WALL_WORK1(IW)
               BZF(I,J) = CFA%PRES_BXN
         END SELECT

      ENDIF INTERPOLATED_ONLY

      ! OPEN (passive opening to exterior of domain) boundary. Apply inflow/outflow BC.

      OPEN_IF: IF (WC%BOUNDARY_TYPE==OPEN_BOUNDARY) THEN

         VT => VENTS(WC%VENT_INDEX)
         B1 => BOUNDARY_PROP1(WC%B1_INDEX)
         IF (ABS(B1%T_IGN-T_BEGIN)<=TWO_EPSILON_EB .AND. VT%PRESSURE_RAMP_INDEX >=1) THEN
            TSI = T
         ELSE
            TSI = T - T_BEGIN
         ENDIF
         TIME_RAMP_FACTOR = EVALUATE_RAMP(TSI,VT%PRESSURE_RAMP_INDEX)
         P_EXTERNAL = TIME_RAMP_FACTOR*VT%DYNAMIC_PRESSURE

         ! Synthetic eddy method for OPEN inflow boundaries
         VEL_EDDY = 0._EB
         IF (VT%N_EDDY>0) THEN
            SELECT CASE(ABS(VT%IOR))
               CASE(1); VEL_EDDY = VT%U_EDDY(J,K)
               CASE(2); VEL_EDDY = VT%V_EDDY(I,K)
               CASE(3); VEL_EDDY = VT%W_EDDY(I,J)
            END SELECT
         ENDIF

         ! Wind inflow boundary conditions

         H0 = 0.5_EB*(U0**2+V0**2+W0**2)
         IF (OPEN_WIND_BOUNDARY) &
         H0 = 0.5_EB*((U_WIND(K)+VEL_EDDY)**2 + (V_WIND(K)+VEL_EDDY)**2 + (W_WIND(K)+VEL_EDDY)**2)

         CFA_B1 => BOUNDARY_PROP1(CFA%B1_INDEX)
         SELECT CASE(IOR)
            CASE( 1)
               IF (UU(0,J,K)<0._EB) THEN
                  CFA%PRES_BXN = P_EXTERNAL/CFA_B1%RHO_F + KRES(1,J,K)
               ELSE
                  CFA%PRES_BXN = P_EXTERNAL/CFA_B1%RHO_F + H0
               ENDIF
               BXS(J,K) = CFA%PRES_BXN
            CASE(-1)
               IF (UU(IBAR,J,K)>0._EB) THEN
                  CFA%PRES_BXN = P_EXTERNAL/CFA_B1%RHO_F + KRES(IBAR,J,K)
               ELSE
                  CFA%PRES_BXN = P_EXTERNAL/CFA_B1%RHO_F + H0
               ENDIF
               BXF(J,K) = CFA%PRES_BXN
            CASE( 2)
               IF (VV(I,0,K)<0._EB) THEN
                  CFA%PRES_BXN = P_EXTERNAL/CFA_B1%RHO_F + KRES(I,1,K)
               ELSE
                  CFA%PRES_BXN = P_EXTERNAL/CFA_B1%RHO_F + H0
               ENDIF
               BYS(I,K) = CFA%PRES_BXN
            CASE(-2)
               IF (VV(I,JBAR,K)>0._EB) THEN
                  CFA%PRES_BXN = P_EXTERNAL/CFA_B1%RHO_F + KRES(I,JBAR,K)
               ELSE
                  CFA%PRES_BXN = P_EXTERNAL/CFA_B1%RHO_F + H0
               ENDIF
               BYF(I,K) = CFA%PRES_BXN
            CASE( 3)
               IF (WW(I,J,0)<0._EB) THEN
                  CFA%PRES_BXN = P_EXTERNAL/CFA_B1%RHO_F + KRES(I,J,1)
               ELSE
                  CFA%PRES_BXN = P_EXTERNAL/CFA_B1%RHO_F + H0
               ENDIF
               BZS(I,J) = CFA%PRES_BXN
            CASE(-3)
               IF (WW(I,J,KBAR)>0._EB) THEN
                  CFA%PRES_BXN = P_EXTERNAL/CFA_B1%RHO_F + KRES(I,J,KBAR)
               ELSE
                  CFA%PRES_BXN = P_EXTERNAL/CFA_B1%RHO_F + H0
               ENDIF
               BZF(I,J) = CFA%PRES_BXN
         END SELECT

      ENDIF OPEN_IF

   ENDIF EXT_CFACE_IF

ENDDO CFACE_LOOP_1

END SUBROUTINE GET_PRES_CFACE_BCS

! --------------------------------- GET_CUTCELL_DDDT --------------------------------

SUBROUTINE GET_CUTCELL_DDDT(DT,NM)

! Here assume CALL POINT_TO_MESH has been made.

REAL(EB), INTENT(IN) :: DT
INTEGER,  INTENT(IN) :: NM

! Local Variables:
REAL(EB) :: RDT, PRFCT, VOL, DIVVOL, DPCC, DIV_JCC
INTEGER  :: I,J,K,IPZ,NCELL,ICC,JCC
REAL(EB), POINTER, DIMENSION(:) :: D_PBAR_DT_P

RDT = 1._EB/DT

SELECT CASE(PREDICTOR)
   CASE(.TRUE.)
      D_PBAR_DT_P => D_PBAR_DT_S
      PRFCT = 1._EB
   CASE(.FALSE.)
      D_PBAR_DT_P => D_PBAR_DT
      PRFCT = 0._EB
END SELECT

PRED_CORR_IF : IF (PREDICTOR) THEN

   ICC_LOOP_1 : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      I      = CUT_CELL(ICC)%IJK(IAXIS)
      J      = CUT_CELL(ICC)%IJK(JAXIS)
      K      = CUT_CELL(ICC)%IJK(KAXIS)
      IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE ICC_LOOP_1
      IPZ    = PRESSURE_ZONE(I,J,K)
      NCELL  = CUT_CELL(ICC)%NCELL
      DIVVOL = 0._EB; DPCC   = 0._EB; VOL    = 0._EB
      IF (ONE_UNKH_PER_CUTCELL) THEN ! DDDTVOL(JCC) defined per cut-cell.
         DO JCC=1,NCELL
            CALL GET_VELOC_DIVERGENCE_CUTCELL(ICC,JCC,0._EB,DIV_JCC) ! Velocity divg of U,V,W -> PRFCT=0._EB
            CUT_CELL(ICC)%DVOL_PR(JCC) = DIV_JCC*CUT_CELL(ICC)%VOLUME(JCC)
            DIVVOL = DIVVOL + CUT_CELL(ICC)%DVOL_PR(JCC)
            ! Thermodynamic divergence * vol:
            DPCC= ( (1._EB-PRFCT)*CUT_CELL(ICC)%D(JCC) + PRFCT*CUT_CELL(ICC)%DS(JCC) )*CUT_CELL(ICC)%VOLUME(JCC)
            ! Add Pressure derivative to divergence:
            CUT_CELL(ICC)%DDDTVOL(JCC)  = (DPCC-CUT_CELL(ICC)%DVOL_PR(JCC))*RDT
         ENDDO
      ELSE
         DO JCC=1,NCELL
            VOL  = VOL + CUT_CELL(ICC)%VOLUME(JCC)
            CALL GET_VELOC_DIVERGENCE_CUTCELL(ICC,JCC,0._EB,DIV_JCC) ! Velocity divg of U,V,W -> PRFCT=0._EB
            DIVVOL = DIVVOL + DIV_JCC*CUT_CELL(ICC)%VOLUME(JCC)
            ! Thermodynamic divergence * vol:
            DPCC= DPCC + ( (1._EB-PRFCT)*CUT_CELL(ICC)%D(JCC) + PRFCT*CUT_CELL(ICC)%DS(JCC) )*CUT_CELL(ICC)%VOLUME(JCC)
         ENDDO
         ! Define average DDDT for CUT_CELL(ICC):
         CUT_CELL(ICC)%DDDTVOL(1)  = (DPCC-DIVVOL)*RDT
         CUT_CELL(ICC)%DVOL_PR(1)  = DIVVOL
      ENDIF

   ENDDO ICC_LOOP_1

ELSEIF (CORRECTOR) THEN PRED_CORR_IF

   ICC_LOOP_2 : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      I      = CUT_CELL(ICC)%IJK(IAXIS)
      J      = CUT_CELL(ICC)%IJK(JAXIS)
      K      = CUT_CELL(ICC)%IJK(KAXIS)
      IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE ICC_LOOP_2
      IPZ    = PRESSURE_ZONE(I,J,K)
      NCELL  = CUT_CELL(ICC)%NCELL
      DIVVOL = 0._EB; DPCC   = 0._EB; VOL    = 0._EB
      IF (ONE_UNKH_PER_CUTCELL) THEN ! DDDTVOL(JCC) defined per cut-cell.
         DO JCC=1,NCELL
            CALL GET_VELOC_DIVERGENCE_CUTCELL(ICC,JCC,1._EB,DIV_JCC) ! Velocity divg of US,VS,WS -> PRFCT=1._EB
            DPCC= ( (1._EB-PRFCT)*CUT_CELL(ICC)%D(JCC) + PRFCT*CUT_CELL(ICC)%DS(JCC) )*CUT_CELL(ICC)%VOLUME(JCC)
            CUT_CELL(ICC)%DDDTVOL(JCC)  =  &
            (2._EB*DPCC-(DIV_JCC*CUT_CELL(ICC)%VOLUME(JCC)+CUT_CELL(ICC)%DVOL_PR(JCC)))*RDT
         ENDDO
      ELSE
         DO JCC=1,NCELL
            VOL  = VOL + CUT_CELL(ICC)%VOLUME(JCC)
            CALL GET_VELOC_DIVERGENCE_CUTCELL(ICC,JCC,1._EB,DIV_JCC) ! Velocity divg of US,VS,WS -> PRFCT=1._EB
            DIVVOL = DIVVOL + DIV_JCC*CUT_CELL(ICC)%VOLUME(JCC)
            ! Thermodynamic divergence * vol:
            DPCC= DPCC + ( (1._EB-PRFCT)*CUT_CELL(ICC)%D(JCC) + PRFCT*CUT_CELL(ICC)%DS(JCC) )*CUT_CELL(ICC)%VOLUME(JCC)
         ENDDO
         ! Define average DDDT for CUT_CELL(ICC):
         CUT_CELL(ICC)%DDDTVOL(1)  = (2._EB*DPCC-(DIVVOL+CUT_CELL(ICC)%DVOL_PR(1)))*RDT
      ENDIF
   ENDDO ICC_LOOP_2

ENDIF PRED_CORR_IF

RETURN
END SUBROUTINE GET_CUTCELL_DDDT


! ------------------------------ CC_PROJECT_VELOCITY -----------------------------

SUBROUTINE CC_PROJECT_VELOCITY(NM,DT,STORE_FLG)

USE MEMORY_FUNCTIONS, ONLY: ChkMemErr

INTEGER, INTENT(IN) :: NM
REAL(EB), INTENT(IN):: DT
LOGICAL, INTENT(IN) :: STORE_FLG
REAL(EB), SAVE, ALLOCATABLE, DIMENSION(:,:,:) :: U_STORE,V_STORE,W_STORE
! Local Vars:
INTEGER :: I,J,K,ICF,JCF,IZERO,X1AXIS,IFACE,IOR,IW,IRC
REAL(EB):: IDX,T_NOW,H_HI,H_LO,FCTH

T_NOW = CURRENT_TIME()

STORE_IF : IF (STORE_FLG) THEN

   ALLOCATE(U_STORE(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO); CALL ChkMemErr('CCIB','U_STORE',IZERO)
   ALLOCATE(V_STORE(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO); CALL ChkMemErr('CCIB','V_STORE',IZERO)
   ALLOCATE(W_STORE(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO); CALL ChkMemErr('CCIB','W_STORE',IZERO)

   U_STORE = U
   V_STORE = V
   W_STORE = W

ELSE STORE_IF

   PRED_CORR_IF : IF (PREDICTOR) THEN

      ! Update INBOUNDARY faces:
      DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
         CF => CUT_FACE(ICF); IF(CF%STATUS /= CC_INBOUNDARY) CYCLE
         CF%VELS(1:CF%NFACE) = CF%VEL(1:CF%NFACE) - DT*CF%FN(1:CF%NFACE)
      ENDDO

      DO K=1,KBAR
         DO J=1,JBAR
            DO I=0,IBAR
               ICF = FCVAR(I,J,K,CC_IDCF,IAXIS)
               IF (ICF>0) THEN
                  CF => CUT_FACE(ICF); FCTH = 1._EB
                  IF(CF%IWC>0 .AND. &
                     ANY(WALL(CF%IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/))) FCTH=0._EB
                  IF (ONE_UNKH_PER_CUTCELL) THEN
                     DO JCF=1,CF%NFACE
                        IDX  = 1._EB/(CF%XCENHIGH(IAXIS,JCF)-CF%XCENLOW(IAXIS,JCF))
                        H_HI = CUT_CELL(CF%CELL_LIST(2,HIGH_IND,JCF))%H(CF%CELL_LIST(3,HIGH_IND,JCF)) ! H(I+1,J,K)
                        H_LO = CUT_CELL(CF%CELL_LIST(2, LOW_IND,JCF))%H(CF%CELL_LIST(3, LOW_IND,JCF)) ! H(  I,J,K)
                        CF%VELS(JCF) = CF%VEL(JCF) - DT*( CF%FN(JCF) + FCTH*IDX*(H_HI-H_LO) )
                     ENDDO
                  ELSE
                     DO JCF=1,CF%NFACE
                        IDX  = 1._EB/(CF%XCENHIGH(IAXIS,JCF)-CF%XCENLOW(IAXIS,JCF))
                        CF%VELS(JCF) = CF%VEL(JCF) - DT*( CF%FN(JCF) +FCTH*IDX*(H(I+1,J,K)-H(I,J,K)) )
                     ENDDO
                  ENDIF
                  US(I,J,K) = DOT_PRODUCT(CF%VELS(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DY(J)*DZ(K))

               ENDIF
            ENDDO
         ENDDO
      ENDDO

      DO K=1,KBAR
         DO J=0,JBAR
            DO I=1,IBAR
               ICF = FCVAR(I,J,K,CC_IDCF,JAXIS)
               IF (ICF>0) THEN
                  CF => CUT_FACE(ICF); FCTH = 1._EB
                  IF(CF%IWC>0 .AND. &
                     ANY(WALL(CF%IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/))) FCTH=0._EB
                  IF (ONE_UNKH_PER_CUTCELL) THEN
                     DO JCF=1,CF%NFACE
                        IDX  = 1._EB/(CF%XCENHIGH(JAXIS,JCF)-CF%XCENLOW(JAXIS,JCF))
                        H_HI = CUT_CELL(CF%CELL_LIST(2,HIGH_IND,JCF))%H(CF%CELL_LIST(3,HIGH_IND,JCF)) ! H(I,J+1,K)
                        H_LO = CUT_CELL(CF%CELL_LIST(2, LOW_IND,JCF))%H(CF%CELL_LIST(3, LOW_IND,JCF)) ! H(I,  J,K)
                        CF%VELS(JCF) = CF%VEL(JCF) - DT*( CF%FN(JCF) + FCTH*IDX*(H_HI-H_LO) )
                     ENDDO
                  ELSE
                     DO JCF=1,CF%NFACE
                        IDX=1._EB/(CF%XCENHIGH(JAXIS,JCF)-CF%XCENLOW(JAXIS,JCF))
                        CF%VELS(JCF) = CF%VEL(JCF) - DT*( CF%FN(JCF) +FCTH*IDX*(H(I,J+1,K)-H(I,J,K)) )
                     ENDDO
                  ENDIF
                  VS(I,J,K) = DOT_PRODUCT(CF%VELS(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DX(I)*DZ(K))
               ENDIF
            ENDDO
         ENDDO
      ENDDO

      DO K=0,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               ICF = FCVAR(I,J,K,CC_IDCF,KAXIS)
               IF (ICF>0) THEN
                  CF => CUT_FACE(ICF); FCTH = 1._EB
                  IF(CF%IWC>0 .AND. &
                     ANY(WALL(CF%IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/))) FCTH=0._EB
                  IF (ONE_UNKH_PER_CUTCELL) THEN
                     DO JCF=1,CF%NFACE
                        IDX  = 1._EB/(CF%XCENHIGH(KAXIS,JCF)-CF%XCENLOW(KAXIS,JCF))
                        H_HI = CUT_CELL(CF%CELL_LIST(2,HIGH_IND,JCF))%H(CF%CELL_LIST(3,HIGH_IND,JCF)) ! H(I,J,K+1)
                        H_LO = CUT_CELL(CF%CELL_LIST(2, LOW_IND,JCF))%H(CF%CELL_LIST(3, LOW_IND,JCF)) ! H(I,J,K  )
                        CF%VELS(JCF) = CF%VEL(JCF) - DT*( CF%FN(JCF) + FCTH*IDX*(H_HI-H_LO) )
                     ENDDO
                  ELSE
                     DO JCF=1,CF%NFACE
                        IDX=1._EB/(CF%XCENHIGH(KAXIS,JCF)-CF%XCENLOW(KAXIS,JCF))
                        CF%VELS(JCF) = CF%VEL(JCF) -  DT*( CF%FN(JCF)+FCTH*IDX*(H(I,J,K+1)-H(I,J,K)) )
                     ENDDO
                  ENDIF
                  WS(I,J,K) = DOT_PRODUCT(CF%VELS(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DY(J)*DX(I))
               ENDIF
            ENDDO
         ENDDO
      ENDDO

      ! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
      DO IFACE=1,MESHES(NM)%CC_NRCFACE_H
         RCF => RC_FACE(MESHES(NM)%RCF_H(IFACE));
         FCTH = 1._EB; IF(RCF%IWC>0 .AND. &
                        ANY(WALL(RCF%IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/))) FCTH=0._EB
         I   = RCF%IJK(IAXIS); J = RCF%IJK(JAXIS); K = RCF%IJK(KAXIS); X1AXIS = RCF%IJK(KAXIS+1)
         IDX = 1._EB / ( RCF%XCEN(X1AXIS,HIGH_IND) - RCF%XCEN(X1AXIS,LOW_IND) )
         SELECT CASE(X1AXIS)
            CASE(IAXIS)
               US(I,J,K)= U(I,J,K) - DT*( FVX(I,J,K) + FCTH*IDX*(H(I+1,J,K)-H(I,J,K)) )
            CASE(JAXIS)
               VS(I,J,K)= V(I,J,K) - DT*( FVY(I,J,K) + FCTH*IDX*(H(I,J+1,K)-H(I,J,K)) )
            CASE(KAXIS)
               WS(I,J,K)= W(I,J,K) - DT*( FVZ(I,J,K) + FCTH*IDX*(H(I,J,K+1)-H(I,J,K)) )
         END SELECT
      ENDDO

      ! Finally RC faces in OPEN Boundaries:
      WALL_CELL_LOOP_1 : DO IW=1,N_EXTERNAL_WALL_CELLS
         WC => WALL(IW)
         IF(.NOT.(WC%BOUNDARY_TYPE==OPEN_BOUNDARY .OR. & ! Drop if boundary type is not OPEN_BOUNDARY.
                  (PRES_FLAG==ULMAT_FLAG .AND. WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY)) ) CYCLE WALL_CELL_LOOP_1
         BC  => BOUNDARY_COORD(WC%BC_INDEX)
         ! Gasphase cell indexes:
         I = BC%IIG; J = BC%JJG; K = BC%KKG; IOR = BC%IOR
         SELECT CASE (IOR)
         CASE( 1); I = BC%IIG-1
         CASE( 2); J = BC%JJG-1
         CASE( 3); K = BC%KKG-1
         END SELECT
         IRC = FCVAR(I,J,K,CC_IDRC,ABS(IOR)); IF(IRC < 1) CYCLE WALL_CELL_LOOP_1 ! Case of RC face in the boundary.
         IDX = 1._EB/( RC_FACE(IRC)%XCEN(ABS(BC%IOR),HIGH_IND) - RC_FACE(IRC)%XCEN(ABS(BC%IOR),LOW_IND) )
         SELECT CASE (ABS(IOR))
         CASE(1); US(I,J,K)= U(I,J,K) - DT*( FVX(I,J,K) + IDX*(H(I+1,J,K)-H(I,J,K)) )
         CASE(2); VS(I,J,K)= V(I,J,K) - DT*( FVY(I,J,K) + IDX*(H(I,J+1,K)-H(I,J,K)) )
         CASE(3); WS(I,J,K)= W(I,J,K) - DT*( FVZ(I,J,K) + IDX*(H(I,J,K+1)-H(I,J,K)) )
         END SELECT
      ENDDO WALL_CELL_LOOP_1

      WHERE(FCVAR(0:IBAR,1:JBAR,1:KBAR,CC_FGSC,IAXIS)==CC_SOLID) US(0:IBAR,1:JBAR,1:KBAR) = 0._EB
      WHERE(FCVAR(1:IBAR,0:JBAR,1:KBAR,CC_FGSC,JAXIS)==CC_SOLID) VS(1:IBAR,0:JBAR,1:KBAR) = 0._EB
      WHERE(FCVAR(1:IBAR,1:JBAR,0:KBAR,CC_FGSC,KAXIS)==CC_SOLID) WS(1:IBAR,1:JBAR,0:KBAR) = 0._EB

   ELSE PRED_CORR_IF

      ! Update INBOUNDARY faces:
      DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
         CF => CUT_FACE(ICF); IF(CF%STATUS /= CC_INBOUNDARY) CYCLE
         CF%VEL(1:CF%NFACE) = 0.5_EB*( CF%VEL(1:CF%NFACE)+CF%VELS(1:CF%NFACE) - DT*CF%FN(1:CF%NFACE) )
      ENDDO

      DO K=1,KBAR
         DO J=1,JBAR
            DO I=0,IBAR
               ICF = FCVAR(I,J,K,CC_IDCF,IAXIS)
               IF (ICF>0) THEN
                  CF => CUT_FACE(ICF); FCTH = 1._EB
                  IF(CF%IWC>0 .AND. &
                     ANY(WALL(CF%IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/))) FCTH=0._EB
                  IF (ONE_UNKH_PER_CUTCELL) THEN
                     DO JCF=1,CF%NFACE
                        IDX=1._EB/(CF%XCENHIGH(IAXIS,JCF)-CF%XCENLOW(IAXIS,JCF))
                        H_HI = CUT_CELL(CF%CELL_LIST(2,HIGH_IND,JCF))%HS(CF%CELL_LIST(3,HIGH_IND,JCF)) ! HS(I+1,J,K)
                        H_LO = CUT_CELL(CF%CELL_LIST(2, LOW_IND,JCF))%HS(CF%CELL_LIST(3, LOW_IND,JCF)) ! HS(I  ,J,K)
                        CF%VEL(JCF) = 0.5_EB*( CF%VEL(JCF) + CF%VELS(JCF)   - &
                                          DT*( CF%FN( JCF) + FCTH*IDX*(H_HI-H_LO)) )
                     ENDDO
                  ELSE
                     DO JCF=1,CF%NFACE
                        IDX=1._EB/(CF%XCENHIGH(IAXIS,JCF)-CF%XCENLOW(IAXIS,JCF))
                        CF%VEL(JCF) = 0.5_EB*( CF%VEL(JCF) + CF%VELS(JCF)   - &
                                          DT*( CF%FN( JCF) + FCTH*IDX*(HS(I+1,J,K)-HS(I,J,K))) )
                     ENDDO
                  ENDIF
                  U(I,J,K) = DOT_PRODUCT(CF%VEL(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DY(J)*DZ(K))
               ENDIF
            ENDDO
         ENDDO
      ENDDO

      DO K=1,KBAR
         DO J=0,JBAR
            DO I=1,IBAR
               ICF = FCVAR(I,J,K,CC_IDCF,JAXIS)
               IF (ICF>0) THEN
                  CF => CUT_FACE(ICF); FCTH = 1._EB
                  IF(CF%IWC>0 .AND. &
                     ANY(WALL(CF%IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/))) FCTH=0._EB
                  IF (ONE_UNKH_PER_CUTCELL) THEN
                     DO JCF=1,CF%NFACE
                        IDX=1._EB/(CF%XCENHIGH(JAXIS,JCF)-CF%XCENLOW(JAXIS,JCF))
                        H_HI = CUT_CELL(CF%CELL_LIST(2,HIGH_IND,JCF))%HS(CF%CELL_LIST(3,HIGH_IND,JCF)) ! HS(I,J+1,K)
                        H_LO = CUT_CELL(CF%CELL_LIST(2, LOW_IND,JCF))%HS(CF%CELL_LIST(3, LOW_IND,JCF)) ! HS(I,J  ,K)
                        CF%VEL(JCF) = 0.5_EB*( CF%VEL(JCF) + CF%VELS(JCF)   - &
                                          DT*( CF%FN( JCF) + FCTH*IDX*(H_HI-H_LO)) )
                     ENDDO
                  ELSE
                     DO JCF=1,CF%NFACE
                        IDX=1._EB/(CF%XCENHIGH(JAXIS,JCF)-CF%XCENLOW(JAXIS,JCF))
                        CF%VEL(JCF) = 0.5_EB*( CF%VEL(JCF) + CF%VELS(JCF)   - &
                                          DT*( CF%FN( JCF) + FCTH*IDX*(HS(I,J+1,K)-HS(I,J,K))) )
                     ENDDO
                  ENDIF
                  V(I,J,K) = DOT_PRODUCT(CF%VEL(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DX(I)*DZ(K))
               ENDIF
            ENDDO
         ENDDO
      ENDDO

      DO K=0,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               ICF = FCVAR(I,J,K,CC_IDCF,KAXIS)
               IF (ICF>0) THEN
                  CF => CUT_FACE(ICF); FCTH = 1._EB
                  IF(CF%IWC>0 .AND. &
                     ANY(WALL(CF%IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/))) FCTH=0._EB
                  IF (ONE_UNKH_PER_CUTCELL) THEN
                     DO JCF=1,CF%NFACE
                        IDX=1._EB/(CF%XCENHIGH(KAXIS,JCF)-CF%XCENLOW(KAXIS,JCF))
                        H_HI = CUT_CELL(CF%CELL_LIST(2,HIGH_IND,JCF))%HS(CF%CELL_LIST(3,HIGH_IND,JCF)) ! HS(I,J,K+1)
                        H_LO = CUT_CELL(CF%CELL_LIST(2, LOW_IND,JCF))%HS(CF%CELL_LIST(3, LOW_IND,JCF)) ! HS(I,J,K  )
                        CF%VEL(JCF) = 0.5_EB*( CF%VEL(JCF) + CF%VELS(JCF)   - &
                                          DT*( CF%FN( JCF) + FCTH*IDX*(H_HI-H_LO)) )
                     ENDDO
                  ELSE
                     DO JCF=1,CF%NFACE
                        IDX=1._EB/(CF%XCENHIGH(KAXIS,JCF)-CF%XCENLOW(KAXIS,JCF))
                        CF%VEL(JCF) = 0.5_EB*( CF%VEL(JCF) + CF%VELS(JCF)   - &
                                          DT*( CF%FN( JCF) + FCTH*IDX*(HS(I,J,K+1)-HS(I,J,K))) )
                     ENDDO
                  ENDIF
                  W(I,J,K) = DOT_PRODUCT(CF%VEL(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DY(J)*DX(I))
               ENDIF
            ENDDO
         ENDDO
      ENDDO

      ! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
      DO IFACE=1,MESHES(NM)%CC_NRCFACE_H
         RCF => RC_FACE(MESHES(NM)%RCF_H(IFACE));
         FCTH = 1._EB; IF(RCF%IWC>0 .AND. &
                        ANY(WALL(RCF%IWC)%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/))) FCTH=0._EB
         I   = RCF%IJK(IAXIS); J = RCF%IJK(JAXIS); K = RCF%IJK(KAXIS); X1AXIS = RCF%IJK(KAXIS+1)
         IDX = 1._EB/( RCF%XCEN(X1AXIS,HIGH_IND) - RCF%XCEN(X1AXIS,LOW_IND) )
         SELECT CASE(X1AXIS)
            CASE(IAXIS)
               U(I,J,K)= 0.5_EB*( U_STORE(I,J,K) + US(I,J,K) - &
                                    DT*(FVX(I,J,K) + FCTH*IDX*(HS(I+1,J,K)-HS(I,J,K))) )
            CASE(JAXIS)
               V(I,J,K)= 0.5_EB*( V_STORE(I,J,K) + VS(I,J,K) - &
                                    DT*(FVY(I,J,K) + FCTH*IDX*(HS(I,J+1,K)-HS(I,J,K))) )
            CASE(KAXIS)
               W(I,J,K)= 0.5_EB*( W_STORE(I,J,K) + WS(I,J,K) - &
                                    DT*(FVZ(I,J,K) + FCTH*IDX*(HS(I,J,K+1)-HS(I,J,K))) )
         END SELECT
      ENDDO

      WALL_CELL_LOOP_2 : DO IW=1,N_EXTERNAL_WALL_CELLS
         WC => WALL(IW)
         IF(.NOT.(WC%BOUNDARY_TYPE==OPEN_BOUNDARY .OR. & ! Drop if boundary type is not OPEN_BOUNDARY.
                  (PRES_FLAG==ULMAT_FLAG .AND. WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY)) ) CYCLE WALL_CELL_LOOP_2
         BC  => BOUNDARY_COORD(WC%BC_INDEX)
         ! Gasphase cell indexes:
         I = BC%IIG; J = BC%JJG; K = BC%KKG; IOR = BC%IOR
         SELECT CASE (IOR)
         CASE( 1); I = BC%IIG-1
         CASE( 2); J = BC%JJG-1
         CASE( 3); K = BC%KKG-1
         END SELECT
         IRC = FCVAR(I,J,K,CC_IDRC,ABS(IOR)); IF(IRC < 1) CYCLE WALL_CELL_LOOP_2 ! Case of RC face in the boundary.
         IDX = 1._EB/( RC_FACE(IRC)%XCEN(ABS(BC%IOR),HIGH_IND) - RC_FACE(IRC)%XCEN(ABS(BC%IOR),LOW_IND) )
         SELECT CASE (ABS(IOR))
         CASE(1); U(I,J,K)= 0.5_EB*( U_STORE(I,J,K) + US(I,J,K) - DT*(FVX(I,J,K) + IDX*(HS(I+1,J,K)-HS(I,J,K))) )
         CASE(2); V(I,J,K)= 0.5_EB*( V_STORE(I,J,K) + VS(I,J,K) - DT*(FVY(I,J,K) + IDX*(HS(I,J+1,K)-HS(I,J,K))) )
         CASE(3); W(I,J,K)= 0.5_EB*( W_STORE(I,J,K) + WS(I,J,K) - DT*(FVZ(I,J,K) + IDX*(HS(I,J,K+1)-HS(I,J,K))) )
         END SELECT
      ENDDO WALL_CELL_LOOP_2

      DEALLOCATE(U_STORE,V_STORE,W_STORE)

      WHERE(FCVAR(0:IBAR,1:JBAR,1:KBAR,CC_FGSC,IAXIS)==CC_SOLID) U(0:IBAR,1:JBAR,1:KBAR) = 0._EB
      WHERE(FCVAR(1:IBAR,0:JBAR,1:KBAR,CC_FGSC,JAXIS)==CC_SOLID) V(1:IBAR,0:JBAR,1:KBAR) = 0._EB
      WHERE(FCVAR(1:IBAR,1:JBAR,0:KBAR,CC_FGSC,KAXIS)==CC_SOLID) W(1:IBAR,1:JBAR,0:KBAR) = 0._EB

   ENDIF PRED_CORR_IF

ENDIF STORE_IF

T_USED(14) = T_USED(14) + CURRENT_TIME() - T_NOW

RETURN
END SUBROUTINE CC_PROJECT_VELOCITY

! ------------------------------------ GET_LINKED_VELOCITIES ---------------------------------------

SUBROUTINE GET_LINKED_VELOCITIES(NM,APPLY_TO_ESTIMATED_VARIABLES,CMP_FLG)

! Assumes POINT_TO_MESH(NM) has been called:

INTEGER, INTENT(IN) :: NM
LOGICAL, INTENT(IN) :: APPLY_TO_ESTIMATED_VARIABLES, CMP_FLG

INTEGER :: I, J, K, ICF, JCF, X1AXIS, IW, IOR, IIO, JJO, KKO, ICFO, NOM
REAL(EB):: T_NOW
REAL(EB), ALLOCATABLE, DIMENSION(:) :: AREA_LNK
TYPE (OMESH_TYPE), POINTER :: OM
TYPE (MESH_TYPE), POINTER :: M2
TYPE (CC_CUTFACE_TYPE), POINTER :: CFO

T_NOW = CURRENT_TIME()

! Compute linked velocity and populate UN_LNK for MESH(NM):
CMP_FLG_IF : IF (CMP_FLG) THEN
   ! Set linked velocity array to zero:
   UN_LNK = 0._EB
   ALLOCATE(AREA_LNK(0:MESHES(NM)%NUNK_F)); AREA_LNK = 0._EB
   PRED_1 : IF (APPLY_TO_ESTIMATED_VARIABLES) THEN
      ! Regular faces:
      DO K=0,KBAR
         DO J=0,JBAR
            DO I=0,IBAR
               IF (FCVAR(I,J,K,CC_UNKF,IAXIS)>0) THEN ! X face
                  UN_LNK(FCVAR(I,J,K,CC_UNKF,IAXIS)) = UN_LNK(FCVAR(I,J,K,CC_UNKF,IAXIS)) + US(I,J,K)*DY(J)*DZ(K)
                  AREA_LNK(FCVAR(I,J,K,CC_UNKF,IAXIS)) = AREA_LNK(FCVAR(I,J,K,CC_UNKF,IAXIS)) + DY(J)*DZ(K)
               ENDIF
               IF (FCVAR(I,J,K,CC_UNKF,JAXIS)>0) THEN ! Y face
                  UN_LNK(FCVAR(I,J,K,CC_UNKF,JAXIS)) = UN_LNK(FCVAR(I,J,K,CC_UNKF,JAXIS)) + VS(I,J,K)*DX(I)*DZ(K)
                  AREA_LNK(FCVAR(I,J,K,CC_UNKF,JAXIS)) = AREA_LNK(FCVAR(I,J,K,CC_UNKF,JAXIS)) + DX(I)*DZ(K)
               ENDIF
               IF (FCVAR(I,J,K,CC_UNKF,KAXIS)>0) THEN ! Z face
                  UN_LNK(FCVAR(I,J,K,CC_UNKF,KAXIS)) = UN_LNK(FCVAR(I,J,K,CC_UNKF,KAXIS)) + WS(I,J,K)*DX(I)*DY(J)
                  AREA_LNK(FCVAR(I,J,K,CC_UNKF,KAXIS)) = AREA_LNK(FCVAR(I,J,K,CC_UNKF,KAXIS)) + DX(I)*DY(J)
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      ! RC faces:
      DO ICF=1,MESHES(NM)%CC_NRCFACE_Z
         IF(RC_FACE(ICF)%UNKF<1) CYCLE
         I = RC_FACE(ICF)%IJK(IAXIS); J = RC_FACE(ICF)%IJK(JAXIS); K = RC_FACE(ICF)%IJK(KAXIS)
         X1AXIS = RC_FACE(ICF)%IJK(KAXIS+1)
         SELECT CASE(X1AXIS)
         CASE(IAXIS)
            UN_LNK(RC_FACE(ICF)%UNKF) = UN_LNK(RC_FACE(ICF)%UNKF) + US(I,J,K)*DY(J)*DZ(K)
            AREA_LNK(RC_FACE(ICF)%UNKF) = AREA_LNK(RC_FACE(ICF)%UNKF) + DY(J)*DZ(K)
         CASE(JAXIS)
            UN_LNK(RC_FACE(ICF)%UNKF) = UN_LNK(RC_FACE(ICF)%UNKF) + VS(I,J,K)*DX(I)*DZ(K)
            AREA_LNK(RC_FACE(ICF)%UNKF) = AREA_LNK(RC_FACE(ICF)%UNKF) + DX(I)*DZ(K)
         CASE(KAXIS)
            UN_LNK(RC_FACE(ICF)%UNKF) = UN_LNK(RC_FACE(ICF)%UNKF) + WS(I,J,K)*DX(I)*DY(J)
            AREA_LNK(RC_FACE(ICF)%UNKF) = AREA_LNK(RC_FACE(ICF)%UNKF) + DX(I)*DY(J)
         END SELECT
      ENDDO
      ! Cut-faces:
      DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
         CF => CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE
         IF(TWO_D .AND. CF%IJK(KAXIS+1)==JAXIS) CYCLE
         DO JCF=1,CF%NFACE
            UN_LNK(CF%UNKF(JCF)) = UN_LNK(CF%UNKF(JCF)) + CF%VELS(JCF)*CF%AREA(JCF)
            AREA_LNK(CF%UNKF(JCF)) = AREA_LNK(CF%UNKF(JCF)) + CF%AREA(JCF)
         ENDDO
      ENDDO

   ELSE PRED_1

      ! Regular faces:
      DO K=0,KBAR
         DO J=0,JBAR
            DO I=0,IBAR
               IF (FCVAR(I,J,K,CC_UNKF,IAXIS)>0) THEN
                  UN_LNK(FCVAR(I,J,K,CC_UNKF,IAXIS)) = UN_LNK(FCVAR(I,J,K,CC_UNKF,IAXIS)) + U(I,J,K)*DY(J)*DZ(K)
                  AREA_LNK(FCVAR(I,J,K,CC_UNKF,IAXIS)) = AREA_LNK(FCVAR(I,J,K,CC_UNKF,IAXIS)) + DY(J)*DZ(K)
               ENDIF
               IF (FCVAR(I,J,K,CC_UNKF,JAXIS)>0) THEN
                  UN_LNK(FCVAR(I,J,K,CC_UNKF,JAXIS)) = UN_LNK(FCVAR(I,J,K,CC_UNKF,JAXIS)) + V(I,J,K)*DX(I)*DZ(K)
                  AREA_LNK(FCVAR(I,J,K,CC_UNKF,JAXIS)) = AREA_LNK(FCVAR(I,J,K,CC_UNKF,JAXIS)) + DX(I)*DZ(K)
               ENDIF
               IF (FCVAR(I,J,K,CC_UNKF,KAXIS)>0) THEN
                  UN_LNK(FCVAR(I,J,K,CC_UNKF,KAXIS)) = UN_LNK(FCVAR(I,J,K,CC_UNKF,KAXIS)) + W(I,J,K)*DX(I)*DY(J)
                  AREA_LNK(FCVAR(I,J,K,CC_UNKF,KAXIS)) = AREA_LNK(FCVAR(I,J,K,CC_UNKF,KAXIS)) + DX(I)*DY(J)
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      ! RC faces:
      DO ICF=1,MESHES(NM)%CC_NRCFACE_Z
         IF(RC_FACE(ICF)%UNKF<1) CYCLE
         I = RC_FACE(ICF)%IJK(IAXIS); J = RC_FACE(ICF)%IJK(JAXIS); K = RC_FACE(ICF)%IJK(KAXIS)
         X1AXIS = RC_FACE(ICF)%IJK(KAXIS+1)
         SELECT CASE(X1AXIS)
         CASE(IAXIS)
            UN_LNK(RC_FACE(ICF)%UNKF) = UN_LNK(RC_FACE(ICF)%UNKF) + U(I,J,K)*DY(J)*DZ(K)
            AREA_LNK(RC_FACE(ICF)%UNKF) = AREA_LNK(RC_FACE(ICF)%UNKF) + DY(J)*DZ(K)
         CASE(JAXIS)
            UN_LNK(RC_FACE(ICF)%UNKF) = UN_LNK(RC_FACE(ICF)%UNKF) + V(I,J,K)*DX(I)*DZ(K)
            AREA_LNK(RC_FACE(ICF)%UNKF) = AREA_LNK(RC_FACE(ICF)%UNKF) + DX(I)*DZ(K)
         CASE(KAXIS)
            UN_LNK(RC_FACE(ICF)%UNKF) = UN_LNK(RC_FACE(ICF)%UNKF) + W(I,J,K)*DX(I)*DY(J)
            AREA_LNK(RC_FACE(ICF)%UNKF) = AREA_LNK(RC_FACE(ICF)%UNKF) + DX(I)*DY(J)
         END SELECT
      ENDDO
      ! Cut-faces:
      DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
         CF => CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE
         IF(TWO_D .AND. CF%IJK(KAXIS+1)==JAXIS) CYCLE
         DO JCF=1,CF%NFACE
            UN_LNK(CF%UNKF(JCF)) = UN_LNK(CF%UNKF(JCF)) + CF%VEL(JCF)*CF%AREA(JCF)
            AREA_LNK(CF%UNKF(JCF)) = AREA_LNK(CF%UNKF(JCF)) + CF%AREA(JCF)
         ENDDO
      ENDDO

   ENDIF PRED_1

   ! Area Average F:
   UN_LNK(1:MESHES(NM)%NUNK_F) = UN_LNK(1:MESHES(NM)%NUNK_F) / AREA_LNK(1:MESHES(NM)%NUNK_F)

   ! Dump in EWC_UN_LNK(IW) and CF%VEL_LNK(JCF) of external boundary regular and cut-faces of type
   ! interpolated boundary:
   EXTERNAL_WALL_LOOP: DO IW=1,MESHES(NM)%N_EXTERNAL_WALL_CELLS
      WC=>WALL(IW)
      IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE EXTERNAL_WALL_LOOP
      EWC=>EXTERNAL_WALL(IW)
      BC =>BOUNDARY_COORD(WC%BC_INDEX)
      I  = BC%II; J = BC%JJ; K = BC%KK
      IOR= BC%IOR; X1AXIS = ABS(IOR)
      SELECT CASE(IOR)
      CASE(-IAXIS); I=I-1
      CASE(-JAXIS); J=J-1
      CASE(-KAXIS); K=K-1
      END SELECT

      ! Default reg faces, unlinked.
      IF(APPLY_TO_ESTIMATED_VARIABLES) THEN
         SELECT CASE(X1AXIS)
         CASE(IAXIS); EWC_UN_LNK(IW) = US(I,J,K)
         CASE(JAXIS); EWC_UN_LNK(IW) = VS(I,J,K)
         CASE(KAXIS); EWC_UN_LNK(IW) = WS(I,J,K)
         END SELECT
      ELSE
         SELECT CASE(X1AXIS)
         CASE(IAXIS); EWC_UN_LNK(IW) = U(I,J,K)
         CASE(JAXIS); EWC_UN_LNK(IW) = V(I,J,K)
         CASE(KAXIS); EWC_UN_LNK(IW) = W(I,J,K)
         END SELECT
      ENDIF
      IF (FCVAR(I,J,K,CC_UNKF,X1AXIS)>0) THEN ! Regular Face, linked.
         EWC_UN_LNK(IW) = UN_LNK(FCVAR(I,J,K,CC_UNKF,X1AXIS))
      ELSEIF(FCVAR(I,J,K,CC_IDRC,X1AXIS)>0) THEN ! RC Face.
         ICF=FCVAR(I,J,K,CC_IDRC,X1AXIS); IF(RC_FACE(ICF)%UNKF<1) CYCLE EXTERNAL_WALL_LOOP
         EWC_UN_LNK(IW) = UN_LNK(RC_FACE(ICF)%UNKF)
      ELSEIF(FCVAR(I,J,K,CC_IDCF,X1AXIS)>0) THEN ! Cut-face.
         ICF=FCVAR(I,J,K,CC_IDCF,X1AXIS)
         CF=>CUT_FACE(ICF)
         DO JCF=1,CF%NFACE
            IF (CF%UNKF(JCF)>0) THEN
               CF%VEL_LNK(JCF) = UN_LNK(CF%UNKF(JCF))
            ELSEIF(APPLY_TO_ESTIMATED_VARIABLES) THEN
               CF%VEL_LNK(JCF) = CF%VELS(JCF)
            ELSE
               CF%VEL_LNK(JCF) = CF%VEL(JCF)
            ENDIF
         ENDDO
      ENDIF
   ENDDO EXTERNAL_WALL_LOOP

   DEALLOCATE(AREA_LNK)

ELSE CMP_FLG_IF


   ! Restore Linked Velocity values:
   PRED_2 : IF (APPLY_TO_ESTIMATED_VARIABLES) THEN

      DO K=0,KBAR
         DO J=0,JBAR
            DO I=0,IBAR
               IF (FCVAR(I,J,K,CC_UNKF,IAXIS)>0)                  US(I,J,K) = UN_LNK(FCVAR(I,J,K,CC_UNKF,IAXIS))
               IF (FCVAR(I,J,K,CC_UNKF,JAXIS)>0 .AND. .NOT.TWO_D) VS(I,J,K) = UN_LNK(FCVAR(I,J,K,CC_UNKF,JAXIS))
               IF (FCVAR(I,J,K,CC_UNKF,KAXIS)>0)                  WS(I,J,K) = UN_LNK(FCVAR(I,J,K,CC_UNKF,KAXIS))
            ENDDO
         ENDDO
      ENDDO
      DO ICF=1,MESHES(NM)%CC_NRCFACE_Z
         IF(RC_FACE(ICF)%UNKF<1) CYCLE
         I = RC_FACE(ICF)%IJK(IAXIS); J = RC_FACE(ICF)%IJK(JAXIS); K = RC_FACE(ICF)%IJK(KAXIS)
         X1AXIS = RC_FACE(ICF)%IJK(KAXIS+1)
         SELECT CASE(X1AXIS)
         CASE(IAXIS); US(I,J,K) = UN_LNK(RC_FACE(ICF)%UNKF)
         CASE(JAXIS); IF(.NOT.TWO_D) VS(I,J,K) = UN_LNK(RC_FACE(ICF)%UNKF)
         CASE(KAXIS); WS(I,J,K) = UN_LNK(RC_FACE(ICF)%UNKF)
         END SELECT
      ENDDO
      DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
         CF => CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE
         IF(TWO_D .AND. CF%IJK(KAXIS+1)==JAXIS) CYCLE
         I = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
         DO JCF=1,CF%NFACE
            IF (CF%UNKF(JCF)<1) CYCLE
            CF%VELS(JCF) = UN_LNK(CF%UNKF(JCF))
         ENDDO
         SELECT CASE(X1AXIS)
         CASE(IAXIS); US(I,J,K) = DOT_PRODUCT(CF%VELS(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DY(J)*DZ(K))
         CASE(JAXIS); VS(I,J,K) = DOT_PRODUCT(CF%VELS(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DX(I)*DZ(K))
         CASE(KAXIS); WS(I,J,K) = DOT_PRODUCT(CF%VELS(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DY(J)*DX(I))
         END SELECT
      ENDDO
      ! Dump flux matched EWC_UN_LNK(IW) and CF%VEL_LNK(JCF) of external boundary regular and cut-faces into
      ! corresponding US,VS,WS,CF%VELS:
      EXTERNAL_WALL_LOOP_2: DO IW=1,MESHES(NM)%N_EXTERNAL_WALL_CELLS
         WC=>WALL(IW)
         IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE EXTERNAL_WALL_LOOP_2
         EWC=>EXTERNAL_WALL(IW)
         BC =>BOUNDARY_COORD(WC%BC_INDEX)
         I  = BC%II; J = BC%JJ; K = BC%KK
         IOR= BC%IOR; X1AXIS = ABS(IOR)
         NOM = EWC%NOM
         OM  => OMESH(NOM)
         M2  => MESHES(NOM)
         SELECT CASE(IOR)
         CASE(-IAXIS); I=I-1
         CASE(-JAXIS); J=J-1
         CASE(-KAXIS); K=K-1
         END SELECT
         IF(FCVAR(I,J,K,CC_IDCF,X1AXIS)>0) THEN ! Cut-face.
            ICF=FCVAR(I,J,K,CC_IDCF,X1AXIS); CF=>CUT_FACE(ICF)
            DO JCF=1,CF%NFACE
               CF%VELS(JCF) = CF%VEL_LNK(JCF)
            ENDDO
            SELECT CASE(X1AXIS)
            CASE(IAXIS); US(I,J,K) = DOT_PRODUCT(CF%VELS(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DY(J)*DZ(K))
            CASE(JAXIS); VS(I,J,K) = DOT_PRODUCT(CF%VELS(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DX(I)*DZ(K))
            CASE(KAXIS); WS(I,J,K) = DOT_PRODUCT(CF%VELS(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DY(J)*DX(I))
            END SELECT
         ELSE ! All other reg faces, unlinked, yet can be matched to linked velocities in OMESH.
            SELECT CASE(X1AXIS)
            CASE(IAXIS); US(I,J,K) = EWC_UN_LNK(IW)
            CASE(JAXIS); VS(I,J,K) = EWC_UN_LNK(IW)
            CASE(KAXIS); WS(I,J,K) = EWC_UN_LNK(IW)
            END SELECT
         ENDIF

         ! Dump Matched OM%U_LNK,V_LNK,W_LNK into OM%US, VS, WS, for use in COMPUTE_VELOCITY_ERROR.
         ! Dump Matched CFO%VEL_LNK_OMESH(JCFO) into CFO%VELS_OMESH(JCFO) for use in COMPUTE_VELOCITY_ERROR.
         SELECT CASE(IOR)
         CASE( 1)
            DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
               DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                  DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                     IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE ! Drop if OMESH cell is solid.
                     IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE  ! Drop if solid cart face.
                     ICFO = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,ABS(IOR))
                     IF(ICFO>0) THEN
                        CFO => M2%CUT_FACE(ICFO)
                        CFO%VELS_OMESH(1:CFO%NFACE) = CFO%VEL_LNK_OMESH(1:CFO%NFACE)
                     ELSE
                        OM%US(IIO,JJO,KKO) = OM%U_LNK(IIO,JJO,KKO)
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         CASE(-1)
            DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
               DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                  DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                     IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                     IF (M2%FCVAR(IIO-1,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE
                     ICFO = M2%FCVAR(IIO-1,JJO,KKO,CC_IDCF,ABS(IOR))
                     IF(ICFO>0) THEN
                        CFO => M2%CUT_FACE(ICFO)
                        CFO%VELS_OMESH(1:CFO%NFACE) = CFO%VEL_LNK_OMESH(1:CFO%NFACE)
                     ELSE
                        OM%US(IIO-1,JJO,KKO) = OM%U_LNK(IIO-1,JJO,KKO)
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         CASE( 2)
            DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
               DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                  DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                     IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                     IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE
                     ICFO = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,ABS(IOR))
                     IF(ICFO>0) THEN
                        CFO => M2%CUT_FACE(ICFO)
                        CFO%VELS_OMESH(1:CFO%NFACE) = CFO%VEL_LNK_OMESH(1:CFO%NFACE)
                     ELSE
                        OM%VS(IIO,JJO,KKO) = OM%V_LNK(IIO,JJO,KKO)
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         CASE(-2)
            DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
               DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                  DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                     IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                     IF (M2%FCVAR(IIO,JJO-1,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE
                     ICFO = M2%FCVAR(IIO,JJO-1,KKO,CC_IDCF,ABS(IOR))
                     IF(ICFO>0) THEN
                        CFO => M2%CUT_FACE(ICFO)
                        CFO%VELS_OMESH(1:CFO%NFACE) = CFO%VEL_LNK_OMESH(1:CFO%NFACE)
                     ELSE
                        OM%VS(IIO,JJO-1,KKO) = OM%V_LNK(IIO,JJO-1,KKO)
                     ENDIF
                ENDDO
             ENDDO
          ENDDO
         CASE( 3)
            DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
               DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                  DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                     IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                     IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE
                     ICFO = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,ABS(IOR))
                     IF(ICFO>0) THEN
                        CFO => M2%CUT_FACE(ICFO)
                        CFO%VELS_OMESH(1:CFO%NFACE) = CFO%VEL_LNK_OMESH(1:CFO%NFACE)
                     ELSE
                        OM%WS(IIO,JJO,KKO) = OM%W_LNK(IIO,JJO,KKO)
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         CASE(-3)
            DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
               DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                  DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                     IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                     IF (M2%FCVAR(IIO,JJO,KKO-1,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE
                     ICFO = M2%FCVAR(IIO,JJO,KKO-1,CC_IDCF,ABS(IOR))
                     IF(ICFO>0) THEN
                        CFO => M2%CUT_FACE(ICFO)
                        CFO%VELS_OMESH(1:CFO%NFACE) = CFO%VEL_LNK_OMESH(1:CFO%NFACE)
                     ELSE
                        OM%WS(IIO,JJO,KKO-1) = OM%W_LNK(IIO,JJO,KKO-1)
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         END SELECT
      ENDDO EXTERNAL_WALL_LOOP_2

   ELSE PRED_2

      ! Save original U,V,W and CF%VEL to restore in Predictor call to CC_RESTORE_UVW_UNLINKED(NM):
      IF (FIRST_PASS) CALL CC_RESTORE_UVW_UNLINKED(NM,ASSIGN_UNLINKED_VEL=.FALSE.)

      ! Assign linked velocities to U,V,W:
      DO K=0,KBAR
         DO J=0,JBAR
            DO I=0,IBAR
               IF (FCVAR(I,J,K,CC_UNKF,IAXIS)>0)                  U(I,J,K) = UN_LNK(FCVAR(I,J,K,CC_UNKF,IAXIS))
               IF (FCVAR(I,J,K,CC_UNKF,JAXIS)>0 .AND. .NOT.TWO_D) V(I,J,K) = UN_LNK(FCVAR(I,J,K,CC_UNKF,JAXIS))
               IF (FCVAR(I,J,K,CC_UNKF,KAXIS)>0)                  W(I,J,K) = UN_LNK(FCVAR(I,J,K,CC_UNKF,KAXIS))
            ENDDO
         ENDDO
      ENDDO
      DO ICF=1,MESHES(NM)%CC_NRCFACE_Z
         IF(RC_FACE(ICF)%UNKF<1) CYCLE
         I = RC_FACE(ICF)%IJK(IAXIS); J = RC_FACE(ICF)%IJK(JAXIS); K = RC_FACE(ICF)%IJK(KAXIS)
         X1AXIS = RC_FACE(ICF)%IJK(KAXIS+1)
         SELECT CASE(X1AXIS)
         CASE(IAXIS); U(I,J,K) = UN_LNK(RC_FACE(ICF)%UNKF)
         CASE(JAXIS); IF(.NOT.TWO_D) V(I,J,K) = UN_LNK(RC_FACE(ICF)%UNKF)
         CASE(KAXIS); W(I,J,K) = UN_LNK(RC_FACE(ICF)%UNKF)
         END SELECT
      ENDDO
      DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
         CF => CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE
         IF(TWO_D .AND. CF%IJK(KAXIS+1)==JAXIS) CYCLE
         I = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
         DO JCF=1,CF%NFACE;
            IF (CF%UNKF(JCF)<1) CYCLE
            CF%VEL(JCF) = UN_LNK(CF%UNKF(JCF))
         ENDDO
         SELECT CASE(X1AXIS)
         CASE(IAXIS); U(I,J,K) = DOT_PRODUCT(CF%VEL(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DY(J)*DZ(K))
         CASE(JAXIS); V(I,J,K) = DOT_PRODUCT(CF%VEL(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DX(I)*DZ(K))
         CASE(KAXIS); W(I,J,K) = DOT_PRODUCT(CF%VEL(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DY(J)*DX(I))
         END SELECT
      ENDDO
      ! Dump flux matched EWC_UN_LNK(IW) and CF%VEL_LNK(JCF) of external boundary regular and cut-faces into
      ! corresponding U,V,W,CF%VEL:
      EXTERNAL_WALL_LOOP_3: DO IW=1,MESHES(NM)%N_EXTERNAL_WALL_CELLS
         WC=>WALL(IW)
         IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE EXTERNAL_WALL_LOOP_3
         EWC =>EXTERNAL_WALL(IW)
         BC  =>BOUNDARY_COORD(WC%BC_INDEX)
         I   = BC%II; J = BC%JJ; K = BC%KK
         IOR = BC%IOR; X1AXIS = ABS(IOR)
         NOM = EWC%NOM
         OM  => OMESH(NOM)
         M2  => MESHES(NOM)
         SELECT CASE(IOR)
         CASE(-IAXIS); I=I-1
         CASE(-JAXIS); J=J-1
         CASE(-KAXIS); K=K-1
         END SELECT
         IF(FCVAR(I,J,K,CC_IDCF,X1AXIS)>0) THEN ! Cut-face.
            ICF=FCVAR(I,J,K,CC_IDCF,X1AXIS); CF=>CUT_FACE(ICF)
            DO JCF=1,CF%NFACE
               CF%VEL(JCF) = CF%VEL_LNK(JCF)
            ENDDO
            SELECT CASE(X1AXIS)
            CASE(IAXIS); U(I,J,K) = DOT_PRODUCT(CF%VEL(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DY(J)*DZ(K))
            CASE(JAXIS); V(I,J,K) = DOT_PRODUCT(CF%VEL(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DX(I)*DZ(K))
            CASE(KAXIS); W(I,J,K) = DOT_PRODUCT(CF%VEL(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DY(J)*DX(I))
            END SELECT
         ELSE ! All other reg faces, unlinked, yet can be matched to linked velocities in OMESH.
            SELECT CASE(X1AXIS)
            CASE(IAXIS); U(I,J,K) = EWC_UN_LNK(IW)
            CASE(JAXIS); V(I,J,K) = EWC_UN_LNK(IW)
            CASE(KAXIS); W(I,J,K) = EWC_UN_LNK(IW)
            END SELECT
         ENDIF

         ! Dump Matched OM%U_LNK,V_LNK,W_LNK into OM%U, V, W, for use in COMPUTE_VELOCITY_ERROR.
         ! Dump Matched CFO%VEL_LNK_OMESH(JCFO) into CFO%VEL_OMESH(JCFO) for use in COMPUTE_VELOCITY_ERROR.
         IF(FIRST_PASS) THEN
            SELECT CASE(IOR)
            CASE( 1)
               DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
                  DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                     DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                        IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE ! Drop if OMESH cell is solid.
                        IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE  ! Drop if solid cart face.
                        ICFO = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,ABS(IOR))
                        IF(ICFO>0) THEN
                           CFO => M2%CUT_FACE(ICFO)
                           CFO%VEL_OMESH(1:CFO%NFACE) = CFO%VEL_LNK_OMESH(1:CFO%NFACE)
                        ELSE
                           OM%U(IIO,JJO,KKO) = OM%U_LNK(IIO,JJO,KKO)
                        ENDIF
                     ENDDO
                  ENDDO
               ENDDO
            CASE(-1)
               DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
                  DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                     DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                        IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                        IF (M2%FCVAR(IIO-1,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE
                        ICFO = M2%FCVAR(IIO-1,JJO,KKO,CC_IDCF,ABS(IOR))
                        IF(ICFO>0) THEN
                           CFO => M2%CUT_FACE(ICFO)
                           CFO%VEL_OMESH(1:CFO%NFACE) = CFO%VEL_LNK_OMESH(1:CFO%NFACE)
                        ELSE
                           OM%U(IIO-1,JJO,KKO) = OM%U_LNK(IIO-1,JJO,KKO)
                        ENDIF
                     ENDDO
                  ENDDO
               ENDDO
            CASE( 2)
               DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
                  DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                     DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                        IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                        IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE
                        ICFO = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,ABS(IOR))
                        IF(ICFO>0) THEN
                           CFO => M2%CUT_FACE(ICFO)
                           CFO%VEL_OMESH(1:CFO%NFACE) = CFO%VEL_LNK_OMESH(1:CFO%NFACE)
                        ELSE
                           OM%V(IIO,JJO,KKO) = OM%V_LNK(IIO,JJO,KKO)
                        ENDIF
                     ENDDO
                  ENDDO
               ENDDO
            CASE(-2)
               DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
                  DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                     DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                        IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                        IF (M2%FCVAR(IIO,JJO-1,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE
                        ICFO = M2%FCVAR(IIO,JJO-1,KKO,CC_IDCF,ABS(IOR))
                        IF(ICFO>0) THEN
                           CFO => M2%CUT_FACE(ICFO)
                           CFO%VEL_OMESH(1:CFO%NFACE) = CFO%VEL_LNK_OMESH(1:CFO%NFACE)
                        ELSE
                           OM%V(IIO,JJO-1,KKO) = OM%V_LNK(IIO,JJO-1,KKO)
                        ENDIF
                   ENDDO
                ENDDO
             ENDDO
            CASE( 3)
               DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
                  DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                     DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                        IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                        IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE
                        ICFO = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,ABS(IOR))
                        IF(ICFO>0) THEN
                           CFO => M2%CUT_FACE(ICFO)
                           CFO%VEL_OMESH(1:CFO%NFACE) = CFO%VEL_LNK_OMESH(1:CFO%NFACE)
                        ELSE
                           OM%W(IIO,JJO,KKO) = OM%W_LNK(IIO,JJO,KKO)
                        ENDIF
                     ENDDO
                  ENDDO
               ENDDO
            CASE(-3)
               DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
                  DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                     DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                        IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                        IF (M2%FCVAR(IIO,JJO,KKO-1,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE
                        ICFO = M2%FCVAR(IIO,JJO,KKO-1,CC_IDCF,ABS(IOR))
                        IF(ICFO>0) THEN
                           CFO => M2%CUT_FACE(ICFO)
                           CFO%VEL_OMESH(1:CFO%NFACE) = CFO%VEL_LNK_OMESH(1:CFO%NFACE)
                        ELSE
                           OM%W(IIO,JJO,KKO-1) = OM%W_LNK(IIO,JJO,KKO-1)
                        ENDIF
                     ENDDO
                  ENDDO
               ENDDO
            END SELECT
         ENDIF
      ENDDO EXTERNAL_WALL_LOOP_3
   ENDIF PRED_2

ENDIF CMP_FLG_IF

T_USED(14) = T_USED(14) + CURRENT_TIME() - T_NOW
END SUBROUTINE GET_LINKED_VELOCITIES


! --------------------------- CC_RESTORE_UVW_UNLINKED -------------------------

SUBROUTINE CC_RESTORE_UVW_UNLINKED(NM,ASSIGN_UNLINKED_VEL)

! NOTE : If ASSIGN_UNLINKED_VEL=.FALSE. assumes point to mesh has been called.

INTEGER, INTENT(IN) :: NM
LOGICAL, INTENT(IN) :: ASSIGN_UNLINKED_VEL

INTEGER :: I,J,K,X1AXIS,ICF,JCF,COUNT,IW
REAL(EB):: T_NOW

T_NOW = CURRENT_TIME()

COUNT = 0
ASSIGN_UNLINKED_IF : IF (ASSIGN_UNLINKED_VEL) THEN

   CALL POINT_TO_MESH(NM)

   DO K=0,KBAR
      DO J=0,JBAR
         DO I=0,IBAR
            IF (FCVAR(I,J,K,CC_UNKF,IAXIS)>0) THEN
               COUNT = COUNT+1; U(I,J,K) = UN_ULNK(COUNT)
            ENDIF
            IF (FCVAR(I,J,K,CC_UNKF,JAXIS)>0 .AND. .NOT.TWO_D) THEN
               COUNT = COUNT+1; V(I,J,K) = UN_ULNK(COUNT)
            ENDIF
            IF (FCVAR(I,J,K,CC_UNKF,KAXIS)>0) THEN
               COUNT = COUNT+1; W(I,J,K) = UN_ULNK(COUNT)
            ENDIF
         ENDDO
      ENDDO
   ENDDO
   DO ICF=1,MESHES(NM)%CC_NRCFACE_Z
      IF(RC_FACE(ICF)%UNKF<1) CYCLE
      I = RC_FACE(ICF)%IJK(IAXIS); J = RC_FACE(ICF)%IJK(JAXIS); K = RC_FACE(ICF)%IJK(KAXIS)
      X1AXIS = RC_FACE(ICF)%IJK(KAXIS+1)
      SELECT CASE(X1AXIS)
      CASE(IAXIS); COUNT = COUNT+1; U(I,J,K) = UN_ULNK(COUNT)
      CASE(JAXIS); IF(.NOT.TWO_D) COUNT = COUNT+1; V(I,J,K) = UN_ULNK(COUNT)
      CASE(KAXIS); COUNT = COUNT+1; W(I,J,K) = UN_ULNK(COUNT)
      END SELECT
   ENDDO
   DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      CF => CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE
      IF(TWO_D .AND. CF%IJK(KAXIS+1)==JAXIS) CYCLE
      I = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
      DO JCF=1,CF%NFACE
         IF (CF%UNKF(JCF)<1) CYCLE
         COUNT = COUNT+1; CF%VEL(JCF) = UN_ULNK(COUNT)
      ENDDO
   ENDDO
   EXTERNAL_WALL_LOOP_1: DO IW=1,MESHES(NM)%N_EXTERNAL_WALL_CELLS
      WC=>WALL(IW)
      IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE EXTERNAL_WALL_LOOP_1
      EWC=>EXTERNAL_WALL(IW)
      BC =>BOUNDARY_COORD(WC%BC_INDEX)
      I  = BC%II; J = BC%JJ; K = BC%KK; X1AXIS = ABS(BC%IOR)
      SELECT CASE(BC%IOR)
      CASE(-IAXIS); I=I-1
      CASE(-JAXIS); J=J-1
      CASE(-KAXIS); K=K-1
      END SELECT
      IF(FCVAR(I,J,K,CC_IDCF,X1AXIS)>0) THEN ! Cut-face.
         ICF=FCVAR(I,J,K,CC_IDCF,X1AXIS); CF=>CUT_FACE(ICF)
         DO JCF=1,CF%NFACE
            COUNT=COUNT+1; CF%VEL(JCF) = UN_ULNK(COUNT)
         ENDDO
         SELECT CASE(X1AXIS)
         CASE(IAXIS); U(I,J,K) = DOT_PRODUCT(CF%VEL(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DY(J)*DZ(K))
         CASE(JAXIS); V(I,J,K) = DOT_PRODUCT(CF%VEL(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DX(I)*DZ(K))
         CASE(KAXIS); W(I,J,K) = DOT_PRODUCT(CF%VEL(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / (DY(J)*DX(I))
         END SELECT
      ELSE ! All other reg faces.
         COUNT = COUNT + 1
         SELECT CASE(X1AXIS)
         CASE(IAXIS); U(I,J,K) = UN_ULNK(COUNT)
         CASE(JAXIS); V(I,J,K) = UN_ULNK(COUNT)
         CASE(KAXIS); W(I,J,K) = UN_ULNK(COUNT)
         END SELECT
      ENDIF
   ENDDO EXTERNAL_WALL_LOOP_1

ELSE ASSIGN_UNLINKED_IF

   DO K=0,KBAR
      DO J=0,JBAR
         DO I=0,IBAR
            IF (FCVAR(I,J,K,CC_UNKF,IAXIS)>0) THEN
               COUNT = COUNT+1; UN_ULNK(COUNT) = U(I,J,K)
            ENDIF
            IF (FCVAR(I,J,K,CC_UNKF,JAXIS)>0 .AND. .NOT.TWO_D) THEN
               COUNT = COUNT+1; UN_ULNK(COUNT) = V(I,J,K)
            ENDIF
            IF (FCVAR(I,J,K,CC_UNKF,KAXIS)>0) THEN
               COUNT = COUNT+1; UN_ULNK(COUNT) = W(I,J,K)
            ENDIF
         ENDDO
      ENDDO
   ENDDO
   DO ICF=1,MESHES(NM)%CC_NRCFACE_Z
      IF(RC_FACE(ICF)%UNKF<1) CYCLE
      I = RC_FACE(ICF)%IJK(IAXIS); J = RC_FACE(ICF)%IJK(JAXIS); K = RC_FACE(ICF)%IJK(KAXIS)
      X1AXIS = RC_FACE(ICF)%IJK(KAXIS+1)
      SELECT CASE(X1AXIS)
      CASE(IAXIS); COUNT = COUNT+1; UN_ULNK(COUNT) = U(I,J,K)
      CASE(JAXIS); IF(.NOT.TWO_D) COUNT = COUNT+1; UN_ULNK(COUNT) = V(I,J,K)
      CASE(KAXIS); COUNT = COUNT+1; UN_ULNK(COUNT) = W(I,J,K)
      END SELECT
   ENDDO
   DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      CF => CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE
      IF(TWO_D .AND. CF%IJK(KAXIS+1)==JAXIS) CYCLE
      I = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
      DO JCF=1,CF%NFACE
         IF (CF%UNKF(JCF)<1) CYCLE
         COUNT = COUNT+1; UN_ULNK(COUNT) = CF%VEL(JCF)
      ENDDO
   ENDDO
   EXTERNAL_WALL_LOOP_2: DO IW=1,MESHES(NM)%N_EXTERNAL_WALL_CELLS
      WC=>WALL(IW)
      IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE EXTERNAL_WALL_LOOP_2
      EWC=>EXTERNAL_WALL(IW)
      BC =>BOUNDARY_COORD(WC%BC_INDEX)
      I  = BC%II; J = BC%JJ; K = BC%KK; X1AXIS = ABS(BC%IOR)
      SELECT CASE(BC%IOR)
      CASE(-IAXIS); I=I-1
      CASE(-JAXIS); J=J-1
      CASE(-KAXIS); K=K-1
      END SELECT
      IF(FCVAR(I,J,K,CC_IDCF,X1AXIS)>0) THEN ! Cut-face.
         ICF=FCVAR(I,J,K,CC_IDCF,X1AXIS); CF=>CUT_FACE(ICF)
         DO JCF=1,CF%NFACE
            COUNT=COUNT+1; UN_ULNK(COUNT) = CF%VEL(JCF)
         ENDDO
      ELSE ! All other reg faces.
         COUNT = COUNT + 1
         SELECT CASE(X1AXIS)
         CASE(IAXIS); UN_ULNK(COUNT) = U(I,J,K)
         CASE(JAXIS); UN_ULNK(COUNT) = V(I,J,K)
         CASE(KAXIS); UN_ULNK(COUNT) = W(I,J,K)
         END SELECT
      ENDIF
   ENDDO EXTERNAL_WALL_LOOP_2

ENDIF ASSIGN_UNLINKED_IF

T_USED(14) = T_USED(14) + CURRENT_TIME() - T_NOW

END SUBROUTINE CC_RESTORE_UVW_UNLINKED


! ------------------------------- CC_COMPUTE_KRES -----------------------------

SUBROUTINE CC_COMPUTE_KRES(APPLY_TO_ESTIMATED_VARIABLES,NM)

LOGICAL, INTENT(IN) :: APPLY_TO_ESTIMATED_VARIABLES
INTEGER, INTENT(IN) :: NM

! Local Variables:
INTEGER :: ICC,I,J,K,JCC,IFC,IFACE,LOWHIGH,X1AXIS,ILH,IFC2,IFACE2,ICFA
REAL(EB):: T_NOW,AUI,AF,VELN,PRFCT,UVWAV(MAX_DIM),ATOTV(MAX_DIM)

T_NOW = CURRENT_TIME()

PRFCT = 0._EB; IF(APPLY_TO_ESTIMATED_VARIABLES) PRFCT = 1._EB
CUTCELL_DO : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
   CC => CUT_CELL(ICC); I = CC%IJK(IAXIS); J = CC%IJK(JAXIS); K = CC%IJK(KAXIS); IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
   IF (ONE_UNKH_PER_CUTCELL) THEN
      DO JCC=1,CC%NCELL
         IFC_LOOP_1 : DO IFC=1,CC%CCELEM(1,JCC)
            IFACE = CC%CCELEM(IFC+1,JCC)
            SELECT CASE(CC%FACE_LIST(1,IFACE))
            CASE(CC_FTYPE_RCGAS) ! REGULAR GASPHASE
               LOWHIGH = CC%FACE_LIST(2,IFACE)
               X1AXIS  = CC%FACE_LIST(3,IFACE)
               ILH     = LOWHIGH - 1
               SELECT CASE(X1AXIS)
               CASE(IAXIS); AF   = DY(J)*DZ(K); VELN = PRFCT*US(I-1+ILH,J,K) + (1._EB-PRFCT)*U(I-1+ILH,J,K)
               CASE(JAXIS); AF   = DX(I)*DZ(K); VELN = PRFCT*VS(I,J-1+ILH,K) + (1._EB-PRFCT)*V(I,J-1+ILH,K)
               CASE(KAXIS); AF   = DX(I)*DY(J); VELN = PRFCT*WS(I,J,K-1+ILH) + (1._EB-PRFCT)*W(I,J,K-1+ILH)
               END SELECT
               ATOTV(X1AXIS) = ATOTV(X1AXIS) + AF
               UVWAV(X1AXIS) = UVWAV(X1AXIS) + VELN * AF
            CASE(CC_FTYPE_CFGAS) ! GASPHASE CUT FACE:
               LOWHIGH = CC%FACE_LIST(2,IFACE)
               IFC2    = CC%FACE_LIST(4,IFACE)
               IFACE2  = CC%FACE_LIST(5,IFACE)
               X1AXIS  = CUT_FACE(IFC2)%IJK(KAXIS+1)
               AF      = CUT_FACE(IFC2)%AREA(IFACE2)
               VELN    = PRFCT*CUT_FACE(IFC2)%VELS(IFACE2) + (1._EB-PRFCT)*CUT_FACE(IFC2)%VEL(IFACE2)
               ATOTV(X1AXIS) = ATOTV(X1AXIS) + AF
               UVWAV(X1AXIS) = UVWAV(X1AXIS) + VELN * AF
            CASE(CC_FTYPE_CFINB) ! INBOUNDARY CUT FACE: Note here we add U_NORMAL with Transpiration velocity due to
                                  ! Poisson solver velocity error.
               IFC2    = CC%FACE_LIST(4,IFACE)
               IFACE2  = CC%FACE_LIST(5,IFACE)
               ICFA    = CUT_FACE(IFC2)%CFACE_INDEX(IFACE2)
               AF      = CUT_FACE(IFC2)%AREA(IFACE2)
               VELN = (1._EB-PRFCT)*CUT_FACE(IFC2)%VEL( IFACE2) + PRFCT *CUT_FACE(IFC2)%VELS(IFACE2)
               ! - to use velocity into gasphase, projected area.
               BC => MESHES(NM)%BOUNDARY_COORD(CFACE(ICFA)%BC_INDEX)
               DO X1AXIS=IAXIS,KAXIS
                 AUI  = ABS(BC%NVEC(X1AXIS)*AF)
                 ATOTV(X1AXIS) = ATOTV(X1AXIS) + AUI
                 UVWAV(X1AXIS) = UVWAV(X1AXIS) - VELN*BC%NVEC(X1AXIS)*AUI
               ENDDO

            END SELECT
         ENDDO IFC_LOOP_1
         WHERE (ATOTV>TWO_EPSILON_EB) UVWAV = UVWAV / ATOTV
         CC%KRES(JCC) = 0.5_EB*(UVWAV(IAXIS)**2._EB+UVWAV(JAXIS)**2._EB+UVWAV(KAXIS)**2._EB)
      ENDDO

   ELSE
      ATOTV(:) = 0._EB; UVWAV(:) = 0._EB
      DO JCC=1,CC%NCELL
         IFC_LOOP_2 : DO IFC=1,CC%CCELEM(1,JCC)
            IFACE = CC%CCELEM(IFC+1,JCC)
            SELECT CASE(CC%FACE_LIST(1,IFACE))
            CASE(CC_FTYPE_RCGAS) ! REGULAR GASPHASE
               LOWHIGH = CC%FACE_LIST(2,IFACE)
               X1AXIS  = CC%FACE_LIST(3,IFACE)
               ILH     = LOWHIGH - 1
               SELECT CASE(X1AXIS)
               CASE(IAXIS); AF   = DY(J)*DZ(K); VELN = PRFCT*US(I-1+ILH,J,K) + (1._EB-PRFCT)*U(I-1+ILH,J,K)
               CASE(JAXIS); AF   = DX(I)*DZ(K); VELN = PRFCT*VS(I,J-1+ILH,K) + (1._EB-PRFCT)*V(I,J-1+ILH,K)
               CASE(KAXIS); AF   = DX(I)*DY(J); VELN = PRFCT*WS(I,J,K-1+ILH) + (1._EB-PRFCT)*W(I,J,K-1+ILH)
               END SELECT
               ATOTV(X1AXIS) = ATOTV(X1AXIS) + AF
               UVWAV(X1AXIS) = UVWAV(X1AXIS) + VELN * AF
            CASE(CC_FTYPE_CFGAS) ! GASPHASE CUT FACE:
               LOWHIGH = CC%FACE_LIST(2,IFACE)
               IFC2    = CC%FACE_LIST(4,IFACE)
               IFACE2  = CC%FACE_LIST(5,IFACE)
               X1AXIS  = CUT_FACE(IFC2)%IJK(KAXIS+1)
               AF      = CUT_FACE(IFC2)%AREA(IFACE2)
               VELN    = PRFCT*CUT_FACE(IFC2)%VELS(IFACE2) + (1._EB-PRFCT)*CUT_FACE(IFC2)%VEL(IFACE2)
               ATOTV(X1AXIS) = ATOTV(X1AXIS) + AF
               UVWAV(X1AXIS) = UVWAV(X1AXIS) + VELN * AF
            CASE(CC_FTYPE_CFINB) ! INBOUNDARY CUT FACE: Note here we add U_NORMAL with Transpiration velocity due to
                                  ! Poisson solver velocity error.
               IFC2    = CC%FACE_LIST(4,IFACE)
               IFACE2  = CC%FACE_LIST(5,IFACE)
               ICFA    = CUT_FACE(IFC2)%CFACE_INDEX(IFACE2)
               AF      = CUT_FACE(IFC2)%AREA(IFACE2)
               VELN = (1._EB-PRFCT)*CUT_FACE(IFC2)%VEL( IFACE2) + PRFCT *CUT_FACE(IFC2)%VELS(IFACE2)
               ! - to use velocity into gasphase, projected area.
               BC => MESHES(NM)%BOUNDARY_COORD(CFACE(ICFA)%BC_INDEX)
               DO X1AXIS=IAXIS,KAXIS
                 AUI  = ABS(BC%NVEC(X1AXIS)*AF)
                 ATOTV(X1AXIS) = ATOTV(X1AXIS) + AUI
                 UVWAV(X1AXIS) = UVWAV(X1AXIS) - VELN*BC%NVEC(X1AXIS)*AUI
               ENDDO

            END SELECT
         ENDDO IFC_LOOP_2
      ENDDO
      WHERE(ATOTV>TWO_EPSILON_EB) UVWAV = UVWAV / ATOTV
      CC%KRES(1:CC%NCELL) = 0.5_EB*(UVWAV(IAXIS)**2._EB+UVWAV(JAXIS)**2._EB+UVWAV(KAXIS)**2._EB)
   ENDIF

   ! Note we use an average KRES per cartesian cell, this will be moved to CC%KRES(JCC).
   KRES(I,J,K)=DOT_PRODUCT(CC%KRES(1:CC%NCELL),CC%VOLUME(1:CC%NCELL))/SUM(CC%VOLUME(1:CC%NCELL))

ENDDO CUTCELL_DO

T_USED(14) = T_USED(14) + CURRENT_TIME() - T_NOW
RETURN
END SUBROUTINE CC_COMPUTE_KRES


! --------------------------- CC_EXCHANGE_UNPACKING_ARRAYS --------------------------

SUBROUTINE CC_EXCHANGE_UNPACKING_ARRAYS()

! Local Variables:
INTEGER :: NM,NOM,NOOM,IFEP,ICD_SGN
TYPE (MESH_TYPE), POINTER :: M
TYPE (OMESH_TYPE), POINTER :: M2
INTEGER :: EP,INPE,INT_NPE_LO,INT_NPE_HI,VIND,IEDGE

RECV_MESH_LOOP: DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   M =>MESHES(NOM)

   SEND_MESH_LOOP: DO NM=1,NMESHES

      M2=>MESHES(NOM)%OMESH(NM)

      ! Boundary and gasphase cut-faces and rcedges, face centered variables for interpolation:
      CF_FC_IF : IF(M2%NFCC_R(1)>0) THEN
         ! RCEDGES:
         ! Count:
         DO IEDGE=1,M%CC_NRCEDGE
            DO EP=1,INT_N_EXT_PTS  ! External point for face IEDGE
               DO VIND=IAXIS,KAXIS ! Velocity component U, V or W for external point EP
                  INT_NPE_LO = M%CC_RCEDGE(IEDGE)%INT_NPE(LOW_IND,VIND,EP,0)
                  INT_NPE_HI = M%CC_RCEDGE(IEDGE)%INT_NPE(HIGH_IND,VIND,EP,0)
                  DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
                     NOOM   = M%CC_RCEDGE(IEDGE)%INT_NOMIND( LOW_IND,INPE); IF (NOOM /= NM) CYCLE
                     M2%NFEP_R(3) = M2%NFEP_R(3) + 1
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
         IF (M2%NFEP_R(3) > 0) THEN
            ! Allocate:
            IF (ALLOCATED(M2%IFEP_R_3)) DEALLOCATE(M2%IFEP_R_3)
            ALLOCATE(M2%IFEP_R_3(LOW_IND:HIGH_IND,M2%NFEP_R(3))); M2%IFEP_R_3 = CC_UNDEFINED
            ! Add index entries:
            IFEP = 0
            DO IEDGE=1,M%CC_NRCEDGE
               DO EP=1,INT_N_EXT_PTS  ! External point for face IEDGE
                  DO VIND=IAXIS,KAXIS ! Velocity component U, V or W for external point EP
                     INT_NPE_LO = M%CC_RCEDGE(IEDGE)%INT_NPE(LOW_IND,VIND,EP,0)
                     INT_NPE_HI = M%CC_RCEDGE(IEDGE)%INT_NPE(HIGH_IND,VIND,EP,0)
                     DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
                        NOOM   = M%CC_RCEDGE(IEDGE)%INT_NOMIND( LOW_IND,INPE); IF (NOOM /= NM) CYCLE
                        IFEP = IFEP + 1
                        M2%IFEP_R_3( LOW_IND:HIGH_IND,IFEP) = (/ IEDGE, INPE /)
                     ENDDO
                  ENDDO
               ENDDO
            ENDDO
         ENDIF

         ! Then IBEDGES:
         ! Count:
         DO IEDGE=1,M%CC_NIBEDGE
            DO ICD_SGN=-2,2
               IF(ICD_SGN==0) CYCLE
               DO EP=1,INT_N_EXT_PTS  ! External point for face IEDGE
                  DO VIND=IAXIS,KAXIS ! Velocity component U, V or W for external point EP
                    INT_NPE_LO = M%CC_IBEDGE(IEDGE)%INT_NPE(LOW_IND,VIND,EP,ICD_SGN)
                    INT_NPE_HI = M%CC_IBEDGE(IEDGE)%INT_NPE(HIGH_IND,VIND,EP,ICD_SGN)
                    DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
                       NOOM   = M%CC_IBEDGE(IEDGE)%INT_NOMIND( LOW_IND,INPE); IF (NOOM /= NM) CYCLE
                       M2%NFEP_R(4) = M2%NFEP_R(4) + 1
                    ENDDO
                 ENDDO
               ENDDO
            ENDDO
         ENDDO
         IF (M2%NFEP_R(4) > 0) THEN
            ! Allocate:
            IF (ALLOCATED(M2%IFEP_R_4)) DEALLOCATE(M2%IFEP_R_4)
            ALLOCATE(M2%IFEP_R_4(LOW_IND:HIGH_IND,M2%NFEP_R(4))); M2%IFEP_R_4 = CC_UNDEFINED
            ! Add index entries:
            IFEP = 0
            DO IEDGE=1,M%CC_NIBEDGE
               DO ICD_SGN=-2,2
                  IF(ICD_SGN==0) CYCLE
                  DO EP=1,INT_N_EXT_PTS  ! External point for face IEDGE
                     DO VIND=IAXIS,KAXIS ! Velocity component U, V or W for external point EP
                        INT_NPE_LO = M%CC_IBEDGE(IEDGE)%INT_NPE(LOW_IND,VIND,EP,ICD_SGN)
                        INT_NPE_HI = M%CC_IBEDGE(IEDGE)%INT_NPE(HIGH_IND,VIND,EP,ICD_SGN)
                        DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
                           NOOM   = M%CC_IBEDGE(IEDGE)%INT_NOMIND( LOW_IND,INPE); IF (NOOM /= NM) CYCLE
                           IFEP = IFEP + 1
                           M2%IFEP_R_4( LOW_IND:HIGH_IND,IFEP) = (/ IEDGE, INPE /)
                        ENDDO
                     ENDDO
                  ENDDO
               ENDDO
            ENDDO
         ENDIF
      ENDIF CF_FC_IF

      ! Boundary cut-faces, cell centered variables for interpolation:
      BNDCF_CC_IF : IF(M2%NFCC_R(2)>0) THEN
         VIND = 0 ! Cell centered variables.
         ! Case of IBEDGES:
         ! Count:
         DO IEDGE=1,M%CC_NIBEDGE
            DO ICD_SGN=-2,2
               IF(ICD_SGN==0) CYCLE
               DO EP=1,INT_N_EXT_PTS  ! External point for face IEDGE
                  INT_NPE_LO = M%CC_IBEDGE(IEDGE)%INT_NPE(LOW_IND,VIND,EP,ICD_SGN)
                  INT_NPE_HI = M%CC_IBEDGE(IEDGE)%INT_NPE(HIGH_IND,VIND,EP,ICD_SGN)
                  DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
                     NOOM   = M%CC_IBEDGE(IEDGE)%INT_NOMIND( LOW_IND,INPE); IF (NOOM /= NM) CYCLE
                     M2%NFEP_R(5) = M2%NFEP_R(5) + 1
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
         IF (M2%NFEP_R(5)>0) THEN
            ! Allocate:
            IF (ALLOCATED(M2%IFEP_R_5)) DEALLOCATE(M2%IFEP_R_5)
            ALLOCATE(M2%IFEP_R_5(LOW_IND:HIGH_IND,M2%NFEP_R(5))); M2%IFEP_R_5 = CC_UNDEFINED
            ! Add index entries:
            IFEP = 0
            DO IEDGE=1,M%CC_NIBEDGE
               DO ICD_SGN=-2,2
                  IF(ICD_SGN==0) CYCLE
                  DO EP=1,INT_N_EXT_PTS  ! External point for face IEDGE
                     INT_NPE_LO = M%CC_IBEDGE(IEDGE)%INT_NPE(LOW_IND,VIND,EP,ICD_SGN)
                     INT_NPE_HI = M%CC_IBEDGE(IEDGE)%INT_NPE(HIGH_IND,VIND,EP,ICD_SGN)
                     DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
                        NOOM   = M%CC_IBEDGE(IEDGE)%INT_NOMIND( LOW_IND,INPE); IF (NOOM /= NM) CYCLE
                        IFEP = IFEP + 1
                        M2%IFEP_R_5( LOW_IND:HIGH_IND,IFEP) = (/ IEDGE, INPE /)
                     ENDDO
                  ENDDO
               ENDDO
            ENDDO
         ENDIF

      ENDIF BNDCF_CC_IF
   ENDDO SEND_MESH_LOOP
ENDDO RECV_MESH_LOOP

RETURN
END SUBROUTINE CC_EXCHANGE_UNPACKING_ARRAYS



! ------------------------------- MESH_CC_EXCHANGE ---------------------------------

SUBROUTINE MESH_CC_EXCHANGE(CODE)

USE MPI_F08

INTEGER, INTENT(IN) :: CODE

! Local Variables:
INTEGER :: NM,NOM,RNODE,SNODE,IERR
INTEGER :: II1,JJ1,KK1,NCELL,ICC,ICC1,JCC1,NQT2,JCC,LL,NN
INTEGER :: I,J,K,II,JJ,KK,IFC,ICF,X1AXIS,ICF1,JCF
TYPE (MESH_TYPE), POINTER :: M,M1
TYPE (OMESH_TYPE), POINTER :: M2,M3
REAL(EB), POINTER, DIMENSION(:,:,:) :: UP,UP2,VP,VP2,WP,WP2
LOGICAL, SAVE :: INITIALIZE_CC_SCALARS_FORC=.TRUE.

INTEGER :: EP,INPE,INT_NPE_LO,INT_NPE_HI,VIND,ICELL,IEDGE,IFEP,IW,IIO,JJO,KKO
REAL(EB) :: TNOW,TINTP

! For solid phase only return. All variables exchanged currently here are gas-phase.
IF (SOLID_PHASE_ONLY) RETURN
! In case of initialization code from main return.
! Initialization of cut-cell communications needs to be done later in the main.f90 sequence and will be done using
! INITIALIZE_CC_SCALARS/VELOCITY logicals.
IF (CODE == 0 .OR. CODE==2 .OR. CODE>6) RETURN
! No need to do mesh exchange within pressure iteration scheme here, when no IBM forcing, or call to fill GLMAT H ghost cells.
IF (.NOT.CC_MATVEC_DEFINED) RETURN
IF (CODE == 3 .AND. CALL_FROM_GLMAT_SETUP) RETURN

TNOW = CURRENT_TIME()

! First Allocate and setup persistent send-receives for scalars:
INITIALIZE_CC_SCALARS_FORC_COND : IF (INITIALIZE_CC_SCALARS_FORC) THEN

   ! Allocate REQ11, for scalar transport quantities, reduced cycling conditionals:
   N_REQ11=0
   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      DO NOM=1,NMESHES
         M3=>MESHES(NM)%OMESH(NOM)
         IF (M3%NICC_S(1)==0 .AND. M3%NICC_R(1)==0) CYCLE
         N_REQ11 = N_REQ11+1
      ENDDO
   ENDDO
   ALLOCATE(REQ11(N_REQ11*4)); N_REQ11=0


   ! Allocate REQ112: Exchange cut-face data in block boundaries.
   N_REQ112=0
   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      DO NOM=1,NMESHES
         M3=>MESHES(NM)%OMESH(NOM)
         IF (M3%NICF_S(1)==0 .AND. M3%NICF_R(1)==0 .AND. M3%NLKF_S==0 .AND. M3%NLKF_R==0) CYCLE
         N_REQ112 = N_REQ112+1
      ENDDO
   ENDDO
   ALLOCATE(REQ112(N_REQ112*4)); N_REQ112=0

   ! Allocate REQ12: Dual use, IBM forcing or TAU,OMG computation vars.
   N_REQ12=0
   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      DO NOM=1,NMESHES
         M3=>MESHES(NM)%OMESH(NOM)
         IF (M3%NFCC_S(1)==0 .AND. M3%NFCC_R(1)==0) CYCLE
         N_REQ12 = N_REQ12+1
      ENDDO
   ENDDO
   ALLOCATE(REQ12(N_REQ12*4)); N_REQ12=0

   ! Allocate REQ13, for end of step H and RHO_0*W interpolation (cell) quantities:
   N_REQ13=0
   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      DO NOM=1,NMESHES
         M3=>MESHES(NM)%OMESH(NOM)
         IF (M3%NFCC_S(2)==0 .AND. M3%NFCC_R(2)==0) CYCLE
         N_REQ13 = N_REQ13+1
      ENDDO
   ENDDO
   ALLOCATE(REQ13(N_REQ13*4)); N_REQ13=0


   ! 1. Receives:
   MESH_LOOP_1: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

      RNODE = PROCESS(NM)

      ! REQ11:
      OTHER_MESH_LOOP_11: DO NOM=1,NMESHES
         M3=>MESHES(NM)%OMESH(NOM)
         IF (M3%NICC_R(1)==0) CYCLE OTHER_MESH_LOOP_11
         SNODE = PROCESS(NOM)
         IF (M3%NICC_R(1)>0) THEN
            ! Cell centered variables on cut-cells:
            ALLOCATE(M3%REAL_RECV_PKG11(M3%NICC_R(2)*(4+N_TOTAL_SCALARS)))
            IF (RNODE/=SNODE) THEN
               N_REQ11 = N_REQ11 + 1
               CALL MPI_RECV_INIT(M3%REAL_RECV_PKG11(1),SIZE(M3%REAL_RECV_PKG11),MPI_DOUBLE_PRECISION, &
                                  SNODE,NOM,MPI_COMM_WORLD,REQ11(N_REQ11),IERR)
            ENDIF
         ENDIF
      ENDDO OTHER_MESH_LOOP_11

      ! REQ112:
      OTHER_MESH_LOOP_112: DO NOM=1,NMESHES
         M3=>MESHES(NM)%OMESH(NOM)
         IF (M3%NICF_R(1)==0 .AND. M3%NLKF_R==0) CYCLE OTHER_MESH_LOOP_112
         SNODE = PROCESS(NOM)
         ! Cut-face centered variables VEL/VELS, F, FB, ICG Hi-1,Hi:
         ALLOCATE(M3%REAL_RECV_PKG112(M3%NICF_R(2) * 4 + M3%NLKF_R * 3))
         IF (RNODE/=SNODE) THEN
            N_REQ112 = N_REQ112 + 1
            CALL MPI_RECV_INIT(M3%REAL_RECV_PKG112(1),SIZE(M3%REAL_RECV_PKG112),MPI_DOUBLE_PRECISION, &
                               SNODE,NOM,MPI_COMM_WORLD,REQ112(N_REQ112),IERR)
         ENDIF
      ENDDO OTHER_MESH_LOOP_112

      ! REQ12:
      OTHER_MESH_LOOP_12: DO NOM=1,NMESHES
         M3=>MESHES(NM)%OMESH(NOM)
         IF (M3%NFCC_R(1)==0) CYCLE OTHER_MESH_LOOP_12
         SNODE = PROCESS(NOM)
         ! Face centered variables Ux1, Fvx1, dHdx1:
         ALLOCATE(M3%REAL_RECV_PKG12(M3%NFCC_R(1) * 2))
         IF (RNODE/=SNODE) THEN
            N_REQ12 = N_REQ12 + 1
            CALL MPI_RECV_INIT(M3%REAL_RECV_PKG12(1),SIZE(M3%REAL_RECV_PKG12),MPI_DOUBLE_PRECISION, &
                               SNODE,NOM,MPI_COMM_WORLD,REQ12(N_REQ12),IERR)
         ENDIF
      ENDDO OTHER_MESH_LOOP_12

      ! REQ13:
      OTHER_MESH_LOOP_13: DO NOM=1,NMESHES
         M3=>MESHES(NM)%OMESH(NOM)
         IF (M3%NFCC_R(2)==0) CYCLE OTHER_MESH_LOOP_13
         SNODE = PROCESS(NOM)
         ! Cell centered variables:
         ALLOCATE(M3%REAL_RECV_PKG13(M3%NFCC_R(2)*(NQT2C+N_TRACKED_SPECIES)))
         IF (RNODE/=SNODE) THEN
            N_REQ13 = N_REQ13 + 1
            CALL MPI_RECV_INIT(M3%REAL_RECV_PKG13(1),SIZE(M3%REAL_RECV_PKG13),MPI_DOUBLE_PRECISION, &
                               SNODE,NOM,MPI_COMM_WORLD,REQ13(N_REQ13),IERR)
         ENDIF
      ENDDO OTHER_MESH_LOOP_13

   ENDDO MESH_LOOP_1

   ! 2. Sends:
   SENDING_MESH_LOOP_1: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

      RNODE = PROCESS(NM)
      M =>MESHES(NM)

      ! REQ11:
      RECEIVING_MESH_LOOP_11: DO NOM=1,NMESHES
         M3=>MESHES(NM)%OMESH(NOM)
         SNODE = PROCESS(NOM)
         ! Initialize persistent send requests
         IF (M3%NICC_S(1)>0 .AND. RNODE/=SNODE) THEN
            ALLOCATE(M3%REAL_SEND_PKG11(M3%NICC_S(2)*(4+N_TOTAL_SCALARS)))
            N_REQ11 = N_REQ11 + 1
            CALL MPI_SEND_INIT(M3%REAL_SEND_PKG11(1),SIZE(M3%REAL_SEND_PKG11),MPI_DOUBLE_PRECISION, &
                               SNODE,NM,MPI_COMM_WORLD,REQ11(N_REQ11),IERR)
         ENDIF
      ENDDO RECEIVING_MESH_LOOP_11

      ! REQ112:
      RECEIVING_MESH_LOOP_112: DO NOM=1,NMESHES
         M3=>MESHES(NM)%OMESH(NOM)
         IF (M3%NICF_S(1)==0 .AND. M3%NLKF_S==0)  CYCLE RECEIVING_MESH_LOOP_112
         SNODE = PROCESS(NOM)
         ! Initialize persistent send requests
         IF ((M3%NICF_S(1)>0 .OR. M3%NLKF_S>0) .AND. RNODE/=SNODE) THEN
            ALLOCATE(M3%REAL_SEND_PKG112(M3%NICF_S(2) * 4 + M3%NLKF_S * 3))
            N_REQ112 = N_REQ112 + 1
            CALL MPI_SEND_INIT(M3%REAL_SEND_PKG112(1),SIZE(M3%REAL_SEND_PKG112),MPI_DOUBLE_PRECISION, &
                               SNODE,NM,MPI_COMM_WORLD,REQ112(N_REQ112),IERR)
         ENDIF
      ENDDO RECEIVING_MESH_LOOP_112

      ! REQ12:
      RECEIVING_MESH_LOOP_12: DO NOM=1,NMESHES
         M3=>MESHES(NM)%OMESH(NOM)
         IF (M3%NFCC_S(1)==0)  CYCLE RECEIVING_MESH_LOOP_12
         SNODE = PROCESS(NOM)
         ! Initialize persistent send requests
         IF (M3%NFCC_S(1)>0 .AND. RNODE/=SNODE) THEN
            ALLOCATE(M3%REAL_SEND_PKG12(M3%NFCC_S(1) * 2))
            N_REQ12 = N_REQ12 + 1
            CALL MPI_SEND_INIT(M3%REAL_SEND_PKG12(1),SIZE(M3%REAL_SEND_PKG12),MPI_DOUBLE_PRECISION, &
                               SNODE,NM,MPI_COMM_WORLD,REQ12(N_REQ12),IERR)
         ENDIF
      ENDDO RECEIVING_MESH_LOOP_12

      ! REQ13:
      RECEIVING_MESH_LOOP_13: DO NOM=1,NMESHES
         M3=>MESHES(NM)%OMESH(NOM)
         IF (M3%NFCC_S(2)==0)  CYCLE RECEIVING_MESH_LOOP_13
         SNODE = PROCESS(NOM)
         ! Initialize persistent send requests
         IF (M3%NFCC_S(2)>0 .AND. RNODE/=SNODE) THEN
            ALLOCATE(M3%REAL_SEND_PKG13(M3%NFCC_S(2)*(NQT2C+N_TRACKED_SPECIES)))
            N_REQ13 = N_REQ13 + 1
            CALL MPI_SEND_INIT(M3%REAL_SEND_PKG13(1),SIZE(M3%REAL_SEND_PKG13),MPI_DOUBLE_PRECISION, &
                               SNODE,NM,MPI_COMM_WORLD,REQ13(N_REQ13),IERR)
         ENDIF
      ENDDO RECEIVING_MESH_LOOP_13

   ENDDO SENDING_MESH_LOOP_1

   INITIALIZE_CC_SCALARS_FORC = .FALSE.

ENDIF INITIALIZE_CC_SCALARS_FORC_COND


! Exchange Scalars in cut-cells:
SENDING_MESH_LOOP_2: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   M =>MESHES(NM)
   RECEIVING_MESH_LOOP_2: DO NOM=1,NMESHES

      M1=>MESHES(NOM)
      M3=>MESHES(NM)%OMESH(NOM)

      SNODE = PROCESS(NOM)
      RNODE = PROCESS(NM)

      ! Exchange of density and species mass fractions following the PREDICTOR update

      IF (CODE==1 .AND. M3%NICC_S(1)>0) THEN
         NQT2 = 4+N_TOTAL_SCALARS
         LL = 0
         IF (RNODE/=SNODE) THEN
            PACK_REAL_SEND_PKG11: DO ICC1=1,M3%NICC_S(1)
               ICC=M3%ICC_UNKZ_CC_S(ICC1)
               NCELL=M%CUT_CELL(ICC)%NCELL
               II1=M%CUT_CELL(ICC)%IJK(IAXIS)
               JJ1=M%CUT_CELL(ICC)%IJK(JAXIS)
               KK1=M%CUT_CELL(ICC)%IJK(KAXIS)
               DO JCC=1,NCELL
                  LL = LL + 1
                  M3%REAL_SEND_PKG11(NQT2*(LL-1)+1) = M%CUT_CELL(ICC)%RHOS(JCC)
                  M3%REAL_SEND_PKG11(NQT2*(LL-1)+2) = M%CUT_CELL(ICC)%TMP(JCC)
                  M3%REAL_SEND_PKG11(NQT2*(LL-1)+3) = M%CUT_CELL(ICC)%RSUM(JCC)
                  M3%REAL_SEND_PKG11(NQT2*(LL-1)+4) = M%CUT_CELL(ICC)%D(JCC)
                  DO NN=1,N_TOTAL_SCALARS
                     M3%REAL_SEND_PKG11(NQT2*(LL-1)+4+NN) = M%CUT_CELL(ICC)%ZZS(NN,JCC)
                  ENDDO
               ENDDO
            ENDDO PACK_REAL_SEND_PKG11
         ENDIF
      ENDIF

      ! Information for cell centered variables:
      IF (CODE==1 .AND. M3%NFCC_S(2)>0) THEN
         NQT2 = NQT2C+N_TOTAL_SCALARS
         LL = 0
         IF (RNODE/=SNODE) THEN
            PACK_REAL_SEND_PKG213 : DO ICC=1,M3%NFCC_S(2)
               I     = M3%IIO_CC_S(ICC)
               J     = M3%JJO_CC_S(ICC)
               K     = M3%KKO_CC_S(ICC)
               LL = LL + 1
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+1) = M%HS(I,J,K)                            ! Prev H in cell I,J,K
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+2) = M%RHO_0(K)                             ! RHO_0 in cell I,J,K
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+3) = 0.5_EB*(M%W(I,J,K-1)+M%W(I,J,K))       ! Wcen^n in I,J,K.
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+4) = M%RHOS(I,J,K)                          ! RHO^*
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+5) = M%TMP(I,J,K)                           ! TMP^*
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+6) = M%RSUM(I,J,K)                          ! RSUM^*
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+7) = M%MU(I,J,K)                            ! MU^n
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+8) = M%MU_DNS(I,J,K)                        ! MU_DNS^n
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+NQT2C)= M%RHO(I,J,K)*(M%HS(I,J,K)-M%KRES(I,J,K)) ! Previous substep pressure.
               DO NN=1,N_TOTAL_SCALARS
                  M3%REAL_SEND_PKG13(NQT2*(LL-1)+NQT2C+NN)= M%ZZS(I,J,K,NN)
               ENDDO
            ENDDO PACK_REAL_SEND_PKG213
         ELSE
            M2=>MESHES(NOM)%OMESH(NM)
            PACK_REAL_RECV_PKG213: DO IFEP=1,M2%NFEP_R(2)
               ICF = M2%IFEP_R_2( LOW_IND,IFEP)
               INPE= M2%IFEP_R_2(HIGH_IND,IFEP)
               LL  = M1%CUT_FACE(ICF)%INT_NOMIND(HIGH_IND,INPE)
               I     = M3%IIO_CC_S(LL)
               J     = M3%JJO_CC_S(LL)
               K     = M3%KKO_CC_S(LL)
               M1%CUT_FACE(ICF)%INT_CVARS(    INT_H_IND,INPE)= M%HS(I,J,K)
               M1%CUT_FACE(ICF)%INT_CVARS(  INT_RHO_IND,INPE)= M%RHOS(I,J,K)
               M1%CUT_FACE(ICF)%INT_CVARS(  INT_TMP_IND,INPE)= M%TMP(I,J,K)
               M1%CUT_FACE(ICF)%INT_CVARS( INT_RSUM_IND,INPE)= M%RSUM(I,J,K)
               M1%CUT_FACE(ICF)%INT_CVARS(   INT_MU_IND,INPE)= M%MU(I,J,K)
               M1%CUT_FACE(ICF)%INT_CVARS(INT_MUDNS_IND,INPE)= M%MU_DNS(I,J,K)
               M1%CUT_FACE(ICF)%INT_CVARS(    INT_P_IND,INPE)= M%RHO(I,J,K)*(M%HS(I,J,K)-M%KRES(I,J,K))
               DO NN=1,N_TOTAL_SCALARS
                  M1%CUT_FACE(ICF)%INT_CVARS(INT_P_IND+NN,INPE)=M%ZZS(I,J,K,NN)
               ENDDO
            ENDDO PACK_REAL_RECV_PKG213
         ENDIF
      ENDIF

      ! Exchange velocity, momentum rhs and previous substep dH/Dx1 for cut-faces, in PREDICTOR, IBM forcing:
      IF (CODE==5 .AND. PREDICTOR .AND. M3%NICF_S(1)>0) THEN
         NQT2 = 4
         LL   = 0
         IF (RNODE/=SNODE) THEN
            PACK_REAL_SEND_PKG112A: DO ICF1=1,M3%NICF_S(1)
               ICF=M3%ICF_UFFB_CF_S(ICF1); CF => M%CUT_FACE(ICF)
               DO JCF=1,CF%NFACE
                  LL = LL + 1
                  M3%REAL_SEND_PKG112(NQT2*(LL-1)+1) = CF%FN(JCF)
                  ICC=CF%CELL_LIST(2,LOW_IND,JCF); JCC=CF%CELL_LIST(3,LOW_IND,JCF)
                  M3%REAL_SEND_PKG112(NQT2*(LL-1)+2) = M%CUT_CELL(ICC)%H(JCC) ! H_LO
                  ICC=CF%CELL_LIST(2,HIGH_IND,JCF); JCC=CF%CELL_LIST(3,HIGH_IND,JCF)
                  M3%REAL_SEND_PKG112(NQT2*(LL-1)+3) = M%CUT_CELL(ICC)%H(JCC) ! H_HI
               ENDDO
            ENDDO PACK_REAL_SEND_PKG112A
         ELSE
            PACK_REAL_SEND_PKG112A2: DO ICF1=1,M3%NICF_S(1)
               ICF=M3%ICF_UFFB_CF_S(ICF1); CF => M%CUT_FACE(ICF)
               DO JCF=1,CF%NFACE
                  CF%FN_OMESH(JCF) = CF%FN(JCF)
                  ! No need to copy H_LO, H_HI
               ENDDO
            ENDDO PACK_REAL_SEND_PKG112A2
         ENDIF
      ENDIF

      ! Exchange Velocity at end of PREDICTOR: To be used in RCEDGEs estimation of OMEGA and TAU at next substep.

      IF (CODE==3 .AND. M3%NICF_S(1)>0) THEN
         NQT2 = 4
         LL   = 0
         IF (RNODE/=SNODE) THEN
            PACK_REAL_SEND_PKG112A3: DO ICF1=1,M3%NICF_S(1)
               ICF=M3%ICF_UFFB_CF_S(ICF1); CF => M%CUT_FACE(ICF)
               DO JCF=1,CF%NFACE
                  LL = LL + 1
                  M3%REAL_SEND_PKG112(NQT2*(LL-1)+1) = CF%VELS(JCF)
                  M3%REAL_SEND_PKG112(NQT2*(LL-1)+2) = CF%VEL_LNK(JCF)
                  ICC=CF%CELL_LIST(2,LOW_IND,JCF); JCC=CF%CELL_LIST(3,LOW_IND,JCF)
                  M3%REAL_SEND_PKG112(NQT2*(LL-1)+3) = M%CUT_CELL(ICC)%H(JCC) ! H_LO
                  ICC=CF%CELL_LIST(2,HIGH_IND,JCF); JCC=CF%CELL_LIST(3,HIGH_IND,JCF)
                  M3%REAL_SEND_PKG112(NQT2*(LL-1)+4) = M%CUT_CELL(ICC)%H(JCC) ! H_HI
               ENDDO
            ENDDO PACK_REAL_SEND_PKG112A3
         ELSE
            PACK_REAL_SEND_PKG112A4: DO ICF1=1,M3%NICF_S(1)
               ICF=M3%ICF_UFFB_CF_S(ICF1); CF => M%CUT_FACE(ICF)
               DO JCF=1,CF%NFACE
                  CF%VELS_OMESH(JCF)    = CF%VELS(JCF)
                  CF%VEL_LNK_OMESH(JCF) = CF%VEL_LNK(JCF)
                  ! No need to copy H_LO and H_HI.
               ENDDO
            ENDDO PACK_REAL_SEND_PKG112A4
         ENDIF
      ENDIF
      IF (CODE==3 .AND. M3%NFCC_S(1)>0) THEN
         NQT2 = 1
         LL = 0
         IF (RNODE/=SNODE) THEN
            PACK_REAL_SEND_PKG121 : DO IFC=1,M3%NFCC_S(1)
               I     = M3%IIO_FC_S(IFC)
               J     = M3%JJO_FC_S(IFC)
               K     = M3%KKO_FC_S(IFC)
               X1AXIS= M3%AXS_FC_S(IFC)
               LL = LL + 1
               SELECT CASE(X1AXIS)
               CASE(IAXIS)
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+1) = M%US(I,J,K)                           ! U^* in x face I,J,K
               CASE(JAXIS)
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+1) = M%VS(I,J,K)                           ! V^* in y face I,J,K
               CASE(KAXIS)
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+1) = M%WS(I,J,K)                           ! W^* in z face I,J,K
               END SELECT
            ENDDO PACK_REAL_SEND_PKG121
         ELSE
            M2=>MESHES(NOM)%OMESH(NM)
            PACK_REAL_RECV_PKG121: DO IFEP=1,M2%NFEP_R(1)
               ICF = M2%IFEP_R_1( LOW_IND,IFEP)
               INPE= M2%IFEP_R_1(HIGH_IND,IFEP)
               LL  = M1%CUT_FACE(ICF)%INT_NOMIND(HIGH_IND,INPE)
               I     = M3%IIO_FC_S(LL)
               J     = M3%JJO_FC_S(LL)
               K     = M3%KKO_FC_S(LL)
               X1AXIS= M3%AXS_FC_S(LL)
               SELECT CASE(X1AXIS)
               CASE(IAXIS)
                  M1%CUT_FACE(ICF)%INT_FVARS( INT_VELS_IND,INPE) = M%US(I,J,K)               ! U^* in x face I,J,K
               CASE(JAXIS)
                  M1%CUT_FACE(ICF)%INT_FVARS( INT_VELS_IND,INPE) = M%VS(I,J,K)               ! V^* in y face I,J,K
               CASE(KAXIS)
                  M1%CUT_FACE(ICF)%INT_FVARS( INT_VELS_IND,INPE) = M%WS(I,J,K)               ! W^* in z face I,J,K
               END SELECT
            ENDDO PACK_REAL_RECV_PKG121
            ! Second Loop cut-edges:
            PACK_REAL_RECV_PKG121E: DO IFEP=1,M2%NFEP_R(3)
               IEDGE= M2%IFEP_R_3( LOW_IND,IFEP)
               INPE = M2%IFEP_R_3(HIGH_IND,IFEP)
               LL   = M1%CC_RCEDGE(IEDGE)%INT_NOMIND(HIGH_IND,INPE)
               I     = M3%IIO_FC_S(LL)
               J     = M3%JJO_FC_S(LL)
               K     = M3%KKO_FC_S(LL)
               X1AXIS= M3%AXS_FC_S(LL)
               SELECT CASE(X1AXIS)
               CASE(IAXIS)
                  M1%CC_RCEDGE(IEDGE)%INT_FVARS(INT_VEL_IND,INPE) = M%US(I,J,K)               ! U^* in x face I,J,K
               CASE(JAXIS)
                  M1%CC_RCEDGE(IEDGE)%INT_FVARS(INT_VEL_IND,INPE) = M%VS(I,J,K)               ! V^* in y face I,J,K
               CASE(KAXIS)
                  M1%CC_RCEDGE(IEDGE)%INT_FVARS(INT_VEL_IND,INPE) = M%WS(I,J,K)               ! W^* in z face I,J,K
               END SELECT
            ENDDO PACK_REAL_RECV_PKG121E
            PACK_REAL_RECV_PKG121EIB: DO IFEP=1,M2%NFEP_R(4)
               IEDGE= M2%IFEP_R_4( LOW_IND,IFEP)
               INPE = M2%IFEP_R_4(HIGH_IND,IFEP)
               LL   = M1%CC_IBEDGE(IEDGE)%INT_NOMIND(HIGH_IND,INPE)
               I     = M3%IIO_FC_S(LL)
               J     = M3%JJO_FC_S(LL)
               K     = M3%KKO_FC_S(LL)
               X1AXIS= M3%AXS_FC_S(LL)
               SELECT CASE(X1AXIS)
               CASE(IAXIS)
                  M1%CC_IBEDGE(IEDGE)%INT_FVARS(INT_VEL_IND,INPE) = M%US(I,J,K)               ! U^* in x face I,J,K
               CASE(JAXIS)
                  M1%CC_IBEDGE(IEDGE)%INT_FVARS(INT_VEL_IND,INPE) = M%VS(I,J,K)               ! V^* in y face I,J,K
               CASE(KAXIS)
                  M1%CC_IBEDGE(IEDGE)%INT_FVARS(INT_VEL_IND,INPE) = M%WS(I,J,K)               ! W^* in z face I,J,K
               END SELECT
            ENDDO PACK_REAL_RECV_PKG121EIB
         ENDIF
      ENDIF

      ! Exchange of density and species mass fractions following the CORRECTOR update

      IF (CODE==4 .AND. M3%NICC_S(1)>0) THEN
         NQT2 = 4+N_TOTAL_SCALARS
         LL = 0
         IF (RNODE/=SNODE) THEN
            PACK_REAL_SEND_PKG111: DO ICC1=1,M3%NICC_S(1)
               ICC=M3%ICC_UNKZ_CC_S(ICC1)
               NCELL=M%CUT_CELL(ICC)%NCELL
               II1=M%CUT_CELL(ICC)%IJK(IAXIS)
               JJ1=M%CUT_CELL(ICC)%IJK(JAXIS)
               KK1=M%CUT_CELL(ICC)%IJK(KAXIS)
               DO JCC=1,NCELL
                  LL = LL + 1
                  M3%REAL_SEND_PKG11(NQT2*(LL-1)+1) = M%CUT_CELL(ICC)%RHO(JCC)
                  M3%REAL_SEND_PKG11(NQT2*(LL-1)+2) = M%CUT_CELL(ICC)%TMP(JCC)
                  M3%REAL_SEND_PKG11(NQT2*(LL-1)+3) = M%CUT_CELL(ICC)%RSUM(JCC)
                  M3%REAL_SEND_PKG11(NQT2*(LL-1)+4) = M%CUT_CELL(ICC)%DS(JCC)
                  DO NN=1,N_TOTAL_SCALARS
                     M3%REAL_SEND_PKG11(NQT2*(LL-1)+4+NN) = M%CUT_CELL(ICC)%ZZ(NN,JCC)
                  ENDDO
               ENDDO
            ENDDO PACK_REAL_SEND_PKG111
         ENDIF
      ENDIF

      ! Information for cell centered variables:
      IF (CODE==4 .AND. M3%NFCC_S(2)>0) THEN
         NQT2 = NQT2C+N_TOTAL_SCALARS
         LL = 0
         IF (RNODE/=SNODE) THEN
            PACK_REAL_SEND_PKG313 : DO ICC=1,M3%NFCC_S(2)
               I     = M3%IIO_CC_S(ICC)
               J     = M3%JJO_CC_S(ICC)
               K     = M3%KKO_CC_S(ICC)
               LL = LL + 1
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+1) = M%H(I,J,K)                             ! Prev H in cell I,J,K
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+2) = M%RHO_0(K)                             ! RHO_0 in cell I,J,K
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+3) = 0.5_EB*(M%WS(I,J,K-1)+M%WS(I,J,K))     ! Wcen^* in I,J,K.
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+4) = M%RHO(I,J,K)                           ! RHO^n+1
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+5) = M%TMP(I,J,K)                           ! TMP^n+1
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+6) = M%RSUM(I,J,K)                          ! RSUM^n+1
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+7) = M%MU(I,J,K)                            ! MU^*
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+8) = M%MU_DNS(I,J,K)                        ! MU_DNS^*
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+NQT2C)= M%RHOS(I,J,K)*(M%H(I,J,K)-M%KRES(I,J,K)) ! Previous substep pressure.
               DO NN=1,N_TOTAL_SCALARS
                  M3%REAL_SEND_PKG13(NQT2*(LL-1)+NQT2C+NN)= M%ZZ(I,J,K,NN)
               ENDDO
            ENDDO PACK_REAL_SEND_PKG313
         ELSE
            M2=>MESHES(NOM)%OMESH(NM)
            PACK_REAL_RECV_PKG313: DO IFEP=1,M2%NFEP_R(2)
               ICF = M2%IFEP_R_2( LOW_IND,IFEP)
               INPE= M2%IFEP_R_2(HIGH_IND,IFEP)
               LL  = M1%CUT_FACE(ICF)%INT_NOMIND(HIGH_IND,INPE)
               I     = M3%IIO_CC_S(LL)
               J     = M3%JJO_CC_S(LL)
               K     = M3%KKO_CC_S(LL)
               M1%CUT_FACE(ICF)%INT_CVARS(    INT_H_IND,INPE)= M%H(I,J,K)
               M1%CUT_FACE(ICF)%INT_CVARS(  INT_RHO_IND,INPE)= M%RHO(I,J,K)
               M1%CUT_FACE(ICF)%INT_CVARS(  INT_TMP_IND,INPE)= M%TMP(I,J,K)
               M1%CUT_FACE(ICF)%INT_CVARS( INT_RSUM_IND,INPE)= M%RSUM(I,J,K)
               M1%CUT_FACE(ICF)%INT_CVARS(   INT_MU_IND,INPE)= M%MU(I,J,K)
               M1%CUT_FACE(ICF)%INT_CVARS(INT_MUDNS_IND,INPE)= M%MU_DNS(I,J,K)
               M1%CUT_FACE(ICF)%INT_CVARS(    INT_P_IND,INPE)= M%RHOS(I,J,K)*(M%H(I,J,K)-M%KRES(I,J,K))
               DO NN=1,N_TOTAL_SCALARS
                  M1%CUT_FACE(ICF)%INT_CVARS(INT_P_IND+NN,INPE)=M%ZZ(I,J,K,NN)
               ENDDO
            ENDDO PACK_REAL_RECV_PKG313
         ENDIF
      ENDIF


      ! Exchange velocity, momentum rhs and previous substep dH/Dx1 for cut-faces, in CORRECTOR, IBM forcing:
      IF (CODE==5 .AND. CORRECTOR .AND. M3%NICF_S(1)>0) THEN
         NQT2 = 4
         LL   = 0
         IF (RNODE/=SNODE) THEN
            PACK_REAL_SEND_PKG112B: DO ICF1=1,M3%NICF_S(1)
               ICF=M3%ICF_UFFB_CF_S(ICF1); CF => M%CUT_FACE(ICF)
               DO JCF=1,CF%NFACE
                  LL = LL + 1
                  M3%REAL_SEND_PKG112(NQT2*(LL-1)+1) = CF%FN(JCF)
                  ICC=CF%CELL_LIST(2,LOW_IND,JCF); JCC=CF%CELL_LIST(3,LOW_IND,JCF)
                  M3%REAL_SEND_PKG112(NQT2*(LL-1)+2) = M%CUT_CELL(ICC)%HS(JCC) ! HS_LO
                  ICC=CF%CELL_LIST(2,HIGH_IND,JCF); JCC=CF%CELL_LIST(3,HIGH_IND,JCF)
                  M3%REAL_SEND_PKG112(NQT2*(LL-1)+3) = M%CUT_CELL(ICC)%HS(JCC) ! HS_HI
               ENDDO
            ENDDO PACK_REAL_SEND_PKG112B
         ELSE
            PACK_REAL_SEND_PKG112B2: DO ICF1=1,M3%NICF_S(1)
               ICF=M3%ICF_UFFB_CF_S(ICF1); CF => M%CUT_FACE(ICF)
               DO JCF=1,CF%NFACE
                  CF%FN_OMESH(JCF) = CF%FN(JCF)
                  ! No need to copy H_LO and H_HI.
               ENDDO
            ENDDO PACK_REAL_SEND_PKG112B2
         ENDIF
      ENDIF

      ! Exchange Velocity and Pressure at end of CORRECTOR: To be used in RCEDGEs estimation of OMEGA and TAU next substep.

      IF (CODE==6 .AND. M3%NICF_S(1)>0) THEN
         NQT2 = 4
         LL   = 0
         IF (RNODE/=SNODE) THEN
            PACK_REAL_SEND_PKG112B3: DO ICF1=1,M3%NICF_S(1)
               ICF=M3%ICF_UFFB_CF_S(ICF1); CF => M%CUT_FACE(ICF)
               DO JCF=1,CF%NFACE
                  LL = LL + 1
                  M3%REAL_SEND_PKG112(NQT2*(LL-1)+1) = CF%VEL(JCF)
                  M3%REAL_SEND_PKG112(NQT2*(LL-1)+2) = CF%VEL_LNK(JCF)
                  ICC=CF%CELL_LIST(2,LOW_IND,JCF); JCC=CF%CELL_LIST(3,LOW_IND,JCF)
                  M3%REAL_SEND_PKG112(NQT2*(LL-1)+3) = M%CUT_CELL(ICC)%HS(JCC) ! H_LO
                  ICC=CF%CELL_LIST(2,HIGH_IND,JCF); JCC=CF%CELL_LIST(3,HIGH_IND,JCF)
                  M3%REAL_SEND_PKG112(NQT2*(LL-1)+4) = M%CUT_CELL(ICC)%HS(JCC) ! H_HI
               ENDDO
            ENDDO PACK_REAL_SEND_PKG112B3
         ELSE
            PACK_REAL_SEND_PKG112B4: DO ICF1=1,M3%NICF_S(1)
               ICF=M3%ICF_UFFB_CF_S(ICF1); CF => M%CUT_FACE(ICF)
               DO JCF=1,CF%NFACE
                  CF%VEL_OMESH(JCF)     = CF%VEL(JCF)
                  CF%VEL_LNK_OMESH(JCF) = CF%VEL_LNK(JCF)
                  ! No need to copy H_LO and H_HI.
               ENDDO
            ENDDO PACK_REAL_SEND_PKG112B4
         ENDIF
      ENDIF
      IF ((CODE==3 .OR. CODE==6) .AND. M3%NLKF_S>0) THEN
         IF (CODE==3) THEN
            UP => M%US ; VP => M%VS ; WP => M%WS
         ELSE
            UP => M%U  ; VP => M%V  ; WP => M%W
         ENDIF
         IF (RNODE/=SNODE) THEN
            LL = 4 * M3%NICF_S(2)
            DO KK=M3%K_MIN_S,M3%K_MAX_S
               DO JJ=M3%J_MIN_S,M3%J_MAX_S
                  DO II=M3%I_MIN_S,M3%I_MAX_S
                     ! U linked Velocity:
                     M3%REAL_SEND_PKG112(LL+1) = UP(II,JJ,KK)
                     IF (M%FCVAR(II,JJ,KK,CC_UNKF,IAXIS)>0) THEN ! Regular Face
                        M3%REAL_SEND_PKG112(LL+1) = M%UN_LNK(M%FCVAR(II,JJ,KK,CC_UNKF,IAXIS))
                     ELSEIF(M%FCVAR(II,JJ,KK,CC_IDRC,IAXIS)>0) THEN ! RC Face.
                        ICF=M%FCVAR(II,JJ,KK,CC_IDRC,IAXIS); IF(M%FCVAR(II,JJ,KK,CC_UNKF,IAXIS)>0) &
                        M3%REAL_SEND_PKG112(LL+1) = M%UN_LNK(M%RC_FACE(ICF)%UNKF)
                     ENDIF
                     ! V linked Velocity:
                     M3%REAL_SEND_PKG112(LL+2) = VP(II,JJ,KK)
                     IF (M%FCVAR(II,JJ,KK,CC_UNKF,JAXIS)>0) THEN ! Regular Face
                        M3%REAL_SEND_PKG112(LL+2) = M%UN_LNK(M%FCVAR(II,JJ,KK,CC_UNKF,JAXIS))
                     ELSEIF(M%FCVAR(II,JJ,KK,CC_IDRC,JAXIS)>0) THEN ! RC Face.
                        ICF=M%FCVAR(II,JJ,KK,CC_IDRC,JAXIS); IF(M%FCVAR(II,JJ,KK,CC_UNKF,JAXIS)>0) &
                        M3%REAL_SEND_PKG112(LL+2) = M%UN_LNK(M%RC_FACE(ICF)%UNKF)
                     ENDIF
                     ! W linked velocity:
                     M3%REAL_SEND_PKG112(LL+3) = WP(II,JJ,KK)
                     IF (M%FCVAR(II,JJ,KK,CC_UNKF,KAXIS)>0) THEN ! Regular Face
                        M3%REAL_SEND_PKG112(LL+3) = M%UN_LNK(M%FCVAR(II,JJ,KK,CC_UNKF,KAXIS))
                     ELSEIF(M%FCVAR(II,JJ,KK,CC_IDRC,KAXIS)>0) THEN ! RC Face.
                        ICF=M%FCVAR(II,JJ,KK,CC_IDRC,KAXIS); IF(M%FCVAR(II,JJ,KK,CC_UNKF,KAXIS)>0) &
                        M3%REAL_SEND_PKG112(LL+3) = M%UN_LNK(M%RC_FACE(ICF)%UNKF)
                     ENDIF
                     LL = LL+3
                  ENDDO
               ENDDO
            ENDDO
         ELSE
            M2=>MESHES(NOM)%OMESH(NM)
            UP2 => M2%U_LNK ; VP2 => M2%V_LNK ; WP2 => M2%W_LNK
            DO KK=M3%K_MIN_S,M3%K_MAX_S
               DO JJ=M3%J_MIN_S,M3%J_MAX_S
                  DO II=M3%I_MIN_S,M3%I_MAX_S
                     ! U linked Velocity:
                     UP2(II,JJ,KK) = UP(II,JJ,KK)
                     IF (M%FCVAR(II,JJ,KK,CC_UNKF,IAXIS)>0) THEN ! Regular Face
                        UP2(II,JJ,KK) = M%UN_LNK(M%FCVAR(II,JJ,KK,CC_UNKF,IAXIS))
                     ELSEIF(M%FCVAR(II,JJ,KK,CC_IDRC,IAXIS)>0) THEN ! RC Face.
                        ICF=M%FCVAR(II,JJ,KK,CC_IDRC,IAXIS); IF(M%FCVAR(II,JJ,KK,CC_UNKF,IAXIS)>0) &
                        UP2(II,JJ,KK) = M%UN_LNK(M%RC_FACE(ICF)%UNKF)
                     ENDIF
                     ! V linked Velocity:
                     VP2(II,JJ,KK) = VP(II,JJ,KK)
                     IF (M%FCVAR(II,JJ,KK,CC_UNKF,JAXIS)>0) THEN ! Regular Face
                        VP2(II,JJ,KK) = M%UN_LNK(M%FCVAR(II,JJ,KK,CC_UNKF,JAXIS))
                     ELSEIF(M%FCVAR(II,JJ,KK,CC_IDRC,JAXIS)>0) THEN ! RC Face.
                        ICF=M%FCVAR(II,JJ,KK,CC_IDRC,JAXIS); IF(M%FCVAR(II,JJ,KK,CC_UNKF,JAXIS)>0) &
                        VP2(II,JJ,KK) = M%UN_LNK(M%RC_FACE(ICF)%UNKF)
                     ENDIF
                     ! W linked velocity:
                     WP2(II,JJ,KK) = WP(II,JJ,KK)
                     IF (M%FCVAR(II,JJ,KK,CC_UNKF,KAXIS)>0) THEN ! Regular Face
                        WP2(II,JJ,KK) = M%UN_LNK(M%FCVAR(II,JJ,KK,CC_UNKF,KAXIS))
                     ELSEIF(M%FCVAR(II,JJ,KK,CC_IDRC,KAXIS)>0) THEN ! RC Face.
                        ICF=M%FCVAR(II,JJ,KK,CC_IDRC,KAXIS); IF(M%FCVAR(II,JJ,KK,CC_UNKF,KAXIS)>0) &
                        WP2(II,JJ,KK) = M%UN_LNK(M%RC_FACE(ICF)%UNKF)
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         ENDIF
      ENDIF
      IF (CODE==6 .AND. M3%NFCC_S(1)>0) THEN
         NQT2 = 1
         LL   = 0
         IF (RNODE/=SNODE) THEN
            PACK_REAL_SEND_PKG122 : DO IFC=1,M3%NFCC_S(1)
               I     = M3%IIO_FC_S(IFC)
               J     = M3%JJO_FC_S(IFC)
               K     = M3%KKO_FC_S(IFC)
               X1AXIS= M3%AXS_FC_S(IFC)
               LL = LL + 1
               SELECT CASE(X1AXIS)
               CASE(IAXIS)
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+1) = M%U(I,J,K)                            ! U^n+1 in x face I,J,K
               CASE(JAXIS)
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+1) = M%V(I,J,K)                            ! V^n+1 in y face I,J,K
               CASE(KAXIS)
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+1) = M%W(I,J,K)                            ! W^n+1 in z face I,J,K
               END SELECT
            ENDDO PACK_REAL_SEND_PKG122
         ELSE
            M2=>MESHES(NOM)%OMESH(NM)
            PACK_REAL_RECV_PKG122: DO IFEP=1,M2%NFEP_R(1)
               ICF = M2%IFEP_R_1( LOW_IND,IFEP)
               INPE= M2%IFEP_R_1(HIGH_IND,IFEP)
               LL  = M1%CUT_FACE(ICF)%INT_NOMIND(HIGH_IND,INPE)
               I     = M3%IIO_FC_S(LL)
               J     = M3%JJO_FC_S(LL)
               K     = M3%KKO_FC_S(LL)
               X1AXIS= M3%AXS_FC_S(LL)
               SELECT CASE(X1AXIS)
               CASE(IAXIS)
                  M1%CUT_FACE(ICF)%INT_FVARS( INT_VEL_IND,INPE) = M%U(I,J,K)                ! U^n+1 in x face I,J,K
               CASE(JAXIS)
                  M1%CUT_FACE(ICF)%INT_FVARS( INT_VEL_IND,INPE) = M%V(I,J,K)                ! V^n+1 in y face I,J,K
               CASE(KAXIS)
                  M1%CUT_FACE(ICF)%INT_FVARS( INT_VEL_IND,INPE) = M%W(I,J,K)                ! W^n+1 in z face I,J,K
               END SELECT
            ENDDO PACK_REAL_RECV_PKG122
            ! Second Loop cut-edges:
            PACK_REAL_RECV_PKG122E: DO IFEP=1,M2%NFEP_R(3)
               IEDGE= M2%IFEP_R_3( LOW_IND,IFEP)
               INPE = M2%IFEP_R_3(HIGH_IND,IFEP)
               LL   = M1%CC_RCEDGE(IEDGE)%INT_NOMIND(HIGH_IND,INPE)
               I     = M3%IIO_FC_S(LL)
               J     = M3%JJO_FC_S(LL)
               K     = M3%KKO_FC_S(LL)
               X1AXIS= M3%AXS_FC_S(LL)
               SELECT CASE(X1AXIS)
               CASE(IAXIS)
                  M1%CC_RCEDGE(IEDGE)%INT_FVARS(INT_VEL_IND,INPE) = M%U(I,J,K)             ! U^n+1 in x face I,J,K
               CASE(JAXIS)
                  M1%CC_RCEDGE(IEDGE)%INT_FVARS(INT_VEL_IND,INPE) = M%V(I,J,K)             ! V^n+1 in y face I,J,K
               CASE(KAXIS)
                  M1%CC_RCEDGE(IEDGE)%INT_FVARS(INT_VEL_IND,INPE) = M%W(I,J,K)             ! W^n+1 in z face I,J,K
               END SELECT
            ENDDO PACK_REAL_RECV_PKG122E
            PACK_REAL_RECV_PKG122EIB: DO IFEP=1,M2%NFEP_R(4)
               IEDGE= M2%IFEP_R_4( LOW_IND,IFEP)
               INPE = M2%IFEP_R_4(HIGH_IND,IFEP)
               LL   = M1%CC_IBEDGE(IEDGE)%INT_NOMIND(HIGH_IND,INPE)
               I     = M3%IIO_FC_S(LL)
               J     = M3%JJO_FC_S(LL)
               K     = M3%KKO_FC_S(LL)
               X1AXIS= M3%AXS_FC_S(LL)
               SELECT CASE(X1AXIS)
               CASE(IAXIS)
                  M1%CC_IBEDGE(IEDGE)%INT_FVARS(INT_VEL_IND,INPE) = M%U(I,J,K)             ! U^n+1 in x face I,J,K
               CASE(JAXIS)
                  M1%CC_IBEDGE(IEDGE)%INT_FVARS(INT_VEL_IND,INPE) = M%V(I,J,K)             ! V^n+1 in y face I,J,K
               CASE(KAXIS)
                  M1%CC_IBEDGE(IEDGE)%INT_FVARS(INT_VEL_IND,INPE) = M%W(I,J,K)             ! W^n+1 in z face I,J,K
               END SELECT
            ENDDO PACK_REAL_RECV_PKG122EIB
         ENDIF
      ENDIF

      ! Exchange H, RHO_0 and W velocity averaged to cell center, at PREDICTOR end of step:

      IF (CODE==3 .AND. M3%NFCC_S(2)>0) THEN
         NQT2 = 4
         LL   = 0
         IF (RNODE/=SNODE) THEN
            PACK_REAL_SEND_PKG13 : DO ICC=1,M3%NFCC_S(2)
               I     = M3%IIO_CC_S(ICC)
               J     = M3%JJO_CC_S(ICC)
               K     = M3%KKO_CC_S(ICC)
               LL = LL + 1
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+1) = M%H(I,J,K)                             ! H^n in cell I,J,K
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+2) = M%RHO_0(K)                             ! RHO_0 in cell I,J,K
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+3) = 0.5_EB*(M%WS(I,J,K-1)+M%WS(I,J,K))     ! Wcen^* in I,J,K.
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+4) = M%MU(I,J,K)                            ! MU in I,J,K
            ENDDO PACK_REAL_SEND_PKG13
         ELSE
            M2=>MESHES(NOM)%OMESH(NM)
            PACK_REAL_RECV_PKG13: DO ICC=1,M3%NFCC_S(2)
               I     = M3%IIO_CC_S(ICC)
               J     = M3%JJO_CC_S(ICC)
               K     = M3%KKO_CC_S(ICC)
               LL = LL + 1
               M2%REAL_RECV_PKG13(NQT2*(LL-1)+1) = M%H(I,J,K)                             ! H^n in cell I,J,K
               M2%REAL_RECV_PKG13(NQT2*(LL-1)+2) = M%RHO_0(K)                             ! RHO_0 in cell I,J,K
               M2%REAL_RECV_PKG13(NQT2*(LL-1)+3) = 0.5_EB*(M%WS(I,J,K-1)+M%WS(I,J,K))     ! Wcen^* in I,J,K.
               M2%REAL_RECV_PKG13(NQT2*(LL-1)+4) = M%MU(I,J,K)                            ! MU in I,J,K
            ENDDO PACK_REAL_RECV_PKG13
         ENDIF
      ENDIF

      ! Exchange H, RHO_0 and W velocity averaged to cell center, at CORRECTOR end of step:

      IF (CODE==6 .AND. M3%NFCC_S(2)>0) THEN
         NQT2 = 4
         LL   = 0
         IF (RNODE/=SNODE) THEN
            PACK_REAL_SEND_PKG113 : DO ICC=1,M3%NFCC_S(2)
               I     = M3%IIO_CC_S(ICC)
               J     = M3%JJO_CC_S(ICC)
               K     = M3%KKO_CC_S(ICC)
               LL = LL + 1
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+1) = M%HS(I,J,K)                            ! H^* in cell I,J,K
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+2) = M%RHO_0(K)                             ! RHO_0 in cell I,J,K
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+3) = 0.5_EB*(M%W(I,J,K-1)+M%W(I,J,K))       ! Wcen  in I,J,K.
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+4) = M%MU(I,J,K)                            ! MU in I,J,K
            ENDDO PACK_REAL_SEND_PKG113
         ELSE
            M2=>MESHES(NOM)%OMESH(NM)
            PACK_REAL_RECV_PKG113: DO ICC=1,M3%NFCC_S(2)
               I     = M3%IIO_CC_S(ICC)
               J     = M3%JJO_CC_S(ICC)
               K     = M3%KKO_CC_S(ICC)
               LL = LL + 1
               M2%REAL_RECV_PKG13(NQT2*(LL-1)+1) = M%HS(I,J,K)                            ! H^* in cell I,J,K
               M2%REAL_RECV_PKG13(NQT2*(LL-1)+2) = M%RHO_0(K)                             ! RHO_0 in cell I,J,K
               M2%REAL_RECV_PKG13(NQT2*(LL-1)+3) = 0.5_EB*(M%W(I,J,K-1)+M%W(I,J,K))       ! Wcen  in I,J,K.
               M2%REAL_RECV_PKG13(NQT2*(LL-1)+4) = M%MU(I,J,K)                            ! MU in I,J,K
            ENDDO PACK_REAL_RECV_PKG113
         ENDIF
      ENDIF

   ENDDO RECEIVING_MESH_LOOP_2
ENDDO SENDING_MESH_LOOP_2

! Exchange Scalars:
IF (N_MPI_PROCESSES>1 .AND. (CODE==1.OR.CODE==4) .AND. N_REQ11>0) THEN
   CALL MPI_STARTALL(N_REQ11,REQ11(1:N_REQ11),IERR)
   CALL CC_TIMEOUT('REQ11',N_REQ11,REQ11(1:N_REQ11))
ENDIF

! Exchange FVX,FVY,FVZ data for gas cut-faces:
IF (N_MPI_PROCESSES>1 .AND. ANY(CODE==(/3,5,6/)) .AND. N_REQ112>0) THEN
   CALL MPI_STARTALL(N_REQ112,REQ112(1:N_REQ112),IERR)
   CALL CC_TIMEOUT('REQ112',N_REQ112,REQ112(1:N_REQ112))
ENDIF

! Exchange End of Step velocity data for RCEDGEs:
IF (N_MPI_PROCESSES>1 .AND. (CODE==3.OR.CODE==6) .AND. N_REQ12>0) THEN
   CALL MPI_STARTALL(N_REQ12,REQ12(1:N_REQ12),IERR)
   CALL CC_TIMEOUT('REQ12',N_REQ12,REQ12(1:N_REQ12))
ENDIF

! Exchange scalar data End of step cell-centered data:
IF (N_MPI_PROCESSES>1 .AND. (CODE==1.OR.CODE==4.OR.CODE==3.OR.CODE==6) .AND. N_REQ13>0) THEN
   CALL MPI_STARTALL(N_REQ13,REQ13(1:N_REQ13),IERR)
   CALL CC_TIMEOUT('REQ13',N_REQ13,REQ13(1:N_REQ13))
ENDIF

! Receive the information sent above into the appropriate arrays.

RECV_MESH_LOOP: DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   M =>MESHES(NOM)

   SEND_MESH_LOOP: DO NM=1,NMESHES

      M2=>MESHES(NOM)%OMESH(NM)

      RNODE = PROCESS(NOM)
      SNODE = PROCESS(NM)

      RNODE_SNODE_IF: IF (RNODE/=SNODE) THEN

         ! Unpack densities and species mass fractions following PREDICTOR exchange

         IF (CODE==1 .AND. M2%NICC_R(1)>0) THEN
            NQT2 = 4+N_TOTAL_SCALARS
            LL   = 0
            ! Copy-cut cell scalar quantities from MESHES(NOM)%OMESH(NM) cells to MESHES(NM) (i.e. other mesh) cut-cells:
            ! Use External wall cell loop:
            EXTERNAL_WALL_LOOP_1 : DO IW=1,M%N_EXTERNAL_WALL_CELLS
               WC=>M%WALL(IW)
               EWC=>M%EXTERNAL_WALL(IW)
               BC=>M%BOUNDARY_COORD(WC%BC_INDEX)
               IF (.NOT.(WC%BOUNDARY_TYPE == INTERPOLATED_BOUNDARY)) CYCLE EXTERNAL_WALL_LOOP_1
               IF (EWC%NOM/=NM) CYCLE EXTERNAL_WALL_LOOP_1
               IF (M%CCVAR(BC%II,BC%JJ,BC%KK,CC_CGSC) /= CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_1
               DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
                  DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                     DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                       ICC   = MESHES(NM)%CCVAR(IIO,JJO,KKO,CC_IDCC)
                       IF (ICC > 0) THEN
                          DO JCC=1,MESHES(NM)%CUT_CELL(ICC)%NCELL
                             LL = LL + 1
                             MESHES(NM)%CUT_CELL(ICC)%RHOS(JCC) = M2%REAL_RECV_PKG11(NQT2*(LL-1)+1)
                             MESHES(NM)%CUT_CELL(ICC)%TMP(JCC)  = M2%REAL_RECV_PKG11(NQT2*(LL-1)+2)
                             MESHES(NM)%CUT_CELL(ICC)%RSUM(JCC) = M2%REAL_RECV_PKG11(NQT2*(LL-1)+3)
                             MESHES(NM)%CUT_CELL(ICC)%D(JCC)    = M2%REAL_RECV_PKG11(NQT2*(LL-1)+4)
                             DO NN=1,N_TOTAL_SCALARS
                                MESHES(NM)%CUT_CELL(ICC)%ZZS(NN,JCC) = M2%REAL_RECV_PKG11(NQT2*(LL-1)+4+NN)
                             ENDDO
                          ENDDO
                       ENDIF
                     ENDDO
                  ENDDO
               ENDDO
            ENDDO EXTERNAL_WALL_LOOP_1
         ENDIF

         IF((CODE==1 .OR. CODE==4) .AND. M2%NFCC_R(2)>0) THEN
            NQT2 = NQT2C+N_TOTAL_SCALARS
            DO IFEP=1,M2%NFEP_R(2)
               ICF = M2%IFEP_R_2( LOW_IND,IFEP)
               INPE= M2%IFEP_R_2(HIGH_IND,IFEP)
               LL  = M%CUT_FACE(ICF)%INT_NOMIND(HIGH_IND,INPE)
               M%CUT_FACE(ICF)%INT_CVARS(    INT_H_IND,INPE)= M2%REAL_RECV_PKG13(NQT2*(LL-1)+1)
               M%CUT_FACE(ICF)%INT_CVARS(  INT_RHO_IND,INPE)= M2%REAL_RECV_PKG13(NQT2*(LL-1)+4)
               M%CUT_FACE(ICF)%INT_CVARS(  INT_TMP_IND,INPE)= M2%REAL_RECV_PKG13(NQT2*(LL-1)+5)
               M%CUT_FACE(ICF)%INT_CVARS( INT_RSUM_IND,INPE)= M2%REAL_RECV_PKG13(NQT2*(LL-1)+6)
               M%CUT_FACE(ICF)%INT_CVARS(   INT_MU_IND,INPE)= M2%REAL_RECV_PKG13(NQT2*(LL-1)+7)
               M%CUT_FACE(ICF)%INT_CVARS(INT_MUDNS_IND,INPE)= M2%REAL_RECV_PKG13(NQT2*(LL-1)+8)
               M%CUT_FACE(ICF)%INT_CVARS(    INT_P_IND,INPE)= M2%REAL_RECV_PKG13(NQT2*(LL-1)+NQT2C)
               DO NN=1,N_TOTAL_SCALARS
                  M%CUT_FACE(ICF)%INT_CVARS(INT_P_IND+NN,INPE)=M2%REAL_RECV_PKG13(NQT2*(LL-1)+NQT2C+NN)
               ENDDO
            ENDDO
         ENDIF

         ! Unpack velocity, momentum rhs and previous substep dH/Dx1 for cut-faces, in PREDICTOR or CORRECTOR, IBM forcing:
         IF (CODE==5  .AND. M2%NICF_R(1)>0) THEN
         NQT2 = 4
         LL   = 0
         EXTERNAL_WALL_LOOP_112A : DO IW=1,M%N_EXTERNAL_WALL_CELLS
            WC=>M%WALL(IW); IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE EXTERNAL_WALL_LOOP_112A
            EWC=>M%EXTERNAL_WALL(IW); IF (EWC%NOM/=NM) CYCLE EXTERNAL_WALL_LOOP_112A
            BC=>M%BOUNDARY_COORD(WC%BC_INDEX); IIO = BC%IIG; JJO = BC%JJG; KKO = BC%KKG
            SELECT CASE(BC%IOR)
            CASE( IAXIS); IF(M%FCVAR(IIO-1,JJO  ,KKO  ,CC_FGSC,IAXIS)/=CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_112A
            CASE(-IAXIS); IF(M%FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,IAXIS)/=CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_112A
            CASE( JAXIS); IF(M%FCVAR(IIO  ,JJO-1,KKO  ,CC_FGSC,JAXIS)/=CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_112A
            CASE(-JAXIS); IF(M%FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,JAXIS)/=CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_112A
            CASE( KAXIS); IF(M%FCVAR(IIO  ,JJO  ,KKO-1,CC_FGSC,KAXIS)/=CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_112A
            CASE(-KAXIS); IF(M%FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,KAXIS)/=CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_112A
            END SELECT
            DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
               DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                  DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                   SELECT CASE(-BC%IOR)
                   CASE( IAXIS); ICF=MESHES(NM)%FCVAR(IIO-1,JJO  ,KKO  ,CC_IDCF,IAXIS)
                   CASE(-IAXIS); ICF=MESHES(NM)%FCVAR(IIO  ,JJO  ,KKO  ,CC_IDCF,IAXIS)
                   CASE( JAXIS); ICF=MESHES(NM)%FCVAR(IIO  ,JJO-1,KKO  ,CC_IDCF,JAXIS)
                   CASE(-JAXIS); ICF=MESHES(NM)%FCVAR(IIO  ,JJO  ,KKO  ,CC_IDCF,JAXIS)
                   CASE( KAXIS); ICF=MESHES(NM)%FCVAR(IIO  ,JJO  ,KKO-1,CC_IDCF,KAXIS)
                   CASE(-KAXIS); ICF=MESHES(NM)%FCVAR(IIO  ,JJO  ,KKO  ,CC_IDCF,KAXIS)
                   END SELECT
                   IF (ICF > 0) THEN
                      CF => MESHES(NM)%CUT_FACE(ICF)
                      DO JCF=1,CF%NFACE
                         LL = LL + 1
                         CF%FN_OMESH(JCF)   = M2%REAL_RECV_PKG112(NQT2*(LL-1)+1)
                         ICC =CF%CELL_LIST(2, LOW_IND,JCF); JCC =CF%CELL_LIST(3, LOW_IND,JCF)
                         ICC1=CF%CELL_LIST(2,HIGH_IND,JCF); JCC1=CF%CELL_LIST(3,HIGH_IND,JCF)
                         IF(PREDICTOR) THEN
                            MESHES(NM)%CUT_CELL(ICC )%H(JCC )  = M2%REAL_RECV_PKG112(NQT2*(LL-1)+2)
                            MESHES(NM)%CUT_CELL(ICC1)%H(JCC1)  = M2%REAL_RECV_PKG112(NQT2*(LL-1)+3)
                         ELSE
                            MESHES(NM)%CUT_CELL(ICC )%HS(JCC ) = M2%REAL_RECV_PKG112(NQT2*(LL-1)+2)
                            MESHES(NM)%CUT_CELL(ICC1)%HS(JCC1) = M2%REAL_RECV_PKG112(NQT2*(LL-1)+3)
                         ENDIF
                      ENDDO
                   ENDIF
                  ENDDO
               ENDDO
            ENDDO
         ENDDO EXTERNAL_WALL_LOOP_112A
         ENDIF

         IF (CODE==3 .AND. M2%NFCC_R(1)>0) THEN
            NQT2 = 1
            ! First loop cut-faces:
            DO IFEP=1,M2%NFEP_R(1) ! Gasphase and Boundary cut-faces:
               ICF = M2%IFEP_R_1( LOW_IND,IFEP);
               INPE= M2%IFEP_R_1(HIGH_IND,IFEP)
               LL  = M%CUT_FACE(ICF)%INT_NOMIND(HIGH_IND,INPE)
               M%CUT_FACE(ICF)%INT_FVARS(INT_VELS_IND,INPE)= M2%REAL_RECV_PKG12(NQT2*(LL-1)+1) ! Vel^*
            ENDDO
            ! Second Loop cut-edges:
            DO IFEP=1,M2%NFEP_R(3)
               IEDGE= M2%IFEP_R_3( LOW_IND,IFEP)
               INPE = M2%IFEP_R_3(HIGH_IND,IFEP)
               LL   = M%CC_RCEDGE(IEDGE)%INT_NOMIND(HIGH_IND,INPE)
               M%CC_RCEDGE(IEDGE)%INT_FVARS(INT_VEL_IND,INPE)= M2%REAL_RECV_PKG12(NQT2*(LL-1)+1) ! Vel^*, added to INT_VEL_IND pos.
            ENDDO
            DO IFEP=1,M2%NFEP_R(4)
               IEDGE= M2%IFEP_R_4( LOW_IND,IFEP)
               INPE = M2%IFEP_R_4(HIGH_IND,IFEP)
               LL   = M%CC_IBEDGE(IEDGE)%INT_NOMIND(HIGH_IND,INPE)
               M%CC_IBEDGE(IEDGE)%INT_FVARS(INT_VEL_IND,INPE)= M2%REAL_RECV_PKG12(NQT2*(LL-1)+1) ! Vel^*, added to INT_VEL_IND pos.
            ENDDO
         ENDIF
         IF(CODE==3 .AND. M2%NICF_R(1)>0) THEN
            NQT2 = 4
            LL   = 0
            EXTERNAL_WALL_LOOP_112B : DO IW=1,M%N_EXTERNAL_WALL_CELLS
               WC=>M%WALL(IW); IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE EXTERNAL_WALL_LOOP_112B
               EWC=>M%EXTERNAL_WALL(IW); IF (EWC%NOM/=NM)   CYCLE EXTERNAL_WALL_LOOP_112B
               BC=>M%BOUNDARY_COORD(WC%BC_INDEX); IIO = BC%IIG; JJO = BC%JJG; KKO = BC%KKG
               SELECT CASE(BC%IOR)
               CASE( IAXIS); IF(M%FCVAR(IIO-1,JJO  ,KKO  ,CC_FGSC,IAXIS)/=CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_112B
               CASE(-IAXIS); IF(M%FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,IAXIS)/=CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_112B
               CASE( JAXIS); IF(M%FCVAR(IIO  ,JJO-1,KKO  ,CC_FGSC,JAXIS)/=CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_112B
               CASE(-JAXIS); IF(M%FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,JAXIS)/=CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_112B
               CASE( KAXIS); IF(M%FCVAR(IIO  ,JJO  ,KKO-1,CC_FGSC,KAXIS)/=CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_112B
               CASE(-KAXIS); IF(M%FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,KAXIS)/=CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_112B
               END SELECT
               DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
                  DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                     DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                        SELECT CASE(-BC%IOR)
                        CASE( IAXIS); ICF=MESHES(NM)%FCVAR(IIO-1,JJO  ,KKO  ,CC_IDCF,IAXIS)
                        CASE(-IAXIS); ICF=MESHES(NM)%FCVAR(IIO  ,JJO  ,KKO  ,CC_IDCF,IAXIS)
                        CASE( JAXIS); ICF=MESHES(NM)%FCVAR(IIO  ,JJO-1,KKO  ,CC_IDCF,JAXIS)
                        CASE(-JAXIS); ICF=MESHES(NM)%FCVAR(IIO  ,JJO  ,KKO  ,CC_IDCF,JAXIS)
                        CASE( KAXIS); ICF=MESHES(NM)%FCVAR(IIO  ,JJO  ,KKO-1,CC_IDCF,KAXIS)
                        CASE(-KAXIS); ICF=MESHES(NM)%FCVAR(IIO  ,JJO  ,KKO  ,CC_IDCF,KAXIS)
                        END SELECT
                        IF (ICF > 0) THEN
                           CF => MESHES(NM)%CUT_FACE(ICF)
                           DO JCF=1,CF%NFACE
                              LL = LL + 1
                              CF%VELS_OMESH(JCF)   = M2%REAL_RECV_PKG112(NQT2*(LL-1)+1)
                              CF%VEL_LNK_OMESH(JCF)= M2%REAL_RECV_PKG112(NQT2*(LL-1)+2)
                              ICC =CF%CELL_LIST(2, LOW_IND,JCF); JCC =CF%CELL_LIST(3, LOW_IND,JCF)
                              ICC1=CF%CELL_LIST(2,HIGH_IND,JCF); JCC1=CF%CELL_LIST(3,HIGH_IND,JCF)
                              MESHES(NM)%CUT_CELL(ICC )%H(JCC )  = M2%REAL_RECV_PKG112(NQT2*(LL-1)+3)
                              MESHES(NM)%CUT_CELL(ICC1)%H(JCC1)  = M2%REAL_RECV_PKG112(NQT2*(LL-1)+4)
                           ENDDO
                        ENDIF
                     ENDDO
                  ENDDO
               ENDDO
            ENDDO EXTERNAL_WALL_LOOP_112B
         ENDIF

         ! Unpack densities and species mass fractions following CORRECTOR exchange

         IF (CODE==4 .AND. M2%NICC_R(1)>0) THEN
            NQT2 = 4+N_TOTAL_SCALARS
            LL   = 0
            ! Copy-cut cell scalar quantities from MESHES(NOM)%OMESH(NM) cells to MESHES(NM) (i.e. other mesh) cut-cells:
            ! Use External wall cell loop:
            EXTERNAL_WALL_LOOP_2 : DO IW=1,M%N_EXTERNAL_WALL_CELLS
               WC=>M%WALL(IW)
               IF (.NOT.(WC%BOUNDARY_TYPE == INTERPOLATED_BOUNDARY)) CYCLE EXTERNAL_WALL_LOOP_2
               BC=>M%BOUNDARY_COORD(WC%BC_INDEX)
               EWC=>M%EXTERNAL_WALL(IW)
               IF (EWC%NOM/=NM) CYCLE EXTERNAL_WALL_LOOP_2
               IF (M%CCVAR(BC%II,BC%JJ,BC%KK,CC_CGSC) /= CC_CUTCFE) &
                  CYCLE EXTERNAL_WALL_LOOP_2
               DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
                  DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                     DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                       ICC   = MESHES(NM)%CCVAR(IIO,JJO,KKO,CC_IDCC)
                       IF (ICC > 0) THEN
                          DO JCC=1,MESHES(NM)%CUT_CELL(ICC)%NCELL
                             LL = LL + 1
                             MESHES(NM)%CUT_CELL(ICC)%RHO(JCC)  = M2%REAL_RECV_PKG11(NQT2*(LL-1)+1)
                             MESHES(NM)%CUT_CELL(ICC)%TMP(JCC)  = M2%REAL_RECV_PKG11(NQT2*(LL-1)+2)
                             MESHES(NM)%CUT_CELL(ICC)%RSUM(JCC) = M2%REAL_RECV_PKG11(NQT2*(LL-1)+3)
                             MESHES(NM)%CUT_CELL(ICC)%DS(JCC)   = M2%REAL_RECV_PKG11(NQT2*(LL-1)+4)
                             DO NN=1,N_TOTAL_SCALARS
                                MESHES(NM)%CUT_CELL(ICC)%ZZ(NN,JCC) = M2%REAL_RECV_PKG11(NQT2*(LL-1)+4+NN)
                             ENDDO
                          ENDDO
                       ENDIF
                     ENDDO
                  ENDDO
               ENDDO
            ENDDO EXTERNAL_WALL_LOOP_2
         ENDIF

         IF (CODE==6 .AND. M2%NFCC_R(1)>0) THEN
            NQT2 = 1
            ! First loop cut-faces:
            DO IFEP=1,M2%NFEP_R(1) ! Gasphase and Boundary cut-faces:
               ICF = M2%IFEP_R_1( LOW_IND,IFEP);
               INPE= M2%IFEP_R_1(HIGH_IND,IFEP)
               LL  = M%CUT_FACE(ICF)%INT_NOMIND(HIGH_IND,INPE)
               M%CUT_FACE(ICF)%INT_FVARS(INT_VEL_IND,INPE)= M2%REAL_RECV_PKG12(NQT2*(LL-1)+1) ! Vel^n+1
            ENDDO
            ! Second Loop cut-edges:
            DO IFEP=1,M2%NFEP_R(3)
               IEDGE= M2%IFEP_R_3( LOW_IND,IFEP)
               INPE = M2%IFEP_R_3(HIGH_IND,IFEP)
               LL   = M%CC_RCEDGE(IEDGE)%INT_NOMIND(HIGH_IND,INPE)
               M%CC_RCEDGE(IEDGE)%INT_FVARS(INT_VEL_IND,INPE)= M2%REAL_RECV_PKG12(NQT2*(LL-1)+1) ! Vel^n+1
            ENDDO
            DO IFEP=1,M2%NFEP_R(4)
               IEDGE= M2%IFEP_R_4( LOW_IND,IFEP)
               INPE = M2%IFEP_R_4(HIGH_IND,IFEP)
               LL   = M%CC_IBEDGE(IEDGE)%INT_NOMIND(HIGH_IND,INPE)
               M%CC_IBEDGE(IEDGE)%INT_FVARS(INT_VEL_IND,INPE)= M2%REAL_RECV_PKG12(NQT2*(LL-1)+1) ! Vel^n+1
            ENDDO
         ENDIF
         IF(CODE==6 .AND. M2%NICF_R(1)>0) THEN
            NQT2 = 4
            LL   = 0
            EXTERNAL_WALL_LOOP_112C : DO IW=1,M%N_EXTERNAL_WALL_CELLS
               WC=>M%WALL(IW); IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE EXTERNAL_WALL_LOOP_112C
               EWC=>M%EXTERNAL_WALL(IW); IF (EWC%NOM/=NM) CYCLE EXTERNAL_WALL_LOOP_112C
               BC=>M%BOUNDARY_COORD(WC%BC_INDEX); IIO = BC%IIG; JJO = BC%JJG; KKO = BC%KKG
               SELECT CASE(BC%IOR)
               CASE( IAXIS); IF(M%FCVAR(IIO-1,JJO  ,KKO  ,CC_FGSC,IAXIS)/=CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_112C
               CASE(-IAXIS); IF(M%FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,IAXIS)/=CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_112C
               CASE( JAXIS); IF(M%FCVAR(IIO  ,JJO-1,KKO  ,CC_FGSC,JAXIS)/=CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_112C
               CASE(-JAXIS); IF(M%FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,JAXIS)/=CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_112C
               CASE( KAXIS); IF(M%FCVAR(IIO  ,JJO  ,KKO-1,CC_FGSC,KAXIS)/=CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_112C
               CASE(-KAXIS); IF(M%FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,KAXIS)/=CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_112C
               END SELECT
               DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
                  DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                     DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                      SELECT CASE(-BC%IOR)
                      CASE( IAXIS); ICF=MESHES(NM)%FCVAR(IIO-1,JJO  ,KKO  ,CC_IDCF,IAXIS)
                      CASE(-IAXIS); ICF=MESHES(NM)%FCVAR(IIO  ,JJO  ,KKO  ,CC_IDCF,IAXIS)
                      CASE( JAXIS); ICF=MESHES(NM)%FCVAR(IIO  ,JJO-1,KKO  ,CC_IDCF,JAXIS)
                      CASE(-JAXIS); ICF=MESHES(NM)%FCVAR(IIO  ,JJO  ,KKO  ,CC_IDCF,JAXIS)
                      CASE( KAXIS); ICF=MESHES(NM)%FCVAR(IIO  ,JJO  ,KKO-1,CC_IDCF,KAXIS)
                      CASE(-KAXIS); ICF=MESHES(NM)%FCVAR(IIO  ,JJO  ,KKO  ,CC_IDCF,KAXIS)
                      END SELECT
                      IF (ICF > 0) THEN
                         CF => MESHES(NM)%CUT_FACE(ICF)
                         DO JCF=1,CF%NFACE
                            LL = LL + 1
                            CF%VEL_OMESH(JCF)    = M2%REAL_RECV_PKG112(NQT2*(LL-1)+1)
                            CF%VEL_LNK_OMESH(JCF)= M2%REAL_RECV_PKG112(NQT2*(LL-1)+2)
                            ICC =CF%CELL_LIST(2, LOW_IND,JCF); JCC =CF%CELL_LIST(3, LOW_IND,JCF)
                            ICC1=CF%CELL_LIST(2,HIGH_IND,JCF); JCC1=CF%CELL_LIST(3,HIGH_IND,JCF)
                            MESHES(NM)%CUT_CELL(ICC )%HS(JCC )  = M2%REAL_RECV_PKG112(NQT2*(LL-1)+3)
                            MESHES(NM)%CUT_CELL(ICC1)%HS(JCC1)  = M2%REAL_RECV_PKG112(NQT2*(LL-1)+4)
                         ENDDO
                      ENDIF
                     ENDDO
                  ENDDO
               ENDDO
            ENDDO EXTERNAL_WALL_LOOP_112C
         ENDIF
         IF ((CODE==3.OR.CODE==6) .AND. M2%NLKF_R>0) THEN
            UP2 => M2%U_LNK ; VP2 => M2%V_LNK ; WP2 => M2%W_LNK
            LL = 4 * M2%NICF_R(2)
            DO KK=M2%K_MIN_R,M2%K_MAX_R
               DO JJ=M2%J_MIN_R,M2%J_MAX_R
                  DO II=M2%I_MIN_R,M2%I_MAX_R
                     UP2(II,JJ,KK) = M2%REAL_RECV_PKG112(LL+1)
                     VP2(II,JJ,KK) = M2%REAL_RECV_PKG112(LL+2)
                     WP2(II,JJ,KK) = M2%REAL_RECV_PKG112(LL+3)
                     LL = LL+3
                  ENDDO
               ENDDO
            ENDDO
         ENDIF

      ENDIF RNODE_SNODE_IF

      ! Unpack H, RHO_0 and W velocity averaged to cell center, at PREDICTOR or CORRECTOR end of step:

      IF ( (CODE==3 .OR. CODE==6) .AND. M2%NFCC_R(2)>0) THEN
         NQT2 = 4
         ! First loop cut-cells:
         VIND = 0
         DO ICC=1,M%N_CUTCELL_MESH
            DO ICELL=0,M%CUT_CELL(ICC)%NCELL
               DO EP=1,INT_N_EXT_PTS  ! External point for cell ICELL
                  INT_NPE_LO = M%CUT_CELL(ICC)%INT_NPE(LOW_IND,VIND,EP,ICELL)
                  INT_NPE_HI = M%CUT_CELL(ICC)%INT_NPE(HIGH_IND,VIND,EP,ICELL)
                  DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
                     IF (M%CUT_CELL(ICC)%INT_NOMIND( LOW_IND,INPE) /= NM) CYCLE
                     LL     = M%CUT_CELL(ICC)%INT_NOMIND(HIGH_IND,INPE)
                     M%CUT_CELL(ICC)%INT_CCVARS(   INT_H_IND,INPE)= M2%REAL_RECV_PKG13(NQT2*(LL-1)+1) ! H^n, or H^s
                     M%CUT_CELL(ICC)%INT_CCVARS(INT_RHO0_IND,INPE)= M2%REAL_RECV_PKG13(NQT2*(LL-1)+2) ! RHO_0
                     M%CUT_CELL(ICC)%INT_CCVARS(INT_WCEN_IND,INPE)= M2%REAL_RECV_PKG13(NQT2*(LL-1)+3) ! Wcen^*, or Wcen^n+1
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
         ! Then Loop IBEDGES:
         DO IFEP=1,M2%NFEP_R(5)
            IEDGE= M2%IFEP_R_5( LOW_IND,IFEP)
            INPE = M2%IFEP_R_5(HIGH_IND,IFEP)
            LL   = M%CC_IBEDGE(IEDGE)%INT_NOMIND(HIGH_IND,INPE)
            M%CC_IBEDGE(IEDGE)%INT_CVARS(INT_MU_IND,INPE)= M2%REAL_RECV_PKG13(NQT2*(LL-1)+4) ! MU.
         ENDDO
      ENDIF

   ENDDO SEND_MESH_LOOP
ENDDO RECV_MESH_LOOP

T_USED(11) = T_USED(11) + CURRENT_TIME() - TNOW ! Add communication time to COMM column.

TINTP= CURRENT_TIME()
IF(CODE==1 .OR. CODE==4) THEN
  CALL FILL_GCCUTCELL_SPECIES
ELSEIF(CODE==3 .OR. CODE==6) THEN
   CALL CC_H_INTERP
   CALL CC_RHO0W_INTERP
ENDIF
T_USED(14) = T_USED(14) + CURRENT_TIME() - TINTP ! Add interpolation time to GEOM column.

IF (TIME_CC_IBM) T_CC_USED(MESH_CC_EXCHANGE_TIME_INDEX) = T_CC_USED(MESH_CC_EXCHANGE_TIME_INDEX) + CURRENT_TIME() - TNOW

RETURN

CONTAINS

SUBROUTINE FILL_GCCUTCELL_SPECIES


REAL(EB):: PRFCT, VCELL, RHO_CC, TMP_CC, RSUM_CC, D_CC, ZZ_CC(1:N_TOTAL_SCALARS), VOL
TYPE (OMESH_TYPE), POINTER :: OM
TYPE(CC_CUTCELL_TYPE), POINTER :: OCC
INTEGER :: NM,NOM,NN,ICC,JCC,IW,IIO,JJO,KKO

! Here inject OMESH cut-cell info obtained in MESH_CC_EXCHANGE into ghost-cell cc containers:
PRFCT = 0._EB; IF (PREDICTOR) PRFCT = 1._EB
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   CALL POINT_TO_MESH(NM)
   EXTERNAL_WALL_LOOP : DO IW=1,N_EXTERNAL_WALL_CELLS
      WC=>WALL(IW)
      IF (.NOT.(WC%BOUNDARY_TYPE == INTERPOLATED_BOUNDARY)) CYCLE EXTERNAL_WALL_LOOP
      BC=>BOUNDARY_COORD(WC%BC_INDEX)
      EWC=>EXTERNAL_WALL(IW)
      IF (CCVAR(BC%II,BC%JJ,BC%KK,CC_CGSC) /= CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP
      ! Do volume average to a cell container for ghost cell II,JJ,KK:
      NOM = EWC%NOM
      OM  => MESHES(NM)%OMESH(NOM)
      RHO_CC=0._EB; TMP_CC=0._EB; RSUM_CC=0._EB; D_CC=0._EB; ZZ_CC(1:N_TOTAL_SCALARS)=0._EB; VOL=0._EB
      DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
         DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
            DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
              IF (MESHES(NOM)%CELL(MESHES(NOM)%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
              ICC   = MESHES(NOM)%CCVAR(IIO,JJO,KKO,CC_IDCC)
              IF (ICC > 0) THEN ! Cut-cells:
                 OCC => MESHES(NOM)%CUT_CELL(ICC)
                 DO JCC=1,OCC%NCELL
                    VCELL   = OCC%VOLUME(JCC)
                    RHO_CC  = RHO_CC  + (PRFCT *OCC%RHOS(JCC) + (1._EB-PRFCT)*OCC%RHO(JCC))*VCELL
                    TMP_CC  = TMP_CC  + OCC%TMP(JCC)*VCELL
                    RSUM_CC = RSUM_CC + OCC%RSUM(JCC)*VCELL
                    D_CC    = D_CC    + (PRFCT *OCC%D(JCC) + (1._EB-PRFCT)*OCC%DS(JCC))*VCELL
                    DO NN=1,N_TOTAL_SCALARS
                       ZZ_CC(NN) = ZZ_CC(NN) + (PRFCT *OCC%ZZS(NN,JCC) + (1._EB-PRFCT)*OCC%ZZ(NN,JCC))*VCELL
                    ENDDO
                    VOL     = VOL  + VCELL
                 ENDDO
              ELSEIF(MESHES(NOM)%CCVAR(IIO,JJO,KKO,CC_CGSC) == CC_GASPHASE) THEN ! Regular cell:
                 VCELL = MESHES(NOM)%DX(IIO)*MESHES(NOM)%DY(JJO)*MESHES(NOM)%DZ(KKO)
                 RHO_CC  = RHO_CC + (PRFCT*RHOS(BC%II,BC%JJ,BC%KK) + (1._EB-PRFCT)*RHO(BC%II,BC%JJ,BC%KK))*VCELL
                 TMP_CC  = TMP_CC + TMP(BC%II,BC%JJ,BC%KK)*VCELL
                 D_CC    = D_CC   + (PRFCT*D(BC%II,BC%JJ,BC%KK) + (1._EB-PRFCT)*DS(BC%II,BC%JJ,BC%KK))*VCELL
                 DO NN=1,N_TOTAL_SCALARS
                 ZZ_CC(NN)=ZZ_CC(NN)+(PRFCT*ZZS(BC%II,BC%JJ,BC%KK,NN)+(1._EB-PRFCT)*ZZ(BC%II,BC%JJ,BC%KK,NN))*VCELL
                 ENDDO
                 VOL     = VOL + VCELL
              ENDIF
            ENDDO
         ENDDO
      ENDDO
      ! Add volume averaged variables into ghost cut-cell:
      ICC   = CCVAR(BC%II,BC%JJ,BC%KK,CC_IDCC)
      IF (PREDICTOR) THEN
         DO JCC=1,CUT_CELL(ICC)%NCELL
            CUT_CELL(ICC)%RHOS(JCC) = RHO_CC/VOL
            CUT_CELL(ICC)%TMP(JCC)  = TMP_CC/VOL
            CUT_CELL(ICC)%RSUM(JCC) = RSUM_CC/VOL
            CUT_CELL(ICC)%D(JCC)    = D_CC/VOL
            CUT_CELL(ICC)%ZZS(1:N_TOTAL_SCALARS,JCC) = ZZ_CC(1:N_TOTAL_SCALARS)/VOL
         ENDDO
      ELSE
         DO JCC=1,CUT_CELL(ICC)%NCELL
            CUT_CELL(ICC)%RHO(JCC)   = RHO_CC/VOL
            CUT_CELL(ICC)%TMP(JCC)   = TMP_CC/VOL
            !CUT_CELL(ICC)%RSUM(JCC) = RSUM_CC/VOL
            CUT_CELL(ICC)%DS(JCC)    = D_CC/VOL
            CUT_CELL(ICC)%ZZ(1:N_TOTAL_SCALARS,JCC) = ZZ_CC(1:N_TOTAL_SCALARS)/VOL
         ENDDO
     ENDIF
   ENDDO EXTERNAL_WALL_LOOP
ENDDO MESH_LOOP


END SUBROUTINE FILL_GCCUTCELL_SPECIES


SUBROUTINE CC_TIMEOUT(RNAME,NR,RR)

REAL(EB) :: START_TIME,WAIT_TIME
INTEGER :: NR
TYPE (MPI_REQUEST), DIMENSION(:) :: RR
LOGICAL :: FLAG
CHARACTER(*) :: RNAME

IF (.NOT.PROFILING) THEN

   START_TIME = MPI_WTIME()
   FLAG = .FALSE.
   DO WHILE(.NOT.FLAG)
      CALL MPI_TESTALL(NR,RR(1:NR),FLAG,MPI_STATUSES_IGNORE,IERR)
      WAIT_TIME = MPI_WTIME() - START_TIME
      IF (WAIT_TIME>MPI_TIMEOUT) THEN
         WRITE(LU_ERR,'(A,A,A,I6,A,A)') 'CC_TIMEOUT Error: ',TRIM(RNAME),' timed out for MPI process ',MY_RANK
         CALL MPI_ABORT(MPI_COMM_WORLD,0,IERR)
      ENDIF
   ENDDO
ELSE

   CALL MPI_WAITALL(NR,RR(1:NR),MPI_STATUSES_IGNORE,IERR)

ENDIF

END SUBROUTINE CC_TIMEOUT

END SUBROUTINE MESH_CC_EXCHANGE


SUBROUTINE CC_MATCH_VELOCITY_FLUX(NM)

! NOTE : Assumes POINT_TO_MESH(NM) has been called.

INTEGER, INTENT(IN) :: NM

! Local Variables:
INTEGER  :: NOM,II,JJ,KK,IOR,IW,IIO,JJO,KKO,ICF,JCF,ICFO,JCFO
REAL(EB) :: T_NOW,DA_OTHER,FN_OTHER
TYPE (OMESH_TYPE), POINTER :: OM
TYPE (MESH_TYPE), POINTER :: M2
TYPE (CC_CUTFACE_TYPE), POINTER :: CFO
CALL POINT_TO_MESH(NM)

T_NOW = CURRENT_TIME()

! Assign local variable names

CALL POINT_TO_MESH(NM)

! Loop over all cell edges and determine the appropriate velocity BCs

EXTERNAL_WALL_LOOP: DO IW=1,N_EXTERNAL_WALL_CELLS

   WC=>WALL(IW)
   EWC=>EXTERNAL_WALL(IW)
   IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE EXTERNAL_WALL_LOOP

   BC => BOUNDARY_COORD(WC%BC_INDEX)
   II  = BC%II
   JJ  = BC%JJ
   KK  = BC%KK
   IOR = BC%IOR
   NOM = EWC%NOM
   OM => OMESH(NOM)
   M2 => MESHES(NOM)

   ! Determine the area of the interpolated cell face

   DA_OTHER = 0._EB
   FN_OTHER = 0._EB

   ! Determine the normal component of velocity flux from the other mesh and use it for average

   SELECT CASE(IOR)

      CASE( 1)

         ICF = FCVAR(0,JJ,KK,CC_IDCF,ABS(IOR))
         DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
            DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
               DO IIO=EWC%IIO_MIN,EWC%IIO_MAX

                  IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE ! Drop if OMESH cell is solid.
                  IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE  ! Drop if solid cart face.
                  ICFO = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,ABS(IOR))
                  IF(ICFO>0) THEN
                     CFO => M2%CUT_FACE(ICFO)
                     DO JCFO=1,CFO%NFACE
                        DA_OTHER = DA_OTHER + CFO%AREA(JCFO)
                        FN_OTHER = FN_OTHER + CFO%FN_OMESH(JCFO)*CFO%AREA(JCFO)
                     ENDDO
                  ELSE
                     DA_OTHER = DA_OTHER + M2%DY(JJO)*M2%DZ(KKO)
                     FN_OTHER = FN_OTHER + OM%FVX(IIO,JJO,KKO)*M2%DY(JJO)*M2%DZ(KKO)
                  ENDIF
               ENDDO
            ENDDO
         ENDDO
         IF(ICF<1) FVX(0,JJ,KK) = 0.5_EB*(FVX(0,JJ,KK) + FN_OTHER/DA_OTHER)

      CASE(-1)

         ICF = FCVAR(IBAR,JJ,KK,CC_IDCF,ABS(IOR))
         DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
            DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
               DO IIO=EWC%IIO_MIN,EWC%IIO_MAX

                  IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                  IF (M2%FCVAR(IIO-1,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE

                  ICFO = M2%FCVAR(IIO-1,JJO,KKO,CC_IDCF,ABS(IOR))
                  IF(ICFO>0) THEN
                     CFO => M2%CUT_FACE(ICFO)
                     DO JCFO=1,CFO%NFACE
                        DA_OTHER = DA_OTHER + CFO%AREA(JCFO)
                        FN_OTHER = FN_OTHER + CFO%FN_OMESH(JCFO)*CFO%AREA(JCFO)
                     ENDDO
                  ELSE
                     DA_OTHER = DA_OTHER + M2%DY(JJO)*M2%DZ(KKO)
                     FN_OTHER = FN_OTHER + OM%FVX(IIO-1,JJO,KKO)*M2%DY(JJO)*M2%DZ(KKO)
                  ENDIF
               ENDDO
            ENDDO
         ENDDO
         IF(ICF<1) FVX(IBAR,JJ,KK) = 0.5_EB*(FVX(IBAR,JJ,KK) + FN_OTHER/DA_OTHER)

      CASE( 2)

         ICF = FCVAR(II,0,KK,CC_IDCF,ABS(IOR))
         DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
            DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
               DO IIO=EWC%IIO_MIN,EWC%IIO_MAX

                  IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                  IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE

                  ICFO = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,ABS(IOR))
                  IF(ICFO>0) THEN
                     CFO => M2%CUT_FACE(ICFO)
                     DO JCFO=1,CFO%NFACE
                        DA_OTHER = DA_OTHER + CFO%AREA(JCFO)
                        FN_OTHER = FN_OTHER + CFO%FN_OMESH(JCFO)*CFO%AREA(JCFO)
                     ENDDO
                  ELSE
                     DA_OTHER = DA_OTHER + M2%DX(IIO)*M2%DZ(KKO)
                     FN_OTHER = FN_OTHER + OM%FVY(IIO,JJO,KKO)*M2%DX(IIO)*M2%DZ(KKO)
                  ENDIF
               ENDDO
            ENDDO
         ENDDO
         IF(ICF<1) FVY(II,0,KK) = 0.5_EB*(FVY(II,0,KK) + FN_OTHER/DA_OTHER)

      CASE(-2)

         ICF = FCVAR(II,JBAR,KK,CC_IDCF,ABS(IOR))
         DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
            DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
               DO IIO=EWC%IIO_MIN,EWC%IIO_MAX

                  IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                  IF (M2%FCVAR(IIO,JJO-1,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE

                  ICFO = M2%FCVAR(IIO,JJO-1,KKO,CC_IDCF,ABS(IOR))
                  IF(ICFO>0) THEN
                     CFO => M2%CUT_FACE(ICFO)
                     DO JCFO=1,CFO%NFACE
                        DA_OTHER = DA_OTHER + CFO%AREA(JCFO)
                        FN_OTHER = FN_OTHER + CFO%FN_OMESH(JCFO)*CFO%AREA(JCFO)
                     ENDDO
                  ELSE
                     DA_OTHER = DA_OTHER + M2%DX(IIO)*M2%DZ(KKO)
                     FN_OTHER = FN_OTHER + OM%FVY(IIO,JJO-1,KKO)*M2%DX(IIO)*M2%DZ(KKO)
                  ENDIF
             ENDDO
          ENDDO
       ENDDO
       IF(ICF<1) FVY(II,JBAR,KK) = 0.5_EB*(FVY(II,JBAR,KK) + FN_OTHER/DA_OTHER)


      CASE( 3)

         ICF = FCVAR(II,JJ,0,CC_IDCF,ABS(IOR))
         DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
            DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
               DO IIO=EWC%IIO_MIN,EWC%IIO_MAX

                  IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                  IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE

                  ICFO = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,ABS(IOR))
                  IF(ICFO>0) THEN
                     CFO => M2%CUT_FACE(ICFO)
                     DO JCFO=1,CFO%NFACE
                        DA_OTHER = DA_OTHER + CFO%AREA(JCFO)
                        FN_OTHER = FN_OTHER + CFO%FN_OMESH(JCFO)*CFO%AREA(JCFO)
                     ENDDO
                  ELSE
                     DA_OTHER = DA_OTHER + M2%DX(IIO)*M2%DY(JJO)
                     FN_OTHER = FN_OTHER + OM%FVZ(IIO,JJO,KKO)*M2%DX(IIO)*M2%DY(JJO)
                  ENDIF
               ENDDO
            ENDDO
         ENDDO
         IF(ICF<1) FVZ(II,JJ,0) = 0.5_EB*(FVZ(II,JJ,0) + FN_OTHER/DA_OTHER)

      CASE(-3)

         ICF = FCVAR(II,JJ,KBAR,CC_IDCF,ABS(IOR))
         DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
            DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
               DO IIO=EWC%IIO_MIN,EWC%IIO_MAX

                  IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                  IF (M2%FCVAR(IIO,JJO,KKO-1,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE

                  ICFO = M2%FCVAR(IIO,JJO,KKO-1,CC_IDCF,ABS(IOR))
                  IF(ICFO>0) THEN
                     CFO => M2%CUT_FACE(ICFO)
                     DO JCFO=1,CFO%NFACE
                        DA_OTHER = DA_OTHER + CFO%AREA(JCFO)
                        FN_OTHER = FN_OTHER + CFO%FN_OMESH(JCFO)*CFO%AREA(JCFO)
                     ENDDO
                  ELSE
                     DA_OTHER = DA_OTHER + M2%DX(IIO)*M2%DY(JJO)
                     FN_OTHER = FN_OTHER + OM%FVZ(IIO,JJO,KKO-1)*M2%DX(IIO)*M2%DY(JJO)
                  ENDIF
               ENDDO
            ENDDO
         ENDDO
         IF(ICF<1) FVZ(II,JJ,KBAR) = 0.5_EB*(FVZ(II,JJ,KBAR) + FN_OTHER/DA_OTHER)

   END SELECT

   ! IF EWC has a cut-face match the cut-face FN:
   IF(ICF>0) THEN
      CF => CUT_FACE(ICF)
      DO JCF=1,CF%NFACE
         CF%FN(JCF) = 0.5_EB*(CF%FN(JCF) + FN_OTHER/DA_OTHER)
      ENDDO
      CF%FV = DOT_PRODUCT(CF%FN(1:CF%NFACE),CF%AREA(1:CF%NFACE))/SUM(CF%AREA(1:CF%NFACE))

   ENDIF


ENDDO EXTERNAL_WALL_LOOP

T_USED(4)=T_USED(4)+CURRENT_TIME()-T_NOW

RETURN
END SUBROUTINE CC_MATCH_VELOCITY_FLUX


! ------------------------------ CC_MATCH_VELOCITY ----------------------------

SUBROUTINE CC_MATCH_VELOCITY(NM,APPLY_TO_ESTIMATED_VARIABLES,DO_U_GHOST)

! Assumes POINT_TO_MESH(NM) has NOT been called.

INTEGER, INTENT(IN) :: NM
LOGICAL, INTENT(IN) :: APPLY_TO_ESTIMATED_VARIABLES,DO_U_GHOST

! Local Variables:
INTEGER  :: NOM,II,JJ,KK,IOR,IW,IIO,JJO,KKO,ICF,JCF,ICFO,JCFO !,I,J,K,X1AXIS
REAL(EB) :: T_NOW,DA_OTHER,VEL_OTHER,VEL_LNK_OTHER,PRFCT,NOM_CELLS
REAL(EB) :: AU,AU1,AV,AV1,AW,AW1
REAL(EB), POINTER, DIMENSION(:,:,:) :: UU,VV,WW,OM_UU,OM_VV,OM_WW
TYPE (OMESH_TYPE), POINTER :: OM
TYPE (MESH_TYPE), POINTER :: M2
TYPE (CC_CUTFACE_TYPE), POINTER :: CFO
CALL POINT_TO_MESH(NM)

T_NOW = CURRENT_TIME()

IF (APPLY_TO_ESTIMATED_VARIABLES) THEN
   UU => US
   VV => VS
   WW => WS
   PRFCT = 1._EB
ELSE
   UU => U
   VV => V
   WW => W
   PRFCT = 0._EB
ENDIF

! NOTE : Loop here is done by N_EXTERNAL_WALL_CELLS. For single pressure variable per cut-cell
! cut faces should be averaged with underlying omesh cut-faces. To Do.
EXTERNAL_WALL_LOOP: DO IW=1,MESHES(NM)%N_EXTERNAL_WALL_CELLS

   WC=>WALL(IW)

   IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE EXTERNAL_WALL_LOOP

   EWC=>EXTERNAL_WALL(IW)
   BC =>BOUNDARY_COORD(WC%BC_INDEX)
   II  = BC%II
   JJ  = BC%JJ
   KK  = BC%KK
   IOR = BC%IOR
   NOM = EWC%NOM
   OM => OMESH(NOM)
   M2 => MESHES(NOM)

   ! Get velocity average from the Other mesh, average with local cut-face or reg face velocity for this
   ! wall cell:
   DA_OTHER      = 0._EB
   VEL_OTHER     = 0._EB
   VEL_LNK_OTHER = 0._EB

   SELECT CASE(IOR)
   CASE( IAXIS)

      IF (APPLY_TO_ESTIMATED_VARIABLES) THEN; OM_UU => OM%US; ELSE; OM_UU => OM%U; ENDIF
      ! Note id current EWC contains cut-faces, assume first cut-face velocity for OMESH VEL averaging:
      ICF = FCVAR(0,JJ,KK,CC_IDCF,ABS(IOR)); JCF = 1;
      DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
         DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
            DO IIO=EWC%IIO_MIN,EWC%IIO_MAX

               IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE ! Drop if OMESH cell is solid.
               IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE  ! Drop if cartesian face tagged solid.

               ICFO = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,ABS(IOR))
               IF(ICFO>0) THEN
                  CFO => M2%CUT_FACE(ICFO)
                  DO JCFO=1,CFO%NFACE
                     DA_OTHER      = DA_OTHER  + CFO%AREA(JCFO)
                     VEL_OTHER     = VEL_OTHER + &
                                     (PRFCT*CFO%VELS_OMESH(JCFO)+(1._EB-PRFCT)*CFO%VEL_OMESH(JCFO))*CFO%AREA(JCFO)
                     VEL_LNK_OTHER = VEL_LNK_OTHER + CFO%VEL_LNK_OMESH(JCFO)*CFO%AREA(JCFO)
                     IF (EWC%AREA_RATIO>0.9_EB) THEN ! Flux match OMESH cut-face vel.
                        IF(ICF>0) THEN
                           IF(APPLY_TO_ESTIMATED_VARIABLES) THEN
                              CFO%VELS_OMESH(JCFO) = 0.5_EB*(CFO%VELS_OMESH(JCFO)+CUT_FACE(ICF)%VELS(JCF))
                           ELSE
                              CFO%VEL_OMESH(JCFO)  = 0.5_EB*(CFO%VEL_OMESH(JCFO)+CUT_FACE(ICF)%VEL(JCF))
                           ENDIF
                           CFO%VEL_LNK_OMESH(JCFO) = 0.5_EB*(CFO%VEL_LNK_OMESH(JCFO)+CUT_FACE(ICF)%VEL_LNK(JCF))
                        ELSE
                           IF(APPLY_TO_ESTIMATED_VARIABLES) THEN
                              CFO%VELS_OMESH(JCFO) = 0.5_EB*(CFO%VELS_OMESH(JCFO)+UU(0,JJ,KK))
                           ELSE
                              CFO%VEL_OMESH(JCFO)  = 0.5_EB*(CFO%VEL_OMESH(JCFO)+UU(0,JJ,KK))
                           ENDIF
                           CFO%VEL_LNK_OMESH(JCFO) = 0.5_EB*(CFO%VEL_LNK_OMESH(JCFO)+EWC_UN_LNK(IW))
                        ENDIF
                     ENDIF
                  ENDDO
               ELSE
                  DA_OTHER      = DA_OTHER  + M2%DY(JJO)*M2%DZ(KKO)
                  VEL_OTHER     = VEL_OTHER + OM_UU(IIO,JJO,KKO)*M2%DY(JJO)*M2%DZ(KKO)
                  VEL_LNK_OTHER = VEL_LNK_OTHER + OM%U_LNK(IIO,JJO,KKO)*M2%DY(JJO)*M2%DZ(KKO)
                  ! Flux match OMESH reg face vel.
                  IF (EWC%AREA_RATIO>0.9_EB) THEN
                     IF(ICF>0) THEN
                        OM_UU(IIO,JJO,KKO)    = 0.5_EB*(OM_UU(IIO,JJO,KKO)+ &
                        PRFCT*CUT_FACE(ICF)%VELS(JCF)+(1._EB-PRFCT)*CUT_FACE(ICF)%VEL(JCF))
                        OM%U_LNK(IIO,JJO,KKO) = 0.5_EB*(OM%U_LNK(IIO,JJO,KKO)+CUT_FACE(ICF)%VEL_LNK(JCF))
                     ELSE
                        OM_UU(IIO,JJO,KKO)    = 0.5_EB*(OM_UU(IIO,JJO,KKO)+UU(0,JJ,KK))
                        OM%U_LNK(IIO,JJO,KKO) = 0.5_EB*(OM%U_LNK(IIO,JJO,KKO)+EWC_UN_LNK(IW))
                     ENDIF
                  ENDIF
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      IF(ICF<1) THEN ! This is a regular, or RC face.
         UVW_SAVE(IW)   = UU(0,JJ,KK) ! This is the original U saved in MATCH_VELOCITY previously.
         UU(0,JJ,KK)    = 0.5_EB*(UU(0,JJ,KK) + VEL_OTHER/DA_OTHER)
         EWC_UN_LNK(IW) = 0.5_EB*(EWC_UN_LNK(IW) + VEL_LNK_OTHER/DA_OTHER)
      ENDIF

   CASE(-IAXIS)

      IF (APPLY_TO_ESTIMATED_VARIABLES) THEN; OM_UU => OM%US; ELSE; OM_UU => OM%U; ENDIF
      ICF = FCVAR(IBAR,JJ,KK,CC_IDCF,ABS(IOR)); JCF = 1;
      DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
         DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
            DO IIO=EWC%IIO_MIN,EWC%IIO_MAX

               IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
               IF (M2%FCVAR(IIO-1,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE

               ICFO = M2%FCVAR(IIO-1,JJO,KKO,CC_IDCF,ABS(IOR))
               IF(ICFO>0) THEN
                  CFO => M2%CUT_FACE(ICFO)
                  DO JCFO=1,CFO%NFACE
                     DA_OTHER      = DA_OTHER  + CFO%AREA(JCFO)
                     VEL_OTHER     = VEL_OTHER + &
                                     (PRFCT*CFO%VELS_OMESH(JCFO)+(1._EB-PRFCT)*CFO%VEL_OMESH(JCFO))*CFO%AREA(JCFO)
                     VEL_LNK_OTHER = VEL_LNK_OTHER + CFO%VEL_LNK_OMESH(JCFO)*CFO%AREA(JCFO)
                     IF (EWC%AREA_RATIO>0.9_EB) THEN ! Flux match OMESH cut-face vel.
                        IF(ICF>0) THEN
                           IF(APPLY_TO_ESTIMATED_VARIABLES) THEN
                              CFO%VELS_OMESH(JCFO) = 0.5_EB*(CFO%VELS_OMESH(JCFO)+CUT_FACE(ICF)%VELS(JCF))
                           ELSE
                              CFO%VEL_OMESH(JCFO)  = 0.5_EB*(CFO%VEL_OMESH(JCFO)+CUT_FACE(ICF)%VEL(JCF))
                           ENDIF
                           CFO%VEL_LNK_OMESH(JCFO) = 0.5_EB*(CFO%VEL_LNK_OMESH(JCFO)+CUT_FACE(ICF)%VEL_LNK(JCF))
                        ELSE
                           IF(APPLY_TO_ESTIMATED_VARIABLES) THEN
                              CFO%VELS_OMESH(JCFO) = 0.5_EB*(CFO%VELS_OMESH(JCFO)+UU(IBAR,JJ,KK))
                           ELSE
                              CFO%VEL_OMESH(JCFO)  = 0.5_EB*(CFO%VEL_OMESH(JCFO)+UU(IBAR,JJ,KK))
                           ENDIF
                           CFO%VEL_LNK_OMESH(JCFO) = 0.5_EB*(CFO%VEL_LNK_OMESH(JCFO)+EWC_UN_LNK(IW))
                        ENDIF
                     ENDIF
                  ENDDO
               ELSE
                  DA_OTHER      = DA_OTHER  + M2%DY(JJO)*M2%DZ(KKO)
                  VEL_OTHER     = VEL_OTHER + OM_UU(IIO-1,JJO,KKO)*M2%DY(JJO)*M2%DZ(KKO)
                  VEL_LNK_OTHER = VEL_LNK_OTHER + OM%U_LNK(IIO-1,JJO,KKO)*M2%DY(JJO)*M2%DZ(KKO)
                  IF (EWC%AREA_RATIO>0.9_EB) THEN
                     IF(ICF>0) THEN
                        OM_UU(IIO-1,JJO,KKO)    = 0.5_EB*(OM_UU(IIO-1,JJO,KKO)+ &
                        PRFCT*CUT_FACE(ICF)%VELS(JCF)+(1._EB-PRFCT)*CUT_FACE(ICF)%VEL(JCF))
                        OM%U_LNK(IIO-1,JJO,KKO) = 0.5_EB*(OM%U_LNK(IIO-1,JJO,KKO)+CUT_FACE(ICF)%VEL_LNK(JCF))
                     ELSE
                        OM_UU(IIO-1,JJO,KKO)    = 0.5_EB*(OM_UU(IIO-1,JJO,KKO)+UU(IBAR,JJ,KK))
                        OM%U_LNK(IIO-1,JJO,KKO) = 0.5_EB*(OM%U_LNK(IIO-1,JJO,KKO)+EWC_UN_LNK(IW))
                     ENDIF
                  ENDIF
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      IF(ICF<1) THEN
         UVW_SAVE(IW)   =  UU(IBAR,JJ,KK)
         UU(IBAR,JJ,KK) = 0.5_EB*(UU(IBAR,JJ,KK) + VEL_OTHER/DA_OTHER)
         EWC_UN_LNK(IW) = 0.5_EB*(EWC_UN_LNK(IW) + VEL_LNK_OTHER/DA_OTHER)
      ENDIF

   CASE( JAXIS)

      IF (APPLY_TO_ESTIMATED_VARIABLES) THEN; OM_VV => OM%VS; ELSE; OM_VV => OM%V; ENDIF
      ICF = FCVAR(II,0,KK,CC_IDCF,ABS(IOR)); JCF = 1
      DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
         DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
            DO IIO=EWC%IIO_MIN,EWC%IIO_MAX

               IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
               IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE

               ICFO = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,ABS(IOR))
               IF(ICFO>0) THEN
                  CFO => M2%CUT_FACE(ICFO)
                  DO JCFO=1,CFO%NFACE
                     DA_OTHER      = DA_OTHER  + CFO%AREA(JCFO)
                     VEL_OTHER     = VEL_OTHER + &
                                     (PRFCT*CFO%VELS_OMESH(JCFO)+(1._EB-PRFCT)*CFO%VEL_OMESH(JCFO))*CFO%AREA(JCFO)
                     VEL_LNK_OTHER = VEL_LNK_OTHER + CFO%VEL_LNK_OMESH(JCFO)*CFO%AREA(JCFO)
                     IF (EWC%AREA_RATIO>0.9_EB) THEN ! Flux match OMESH cut-face vel.
                        IF(ICF>0) THEN
                           IF(APPLY_TO_ESTIMATED_VARIABLES) THEN
                              CFO%VELS_OMESH(JCFO) = 0.5_EB*(CFO%VELS_OMESH(JCFO)+CUT_FACE(ICF)%VELS(JCF))
                           ELSE
                              CFO%VEL_OMESH(JCFO)  = 0.5_EB*(CFO%VEL_OMESH(JCFO)+CUT_FACE(ICF)%VEL(JCF))
                           ENDIF

                           CFO%VEL_LNK_OMESH(JCFO) = 0.5_EB*(CFO%VEL_LNK_OMESH(JCFO)+CUT_FACE(ICF)%VEL_LNK(JCF))
                        ELSE
                           IF(APPLY_TO_ESTIMATED_VARIABLES) THEN
                              CFO%VELS_OMESH(JCFO) = 0.5_EB*(CFO%VELS_OMESH(JCFO)+VV(II,0,KK))
                           ELSE
                              CFO%VEL_OMESH(JCFO)  = 0.5_EB*(CFO%VEL_OMESH(JCFO)+VV(II,0,KK))
                           ENDIF
                           CFO%VEL_LNK_OMESH(JCFO) = 0.5_EB*(CFO%VEL_LNK_OMESH(JCFO)+EWC_UN_LNK(IW))
                        ENDIF
                     ENDIF
                  ENDDO
               ELSE
                  DA_OTHER      = DA_OTHER  + M2%DX(IIO)*M2%DZ(KKO)
                  VEL_OTHER     = VEL_OTHER + OM_VV(IIO,JJO,KKO)*M2%DX(IIO)*M2%DZ(KKO)
                  VEL_LNK_OTHER = VEL_LNK_OTHER + OM%V_LNK(IIO,JJO,KKO)*M2%DX(IIO)*M2%DZ(KKO)
                  IF (EWC%AREA_RATIO>0.9_EB) THEN
                     IF(ICF>0) THEN
                        OM_VV(IIO,JJO,KKO)    = 0.5_EB*(OM_VV(IIO,JJO,KKO)+ &
                        PRFCT*CUT_FACE(ICF)%VELS(JCF)+(1._EB-PRFCT)*CUT_FACE(ICF)%VEL(JCF))
                        OM%V_LNK(IIO,JJO,KKO) = 0.5_EB*(OM%V_LNK(IIO,JJO,KKO)+CUT_FACE(ICF)%VEL_LNK(JCF))
                     ELSE
                        OM_VV(IIO,JJO,KKO)    = 0.5_EB*(OM_VV(IIO,JJO,KKO)+VV(II,0,KK))
                        OM%V_LNK(IIO,JJO,KKO) = 0.5_EB*(OM%V_LNK(IIO,JJO,KKO)+EWC_UN_LNK(IW))
                     ENDIF
                  ENDIF
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      IF(ICF<1) THEN
         UVW_SAVE(IW)   = VV(II,0,KK)
         VV(II,0,KK)    = 0.5_EB*(VV(II,0,KK) + VEL_OTHER/DA_OTHER)
         EWC_UN_LNK(IW) = 0.5_EB*(EWC_UN_LNK(IW) + VEL_LNK_OTHER/DA_OTHER)
      ENDIF

   CASE(-JAXIS)

      IF (APPLY_TO_ESTIMATED_VARIABLES) THEN; OM_VV => OM%VS; ELSE; OM_VV => OM%V; ENDIF
      ICF = FCVAR(II,JBAR,KK,CC_IDCF,ABS(IOR)); JCF = 1
      DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
         DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
            DO IIO=EWC%IIO_MIN,EWC%IIO_MAX

               IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
               IF (M2%FCVAR(IIO,JJO-1,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE

               ICFO = M2%FCVAR(IIO,JJO-1,KKO,CC_IDCF,ABS(IOR))
               IF(ICFO>0) THEN
                  CFO => M2%CUT_FACE(ICFO)
                  DO JCFO=1,CFO%NFACE
                     DA_OTHER      = DA_OTHER  + CFO%AREA(JCFO)
                     VEL_OTHER     = VEL_OTHER + &
                                     (PRFCT*CFO%VELS_OMESH(JCFO)+(1._EB-PRFCT)*CFO%VEL_OMESH(JCFO))*CFO%AREA(JCFO)
                     VEL_LNK_OTHER = VEL_LNK_OTHER + CFO%VEL_LNK_OMESH(JCFO)*CFO%AREA(JCFO)
                     IF (EWC%AREA_RATIO>0.9_EB) THEN ! Flux match OMESH cut-face vel.
                        IF(ICF>0) THEN
                           IF(APPLY_TO_ESTIMATED_VARIABLES) THEN
                              CFO%VELS_OMESH(JCFO) = 0.5_EB*(CFO%VELS_OMESH(JCFO)+CUT_FACE(ICF)%VELS(JCF))
                           ELSE
                              CFO%VEL_OMESH(JCFO)  = 0.5_EB*(CFO%VEL_OMESH(JCFO)+CUT_FACE(ICF)%VEL(JCF))
                           ENDIF
                           CFO%VEL_LNK_OMESH(JCFO) = 0.5_EB*(CFO%VEL_LNK_OMESH(JCFO)+CUT_FACE(ICF)%VEL_LNK(JCF))
                        ELSE
                           IF(APPLY_TO_ESTIMATED_VARIABLES) THEN
                              CFO%VELS_OMESH(JCFO) = 0.5_EB*(CFO%VELS_OMESH(JCFO)+VV(II,JBAR,KK))
                           ELSE
                              CFO%VEL_OMESH(JCFO)  = 0.5_EB*(CFO%VEL_OMESH(JCFO)+VV(II,JBAR,KK))
                           ENDIF
                           CFO%VEL_LNK_OMESH(JCFO) = 0.5_EB*(CFO%VEL_LNK_OMESH(JCFO)+EWC_UN_LNK(IW))
                        ENDIF
                     ENDIF
                  ENDDO
               ELSE
                  DA_OTHER      = DA_OTHER  + M2%DX(IIO)*M2%DZ(KKO)
                  VEL_OTHER     = VEL_OTHER + OM_VV(IIO,JJO-1,KKO)*M2%DX(IIO)*M2%DZ(KKO)
                  VEL_LNK_OTHER = VEL_LNK_OTHER + OM%V_LNK(IIO,JJO-1,KKO)*M2%DX(IIO)*M2%DZ(KKO)
                  IF (EWC%AREA_RATIO>0.9_EB) THEN
                     IF(ICF>0) THEN
                        OM_VV(IIO,JJO-1,KKO)    = 0.5_EB*(OM_VV(IIO,JJO-1,KKO)+ &
                        PRFCT*CUT_FACE(ICF)%VELS(JCF)+(1._EB-PRFCT)*CUT_FACE(ICF)%VEL(JCF))
                        OM%V_LNK(IIO,JJO-1,KKO) = 0.5_EB*(OM%V_LNK(IIO,JJO-1,KKO)+CUT_FACE(ICF)%VEL_LNK(JCF))
                     ELSE
                        OM_VV(IIO,JJO-1,KKO)    = 0.5_EB*(OM_VV(IIO,JJO-1,KKO)+VV(II,JBAR,KK))
                        OM%V_LNK(IIO,JJO-1,KKO) = 0.5_EB*(OM%V_LNK(IIO,JJO-1,KKO)+EWC_UN_LNK(IW))
                     ENDIF
                  ENDIF
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      IF(ICF<1) THEN
         UVW_SAVE(IW)   = VV(II,JBAR,KK)
         VV(II,JBAR,KK) = 0.5_EB*(VV(II,JBAR,KK) + VEL_OTHER/DA_OTHER)
         EWC_UN_LNK(IW) = 0.5_EB*(EWC_UN_LNK(IW) + VEL_LNK_OTHER/DA_OTHER)
      ENDIF

   CASE( KAXIS)

      IF (APPLY_TO_ESTIMATED_VARIABLES) THEN; OM_WW => OM%WS; ELSE; OM_WW => OM%W; ENDIF
      ICF = FCVAR(II,JJ,0,CC_IDCF,ABS(IOR)); JCF = 1
      DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
         DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
            DO IIO=EWC%IIO_MIN,EWC%IIO_MAX

               IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
               IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE

               ICFO = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,ABS(IOR))
               IF(ICFO>0) THEN
                  CFO => M2%CUT_FACE(ICFO)
                  DO JCFO=1,CFO%NFACE
                     DA_OTHER      = DA_OTHER  + CFO%AREA(JCFO)
                     VEL_OTHER     = VEL_OTHER + &
                                     (PRFCT*CFO%VELS_OMESH(JCFO)+(1._EB-PRFCT)*CFO%VEL_OMESH(JCFO))*CFO%AREA(JCFO)
                     VEL_LNK_OTHER = VEL_LNK_OTHER + CFO%VEL_LNK_OMESH(JCFO)*CFO%AREA(JCFO)
                     IF (EWC%AREA_RATIO>0.9_EB) THEN ! Flux match OMESH cut-face vel.
                        IF(ICF>0) THEN
                           IF(APPLY_TO_ESTIMATED_VARIABLES) THEN
                              CFO%VELS_OMESH(JCFO) = 0.5_EB*(CFO%VELS_OMESH(JCFO)+CUT_FACE(ICF)%VELS(JCF))
                           ELSE
                              CFO%VEL_OMESH(JCFO)  = 0.5_EB*(CFO%VEL_OMESH(JCFO)+CUT_FACE(ICF)%VEL(JCF))
                           ENDIF
                           CFO%VEL_LNK_OMESH(JCFO) = 0.5_EB*(CFO%VEL_LNK_OMESH(JCFO)+CUT_FACE(ICF)%VEL_LNK(JCF))
                        ELSE
                           IF(APPLY_TO_ESTIMATED_VARIABLES) THEN
                              CFO%VELS_OMESH(JCFO) = 0.5_EB*(CFO%VELS_OMESH(JCFO)+WW(II,JJ,0))
                           ELSE
                              CFO%VEL_OMESH(JCFO)  = 0.5_EB*(CFO%VEL_OMESH(JCFO)+WW(II,JJ,0))
                           ENDIF
                           CFO%VEL_LNK_OMESH(JCFO) = 0.5_EB*(CFO%VEL_LNK_OMESH(JCFO)+EWC_UN_LNK(IW))
                        ENDIF
                     ENDIF
                  ENDDO
               ELSE
                  DA_OTHER      = DA_OTHER  + M2%DX(IIO)*M2%DY(JJO)
                  VEL_OTHER     = VEL_OTHER + OM_WW(IIO,JJO,KKO)*M2%DX(IIO)*M2%DY(JJO)
                  VEL_LNK_OTHER = VEL_LNK_OTHER + OM%W_LNK(IIO,JJO,KKO)*M2%DX(IIO)*M2%DY(JJO)
                  IF (EWC%AREA_RATIO>0.9_EB) THEN
                     IF(ICF>0) THEN
                        OM_WW(IIO,JJO,KKO)    = 0.5_EB*(OM_WW(IIO,JJO,KKO)+ &
                        PRFCT*CUT_FACE(ICF)%VELS(JCF)+(1._EB-PRFCT)*CUT_FACE(ICF)%VEL(JCF))
                        OM%W_LNK(IIO,JJO,KKO) = 0.5_EB*(OM%W_LNK(IIO,JJO,KKO)+CUT_FACE(ICF)%VEL_LNK(JCF))
                     ELSE
                        OM_WW(IIO,JJO,KKO)    = 0.5_EB*(OM_WW(IIO,JJO,KKO)+WW(II,JJ,0))
                        OM%W_LNK(IIO,JJO,KKO) = 0.5_EB*(OM%W_LNK(IIO,JJO,KKO)+EWC_UN_LNK(IW))
                     ENDIF
                  ENDIF
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      IF(ICF<1) THEN
         UVW_SAVE(IW)   = WW(II,JJ,0)
         WW(II,JJ,0)    = 0.5_EB*(WW(II,JJ,0) + VEL_OTHER/DA_OTHER)
         EWC_UN_LNK(IW) = 0.5_EB*(EWC_UN_LNK(IW) + VEL_LNK_OTHER/DA_OTHER)
      ENDIF

   CASE(-KAXIS)

      IF (APPLY_TO_ESTIMATED_VARIABLES) THEN; OM_WW => OM%WS; ELSE; OM_WW => OM%W; ENDIF
      ICF = FCVAR(II,JJ,KBAR,CC_IDCF,ABS(IOR)); JCF = 1
      DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
         DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
            DO IIO=EWC%IIO_MIN,EWC%IIO_MAX

               IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
               IF (M2%FCVAR(IIO,JJO,KKO-1,CC_FGSC,ABS(IOR))==CC_SOLID) CYCLE

               ICFO = M2%FCVAR(IIO,JJO,KKO-1,CC_IDCF,ABS(IOR))
               IF(ICFO>0) THEN
                  CFO => M2%CUT_FACE(ICFO)
                  DO JCFO=1,CFO%NFACE
                     DA_OTHER      = DA_OTHER  + CFO%AREA(JCFO)
                     VEL_OTHER     = VEL_OTHER + &
                                     (PRFCT*CFO%VELS_OMESH(JCFO)+(1._EB-PRFCT)*CFO%VEL_OMESH(JCFO))*CFO%AREA(JCFO)
                     VEL_LNK_OTHER = VEL_LNK_OTHER + CFO%VEL_LNK_OMESH(JCFO)*CFO%AREA(JCFO)
                     IF (EWC%AREA_RATIO>0.9_EB) THEN ! Flux match OMESH cut-face vel.
                        IF(ICF>0) THEN
                           IF(APPLY_TO_ESTIMATED_VARIABLES) THEN
                              CFO%VELS_OMESH(JCFO) = 0.5_EB*(CFO%VELS_OMESH(JCFO)+CUT_FACE(ICF)%VELS(JCF))
                           ELSE
                              CFO%VEL_OMESH(JCFO)  = 0.5_EB*(CFO%VEL_OMESH(JCFO)+CUT_FACE(ICF)%VEL(JCF))
                           ENDIF
                           CFO%VEL_LNK_OMESH(JCFO) = 0.5_EB*(CFO%VEL_LNK_OMESH(JCFO)+CUT_FACE(ICF)%VEL_LNK(JCF))
                        ELSE
                           IF(APPLY_TO_ESTIMATED_VARIABLES) THEN
                              CFO%VELS_OMESH(JCFO) = 0.5_EB*(CFO%VELS_OMESH(JCFO)+WW(II,JJ,KBAR))
                           ELSE
                              CFO%VEL_OMESH(JCFO)  = 0.5_EB*(CFO%VEL_OMESH(JCFO)+WW(II,JJ,KBAR))
                           ENDIF
                           CFO%VEL_LNK_OMESH(JCFO) = 0.5_EB*(CFO%VEL_LNK_OMESH(JCFO)+EWC_UN_LNK(IW))
                        ENDIF
                     ENDIF
                  ENDDO
               ELSE
                  DA_OTHER      = DA_OTHER  + M2%DX(IIO)*M2%DY(JJO)
                  VEL_OTHER     = VEL_OTHER + OM_WW(IIO,JJO,KKO-1)*M2%DX(IIO)*M2%DY(JJO)
                  VEL_LNK_OTHER = VEL_LNK_OTHER + OM%W_LNK(IIO,JJO,KKO-1)*M2%DX(IIO)*M2%DY(JJO)
                  IF (EWC%AREA_RATIO>0.9_EB) THEN
                     IF(ICF>0) THEN
                        OM_WW(IIO,JJO,KKO-1)    = 0.5_EB*(OM_WW(IIO,JJO,KKO-1)+ &
                        PRFCT*CUT_FACE(ICF)%VELS(JCF)+(1._EB-PRFCT)*CUT_FACE(ICF)%VEL(JCF))
                        OM%W_LNK(IIO,JJO,KKO-1) = 0.5_EB*(OM%W_LNK(IIO,JJO,KKO-1)+CUT_FACE(ICF)%VEL_LNK(JCF))
                     ELSE
                        OM_WW(IIO,JJO,KKO-1)    = 0.5_EB*(OM_WW(IIO,JJO,KKO-1)+WW(II,JJ,KBAR))
                        OM%W_LNK(IIO,JJO,KKO-1) = 0.5_EB*(OM%W_LNK(IIO,JJO,KKO-1)+EWC_UN_LNK(IW))
                     ENDIF
                  ENDIF
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      IF(ICF<1) THEN
         UVW_SAVE(IW)   = WW(II,JJ,KBAR)
         WW(II,JJ,KBAR) = 0.5_EB*(WW(II,JJ,KBAR) + VEL_OTHER/DA_OTHER)
         EWC_UN_LNK(IW) = 0.5_EB*(EWC_UN_LNK(IW) + VEL_LNK_OTHER/DA_OTHER)
      ENDIF

   END SELECT

   ! IF EWC has a cut-face match the cut-face velocity:
   ! VEL_OTHER is averaged, so assumes single cut-face per Cartesian face, single pressure zone per Cut-Cell.
   IF(ICF>0) THEN
      CF => CUT_FACE(ICF)
      IF (APPLY_TO_ESTIMATED_VARIABLES) THEN
         DO JCF=1,CF%NFACE
            CF%VEL_SAVE(JCF) = CF%VELS(JCF)
            CF%VELS(JCF)     = 0.5_EB*(CF%VELS(JCF) + VEL_OTHER/DA_OTHER)
         ENDDO
      ELSE
         DO JCF=1,CF%NFACE
            CF%VEL_SAVE(JCF) = CF%VEL(JCF)
            CF%VEL(JCF)      = 0.5_EB*(CF%VEL(JCF) + VEL_OTHER/DA_OTHER)
         ENDDO
      ENDIF
      DO JCF=1,CF%NFACE
         CF%VEL_LNK(JCF)      = 0.5_EB*(CF%VEL_LNK(JCF) + VEL_LNK_OTHER/DA_OTHER)
      ENDDO
   ENDIF

   IF (DO_U_GHOST) THEN
      ! Save velocity components at the ghost cell midpoint

      U_GHOST(IW) = 0._EB
      V_GHOST(IW) = 0._EB
      W_GHOST(IW) = 0._EB

      IF (APPLY_TO_ESTIMATED_VARIABLES) THEN; OM_UU => OM%US; ELSE; OM_UU => OM%U; ENDIF
      IF (APPLY_TO_ESTIMATED_VARIABLES) THEN; OM_VV => OM%VS; ELSE; OM_VV => OM%V; ENDIF
      IF (APPLY_TO_ESTIMATED_VARIABLES) THEN; OM_WW => OM%WS; ELSE; OM_WW => OM%W; ENDIF

      DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
         DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
            DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
               AU =1._EB; ICF=M2%FCVAR(IIO  ,JJO,KKO,CC_IDCF,IAXIS); IF(ICF>0) AU =M2%CUT_FACE(ICF)%ALPHA_CF
               AU1=1._EB; ICF=M2%FCVAR(IIO-1,JJO,KKO,CC_IDCF,IAXIS); IF(ICF>0) AU1=M2%CUT_FACE(ICF)%ALPHA_CF
               AV =1._EB; ICF=M2%FCVAR(IIO,JJO  ,KKO,CC_IDCF,JAXIS); IF(ICF>0) AV =M2%CUT_FACE(ICF)%ALPHA_CF
               AV1=1._EB; ICF=M2%FCVAR(IIO,JJO-1,KKO,CC_IDCF,JAXIS); IF(ICF>0) AV1=M2%CUT_FACE(ICF)%ALPHA_CF
               AW =1._EB; ICF=M2%FCVAR(IIO,JJO,KKO  ,CC_IDCF,KAXIS); IF(ICF>0) AW =M2%CUT_FACE(ICF)%ALPHA_CF
               AW1=1._EB; ICF=M2%FCVAR(IIO,JJO,KKO-1,CC_IDCF,KAXIS); IF(ICF>0) AW1=M2%CUT_FACE(ICF)%ALPHA_CF
               U_GHOST(IW) = U_GHOST(IW) + (OM_UU(IIO,JJO,KKO)*AU+OM_UU(IIO-1,JJO,KKO)*AU1)/(AU+AU1)
               V_GHOST(IW) = V_GHOST(IW) + (OM_VV(IIO,JJO,KKO)*AV+OM_VV(IIO,JJO-1,KKO)*AV1)/(AV+AV1)
               W_GHOST(IW) = W_GHOST(IW) + (OM_WW(IIO,JJO,KKO)*AW+OM_WW(IIO,JJO,KKO-1)*AW1)/(AW+AW1)
            ENDDO
         ENDDO
      ENDDO

      NOM_CELLS = REAL((EWC%IIO_MAX-EWC%IIO_MIN+1)*(EWC%JJO_MAX-EWC%JJO_MIN+1)*(EWC%KKO_MAX-EWC%KKO_MIN+1),EB)
      U_GHOST(IW) = U_GHOST(IW)/NOM_CELLS
      V_GHOST(IW) = V_GHOST(IW)/NOM_CELLS
      W_GHOST(IW) = W_GHOST(IW)/NOM_CELLS
   ENDIF

ENDDO EXTERNAL_WALL_LOOP

T_USED(4) = T_USED(4) + CURRENT_TIME() - T_NOW

END SUBROUTINE CC_MATCH_VELOCITY


! ----------------------------- CC_COMPUTE_VISCOSITY -------------------------

SUBROUTINE CC_COMPUTE_VISCOSITY(DT,NM)

USE TURBULENCE, ONLY: WALE_VISCOSITY

REAL(EB), INTENT(IN):: DT
INTEGER, INTENT(IN) :: NM

! Local Variables:
INTEGER :: I,J,K
REAL(EB), POINTER, DIMENSION(:,:,:) :: RHOP=>NULL(),UU=>NULL(),VV=>NULL(),WW=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: ZZP=>NULL()
REAL(EB) :: NU_EDDY,DELTA,A_IJ(3,3),DUDX,DUDY,DUDZ,DVDX,DVDY,DVDZ,DWDX,DWDY,DWDZ

REAL(EB) :: TNOW

! Dummy assignments:
TNOW = DT
I    = NM

TNOW = CURRENT_TIME()

IF (PREDICTOR) THEN
   RHOP => RHO
   UU   => U
   VV   => V
   WW   => W
   ZZP  => ZZ
ELSE
   RHOP => RHOS
   UU   => US
   VV   => VS
   WW   => WS
   ZZP  => ZZS
ENDIF

! No need to compute WALE model turbulent viscosity on cut-cell region.
LES_IF : IF (SIM_MODE/=DNS_MODE) THEN

   ! WALE model on cells belonging to cut-cell region:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
             IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
             IF (CCVAR(I,J,K,CC_CGSC)==CC_SOLID) THEN; MU(I,J,K) = MU_DNS(I,J,K); CYCLE; ENDIF
             IF (CCVAR(I,J,K,CC_IDCF)<1) CYCLE ! Cycle everything except cut-cells with boundary CFACEs.

             DELTA = LES_FILTER_WIDTH(I,J,K)
             ! compute velocity gradient tensor
             DUDX = RDX(I)*(UU(I,J,K)-UU(I-1,J,K))
             DVDY = RDY(J)*(VV(I,J,K)-VV(I,J-1,K))
             DWDZ = RDZ(K)*(WW(I,J,K)-WW(I,J,K-1))
             DUDY = 0.25_EB*RDY(J)*(UU(I,J+1,K)-UU(I,J-1,K)+UU(I-1,J+1,K)-UU(I-1,J-1,K))
             DUDZ = 0.25_EB*RDZ(K)*(UU(I,J,K+1)-UU(I,J,K-1)+UU(I-1,J,K+1)-UU(I-1,J,K-1))
             DVDX = 0.25_EB*RDX(I)*(VV(I+1,J,K)-VV(I-1,J,K)+VV(I+1,J-1,K)-VV(I-1,J-1,K))
             DVDZ = 0.25_EB*RDZ(K)*(VV(I,J,K+1)-VV(I,J,K-1)+VV(I,J-1,K+1)-VV(I,J-1,K-1))
             DWDX = 0.25_EB*RDX(I)*(WW(I+1,J,K)-WW(I-1,J,K)+WW(I+1,J,K-1)-WW(I-1,J,K-1))
             DWDY = 0.25_EB*RDY(J)*(WW(I,J+1,K)-WW(I,J-1,K)+WW(I,J+1,K-1)-WW(I,J-1,K-1))
             A_IJ(1,1)=DUDX; A_IJ(1,2)=DUDY; A_IJ(1,3)=DUDZ
             A_IJ(2,1)=DVDX; A_IJ(2,2)=DVDY; A_IJ(2,3)=DVDZ
             A_IJ(3,1)=DWDX; A_IJ(3,2)=DWDY; A_IJ(3,3)=DWDZ

             CALL WALE_VISCOSITY(NU_EDDY,A_IJ,DELTA)

             MU(I,J,K) = MU_DNS(I,J,K) + RHOP(I,J,K)*NU_EDDY

         ENDDO
      ENDDO
   ENDDO

ENDIF LES_IF

T_USED(14) = T_USED(14) + CURRENT_TIME() - TNOW
IF (TIME_CC_IBM) &
   T_CC_USED(CC_COMPUTE_VISCOSITY_TIME_INDEX) = T_CC_USED(CC_COMPUTE_VISCOSITY_TIME_INDEX) + CURRENT_TIME() - TNOW


RETURN
END SUBROUTINE CC_COMPUTE_VISCOSITY


! -------------------------------- ADD_Q_DOT_CUTCELLS ------------------------------

SUBROUTINE ADD_Q_DOT_CUTCELLS(NM,QCOMB,QRAD,QPRES,SP_ENTH)

! This routine assumes POINT_TO_MESH(NM) has already been called for mesh NM.

USE PHYSICAL_FUNCTIONS, ONLY : GET_SENSIBLE_ENTHALPY

INTEGER, INTENT(IN) :: NM
REAL(EB), INTENT(INOUT) :: QCOMB,QRAD,QPRES,SP_ENTH

! Local Variables:
INTEGER :: ICC, JCC, I, J, K
REAL(EB):: VC,ZZ_GET(1:N_TRACKED_SPECIES),H_S

DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
   I = CUT_CELL(ICC)%IJK(IAXIS)
   J = CUT_CELL(ICC)%IJK(JAXIS)
   K = CUT_CELL(ICC)%IJK(KAXIS)
   VC = DX(I)*DY(J)*DZ(K)
   QPRES = QPRES + 0.5_EB*(D_PBAR_DT_S(PRESSURE_ZONE(I,J,K))+D_PBAR_DT(PRESSURE_ZONE(I,J,K)))*VC
   DO JCC=1,CUT_CELL(ICC)%NCELL
      QCOMB = QCOMB + CUT_CELL(ICC)%Q(JCC)*CUT_CELL(ICC)%VOLUME(JCC)
      QRAD  = QRAD  + CUT_CELL(ICC)%QR(JCC)*CUT_CELL(ICC)%VOLUME(JCC)
      ZZ_GET(1:N_TRACKED_SPECIES) = CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC)
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,CUT_CELL(ICC)%TMP(JCC))
      SP_ENTH = SP_ENTH + CUT_CELL(ICC)%RHO(JCC)*H_S*CUT_CELL(ICC)%VOLUME(JCC)
   ENDDO
ENDDO

RETURN
END SUBROUTINE ADD_Q_DOT_CUTCELLS


! -------------------------- CFACE_PREDICT_NORMAL_VELOCITY -------------------------

SUBROUTINE CFACE_PREDICT_NORMAL_VELOCITY(T,DT)


USE MATH_FUNCTIONS, ONLY : EVALUATE_RAMP

REAL(EB), INTENT(IN) :: T, DT

! Local variables:
INTEGER :: ICF
TYPE(SURFACE_TYPE), POINTER :: SF
REAL(EB), POINTER, DIMENSION(:,:) :: PBAR_P
REAL(EB) :: TSI, TIME_RAMP_FACTOR, RDT

RDT = 1._EB/DT

SELECT CASE(PREDICTOR)
   CASE(.TRUE.)
      PBAR_P => PBAR_S
   CASE(.FALSE.)
      PBAR_P => PBAR
END SELECT

PREDICT_NORMALS: IF (PREDICTOR) THEN

   ! Run computation for External and Internal CFACE cells:
   CFACE_LOOP: DO ICF=1,N_EXTERNAL_CFACE_CELLS+N_INTWALL_CFACE_CELLS+N_INTERNAL_CFACE_CELLS

      CFA => CFACE(ICF)
      B1  => BOUNDARY_PROP1(CFA%B1_INDEX)

      WALL_CELL_TYPE: SELECT CASE (CFA%BOUNDARY_TYPE)

         CASE (NULL_BOUNDARY)

            B1%U_NORMAL_S = 0._EB

         CASE (SOLID_BOUNDARY)

            SF => SURFACE(CFA%SURF_INDEX)

            IF (SF%SPECIES_BC_INDEX==SPECIFIED_MASS_FLUX .OR. &
                B1%NODE_INDEX > 0                 .OR. &
                ANY(SF%LEAK_PATH>0))                          &
                CYCLE CFACE_LOOP

            IF (ABS(B1%T_IGN-T_BEGIN) < SPACING(B1%T_IGN) .AND. SF%RAMP(TIME_VELO)%INDEX>=1) THEN
               TSI = T + DT
            ELSE
               TSI = T + DT - B1%T_IGN
               IF (TSI<0._EB) THEN
                  B1%U_NORMAL_S = 0._EB
                  CYCLE CFACE_LOOP
               ENDIF
            ENDIF
            TIME_RAMP_FACTOR = EVALUATE_RAMP(TSI,SF%RAMP(TIME_VELO)%INDEX,TAU=SF%RAMP(TIME_VELO)%TAU)
            B1%U_NORMAL_S = TIME_RAMP_FACTOR*B1%U_NORMAL_0

            ! Special Cases
            ! NEUMANN_IF: IF (SF%SPECIFIED_NORMAL_GRADIENT) THEN
            ! TO DO, following PREDICT_NORMAL_VELOCITY.

            IF (ABS(SURFACE(CFA%SURF_INDEX)%MASS_FLUX_TOTAL)>=TWO_EPSILON_EB) B1%U_NORMAL_S = &
                                                                              B1%U_NORMAL_S*RHOA/B1%RHO_F

            ! VENT_IF: IF (WC%VENT_INDEX>0) THEN
            ! TO DO, following PREDICT_NORMAL_VELOCITY.

      END SELECT WALL_CELL_TYPE

   ENDDO CFACE_LOOP

   DO ICF=1,N_EXTERNAL_CFACE_CELLS+N_INTWALL_CFACE_CELLS+N_INTERNAL_CFACE_CELLS
      CFA => CFACE(ICF)
      B1  => BOUNDARY_PROP1(CFA%B1_INDEX)
      CFA%DUNDT = RDT*(B1%U_NORMAL_S-B1%U_NORMAL)
   ENDDO

ELSE PREDICT_NORMALS

   ! In the CORRECTOR step, the normal component of velocity, U_NORMAL, is the same as the predicted value, U_NORMAL_S.
   ! However, for species mass fluxes and HVAC, U_NORMAL is computed elsewhere (wall.f90).

   CFACE_LOOPC: DO ICF=1,N_EXTERNAL_CFACE_CELLS+N_INTWALL_CFACE_CELLS+N_INTERNAL_CFACE_CELLS
      CFA => CFACE(ICF)
      B1  => BOUNDARY_PROP1(CFA%B1_INDEX)
      IF (CFA%BOUNDARY_TYPE==SOLID_BOUNDARY) THEN
         SF => SURFACE(CFA%SURF_INDEX)
         IF (SF%SPECIES_BC_INDEX==SPECIFIED_MASS_FLUX .OR. &
             B1%NODE_INDEX > 0                 .OR. &
             ANY(SF%LEAK_PATH>0) ) CYCLE
      ENDIF
      B1%U_NORMAL = B1%U_NORMAL_S
   ENDDO CFACE_LOOPC

   DO ICF=1,N_EXTERNAL_CFACE_CELLS+N_INTWALL_CFACE_CELLS+N_INTERNAL_CFACE_CELLS
      CFA => CFACE(ICF)
      B1 => BOUNDARY_PROP1(CFA%B1_INDEX)
      CFA%DUNDT = CFA%DUNDT + 2._EB*RDT*(B1%U_NORMAL-B1%U_NORMAL_S)
   ENDDO

ENDIF PREDICT_NORMALS

RETURN

END SUBROUTINE CFACE_PREDICT_NORMAL_VELOCITY


! ---------------------------- ROTATED_CUBE_VELOCITY_FLUX --------------------------

SUBROUTINE ROTATED_CUBE_VELOCITY_FLUX(NM,TLEVEL)

INTEGER, INTENT(IN) :: NM
REAL(EB), INTENT(IN):: TLEVEL

! Local Variables:
REAL(EB) :: XGLOB(2,1), XLOC(2,1), FGLOB(2,1), FLOC(2,1), X_I, Y_J, NU
INTEGER  :: I,J,K
REAL(EB), POINTER, DIMENSION(:,:,:) :: RHOP=>NULL()
REAL(EB) :: SIN_T, COS_T, COS_KX, SIN_KX, COS_KY, SIN_KY

CALL POINT_TO_MESH(NM)

IF (PREDICTOR) THEN
   RHOP => RHO
ELSE
   RHOP => RHOS
ENDIF

ROTANG = 0._EB
IF(PERIODIC_TEST==21) THEN
   ROTANG = 0._EB ! No rotation.
ELSEIF(PERIODIC_TEST==22) THEN
   ROTANG = ATAN(1._EB/2._EB) ! ~27 Degrees.
ELSEIF(PERIODIC_TEST==23) THEN
   ROTANG = ATAN(1._EB)       ! 45 degrees.
ELSE
   RETURN
ENDIF
ROTMAT(1,1) = COS(ROTANG); ROTMAT(1,2) = -SIN(ROTANG);
ROTMAT(2,1) = SIN(ROTANG); ROTMAT(2,2) =  COS(ROTANG);
TROTMAT = TRANSPOSE(ROTMAT)

COS_T = COS(TLEVEL)
SIN_T = SIN(TLEVEL)

! X Force:
DO K=1,KBAR
   DO J=1,JBAR
      DO I=0,IBAR
         IF (CC_IBM) THEN
            IF (FCVAR(I,J,K,CC_FGSC,IAXIS) == CC_SOLID) CYCLE    ! Stress method.
         ENDIF
         ! Kinematic Viscosity:
         NU = 0.5_EB*(MU(I,J,K)/RHOP(I,J,K) + MU(I+1,J,K)/RHOP(I+1,J,K))

         ! Global position:
         XGLOB(1:2,1) = (/ X(I), ZC(K) /)

         ! Local position:
         XGLOB(1:2,1) = XGLOB(1:2,1) - DISPL
         XLOC         = MATMUL(TROTMAT, XGLOB )
         XLOC( 1:2,1) = XLOC( 1:2,1) - DISPXY(1:2,1)

         X_I = XLOC(1,1); Y_J = XLOC(2,1)

         COS_KX = COS(NWAVE*X_I)
         SIN_KX = SIN(NWAVE*X_I)

         COS_KY = COS(NWAVE*Y_J)
         SIN_KY = SIN(NWAVE*Y_J)

         FLOC(1,1)=2._EB*COS_KY*SIN_KX**2._EB*SIN_KY*COS_T - &
         4._EB*NWAVE*SIN_KY*SIN_T*(COS_KX*SIN_KX**3._EB*SIN_KY*SIN_T + &
         NWAVE*NU*COS_KX**2._EB*COS_KY - 3._EB*NWAVE*NU*COS_KY*SIN_KX**2._EB) + &
         NWAVE*COS_KX*SIN_KX*SIN_T*(2._EB*COS_KY**2._EB + 1._EB);


         FLOC(2,1)= NWAVE*COS_KY*SIN_KY*SIN_T*(2._EB*COS_KX**2._EB + 1._EB) - &
         2._EB*COS_KX*SIN_KX*SIN_KY**2._EB*COS_T - &
         4._EB*NWAVE*SIN_KX*SIN_T*(COS_KY*SIN_KX*SIN_KY**3._EB*SIN_T - &
         NWAVE*NU*COS_KX*COS_KY**2._EB + 3._EB*NWAVE*NU*COS_KX*SIN_KY**2._EB);

         FGLOB        = MATMUL(ROTMAT, FLOC )

         FVX(I,J,K)   = FVX(I,J,K) + 0.5_EB*(RHOP(I,J,K)+RHOP(I+1,J,K))*FGLOB(IAXIS,1)

      ENDDO
   ENDDO
ENDDO


! Z Force:
DO K=0,KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         IF (CC_IBM) THEN
            IF (FCVAR(I,J,K,CC_FGSC,KAXIS) == CC_SOLID) CYCLE    ! Stress method.
         ENDIF
         ! Kinematic Viscosity:
         NU = 0.5_EB*(MU(I,J,K)/RHOP(I,J,K) + MU(I,J,K+1)/RHOP(I,J,K+1))

         ! Global position:
         XGLOB(1:2,1) = (/ XC(I), Z(K) /)

         ! Local position:
         XGLOB(1:2,1) = XGLOB(1:2,1) - DISPL
         XLOC         = MATMUL(TROTMAT, XGLOB )
         XLOC( 1:2,1) = XLOC( 1:2,1) - DISPXY(1:2,1)

         X_I = XLOC(1,1); Y_J = XLOC(2,1)

         COS_KX = COS(NWAVE*X_I)
         SIN_KX = SIN(NWAVE*X_I)

         COS_KY = COS(NWAVE*Y_J)
         SIN_KY = SIN(NWAVE*Y_J)

         FLOC(1,1)=2._EB*COS_KY*SIN_KX**2._EB*SIN_KY*COS_T - &
         4._EB*NWAVE*SIN_KY*SIN_T*(COS_KX*SIN_KX**3._EB*SIN_KY*SIN_T + &
         NWAVE*NU*COS_KX**2._EB*COS_KY - 3._EB*NWAVE*NU*COS_KY*SIN_KX**2._EB) + &
         NWAVE*COS_KX*SIN_KX*SIN_T*(2._EB*COS_KY**2._EB + 1._EB);


         FLOC(2,1)= NWAVE*COS_KY*SIN_KY*SIN_T*(2._EB*COS_KX**2._EB + 1._EB) - &
         2._EB*COS_KX*SIN_KX*SIN_KY**2._EB*COS_T - &
         4._EB*NWAVE*SIN_KX*SIN_T*(COS_KY*SIN_KX*SIN_KY**3._EB*SIN_T - &
         NWAVE*NU*COS_KX*COS_KY**2._EB + 3._EB*NWAVE*NU*COS_KX*SIN_KY**2._EB);

         FGLOB        = MATMUL(ROTMAT, FLOC )

         FVZ(I,J,K)   = FVZ(I,J,K) + 0.5_EB*(RHOP(I,J,K)+RHOP(I,J,K+1))*FGLOB(JAXIS,1)

      ENDDO
   ENDDO
ENDDO


RETURN
END SUBROUTINE ROTATED_CUBE_VELOCITY_FLUX

! ------------------------------ ROTATED_CUBE_ANN_SOLN ----------------------------

SUBROUTINE ROTATED_CUBE_ANN_SOLN(NM,TLEVEL)

INTEGER, INTENT(IN) :: NM
REAL(EB), INTENT(IN):: TLEVEL

! Local Variables:
REAL(EB) :: XGLOB(2,1), XLOC(2,1), UGLOB(2,1), ULOC(2,1), VEL_CF
INTEGER :: I,J,K,NFACE,X1AXIS,ICF,ICF2,ICC,JCC,NCELL

ROTANG = 0._EB
IF(PERIODIC_TEST==21) THEN
   ROTANG = 0._EB ! No rotation.
ELSEIF(PERIODIC_TEST==22) THEN
   ROTANG = ATAN(1._EB/2._EB) ! ~27 Degrees.
ELSEIF(PERIODIC_TEST==23) THEN
   ROTANG = ATAN(1._EB)       ! 45 degrees.
ELSE
   RETURN
ENDIF
ROTMAT(1,1) = COS(ROTANG); ROTMAT(1,2) = -SIN(ROTANG);
ROTMAT(2,1) = SIN(ROTANG); ROTMAT(2,2) =  COS(ROTANG);
TROTMAT = TRANSPOSE(ROTMAT)

CALL POINT_TO_MESH(NM)


! X Velocities:
DO K=0,KBP1
   DO J=0,JBP1
      DO I=0,IBAR
         ! Global position:
         XGLOB(1:2,1) = (/ X(I), ZC(K) /)

         ! Local position:
         XGLOB(1:2,1) = XGLOB(1:2,1) - DISPL
         XLOC         = MATMUL(TROTMAT, XGLOB )
         XLOC( 1:2,1) = XLOC( 1:2,1) - DISPXY(1:2,1)

         ! Velocity field in local axes:
         ULOC(IAXIS,1)= -SIN(NWAVE*XLOC(IAXIS,1))**2._EB * SIN(2._EB*NWAVE*XLOC(JAXIS,1))
         ULOC(JAXIS,1)=  SIN(2._EB*NWAVE*XLOC(IAXIS,1))  * SIN(NWAVE*XLOC(JAXIS,1))**2._EB

         ! Velocity field in global axes:
         UGLOB        = MATMUL(ROTMAT,ULOC)
         U(I,J,K)     = SIN(TLEVEL) * UGLOB(IAXIS,1)

      ENDDO
   ENDDO
ENDDO

! Y Velocities:
V(:,:,:)=0._EB

! Z Velocities:
DO K=0,KBAR
   DO J=0,JBP1
      DO I=0,IBP1
         ! Global position:
         XGLOB(1:2,1) = (/ XC(I), Z(K) /)

         ! Local position:
         XGLOB(1:2,1) = XGLOB(1:2,1) - DISPL
         XLOC         = MATMUL(TROTMAT, XGLOB )
         XLOC( 1:2,1) = XLOC( 1:2,1) - DISPXY(1:2,1)

         ! Velocity field in local axes:
         ULOC(IAXIS,1)= -SIN(NWAVE*XLOC(IAXIS,1))**2._EB * SIN(2._EB*NWAVE*XLOC(JAXIS,1))
         ULOC(JAXIS,1)=  SIN(2._EB*NWAVE*XLOC(IAXIS,1))  * SIN(NWAVE*XLOC(JAXIS,1))**2._EB

         ! Velocity field in global axes:
         UGLOB        = MATMUL(ROTMAT,ULOC)
         W(I,J,K)     = SIN(TLEVEL) * UGLOB(JAXIS,1)

      ENDDO
   ENDDO
ENDDO

! Now GASPHASE cut-faces:
IF (CC_IBM) THEN
   CUTFACE_LOOP : DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      NFACE  = CUT_FACE(ICF)%NFACE
      IF (CUT_FACE(ICF)%STATUS == CC_GASPHASE) THEN
         I      = CUT_FACE(ICF)%IJK(IAXIS)
         J      = CUT_FACE(ICF)%IJK(JAXIS)
         K      = CUT_FACE(ICF)%IJK(KAXIS)
         X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)
         DO ICF2=1,NFACE
            ! Global position:
            XGLOB(1:2,1) = (/ CUT_FACE(ICF)%XYZCEN(IAXIS,ICF2), CUT_FACE(ICF)%XYZCEN(KAXIS,ICF2) /)

            ! Local position:
            XGLOB(1:2,1) = XGLOB(1:2,1) - DISPL
            XLOC         = MATMUL(TROTMAT, XGLOB )
            XLOC( 1:2,1) = XLOC( 1:2,1) - DISPXY(1:2,1)

            ! Velocity field in local axes:
            ULOC(IAXIS,1)= -SIN(NWAVE*XLOC(IAXIS,1))**2._EB * SIN(2._EB*NWAVE*XLOC(JAXIS,1))
            ULOC(JAXIS,1)=  SIN(2._EB*NWAVE*XLOC(IAXIS,1))  * SIN(NWAVE*XLOC(JAXIS,1))**2._EB

            ! Velocity field in global axes:
            UGLOB        = MATMUL(ROTMAT,ULOC)
            SELECT CASE(X1AXIS)
            CASE(IAXIS)
               VEL_CF = SIN(TLEVEL) * UGLOB(IAXIS,1)
            CASE(JAXIS)
               VEL_CF = 0._EB
            CASE(KAXIS)
               VEL_CF = SIN(TLEVEL) * UGLOB(JAXIS,1)
            END SELECT

            CUT_FACE(ICF)%VEL(ICF2)  = VEL_CF
            CUT_FACE(ICF)%VELS(ICF2) = VEL_CF

         ENDDO

      ELSE ! CC_INBOUNDARY

         VEL_CF = 0._EB
         CUT_FACE(ICF)%VEL(1:NFACE)  = VEL_CF
         CUT_FACE(ICF)%VELS(1:NFACE) = VEL_CF

      ENDIF
   ENDDO CUTFACE_LOOP
ENDIF

! Fields for scalars:
! Regular cells:
DO K=0,KBP1
   DO J=0,JBP1
      DO I=0,IBP1
         IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
         ! Global position:
         XGLOB(1:2,1) = (/ XC(I), ZC(K) /)

         ! Local position:
         XGLOB(1:2,1) = XGLOB(1:2,1) - DISPL
         XLOC         = MATMUL(TROTMAT, XGLOB )
         XLOC( 1:2,1) = XLOC( 1:2,1) - DISPXY(1:2,1)

         ZZ(I,J,K,N_SPEC_NEUMN) = AMP_Z/3._EB*SIN(TLEVEL)*(1._EB-COS(2._EB*NWAVE*(XLOC(IAXIS,1)-GAM))) * &
                                                          (1._EB-COS(2._EB*NWAVE*(XLOC(JAXIS,1)-GAM)))   &
                                                          -AMP_Z/3._EB*SIN(TLEVEL) + MEAN_Z
         ZZ(I,J,K,N_SPEC_BACKG) = 1._EB - ZZ(I,J,K,N_SPEC_NEUMN)

      ENDDO
   ENDDO
ENDDO

! Cut cells:
IF (CC_IBM) THEN
   CUTCELL_LOOP : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      NCELL  = CUT_CELL(ICC)%NCELL
      DO JCC=1,NCELL
         ! Global position:
         XGLOB(1:2,1) = (/ CUT_CELL(ICC)%XYZCEN(IAXIS,JCC), CUT_CELL(ICC)%XYZCEN(KAXIS,JCC) /)

         ! Local position:
         XGLOB(1:2,1) = XGLOB(1:2,1) - DISPL
         XLOC         = MATMUL(TROTMAT, XGLOB )
         XLOC( 1:2,1) = XLOC( 1:2,1) - DISPXY(1:2,1)

         CUT_CELL(ICC)%ZZ(N_SPEC_NEUMN,JCC) = AMP_Z/3._EB*SIN(TLEVEL)*(1._EB-COS(2._EB*NWAVE*(XLOC(IAXIS,1)-GAM))) * &
                                                                      (1._EB-COS(2._EB*NWAVE*(XLOC(JAXIS,1)-GAM)))   &
                                                                      -AMP_Z/3._EB*SIN(TLEVEL) + MEAN_Z
         CUT_CELL(ICC)%ZZ(N_SPEC_BACKG,JCC) = 1._EB - CUT_CELL(ICC)%ZZ(N_SPEC_NEUMN,JCC)
      ENDDO
   ENDDO CUTCELL_LOOP
ENDIF


RETURN

END SUBROUTINE ROTATED_CUBE_ANN_SOLN

! ------------------------------ ROTATED_CUBE_RHS_ZZ -----------------------------------

SUBROUTINE ROTATED_CUBE_RHS_ZZ(TLEVEL,DT,NM)

USE MATH_FUNCTIONS, ONLY: INTERPOLATE1D_UNIFORM

REAL(EB), INTENT(IN) :: TLEVEL,DT
INTEGER, INTENT(IN)  :: NM

! Local Variables:
INTEGER :: I, J ,K
REAL(EB), POINTER, DIMENSION(:,:,:)   :: RHOP
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: ZZP
REAL(EB) :: D_Z_N(0:I_MAX_TEMP),XLOC(2,1),XGLOB(2,1),Q_ZN,D_Z_TEMP,RHO_IJK,DTFC
REAL(EB) :: SIN_T, COS_T

ROTANG = 0._EB
IF(PERIODIC_TEST==21) THEN
   ROTANG = 0._EB ! No rotation.
ELSEIF(PERIODIC_TEST==22) THEN
   ROTANG = ATAN(1._EB/2._EB) ! ~27 Degrees.
ELSEIF(PERIODIC_TEST==23) THEN
   ROTANG = ATAN(1._EB)       ! 45 degrees.
ELSE
   RETURN
ENDIF
ROTMAT(1,1) = COS(ROTANG); ROTMAT(1,2) = -SIN(ROTANG);
ROTMAT(2,1) = SIN(ROTANG); ROTMAT(2,2) =  COS(ROTANG);
TROTMAT = TRANSPOSE(ROTMAT)

SIN_T    = SIN(TLEVEL)
COS_T    = COS(TLEVEL)

CALL POINT_TO_MESH(NM)

IF (PREDICTOR) THEN
   RHOP => RHO
   ZZP  => ZZS
   DTFC = 1._EB
ELSE
   RHOP => RHOS
   ZZP  => ZZ
   DTFC = 0.5_EB
ENDIF

D_Z_N=D_Z(:,N_SPEC_NEUMN)

! Add Q_Z on regular cells:
DO K=1,KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
         IF (CC_IBM) THEN
            IF(CCVAR(I,J,K,CC_CGSC)/=CC_GASPHASE) CYCLE
            IF(CCVAR(I,J,K,CC_UNKZ)>0) CYCLE
         ENDIF
         ! Global position:
         XGLOB(1:2,1) = (/ XC(I), ZC(K) /)
         ! Local position:
         XGLOB(1:2,1) = XGLOB(1:2,1) - DISPL
         XLOC         = MATMUL(TROTMAT, XGLOB )
         XLOC( 1:2,1) = XLOC( 1:2,1) - DISPXY(1:2,1)
         RHO_IJK = RHOP(I,J,K)
         CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMP(I,J,K),D_Z_TEMP)
         CALL ROTATED_CUBE_NEUMN_FZ(SIN_T,COS_T,RHO_IJK,D_Z_TEMP,XLOC,Q_ZN)

         ! Update species:
         ZZP(I,J,K,N_SPEC_NEUMN) = ZZP(I,J,K,N_SPEC_NEUMN) + DTFC*DT*Q_ZN
         ZZP(I,J,K,N_SPEC_BACKG) = ZZP(I,J,K,N_SPEC_BACKG) - DTFC*DT*Q_ZN
      ENDDO
   ENDDO
ENDDO


RETURN
END SUBROUTINE ROTATED_CUBE_RHS_ZZ

! ------------------------- CC_ROTATED_CUBE_RHS_ZZ -------------------------------

SUBROUTINE CC_ROTATED_CUBE_RHS_ZZ(TLEVEL,N)

USE MATH_FUNCTIONS, ONLY: INTERPOLATE1D_UNIFORM

REAL(EB), INTENT(IN) :: TLEVEL
INTEGER, INTENT(IN)  :: N

! Local Variables:
INTEGER :: NM, I, J ,K, IROW, ICC, JCC
REAL(EB), POINTER, DIMENSION(:,:,:) :: RHOP
REAL(EB) :: PREDFCT,D_Z_N(0:I_MAX_TEMP),XLOC(2,1),XGLOB(2,1),Q_Z,D_Z_TEMP,RHO_IJK,FCT
REAL(EB) :: SIN_T, COS_T

ROTANG = 0._EB
IF(PERIODIC_TEST==21) THEN
   ROTANG = 0._EB ! No rotation.
ELSEIF(PERIODIC_TEST==22) THEN
   ROTANG = ATAN(1._EB/2._EB) ! ~27 Degrees.
ELSEIF(PERIODIC_TEST==23) THEN
   ROTANG = ATAN(1._EB)       ! 45 degrees.
ELSE
   RETURN
ENDIF
ROTMAT(1,1) = COS(ROTANG); ROTMAT(1,2) = -SIN(ROTANG);
ROTMAT(2,1) = SIN(ROTANG); ROTMAT(2,2) =  COS(ROTANG);
TROTMAT = TRANSPOSE(ROTMAT)

SIN_T    = SIN(TLEVEL)
COS_T    = COS(TLEVEL)

MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN
      PREDFCT=1._EB
      RHOP => RHO
   ELSE
      PREDFCT=0._EB
      RHOP => RHOS
   ENDIF

   D_Z_N = D_Z(:,N)

   ! First add Q_Z on regular cells to source F_Z:
   IF (N==N_SPEC_BACKG) THEN
      FCT=-1._EB
   ELSEIF (N==N_SPEC_NEUMN) THEN
      FCT=1._EB
   ENDIF

   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF(CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
            IROW = CCVAR(I,J,K,CC_UNKZ) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
            ! Global position:
            XGLOB(1:2,1) = (/ XC(I), ZC(K) /)
            ! Local position:
            XGLOB(1:2,1) = XGLOB(1:2,1) - DISPL
            XLOC         = MATMUL(TROTMAT, XGLOB )
            XLOC( 1:2,1) = XLOC( 1:2,1) - DISPXY(1:2,1)
            CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMP(I,J,K),D_Z_TEMP)
            RHO_IJK = RHOP(I,J,K)
            CALL ROTATED_CUBE_NEUMN_FZ(SIN_T,COS_T,RHO_IJK,D_Z_TEMP,XLOC,Q_Z)
            F_Z(IROW) = F_Z(IROW) - FCT*Q_Z*DX(I)*DY(J)*DZ(K)
         ENDDO
      ENDDO
   ENDDO
   ! Then add Cut-cell contributions to F_Z:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      DO JCC=1,CUT_CELL(ICC)%NCELL
         IROW = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
         ! Global position:
         XGLOB(1:2,1) = (/ CUT_CELL(ICC)%XYZCEN(IAXIS,JCC), CUT_CELL(ICC)%XYZCEN(KAXIS,JCC) /)
         ! Local position:
         XGLOB(1:2,1) = XGLOB(1:2,1) - DISPL
         XLOC         = MATMUL(TROTMAT, XGLOB )
         XLOC( 1:2,1) = XLOC( 1:2,1) - DISPXY(1:2,1)
         CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,CUT_CELL(ICC)%TMP(JCC),D_Z_TEMP)
         RHO_IJK = (1._EB - PREDFCT)*CUT_CELL(ICC)%RHOS(JCC) + PREDFCT*CUT_CELL(ICC)%RHO(JCC)
         CALL ROTATED_CUBE_NEUMN_FZ(SIN_T,COS_T,RHO_IJK,D_Z_TEMP,XLOC,Q_Z)
         F_Z(IROW) = F_Z(IROW) - FCT*Q_Z*CUT_CELL(ICC)%VOLUME(JCC)
      ENDDO
   ENDDO

ENDDO MESH_LOOP


RETURN
END SUBROUTINE CC_ROTATED_CUBE_RHS_ZZ

! ---------------------------------- ROTATED_CUBE_NEUMN_FZ ---------------------------------

SUBROUTINE ROTATED_CUBE_NEUMN_FZ(SIN_T,COS_T,RHO_IJK,D_Z_TEMP,XLOC,Q_Z)

REAL(EB), INTENT(IN) :: SIN_T,COS_T, RHO_IJK, D_Z_TEMP, XLOC(2,1)
REAL(EB), INTENT(OUT):: Q_Z

! Local Variables:
REAL(EB) :: COS_2KGX, COS_2KGZ, SIN_2KGX, SIN_2KGZ
REAL(EB) :: COS_KX, COS_KZ, SIN_KX, SIN_KZ
REAL(EB) :: SIN_2KX, SIN_2KZ

Q_Z=0._EB

COS_2KGX = COS(2._EB*NWAVE*(GAM - XLOC(IAXIS,1)))
COS_2KGZ = COS(2._EB*NWAVE*(GAM - XLOC(JAXIS,1)))

SIN_2KGX = SIN(2._EB*NWAVE*(GAM - XLOC(IAXIS,1)))
SIN_2KGZ = SIN(2._EB*NWAVE*(GAM - XLOC(JAXIS,1)))

COS_KX   = COS(NWAVE*XLOC(IAXIS,1))
COS_KZ   = COS(NWAVE*XLOC(JAXIS,1))
SIN_KX   = SIN(NWAVE*XLOC(IAXIS,1))
SIN_KZ   = SIN(NWAVE*XLOC(JAXIS,1))

SIN_2KX  = SIN(2._EB*NWAVE*XLOC(IAXIS,1))
SIN_2KZ  = SIN(2._EB*NWAVE*XLOC(JAXIS,1))

Q_Z = (4._EB*AMP_Z*D_Z_TEMP*NWAVE**2*RHO_IJK*COS_2KGX*SIN_T*(COS_2KGZ - 1._EB))/3._EB - &
       RHO_IJK*((AMP_Z*COS_T)/3._EB - (AMP_Z*COS_T*(COS_2KGX - 1._EB)*(COS_2KGZ - 1._EB))/3._EB) + &
      (4._EB*AMP_Z*D_Z_TEMP*NWAVE**2*RHO_IJK*COS_2KGZ*SIN_T*(COS_2KGX - 1._EB))/3._EB - &
       2._EB*NWAVE*RHO_IJK*COS_KX*SIN_KX*SIN_2KZ*SIN_T*(MEAN_Z - &
      (AMP_Z*SIN_T)/3._EB + (AMP_Z*SIN_T*(COS_2KGX - 1._EB)*(COS_2KGZ - 1._EB))/3._EB) + &
       2._EB*NWAVE*RHO_IJK*COS_KZ*SIN_2KX*SIN_KZ*SIN_T*(MEAN_Z - (AMP_Z*SIN_T)/3._EB + &
      (AMP_Z*SIN_T*(COS_2KGX - 1._EB)*(COS_2KGZ - 1._EB))/3._EB) + &
      (2._EB*AMP_Z*NWAVE*RHO_IJK*SIN_2KX*SIN_KZ**2*SIN_2KGZ*SIN_T**2*(COS_2KGX - 1._EB))/3._EB - &
      (2._EB*AMP_Z*NWAVE*RHO_IJK*SIN_KX**2*SIN_2KZ*SIN_2KGX*SIN_T**2*(COS_2KGZ - 1._EB))/3._EB


RETURN
END SUBROUTINE ROTATED_CUBE_NEUMN_FZ


! --------------------------------- GET_SHUNN3_QZ --------------------------------

SUBROUTINE GET_SHUNN3_QZ(T,N)

USE MANUFACTURED_SOLUTIONS, ONLY: UF_MMS,WF_MMS,VD2D_MMS_Z_SRC

REAL(EB),INTENT(IN) :: T
INTEGER, INTENT(IN) :: N

! Local Variables:
INTEGER I,J,K,NM,IROW,ICC,JCC
REAL(EB) :: FCT,XHAT,ZHAT,Q_Z

FCT=REAL(2*(1-N)+1,EB)

! Mesh Loop:
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! First add Q_Z on regular cells to source F_Z:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF(CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
            IROW = CCVAR(I,J,K,CC_UNKZ) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
            ! divergence from EOS
            XHAT = XC(I) - UF_MMS*T
            ZHAT = ZC(K) - WF_MMS*T
            Q_Z = VD2D_MMS_Z_SRC(XHAT,ZHAT,T)
            F_Z(IROW) = F_Z(IROW) + FCT*Q_Z*DX(I)*DY(J)*DZ(K)
         ENDDO
      ENDDO
   ENDDO

   ! Then add Cut-cell contributions to F_Z:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      DO JCC=1,CUT_CELL(ICC)%NCELL
         IROW = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
         ! divergence from EOS
         XHAT = CUT_CELL(ICC)%XYZCEN(IAXIS,JCC) - UF_MMS*T
         ZHAT = CUT_CELL(ICC)%XYZCEN(KAXIS,JCC) - WF_MMS*T
         Q_Z = VD2D_MMS_Z_SRC(XHAT,ZHAT,T)
         F_Z(IROW) = F_Z(IROW) + FCT*Q_Z*CUT_CELL(ICC)%VOLUME(JCC)
      ENDDO
   ENDDO

ENDDO MESH_LOOP

RETURN
END SUBROUTINE GET_SHUNN3_QZ


! ---------------------------------- GET_MUDNS_CFACE --------------------------------

SUBROUTINE GET_MUDNS_CFACE(MU_WALL,IND1,IND2)

USE PHYSICAL_FUNCTIONS, ONLY : GET_VISCOSITY

REAL(EB), INTENT(OUT)::  MU_WALL
INTEGER, INTENT(IN) :: IND1,IND2

! Local Variables:
INTEGER :: VIND, EP, INT_NPE_LO, INT_NPE_HI, INPE, ICC, IIG, JJG, KKG
REAL(EB):: MU_DNS_EP, TMP_EP, ZZ_GET(1:N_TRACKED_SPECIES)

! Cell-centered variables:
VIND=0;  EP  =1
INT_NPE_LO  = CUT_FACE(IND1)%INT_NPE( LOW_IND,VIND,EP,IND2)
INT_NPE_HI  = CUT_FACE(IND1)%INT_NPE(HIGH_IND,VIND,EP,IND2)
IF (INT_NPE_HI > 0) THEN
   MU_WALL=0._EB
   DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
      ! Compute MU_DNS for INPE:
      ZZ_GET(1:N_TRACKED_SPECIES) = CUT_FACE(IND1)%INT_CVARS(INT_P_IND+1:INT_P_IND+N_TRACKED_SPECIES,INPE)
      TMP_EP = CUT_FACE(IND1)%INT_CVARS( INT_TMP_IND,INPE)
      CALL GET_VISCOSITY(ZZ_GET,MU_DNS_EP,TMP_EP)
      ! Add to MU_WALL:
      MU_WALL = MU_WALL + CUT_FACE(IND1)%INT_COEF(INPE)*MU_DNS_EP
   ENDDO
ELSE
   ! Underlying cell approximate value:
   ICC = CUT_FACE(IND1)%CELL_LIST(2,LOW_IND,IND2)
   IIG = CUT_CELL(ICC)%IJK(1)
   JJG = CUT_CELL(ICC)%IJK(2)
   KKG = CUT_CELL(ICC)%IJK(3)
   MU_WALL = MU_DNS(IIG,JJG,KKG)
ENDIF

RETURN
END SUBROUTINE GET_MUDNS_CFACE

! ---------------------------------- GET_UVWGAS_CFACE --------------------------------

SUBROUTINE GET_UVWGAS_CFACE(U_CELL,V_CELL,W_CELL,IND1,IND2,UP,VP,WP,PREDFCT)

INTEGER, INTENT(IN) :: IND1,IND2
REAL(EB),INTENT(OUT):: U_CELL,V_CELL,W_CELL
REAL(EB), POINTER, DIMENSION(:,:,:), INTENT(IN) :: UP,VP,WP
REAL(EB), INTENT(IN) :: PREDFCT

! Local Variables:
REAL(EB):: AF,VELN, U_AREA, V_AREA, W_AREA, NX, NY, NZ
INTEGER :: ICC, JCC, I, J, K, NFCELL, ICCF, IFACE, LOWHIGH, X1AXIS, ILH, IFC2, IFACE2, IBOD, IWSEL

U_CELL=0._EB; V_CELL=0._EB; W_CELL=0._EB
U_AREA= 0._EB; V_AREA= 0._EB; W_AREA= 0._EB
! Finally U velocity: Compute the Area average component on each direction:
ICC = CUT_FACE(IND1)%CELL_LIST(2,LOW_IND,IND2)
JCC = CUT_FACE(IND1)%CELL_LIST(3,LOW_IND,IND2)
I = CUT_CELL(ICC)%IJK(IAXIS)
J = CUT_CELL(ICC)%IJK(JAXIS)
K = CUT_CELL(ICC)%IJK(KAXIS)
NFCELL=CUT_CELL(ICC)%CCELEM(1,JCC)
DO ICCF=1,NFCELL
   IFACE=CUT_CELL(ICC)%CCELEM(ICCF+1,JCC)
   SELECT CASE(CUT_CELL(ICC)%FACE_LIST(1,IFACE))
   CASE(CC_FTYPE_RCGAS) ! REGULAR GASPHASE
      LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
      X1AXIS  = CUT_CELL(ICC)%FACE_LIST(3,IFACE)
      ILH     = LOWHIGH - 1
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         AF     = DY(J)*DZ(K)
         U_CELL = U_CELL + AF*UP(I-1+ILH,J,K); U_AREA = U_AREA + AF
      CASE(JAXIS)
         AF     = DX(I)*DZ(K)
         V_CELL = V_CELL + AF*VP(I,J-1+ILH,K); V_AREA = V_AREA + AF
      CASE(KAXIS)
         AF     = DX(I)*DY(J)
         W_CELL = W_CELL + AF*WP(I,J,K-1+ILH); W_AREA = W_AREA + AF
      END SELECT

   CASE(CC_FTYPE_CFGAS)
      LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
      IFC2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
      IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
      X1AXIS  = CUT_FACE(IFC2)%IJK(KAXIS+1)
      AF      = CUT_FACE(IFC2)%AREA(IFACE2)
      VELN    =        PREDFCT *CUT_FACE(IFC2)%VEL( IFACE2) + &
                  (1._EB-PREDFCT)*CUT_FACE(IFC2)%VELS(IFACE2)

      SELECT CASE(X1AXIS)
      CASE(IAXIS); U_CELL= U_CELL + AF*VELN; U_AREA = U_AREA + AF
      CASE(JAXIS); V_CELL= V_CELL + AF*VELN; V_AREA = V_AREA + AF
      CASE(KAXIS); W_CELL= W_CELL + AF*VELN; W_AREA = W_AREA + AF
      END SELECT

   CASE(CC_FTYPE_CFINB)
      IFC2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
      IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)

      AF      = CUT_FACE(IFC2)%AREA(IFACE2)
      ! Normal velocity defined into the body. We want velocity in direction of normal out of bod.
      VELN    = -1._EB*(       PREDFCT *CUT_FACE(IFC2)%VEL( IFACE2) + &
                        (1._EB-PREDFCT)*CUT_FACE(IFC2)%VELS(IFACE2))

      ! Fetch normal out of body on surface triangle this cface lives in:
      IBOD =CUT_FACE(IFC2)%BODTRI(1,IFACE2)
      IWSEL=CUT_FACE(IFC2)%BODTRI(2,IFACE2)
      NX = GEOMETRY(IBOD)%FACES_NORMAL(IAXIS,IWSEL)
      NY = GEOMETRY(IBOD)%FACES_NORMAL(JAXIS,IWSEL)
      NZ = GEOMETRY(IBOD)%FACES_NORMAL(KAXIS,IWSEL)
      U_CELL = U_CELL + AF*VELN*NX; U_AREA = U_AREA + AF*ABS(NX)
      V_CELL = V_CELL + AF*VELN*NY; V_AREA = V_AREA + AF*ABS(NY)
      W_CELL = W_CELL + AF*VELN*NZ; W_AREA = W_AREA + AF*ABS(NZ)
   END SELECT
ENDDO
! Normalize by area:
IF(U_AREA > TWO_EPSILON_EB) U_CELL = U_CELL / U_AREA
IF(V_AREA > TWO_EPSILON_EB) V_CELL = V_CELL / V_AREA
IF(W_AREA > TWO_EPSILON_EB) W_CELL = W_CELL / W_AREA

RETURN
END SUBROUTINE GET_UVWGAS_CFACE

! ----------------------------------- GET_PRES_CFACE ---------------------------------

SUBROUTINE GET_PRES_CFACE(PRESS,IND1,IND2,CFA)

TYPE(CFACE_TYPE), INTENT(IN) :: CFA
INTEGER,  INTENT( IN) :: IND1, IND2
REAL(EB), INTENT(OUT) :: PRESS

! Local Variables:
INTEGER :: ICC, IIG, JJG, KKG
TYPE(BOUNDARY_PROP1_TYPE), POINTER :: B1

B1 => BOUNDARY_PROP1(CFA%B1_INDEX)
! Underlying cell values corresponding to cut-cell:
ICC = CUT_FACE(IND1)%CELL_LIST(2,LOW_IND,IND2)
IIG = CUT_CELL(ICC)%IJK(IAXIS)
JJG = CUT_CELL(ICC)%IJK(JAXIS)
KKG = CUT_CELL(ICC)%IJK(KAXIS)
PRESS=B1%RHO_G*(H(IIG,JJG,KKG)-KRES(IIG,JJG,KKG))

RETURN
END SUBROUTINE GET_PRES_CFACE

! ----------------------------------- GET_PRES_CFACE_TEST ---------------------------------

SUBROUTINE GET_PRES_CFACE_TEST(PRESS,IND1,IND2,CFA)

TYPE(CFACE_TYPE), INTENT(IN) :: CFA
INTEGER,  INTENT( IN) :: IND1, IND2
REAL(EB), INTENT(OUT) :: PRESS
TYPE(BOUNDARY_PROP1_TYPE), POINTER :: B1

! Local Variables:
INTEGER :: VIND, EP, INT_NPE_LO, INT_NPE_HI, INPE, ICC, IIG, JJG, KKG

! Cell-centered variables:
VIND=0;  EP  =1
INT_NPE_LO  = CUT_FACE(IND1)%INT_NPE( LOW_IND,VIND,EP,IND2)
INT_NPE_HI  = CUT_FACE(IND1)%INT_NPE(HIGH_IND,VIND,EP,IND2)
IF (INT_NPE_HI > 0) THEN
   PRESS=0._EB
   DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
      ! PRESS = PRESS + CUT_FACE(IND1)%INT_COEF(INPE)*CUT_FACE(IND1)%INT_CVARS( INT_P_IND,INPE)
      PRESS = PRESS + CUT_FACE(IND1)%INT_COEF(INPE)* &
      CUT_FACE(IND1)%INT_CVARS( INT_RHO_IND,INPE)*CUT_FACE(IND1)%INT_CVARS( INT_H_IND,INPE)
   ENDDO
ELSE
   B1 => BOUNDARY_PROP1(CFA%B1_INDEX)
   ! Underlying cell approximate value:
   ICC = CUT_FACE(IND1)%CELL_LIST(2,LOW_IND,IND2)
   IIG = CUT_CELL(ICC)%IJK(1)
   JJG = CUT_CELL(ICC)%IJK(2)
   KKG = CUT_CELL(ICC)%IJK(3)
   PRESS=B1%RHO_G*H(IIG,JJG,KKG)
ENDIF

RETURN
END SUBROUTINE GET_PRES_CFACE_TEST

! ------------------------------- CFACE_THERMAL_GASVARS ------------------------------

SUBROUTINE CFACE_THERMAL_GASVARS(ICF,SF,B1,T)
USE MATH_FUNCTIONS, ONLY: EVALUATE_RAMP
TYPE(SURFACE_TYPE), POINTER :: SF
TYPE(BOUNDARY_PROP1_TYPE) :: B1
INTEGER, INTENT(IN) :: ICF
REAL(EB),INTENT(IN) :: T

! Local Variables:
INTEGER :: IND1, IND2, ICC, JCC, I ,J ,K
REAL(EB):: PREDFCT,U_CAVG,V_CAVG,W_CAVG,K_G
REAL(EB), POINTER, DIMENSION(:,:,:) :: UP,VP,WP
TYPE(CFACE_TYPE),          POINTER :: CFA
TYPE(BOUNDARY_COORD_TYPE), POINTER :: BC

CFA => CFACE(ICF)
BC => BOUNDARY_COORD(CFA%BC_INDEX)
! Load indexes {ICF,IFACE} in CUT_FACE, for CFACE {ICFACE}:
IND1=CFA%CUT_FACE_IND1
IND2=CFA%CUT_FACE_IND2

IF (PREDICTOR) THEN
   PREDFCT=1._EB
   UP => U ! Corrector final velocities.
   VP => V
   WP => W
ELSE
   PREDFCT=0._EB
   UP => US ! Predictor final velocities.
   VP => VS
   WP => WS
ENDIF
SELECT CASE(CUT_FACE(IND1)%CELL_LIST(1,LOW_IND,IND2))
CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use value from CUT_CELL data struct:

   ICC = CUT_FACE(IND1)%CELL_LIST(2,LOW_IND,IND2)
   JCC = CUT_FACE(IND1)%CELL_LIST(3,LOW_IND,IND2)

   I = CUT_CELL(ICC)%IJK(IAXIS)
   J = CUT_CELL(ICC)%IJK(JAXIS)
   K = CUT_CELL(ICC)%IJK(KAXIS)

   ! ADD CUT_CELL properties:
   IF (SF%TMP_GAS_FRONT > 0._EB) THEN
      B1%TMP_G = TMPA + EVALUATE_RAMP(T-T_BEGIN,SF%RAMP(TIME_TGF)%INDEX)*(SF%TMP_GAS_FRONT-TMPA)
   ELSE
      B1%TMP_G = CUT_CELL(ICC)%TMP(JCC)
   ENDIF
   CFA%RSUM_G= CUT_CELL(ICC)%RSUM(JCC)

   ! Mixture density and Species mass fractions:
   B1%RHO_G = PREDFCT*CUT_CELL(ICC)%RHOS(JCC) + (1._EB-PREDFCT)*CUT_CELL(ICC)%RHO(JCC)
   B1%ZZ_G(1:N_TRACKED_SPECIES) = PREDFCT *CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC) + &
                              (1._EB-PREDFCT)*CUT_CELL(ICC)% ZZ(1:N_TRACKED_SPECIES,JCC)

   ! Viscosity, Use MU from bearing cartesian cell:
   CFA%MU_G = MU(I,J,K)

   ! Gas conductivity:
   CALL GET_CC_CELL_CONDUCTIVITY(B1%ZZ_G(1:N_TRACKED_SPECIES),MU(I,J,K),MU_DNS(I,J,K),B1%TMP_G,K_G)
   B1%K_G = K_G

   CALL GET_UVWGAS_CFACE(U_CAVG,V_CAVG,W_CAVG,IND1,IND2,UP,VP,WP,PREDFCT)

   ! U_TANG use the norm of CC centroid area averaged velocity:
   B1%U_TANG = SQRT( U_CAVG**2._EB + V_CAVG**2._EB + W_CAVG**2._EB )

END SELECT

END SUBROUTINE CFACE_THERMAL_GASVARS

! -------------------------- CC_VELOCITY_CUTFACES ----------------------------

SUBROUTINE CC_VELOCITY_CUTFACES(APPLY_TO_ESTIMATED_VARIABLES)

LOGICAL, INTENT(IN) :: APPLY_TO_ESTIMATED_VARIABLES

! Local Variables:
INTEGER  :: NM,ICF,I,J,K,X1AXIS
REAL(EB) :: AREATOT, A_CART
REAL(EB), POINTER, DIMENSION(:,:,:) :: UP,VP,WP
TYPE(CC_CUTFACE_TYPE), POINTER :: CF=>NULL()

! Mesh Loop:
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   CALL POINT_TO_MESH(NM)
   IF (APPLY_TO_ESTIMATED_VARIABLES) THEN
      UP => US ! Predictor final velocities.
      VP => VS
      WP => WS
   ELSE
      UP => U  ! Corrector final velocities.
      VP => V
      WP => W
   ENDIF

   ! Cut-face Loop:
   CUTFACE_LOOP_1 : DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      CF => CUT_FACE(ICF); IF (CF%STATUS /= CC_GASPHASE) CYCLE
      I  =  CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
      AREATOT= SUM(CF%AREA(1:CF%NFACE))
      IF (APPLY_TO_ESTIMATED_VARIABLES) THEN
         CF%VEL_CF = DOT_PRODUCT(CF%VELS(1:CF%NFACE),CF%AREA(1:CF%NFACE))/AREATOT
      ELSE
         CF%VEL_CF = DOT_PRODUCT(CF%VEL(1:CF%NFACE) ,CF%AREA(1:CF%NFACE))/AREATOT
      ENDIF
      SELECT CASE(X1AXIS)
      CASE(IAXIS); A_CART = DY(J)*DZ(K); CF%VEL_CRT= CF%VEL_CF*AREATOT/A_CART; UP(I,J,K) = CF%VEL_CRT
      CASE(JAXIS); A_CART = DZ(K)*DX(I); CF%VEL_CRT= CF%VEL_CF*AREATOT/A_CART; VP(I,J,K) = CF%VEL_CRT
      CASE(KAXIS); A_CART = DX(I)*DY(J); CF%VEL_CRT= CF%VEL_CF*AREATOT/A_CART; WP(I,J,K) = CF%VEL_CRT
      END SELECT
   ENDDO CUTFACE_LOOP_1

ENDDO MESH_LOOP


RETURN
END SUBROUTINE CC_VELOCITY_CUTFACES


! ----------------------------- CC_RHO0W_INTERP ------------------------------

SUBROUTINE CC_RHO0W_INTERP

! Local Variables:
REAL(EB), POINTER, DIMENSION(:,:,:) :: WP
INTEGER :: NM, ICC, NCELL, ICELL
INTEGER :: I, J ,K, INBFC_CCCEN(1:3)
REAL(EB):: XYZ_PP(MAX_DIM)
REAL(EB):: TNOW
INTEGER :: INPE,INT_NPE_LO,INT_NPE_HI,EP,VIND
REAL(EB):: RHO0_EP,RHO0_BP,WCEN_EP,WCEN_BP,COEF_EP,COEF_BP

! This routines interpolates RHO_0 and W velocity component to cut-cell centers,
! It is used when stratification is .TRUE.

IF (.NOT. STRATIFICATION) RETURN
IF (PERIODIC_TEST == 103 .OR. PERIODIC_TEST == 11 .OR. PERIODIC_TEST==7) RETURN

TNOW = CURRENT_TIME()

MESH_LOOP : DO NM=1,NMESHES

   IF (PROCESS(NM)/=MY_RANK) CYCLE

   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN
      WP => WS ! End of step velocities.
   ELSE
      WP => W
   ENDIF

   VIND = 0
   ICC_LOOP_3 : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      NCELL  = CUT_CELL(ICC)%NCELL
      I      = CUT_CELL(ICC)%IJK(IAXIS)
      J      = CUT_CELL(ICC)%IJK(JAXIS)
      K      = CUT_CELL(ICC)%IJK(KAXIS)
      RHO0_BP = RHO_0(K)
      DO ICELL=1,NCELL
         RHO0_EP = 0._EB
         WCEN_EP = 0._EB
         DO EP=1,INT_N_EXT_PTS  ! External point for cell ICELL
            INT_NPE_LO = CUT_CELL(ICC)%INT_NPE(LOW_IND,VIND,EP,ICELL)
            INT_NPE_HI = CUT_CELL(ICC)%INT_NPE(HIGH_IND,VIND,EP,ICELL)
            DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
               RHO0_EP = RHO0_EP + CUT_CELL(ICC)%INT_COEF(INPE)* &
                                   CUT_CELL(ICC)%INT_CCVARS(INT_RHO0_IND,INPE)
               WCEN_EP = WCEN_EP + CUT_CELL(ICC)%INT_COEF(INPE)* &
                                   CUT_CELL(ICC)%INT_CCVARS(INT_WCEN_IND,INPE)
            ENDDO
         ENDDO

         XYZ_PP(IAXIS:KAXIS) = CUT_CELL(ICC)%INT_XYZBF(IAXIS:KAXIS,ICELL)
         INBFC_CCCEN(1:3)    = CUT_CELL(ICC)%INT_INBFC(1:3,ICELL)

         CALL GET_BOUND_VEL(KAXIS,INBFC_CCCEN,XYZ_PP,WCEN_BP)

         COEF_EP = 0._EB
         IF (ABS(CUT_CELL(ICC)%INT_XN(1,ICELL)) > TWO_EPSILON_EB) &
         COEF_EP = CUT_CELL(ICC)%INT_XN(0,ICELL)/CUT_CELL(ICC)%INT_XN(1,ICELL)
         COEF_BP = 1._EB - COEF_EP

         !CUT_CELL(ICC)%RHO_0(ICELL) = COEF_BP*RHO0_BP + COEF_EP*RHO0_EP
         CUT_CELL(ICC)%WVEL(ICELL)  = COEF_BP*WCEN_BP + COEF_EP*WCEN_EP

      ENDDO
   ENDDO ICC_LOOP_3

   NULLIFY(WP)

ENDDO MESH_LOOP

T_USED(14) = T_USED(14) + CURRENT_TIME() - TNOW
RETURN
END SUBROUTINE CC_RHO0W_INTERP

! ------------------------------- CC_H_INTERP --------------------------------

SUBROUTINE CC_H_INTERP

! Local Variables:
REAL(EB), POINTER, DIMENSION(:,:,:) :: UP,VP,WP,HP
INTEGER :: NM, ICC, NCELL, I, J ,K
REAL(EB):: VCRT
LOGICAL :: VOLFLG

! This routine interpolates H to cut cells/Cartesian cells at the end of step.
! Makes use of dH/dXn boundary condition on immersed solid surfaces.

! Interpolate H in cut-cells:
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN
      HP => H
      UP => US ! End of step velocities.
      VP => VS
      WP => WS
   ELSE
      HP => HS
      UP => U ! End of step velocities.
      VP => V
      WP => W
   ENDIF

   ! Interpolate to cut-cells. Cut-cell loop:
   ICC_LOOP : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH

      NCELL  = CUT_CELL(ICC)%NCELL

      I      = CUT_CELL(ICC)%IJK(IAXIS)
      J      = CUT_CELL(ICC)%IJK(JAXIS)
      K      = CUT_CELL(ICC)%IJK(KAXIS)
      VCRT   = DX(I)*DY(J)*DZ(K)

      VOLFLG = .FALSE.
      IF(NCELL > 0) VOLFLG = ABS(VCRT-CUT_CELL(ICC)%VOLUME(1)) < LOOSEPS*VCRT
      IF(PERIODIC_TEST == 103 .OR. PERIODIC_TEST == 11 .OR. PERIODIC_TEST==7 .OR. VOLFLG) THEN
         IF (PREDICTOR) THEN
            CUT_CELL(ICC)%H(1:NCELL) = HP(I,J,K)
         ELSE
            CUT_CELL(ICC)%HS(1:NCELL) = HP(I,J,K)
         ENDIF
         CYCLE
      ENDIF

      ! Unstructured projection:
      IF (.NOT.ONE_UNKH_PER_CUTCELL) THEN
         IF (PREDICTOR) THEN
            CUT_CELL(ICC)%H(1:NCELL) = HP(I,J,K) ! Use underlying value of HP.
         ELSE
            CUT_CELL(ICC)%HS(1:NCELL) = HP(I,J,K)
         ENDIF
      ENDIF

   ENDDO ICC_LOOP

   ! Finally set HP to zero inside immersed solids:
   WHERE(MESHES(NM)%CCVAR(0:IBP1,0:JBP1,0:KBP1,CC_CGSC)==CC_SOLID) HP(0:IBP1,0:JBP1,0:KBP1) = 0._EB

   ! Set velocities on solid faces to zero:
   WHERE(MESHES(NM)%FCVAR(0:IBAR,1:JBAR,1:KBAR,CC_FGSC,IAXIS)==CC_SOLID) UP(0:IBAR,1:JBAR,1:KBAR) = 0._EB
   WHERE(MESHES(NM)%FCVAR(1:IBAR,0:JBAR,1:KBAR,CC_FGSC,JAXIS)==CC_SOLID) VP(1:IBAR,0:JBAR,1:KBAR) = 0._EB
   WHERE(MESHES(NM)%FCVAR(1:IBAR,1:JBAR,0:KBAR,CC_FGSC,KAXIS)==CC_SOLID) WP(1:IBAR,1:JBAR,0:KBAR) = 0._EB

   NULLIFY(UP,VP,WP,HP)

ENDDO MESH_LOOP

RETURN
END SUBROUTINE CC_H_INTERP


! ----------------------------- CCCOMPUTE_RADIATION --------------------------------

SUBROUTINE CCCOMPUTE_RADIATION(T,NM,ITER)

! This is a temporary container where to add QR=-CHI_R*Q

INTEGER, INTENT(IN) :: NM,ITER
REAL(EB), INTENT(IN) :: T

! Local Variables:
INTEGER ICC, JCC, I, J, K, NCELL
REAL(EB):: DUMMY1
INTEGER :: DUMMY2
REAL(EB) :: TNOW

DUMMY1=T
DUMMY2=ITER

TNOW = CURRENT_TIME()

IF(.NOT.RADIATION) THEN
   IF (N_REACTIONS>0) THEN
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            CUT_CELL(ICC)%QR(JCC) = -CUT_CELL(ICC)%CHI_R(JCC)*CUT_CELL(ICC)%Q(JCC)
         ENDDO
      ENDDO
   ENDIF
ELSE
   ! Solution for QR in underlaying Cartesian cell, coming from RADIATION_FVM
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      I = CUT_CELL(ICC)%IJK(IAXIS)
      J = CUT_CELL(ICC)%IJK(JAXIS)
      K = CUT_CELL(ICC)%IJK(KAXIS)
      NCELL = CUT_CELL(ICC)%NCELL
      DO JCC=1,CUT_CELL(ICC)%NCELL
         CUT_CELL(ICC)%QR(JCC) = QR(I,J,K)
      ENDDO
   ENDDO
ENDIF

T_USED(14) = T_USED(14) + CURRENT_TIME() - TNOW
IF (TIME_CC_IBM) T_CC_USED(CCCOMPUTE_RADIATION_TIME_INDEX) = T_CC_USED(CCCOMPUTE_RADIATION_TIME_INDEX) + CURRENT_TIME() - TNOW
RETURN
END SUBROUTINE CCCOMPUTE_RADIATION


! -------------------------------- CC_SET_DATA ----------------------------------

SUBROUTINE CC_SET_DATA(FIRST_CALL)

USE MEMORY_FUNCTIONS, ONLY: EXCHANGE_GEOMETRY_INFO

LOGICAL, INTENT(IN) :: FIRST_CALL

! Local Variables:
INTEGER :: NM,ICALL
REAL(EB):: LX,LY,LZ,MAX_DIST
REAL(EB):: TNOW,TNOW2,TDEL,MIN_XS(1:3),MAX_XF(1:3)

INTEGER :: ICF, IG
CHARACTER(80) :: FN_CCTIME
CHARACTER(200)::TCFORM

INTEGER :: ICC,JCC,I,J,K,ICC2,JCC2,JCF,IFACE,FTYPE,IFC2,IFACE2,ICF2,JCF2
REAL(EB):: ACRT
TYPE(CC_CUTCELL_TYPE), POINTER :: CC2
TYPE(CC_CUTFACE_TYPE), POINTER :: CF2

TNOW2 = CURRENT_TIME()

SET_CUTCELLS_CALL_IF : IF(FIRST_CALL) THEN

! Plane by plane Evaluation of stesses for IBEDGES, a la OBSTS.
CC_ONLY_IBEDGES_FLAG=.FALSE.
THRES_FCT_EP = -1._EB

IF (N_GEOMETRY==0 .AND. .NOT.(PERIODIC_TEST==103 .OR. PERIODIC_TEST==11 .OR. PERIODIC_TEST==7)) THEN
   IF (MY_RANK==0) THEN
      WRITE(LU_ERR,*) ' '
      WRITE(LU_ERR,*) 'CCIBM Setup Error : &MISC CC_IBM=.TRUE., but no &GEOM namelist defined on input file.'
      WRITE(LU_ERR,*) ' '
   ENDIF
   STOP_STATUS = SETUP_STOP
   RETURN
ENDIF

! Defined relative GEOMEPS:
! Find largest domain distance to define relative epsilon:
MIN_XS(1:3) = (/ MESHES(1)%XS, MESHES(1)%YS, MESHES(1)%ZS /)
MAX_XF(1:3) = (/ MESHES(1)%XF, MESHES(1)%YF, MESHES(1)%ZF /)
DO NM=2,NMESHES
   MIN_XS(1) = MIN(0._EB,MIN_XS(1),MESHES(NM)%XS)
   MIN_XS(2) = MIN(0._EB,MIN_XS(2),MESHES(NM)%YS)
   MIN_XS(3) = MIN(0._EB,MIN_XS(3),MESHES(NM)%ZS)
   MAX_XF(1) = MAX(0._EB,MAX_XF(1),MESHES(NM)%XF)
   MAX_XF(2) = MAX(0._EB,MAX_XF(2),MESHES(NM)%YF)
   MAX_XF(3) = MAX(0._EB,MAX_XF(3),MESHES(NM)%ZF)
ENDDO
LX = MAX_XF(1) - MIN_XS(1)
LY = MAX_XF(2) - MIN_XS(2)
LZ = MAX_XF(3) - MIN_XS(3)
MAX_DIST=MAX(LX,LY,LZ)

! Now test against GEOMETRY size:
DO IG=1,N_GEOMETRY
   LX = GEOMETRY(IG)%GEOM_BOX(HIGH_IND,IAXIS) - GEOMETRY(IG)%GEOM_BOX( LOW_IND,IAXIS)
   LY = GEOMETRY(IG)%GEOM_BOX(HIGH_IND,JAXIS) - GEOMETRY(IG)%GEOM_BOX( LOW_IND,JAXIS)
   LZ = GEOMETRY(IG)%GEOM_BOX(HIGH_IND,KAXIS) - GEOMETRY(IG)%GEOM_BOX( LOW_IND,KAXIS)
   MAX_DIST=MAX(MAX_DIST,LX,LY,LZ)
ENDDO

! Set relative epsilon for cut-cell definition:
MAX_DIST= MAX(1._EB,MAX_DIST)
GEOMEPS = GEOMEPS*MAX_DIST

! Set CCVOL_LINK an epsilon higher than defined value to have all cells/faces around defined value linked.
CCVOL_LINK = CCVOL_LINK + GEOMEPS

IF (PERIODIC_TEST == 105) THEN ! Set cc-guard to zero, i.e. do not compute guard-cell cut-cells, for timings.
   NGUARD = 2
   CCGUARD= NGUARD-2
ENDIF

TNOW = CURRENT_TIME()
CALL SET_CUTCELLS_3D                    ! Defines CUT_CELL data for each mesh.
IF (STOP_STATUS==SETUP_STOP) RETURN

TDEL = CURRENT_TIME() - TNOW

IF (PERIODIC_TEST == 105) THEN ! Cut-cell definition timings test.
    IF(MY_RANK==0) WRITE(LU_ERR,*) ' '
    ICALL = 1
    IF(MY_RANK==0) WRITE(LU_ERR,*) 'CALL number ',ICALL,' to SET_CUTCELLS_3D finished. Max Time=',TDEL,' sec.'
    DO ICALL=2,N_SET_CUTCELLS_3D_CALLS
       TNOW = CURRENT_TIME()
       CALL SET_CUTCELLS_3D                    ! Defines CUT_CELL data for each mesh, average timings.
       TDEL = CURRENT_TIME() - TNOW
       IF(MY_RANK==0) WRITE(LU_ERR,*) 'CALL number ',ICALL,' to SET_CUTCELLS_3D finished. Max Time=',TDEL,' sec.'
    ENDDO
    WRITE_SET_CUTCELLS_TIMINGS = .TRUE.
ENDIF

! Write out SET_CUTCELLS_3D loop time:
IF (WRITE_SET_CUTCELLS_TIMINGS) THEN

   ! Total number of cut-cells and faces computed does not consider guard-cells:
   N_CUTCELLS_PROC     = 0
   N_INB_CUTFACES_PROC = 0
   N_REG_CUTFACES_PROC = 0
   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      CALL POINT_TO_MESH(NM)
      ! Cut-cells:
      N_CUTCELLS_PROC = N_CUTCELLS_PROC + MESHES(NM)%N_CUTCELL_MESH
      ! Cut-faces:
      DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
         SELECT CASE(CUT_FACE(ICF)%STATUS)
         CASE(CC_GASPHASE)
            N_REG_CUTFACES_PROC = N_REG_CUTFACES_PROC + CUT_FACE(ICF)%NFACE
         CASE(CC_INBOUNDARY)
            N_INB_CUTFACES_PROC = N_INB_CUTFACES_PROC + CUT_FACE(ICF)%NFACE
         END SELECT
      ENDDO
   ENDDO

   ! Write xxx_cc_cpu_0001.csv
   ! This csv file contains the following fields (14):
   ! N_CUTCELLS, N_INB_CUTFACES, N_REG_CUTFACES, SET_CUTCELLS_TIME, GET_BODINT_PLANE_TIME, GET_X2_INTERSECTIONS_TIME, &
   ! GET_X2_VERTVAR_TIME, GET_CARTEDGE_CUTEDGES_TIME, GET_BODX2X3_INTERSECTIONS_TIME, GET_CARTFACE_CUTEDGES_TIME, &
   ! GET_CARTCELL_CUTEDGES_TIME, GET_CARTFACE_CUTFACES_TIME, GET_CARTCELL_CUTFACES_TIME, GET_CARTCELL_CUTCELLS_TIME
   WRITE(FN_CCTIME,'(A,A,I3.3,A)') TRIM(CHID),'_cc_cpu_',MY_RANK,'.csv'
   OPEN(333,FILE=TRIM(FN_CCTIME),STATUS='UNKNOWN')
   WRITE(333,'(A,A,A,A)') "N_CUTCELLS, N_INB_CUTFACES, N_REG_CUTFACES, SET_CUTCELLS_TIME, GET_BODINT_PLANE_TIME, ",   &
                          "GET_X2_INTERSECTIONS_TIME, GET_X2_VERTVAR_TIME, GET_CARTEDGE_CUTEDGES_TIME, ",             &
                          "GET_BODX2X3_INTERSECTIONS_TIME, GET_CARTFACE_CUTEDGES_TIME, GET_CARTCELL_CUTEDGES_TIME, ", &
                          "GET_CARTFACE_CUTFACES_TIME, GET_CARTCELL_CUTFACES_TIME, GET_CARTCELL_CUTCELLS_TIME"
   WRITE(TCFORM,'(23A)')  "(I6,',',I6,',',I6,',',",FMT_R,",',',",FMT_R,",',',",FMT_R,",',',",FMT_R,",',',",           &
                          FMT_R,",',',",FMT_R,",',',",FMT_R,",',',",FMT_R,",',',",FMT_R,",',',",FMT_R,",',',",FMT_R,")"
   WRITE(333,TCFORM) N_CUTCELLS_PROC,N_INB_CUTFACES_PROC,N_REG_CUTFACES_PROC, &
                     T_CC_USED(SET_CUTCELLS_TIME_INDEX:GET_CARTCELL_CUTCELLS_TIME_INDEX)/ &
                     REAL(N_SET_CUTCELLS_3D_CALLS,EB)
   CLOSE(333)


   IF (MY_RANK == 0) THEN
      WRITE(LU_ERR,*) ' '
      WRITE(LU_ERR,*) 'Spheres NVERTS,NFACES',GEOMETRY(1)%N_VERTS,GEOMETRY(1)%N_FACES
      WRITE(LU_ERR,*) 'SET_CUTCELLS_3D loop time by process ',MY_RANK,' =',T_CC_USED(SET_CUTCELLS_TIME_INDEX), &
                      ' sec., cut-cells=',N_CUTCELLS_PROC,', cut-faces=',N_INB_CUTFACES_PROC,N_REG_CUTFACES_PROC
   ENDIF
ENDIF

! Redefine interpolated external wall_cells inside Geoms: We assume them SOLID_BOUNDARY
CALL BLOCK_CC_SOLID_EXTWALLCELLS(FIRST_CALL)

ELSE SET_CUTCELLS_CALL_IF

IF (GET_CUTCELLS_VERBOSE .AND. MY_RANK==0) THEN
   CALL CPU_TIME(TNOW)
ENDIF

! Redefine wall_cells inside Geoms: This is done before EDGE info as edges with WALL_CELL type NULL_BOUNDARY will be taken
! care of by GEOM edges. Note EDGE_INDEX will be reassigned the IBEDGE position in OMEGA, TAU arrays for velocity flux to
! be computed correctly.

CALL BLOCK_CC_SOLID_EXTWALLCELLS(FIRST_CALL)

! Reallocate and populate FDS edge and cell topology variables

DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   IF (.NOT.CC_ONLY_IBEDGES_FLAG) CALL GET_REGULAR_CUT_EDGES_BC(NM)
   CALL GET_SOLID_CUTCELL_EDGES_BC(NM)
ENDDO

CALL EXCHANGE_GEOMETRY_INFO

CALL GET_CRTCFCC_INT_STENCILS ! Computes interpolation stencils for face and cell centers.
IF (GET_CUTCELLS_VERBOSE .AND. MY_RANK==0) THEN
   CALL CPU_TIME(TDEL)
   WRITE(LU_ERR,'(A,F8.3,A)') ' Executed GET_CRTCFCC_INT_STENCILS. Time taken : ',TDEL-TNOW,' sec.'
ENDIF
CALL SET_CC_MATVEC_DATA              ! Defines data for discretization matrix-vectors.
IF (GET_CUTCELLS_VERBOSE .AND. MY_RANK==0) THEN
   CALL CPU_TIME(TNOW)
   WRITE(LU_ERR,'(A,F8.3,A)') ' Executing SET_CC_MATVEC_DATA. Time taken : ',TNOW-TDEL,' sec.'
ENDIF
CALL SET_CFACES_P1_RDN               ! Set inverse DXN for CFACES, uses cell linking information.
IF (GET_CUTCELLS_VERBOSE .AND. MY_RANK==0) THEN
   CALL CPU_TIME(TDEL)
   WRITE(LU_ERR,'(A,F8.3,A)') ' Executing SET_CFACES_P1_RDN. Time taken : ',TDEL-TNOW,' sec.'
ENDIF

! Give information for a particular cell:
IF (DEBUG_MATVEC_DATA) THEN
   NM = 1; I = 17; J = 24; K = 19
   CALL POINT_TO_MESH(NM)
   IF (CCVAR(I,J,K,CC_IDCC)<1) THEN
      WRITE(LU_ERR,*) 'No cut-cells in cell NM,I,J,K=',NM,I,J,K
   ELSE
      ICC = CCVAR(I,J,K,CC_IDCC); CC=>CUT_CELL(ICC)
      WRITE(LU_ERR,*) 'Cut Cell in cell NM,I,J,K : ICC,NCELL=',NM,I,J,K,':',ICC,CC%NCELL
      DO JCC=1,CC%NCELL
         ! Linking Info on cut-cell ICC,JCC
         WRITE(LU_ERR,*) 'JCC,ALPHA_CC, CC%IJK_LINK(:,JCC) : CC%LINK_LEV(JCC), UNKZ=',&
         JCC,CC%VOLUME(JCC)/(DX(I)*DY(J)*DZ(K)),CC%IJK_LINK(:,JCC),':',CC%LINK_LEV(JCC),CC%UNKZ(JCC)
         IF (CC%IJK_LINK(1,JCC)==CC_CUTCFE) THEN
            ICC2=CCVAR(CC%IJK_LINK(2,JCC),CC%IJK_LINK(3,JCC),CC%IJK_LINK(4,JCC),CC_IDCC);
            JCC2=CC%IJK_LINK(5,JCC)
            CC2 => CUT_CELL(ICC2)
            ! Linking Info on Parent if it is a cut-face:
            WRITE(LU_ERR,*) 'Parent CC2 I,J,K,JCC2 : ALPHA_CC2, CC2%IJK_LINK(:,JCC2) : CC2%LINK_LEV(JCC2) UNKZ=',&
            CC%IJK_LINK(2:5,JCC),':',CC2%VOLUME(JCC2)/(DX(I)*DY(J)*DZ(K)),CC2%IJK_LINK(:,JCC2),':',&
            CC2%LINK_LEV(JCC2),CC2%UNKZ(JCC2)
         ENDIF
         ! Linking info on cut-faces for ICC,JCC:
         DO JCF=2,CC%CCELEM(1,JCC)+1
            IFACE = CC%CCELEM(JCF,JCC)
            FTYPE = CC%FACE_LIST(1,IFACE)
            IF (FTYPE==CC_FTYPE_CFGAS) THEN
               IFC2    = CC%FACE_LIST(4,IFACE)
               IFACE2  = CC%FACE_LIST(5,IFACE)
               CF => CUT_FACE(IFC2)
               IF(CF%IJK(KAXIS+1)==IAXIS) ACRT = DY(J)*DZ(K)
               IF(CF%IJK(KAXIS+1)==JAXIS) ACRT = DX(I)*DZ(K)
               IF(CF%IJK(KAXIS+1)==KAXIS) ACRT = DX(I)*DY(J)
               WRITE(LU_ERR,*) 'CC Cut-face JFC,ICF,JCF,ALPHA_CF : CF%LINK_LEV(JCF),CF%UNKF(JCF)=',&
               JCF,IFC2,IFACE2,CF%AREA(IFACE2)/ACRT,':',CF%LINK_LEV(IFACE2),CF%UNKF(IFACE2)
               WRITE(LU_ERR,*) 'CUT-FACES with UNKF(JCF) : ',CF%UNKF(IFACE2)
               DO ICF2=1,MESHES(NM)%N_CUTFACE_MESH
                  CF2=>CUT_FACE(ICF2); IF(CF2%STATUS/=CC_GASPHASE) CYCLE
                  DO JCF2=1,CF2%NFACE
                     IF(CF2%UNKF(JCF2)==CF%UNKF(IFACE2)) THEN
                        WRITE(LU_ERR,*) 'CF with UNKF(JCF) ICF2,JCF2,I2,J2,K2,AX2,ALPHA_2,LINK_LEV2=',&
                        ICF2,JCF2,CF2%IJK(1:4),CF2%AREA(JCF2)/ACRT,':',CF2%LINK_LEV(JCF2),CF2%UNKF(JCF2)
                     ENDIF
                  ENDDO
               ENDDO
            ENDIF
         ENDDO
      ENDDO
   ENDIF
ENDIF



IF(GET_CUTCELLS_VERBOSE) CLOSE(LU_SETCC)

! Set flag that specifies cut-cell data as defined:
CC_MATVEC_DEFINED=.TRUE.

ENDIF SET_CUTCELLS_CALL_IF

T_USED(14) = T_USED(14) + CURRENT_TIME() - TNOW2

IF (TIME_CC_IBM) T_CC_USED(CC_SET_DATA_TIME_INDEX) = T_CC_USED(CC_SET_DATA_TIME_INDEX) + CURRENT_TIME() - TNOW2
RETURN

CONTAINS

! ------------------------ SET_CFACES_P1_RDN ---------------------------------

SUBROUTINE SET_CFACES_P1_RDN

! Local Variables:
INTEGER :: ICF, IFACE
INTEGER :: ICC, JCC, I, J, K
INTEGER :: IFACE_CELL, ICF_CELL, IROW
REAL(EB):: AREAI
REAL(EB), ALLOCATABLE, DIMENSION(:) :: DXN_UNKZ_LOC, AREA_UNKZ_LOC, VOL_UNKZ_LOC

! ALLOCATE local arrays
ALLOCATE(DXN_UNKZ_LOC(1:NUNKZ_LOCAL));  DXN_UNKZ_LOC(:)  = 0._EB
ALLOCATE(AREA_UNKZ_LOC(1:NUNKZ_LOCAL)); AREA_UNKZ_LOC(:) = 0._EB
ALLOCATE(VOL_UNKZ_LOC(1:NUNKZ_LOCAL));  VOL_UNKZ_LOC(:)  = 0._EB

! Main Loop:
MESH_LOOP_01 : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! Do a volume weighted average of distance to wall from linked cells, if one of them is a regular cell use 1/2 the
   ! distance of corner to corner sqrt(DX^2+DY^2+DZ^2).
   ! 1. Regular GASPHASE cells within the cc-region:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,CC_UNKZ) <= 0 ) CYCLE ! Drop if regular gas cell has not been assigned unknown number.
            IROW = CCVAR(I,J,K,CC_UNKZ) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
            VOL_UNKZ_LOC(IROW) = VOL_UNKZ_LOC(IROW) + (DX(I)*DY(J)*DZ(K))
         ENDDO
      ENDDO
   ENDDO
   ! 2. Cut-cells:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      CC => CUT_CELL(ICC); I = CC%IJK(IAXIS); J = CC%IJK(JAXIS); K = CC%IJK(KAXIS)
      IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
      DO JCC=1,CC%NCELL
         IROW = CC%UNKZ(JCC) - UNKZ_IND(NM_START)
         ! Mean INBOUNDARY cut-face distance to this cut-cell center, projected to cut-face normal:
         AREAI = 0._EB
         DO ICF_CELL=1,CC%CCELEM(1,JCC)
            IFACE_CELL = CC%CCELEM(ICF_CELL+1,JCC)
            IF (CC%FACE_LIST(1,IFACE_CELL) /= CC_FTYPE_CFINB) CYCLE
            ! Indexes of INBOUNDARY cutface on CUT_FACE:
            ICF   = CC%FACE_LIST(4,IFACE_CELL)
            IFACE = CC%FACE_LIST(5,IFACE_CELL)
            ! Area sum:
            AREAI = AREAI + CUT_FACE(ICF)%AREA(IFACE)
         ENDDO
         AREA_UNKZ_LOC(IROW) = AREA_UNKZ_LOC(IROW) + AREAI
         VOL_UNKZ_LOC(IROW) = VOL_UNKZ_LOC(IROW) + CC%VOLUME(JCC)
      ENDDO
   ENDDO

ENDDO MESH_LOOP_01

! Compute average DXN of all linked cells:
DXN_UNKZ_LOC = VOL_UNKZ_LOC / (AREA_UNKZ_LOC + TWO_EPSILON_EB)

! Finally Define B1%RDN:
MESH_LOOP_02 : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   CALL POINT_TO_MESH(NM)
   DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      CF => CUT_FACE(ICF); IF(CF%STATUS /= CC_INBOUNDARY) CYCLE
      I = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
      DO IFACE=1,CF%NFACE
         IF (CF%CELL_LIST(1,LOW_IND,IFACE) /= CC_FTYPE_CFGAS) CYCLE
         ICC = CF%CELL_LIST(2,LOW_IND,IFACE)
         JCC = CF%CELL_LIST(3,LOW_IND,IFACE)
         IROW = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
         BOUNDARY_PROP1(CFACE(CF%CFACE_INDEX(IFACE))%B1_INDEX)%RDN = 1._EB/DXN_UNKZ_LOC(IROW)
      ENDDO
   ENDDO
ENDDO MESH_LOOP_02
DEALLOCATE(DXN_UNKZ_LOC, VOL_UNKZ_LOC, AREA_UNKZ_LOC)

RETURN
END SUBROUTINE SET_CFACES_P1_RDN

END SUBROUTINE CC_SET_DATA

! ------------------------------- CC_END_STEP --------------------------------

SUBROUTINE CC_END_STEP(T,DT,DIAGNOSTICS)

REAL(EB),INTENT(IN) :: T,DT
LOGICAL, INTENT(IN) :: DIAGNOSTICS

! Local Variables:
INTEGER :: NM
REAL(EB):: TNOW
LOGICAL :: DUMLOG
REAL(EB):: TNOW2

IF (FREEZE_VELOCITY .OR. SOLID_PHASE_ONLY) RETURN

TNOW = CURRENT_TIME()
TNOW2= TNOW

! Populate Linked velocity arrays:
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   CALL POINT_TO_MESH(NM)
   CALL GET_LINKED_VELOCITIES(NM,PREDICTOR,CMP_FLG=.TRUE.)
ENDDO

! Flux match Cartesian face velocity back to cut-faces:
CALL CC_VELOCITY_CUTFACES(PREDICTOR)

IF (DEBUG_CC_SCALAR_TRANSPORT) THEN
   DUMLOG = DIAGNOSTICS
   IF (PREDICTOR) CALL CC_CHECK_DIVERGENCE(T,DT,.TRUE.)
   IF (CORRECTOR) CALL CC_CHECK_DIVERGENCE(T,DT,.FALSE.)
ELSE
   IF (CORRECTOR .AND. (DIAGNOSTICS .OR. STORE_CUTCELL_DIVERGENCE)) CALL CC_CHECK_DIVERGENCE(T,DT,.FALSE.)
ENDIF

T_USED(14) = T_USED(14) + CURRENT_TIME() - TNOW
IF (TIME_CC_IBM) T_CC_USED(CC_END_STEP_TIME_INDEX) = T_CC_USED(CC_END_STEP_TIME_INDEX) + CURRENT_TIME() - TNOW2
RETURN

END SUBROUTINE CC_END_STEP

! ----------------------------- INIT_CUTCELL_DATA -------------------------------

SUBROUTINE INIT_CUTCELL_DATA(T,DT,FIRST_CALL)

! This routine assumes INITIALIZE_MESH_VARIABLES_1(DT,NM) has already been called.

USE PHYSICAL_FUNCTIONS, ONLY: GET_SPECIFIC_GAS_CONSTANT
USE MATH_FUNCTIONS, ONLY: EVALUATE_RAMP

REAL(EB), INTENT(IN) :: T, DT
LOGICAL, INTENT(IN)  :: FIRST_CALL

! Local Variables:
INTEGER :: NM,I,J,K,N,ICC,JCC,X1AXIS,NFACE,ICF
REAL(EB) TMP_CC,RHO_CC,AREAT,VEL_CF !,Z_CC,TMP_0_CC,P_0_CC
REAL(EB), ALLOCATABLE, DIMENSION(:) :: ZZ_CC
INTEGER :: IW,IROW_LOC

REAL(EB) :: TNOW

TNOW = CURRENT_TIME()

ALLOCATE( ZZ_CC(1:N_TOTAL_SCALARS) )

! Loop Meshes:
! Get Z location of linked cells centroids, then P_0_CV for the control volumes:
ZCEN_CV(:) = 0._EB; RZ_Z = 0._EB
MESH_LOOP_0 : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
            IROW_LOC     = CCVAR(I,J,K,CC_UNKZ) - UNKZ_IND(NM_START)
            RZ_Z(IROW_LOC)= RZ_Z(IROW_LOC) + DX(I)*DY(J)*DZ(K)
            ZCEN_CV(IROW_LOC) = ZCEN_CV(IROW_LOC) + ZC(K)*DX(I)*DY(J)*DZ(K)
         ENDDO
      ENDDO
   ENDDO

   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      CC => CUT_CELL(ICC); IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
      DO JCC=1,CC%NCELL
         IROW_LOC     = CC%UNKZ(JCC) - UNKZ_IND(NM_START)
         RZ_Z(IROW_LOC)= RZ_Z(IROW_LOC) + CC%VOLUME(JCC)
         ZCEN_CV(IROW_LOC) = ZCEN_CV(IROW_LOC) + CC%XYZCEN(KAXIS,JCC)*CC%VOLUME(JCC)
      ENDDO
   ENDDO
ENDDO MESH_LOOP_0
DO IROW_LOC=1,NUNKZ_LOCAL
   ZCEN_CV(IROW_LOC) = ZCEN_CV(IROW_LOC) / RZ_Z(IROW_LOC)
ENDDO

P_0_CV(:)  = P_INF
TMP_0_CV(:)= TMPA
IF (STRATIFICATION) THEN
   DO IROW_LOC=1,NUNKZ_LOCAL
      P_0_CV(IROW_LOC)  = EVALUATE_RAMP(ZCEN_CV(IROW_LOC),I_RAMP_P0_Z)
      TMP_0_CV(IROW_LOC)= TMPA*EVALUATE_RAMP(ZCEN_CV(IROW_LOC),I_RAMP_TMP0_Z)
   ENDDO
ENDIF
DO IROW_LOC=1,NUNKZ_LOCAL
   RHO_0_CV(IROW_LOC) = P_0_CV(IROW_LOC)/(TMP_0_CV(IROW_LOC)*RSUM0)
ENDDO

MESH_LOOP_1 : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! Default initialization:
   IF(.NOT.RESTART .AND. PERIODIC_TEST/=11 .AND. PERIODIC_TEST/=7) THEN
      DO K=1,KBAR ! Linked cells get initialized to control volume values of TMP_0 and RHO_0
         DO J=1,JBAR
            DO I=1,IBAR
               IF(CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
               IROW_LOC     = CCVAR(I,J,K,CC_UNKZ) - UNKZ_IND(NM_START)
               TMP(I,J,K) = TMP_0_CV(IROW_LOC)
               RHO(I,J,K) = RHO_0_CV(IROW_LOC)
               RHOS(I,J,K)= RHO_0_CV(IROW_LOC)
            ENDDO
         ENDDO
      ENDDO
   ENDIF

   ! Cut-cells inherit underlying Cartesian cell values of rho,T,Z, etc.:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      CC => CUT_CELL(ICC);  I=CC%IJK(IAXIS); J=CC%IJK(JAXIS);  K=CC%IJK(KAXIS); IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
      TMP_CC = TMP(I,J,K)
      RHO_CC = RHO(I,J,K)
      ZZ_CC(1:N_TOTAL_SCALARS) = ZZ(I,J,K,1:N_TOTAL_SCALARS)
      DO JCC=1,CC%NCELL
         IROW_LOC     = CC%UNKZ(JCC) - UNKZ_IND(NM_START)
         CC%RHO_0(JCC)= RHO_0_CV(IROW_LOC)
         IF (.NOT.RESTART .AND. PERIODIC_TEST/=11 .AND. PERIODIC_TEST/=7) THEN
           TMP_CC = TMP_0_CV(IROW_LOC)
           RHO_CC = RHO_0_CV(IROW_LOC)
         ENDIF

         CC%TMP(JCC)  = TMP_CC
         CC%RHO(JCC)  = RHO_CC
         CC%RHOS(JCC) = RHO_CC

         CC%ZZ(1:N_TOTAL_SCALARS,JCC) = ZZ_CC(1:N_TOTAL_SCALARS)
         DO N=1,N_TRACKED_SPECIES
            CC%ZZS(N,JCC) = SPECIES_MIXTURE(N)%ZZ0
         ENDDO
         CC%MIX_TIME(JCC) = DT
         CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_CC(1:N_TRACKED_SPECIES),CC%RSUM(JCC))
         CC%D(JCC)        = 0._EB
         CC%DS(JCC)       = 0._EB
         CC%DVOL(JCC)     = 0._EB
         CC%D_SOURCE(JCC) = 0._EB
         CC%Q(JCC)        = 0._EB
         CC%QR(JCC)       = 0._EB
         CC%M_DOT_PPP(:,JCC) = 0._EB
         IF(RESTART) THEN
            CC%D(JCC)        = D(I,J,K)/CC%ALPHA_CC
            IF (ALLOCATED(MESHES(NM)%D_SOURCE)) CC%D_SOURCE(JCC) = D_SOURCE(I,J,K)/CC%ALPHA_CC
            CC%Q(JCC)        = Q(I,J,K)/CC%ALPHA_CC
            CC%QR(JCC)       = QR(I,J,K) ! Not needed for radiation.
            IF (ALLOCATED(MESHES(NM)%M_DOT_PPP)) CC%M_DOT_PPP(1:N_TRACKED_SPECIES,JCC) = &
                                                    M_DOT_PPP(I,J,K,1:N_TRACKED_SPECIES)/CC%ALPHA_CC
         ENDIF
      ENDDO
      IF (ALLOCATED(MESHES(NM)%D_SOURCE)) THEN
         D_SOURCE(I,J,K) = 0._EB
         M_DOT_PPP(I,J,K,1:N_TRACKED_SPECIES) = 0._EB
      ENDIF
   ENDDO

   ! Init guardcell cut-cells:
   DO ICC=MESHES(NM)%N_CUTCELL_MESH+1,MESHES(NM)%N_CUTCELL_MESH+MESHES(NM)%N_GCCUTCELL_MESH
      CC => CUT_CELL(ICC);  I = CC%IJK(IAXIS); J = CC%IJK(JAXIS);  K = CC%IJK(KAXIS)
      IF(I < 0 .OR. I > IBP1) CYCLE
      IF(J < 0 .OR. J > JBP1) CYCLE
      IF(K < 0 .OR. K > KBP1) CYCLE
      TMP_CC = TMP(I,J,K)
      RHO_CC = RHO(I,J,K)
      ZZ_CC(1:N_TOTAL_SCALARS) = ZZ(I,J,K,1:N_TOTAL_SCALARS)
      DO JCC=1,CC%NCELL
         CC%RHO_0(JCC)= RHO_0(K)
         CC%TMP(JCC)  = TMP_CC
         CC%RHO(JCC)  = RHO_CC
         CC%RHOS(JCC) = RHO_CC
         CC%ZZ(1:N_TOTAL_SCALARS,JCC) = ZZ_CC(1:N_TOTAL_SCALARS)
         DO N=1,N_TRACKED_SPECIES
            CC%ZZS(N,JCC) = SPECIES_MIXTURE(N)%ZZ0
         ENDDO
         CC%MIX_TIME(JCC) = DT
         CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_CC(1:N_TRACKED_SPECIES),CC%RSUM(JCC))
         CC%D(JCC)        = 0._EB
         CC%DS(JCC)       = 0._EB
         CC%DVOL(JCC)     = 0._EB
         CC%D_SOURCE(JCC) = 0._EB
         CC%Q(JCC)        = 0._EB
         CC%QR(JCC)       = 0._EB
         CC%M_DOT_PPP(:,JCC) = 0._EB
         IF(RESTART) THEN
            CC%D(JCC)        = D(I,J,K)/CC%ALPHA_CC
            IF (ALLOCATED(MESHES(NM)%D_SOURCE)) CC%D_SOURCE(JCC) = D_SOURCE(I,J,K)/CC%ALPHA_CC
            CC%Q(JCC)        = Q(I,J,K)/CC%ALPHA_CC
            CC%QR(JCC)       = QR(I,J,K) ! Not needed for radiation.
            IF (ALLOCATED(MESHES(NM)%M_DOT_PPP)) CC%M_DOT_PPP(1:N_TRACKED_SPECIES,JCC) = &
                                                    M_DOT_PPP(I,J,K,1:N_TRACKED_SPECIES)/CC%ALPHA_CC
         ENDIF
      ENDDO
      IF (ALLOCATED(MESHES(NM)%D_SOURCE)) THEN
         D_SOURCE(I,J,K) = 0._EB
         M_DOT_PPP(I,J,K,1:N_TRACKED_SPECIES) = 0._EB
      ENDIF
   ENDDO

   ! Gasphase Cut-faces inherit underlying Cartesian face values of Velocity (flux matched or not):
   PERIODIC_TEST_COND : IF (PERIODIC_TEST /= 21 .AND. PERIODIC_TEST /= 22 .AND. PERIODIC_TEST /= 24) THEN

      ! First GASPHASe cut-faces:
      CUTFACE_LOOP : DO ICF=1,MESHES(NM)%N_CUTFACE_MESH+MESHES(NM)%N_GCCUTFACE_MESH
         NFACE  = CUT_FACE(ICF)%NFACE
         IF (CUT_FACE(ICF)%STATUS /= CC_GASPHASE) CYCLE
         I      = CUT_FACE(ICF)%IJK(IAXIS); IF(I<0 .OR. I>IBP1) CYCLE
         J      = CUT_FACE(ICF)%IJK(JAXIS); IF(J<0 .OR. J>JBP1) CYCLE
         K      = CUT_FACE(ICF)%IJK(KAXIS); IF(K<0 .OR. K>KBP1) CYCLE
         X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)

         AREAT  = SUM( CUT_FACE(ICF)%AREA(1:NFACE) )

         ! Flux matched U to cut-face centroids, they all get same velocity:
         IF(RESTART) THEN
            SELECT CASE(X1AXIS)
            CASE(IAXIS); VEL_CF = (DY(J)*DZ(K))/(AREAT+TWO_EPSILON_EB) * U(I,J,K)
            CASE(JAXIS); VEL_CF = (DX(I)*DZ(K))/(AREAT+TWO_EPSILON_EB) * V(I,J,K)
            CASE(KAXIS); VEL_CF = (DX(I)*DY(J))/(AREAT+TWO_EPSILON_EB) * W(I,J,K)
            END SELECT
         ELSE
            SELECT CASE(X1AXIS)
            CASE(IAXIS); VEL_CF = U(I,J,K)
            CASE(JAXIS); VEL_CF = V(I,J,K)
            CASE(KAXIS); VEL_CF = W(I,J,K)
            END SELECT
         ENDIF

         CUT_FACE(ICF)%VEL(1:NFACE)  = VEL_CF
         CUT_FACE(ICF)%VELS(1:NFACE) = VEL_CF
         CUT_FACE(ICF)%VEL_CF        = VEL_CF
      ENDDO CUTFACE_LOOP

      ! Push cut-face velocities down to cartesian velocities:
      DO ICF=1,MESHES(NM)%N_CUTFACE_MESH+MESHES(NM)%N_GCCUTFACE_MESH
         NFACE  = CUT_FACE(ICF)%NFACE
         IF (CUT_FACE(ICF)%STATUS /= CC_GASPHASE) CYCLE
         I      = CUT_FACE(ICF)%IJK(IAXIS); IF(I<0 .OR. I>IBP1) CYCLE
         J      = CUT_FACE(ICF)%IJK(JAXIS); IF(J<0 .OR. J>JBP1) CYCLE
         K      = CUT_FACE(ICF)%IJK(KAXIS); IF(K<0 .OR. K>KBP1) CYCLE
         X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)
         VEL_CF = DOT_PRODUCT(CUT_FACE(ICF)%VEL(1:NFACE),CUT_FACE(ICF)%AREA(1:NFACE))
         SELECT CASE(X1AXIS)
         CASE(IAXIS); U(I,J,K) = VEL_CF/(DY(J)*DZ(K)); CUT_FACE(ICF)%VEL_CRT=U(I,J,K)
         CASE(JAXIS); V(I,J,K) = VEL_CF/(DX(I)*DZ(K)); CUT_FACE(ICF)%VEL_CRT=V(I,J,K)
         CASE(KAXIS); W(I,J,K) = VEL_CF/(DX(I)*DY(J)); CUT_FACE(ICF)%VEL_CRT=W(I,J,K)
         END SELECT
      ENDDO

      ! Force U velocities in CC_SOLID faces to zero
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=0,IBAR
               IF (MESHES(NM)%FCVAR(I,J,K,CC_FGSC,IAXIS) /= CC_SOLID ) CYCLE
               U(I,J,K) = 0._EB; US(I,J,K)= 0._EB
            ENDDO
         ENDDO
      ENDDO

      ! Force V velocities in CC_SOLID faces to zero
      DO K=1,KBAR
         DO J=0,JBAR
            DO I=1,IBAR
               IF (MESHES(NM)%FCVAR(I,J,K,CC_FGSC,JAXIS) /= CC_SOLID ) CYCLE
               V(I,J,K) = 0._EB; VS(I,J,K)= 0._EB
            ENDDO
         ENDDO
      ENDDO

      ! Force W velocities in CC_SOLID faces to zero
      DO K=0,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (MESHES(NM)%FCVAR(I,J,K,CC_FGSC,KAXIS) /= CC_SOLID ) CYCLE
               W(I,J,K) = 0._EB; WS(I,J,K)= 0._EB
            ENDDO
         ENDDO
      ENDDO

      ! INBOUNDARY cut-faces are initialized with 0._EB velocity, that will be changed in
      ! CFACE_PREDICT_NORMAL_VELOCITY.

   ENDIF PERIODIC_TEST_COND

   ! External mesh CFACEs initialize P1 BCs:
   DO ICF=1,N_EXTERNAL_CFACE_CELLS+N_INTWALL_CFACE_CELLS
      CFA  => CFACE(ICF)
      IW = CUT_FACE(CFA%CUT_FACE_IND1)%IWC
      CALL INIT_CFACE_CELL(NM,CFA%CUT_FACE_IND1,CFA%CUT_FACE_IND2,ICF,CFA%SURF_INDEX,INTEGER_THREE,&
                           IS_INB=.FALSE.,IW=IW)
   ENDDO

   ! Geometry boundary CFACES initialize P1 BCs:
   IF(.NOT.RESTART) THEN ! Only if not restarting, otherwise the Boundary P1 vars are read from restart file.
      DO ICF=INTERNAL_CFACE_CELLS_LB+1,INTERNAL_CFACE_CELLS_LB+N_INTERNAL_CFACE_CELLS
         CFA  => CFACE(ICF)
         CALL INIT_CFACE_CELL(NM,CFA%CUT_FACE_IND1,CFA%CUT_FACE_IND2,ICF,CFA%SURF_INDEX,INTEGER_THREE,IS_INB=.TRUE.)
      ENDDO
   ENDIF

ENDDO MESH_LOOP_1

DEALLOCATE( ZZ_CC)
IF( (.NOT.RESTART .AND. FIRST_CALL) .OR. (RESTART .AND. .NOT.FIRST_CALL) ) DEALLOCATE(FDS_AREA_GEOM)

! Populate Linked velocity arrays:
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   CALL POINT_TO_MESH(NM)
   CALL GET_LINKED_VELOCITIES(NM,APPLY_TO_ESTIMATED_VARIABLES=.FALSE.,CMP_FLG=.TRUE.)
ENDDO

! Flux match Cartesian face velocity back to cut-faces:
CALL CC_VELOCITY_CUTFACES(APPLY_TO_ESTIMATED_VARIABLES=.FALSE.)


CALL MESH_CC_EXCHANGE(1)
CALL MESH_CC_EXCHANGE(4)
CALL MESH_CC_EXCHANGE(6)

CALL CC_H_INTERP
CALL CC_RHO0W_INTERP

! Check divergence of initial velocity field:
IF(GET_CUTCELLS_VERBOSE) CALL CC_CHECK_DIVERGENCE(T,DT,.FALSE.)

T_USED(14) = T_USED(14) + CURRENT_TIME() - TNOW
IF (TIME_CC_IBM) T_CC_USED(INIT_CUTCELL_DATA_TIME_INDEX) = T_CC_USED(INIT_CUTCELL_DATA_TIME_INDEX) + CURRENT_TIME() - TNOW
RETURN
END SUBROUTINE INIT_CUTCELL_DATA


! ------------------------------- SET_EXIMADVFLX_3D ------------------------------

SUBROUTINE SET_EXIMADVFLX_3D(NM,UU,VV,WW)

INTEGER, INTENT(IN) :: NM
REAL(EB), POINTER, DIMENSION(:,:,:) :: UU,VV,WW

! Local Variables:
INTEGER :: N,I,J,K,X1AXIS,IFACE
TYPE(CC_REGFACEZ_TYPE),  POINTER, DIMENSION(:) :: REGFACE_Z=>NULL()
! Loop on scalars:
SPECIES_LOOP : DO N=1,N_TOTAL_SCALARS

   AXIS_DO : DO X1AXIS = IAXIS,KAXIS
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         REGFACE_Z => CC_REGFACE_IAXIS_Z
      CASE(JAXIS)
         REGFACE_Z => CC_REGFACE_JAXIS_Z
      CASE(KAXIS)
         REGFACE_Z => CC_REGFACE_KAXIS_Z
      END SELECT
      IFACE_DO : DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
         I  = REGFACE_Z(IFACE)%IJK(IAXIS)
         J  = REGFACE_Z(IFACE)%IJK(JAXIS)
         K  = REGFACE_Z(IFACE)%IJK(KAXIS)
         ! Load Advective flux in REG face container:
         REGFACE_Z(IFACE)%RHOZZ_U(N) = 0._EB
         SELECT CASE(X1AXIS)
         CASE(IAXIS)
            REGFACE_Z(IFACE)%RHOZZ_U(N) = FX(I,J,K,N)*UU(I,J,K)*R(I)
         CASE(JAXIS)
            REGFACE_Z(IFACE)%RHOZZ_U(N) = FY(I,J,K,N)*VV(I,J,K)
         CASE(KAXIS)
            REGFACE_Z(IFACE)%RHOZZ_U(N) = FZ(I,J,K,N)*WW(I,J,K)
         END SELECT
      ENDDO IFACE_DO
   ENDDO AXIS_DO

ENDDO SPECIES_LOOP

RETURN
END SUBROUTINE SET_EXIMADVFLX_3D

! ----------------------------- SET_EXIMRHOZZLIM_3D -----------------------------

SUBROUTINE SET_EXIMRHOZZLIM_3D(NM,N)

! Get flux limited \bar{rho Za} computed on divg.f90 in EXIM boundary faces.

INTEGER, INTENT(IN) :: NM, N

! Local Variables:
INTEGER :: I,J,K,X1AXIS
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: FX_ZZ=>NULL(),FY_ZZ=>NULL(),FZ_ZZ=>NULL()
INTEGER :: IFACE,IW
TYPE(CC_REGFACEZ_TYPE),  POINTER, DIMENSION(:) :: REGFACE_Z=>NULL()

FX_ZZ=>SWORK1
FY_ZZ=>SWORK2
FZ_ZZ=>SWORK3

AXIS_DO : DO X1AXIS = IAXIS,KAXIS
   SELECT CASE(X1AXIS)
   CASE(IAXIS)
      REGFACE_Z => CC_REGFACE_IAXIS_Z
   CASE(JAXIS)
      REGFACE_Z => CC_REGFACE_JAXIS_Z
   CASE(KAXIS)
      REGFACE_Z => CC_REGFACE_KAXIS_Z
   END SELECT
   IFACE_DO : DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
      IW = REGFACE_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE IFACE_DO
      I  = REGFACE_Z(IFACE)%IJK(IAXIS)
      J  = REGFACE_Z(IFACE)%IJK(JAXIS)
      K  = REGFACE_Z(IFACE)%IJK(KAXIS)
      ! Load Diffusive flux in EXIM boundary face container:
      REGFACE_Z(IFACE)%FN_ZZ(N) = 0._EB
      IF (REGFACE_Z(IFACE)%IWC > 0) THEN
         WC=>WALL(REGFACE_Z(IFACE)%IWC)
         B1 => BOUNDARY_PROP1(WC%B1_INDEX)
         IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY) CYCLE
         REGFACE_Z(IFACE)%FN_ZZ(N)=B1%RHO_F*B1%ZZ_F(N)
      ELSE
         SELECT CASE(X1AXIS)
         CASE(IAXIS)
            REGFACE_Z(IFACE)%FN_ZZ(N) = FX_ZZ(I,J,K,N)
         CASE(JAXIS)
            REGFACE_Z(IFACE)%FN_ZZ(N) = FY_ZZ(I,J,K,N)
         CASE(KAXIS)
            REGFACE_Z(IFACE)%FN_ZZ(N) = FZ_ZZ(I,J,K,N)
         END SELECT
      ENDIF
   ENDDO IFACE_DO
ENDDO AXIS_DO

RETURN
END SUBROUTINE SET_EXIMRHOZZLIM_3D

! ----------------------------- SET_EXIMRHOHSLIM_3D -----------------------------

SUBROUTINE SET_EXIMRHOHSLIM_3D(NM)

! Get flux limited \bar{rho hs} computed on divg.f90 in EXIM boundary faces.

USE PHYSICAL_FUNCTIONS, ONLY: GET_SENSIBLE_ENTHALPY

INTEGER, INTENT(IN) :: NM

! Local Variables:
INTEGER :: I,J,K,X1AXIS
REAL(EB), POINTER, DIMENSION(:,:,:) :: FX_H_S=>NULL(),FY_H_S=>NULL(),FZ_H_S=>NULL()
REAL(EB) :: H_S,ZZ_GET(1:N_TRACKED_SPECIES),TMP_F_GAS,VELC2
INTEGER :: IFACE,IW
TYPE(CC_REGFACEZ_TYPE),  POINTER, DIMENSION(:) :: REGFACE_Z=>NULL()

FX_H_S=>WORK2
FY_H_S=>WORK3
FZ_H_S=>WORK4

AXIS_DO : DO X1AXIS = IAXIS,KAXIS
   SELECT CASE(X1AXIS)
   CASE(IAXIS)
      REGFACE_Z => CC_REGFACE_IAXIS_Z
   CASE(JAXIS)
      REGFACE_Z => CC_REGFACE_JAXIS_Z
   CASE(KAXIS)
      REGFACE_Z => CC_REGFACE_KAXIS_Z
   END SELECT
   IFACE_DO : DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
      IW = REGFACE_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE IFACE_DO
      I  = REGFACE_Z(IFACE)%IJK(IAXIS)
      J  = REGFACE_Z(IFACE)%IJK(JAXIS)
      K  = REGFACE_Z(IFACE)%IJK(KAXIS)
      ! Load Diffusive flux in REG boundary face container:
      REGFACE_Z(IFACE)%FN_H_S = 0._EB
      IF (REGFACE_Z(IFACE)%IWC > 0) THEN
         IW = REGFACE_Z(IFACE)%IWC
         WC=>WALL(IW)
         IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY) CYCLE IFACE_DO
         B1 => BOUNDARY_PROP1(WC%B1_INDEX)
         BC => BOUNDARY_COORD(WC%BC_INDEX)
         IF (PREDICTOR) THEN
            VELC2 = B1%U_NORMAL_S
         ELSE
            VELC2 = B1%U_NORMAL
         ENDIF
         IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY .AND. VELC2>0._EB) THEN
            TMP_F_GAS = TMP(BC%IIG,BC%JJG,BC%KKG)
         ELSE
            TMP_F_GAS = B1%TMP_F
         ENDIF
         ZZ_GET(1:N_TRACKED_SPECIES) = B1%ZZ_F(1:N_TRACKED_SPECIES)
         CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP_F_GAS)
         REGFACE_Z(IFACE)%FN_H_S = B1%RHO_F*H_S ! bar{rho*hs}
      ELSE
         SELECT CASE(X1AXIS)
         CASE(IAXIS)
            REGFACE_Z(IFACE)%FN_H_S = FX_H_S(I,J,K)
         CASE(JAXIS)
            REGFACE_Z(IFACE)%FN_H_S = FY_H_S(I,J,K)
         CASE(KAXIS)
            REGFACE_Z(IFACE)%FN_H_S = FZ_H_S(I,J,K)
         END SELECT
      ENDIF
   ENDDO IFACE_DO
ENDDO AXIS_DO

RETURN
END SUBROUTINE SET_EXIMRHOHSLIM_3D

! ------------------------------ SET_EXIMDIFFLX_3D ------------------------------

SUBROUTINE SET_EXIMDIFFLX_3D(NM,RHO_D_DZDX,RHO_D_DZDY,RHO_D_DZDZ)

INTEGER, INTENT(IN) :: NM
REAL(EB), INTENT(IN), POINTER, DIMENSION(:,:,:,:) :: RHO_D_DZDX,RHO_D_DZDY,RHO_D_DZDZ

! Local Variables:
INTEGER :: N,I,J,K,X1AXIS,IFACE
TYPE(CC_REGFACEZ_TYPE),  POINTER, DIMENSION(:) :: REGFACE_Z=>NULL()

! First, set all diffusive fluxes to zero on CC_SOLID faces:
! IAXIS:
X1AXIS = IAXIS
DO K=1,MESHES(NM)%KBAR
   DO J=1,MESHES(NM)%JBAR
      DO I=0,MESHES(NM)%IBAR
         IF (MESHES(NM)%FCVAR(I,J,K,CC_FGSC,X1AXIS) /= CC_SOLID ) CYCLE
         RHO_D_DZDX(I,J,K,1:N_TOTAL_SCALARS) = 0._EB
      ENDDO
   ENDDO
ENDDO
! JAXIS:
X1AXIS = JAXIS
DO K=1,MESHES(NM)%KBAR
   DO J=0,MESHES(NM)%JBAR
      DO I=1,MESHES(NM)%IBAR
         IF (MESHES(NM)%FCVAR(I,J,K,CC_FGSC,X1AXIS) /= CC_SOLID ) CYCLE
         RHO_D_DZDY(I,J,K,1:N_TOTAL_SCALARS) = 0._EB
      ENDDO
   ENDDO
ENDDO
! KAXIS:
X1AXIS = KAXIS
DO K=0,MESHES(NM)%KBAR
   DO J=1,MESHES(NM)%JBAR
      DO I=1,MESHES(NM)%IBAR
         IF (MESHES(NM)%FCVAR(I,J,K,CC_FGSC,X1AXIS) /= CC_SOLID ) CYCLE
         RHO_D_DZDZ(I,J,K,1:N_TOTAL_SCALARS) = 0._EB
      ENDDO
   ENDDO
ENDDO

! Loop on scalars:
SPECIES_LOOP : DO N=1,N_TOTAL_SCALARS

   AXIS_DO : DO X1AXIS = IAXIS,KAXIS
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         REGFACE_Z => CC_REGFACE_IAXIS_Z
      CASE(JAXIS)
         REGFACE_Z => CC_REGFACE_JAXIS_Z
      CASE(KAXIS)
         REGFACE_Z => CC_REGFACE_KAXIS_Z
      END SELECT
      IFACE_DO : DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
         I  = REGFACE_Z(IFACE)%IJK(IAXIS)
         J  = REGFACE_Z(IFACE)%IJK(JAXIS)
         K  = REGFACE_Z(IFACE)%IJK(KAXIS)
         SELECT CASE(X1AXIS)
         CASE(IAXIS)
            REGFACE_Z(IFACE)%RHO_D_DZDN(N) = RHO_D_DZDX(I,J,K,N)
         CASE(JAXIS)
            REGFACE_Z(IFACE)%RHO_D_DZDN(N) = RHO_D_DZDY(I,J,K,N)
         CASE(KAXIS)
            REGFACE_Z(IFACE)%RHO_D_DZDN(N) = RHO_D_DZDZ(I,J,K,N)
         END SELECT
      ENDDO IFACE_DO
   ENDDO AXIS_DO

ENDDO SPECIES_LOOP

RETURN
END SUBROUTINE SET_EXIMDIFFLX_3D


! -------------------------------- FINISH_CC ---------------------------------

SUBROUTINE FINISH_CC

USE MPI_F08

! Local variables:
INTEGER :: I, TLB, TUB, LU_TCC, IERR
CHARACTER(MESSAGE_LENGTH) :: CC_CPU_FILE
REAL(EB), ALLOCATABLE, DIMENSION(:) :: T_CC_USED_MIN, T_CC_USED_MAX, T_CC_USED_MEA
CHARACTER(30) :: FRMT

IF (TIME_CC_IBM) THEN
   TLB = LBOUND(T_CC_USED,DIM=1)
   TUB = UBOUND(T_CC_USED,DIM=1)
   ALLOCATE(T_CC_USED_MIN(TLB:TUB),T_CC_USED_MAX(TLB:TUB),T_CC_USED_MEA(TLB:TUB))
   IF (N_MPI_PROCESSES > 1) THEN
      CALL MPI_ALLREDUCE(T_CC_USED(TLB) , T_CC_USED_MIN(TLB) , TUB-TLB+1, MPI_DOUBLE_PRECISION, MPI_MIN, MPI_COMM_WORLD, IERR)
      CALL MPI_ALLREDUCE(T_CC_USED(TLB) , T_CC_USED_MAX(TLB) , TUB-TLB+1, MPI_DOUBLE_PRECISION, MPI_MAX, MPI_COMM_WORLD, IERR)
      CALL MPI_ALLREDUCE(T_CC_USED(TLB) , T_CC_USED_MEA(TLB) , TUB-TLB+1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD, IERR)
      T_CC_USED_MEA = T_CC_USED_MEA / REAL(N_MPI_PROCESSES,EB)
   ELSE
      T_CC_USED_MIN(TLB:TUB) = T_CC_USED(TLB:TUB)
      T_CC_USED_MAX(TLB:TUB) = T_CC_USED(TLB:TUB)
      T_CC_USED_MEA(TLB:TUB) = T_CC_USED(TLB:TUB)
   ENDIF
   IF (MY_RANK==0) THEN
      WRITE(CC_CPU_FILE,'(A,A)') TRIM(CHID),'_cc_cpu.csv'
      LU_TCC = GET_FILE_NUMBER()
      OPEN(LU_TCC,FILE=TRIM(CC_CPU_FILE),STATUS='UNKNOWN')
      WRITE(LU_TCC,'(A,A,A)') 'CCCOMPUTE_RADIATION, CC_DENSITY, CC_VELOCITY_FLUX, CC_COMPUTE_VISCOSITY, ',&
                              'CC_INTERP_FACE_VEL, CC_DIVERGENCE_PART_1, CC_END_STEP, CC_TARGET_VELOCITY, ',&
                              'CC_NO_FLUX, CC_COMPUTE_VELOCITY_ERROR, MESH_CC_EXCHANGE (s)'
      WRITE(FRMT,'(A,I2.2,A)') '(',MESH_CC_EXCHANGE_TIME_INDEX-CCCOMPUTE_RADIATION_TIME_INDEX+1,'(",",ES10.3))'
      WRITE(LU_TCC,FRMT) (T_CC_USED_MIN(I),I=CCCOMPUTE_RADIATION_TIME_INDEX,MESH_CC_EXCHANGE_TIME_INDEX)
      WRITE(LU_TCC,FRMT) (T_CC_USED_MAX(I),I=CCCOMPUTE_RADIATION_TIME_INDEX,MESH_CC_EXCHANGE_TIME_INDEX)
      WRITE(LU_TCC,FRMT) (T_CC_USED_MEA(I),I=CCCOMPUTE_RADIATION_TIME_INDEX,MESH_CC_EXCHANGE_TIME_INDEX)
      CLOSE(LU_TCC)
   ENDIF
   DEALLOCATE(T_CC_USED_MIN,T_CC_USED_MAX,T_CC_USED_MEA)
ENDIF

! Release Requests:
DO I=1,N_REQ11  ; CALL MPI_REQUEST_FREE(REQ11(I) ,IERR) ; ENDDO
DO I=1,N_REQ12  ; CALL MPI_REQUEST_FREE(REQ12(I) ,IERR) ; ENDDO
DO I=1,N_REQ13  ; CALL MPI_REQUEST_FREE(REQ13(I) ,IERR) ; ENDDO

RETURN
END SUBROUTINE FINISH_CC


! -------------------------- CC_DIVERGENCE_PART_1 --------------------------

SUBROUTINE CC_DIVERGENCE_PART_1(T,DT,NM)

USE PHYSICAL_FUNCTIONS, ONLY: GET_SPECIFIC_HEAT,GET_SENSIBLE_ENTHALPY_Z, &
                              GET_SENSIBLE_ENTHALPY,GET_VISCOSITY,GET_MOLECULAR_WEIGHT
USE MANUFACTURED_SOLUTIONS, ONLY: UF_MMS,WF_MMS,VD2D_MMS_Z_SRC

REAL(EB), INTENT(IN) :: T,DT
INTEGER,  INTENT(IN) :: NM
! Recompute divergence terms in cut-cell region and surrounding cells.
! Use velocity divergence equivalence to define divergence on cut-cell underlying Cartesian cells.

! Local Variables:
INTEGER :: N,I,J,K,X1AXIS,ISIDE,IFACE,ICC,JCC,ICF
REAL(EB), POINTER, DIMENSION(:,:,:) :: DP,DPVOL,RHOP,RTRM,CP,R_H_G,U_DOT_DEL_RHO_Z_VOL
REAL(EB), POINTER, DIMENSION(:,:) :: PBAR_P
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: ZZP
REAL(EB) :: RDT,CCM1,CCP1,IDX,AF,TMP_G,H_S,TNOW,RHOPV(-2:1),TMPV(-1:0),X1F,PRFCT,PRFCTV, &
            CPV(-1:0),FCT,MUV(-1:0),MU_DNSV(-1:0)
REAL(EB), ALLOCATABLE, DIMENSION(:) :: ZZ_GET
REAL(EB), POINTER, DIMENSION(:,:,:) :: UU,VV,WW
TYPE(SPECIES_MIXTURE_TYPE), POINTER :: SM

REAL(EB) :: VCELL, VCCELL, DIVVOL, DUMMY, RTRMVOL, CCVOL

LOGICAL, PARAMETER :: DO_CONDUCTION_HEAT_FLUX=.TRUE.
INTEGER :: DIFFHFLX_IND, JFLX_IND

LOGICAL, PARAMETER :: SET_DIV_TO_ZERO  = .FALSE.
LOGICAL, PARAMETER :: SET_CCDIV_TO_ZERO= .FALSE.
LOGICAL, PARAMETER :: FIX_DIFF_FLUXES  = .TRUE.

REAL(EB), ALLOCATABLE, DIMENSION(:) :: DIVRG_VEC , RTRM_VEC, VOLDVRG
INTEGER :: INDZ

! Pressure sums re-integration vars:
INTEGER :: IW,IND1,IND2

! Shunn MMS test case vars:
REAL(EB) :: XHAT, ZHAT, Q_Z, TT

! Dummy on T:
DUMMY = T

! Check whether to skip this routine

IF (SOLID_PHASE_ONLY) RETURN

TNOW=CURRENT_TIME()

DIFFHFLX_IND = LOW_IND  ! -rho Da Grad(Za)
JFLX_IND     = LOW_IND

CALL POINT_TO_MESH(NM)

RDT = 1._EB/DT

SELECT CASE(PREDICTOR)
   CASE(.TRUE.)
      DP     => DS
      PBAR_P => PBAR_S
      RHOP   => RHOS
      PRFCT  = 0._EB ! Use star cut-cell quantities.
   CASE(.FALSE.)
      DP     => D
      PBAR_P => PBAR
      RHOP   => RHO
      PRFCT  = 1._EB ! Use end of step cut-cell quantities.
END SELECT


R_PBAR = 1._EB/PBAR_P
DPVOL  => DP
RTRM   => WORK1

! Set DP to zero in Cartesian cells of type: CC_SOLID, CC_CUTCFE, and CC_GASPHASE where CC_UNKZ > 0:
DO K=1,KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         IF ((CCVAR(I,J,K,CC_CGSC) == CC_GASPHASE) .AND. (CCVAR(I,J,K,CC_UNKZ) <= 0)) CYCLE
         DPVOL(I,J,K) = 0._EB
         DEL_RHO_D_DEL_Z(I,J,K,1:N_TOTAL_SCALARS) = 0._EB
      ENDDO
   ENDDO
ENDDO
DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
   CUT_CELL(ICC)%DVOL(1:CUT_CELL(ICC)%NCELL)= 0._EB
   CUT_CELL(ICC)%DEL_RHO_D_DEL_Z_VOL(1:N_TOTAL_SCALARS,1:CUT_CELL(ICC)%NCELL)=0._EB
ENDDO
IF (CORRECTOR) THEN
   IF (ALLOCATED(MESHES(NM)%D_SOURCE)) THEN
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         I     = CUT_CELL(ICC)%IJK(IAXIS)
         J     = CUT_CELL(ICC)%IJK(JAXIS)
         K     = CUT_CELL(ICC)%IJK(KAXIS)
         VCELL = DX(I)*DY(J)*DZ(K)

         ! Up to here in D_SOURCE(I,J,K), M_DOT_PPP(I,J,K,1:N_TOTAL_SCALARS) we have contributions by particles.
         ! Add these contributions in corresponding cut-cells:
         ! NOTE : Assumes the source from particles is distributed evenly over CCs of the Cartesian cell.
         VCCELL = SUM(CUT_CELL(ICC)%VOLUME(1:CUT_CELL(ICC)%NCELL))
         DO JCC=1,CUT_CELL(ICC)%NCELL
            CUT_CELL(ICC)%D_SOURCE(JCC) = CUT_CELL(ICC)%D_SOURCE(JCC) + D_SOURCE(I,J,K)
            CUT_CELL(ICC)%M_DOT_PPP(1:N_TOTAL_SCALARS,JCC) = &
            CUT_CELL(ICC)%M_DOT_PPP(1:N_TOTAL_SCALARS,JCC) + M_DOT_PPP(I,J,K,1:N_TOTAL_SCALARS)
         ENDDO
      ENDDO
   ENDIF
ENDIF

IF (SET_DIV_TO_ZERO) THEN
   DP = 0._EB ! Set to zero divg on all cells.
   RETURN
ENDIF
IF (SET_CCDIV_TO_ZERO) RETURN

! Point to corresponding ZZ array:
SELECT CASE(PREDICTOR)
   CASE(.TRUE.)
      ZZP => ZZS
   CASE(.FALSE.)
      ZZP => ZZ
END SELECT

ALLOCATE(ZZ_GET(N_TRACKED_SPECIES))

! Add species diffusion terms to divergence expression and compute diffusion term for species equations
SPECIES_GT_1_IF: IF (N_TOTAL_SCALARS>1) THEN

   ! 1. Diffusive Heat flux = - Grad dot (h_s rho D Grad Z_n):
   ! In FV form: use faces to add corresponding face integral terms, for face k
   ! (sum_a{h_{s,a} rho D_a Grad z_a) dot \hat{n}_k A_k, where \hat{n}_k is the versor outside of cell
   ! at face k.
   CALL CC_DIFFUSIVE_MASS_FLUXES(NM)

   ! Ensure RHO_D terms sum to zero over all species.  Gather error into largest mass fraction present.
   IF (FIX_DIFF_FLUXES) CALL FIX_CC_DIFF_MASS_FLUXES

   ! Zero out DEL_RHO_D_DEL_Z for impregion regular cells:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF(CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
            DEL_RHO_D_DEL_Z(I,J,K,1:N_TOTAL_SCALARS) = 0._EB
         ENDDO
      ENDDO
   ENDDO

   ! 1. Diffusive heat flux  = - hs,a (Da Grad(rho*Ya) - Da/rho Grad(rho) (rho Ya)):
   CALL CC_DIFFUSIVE_HEAT_FLUXES

ENDIF SPECIES_GT_1_IF


CONDUCTION_HEAT_IF : IF( DO_CONDUCTION_HEAT_FLUX ) THEN
   ! 2. Conduction heat flux = - k Grad(T):
   CALL CC_CONDUCTION_HEAT_FLUX
ENDIF CONDUCTION_HEAT_IF


! Add \dot{q}''' and QR to DP:
! Regular cells:
DO K=1,KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
         ! Add \dot{q}''' and QR to DP*Vii:
         DPVOL(I,J,K) = DPVOL(I,J,K) + (Q(I,J,K) + QR(I,J,K)) * DX(I)*DY(J)*DZ(K)
      ENDDO
   ENDDO
ENDDO

! HERE Cut-cells \dot{q}'''*VOL and QR*VOL:
DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
   DO JCC=1,CUT_CELL(ICC)%NCELL
      CUT_CELL(ICC)%DVOL(JCC) = CUT_CELL(ICC)%DVOL(JCC)+(CUT_CELL(ICC)%Q(JCC)+CUT_CELL(ICC)%QR(JCC))*CUT_CELL(ICC)%VOLUME(JCC)
   ENDDO
ENDDO

! 3. Enthalpy advection term = - \bar{ u dot Grad (rho h_s) }:
! R_H_G = 1/(Cp * T)
! RTRM  = 1/(rho * Cp * T)
! Point to the appropriate velocity components

IF (PREDICTOR) THEN
   UU=>U
   VV=>V
   WW=>W
   PRFCTV = 1._EB
ELSE
   UU=>US
   VV=>VS
   WW=>WS
   PRFCTV = 0._EB
ENDIF

CONST_GAMMA_IF_1: IF (.NOT.CONSTANT_SPECIFIC_HEAT_RATIO) THEN
   CALL CCENTHALPY_ADVECTION ! Compute u dot grad rho h_s in FV form and add to DP in regular + cut-cells.
ENDIF CONST_GAMMA_IF_1


! Loop through regular cells in the implicit region, as well as cut-cells and compute R_H_G, and RTRM:
CP    => WORK5
R_H_G => WORK9
RTRM  => WORK1
! Regular cells:
DO K=1,KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
         ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K,1:N_TRACKED_SPECIES)
         CALL GET_SPECIFIC_HEAT(ZZ_GET,CP(I,J,K),TMP(I,J,K))
         R_H_G(I,J,K) = 1._EB/(CP(I,J,K)*TMP(I,J,K))
         RTRM(I,J,K)  = R_H_G(I,J,K)/RHOP(I,J,K)
         DPVOL(I,J,K) = RTRM(I,J,K)*DPVOL(I,J,K)
      ENDDO
   ENDDO
ENDDO

! Cut-cells:
DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
   CC => CUT_CELL(ICC); IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
   DO JCC=1,CC%NCELL
      TMPV(0) = CC%TMP(JCC)
      ZZ_GET(1:N_TRACKED_SPECIES) = PRFCT*CC%ZZ(1:N_TRACKED_SPECIES,JCC) + (1._EB-PRFCT)*CC%ZZS(1:N_TRACKED_SPECIES,JCC)
      CALL GET_SPECIFIC_HEAT(ZZ_GET,CPV(0),TMPV(0))
      CC%R_H_G(JCC) = 1._EB/(CPV(0)*TMPV(0))
      RHOPV(0) = PRFCT *CC%RHO(JCC) + (1._EB-PRFCT)*CC%RHOS(JCC)
      CC%RTRM(JCC) = CC%R_H_G(JCC)/RHOPV(0)
      CC%DVOL(JCC) = CC%RTRM(JCC)*CC%DVOL(JCC)
   ENDDO
ENDDO


! 4. Enthalpy flux due to mass diffusion and advection:
! sum_n [\bar{W}/W_n - h_{s,n}*R_H_G] ( Grad dot (rho D_\alpha Grad Z_n) - \bar{u dot Grad (rho Z_n)})

CONST_GAMMA_IF_2: IF (.NOT.CONSTANT_SPECIFIC_HEAT_RATIO) THEN

   SPECIES_LOOP: DO N=1,N_TRACKED_SPECIES

      CALL CCSPECIES_ADVECTION ! Compute u dot grad rho Z_n

      SM  => SPECIES_MIXTURE(N)

      ! Regular cells:
      ICC = 0
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
               CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP(I,J,K),H_S)
               DPVOL(I,J,K) = DPVOL(I,J,K) + (SM%RCON/RSUM(I,J,K) - H_S*R_H_G(I,J,K))* &
                                             (DEL_RHO_D_DEL_Z(I,J,K,N) - U_DOT_DEL_RHO_Z_VOL(I,J,K))/RHOP(I,J,K)
               ! Values of DEL_RHO_D_DEL_Z(I,J,K,N) have been filled previously.
               ! RSUM was computed in the implicit region advance routine for scalars CCDENSITY.
               ICC = ICC + 1
            ENDDO
         ENDDO
      ENDDO

      ! Cut-cells:
      IF (PREDICTOR) THEN
         DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
            CC => CUT_CELL(ICC); IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
            DO JCC=1,CC%NCELL
               TMPV(0) = CC%TMP(JCC)
               CALL GET_SENSIBLE_ENTHALPY_Z(N,TMPV(0),H_S)
               CC%DVOL(JCC) = CC%DVOL(JCC) + (SM%RCON/CC%RSUM(JCC) - H_S*CC%R_H_G(JCC))/CC%RHOS(JCC) * &
                                             (CC%DEL_RHO_D_DEL_Z_VOL(N,JCC)- CC%U_DOT_DEL_RHO_Z_VOL(N,JCC))
            ENDDO
         ENDDO
      ELSE
         DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
            CC => CUT_CELL(ICC); IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
            DO JCC=1,CC%NCELL
               TMPV(0) = CC%TMP(JCC)
               CALL GET_SENSIBLE_ENTHALPY_Z(N,TMPV(0),H_S)
               CC%DVOL(JCC) = CC%DVOL(JCC) + (SM%RCON/CC%RSUM(JCC) - H_S*CC%R_H_G(JCC))/CC%RHO(JCC) * &
                                             (CC%DEL_RHO_D_DEL_Z_VOL(N,JCC)- CC%U_DOT_DEL_RHO_Z_VOL(N,JCC))
            ENDDO
         ENDDO
      ENDIF

   ENDDO SPECIES_LOOP

ENDIF CONST_GAMMA_IF_2

! Add contribution of reactions

IF (ALLOCATED(MESHES(NM)%D_SOURCE)) THEN

   ! Regular Cells on the implicit region:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
            DPVOL(I,J,K) = DPVOL(I,J,K) + D_SOURCE(I,J,K)*DX(I)*DY(J)*DZ(K)
         ENDDO
      ENDDO
   ENDDO

   ! Cut cells:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      CC => CUT_CELL(ICC); IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
      DO JCC=1,CC%NCELL
         CC%DVOL(JCC) = CC%DVOL(JCC) + CC%D_SOURCE(JCC)*CC%VOLUME(JCC)
      ENDDO
   ENDDO

ENDIF

! Atmospheric stratification term

IF (STRATIFICATION) THEN
   ! Regular Cells on the implicit region:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
            DPVOL(I,J,K) = DPVOL(I,J,K) + &
            RTRM(I,J,K)*0.5_EB*(WW(I,J,K)+WW(I,J,K-1))* &
            RHO_0_CV( CCVAR(I,J,K,CC_UNKZ)-UNKZ_IND(NM_START) )*GVEC(KAXIS)*DX(I)*DY(J)*DZ(K)
         ENDDO
      ENDDO
   ENDDO
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      CC => CUT_CELL(ICC); IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
      DO JCC=1,CC%NCELL
         ! D = D + w*rho_0*g/(rho*Cp*T)*Vii
         CC%DVOL(JCC) = CC%DVOL(JCC) + CC%RTRM(JCC)*CC%WVEL(JCC)*CC%RHO_0(JCC)*GVEC(KAXIS)*CC%VOLUME(JCC)
      ENDDO
   ENDDO
ENDIF

! Manufactured solution

MMS_IF: IF (PERIODIC_TEST==7) THEN
   IF (PREDICTOR) TT=T+DT
   IF (CORRECTOR) TT=T
   ! Regular cells on cut-cell region:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
            ! this term is similar to D_REACTION from fire
            XHAT = XC(I) - UF_MMS*TT
            ZHAT = ZC(K) - WF_MMS*TT
            DO N=1,N_TRACKED_SPECIES
               SM => SPECIES_MIXTURE(N)
               SELECT CASE(N)
                  CASE(1); Q_Z = -VD2D_MMS_Z_SRC(XHAT,ZHAT,TT)
                  CASE(2); Q_Z =  VD2D_MMS_Z_SRC(XHAT,ZHAT,TT)
               END SELECT
               CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP(I,J,K),H_S)
               DPVOL(I,J,K) = DPVOL(I,J,K) + ( SM%RCON/RSUM(I,J,K) - H_S*R_H_G(I,J,K) )*Q_Z/RHOP(I,J,K)*DX(I)*DY(J)*DZ(K)
            ENDDO
         ENDDO
      ENDDO
   ENDDO
   ! Cut-cells:
   IF (PREDICTOR) THEN
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            ! this term is similar to D_REACTION from fire
            XHAT = CUT_CELL(ICC)%XYZCEN(IAXIS,JCC) - UF_MMS*TT
            ZHAT = CUT_CELL(ICC)%XYZCEN(KAXIS,JCC) - WF_MMS*TT
            TMPV(0) = CUT_CELL(ICC)%TMP(JCC)
            DO N=1,N_TRACKED_SPECIES
               SM => SPECIES_MIXTURE(N)
               SELECT CASE(N)
                  CASE(1); Q_Z = -VD2D_MMS_Z_SRC(XHAT,ZHAT,TT)
                  CASE(2); Q_Z =  VD2D_MMS_Z_SRC(XHAT,ZHAT,TT)
               END SELECT
               CALL GET_SENSIBLE_ENTHALPY_Z(N,TMPV(0),H_S)
               CUT_CELL(ICC)%DVOL(JCC) = CUT_CELL(ICC)%DVOL(JCC) +  &
               (SM%RCON/CUT_CELL(ICC)%RSUM(JCC) - H_S*CUT_CELL(ICC)%R_H_G(JCC)) * &
               Q_Z/CUT_CELL(ICC)%RHOS(JCC)*CUT_CELL(ICC)%VOLUME(JCC)
            ENDDO
         ENDDO
      ENDDO
   ELSE ! CORRECTOR
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            ! this term is similar to D_REACTION from fire
            XHAT = CUT_CELL(ICC)%XYZCEN(IAXIS,JCC) - UF_MMS*TT
            ZHAT = CUT_CELL(ICC)%XYZCEN(KAXIS,JCC) - WF_MMS*TT
            TMPV(0) = CUT_CELL(ICC)%TMP(JCC)
            DO N=1,N_TRACKED_SPECIES
               SM => SPECIES_MIXTURE(N)
               SELECT CASE(N)
                  CASE(1); Q_Z = -VD2D_MMS_Z_SRC(XHAT,ZHAT,TT)
                  CASE(2); Q_Z =  VD2D_MMS_Z_SRC(XHAT,ZHAT,TT)
               END SELECT
               CALL GET_SENSIBLE_ENTHALPY_Z(N,TMPV(0),H_S)
               CUT_CELL(ICC)%DVOL(JCC) = CUT_CELL(ICC)%DVOL(JCC) +  &
               (SM%RCON/CUT_CELL(ICC)%RSUM(JCC) - H_S*CUT_CELL(ICC)%R_H_G(JCC)) * &
               Q_Z/CUT_CELL(ICC)%RHO(JCC)*CUT_CELL(ICC)%VOLUME(JCC)
            ENDDO
         ENDDO
      ENDDO
   ENDIF
ENDIF MMS_IF

! Assign divergence and 1/(rho*Cp*T) on Cartesian Cells:
! Average divergence on linked cells:
ALLOCATE ( DIVRG_VEC(1:NUNKZ_LOCAL) , VOLDVRG(1:NUNKZ_LOCAL), RTRM_VEC(1:NUNKZ_LOCAL) )
DIVRG_VEC(:) = 0._EB
VOLDVRG(:)   = 0._EB
RTRM_VEC(:)  = 0._EB

! Add div*vol for all cells and cut-cells on implicit region:
! Regular cells:
DO K=1,KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
         ! Unknown number:
         INDZ  = CCVAR(I,J,K,CC_UNKZ) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
         DIVRG_VEC(INDZ) =  DIVRG_VEC(INDZ) + DPVOL(I,J,K)
         RTRM_VEC(INDZ)  =  RTRM_VEC(INDZ)  + RTRM(I,J,K)*(DX(I)*DY(J)*DZ(K))
         VOLDVRG(INDZ)   =  VOLDVRG(INDZ)   + (DX(I)*DY(J)*DZ(K))
      ENDDO
   ENDDO
ENDDO

If (PREDICTOR) THEN
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      I      = CUT_CELL(ICC)%IJK(IAXIS)
      J      = CUT_CELL(ICC)%IJK(JAXIS)
      K      = CUT_CELL(ICC)%IJK(KAXIS)
      IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
      DO JCC=1,CUT_CELL(ICC)%NCELL
         INDZ = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
         DIVRG_VEC(INDZ) =  DIVRG_VEC(INDZ) + CUT_CELL(ICC)%DVOL(JCC)
         RTRM_VEC(INDZ)  =  RTRM_VEC(INDZ)  + CUT_CELL(ICC)%RTRM(JCC)*CUT_CELL(ICC)%VOLUME(JCC)
         VOLDVRG(INDZ)   =  VOLDVRG(INDZ)   + CUT_CELL(ICC)%VOLUME(JCC)
      ENDDO
   ENDDO
ELSE ! CORRECTOR
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      I      = CUT_CELL(ICC)%IJK(IAXIS)
      J      = CUT_CELL(ICC)%IJK(JAXIS)
      K      = CUT_CELL(ICC)%IJK(KAXIS)
      IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
      DO JCC=1,CUT_CELL(ICC)%NCELL
         INDZ = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
         DIVRG_VEC(INDZ) =  DIVRG_VEC(INDZ) + CUT_CELL(ICC)%DVOL(JCC)
         RTRM_VEC(INDZ)  =  RTRM_VEC(INDZ)  + CUT_CELL(ICC)%RTRM(JCC)*CUT_CELL(ICC)%VOLUME(JCC)
         VOLDVRG(INDZ)   =  VOLDVRG(INDZ)   + CUT_CELL(ICC)%VOLUME(JCC)
      ENDDO
   ENDDO
ENDIF

! Here there should be a mesh exchange (add) of div*vol for cases where cut-cells are linked to cells
! that belong to other meshes.

! Compute final divergence:
DO INDZ=UNKZ_ILC(NM)+1,UNKZ_ILC(NM)+NUNKZ_LOC(NM)
   DIVRG_VEC(INDZ)=DIVRG_VEC(INDZ)/VOLDVRG(INDZ)
   RTRM_VEC(INDZ) = RTRM_VEC(INDZ)/VOLDVRG(INDZ)
ENDDO

! Finally load final thermodynamic divergence to corresponding cells:
! Regular cells:
DO K=1,KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
         INDZ  = CCVAR(I,J,K,CC_UNKZ) - UNKZ_IND(NM_START)
         DP(I,J,K)   = DIVRG_VEC(INDZ) ! Previously divided by VOL.
         RTRM(I,J,K) = RTRM_VEC(INDZ)  ! Previously divided by VOL.
         DEL_RHO_D_DEL_Z(I,J,K,1:N_TRACKED_SPECIES) = DEL_RHO_D_DEL_Z(I,J,K,1:N_TRACKED_SPECIES)/(DX(I)*DY(J)*DZ(K))
      ENDDO
   ENDDO
ENDDO

IF (PREDICTOR) THEN
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      I      = CUT_CELL(ICC)%IJK(IAXIS)
      J      = CUT_CELL(ICC)%IJK(JAXIS)
      K      = CUT_CELL(ICC)%IJK(KAXIS)
      IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
      DIVVOL = 0._EB
      RTRMVOL= 0._EB
      CCVOL  = 0._EB
      DO JCC=1,CUT_CELL(ICC)%NCELL
         INDZ = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
         CUT_CELL(ICC)%DVOL(JCC)= DIVRG_VEC(INDZ)*CUT_CELL(ICC)%VOLUME(JCC)
         CUT_CELL(ICC)%DS(JCC)  = DIVRG_VEC(INDZ)
         CUT_CELL(ICC)%RTRM(JCC)= RTRM_VEC(INDZ)
         DIVVOL = DIVVOL + CUT_CELL(ICC)%DVOL(JCC)
         RTRMVOL= RTRMVOL+ CUT_CELL(ICC)%RTRM(JCC)*CUT_CELL(ICC)%VOLUME(JCC)
         CCVOL  = CCVOL  + CUT_CELL(ICC)%VOLUME(JCC)
      ENDDO

      ! Now get sum(un*ACFace) and add to divergence:
      DP(I,J,K)  = DIVVOL/(DX(I)*DY(J)*DZ(K)) ! Now push Divergence to underlying Cartesian cell.
      RTRM(I,J,K)= RTRMVOL/(DX(I)*DY(J)*DZ(K))
   ENDDO
ELSE ! CORRECTOR
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      I      = CUT_CELL(ICC)%IJK(IAXIS)
      J      = CUT_CELL(ICC)%IJK(JAXIS)
      K      = CUT_CELL(ICC)%IJK(KAXIS)
      IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
      DIVVOL = 0._EB
      RTRMVOL= 0._EB
      CCVOL  = 0._EB
      DO JCC=1,CUT_CELL(ICC)%NCELL
         INDZ = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
         CUT_CELL(ICC)%DVOL(JCC)= DIVRG_VEC(INDZ)*CUT_CELL(ICC)%VOLUME(JCC)
         CUT_CELL(ICC)%D(JCC)   = DIVRG_VEC(INDZ)
         CUT_CELL(ICC)%RTRM(JCC)= RTRM_VEC(INDZ)
         DIVVOL = DIVVOL + CUT_CELL(ICC)%DVOL(JCC)
         RTRMVOL= RTRMVOL+ CUT_CELL(ICC)%RTRM(JCC)*CUT_CELL(ICC)%VOLUME(JCC)
         CCVOL  = CCVOL  + CUT_CELL(ICC)%VOLUME(JCC)
      ENDDO

      ! Now get sum(un*ACFace) and add to divergence:
      DP(I,J,K) = DIVVOL/(DX(I)*DY(J)*DZ(K))
      RTRM(I,J,K)= RTRMVOL/(DX(I)*DY(J)*DZ(K))
   ENDDO
ENDIF
DEALLOCATE ( DIVRG_VEC , VOLDVRG, RTRM_VEC )
DEALLOCATE(ZZ_GET)

T_USED(14) = T_USED(14) + CURRENT_TIME() - TNOW
IF (TIME_CC_IBM) &
   T_CC_USED(CC_DIVERGENCE_PART_1_TIME_INDEX) = T_CC_USED(CC_DIVERGENCE_PART_1_TIME_INDEX) + CURRENT_TIME() - TNOW
RETURN

CONTAINS

! --------------------------- FIX_CC_DIFF_MASS_FLUXES -------------------------

SUBROUTINE FIX_CC_DIFF_MASS_FLUXES

REAL(EB) :: ZZ_FACE(1:N_TRACKED_SPECIES)

! IAXIS faces:
X1AXIS = IAXIS
DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
   IW = CC_REGFACE_IAXIS_Z(IFACE)%IWC
   ! Cycle if boundary condition other then INTERPOLATED, OPEN or PERIODIC, already done in GET_BBREGFACE_RHO_D_DZDN.
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==OPEN_BOUNDARY         .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I  = CC_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
   J  = CC_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
   K  = CC_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)

   ZZ_FACE(1:N_TRACKED_SPECIES) = 0.5_EB*(ZZP(I+1,J,K,1:N_TRACKED_SPECIES) + &
                                          ZZP(I  ,J,K,1:N_TRACKED_SPECIES))

   N=MAXLOC(ZZ_FACE(1:N_TRACKED_SPECIES),1)

   CC_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N) = &
   -(SUM(CC_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(1:N_TRACKED_SPECIES))-CC_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N))

ENDDO

! JAXIS faces:
X1AXIS = JAXIS
DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
   IW = CC_REGFACE_JAXIS_Z(IFACE)%IWC
   ! Cycle if boundary condition other then INTERPOLATED, OPEN or PERIODIC, already done in GET_BBREGFACE_RHO_D_DZDN.
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==OPEN_BOUNDARY         .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I  = CC_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
   J  = CC_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
   K  = CC_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)

   ZZ_FACE(1:N_TRACKED_SPECIES) = 0.5_EB*(ZZP(I,J+1,K,1:N_TRACKED_SPECIES) + &
                                          ZZP(I,J  ,K,1:N_TRACKED_SPECIES))

   N=MAXLOC(ZZ_FACE(1:N_TRACKED_SPECIES),1)

   CC_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N) = &
   -(SUM(CC_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(1:N_TRACKED_SPECIES))-CC_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N))

ENDDO

! KAXIS faces:
X1AXIS = KAXIS
DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
   IW = CC_REGFACE_KAXIS_Z(IFACE)%IWC
   ! Cycle if boundary condition other then INTERPOLATED, OPEN or PERIODIC, already done in GET_BBREGFACE_RHO_D_DZDN.
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==OPEN_BOUNDARY         .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I  = CC_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
   J  = CC_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
   K  = CC_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)

   ZZ_FACE(1:N_TRACKED_SPECIES) = 0.5_EB*(ZZP(I,J,K+1,1:N_TRACKED_SPECIES) + &
                                          ZZP(I,J,K  ,1:N_TRACKED_SPECIES))

   N=MAXLOC(ZZ_FACE(1:N_TRACKED_SPECIES),1)

   CC_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N) = &
   -(SUM(CC_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(1:N_TRACKED_SPECIES))-CC_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N))

ENDDO

! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
DO IFACE=1,MESHES(NM)%CC_NRCFACE_Z
   IW = MESHES(NM)%RC_FACE(IFACE)%IWC
   ! Cycle if boundary condition other then INTERPOLATED, OPEN or PERIODIC, already done in GET_BBRCFACE_RHO_D_DZDN.
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==OPEN_BOUNDARY         .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

   ZZ_FACE(1:N_TRACKED_SPECIES) = RC_FACE(IFACE)%ZZ_FACE(1:N_TRACKED_SPECIES)
   N=MAXLOC(ZZ_FACE(1:N_TRACKED_SPECIES),1)

   RC_FACE(IFACE)%RHO_D_DZDN(N) = -(SUM(RC_FACE(IFACE)%RHO_D_DZDN(1:N_TRACKED_SPECIES))- &
                                         RC_FACE(IFACE)%RHO_D_DZDN(N))

ENDDO


! GASPHASE cut-faces:
DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
   IF ( CUT_FACE(ICF)%STATUS /= CC_GASPHASE ) CYCLE
   IW = MESHES(NM)%CUT_FACE(ICF)%IWC
   ! Cycle if boundary condition other then INTERPOLATED, OPEN or PERIODIC, already done in GET_BBCUTFACE_RHO_D_DZDN.
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==OPEN_BOUNDARY         .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

   DO IFACE=1,CUT_FACE(ICF)%NFACE
      ZZ_FACE(1:N_TRACKED_SPECIES) = CUT_FACE(ICF)%ZZ_FACE(1:N_TRACKED_SPECIES,IFACE)

      N=MAXLOC(ZZ_FACE(1:N_TRACKED_SPECIES),1)
      CUT_FACE(ICF)%RHO_D_DZDN(N,IFACE) = &
      -(SUM(CUT_FACE(ICF)%RHO_D_DZDN(1:N_TRACKED_SPECIES,IFACE))-CUT_FACE(ICF)%RHO_D_DZDN(N,IFACE))

   ENDDO ! IFACE
ENDDO ! ICF

END SUBROUTINE FIX_CC_DIFF_MASS_FLUXES


! ---------------------------- CCSPECIES_ADVECTION ------------------------------

SUBROUTINE CCSPECIES_ADVECTION


! Computes FV version of flux limited \bar{u dot Grad rho Yalpha} in faces near IB
! region and adds components to thermodynamic divergence.

! Local Variables:
REAL(EB) :: RHO_Z_PV(-2:1), VELC, FN_ZZ, ZZ_GET_N
REAL(EB), PARAMETER :: SGNFCT=1._EB
INTEGER :: IOR, ICFA
TYPE(BOUNDARY_PROP1_TYPE), POINTER :: B1
TYPE(CC_REGFACEZ_TYPE),  POINTER, DIMENSION(:) :: RGF=>NULL()

U_DOT_DEL_RHO_Z_VOL=>WORK7
U_DOT_DEL_RHO_Z_VOL=0._EB

! Zero out  for species N in cut-cells:
DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
   CC => CUT_CELL(ICC); CC%U_DOT_DEL_RHO_Z_VOL(N,1:CC%NCELL) = 0._EB
ENDDO

! IAXIS faces:
X1AXIS = IAXIS; RGF => CC_REGFACE_IAXIS_Z
DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
   IW=RGF(IFACE)%IWC; I =RGF(IFACE)%IJK(IAXIS); J=RGF(IFACE)%IJK(JAXIS); K =RGF(IFACE)%IJK(KAXIS); AF = DY(J)*DZ(K)
   RG_ON_WC_IF_1 : IF((IW>0).AND. .NOT.ANY(WALL(IW)%BOUNDARY_TYPE==(/INTERPOLATED_BOUNDARY,PERIODIC_BOUNDARY/))) THEN
      WC => WALL(IW)
      B1 => BOUNDARY_PROP1(WC%B1_INDEX)
      IOR = BOUNDARY_COORD(WC%BC_INDEX)%IOR
      ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
      !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
      ISIDE = -1 + (SIGN(1,IOR)+1) / 2
      RHOPV(ISIDE)    = RHOP(I+1+ISIDE,J,K)
      RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZP(I+1+ISIDE,J,K,N)
      FN_ZZ           = B1%RHO_F*B1%ZZ_F(N)
      SELECT CASE(WC%BOUNDARY_TYPE)
         CASE DEFAULT
            VELC = UU(I,J,K)
         CASE(SOLID_BOUNDARY)
            IF (PREDICTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*B1%U_NORMAL_S
            IF (CORRECTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*B1%U_NORMAL
      END SELECT
      ! Add: -(bar{rho*zz} u dot n - (rho*zz) u dot n) to corresponding cell DP:
      U_DOT_DEL_RHO_Z_VOL(I+1+ISIDE,J,K) = U_DOT_DEL_RHO_Z_VOL(I+1+ISIDE,J,K) - &
                                           SIGN(1._EB,REAL(IOR,EB))*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
   ELSE RG_ON_WC_IF_1
      VELC=UU(I,J,K); IF(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) VELC=UVW_SAVE(IW)
      ! Get rho*zz on cells at both sides of IFACE:
      RHO_Z_PV(-1:0) = RHOP(I:I+1,J,K)*ZZP(I:I+1,J,K,N)
      ! Add: -(bar{rho*zz} u dot n - (rho*zz) u dot n) to corresponding cell DP:
      IF(RGF(IFACE)%DO_LO_IND) U_DOT_DEL_RHO_Z_VOL(I  ,J,K) = U_DOT_DEL_RHO_Z_VOL(I  ,J,K) + &
                                                         SGNFCT*(RGF(IFACE)%FN_ZZ(N)-RHO_Z_PV(-1))*VELC*AF !+ve dot
      IF(RGF(IFACE)%DO_HI_IND) U_DOT_DEL_RHO_Z_VOL(I+1,J,K) = U_DOT_DEL_RHO_Z_VOL(I+1,J,K) - &
                                                         SGNFCT*(RGF(IFACE)%FN_ZZ(N)-RHO_Z_PV( 0))*VELC*AF !-ve dot
   ENDIF RG_ON_WC_IF_1
ENDDO

! JAXIS faces:
X1AXIS = JAXIS; RGF => CC_REGFACE_JAXIS_Z
DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
   IW=RGF(IFACE)%IWC; I =RGF(IFACE)%IJK(IAXIS); J=RGF(IFACE)%IJK(JAXIS); K =RGF(IFACE)%IJK(KAXIS); AF = DX(I)*DZ(K)
   RG_ON_WC_IF_2 : IF((IW>0).AND. .NOT.ANY(WALL(IW)%BOUNDARY_TYPE==(/INTERPOLATED_BOUNDARY,PERIODIC_BOUNDARY/))) THEN
      WC => WALL(IW)
      B1 => BOUNDARY_PROP1(WC%B1_INDEX)
      BC    => BOUNDARY_COORD(WC%BC_INDEX)
      IOR = BC%IOR
      ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
      !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
      ISIDE = -1 + (SIGN(1,IOR)+1) / 2
      RHOPV(ISIDE)    = RHOP(I,J+1+ISIDE,K)
      RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZP(I,J+1+ISIDE,K,N)
      FN_ZZ           = B1%RHO_F*B1%ZZ_F(N)
      SELECT CASE(WC%BOUNDARY_TYPE)
         CASE DEFAULT
            VELC = VV(I,J,K)
         CASE(SOLID_BOUNDARY)
            IF (PREDICTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*B1%U_NORMAL_S
            IF (CORRECTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*B1%U_NORMAL
      END SELECT
      ! Add: -(bar{rho*zz} u dot n - (rho*zz) u dot n) to corresponding cell DP:
      U_DOT_DEL_RHO_Z_VOL(I,J+1+ISIDE,K) = U_DOT_DEL_RHO_Z_VOL(I,J+1+ISIDE,K) - &
                                           SIGN(1._EB,REAL(IOR,EB))*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
   ELSE RG_ON_WC_IF_2
      VELC=VV(I,J,K); IF(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) VELC=UVW_SAVE(IW)
      ! Get rho*zz on cells at both sides of IFACE:
      RHO_Z_PV(-1:0) = RHOP(I,J:J+1,K)*ZZP(I,J:J+1,K,N)
      ! Add: -(bar{rho*zz} u dot n - (rho*zz) u dot n) to corresponding cell DP:
      IF(RGF(IFACE)%DO_LO_IND) U_DOT_DEL_RHO_Z_VOL(I,J  ,K) = U_DOT_DEL_RHO_Z_VOL(I,J  ,K) + &
                                                         SGNFCT*(RGF(IFACE)%FN_ZZ(N)-RHO_Z_PV(-1))*VELC*AF !+ve dot
      IF(RGF(IFACE)%DO_HI_IND) U_DOT_DEL_RHO_Z_VOL(I,J+1,K) = U_DOT_DEL_RHO_Z_VOL(I,J+1,K) - &
                                                         SGNFCT*(RGF(IFACE)%FN_ZZ(N)-RHO_Z_PV( 0))*VELC*AF !-ve dot
   ENDIF RG_ON_WC_IF_2
ENDDO

! KAXIS faces:
X1AXIS = KAXIS; RGF => CC_REGFACE_KAXIS_Z
DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
   IW=RGF(IFACE)%IWC; I =RGF(IFACE)%IJK(IAXIS); J=RGF(IFACE)%IJK(JAXIS); K =RGF(IFACE)%IJK(KAXIS); AF = DX(I)*DY(J)
   RG_ON_WC_IF_3 : IF((IW>0).AND. .NOT.ANY(WALL(IW)%BOUNDARY_TYPE==(/INTERPOLATED_BOUNDARY,PERIODIC_BOUNDARY/))) THEN
      WC => WALL(IW)
      B1 => BOUNDARY_PROP1(WC%B1_INDEX)
      IOR = BOUNDARY_COORD(WC%BC_INDEX)%IOR
      ! This expression is such that when sign of IOR is -1 ->G use Low Side cell  -> ISIDE=-1,
      !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
      ISIDE = -1 + (SIGN(1,IOR)+1) / 2
      RHOPV(ISIDE)    = RHOP(I,J,K+1+ISIDE)
      RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZP(I,J,K+1+ISIDE,N)
      FN_ZZ           = B1%RHO_F*B1%ZZ_F(N)
      SELECT CASE(WC%BOUNDARY_TYPE)
         CASE DEFAULT
            VELC = WW(I,J,K)
         CASE(SOLID_BOUNDARY)
            IF (PREDICTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*B1%U_NORMAL_S
            IF (CORRECTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*B1%U_NORMAL
      END SELECT
      ! Add: -(bar{rho*zz} u dot n - (rho*zz) u dot n) to corresponding cell DP:
      U_DOT_DEL_RHO_Z_VOL(I,J,K+1+ISIDE) = U_DOT_DEL_RHO_Z_VOL(I,J,K+1+ISIDE) - &
                                           SIGN(1._EB,REAL(IOR,EB))*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
   ELSE RG_ON_WC_IF_3
      VELC=WW(I,J,K); IF(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) VELC=UVW_SAVE(IW)
      ! Get rho*zz on cells at both sides of IFACE:
      RHO_Z_PV(-1:0) = RHOP(I,J,K:K+1)*ZZP(I,J,K:K+1,N)
      ! Add: -(bar{rho*zz} u dot n - (rho*zz) u dot n) to corresponding cell DP:
      IF(RGF(IFACE)%DO_LO_IND) U_DOT_DEL_RHO_Z_VOL(I,J,K  ) = U_DOT_DEL_RHO_Z_VOL(I,J,K  ) + &
                                                         SGNFCT*(RGF(IFACE)%FN_ZZ(N)-RHO_Z_PV(-1))*VELC*AF !+ve dot
      IF(RGF(IFACE)%DO_HI_IND) U_DOT_DEL_RHO_Z_VOL(I,J,K+1) = U_DOT_DEL_RHO_Z_VOL(I,J,K+1) - &
                                                         SGNFCT*(RGF(IFACE)%FN_ZZ(N)-RHO_Z_PV( 0))*VELC*AF !-ve dot
   ENDIF RG_ON_WC_IF_3
ENDDO

! Regular faces connecting gasphase - cut-cells:
DO IFACE=1,MESHES(NM)%CC_NRCFACE_Z
   RCF => RC_FACE(IFACE); I =RCF%IJK(IAXIS); J =RCF%IJK(JAXIS); K =RCF%IJK(KAXIS); X1AXIS =RCF%IJK(KAXIS+1); IW =RCF%IWC
   RCF_ON_WALL_CELL_IF : IF((IW > 0)) THEN ! INTERPOLATED or PERIODIC treated through RHO_F, ZZ_F(N).
      IF(WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY) CYCLE
      WC => WALL(IW)
      B1 => BOUNDARY_PROP1(WC%B1_INDEX)
      IOR = BOUNDARY_COORD(WC%BC_INDEX)%IOR
      ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
      !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
      ISIDE = -1 + (SIGN(1,IOR)+1) / 2
      FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
      ! First (rho hs)_i,j,k:
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         AF = DY(J)*DZ(K)
         VELC = UU(I,J,K)
         RHOPV(ISIDE)      = RHOP(I+1+ISIDE,J,K)
         SELECT CASE(RCF%CELL_LIST(1,ISIDE+2))
         CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
            ZZ_GET_N = ZZP(I+1+ISIDE,J,K,N)
         CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
            ICC = RCF%CELL_LIST(2,ISIDE+2)
            JCC = RCF%CELL_LIST(3,ISIDE+2)
            RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)* CUT_CELL(ICC)%RHOS(JCC)
            ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
         END SELECT
      CASE(JAXIS)
         AF = DX(I)*DZ(K)
         VELC = VV(I,J,K)
         RHOPV(ISIDE)      = RHOP(I,J+1+ISIDE,K)
         SELECT CASE(RCF%CELL_LIST(1,ISIDE+2))
         CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
            ZZ_GET_N = ZZP(I,J+1+ISIDE,K,N)
         CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
            ICC = RCF%CELL_LIST(2,ISIDE+2)
            JCC = RCF%CELL_LIST(3,ISIDE+2)
            RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)* CUT_CELL(ICC)%RHOS(JCC)
            ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
         END SELECT
      CASE(KAXIS)
         AF = DX(I)*DY(J)
         VELC = WW(I,J,K)
         RHOPV(ISIDE)      = RHOP(I,J,K+1+ISIDE)
         SELECT CASE(RCF%CELL_LIST(1,ISIDE+2))
         CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
            ZZ_GET_N = ZZP(I,J,K+1+ISIDE,N)
         CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
            ICC = RCF%CELL_LIST(2,ISIDE+2)
            JCC = RCF%CELL_LIST(3,ISIDE+2)
            RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)* CUT_CELL(ICC)%RHOS(JCC)
            ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
         END SELECT
      END SELECT
      RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
      FN_ZZ           = B1%RHO_F*B1%ZZ_F(N)
      SELECT CASE(WC%BOUNDARY_TYPE)
         CASE DEFAULT
            ! Already filled in previous X1AXIS select case.
         CASE(SOLID_BOUNDARY)
            IF (PREDICTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*B1%U_NORMAL_S
            IF (CORRECTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*B1%U_NORMAL
         CASE(INTERPOLATED_BOUNDARY)
            VELC = UVW_SAVE(IW)
      END SELECT
      SELECT CASE(RCF%CELL_LIST(1,ISIDE+2))
      CASE(CC_FTYPE_RGGAS)
        SELECT CASE(X1AXIS)
        CASE(IAXIS)
        U_DOT_DEL_RHO_Z_VOL(I+1+ISIDE,J,K)=U_DOT_DEL_RHO_Z_VOL(I+1+ISIDE,J,K)+FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
        CASE(JAXIS)
        U_DOT_DEL_RHO_Z_VOL(I,J+1+ISIDE,K)=U_DOT_DEL_RHO_Z_VOL(I,J+1+ISIDE,K)+FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
        CASE(KAXIS)
        U_DOT_DEL_RHO_Z_VOL(I,J,K+1+ISIDE)=U_DOT_DEL_RHO_Z_VOL(I,J,K+1+ISIDE)+FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
        END SELECT
      CASE(CC_FTYPE_CFGAS) ! Cut-cell
        ICC = RCF%CELL_LIST(2,ISIDE+2)
        JCC = RCF%CELL_LIST(3,ISIDE+2)
        CUT_CELL(ICC)%U_DOT_DEL_RHO_Z_VOL(N,JCC) = CUT_CELL(ICC)%U_DOT_DEL_RHO_Z_VOL(N,JCC) + &
                                                   FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
      END SELECT

   ELSE RCF_ON_WALL_CELL_IF
      RHO_Z_PV(-2:1) = 0._EB
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            AF = DY(J)*DZ(K)
            RHOPV(-2:1)      = RHOP(I-1:I+2,J,K)
            ! First two cells surrounding face:
            DO ISIDE=-1,0
               SELECT CASE(RCF%CELL_LIST(1,ISIDE+2))
               CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
                  ZZ_GET_N = ZZP(I+1+ISIDE,J,K,N)
               CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = RCF%CELL_LIST(2,ISIDE+2)
                  JCC = RCF%CELL_LIST(3,ISIDE+2)
                  RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT) *CUT_CELL(ICC)%RHOS(JCC)
                  ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
               END SELECT
               RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
            ENDDO
            ! Lower cell:
            ISIDE=-2
            IF (CELL(CELL_INDEX(I+1+ISIDE,J,K))%SOLID .OR. CCVAR(I+1+ISIDE,J,K,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE+1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I+1+ISIDE,J,K,N)
               RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
            ENDIF
            ! Upper cell:
            ISIDE=1
            IF (CELL(CELL_INDEX(I+1+ISIDE,J,K))%SOLID .OR. CCVAR(I+1+ISIDE,J,K,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE-1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I+1+ISIDE,J,K,N)
               RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
            ENDIF
            ! Now Godunov flux limited value of rho*zz on face:
            VELC = UU(I,J,K)
            ! bar{rho*zz}:
            Z_TEMP(0:3,1,1) = RHO_Z_PV(-2:1)
            U_TEMP(1,1,1) = VELC
            CALL GET_SCALAR_FACE_VALUE(U_TEMP,Z_TEMP,F_TEMP,1,1,1,1,1,1,1,I_FLUX_LIMITER)
            FN_ZZ = F_TEMP(1,1,1)

            DO ISIDE=-1,0
               FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
               SELECT CASE(RCF%CELL_LIST(1,ISIDE+2))
               CASE(CC_FTYPE_RGGAS) ! Regular cell
                  U_DOT_DEL_RHO_Z_VOL(I+1+ISIDE,J,K) = U_DOT_DEL_RHO_Z_VOL(I+1+ISIDE,J,K) + &
                  FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC * AF ! +ve or -ve dot
               CASE(CC_FTYPE_CFGAS) ! Cut-cell
                  ICC = RCF%CELL_LIST(2,ISIDE+2)
                  IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
                  JCC = RCF%CELL_LIST(3,ISIDE+2)
                  CUT_CELL(ICC)%U_DOT_DEL_RHO_Z_VOL(N,JCC) = CUT_CELL(ICC)%U_DOT_DEL_RHO_Z_VOL(N,JCC) + &
                  FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC * AF ! +ve or -ve dot
               END SELECT
            ENDDO
         CASE(JAXIS)
            AF = DX(I)*DZ(K)
            RHOPV(-2:1)      = RHOP(I,J-1:J+2,K)
            DO ISIDE=-1,0
               SELECT CASE(RCF%CELL_LIST(1,ISIDE+2))
               CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
                  ZZ_GET_N = ZZP(I,J+1+ISIDE,K,N)
               CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = RCF%CELL_LIST(2,ISIDE+2)
                  JCC = RCF%CELL_LIST(3,ISIDE+2)
                  RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT) *CUT_CELL(ICC)%RHOS(JCC)
                  ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
               END SELECT
               RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
            ENDDO
            ! Lower cell:
            ISIDE=-2
            IF (CELL(CELL_INDEX(I,J+1+ISIDE,K))%SOLID .OR. CCVAR(I,J+1+ISIDE,K,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE+1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I,J+1+ISIDE,K,N)
               RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
            ENDIF
            ! Upper cell:
            ISIDE=1
            IF (CELL(CELL_INDEX(I,J+1+ISIDE,K))%SOLID .OR. CCVAR(I,J+1+ISIDE,K,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE-1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I,J+1+ISIDE,K,N)
               RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
            ENDIF
            ! Now Godunov flux limited value of rho*zz on face:
            VELC = VV(I,J,K)
            ! bar{rho*zz}:
            Z_TEMP(0:3,1,1) = RHO_Z_PV(-2:1)
            U_TEMP(1,1,1) = VELC
            CALL GET_SCALAR_FACE_VALUE(U_TEMP,Z_TEMP,F_TEMP,1,1,1,1,1,1,1,I_FLUX_LIMITER)
            FN_ZZ = F_TEMP(1,1,1)
            DO ISIDE=-1,0
               FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
               SELECT CASE(RCF%CELL_LIST(1,ISIDE+2))
               CASE(CC_FTYPE_RGGAS) ! Regular cell
                  U_DOT_DEL_RHO_Z_VOL(I,J+1+ISIDE,K) = U_DOT_DEL_RHO_Z_VOL(I,J+1+ISIDE,K) + &
                  FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC * AF ! +ve or -ve dot
               CASE(CC_FTYPE_CFGAS) ! Cut-cell
                  ICC = RCF%CELL_LIST(2,ISIDE+2)
                  IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
                  JCC = RCF%CELL_LIST(3,ISIDE+2)
                  CUT_CELL(ICC)%U_DOT_DEL_RHO_Z_VOL(N,JCC) = CUT_CELL(ICC)%U_DOT_DEL_RHO_Z_VOL(N,JCC) + &
                  FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC * AF ! +ve or -ve dot
               END SELECT
            ENDDO
         CASE(KAXIS)
            AF = DX(I)*DY(J)
            RHOPV(-2:1)      = RHOP(I,J,K-1:K+2)
            DO ISIDE=-1,0
               SELECT CASE(RCF%CELL_LIST(1,ISIDE+2))
               CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
                  ZZ_GET_N = ZZP(I,J,K+1+ISIDE,N)
               CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = RCF%CELL_LIST(2,ISIDE+2)
                  JCC = RCF%CELL_LIST(3,ISIDE+2)
                  RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)* CUT_CELL(ICC)%RHOS(JCC)
                  ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
               END SELECT
               RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
            ENDDO
            ! Lower cell:
            ISIDE=-2
            IF (CELL(CELL_INDEX(I,J,K+1+ISIDE))%SOLID .OR. CCVAR(I,J,K+1+ISIDE,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE+1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I,J,K+1+ISIDE,N)
               RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
            ENDIF
            ! Upper cell:
            ISIDE=1
            IF (CELL(CELL_INDEX(I,J,K+1+ISIDE))%SOLID .OR. CCVAR(I,J,K+1+ISIDE,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE-1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I,J,K+1+ISIDE,N)
               RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
            ENDIF
            ! Now Godunov flux limited value of rho*zz on face:
            VELC = WW(I,J,K)
            ! bar{rho*zz}:
            Z_TEMP(0:3,1,1) = RHO_Z_PV(-2:1)
            U_TEMP(1,1,1) = VELC
            CALL GET_SCALAR_FACE_VALUE(U_TEMP,Z_TEMP,F_TEMP,1,1,1,1,1,1,1,I_FLUX_LIMITER)
            FN_ZZ = F_TEMP(1,1,1)
            DO ISIDE=-1,0
               FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
               SELECT CASE(RCF%CELL_LIST(1,ISIDE+2))
               CASE(CC_FTYPE_RGGAS) ! Regular cell
                  U_DOT_DEL_RHO_Z_VOL(I,J,K+1+ISIDE) = U_DOT_DEL_RHO_Z_VOL(I,J,K+1+ISIDE) + &
                  FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC * AF ! +ve or -ve dot
               CASE(CC_FTYPE_CFGAS) ! Cut-cell
                  ICC = RCF%CELL_LIST(2,ISIDE+2)
                  IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
                  JCC = RCF%CELL_LIST(3,ISIDE+2)
                  CUT_CELL(ICC)%U_DOT_DEL_RHO_Z_VOL(N,JCC) = CUT_CELL(ICC)%U_DOT_DEL_RHO_Z_VOL(N,JCC) + &
                  FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC * AF ! +ve or -ve dot
               END SELECT
            ENDDO
      ENDSELECT
   ENDIF RCF_ON_WALL_CELL_IF
ENDDO

! GASPHASE cut-faces:
DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
   CF =>  CUT_FACE(ICF);  IF ( CF%STATUS /= CC_GASPHASE ) CYCLE
   IW = CF%IWC; I = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
   CF_ON_WALL_CELL_IF : IF (IW > 0) THEN
      IF(WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY) CYCLE
      WC => WALL(IW)
      B1 => BOUNDARY_PROP1(WC%B1_INDEX)
      IOR = BOUNDARY_COORD(WC%BC_INDEX)%IOR
      FN_ZZ = B1%RHO_F*B1%ZZ_F(N)
      ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
      !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
      ISIDE = -1 + (SIGN(1,IOR)+1) / 2
      FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
      DO IFACE=1,CF%NFACE
         AF   = CF%AREA(IFACE)
         IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY) THEN ! Here used the CFA corresponding U_NORMAL.
            FCT  = 1._EB
            B1 => BOUNDARY_PROP1(CFACE(CF%CFACE_INDEX(IFACE))%B1_INDEX)
            VELC =         PRFCT*B1%U_NORMAL + (1._EB-PRFCT)*B1%U_NORMAL_S
         ELSEIF(WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) THEN
            VELC = CUT_FACE(ICF)%VEL_SAVE(IFACE)
         ELSE
            ! Last known cut-face velocity.
            VELC = (1._EB-PRFCT)*CF%VEL(IFACE) + PRFCT*CF%VELS(IFACE)
         ENDIF
         ! First (rho hs)_i,j,k:
         IF (CF%CELL_LIST(1,ISIDE+2,IFACE) == CC_FTYPE_CFGAS) THEN
           ICC = CF%CELL_LIST(2,ISIDE+2,IFACE)
           JCC = CF%CELL_LIST(3,ISIDE+2,IFACE)
           RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT) *CUT_CELL(ICC)%RHOS(JCC)
           ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
           RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
           CUT_CELL(ICC)%U_DOT_DEL_RHO_Z_VOL(N,JCC) = CUT_CELL(ICC)%U_DOT_DEL_RHO_Z_VOL(N,JCC) + &
                                                      FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
         ENDIF
      ENDDO ! IFACE

   ELSE CF_ON_WALL_CELL_IF
      DO IFACE=1,CF%NFACE
         AF = CF%AREA(IFACE)
         RHOPV(-1:0)    = -1._EB
         RHO_Z_PV(-1:0) =  0._EB
         DO ISIDE=-1,0
            SELECT CASE(CF%CELL_LIST(1,ISIDE+2,IFACE))
            CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = CF%CELL_LIST(2,ISIDE+2,IFACE)
               JCC = CF%CELL_LIST(3,ISIDE+2,IFACE)
               RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT) *CUT_CELL(ICC)%RHOS(JCC)
               ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
            END SELECT
            RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
         ENDDO
         SELECT CASE(X1AXIS)
         CASE(IAXIS)
            ! Lower cell:
            ISIDE=-2
            IF (CELL(CELL_INDEX(I+1+ISIDE,J,K))%SOLID .OR. CCVAR(I+1+ISIDE,J,K,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE+1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I+1+ISIDE,J,K,N)
               RHO_Z_PV(ISIDE) = RHOP(I+1+ISIDE,J,K)*ZZ_GET_N
            ENDIF
            ! Upper cell:
            ISIDE=1
            IF (CELL(CELL_INDEX(I+1+ISIDE,J,K))%SOLID .OR. CCVAR(I+1+ISIDE,J,K,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE-1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I+1+ISIDE,J,K,N)
               RHO_Z_PV(ISIDE) = RHOP(I+1+ISIDE,J,K)*ZZ_GET_N
            ENDIF
         CASE(JAXIS)
            ! Lower cell:
            ISIDE=-2
            IF (CELL(CELL_INDEX(I,J+1+ISIDE,K))%SOLID .OR. CCVAR(I,J+1+ISIDE,K,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE+1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I,J+1+ISIDE,K,N)
               RHO_Z_PV(ISIDE) = RHOP(I,J+1+ISIDE,K)*ZZ_GET_N
            ENDIF
            ! Upper cell:
            ISIDE=1
            IF (CELL(CELL_INDEX(I,J+1+ISIDE,K))%SOLID .OR. CCVAR(I,J+1+ISIDE,K,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE-1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I,J+1+ISIDE,K,N)
               RHO_Z_PV(ISIDE) = RHOP(I,J+1+ISIDE,K)*ZZ_GET_N
            ENDIF
         CASE(KAXIS)
            ! Lower cell:
            ISIDE=-2
            IF (CELL(CELL_INDEX(I,J,K+1+ISIDE))%SOLID .OR. CCVAR(I,J,K+1+ISIDE,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE+1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I,J,K+1+ISIDE,N)
               RHO_Z_PV(ISIDE) = RHOP(I,J,K+1+ISIDE)*ZZ_GET_N
            ENDIF
            ! Upper cell:
            ISIDE=1
            IF (CELL(CELL_INDEX(I,J,K+1+ISIDE))%SOLID .OR. CCVAR(I,J,K+1+ISIDE,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE-1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I,J,K+1+ISIDE,N)
               RHO_Z_PV(ISIDE) = RHOP(I,J,K+1+ISIDE)*ZZ_GET_N
            ENDIF
         END SELECT
         VELC  = PRFCTV *CF%VEL(IFACE) + (1._EB-PRFCTV)*CF%VELS(IFACE)
         ! bar{rho*zz}:
         Z_TEMP(0:3,1,1) = RHO_Z_PV(-2:1)
         U_TEMP(1,1,1) = VELC
         CALL GET_SCALAR_FACE_VALUE(U_TEMP,Z_TEMP,F_TEMP,1,1,1,1,1,1,1,I_FLUX_LIMITER)
         FN_ZZ = F_TEMP(1,1,1)
         DO ISIDE=-1,0
            FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
            SELECT CASE(CF%CELL_LIST(1,ISIDE+2,IFACE))
            CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = CF%CELL_LIST(2,ISIDE+2,IFACE)
               IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
               JCC = CF%CELL_LIST(3,ISIDE+2,IFACE)
               CUT_CELL(ICC)%U_DOT_DEL_RHO_Z_VOL(N,JCC) = CUT_CELL(ICC)%U_DOT_DEL_RHO_Z_VOL(N,JCC) + &
               FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC * AF ! +ve or -ve dot
            END SELECT
         ENDDO
      ENDDO ! IFACE
   ENDIF CF_ON_WALL_CELL_IF
ENDDO ! ICF

! INBOUNDARY cut-faces:
! Species advection due to INBOUNDARY cut-faces (CFACE):
ISIDE=-1
CFACE_LOOP : DO ICFA=INTERNAL_CFACE_CELLS_LB+1,INTERNAL_CFACE_CELLS_LB+N_INTERNAL_CFACE_CELLS
   CFA => CFACE(ICFA)
   B1 => BOUNDARY_PROP1(CFA%B1_INDEX)
   ! Find associated cut-cell:
   IND1=CFA%CUT_FACE_IND1
   IND2=CFA%CUT_FACE_IND2
   ICC = CUT_FACE(IND1)%CELL_LIST(2,LOW_IND,IND2)
   JCC = CUT_FACE(IND1)%CELL_LIST(3,LOW_IND,IND2)
   AF  = CFA%AREA
   VELC= PRFCT*B1%U_NORMAL + (1._EB-PRFCT)*B1%U_NORMAL_S
   ! Takes place of flux limited interpolation:
   FN_ZZ        = B1%RHO_F * B1%ZZ_F(N)
   RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT) *CUT_CELL(ICC)%RHOS(JCC)
   ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
   ! Cut-cell value of rho*Z:
   RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
   ! Add to U_DOT_DEL_RHO_Z:                                        ! (\bar{rho*Z}_CFACE - (rho*Z)_CC)*VELOUT*AF
   CUT_CELL(ICC)%U_DOT_DEL_RHO_Z_VOL(N,JCC)=CUT_CELL(ICC)%U_DOT_DEL_RHO_Z_VOL(N,JCC) + (FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
ENDDO CFACE_LOOP

RETURN
END SUBROUTINE CCSPECIES_ADVECTION


! ---------------------------- CCENTHALPY_ADVECTION -----------------------------

SUBROUTINE CCENTHALPY_ADVECTION


! Computes FV version of flux limited \bar{ u dot Grad rho hs} in faces of near IB
! region and adds components to thermodynamic divergence.


! Local Variables:
REAL(EB) :: RHO_H_S_PV(-2:1), VELC, VELC2, FN_H_S, TMP_F_GAS
INTEGER  :: IOR, ICFA
TYPE(BOUNDARY_PROP1_TYPE), POINTER :: B1
TYPE(CC_REGFACEZ_TYPE),  POINTER, DIMENSION(:) :: REGFACE_Z=>NULL()
LOGICAL :: DO_LO, DO_HI

! IAXIS faces:
X1AXIS = IAXIS
REGFACE_Z => CC_REGFACE_IAXIS_Z
DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
   IW = REGFACE_Z(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I    = REGFACE_Z(IFACE)%IJK(IAXIS)
   J    = REGFACE_Z(IFACE)%IJK(JAXIS)
   K    = REGFACE_Z(IFACE)%IJK(KAXIS)
   DO_LO= REGFACE_Z(IFACE)%DO_LO_IND
   DO_HI= REGFACE_Z(IFACE)%DO_HI_IND
   RHOPV(-1:0)      = RHOP(I:I+1,J,K)
   TMPV(-1:0)       =  TMP(I:I+1,J,K)
   RHO_H_S_PV(-1:0) = 0._EB
   ! Get rho*hs on cells at both sides of IFACE:
   DO ISIDE=-1,0
      ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I+1+ISIDE,J,K,1:N_TRACKED_SPECIES)
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
      RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
   ENDDO
   ! Add: -(bar{rho*hs} u dot n - (rho*hs) u dot n) to corresponding cell DP:
   AF  = DY(J)*DZ(K)
   VELC=UU(I,J,K); IF(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) VELC=UVW_SAVE(IW)
   IF(DO_LO) DPVOL(I  ,J,K) = DPVOL(I  ,J,K) + (-1._EB)*(REGFACE_Z(IFACE)%FN_H_S-RHO_H_S_PV(-1))*VELC*AF ! +ve dot
   IF(DO_HI) DPVOL(I+1,J,K) = DPVOL(I+1,J,K) - (-1._EB)*(REGFACE_Z(IFACE)%FN_H_S-RHO_H_S_PV( 0))*VELC*AF ! -ve dot
ENDDO

! JAXIS faces:
X1AXIS = JAXIS
REGFACE_Z => CC_REGFACE_JAXIS_Z
DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
   IW = REGFACE_Z(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I    = REGFACE_Z(IFACE)%IJK(IAXIS)
   J    = REGFACE_Z(IFACE)%IJK(JAXIS)
   K    = REGFACE_Z(IFACE)%IJK(KAXIS)
   DO_LO= REGFACE_Z(IFACE)%DO_LO_IND
   DO_HI= REGFACE_Z(IFACE)%DO_HI_IND
   RHOPV(-1:0)      = RHOP(I,J:J+1,K)
   TMPV(-1:0)       =  TMP(I,J:J+1,K)
   RHO_H_S_PV(-1:0) = 0._EB
   ! Get rho*hs on cells at both sides of IFACE:
   DO ISIDE=-1,0
      ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J+1+ISIDE,K,1:N_TRACKED_SPECIES)
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
      RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
   ENDDO
   ! Add: -(bar{rho*hs} u dot n - (rho*hs) u dot n) to corresponding cell DP:
   AF = DX(I)*DZ(K)
   VELC=VV(I,J,K); IF(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) VELC=UVW_SAVE(IW)
   IF(DO_LO) DPVOL(I,J  ,K) = DPVOL(I,J  ,K) + (-1._EB)*(REGFACE_Z(IFACE)%FN_H_S-RHO_H_S_PV(-1))*VELC*AF ! +ve dot
   IF(DO_HI) DPVOL(I,J+1,K) = DPVOL(I,J+1,K) - (-1._EB)*(REGFACE_Z(IFACE)%FN_H_S-RHO_H_S_PV( 0))*VELC*AF ! -ve dot
ENDDO

! KAXIS faces:
X1AXIS = KAXIS
REGFACE_Z => CC_REGFACE_KAXIS_Z
DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
   IW = REGFACE_Z(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I    = REGFACE_Z(IFACE)%IJK(IAXIS)
   J    = REGFACE_Z(IFACE)%IJK(JAXIS)
   K    = REGFACE_Z(IFACE)%IJK(KAXIS)
   DO_LO= REGFACE_Z(IFACE)%DO_LO_IND
   DO_HI= REGFACE_Z(IFACE)%DO_HI_IND
   RHOPV(-1:0)      = RHOP(I,J,K:K+1)
   TMPV(-1:0)       =  TMP(I,J,K:K+1)
   RHO_H_S_PV(-1:0) = 0._EB
   ! Get rho*hs on cells at both sides of IFACE:
   DO ISIDE=-1,0
      ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K+1+ISIDE,1:N_TRACKED_SPECIES)
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
      RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
   ENDDO
   ! Add: -(bar{rho*hs} u dot n - (rho*hs) u dot n) to corresponding cell DP:
   AF = DX(I)*DY(J)
   VELC=WW(I,J,K); IF(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) VELC=UVW_SAVE(IW)
   IF(DO_LO) DPVOL(I,J,K  ) = DPVOL(I,J,K  ) + (-1._EB)*(REGFACE_Z(IFACE)%FN_H_S-RHO_H_S_PV(-1))*VELC*AF ! +ve dot
   IF(DO_HI) DPVOL(I,J,K+1) = DPVOL(I,J,K+1) - (-1._EB)*(REGFACE_Z(IFACE)%FN_H_S-RHO_H_S_PV( 0))*VELC*AF ! -ve dot
ENDDO

! Regular faces connecting gasphase - cut-cells:
DO IFACE=1,MESHES(NM)%CC_NRCFACE_Z
   IW = RC_FACE(IFACE)%IWC
   IF( IW > 0 ) CYCLE
   I      = RC_FACE(IFACE)%IJK(IAXIS)
   J      = RC_FACE(IFACE)%IJK(JAXIS)
   K      = RC_FACE(IFACE)%IJK(KAXIS)
   X1AXIS = RC_FACE(IFACE)%IJK(KAXIS+1)
   RHO_H_S_PV(-2:1) = 0._EB
   SELECT CASE(X1AXIS)
      CASE(IAXIS)
         AF = DY(J)*DZ(K)
         RHOPV(-1:0)      = RHOP(I:I+1,J,K)
         TMPV(-1:0)       =  TMP(I:I+1,J,K)
         DO ISIDE=-1,0
            ZZ_GET = 0._EB
            SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
               ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I+1+ISIDE,J,K,1:N_TRACKED_SPECIES)
            CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
               JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
               TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
               RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
               ZZ_GET(1:N_TRACKED_SPECIES) =  PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                                       (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
            END SELECT
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
            RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
         ENDDO
         ! Lower cell:
         ISIDE=-2
         IF (CELL(CELL_INDEX(I+1+ISIDE,J,K))%SOLID .OR. CCVAR(I+1+ISIDE,J,K,CC_CGSC)==CC_SOLID) THEN
            RHO_H_S_PV(ISIDE) = RHO_H_S_PV(ISIDE+1) ! Use center cell.
         ELSE
            ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I+1+ISIDE,J,K,1:N_TRACKED_SPECIES)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP(I+1+ISIDE,J,K))
            RHO_H_S_PV(ISIDE) = RHOP(I+1+ISIDE,J,K)*H_S
         ENDIF
         ! Upper cell:
         ISIDE=1
         IF (CELL(CELL_INDEX(I+1+ISIDE,J,K))%SOLID .OR. CCVAR(I+1+ISIDE,J,K,CC_CGSC)==CC_SOLID) THEN
            RHO_H_S_PV(ISIDE) = RHO_H_S_PV(ISIDE-1) ! Use center cell.
         ELSE
            ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I+1+ISIDE,J,K,1:N_TRACKED_SPECIES)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP(I+1+ISIDE,J,K))
            RHO_H_S_PV(ISIDE) = RHOP(I+1+ISIDE,J,K)*H_S
         ENDIF
         ! Now Godunov flux limited value of rho*hs on face:
         VELC = UU(I,J,K)
         Z_TEMP(0:3,1,1) = RHO_H_S_PV(-2:1)
         U_TEMP(1,1,1) = VELC
         CALL GET_SCALAR_FACE_VALUE(U_TEMP,Z_TEMP,F_TEMP,1,1,1,1,1,1,1,I_FLUX_LIMITER)
         FN_H_S = F_TEMP(1,1,1)
         ! Add contribution to DP:
         DO ISIDE=-1,0
            FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
            SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(CC_FTYPE_RGGAS) ! Regular cell
               DPVOL(I+1+ISIDE,J,K)=DPVOL(I+1+ISIDE,J,K)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF !+ve/-ve dot
            CASE(CC_FTYPE_CFGAS) ! Cut-cell
               ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
               IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
               JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
               CUT_CELL(ICC)%DVOL(JCC)=CUT_CELL(ICC)%DVOL(JCC)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
            END SELECT
         ENDDO

      CASE(JAXIS)
         AF = DX(I)*DZ(K)
         RHOPV(-1:0)      = RHOP(I,J:J+1,K)
         TMPV(-1:0)       =  TMP(I,J:J+1,K)
         DO ISIDE=-1,0
            ZZ_GET = 0._EB
            SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
               ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J+1+ISIDE,K,1:N_TRACKED_SPECIES)
            CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
               JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
               TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
               RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
               ZZ_GET(1:N_TRACKED_SPECIES) =  PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                                       (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
            END SELECT
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
            RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
         ENDDO
         ! Lower cell:
         ISIDE=-2
         IF (CELL(CELL_INDEX(I,J+1+ISIDE,K))%SOLID .OR. CCVAR(I,J+1+ISIDE,K,CC_CGSC)==CC_SOLID) THEN
            RHO_H_S_PV(ISIDE) = RHO_H_S_PV(ISIDE+1) ! Use center cell.
         ELSE
            ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J+1+ISIDE,K,1:N_TRACKED_SPECIES)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP(I,J+1+ISIDE,K))
            RHO_H_S_PV(ISIDE) = RHOP(I,J+1+ISIDE,K)*H_S
         ENDIF
         ! Upper cell:
         ISIDE=1
         IF (CELL(CELL_INDEX(I,J+1+ISIDE,K))%SOLID .OR. CCVAR(I,J+1+ISIDE,K,CC_CGSC)==CC_SOLID) THEN
            RHO_H_S_PV(ISIDE) = RHO_H_S_PV(ISIDE-1) ! Use center cell.
         ELSE
            ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J+1+ISIDE,K,1:N_TRACKED_SPECIES)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP(I,J+1+ISIDE,K))
            RHO_H_S_PV(ISIDE) = RHOP(I,J+1+ISIDE,K)*H_S
         ENDIF
         ! Now Godunov flux limited value of rho*hs on face:
         VELC = VV(I,J,K)
         Z_TEMP(0:3,1,1) = RHO_H_S_PV(-2:1)
         U_TEMP(1,1,1) = VELC
         CALL GET_SCALAR_FACE_VALUE(U_TEMP,Z_TEMP,F_TEMP,1,1,1,1,1,1,1,I_FLUX_LIMITER)
         FN_H_S = F_TEMP(1,1,1)
         ! Add contribution to DP:
         DO ISIDE=-1,0
            FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
            SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(CC_FTYPE_RGGAS) ! Regular cell
               DPVOL(I,J+1+ISIDE,K)=DPVOL(I,J+1+ISIDE,K)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF !+ve/-ve dot
            CASE(CC_FTYPE_CFGAS) ! Cut-cell
               ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
               IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
               JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
               CUT_CELL(ICC)%DVOL(JCC)=CUT_CELL(ICC)%DVOL(JCC)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
            END SELECT
         ENDDO

      CASE(KAXIS)
         AF = DX(I)*DY(J)
         RHOPV(-1:0)      = RHOP(I,J,K:K+1)
         TMPV(-1:0)       =  TMP(I,J,K:K+1)
         DO ISIDE=-1,0
            ZZ_GET = 0._EB
            SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
               ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K+1+ISIDE,1:N_TRACKED_SPECIES)
            CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
               JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
               TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
               RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
               ZZ_GET(1:N_TRACKED_SPECIES) =  PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                                       (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
            END SELECT
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
            RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
         ENDDO
         ! Lower cell:
         ISIDE=-2
         IF (CELL(CELL_INDEX(I,J,K+1+ISIDE))%SOLID .OR. CCVAR(I,J,K+1+ISIDE,CC_CGSC)==CC_SOLID) THEN
            RHO_H_S_PV(ISIDE) = RHO_H_S_PV(ISIDE+1) ! Use center cell.
         ELSE
            ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K+1+ISIDE,1:N_TRACKED_SPECIES)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP(I,J,K+1+ISIDE))
            RHO_H_S_PV(ISIDE) = RHOP(I,J,K+1+ISIDE)*H_S
         ENDIF
         ! Upper cell:
         ISIDE=1
         IF (CELL(CELL_INDEX(I,J,K+1+ISIDE))%SOLID .OR. CCVAR(I,J,K+1+ISIDE,CC_CGSC)==CC_SOLID) THEN
            RHO_H_S_PV(ISIDE) = RHO_H_S_PV(ISIDE-1) ! Use center cell.
         ELSE
            ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K+1+ISIDE,1:N_TRACKED_SPECIES)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP(I,J,K+1+ISIDE))
            RHO_H_S_PV(ISIDE) = RHOP(I,J,K+1+ISIDE)*H_S
         ENDIF
         ! Now Godunov flux limited value of rho*hs on face:
         VELC = WW(I,J,K)
         Z_TEMP(0:3,1,1) = RHO_H_S_PV(-2:1)
         U_TEMP(1,1,1) = VELC
         CALL GET_SCALAR_FACE_VALUE(U_TEMP,Z_TEMP,F_TEMP,1,1,1,1,1,1,1,I_FLUX_LIMITER)
         FN_H_S = F_TEMP(1,1,1)
         ! Add contribution to DP:
         ! Low side cell:
         DO ISIDE=-1,0
            FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
            SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(CC_FTYPE_RGGAS) ! Regular cell
               DPVOL(I,J,K+1+ISIDE)=DPVOL(I,J,K+1+ISIDE)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF !+ve/-ve dot
            CASE(CC_FTYPE_CFGAS) ! Cut-cell
               ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
               IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
               JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
               CUT_CELL(ICC)%DVOL(JCC)=CUT_CELL(ICC)%DVOL(JCC)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
            END SELECT
         ENDDO

   ENDSELECT

ENDDO

! GASPHASE cut-faces:
DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
   IF ( CUT_FACE(ICF)%STATUS /= CC_GASPHASE ) CYCLE
   IW = CUT_FACE(ICF)%IWC
   IF(IW > 0) CYCLE
   I = CUT_FACE(ICF)%IJK(IAXIS)
   J = CUT_FACE(ICF)%IJK(JAXIS)
   K = CUT_FACE(ICF)%IJK(KAXIS)
   X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)
   DO IFACE=1,CUT_FACE(ICF)%NFACE
      AF = CUT_FACE(ICF)%AREA(IFACE)
      RHOPV(-1:0)      = -1._EB
      TMPV(-1:0)       = -1._EB
      RHO_H_S_PV(-2:1) =  0._EB
      DO ISIDE=-1,0
         ZZ_GET = 0._EB
         SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
         CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
            ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
            JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
            TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
            RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
            ZZ_GET(1:N_TRACKED_SPECIES) =  PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                                    (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
         END SELECT
         CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
         RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
      ENDDO
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         ! Lower cell:
         ISIDE=-2
         IF (CELL(CELL_INDEX(I+1+ISIDE,J,K))%SOLID .OR. CCVAR(I+1+ISIDE,J,K,CC_CGSC)==CC_SOLID) THEN
            RHO_H_S_PV(ISIDE) = RHO_H_S_PV(ISIDE+1) ! Use center cell.
         ELSE
            ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I+1+ISIDE,J,K,1:N_TRACKED_SPECIES)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP(I+1+ISIDE,J,K))
            RHO_H_S_PV(ISIDE) = RHOP(I+1+ISIDE,J,K)*H_S
         ENDIF
         ! Upper cell:
         ISIDE=1
         IF (CELL(CELL_INDEX(I+1+ISIDE,J,K))%SOLID .OR. CCVAR(I+1+ISIDE,J,K,CC_CGSC)==CC_SOLID) THEN
            RHO_H_S_PV(ISIDE) = RHO_H_S_PV(ISIDE-1) ! Use center cell.
         ELSE
            ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I+1+ISIDE,J,K,1:N_TRACKED_SPECIES)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP(I+1+ISIDE,J,K))
            RHO_H_S_PV(ISIDE) = RHOP(I+1+ISIDE,J,K)*H_S
         ENDIF
      CASE(JAXIS)
         ! Lower cell:
         ISIDE=-2
         IF (CELL(CELL_INDEX(I,J+1+ISIDE,K))%SOLID .OR. CCVAR(I,J+1+ISIDE,K,CC_CGSC)==CC_SOLID) THEN
            RHO_H_S_PV(ISIDE) = RHO_H_S_PV(ISIDE+1) ! Use center cell.
         ELSE
            ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J+1+ISIDE,K,1:N_TRACKED_SPECIES)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP(I,J+1+ISIDE,K))
            RHO_H_S_PV(ISIDE) = RHOP(I,J+1+ISIDE,K)*H_S
         ENDIF
         ! Upper cell:
         ISIDE=1
         IF (CELL(CELL_INDEX(I,J+1+ISIDE,K))%SOLID .OR. CCVAR(I,J+1+ISIDE,K,CC_CGSC)==CC_SOLID) THEN
            RHO_H_S_PV(ISIDE) = RHO_H_S_PV(ISIDE-1) ! Use center cell.
         ELSE
            ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J+1+ISIDE,K,1:N_TRACKED_SPECIES)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP(I,J+1+ISIDE,K))
            RHO_H_S_PV(ISIDE) = RHOP(I,J+1+ISIDE,K)*H_S
         ENDIF
      CASE(KAXIS)
         ! Lower cell:
         ISIDE=-2
         IF (CELL(CELL_INDEX(I,J,K+1+ISIDE))%SOLID .OR. CCVAR(I,J,K+1+ISIDE,CC_CGSC)==CC_SOLID) THEN
            RHO_H_S_PV(ISIDE) = RHO_H_S_PV(ISIDE+1) ! Use center cell.
         ELSE
            ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K+1+ISIDE,1:N_TRACKED_SPECIES)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP(I,J,K+1+ISIDE))
            RHO_H_S_PV(ISIDE) = RHOP(I,J,K+1+ISIDE)*H_S
         ENDIF
         ! Upper cell:
         ISIDE=1
         IF (CELL(CELL_INDEX(I,J,K+1+ISIDE))%SOLID .OR. CCVAR(I,J,K+1+ISIDE,CC_CGSC)==CC_SOLID) THEN
            RHO_H_S_PV(ISIDE) = RHO_H_S_PV(ISIDE-1) ! Use center cell.
         ELSE
            ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K+1+ISIDE,1:N_TRACKED_SPECIES)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP(I,J,K+1+ISIDE))
            RHO_H_S_PV(ISIDE) = RHOP(I,J,K+1+ISIDE)*H_S
         ENDIF
      END SELECT
      VELC    = PRFCTV *CUT_FACE(ICF)%VEL(IFACE) + (1._EB-PRFCTV)*CUT_FACE(ICF)%VELS(IFACE)
      Z_TEMP(0:3,1,1) = RHO_H_S_PV(-2:1)
      U_TEMP(1,1,1) = VELC
      CALL GET_SCALAR_FACE_VALUE(U_TEMP,Z_TEMP,F_TEMP,1,1,1,1,1,1,1,I_FLUX_LIMITER)
      FN_H_S = F_TEMP(1,1,1)
      ! Add to divergence integral of surrounding cut-cells:
      DO ISIDE=-1,0
         FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
         SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
         CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
            ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
            IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
            JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
            CUT_CELL(ICC)%DVOL(JCC)=CUT_CELL(ICC)%DVOL(JCC)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
         END SELECT
      ENDDO
   ENDDO ! IFACE
ENDDO ! ICF

! Now work with boundary faces:
! IAXIS faces:
X1AXIS = IAXIS
DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
   IW = CC_REGFACE_IAXIS_Z(IFACE)%IWC; IF(IW<1) CYCLE
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
   I  = CC_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
   J  = CC_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
   K  = CC_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)
   WC => WALL(IW)
   B1 => BOUNDARY_PROP1(WC%B1_INDEX)
   BC => BOUNDARY_COORD(WC%BC_INDEX)
   IOR = BC%IOR
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   RHOPV(ISIDE)      = RHOP(I+1+ISIDE,J,K)
   TMPV(ISIDE)       =  TMP(I+1+ISIDE,J,K)
   ! Get rho*hs on cells at both sides of IFACE:
   ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I+1+ISIDE,J,K,1:N_TRACKED_SPECIES)
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
   RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
   ! Calculate the sensible enthalpy at the boundary. If the boundary is solid
   ! and the gas is flowing out, use the gas temperature for the calculation.
   VELC      = UU(I,J,K)
   VELC2     = PRFCT*B1%U_NORMAL + (1._EB-PRFCT)*B1%U_NORMAL_S
   TMP_F_GAS = B1%TMP_F
   IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY) THEN
      VELC = -SIGN(1._EB,REAL(IOR,EB))*VELC2
      IF (VELC2>0._EB) TMP_F_GAS = TMP(BC%IIG,BC%JJG,BC%KKG)
   ENDIF
   ZZ_GET(1:N_TRACKED_SPECIES) = B1%ZZ_F(1:N_TRACKED_SPECIES)
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP_F_GAS)
   FN_H_S = B1%RHO_F*H_S ! bar{rho*hs}
   ! Add: -(bar{rho*hs} u dot n - (rho*hs) u dot n) to corresponding cell DP:
   AF = DY(J)*DZ(K)
   DPVOL(I+1+ISIDE,J,K) = DPVOL(I+1+ISIDE,J,K) + SIGN(1._EB,REAL(IOR,EB))*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
ENDDO

! JAXIS faces:
X1AXIS = JAXIS
DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
   IW = CC_REGFACE_JAXIS_Z(IFACE)%IWC; IF(IW<1) CYCLE
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
   I  = CC_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
   J  = CC_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
   K  = CC_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)
   WC => WALL(IW)
   B1 => BOUNDARY_PROP1(WC%B1_INDEX)
   BC => BOUNDARY_COORD(WC%BC_INDEX)
   IOR = BC%IOR
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   RHOPV(ISIDE)      = RHOP(I,J+1+ISIDE,K)
   TMPV(ISIDE)       =  TMP(I,J+1+ISIDE,K)
   ! Get rho*hs on cells at both sides of IFACE:
   ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J+1+ISIDE,K,1:N_TRACKED_SPECIES)
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
   RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
   ! Calculate the sensible enthalpy at the boundary. If the boundary is solid
   ! and the gas is flowing out, use the gas temperature for the calculation.
   VELC      = VV(I,J,K)
   VELC2     = PRFCT*B1%U_NORMAL + (1._EB-PRFCT)*B1%U_NORMAL_S
   TMP_F_GAS = B1%TMP_F
   IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY) THEN
      VELC = -SIGN(1._EB,REAL(IOR,EB))*VELC2
      IF (VELC2>0._EB) TMP_F_GAS = TMP(BC%IIG,BC%JJG,BC%KKG)
   ENDIF
   ZZ_GET(1:N_TRACKED_SPECIES) = B1%ZZ_F(1:N_TRACKED_SPECIES)
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP_F_GAS)
   FN_H_S = B1%RHO_F*H_S ! bar{rho*hs}
   ! Add: -(bar{rho*hs} u dot n - (rho*hs) u dot n) to corresponding cell DP:
   AF = DX(I)*DZ(K)
   DPVOL(I,J+1+ISIDE,K) = DPVOL(I,J+1+ISIDE,K) + SIGN(1._EB,REAL(IOR,EB))*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
ENDDO

! KAXIS faces:
X1AXIS = KAXIS
DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
   IW = CC_REGFACE_KAXIS_Z(IFACE)%IWC; IF(IW<1) CYCLE
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
   I  = CC_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
   J  = CC_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
   K  = CC_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)
   WC => WALL(IW)
   B1 => BOUNDARY_PROP1(WC%B1_INDEX)
   BC => BOUNDARY_COORD(WC%BC_INDEX)
   IOR = BC%IOR
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   RHOPV(ISIDE)      = RHOP(I,J,K+1+ISIDE)
   TMPV(ISIDE)       =  TMP(I,J,K+1+ISIDE)
   ! Get rho*hs on cells at both sides of IFACE:
   ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K+1+ISIDE,1:N_TRACKED_SPECIES)
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
   RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
   ! Calculate the sensible enthalpy at the boundary. If the boundary is solid
   ! and the gas is flowing out, use the gas temperature for the calculation.
   VELC      = WW(I,J,K)
   VELC2     = PRFCT*B1%U_NORMAL + (1._EB-PRFCT)*B1%U_NORMAL_S
   TMP_F_GAS = B1%TMP_F
   IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY) THEN
      VELC = -SIGN(1._EB,REAL(IOR,EB))*VELC2
      IF (VELC2>0._EB) TMP_F_GAS = TMP(BC%IIG,BC%JJG,BC%KKG)
   ENDIF
   ZZ_GET(1:N_TRACKED_SPECIES) = B1%ZZ_F(1:N_TRACKED_SPECIES)
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP_F_GAS)
   FN_H_S = B1%RHO_F*H_S ! bar{rho*hs}
   ! Add: -(bar{rho*hs} u dot n - (rho*hs) u dot n) to corresponding cell DP:
   AF = DX(I)*DY(J)
   DPVOL(I,J,K+1+ISIDE) = DPVOL(I,J,K+1+ISIDE) + SIGN(1._EB,REAL(IOR,EB))*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
ENDDO

! Regular Faces connecting gasphase cells to cut-cells:
DO IFACE=1,MESHES(NM)%CC_NBBRCFACE_Z
   IW = RC_FACE(IFACE)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY ) CYCLE
   I      = RC_FACE(IFACE)%IJK(IAXIS)
   J      = RC_FACE(IFACE)%IJK(JAXIS)
   K      = RC_FACE(IFACE)%IJK(KAXIS)
   X1AXIS = RC_FACE(IFACE)%IJK(KAXIS+1)
   WC => WALL(IW)
   B1 => BOUNDARY_PROP1(WC%B1_INDEX)
   BC => BOUNDARY_COORD(WC%BC_INDEX)
   IOR = BC%IOR
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   FCT   = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
   ! First (rho hs)_i,j,k:
   SELECT CASE(X1AXIS)
   CASE(IAXIS)
      AF = DY(J)*DZ(K)
      VELC = UU(I,J,K)
      RHOPV(ISIDE)      = RHOP(I+1+ISIDE,J,K)
      TMPV(ISIDE)       =  TMP(I+1+ISIDE,J,K)
      SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
      CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
         ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I+1+ISIDE,J,K,1:N_TRACKED_SPECIES)
      CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
         ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
         JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
         TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
         RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
         ZZ_GET(1:N_TRACKED_SPECIES) =  PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                                 (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
      END SELECT
   CASE(JAXIS)
      AF = DX(I)*DZ(K)
      VELC = VV(I,J,K)
      RHOPV(ISIDE)      = RHOP(I,J+1+ISIDE,K)
      TMPV(ISIDE)       =  TMP(I,J+1+ISIDE,K)
      SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
      CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
         ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J+1+ISIDE,K,1:N_TRACKED_SPECIES)
      CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
         ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
         JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
         TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
         RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
         ZZ_GET(1:N_TRACKED_SPECIES) =  PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                                 (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
      END SELECT
   CASE(KAXIS)
      AF = DX(I)*DY(J)
      VELC = WW(I,J,K)
      RHOPV(ISIDE)      = RHOP(I,J,K+1+ISIDE)
      TMPV(ISIDE)       =  TMP(I,J,K+1+ISIDE)
      SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
      CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
         ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K+1+ISIDE,1:N_TRACKED_SPECIES)
      CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
         ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
         JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
         TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
         RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
         ZZ_GET(1:N_TRACKED_SPECIES) =  PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                                 (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
      END SELECT
   END SELECT
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
   RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S

   ! Flux limited face value bar{rho*hs}_F
   ! Calculate the sensible enthalpy at the boundary. If the boundary is solid
   ! and the gas is flowing out, use the gas temperature for the calculation.
   VELC2     = PRFCT*B1%U_NORMAL + (1._EB-PRFCT)*B1%U_NORMAL_S
   TMP_F_GAS = B1%TMP_F
   SELECT CASE(WC%BOUNDARY_TYPE)
      CASE DEFAULT
         ! No need to do anything, populated before.
      CASE(SOLID_BOUNDARY)
         VELC = -SIGN(1._EB,REAL(IOR,EB))*VELC2
         IF (VELC2>0._EB) TMP_F_GAS = TMP(BC%IIG,BC%JJG,BC%KKG)
      CASE(INTERPOLATED_BOUNDARY)
         VELC = UVW_SAVE(IW)
   END SELECT
   ZZ_GET(1:N_TRACKED_SPECIES) = B1%ZZ_F(1:N_TRACKED_SPECIES)
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP_F_GAS)
   FN_H_S = B1%RHO_F*H_S ! bar{rho*hs}
   ! Finally add to Div:
   SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
   CASE(CC_FTYPE_RGGAS) ! Regular cell
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         DPVOL(I+1+ISIDE,J,K)=DPVOL(I+1+ISIDE,J,K)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF !+ve/-ve dot
      CASE(JAXIS)
         DPVOL(I,J+1+ISIDE,K)=DPVOL(I,J+1+ISIDE,K)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
      CASE(KAXIS)
         DPVOL(I,J,K+1+ISIDE)=DPVOL(I,J,K+1+ISIDE)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
      END SELECT
   CASE(CC_FTYPE_CFGAS) ! Cut-cell
      ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
      JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
      CUT_CELL(ICC)%DVOL(JCC)=CUT_CELL(ICC)%DVOL(JCC)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
   END SELECT
ENDDO

! Finally Gasphase cut-faces:
DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
   IF ( CUT_FACE(ICF)%STATUS /= CC_GASPHASE .OR. MESHES(NM)%CUT_FACE(ICF)%IWC<1) CYCLE
   IW = CUT_FACE(ICF)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY ) CYCLE
   WC => WALL(IW)
   B1 => BOUNDARY_PROP1(WC%B1_INDEX)
   BC => BOUNDARY_COORD(WC%BC_INDEX)
   IOR = BC%IOR
   ! Flux limited face value bar{rho*hs}_F, the P1 variable values fo TMP, RHOP, ZZ and RSUM have been averaged to
   ! the cartesian cell location in CC_DENSITY:
   VELC2     = PRFCT*B1%U_NORMAL + (1._EB-PRFCT)*B1%U_NORMAL_S
   TMP_F_GAS = B1%TMP_F
   IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY .AND. VELC2>0._EB) TMP_F_GAS = TMP(BC%IIG,BC%JJG,BC%KKG)
   ZZ_GET(1:N_TRACKED_SPECIES) = B1%ZZ_F(1:N_TRACKED_SPECIES)
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP_F_GAS)
   FN_H_S = B1%RHO_F*H_S ! bar{rho*hs}
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
   DO IFACE=1,CUT_FACE(ICF)%NFACE
      AF   = CUT_FACE(ICF)%AREA(IFACE)
      IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY) THEN ! Here used the CFA corresponding U_NORMAL.
         FCT  = 1._EB
         B1 => BOUNDARY_PROP1(CFACE(CUT_FACE(ICF)%CFACE_INDEX(IFACE))%B1_INDEX)
         VELC =         PRFCT*B1%U_NORMAL + (1._EB-PRFCT)*B1%U_NORMAL_S
      ELSEIF(WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) THEN
         VELC = CUT_FACE(ICF)%VEL_SAVE(IFACE)
      ELSE
         ! Last known cut-face velocity.
         VELC = (1._EB-PRFCT)*CUT_FACE(ICF)%VEL(IFACE) + PRFCT*CUT_FACE(ICF)%VELS(IFACE)
      ENDIF
      ! Here if INTERPOLATED_BOUNDARY we might need UVW_SAVE.
      ! First (rho hs)_i,j,k:
      SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
      CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
         ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
         JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
         TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
         RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
         ZZ_GET(1:N_TRACKED_SPECIES) =  PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                                 (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
         CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
         RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
         CUT_CELL(ICC)%DVOL(JCC)=CUT_CELL(ICC)%DVOL(JCC)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF ! +ve or -ve dot
      END SELECT
   ENDDO ! IFACE
ENDDO ! ICF

! Enthalpy advection due to INBOUNDARY cut-faces (CFACE):
ISIDE=-1
CFACE_LOOP : DO ICFA=INTERNAL_CFACE_CELLS_LB+1,INTERNAL_CFACE_CELLS_LB+N_INTERNAL_CFACE_CELLS
   CFA => CFACE(ICFA)
   B1 => BOUNDARY_PROP1(CFA%B1_INDEX)
   ! Find associated cut-cell:
   IND1=CFA%CUT_FACE_IND1
   IND2=CFA%CUT_FACE_IND2
   ICC = CUT_FACE(IND1)%CELL_LIST(2,LOW_IND,IND2)
   JCC = CUT_FACE(IND1)%CELL_LIST(3,LOW_IND,IND2)
   AF = CFA%AREA
   VELC      = PRFCT*B1%U_NORMAL + (1._EB-PRFCT)*B1%U_NORMAL_S ! Contains AREA_ADJUST for the CFACE.
   TMP_F_GAS = B1%TMP_F
   IF (VELC>0._EB) TMP_F_GAS = B1%TMP_G ! CUT_CELL(ICC)%TMP(JCC)
   ZZ_GET(1:N_TRACKED_SPECIES) = B1%ZZ_F(1:N_TRACKED_SPECIES)
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP_F_GAS)
   FN_H_S = B1%RHO_F*H_S ! bar{rho*hs}

   TMPV(ISIDE)  = CUT_CELL(ICC)%TMP(JCC)
   RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
   ZZ_GET(1:N_TRACKED_SPECIES) = PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                          (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
   RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
   CUT_CELL(ICC)%DVOL(JCC)=CUT_CELL(ICC)%DVOL(JCC)+(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF ! +ve or -ve dot
ENDDO CFACE_LOOP

RETURN
END SUBROUTINE CCENTHALPY_ADVECTION

! ----------------------- CC_DIFFUSIVE_HEAT_FLUXES ------------------------

SUBROUTINE CC_DIFFUSIVE_HEAT_FLUXES

! NOTE: this routine assumes POINT_TO_MESH(NM) has been previously called.

! Local Variables:
INTEGER :: IIG, JJG, KKG , IOR
REAL(EB) :: UN_P
LOGICAL :: DO_LO, DO_HI

SPECIES_LOOP1: DO N=1,N_TOTAL_SCALARS

   ! IAXIS faces:
   X1AXIS = IAXIS
   DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
      IW = CC_REGFACE_IAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I     = CC_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
      J     = CC_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
      K     = CC_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)
      DO_LO = CC_REGFACE_IAXIS_Z(IFACE)%DO_LO_IND
      DO_HI = CC_REGFACE_IAXIS_Z(IFACE)%DO_HI_IND

      ! H_RHO_D_DZDN
      TMP_G = 0.5_EB*(TMP(I+1,J,K)+TMP(I,J,K))
      CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
      CC_REGFACE_IAXIS_Z(IFACE)%H_RHO_D_DZDN(N) = H_S*CC_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N)

      ! Add H_RHO_D_DZDN dot n to corresponding cell DP. Add to int(DEL_RHO_D_DEL_Z)dv in FV form:
      AF = DY(J)*DZ(K)
      IF (DO_LO) THEN
         DPVOL(I  ,J,K) = DPVOL(I  ,J,K) + CC_REGFACE_IAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! +ve dot
         DEL_RHO_D_DEL_Z(I  ,J,K,N)=DEL_RHO_D_DEL_Z(I  ,J,K,N)+CC_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N)*AF !+ dot
      ENDIF
      IF (DO_HI) THEN
         DPVOL(I+1,J,K) = DPVOL(I+1,J,K) - CC_REGFACE_IAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! -ve dot
         DEL_RHO_D_DEL_Z(I+1,J,K,N)=DEL_RHO_D_DEL_Z(I+1,J,K,N)-CC_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N)*AF !- dot
      ENDIF
   ENDDO

   ! JAXIS faces:
   X1AXIS = JAXIS
   DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
      IW = CC_REGFACE_JAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I     = CC_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
      J     = CC_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
      K     = CC_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)
      DO_LO = CC_REGFACE_JAXIS_Z(IFACE)%DO_LO_IND
      DO_HI = CC_REGFACE_JAXIS_Z(IFACE)%DO_HI_IND

      ! H_RHO_D_DZDN
      TMP_G = 0.5_EB*(TMP(I,J+1,K)+TMP(I,J,K))
      CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
      CC_REGFACE_JAXIS_Z(IFACE)%H_RHO_D_DZDN(N) = H_S*CC_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N)

      ! Add H_RHO_D_DZDN dot n to corresponding cell DP. Add to int(DEL_RHO_D_DEL_Z)dv in FV form:
      AF = DX(I)*DZ(K)
      IF (DO_LO) THEN
         DPVOL(I,J  ,K) = DPVOL(I,J  ,K) + CC_REGFACE_JAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! +ve dot
         DEL_RHO_D_DEL_Z(I,J  ,K,N)=DEL_RHO_D_DEL_Z(I,J  ,K,N)+CC_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N)*AF !+ dot
      ENDIF
      IF (DO_HI) THEN
         DPVOL(I,J+1,K) = DPVOL(I,J+1,K) - CC_REGFACE_JAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! -ve dot
         DEL_RHO_D_DEL_Z(I,J+1,K,N)=DEL_RHO_D_DEL_Z(I,J+1,K,N)-CC_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N)*AF !- dot
      ENDIF
   ENDDO

   ! KAXIS faces:
   X1AXIS = KAXIS
   DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
      IW = CC_REGFACE_KAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
      I     = CC_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
      J     = CC_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
      K     = CC_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)
      DO_LO = CC_REGFACE_KAXIS_Z(IFACE)%DO_LO_IND
      DO_HI = CC_REGFACE_KAXIS_Z(IFACE)%DO_HI_IND

      ! H_RHO_D_DZDN
      TMP_G = 0.5_EB*(TMP(I,J,K+1)+TMP(I,J,K))
      CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
      CC_REGFACE_KAXIS_Z(IFACE)%H_RHO_D_DZDN(N) = H_S*CC_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N)

      ! Add H_RHO_D_DZDN dot n to corresponding cell DP. Add to int(DEL_RHO_D_DEL_Z)dv in FV form:
      AF = DX(I)*DY(J)
      IF (DO_LO) THEN
         DPVOL(I,J,K  ) = DPVOL(I,J,K  ) + CC_REGFACE_KAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! +ve dot
         DEL_RHO_D_DEL_Z(I,J,K  ,N)=DEL_RHO_D_DEL_Z(I,J,K  ,N)+CC_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N)*AF !+ dot
      ENDIF
      IF (DO_HI) THEN
         DPVOL(I,J,K+1) = DPVOL(I,J,K+1) - CC_REGFACE_KAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! -ve dot
         DEL_RHO_D_DEL_Z(I,J,K+1,N)=DEL_RHO_D_DEL_Z(I,J,K+1,N)-CC_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N)*AF !- dot
      ENDIF
   ENDDO

ENDDO SPECIES_LOOP1

! Regular faces connecting gasphase- cut-cells:
DO IFACE=1,MESHES(NM)%CC_NRCFACE_Z
   IW = RC_FACE(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I      = RC_FACE(IFACE)%IJK(IAXIS)
   J      = RC_FACE(IFACE)%IJK(JAXIS)
   K      = RC_FACE(IFACE)%IJK(KAXIS)
   X1AXIS = RC_FACE(IFACE)%IJK(KAXIS+1)
   TMP_G  = RC_FACE(IFACE)%TMP_FACE
   SELECT CASE(X1AXIS)
   CASE(IAXIS)
      AF = DY(J)*DZ(K)
      ! H_RHO_D_DZDN
      DO N=1,N_TOTAL_SCALARS
         CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
         RC_FACE(IFACE)%H_RHO_D_DZDN(N) = H_S*RC_FACE(IFACE)%RHO_D_DZDN(N)
      ENDDO
      ! Add contribution to DP:
      ! Low side cell:
      DO ISIDE=-1,0
         FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
         SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
         CASE(CC_FTYPE_RGGAS) ! Regular cell
         DPVOL(I+1+ISIDE,J,K)=DPVOL(I+1+ISIDE,J,K)+FCT*SUM(RC_FACE(IFACE)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF
         ! +ve or -ve dot
         DO N=1,N_TOTAL_SCALARS
         DEL_RHO_D_DEL_Z(I+1+ISIDE,J,K,N)=DEL_RHO_D_DEL_Z(I+1+ISIDE,J,K,N)+FCT*RC_FACE(IFACE)%RHO_D_DZDN(N)*AF
         ENDDO
         CASE(CC_FTYPE_CFGAS) ! Cut-cell
         ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
         IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE
         JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
         CUT_CELL(ICC)%DVOL(JCC)=CUT_CELL(ICC)%DVOL(JCC)+FCT*SUM(RC_FACE(IFACE)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF !+/- dot
         CUT_CELL(ICC)%DEL_RHO_D_DEL_Z_VOL(1:N_TOTAL_SCALARS,JCC)= &
         CUT_CELL(ICC)%DEL_RHO_D_DEL_Z_VOL(1:N_TOTAL_SCALARS,JCC)+FCT*RC_FACE(IFACE)%RHO_D_DZDN(1:N_TOTAL_SCALARS)*AF
         END SELECT
      ENDDO
   CASE(JAXIS)
      AF = DX(I)*DZ(K)
      ! H_RHO_D_DZDN
      DO N=1,N_TOTAL_SCALARS
         CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
         RC_FACE(IFACE)%H_RHO_D_DZDN(N) = H_S*RC_FACE(IFACE)%RHO_D_DZDN(N)
      ENDDO
      ! Add contribution to DP:
      ! Low side cell:
      DO ISIDE=-1,0
         FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
         SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
         CASE(CC_FTYPE_RGGAS) ! Regular cell
         DPVOL(I,J+1+ISIDE,K)=DPVOL(I,J+1+ISIDE,K)+FCT*SUM(RC_FACE(IFACE)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF
         ! +ve or -ve dot
         DO N=1,N_TOTAL_SCALARS
         DEL_RHO_D_DEL_Z(I,J+1+ISIDE,K,N)=DEL_RHO_D_DEL_Z(I,J+1+ISIDE,K,N)+FCT*RC_FACE(IFACE)%RHO_D_DZDN(N)*AF
         ENDDO
         CASE(CC_FTYPE_CFGAS) ! Cut-cell
         ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
         IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE
         JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
         CUT_CELL(ICC)%DVOL(JCC)=CUT_CELL(ICC)%DVOL(JCC)+FCT*SUM(RC_FACE(IFACE)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF !+/- dot
         CUT_CELL(ICC)%DEL_RHO_D_DEL_Z_VOL(1:N_TOTAL_SCALARS,JCC)= &
         CUT_CELL(ICC)%DEL_RHO_D_DEL_Z_VOL(1:N_TOTAL_SCALARS,JCC)+FCT*RC_FACE(IFACE)%RHO_D_DZDN(1:N_TOTAL_SCALARS)*AF
         END SELECT
      ENDDO
   CASE(KAXIS)
      AF = DX(I)*DY(J)
      ! H_RHO_D_DZDN
      DO N=1,N_TOTAL_SCALARS
         CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
         RC_FACE(IFACE)%H_RHO_D_DZDN(N) = H_S*RC_FACE(IFACE)%RHO_D_DZDN(N)
      ENDDO
      ! Add contribution to DP:
      ! Low side cell:
      DO ISIDE=-1,0
         FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
         SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
         CASE(CC_FTYPE_RGGAS) ! Regular cell
         DPVOL(I,J,K+1+ISIDE)=DPVOL(I,J,K+1+ISIDE)+FCT*SUM(RC_FACE(IFACE)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF
         ! +ve or -ve dot
         DO N=1,N_TOTAL_SCALARS
         DEL_RHO_D_DEL_Z(I,J,K+1+ISIDE,N)=DEL_RHO_D_DEL_Z(I,J,K+1+ISIDE,N)+FCT*RC_FACE(IFACE)%RHO_D_DZDN(N)*AF
         ENDDO
         CASE(CC_FTYPE_CFGAS) ! Cut-cell
         ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
         IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE
         JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
         CUT_CELL(ICC)%DVOL(JCC)=CUT_CELL(ICC)%DVOL(JCC)+FCT*SUM(RC_FACE(IFACE)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF !+/- dot
         CUT_CELL(ICC)%DEL_RHO_D_DEL_Z_VOL(1:N_TOTAL_SCALARS,JCC)= &
         CUT_CELL(ICC)%DEL_RHO_D_DEL_Z_VOL(1:N_TOTAL_SCALARS,JCC)+FCT*RC_FACE(IFACE)%RHO_D_DZDN(1:N_TOTAL_SCALARS)*AF
         END SELECT
      ENDDO
   END SELECT
ENDDO

! GASPHASE cut-faces:
DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
   IF ( CUT_FACE(ICF)%STATUS /= CC_GASPHASE ) CYCLE
   IW = CUT_FACE(ICF)%IWC
   ! Note: for cut-faces open boundaries are dealt with below in external BC loops:
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I = CUT_FACE(ICF)%IJK(IAXIS)
   J = CUT_FACE(ICF)%IJK(JAXIS)
   K = CUT_FACE(ICF)%IJK(KAXIS)
   X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)
   DO IFACE=1,CUT_FACE(ICF)%NFACE
      AF = CUT_FACE(ICF)%AREA(IFACE)
      ! H_RHO_D_DZDN
      TMP_G = CUT_FACE(ICF)%TMP_FACE(IFACE)
      DO N=1,N_TOTAL_SCALARS
         CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
         CUT_FACE(ICF)%H_RHO_D_DZDN(N,IFACE) = H_S*CUT_FACE(ICF)%RHO_D_DZDN(N,IFACE)
      ENDDO
      ! Add to divergence integral of surrounding cut-cells:
      DO ISIDE=-1,0
         FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
         SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
         CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
         ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
         IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE
         JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
         CUT_CELL(ICC)%DVOL(JCC) = CUT_CELL(ICC)%DVOL(JCC)+FCT*SUM(CUT_FACE(ICF)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS,IFACE))*AF !+/- dot
         CUT_CELL(ICC)%DEL_RHO_D_DEL_Z_VOL(1:N_TOTAL_SCALARS,JCC)= &
         CUT_CELL(ICC)%DEL_RHO_D_DEL_Z_VOL(1:N_TOTAL_SCALARS,JCC)+FCT*CUT_FACE(ICF)%RHO_D_DZDN(1:N_TOTAL_SCALARS,IFACE)*AF
         END SELECT
      ENDDO
   ENDDO ! IFACE
ENDDO ! ICF


! Now define diffussive heat flux components in Boundaries:
! CFACES:
ISIDE=-1
CFACE_LOOP : DO ICF=INTERNAL_CFACE_CELLS_LB+1,INTERNAL_CFACE_CELLS_LB+N_INTERNAL_CFACE_CELLS
   CFA => CFACE(ICF)
   B1 => BOUNDARY_PROP1(CFA%B1_INDEX)
   IND1 = CFA%CUT_FACE_IND1;                         IND2 = CFA%CUT_FACE_IND2
   ICC  = CUT_FACE(IND1)%CELL_LIST(2,LOW_IND,IND2);  JCC  = CUT_FACE(IND1)%CELL_LIST(3,LOW_IND,IND2)
   ! H_RHO_D_DZDN
   UN_P =  PRFCT*B1%U_NORMAL + (1._EB-PRFCT)*B1%U_NORMAL_S
   TMP_G = B1%TMP_F
   IF (UN_P>0._EB) TMP_G = B1%TMP_G
   DO N=1,N_TOTAL_SCALARS
      CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
      CUT_FACE(IND1)%H_RHO_D_DZDN(N,IND2) = H_S*B1%RHO_D_DZDN_F(N)
   ENDDO
   AF = CFA%AREA  ! No need for B1%AREA_ADJUST, RHO_D_DZDN_F is already area djusted. Same for Domain Boundaries below.
   ! Add diffusive mass flux enthalpy contribution to cut-cell thermo divg:
   CUT_CELL(ICC)%DVOL(JCC) = CUT_CELL(ICC)%DVOL(JCC) - SUM(CUT_FACE(IND1)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS,IND2))*AF
   CUT_CELL(ICC)%DEL_RHO_D_DEL_Z_VOL(1:N_TOTAL_SCALARS,JCC) = &
   CUT_CELL(ICC)%DEL_RHO_D_DEL_Z_VOL(1:N_TOTAL_SCALARS,JCC) - B1%RHO_D_DZDN_F(1:N_TOTAL_SCALARS)*AF
ENDDO CFACE_LOOP

! Domain boundaries:
SPECIES_LOOP2: DO N=1,N_TOTAL_SCALARS

   ! IAXIS faces:
   X1AXIS = IAXIS
   DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
      IW = CC_REGFACE_IAXIS_Z(IFACE)%IWC; IF(IW<1) CYCLE; WC => WALL(IW)
      IF( ANY(WC%BOUNDARY_TYPE==(/NULL_BOUNDARY,INTERPOLATED_BOUNDARY,PERIODIC_BOUNDARY/)) ) CYCLE
      I  = CC_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
      J  = CC_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
      K  = CC_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)
      B1 => BOUNDARY_PROP1(WC%B1_INDEX)
      BC => BOUNDARY_COORD(WC%BC_INDEX)
      UN_P = PRFCT*B1%U_NORMAL + (1._EB-PRFCT)*B1%U_NORMAL_S
      TMP_G = B1%TMP_F
      IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY .AND. UN_P>0._EB) TMP_G = TMP(BC%IIG,BC%JJG,BC%KKG)
      ! H_RHO_D_DZDN
      CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
      CC_REGFACE_IAXIS_Z(IFACE)%H_RHO_D_DZDN(N) = H_S*CC_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N)

      ! Add H_RHO_D_DZDN dot n to corresponding cell DP:
      AF = DY(J)*DZ(K)
      SELECT CASE(BOUNDARY_COORD(WC%BC_INDEX)%IOR)
      CASE(-IAXIS) ! Low side cell. Add to int(DEL_RHO_D_DEL_Z)dv in FV form:
      IF (.NOT.CC_REGFACE_IAXIS_Z(IFACE)%DO_LO_IND) CYCLE
      DPVOL(I  ,J,K)             =             DPVOL(I  ,J,K) + CC_REGFACE_IAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! +ve dot
      DEL_RHO_D_DEL_Z(I  ,J,K,N) = DEL_RHO_D_DEL_Z(I  ,J,K,N) + CC_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N)   * AF ! +ve dot
      CASE( IAXIS) ! High side cell.
      IF (.NOT.CC_REGFACE_IAXIS_Z(IFACE)%DO_HI_IND) CYCLE
      DPVOL(I+1,J,K)             =             DPVOL(I+1,J,K) - CC_REGFACE_IAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! -ve dot
      DEL_RHO_D_DEL_Z(I+1,J,K,N) = DEL_RHO_D_DEL_Z(I+1,J,K,N) - CC_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N)   * AF ! -ve dot
      END SELECT
   ENDDO

   ! JAXIS faces:
   X1AXIS = JAXIS
   DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
      IW = CC_REGFACE_JAXIS_Z(IFACE)%IWC; IF(IW<1) CYCLE; WC => WALL(IW)
      IF( ANY(WC%BOUNDARY_TYPE==(/NULL_BOUNDARY,INTERPOLATED_BOUNDARY,PERIODIC_BOUNDARY/)) ) CYCLE
      I  = CC_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
      J  = CC_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
      K  = CC_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)
      B1 => BOUNDARY_PROP1(WC%B1_INDEX)
      BC => BOUNDARY_COORD(WC%BC_INDEX)
      UN_P = PRFCT*B1%U_NORMAL + (1._EB-PRFCT)*B1%U_NORMAL_S
      TMP_G = B1%TMP_F
      IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY .AND. UN_P>0._EB) TMP_G = TMP(BC%IIG,BC%JJG,BC%KKG)
      ! H_RHO_D_DZDN
      CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
      CC_REGFACE_JAXIS_Z(IFACE)%H_RHO_D_DZDN(N) = H_S*CC_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N)

      ! Add H_RHO_D_DZDN dot n to corresponding cell DP:
      AF = DX(I)*DZ(K)
      SELECT CASE(BOUNDARY_COORD(WC%BC_INDEX)%IOR)
      CASE(-JAXIS) ! Low side cell. Add to int(DEL_RHO_D_DEL_Z)dv in FV form:
      IF (.NOT.CC_REGFACE_JAXIS_Z(IFACE)%DO_LO_IND) CYCLE
      DPVOL(I,J  ,K)             =             DPVOL(I,J  ,K) + CC_REGFACE_JAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! +ve dot
      DEL_RHO_D_DEL_Z(I,J  ,K,N) = DEL_RHO_D_DEL_Z(I,J  ,K,N) + CC_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N)   * AF ! +ve dot
      CASE( JAXIS) ! High side cell.
      IF (.NOT.CC_REGFACE_JAXIS_Z(IFACE)%DO_HI_IND) CYCLE
      DPVOL(I,J+1,K)             =             DPVOL(I,J+1,K) - CC_REGFACE_JAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! -ve dot
      DEL_RHO_D_DEL_Z(I,J+1,K,N) = DEL_RHO_D_DEL_Z(I,J+1,K,N) - CC_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N)   * AF ! -ve dot
      END SELECT
   ENDDO

   ! KAXIS faces:
   X1AXIS = KAXIS
   DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
      IW = CC_REGFACE_KAXIS_Z(IFACE)%IWC; IF(IW<1) CYCLE; WC => WALL(IW)
      IF( ANY(WC%BOUNDARY_TYPE==(/NULL_BOUNDARY,INTERPOLATED_BOUNDARY,PERIODIC_BOUNDARY/)) ) CYCLE
      I  = CC_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
      J  = CC_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
      K  = CC_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)
      B1 => BOUNDARY_PROP1(WC%B1_INDEX)
      BC => BOUNDARY_COORD(WC%BC_INDEX)
      UN_P = PRFCT*B1%U_NORMAL + (1._EB-PRFCT)*B1%U_NORMAL_S
      TMP_G = B1%TMP_F
      IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY .AND. UN_P>0._EB) TMP_G = TMP(BC%IIG,BC%JJG,BC%KKG)
      ! H_RHO_D_DZDN
      CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
      CC_REGFACE_KAXIS_Z(IFACE)%H_RHO_D_DZDN(N) = H_S*CC_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N)

      ! Add H_RHO_D_DZDN dot n to corresponding cell DP:
      AF = DX(I)*DY(J)
      SELECT CASE(BOUNDARY_COORD(WC%BC_INDEX)%IOR)
      CASE(-KAXIS) ! Low side cell. Add to int(DEL_RHO_D_DEL_Z)dv in FV form:
      IF (.NOT.CC_REGFACE_KAXIS_Z(IFACE)%DO_LO_IND) CYCLE
      DPVOL(I,J,K  )             =             DPVOL(I,J,K  ) + CC_REGFACE_KAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! +ve dot
      DEL_RHO_D_DEL_Z(I,J,K  ,N) = DEL_RHO_D_DEL_Z(I,J,K  ,N) + CC_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N)   * AF ! +ve dot
      CASE( KAXIS) ! High side cell.
      IF (.NOT.CC_REGFACE_KAXIS_Z(IFACE)%DO_HI_IND) CYCLE
      DPVOL(I,J,K+1)             =             DPVOL(I,J,K+1) - CC_REGFACE_KAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! -ve dot
      DEL_RHO_D_DEL_Z(I,J,K+1,N) = DEL_RHO_D_DEL_Z(I,J,K+1,N) - CC_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N)   * AF ! -ve dot
      END SELECT
   ENDDO

ENDDO SPECIES_LOOP2

! Regular faces connecting gasphase- cut-cells:
DO IFACE=1,MESHES(NM)%CC_NBBRCFACE_Z
   RCF => RC_FACE(IFACE); IW = RCF%IWC; WC => WALL(IW)
   IF( ANY(WC%BOUNDARY_TYPE==(/NULL_BOUNDARY,INTERPOLATED_BOUNDARY,PERIODIC_BOUNDARY/)) ) CYCLE
   I   = RCF%IJK(IAXIS); J = RCF%IJK(JAXIS); K = RCF%IJK(KAXIS); X1AXIS = RCF%IJK(KAXIS+1); TMP_G = RCF%TMP_FACE
   BC => BOUNDARY_COORD(WC%BC_INDEX)
   IIG = BC%IIG; JJG = BC%JJG; KKG = BC%KKG; IOR = BC%IOR
   ! H_RHO_D_DZDN
   DO N=1,N_TOTAL_SCALARS
      CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
      RCF%H_RHO_D_DZDN(N) = H_S*RCF%RHO_D_DZDN(N)
   ENDDO
   SELECT CASE(X1AXIS)
   CASE(IAXIS); AF = DY(J)*DZ(K)
   CASE(JAXIS); AF = DX(I)*DZ(K)
   CASE(KAXIS); AF = DX(I)*DY(J)
   END SELECT
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
   SELECT CASE(RCF%CELL_LIST(1,ISIDE+2))
   CASE(CC_FTYPE_RGGAS) ! Regular cell
   DPVOL(IIG,JJG,KKG)=DPVOL(IIG,JJG,KKG)+FCT*SUM(RCF%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF ! +ve or -ve dot
   DO N=1,N_TOTAL_SCALARS
      DEL_RHO_D_DEL_Z(IIG,JJG,KKG,N)=DEL_RHO_D_DEL_Z(IIG,JJG,KKG,N)+FCT*RCF%RHO_D_DZDN(N)*AF
   ENDDO
   CASE(CC_FTYPE_CFGAS) ! Cut-cell
   ICC = RCF%CELL_LIST(2,ISIDE+2); JCC = RCF%CELL_LIST(3,ISIDE+2)
   CUT_CELL(ICC)%DVOL(JCC) = CUT_CELL(ICC)%DVOL(JCC) + FCT*SUM(RCF%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF !+/- dot
   CUT_CELL(ICC)%DEL_RHO_D_DEL_Z_VOL(1:N_TOTAL_SCALARS,JCC) = &
   CUT_CELL(ICC)%DEL_RHO_D_DEL_Z_VOL(1:N_TOTAL_SCALARS,JCC) + FCT*RCF%RHO_D_DZDN(1:N_TOTAL_SCALARS) * AF
   END SELECT
ENDDO

! GASPHASE cut-faces:
DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
   CF => CUT_FACE(ICF); IF ( CF%STATUS /= CC_GASPHASE .OR. CF%IWC<1) CYCLE
   IW = CF%IWC; WC => WALL(IW)
   IF( ANY(WC%BOUNDARY_TYPE==(/NULL_BOUNDARY,INTERPOLATED_BOUNDARY,PERIODIC_BOUNDARY/)) ) CYCLE
   I  = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
   IOR= BOUNDARY_COORD(WC%BC_INDEX)%IOR
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   DO IFACE=1,CF%NFACE
      AF = CF%AREA(IFACE)
      ! H_RHO_D_DZDN
      TMP_G = CF%TMP_FACE(IFACE)
      DO N=1,N_TOTAL_SCALARS
         CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
         CF%H_RHO_D_DZDN(N,IFACE) = H_S*CF%RHO_D_DZDN(N,IFACE)
      ENDDO
      ! Add to divergence integral of surrounding cut-cells:
      FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
      SELECT CASE(CF%CELL_LIST(1,ISIDE+2,IFACE))
      CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
      ICC = CF%CELL_LIST(2,ISIDE+2,IFACE); JCC = CF%CELL_LIST(3,ISIDE+2,IFACE)
      CUT_CELL(ICC)%DVOL(JCC) = CUT_CELL(ICC)%DVOL(JCC) + FCT*SUM(CF%H_RHO_D_DZDN(1:N_TOTAL_SCALARS,IFACE)) * AF !+/- dot
      CUT_CELL(ICC)%DEL_RHO_D_DEL_Z_VOL(1:N_TOTAL_SCALARS,JCC) = &
      CUT_CELL(ICC)%DEL_RHO_D_DEL_Z_VOL(1:N_TOTAL_SCALARS,JCC) + FCT*CF%RHO_D_DZDN(1:N_TOTAL_SCALARS,IFACE)*AF
      END SELECT
   ENDDO ! IFACE
ENDDO ! ICF

RETURN
END SUBROUTINE CC_DIFFUSIVE_HEAT_FLUXES

! ----------------------- CC_CONDUCTION_HEAT_FLUX --------------------------

SUBROUTINE CC_CONDUCTION_HEAT_FLUX

INTEGER :: IIG, JJG, KKG, IOR
REAL(EB):: KPDTDN=0._EB,KPV(-1:0)=0._EB

! IAXIS faces:
X1AXIS = IAXIS
DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)

   IW = CC_REGFACE_IAXIS_Z(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

   I     = CC_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
   J     = CC_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
   K     = CC_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)

   ! K*DTDN:
   TMPV(-1:0)  = TMP(I:I+1,J,K)
   ! KP on low-high side cells:
   DO ISIDE=-1,0
      ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I+1+ISIDE,J,K,1:N_TRACKED_SPECIES)
      CALL GET_CC_CELL_CONDUCTIVITY(ZZ_GET,MU(I+1+ISIDE,J,K),&
                                             MU_DNS(I+1+ISIDE,J,K),TMPV(ISIDE),KPV(ISIDE))
   ENDDO
   KPDTDN = 0.5_EB*(KPV(-1)+KPV(0)) * (TMPV(0)-TMPV(-1)) / DX(I)

   ! Add K*DTDN dot n to corresponding cell DP:
   AF = DY(J)*DZ(K)
   IF(CC_REGFACE_IAXIS_Z(IFACE)%DO_LO_IND) DPVOL(I  ,J,K) = DPVOL(I  ,J,K) + KPDTDN * AF ! +ve dot
   IF(CC_REGFACE_IAXIS_Z(IFACE)%DO_HI_IND) DPVOL(I+1,J,K) = DPVOL(I+1,J,K) - KPDTDN * AF ! -ve dot
ENDDO

! JAXIS faces:
X1AXIS = JAXIS
DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)

   IW = CC_REGFACE_JAXIS_Z(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

   I  = CC_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
   J  = CC_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
   K  = CC_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)

   ! K*DTDN:
   TMPV(-1:0)  = TMP(I,J:J+1,K)
   ! KP on low-high side cells:
   DO ISIDE=-1,0
      ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J+1+ISIDE,K,1:N_TRACKED_SPECIES)
      CALL GET_CC_CELL_CONDUCTIVITY(ZZ_GET,MU(I,J+1+ISIDE,K),&
                                             MU_DNS(I,J+1+ISIDE,K),TMPV(ISIDE),KPV(ISIDE))
   ENDDO
   KPDTDN = 0.5_EB*(KPV(-1)+KPV(0)) * (TMPV(0)-TMPV(-1)) / DY(J)

   ! Add K*DTDN dot n to corresponding cell DP:
   AF = DX(I)*DZ(K)
   IF(CC_REGFACE_JAXIS_Z(IFACE)%DO_LO_IND) DPVOL(I,J  ,K) = DPVOL(I,J  ,K) + KPDTDN * AF ! +ve dot
   IF(CC_REGFACE_JAXIS_Z(IFACE)%DO_HI_IND) DPVOL(I,J+1,K) = DPVOL(I,J+1,K) - KPDTDN * AF ! -ve dot
ENDDO

! KAXIS faces:
X1AXIS = KAXIS
DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)

   IW = CC_REGFACE_KAXIS_Z(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

   I  = CC_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
   J  = CC_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
   K  = CC_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)

   ! K*DTDN:
   TMPV(-1:0)  = TMP(I,J,K:K+1)
   ! KP on low-high side cells:
   DO ISIDE=-1,0
      ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K+1+ISIDE,1:N_TRACKED_SPECIES)
      CALL GET_CC_CELL_CONDUCTIVITY(ZZ_GET,MU(I,J,K+1+ISIDE),&
                                             MU_DNS(I,J,K+1+ISIDE),TMPV(ISIDE),KPV(ISIDE))
   ENDDO
   KPDTDN = 0.5_EB*(KPV(-1)+KPV(0)) * (TMPV(0)-TMPV(-1)) / DZ(K)

   ! Add K*DTDN dot n to corresponding cell DP:
   AF = DX(I)*DY(J)
   IF(CC_REGFACE_KAXIS_Z(IFACE)%DO_LO_IND) DPVOL(I,J,K  ) = DPVOL(I,J,K  ) + KPDTDN * AF ! +ve dot
   IF(CC_REGFACE_KAXIS_Z(IFACE)%DO_HI_IND) DPVOL(I,J,K+1) = DPVOL(I,J,K+1) - KPDTDN * AF ! -ve dot
ENDDO


! Regular faces connecting gasphase - cut-cells:
DO IFACE=1,MESHES(NM)%CC_NRCFACE_Z

   IW = RC_FACE(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

   I      = RC_FACE(IFACE)%IJK(IAXIS)
   J      = RC_FACE(IFACE)%IJK(JAXIS)
   K      = RC_FACE(IFACE)%IJK(KAXIS)
   X1AXIS = RC_FACE(IFACE)%IJK(KAXIS+1)

   SELECT CASE(X1AXIS)
      CASE(IAXIS)
         AF = DY(J)*DZ(K)
         X1F= MESHES(NM)%X(I)
         IDX = 1._EB / ( RC_FACE(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                         RC_FACE(IFACE)%XCEN(X1AXIS,LOW_IND) )
         ! Linear interpolation coefficients:
         CCM1 = IDX*(RC_FACE(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
         CCP1 = IDX*(X1F -RC_FACE(IFACE)%XCEN(X1AXIS,LOW_IND))

         TMPV(-1:0)  = TMP(I:I+1,J,K)
         DO ISIDE=-1,0
            ZZ_GET = 0._EB
            SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
               ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I+1+ISIDE,J,K,1:N_TRACKED_SPECIES)
            CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
               JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
               TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
               ZZ_GET(1:N_TRACKED_SPECIES) =  &
                      PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
               (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
            END SELECT
            ! KP on low-high side cells:
            CALL GET_CC_CELL_CONDUCTIVITY(ZZ_GET,MU(I+1+ISIDE,J,K),&
                                                   MU_DNS(I+1+ISIDE,J,K),TMPV(ISIDE),KPV(ISIDE))
         ENDDO

         KPDTDN = (CCM1*KPV(-1)+CCP1*KPV(0)) * (TMPV(0)-TMPV(-1)) * IDX

         ! Add contribution to DP:
         ! Low side cell:
         DO ISIDE=-1,0
            FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
            SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(CC_FTYPE_RGGAS) ! Regular cell
               DPVOL(I+1+ISIDE,J,K) = DPVOL(I+1+ISIDE,J,K) + FCT*KPDTDN * AF ! +ve or -ve dot
            CASE(CC_FTYPE_CFGAS) ! Cut-cell
               ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
               IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
               JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
               CUT_CELL(ICC)%DVOL(JCC) = CUT_CELL(ICC)%DVOL(JCC) + FCT*KPDTDN * AF ! +ve or -ve dot
            END SELECT
         ENDDO

      CASE(JAXIS)
         AF = DX(I)*DZ(K)
         X1F= MESHES(NM)%Y(J)
         IDX = 1._EB / ( RC_FACE(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                         RC_FACE(IFACE)%XCEN(X1AXIS,LOW_IND) )
         ! Linear interpolation coefficients:
         CCM1 = IDX*(RC_FACE(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
         CCP1 = IDX*(X1F -RC_FACE(IFACE)%XCEN(X1AXIS,LOW_IND))

         TMPV(-1:0)  = TMP(I,J:J+1,K)
         DO ISIDE=-1,0
            ZZ_GET = 0._EB
            SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
               ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J+1+ISIDE,K,1:N_TRACKED_SPECIES)
            CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
               JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
               TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
               ZZ_GET(1:N_TRACKED_SPECIES) =  &
                      PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
               (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
            END SELECT
            ! KP on low-high side cells:
            CALL GET_CC_CELL_CONDUCTIVITY(ZZ_GET,MU(I,J+1+ISIDE,K),&
                                                   MU_DNS(I,J+1+ISIDE,K),TMPV(ISIDE),KPV(ISIDE))
         ENDDO

         KPDTDN = (CCM1*KPV(-1)+CCP1*KPV(0)) * (TMPV(0)-TMPV(-1)) * IDX

         ! Add contribution to DP:
         ! Low side cell:
         DO ISIDE=-1,0
            FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
            SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(CC_FTYPE_RGGAS) ! Regular cell
               DPVOL(I,J+1+ISIDE,K) = DPVOL(I,J+1+ISIDE,K) + FCT*KPDTDN * AF ! +ve or -ve dot
            CASE(CC_FTYPE_CFGAS) ! Cut-cell
               ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
               IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
               JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
               CUT_CELL(ICC)%DVOL(JCC) = CUT_CELL(ICC)%DVOL(JCC) + FCT*KPDTDN * AF ! +ve or -ve dot
            END SELECT
         ENDDO

      CASE(KAXIS)
         AF = DX(I)*DY(J)
         X1F= MESHES(NM)%Z(K)
         IDX = 1._EB / ( RC_FACE(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                         RC_FACE(IFACE)%XCEN(X1AXIS,LOW_IND) )
         ! Linear interpolation coefficients:
         CCM1 = IDX*(RC_FACE(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
         CCP1 = IDX*(X1F -RC_FACE(IFACE)%XCEN(X1AXIS,LOW_IND))

         TMPV(-1:0)  = TMP(I,J,K:K+1)
         DO ISIDE=-1,0
            ZZ_GET = 0._EB
            SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
               ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K+1+ISIDE,1:N_TRACKED_SPECIES)
            CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
               JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
               TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
               ZZ_GET(1:N_TRACKED_SPECIES) =  &
                      PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
               (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
            END SELECT
            ! KP on low-high side cells:
            CALL GET_CC_CELL_CONDUCTIVITY(ZZ_GET,MU(I,J,K+1+ISIDE),&
                                                   MU_DNS(I,J,K+1+ISIDE),TMPV(ISIDE),KPV(ISIDE))
         ENDDO

         KPDTDN = (CCM1*KPV(-1)+CCP1*KPV(0)) * (TMPV(0)-TMPV(-1)) * IDX

         ! Add contribution to DP:
         ! Low side cell:
         DO ISIDE=-1,0
            FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
            SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(CC_FTYPE_RGGAS) ! Regular cell
               DPVOL(I,J,K+1+ISIDE) = DPVOL(I,J,K+1+ISIDE) + FCT*KPDTDN * AF ! +ve or -ve dot
            CASE(CC_FTYPE_CFGAS) ! Cut-cell
               ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
               IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
               JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
               CUT_CELL(ICC)%DVOL(JCC) = CUT_CELL(ICC)%DVOL(JCC) + FCT*KPDTDN * AF ! +ve or -ve dot
            END SELECT
         ENDDO

   ENDSELECT

ENDDO

! GASPHASE cut-faces:
DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
   IF ( CUT_FACE(ICF)%STATUS /= CC_GASPHASE ) CYCLE
   IW = CUT_FACE(ICF)%IWC
   ! Note: for cut-faces open boundaries are dealt with below in external BC loops:
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I = CUT_FACE(ICF)%IJK(IAXIS)
   J = CUT_FACE(ICF)%IJK(JAXIS)
   K = CUT_FACE(ICF)%IJK(KAXIS)
   X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)
   SELECT CASE(X1AXIS)
   CASE(IAXIS)
      MUV(-1:0)    = MU(I:I+1,J,K)
      MU_DNSV(-1:0)= MU_DNS(I:I+1,J,K)
   CASE(JAXIS)
      MUV(-1:0)    = MU(I,J:J+1,K)
      MU_DNSV(-1:0)= MU_DNS(I,J:J+1,K)
   CASE(KAXIS)
      MUV(-1:0)    = MU(I,J,K:K+1)
      MU_DNSV(-1:0)= MU_DNS(I,J,K:K+1)
   END SELECT
   DO IFACE=1,CUT_FACE(ICF)%NFACE
      AF = CUT_FACE(ICF)%AREA(IFACE)
      X1F= CUT_FACE(ICF)%XYZCEN(X1AXIS,IFACE)
      IDX= 1._EB/ ( CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE) - &
                    CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE) )
      CCM1= IDX*(CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE)-X1F)
      CCP1= IDX*(X1F-CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE))
      ! Interpolate D_Z to the face, linear interpolation:
      TMPV(-1:0)  = -1._EB
      DO ISIDE=-1,0
         ZZ_GET = 0._EB
         SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
         CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
            ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
            JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
            TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
            ZZ_GET(1:N_TRACKED_SPECIES) =  &
                   PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
            (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
         END SELECT
         ! KP on low-high side cells:
         CALL GET_CC_CELL_CONDUCTIVITY(ZZ_GET,MUV(ISIDE),MU_DNSV(ISIDE),TMPV(ISIDE),KPV(ISIDE))
      ENDDO
      KPDTDN = (CCM1*KPV(-1)+CCP1*KPV(0)) * (TMPV(0)-TMPV(-1)) * IDX
      ! Add to divergence integral of surrounding cut-cells:
      DO ISIDE=-1,0
         FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
         SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
         CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
            ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
            IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
            JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
            CUT_CELL(ICC)%DVOL(JCC) = CUT_CELL(ICC)%DVOL(JCC) + FCT*KPDTDN * AF ! +ve or -ve dot
         END SELECT
      ENDDO
   ENDDO ! IFACE
ENDDO ! ICF

! Now do Boundary conditions for Conductive Heat Flux:
! IAXIS faces:
X1AXIS = IAXIS
DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
   IW = CC_REGFACE_IAXIS_Z(IFACE)%IWC; IF(IW<1) CYCLE
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE ! Already done on previous loops.
   WC => WALL(IW)
   B1 => BOUNDARY_PROP1(WC%B1_INDEX)
   BC => BOUNDARY_COORD(WC%BC_INDEX)
   IIG = BC%IIG
   JJG = BC%JJG
   KKG = BC%KKG
   AF  = DY(JJG)*DZ(KKG)
   ! Q_LEAK accounts for enthalpy moving through leakage paths
   DPVOL(IIG,JJG,KKG) = DPVOL(IIG,JJG,KKG) - ( B1%AREA_ADJUST*B1%Q_CON_F ) * AF  + B1%Q_LEAK * (DX(IIG)*DY(JJG)*DZ(KKG))
ENDDO

! JAXIS faces:
X1AXIS = JAXIS
DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
   IW = CC_REGFACE_JAXIS_Z(IFACE)%IWC; IF(IW<1) CYCLE
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE ! Already done on previous loops.
   WC => WALL(IW)
   B1 => BOUNDARY_PROP1(WC%B1_INDEX)
   BC => BOUNDARY_COORD(WC%BC_INDEX)
   IIG = BC%IIG
   JJG = BC%JJG
   KKG = BC%KKG
   AF  = DX(IIG)*DZ(KKG)
   ! Q_LEAK accounts for enthalpy moving through leakage paths
   DPVOL(IIG,JJG,KKG) = DPVOL(IIG,JJG,KKG) - ( B1%AREA_ADJUST*B1%Q_CON_F ) * AF  + B1%Q_LEAK * (DX(IIG)*DY(JJG)*DZ(KKG))
ENDDO

! KAXIS faces:
X1AXIS = KAXIS
DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
   IW = CC_REGFACE_KAXIS_Z(IFACE)%IWC; IF(IW<1) CYCLE
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE ! Already done on previous loops.
   WC => WALL(IW)
   B1 => BOUNDARY_PROP1(WC%B1_INDEX)
   BC => BOUNDARY_COORD(WC%BC_INDEX)
   IIG = BC%IIG
   JJG = BC%JJG
   KKG = BC%KKG
   AF  = DX(IIG)*DY(JJG)
   ! Q_LEAK accounts for enthalpy moving through leakage paths
   DPVOL(IIG,JJG,KKG) = DPVOL(IIG,JJG,KKG) - ( B1%AREA_ADJUST*B1%Q_CON_F ) * AF  + B1%Q_LEAK * (DX(IIG)*DY(JJG)*DZ(KKG))
ENDDO

! Regular faces connecting gasphase - cut-cells:
DO IFACE=1,MESHES(NM)%CC_NBBRCFACE_Z
   IW = RC_FACE(IFACE)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
   X1AXIS = RC_FACE(IFACE)%IJK(KAXIS+1)
   WC => WALL(IW)
   B1 => BOUNDARY_PROP1(WC%B1_INDEX)
   BC => BOUNDARY_COORD(WC%BC_INDEX)
   IIG = BC%IIG
   JJG = BC%JJG
   KKG = BC%KKG
   IOR = BC%IOR
   SELECT CASE(X1AXIS)
       CASE(IAXIS)
          AF=DY(JJG)*DZ(KKG)
       CASE(JAXIS)
          AF=DX(IIG)*DZ(KKG)
       CASE(KAXIS)
          AF=DX(IIG)*DY(JJG)
   END SELECT
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
   CASE(CC_FTYPE_RGGAS) ! Regular cell.
      ! Q_LEAK accounts for enthalpy moving through leakage paths
      DPVOL(IIG,JJG,KKG) = DPVOL(IIG,JJG,KKG) - ( B1%AREA_ADJUST*B1%Q_CON_F ) * AF  + B1%Q_LEAK * (DX(IIG)*DY(JJG)*DZ(KKG))
   CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
      ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
      IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
      JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
      CUT_CELL(ICC)%DVOL(JCC) = &
      CUT_CELL(ICC)%DVOL(JCC) - ( B1%AREA_ADJUST*B1%Q_CON_F ) * AF + B1%Q_LEAK * CUT_CELL(ICC)%VOLUME(JCC) ! Qconf +ve sign is
                                                                                                       ! outwards of cut-cell.
   END SELECT
ENDDO

! GASPHASE cut-faces:
DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
   IF ( CUT_FACE(ICF)%STATUS /= CC_GASPHASE .OR. MESHES(NM)%CUT_FACE(ICF)%IWC<1) CYCLE
   IW = MESHES(NM)%CUT_FACE(ICF)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE

   I = CUT_FACE(ICF)%IJK(IAXIS)
   J = CUT_FACE(ICF)%IJK(JAXIS)
   K = CUT_FACE(ICF)%IJK(KAXIS)
   X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)
   WC => WALL(IW)
   B1 => BOUNDARY_PROP1(WC%B1_INDEX)
   IOR = BOUNDARY_COORD(WC%BC_INDEX)%IOR
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   ! External boundary cut-cells of type OPEN_BOUNDARY:
   GASBOUND_IF : IF (WC%BOUNDARY_TYPE==OPEN_BOUNDARY) THEN
      FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
      DO IFACE=1,CUT_FACE(ICF)%NFACE
         SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
         CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
            AF = CUT_FACE(ICF)%AREA(IFACE)
            X1F= CUT_FACE(ICF)%XYZCEN(X1AXIS,IFACE)
            IF (IOR > 0) THEN
               IDX= 0.5_EB/(CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE)-X1F) ! Assumes DX twice the distance from WALL_CELL
                                                                      ! to internal cut-cell centroid.
            ELSE
               IDX= 0.5_EB/(X1F-CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE))
            ENDIF
            SELECT CASE(X1AXIS)
            CASE(IAXIS)
               MUV(-1:0)    =     MU(I:I+1,J,K)
               MU_DNSV(-1:0)= MU_DNS(I:I+1,J,K)
               KPV(-1:0)    =     MU(I:I+1,J,K)*CPOPR
               TMPV(-1:0)   =    TMP(I:I+1,J,K)
            CASE(JAXIS)
               MUV(-1:0)    =     MU(I,J:J+1,K)
               MU_DNSV(-1:0)= MU_DNS(I,J:J+1,K)
               KPV(-1:0)    =     MU(I,J:J+1,K)*CPOPR
               TMPV(-1:0)   =    TMP(I,J:J+1,K)
            CASE(KAXIS)
               MUV(-1:0)    =     MU(I,J,K:K+1)
               MU_DNSV(-1:0)= MU_DNS(I,J,K:K+1)
               KPV(-1:0)    =     MU(I,J,K:K+1)*CPOPR
               TMPV(-1:0)   =    TMP(I,J,K:K+1)
            END SELECT
            ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
            IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
            JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
            TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
            ZZ_GET(1:N_TRACKED_SPECIES) =  PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                                    (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
            CALL GET_CC_CELL_CONDUCTIVITY(ZZ_GET,MUV(ISIDE),MU_DNSV(ISIDE),TMPV(ISIDE),KPV(ISIDE))
            KPDTDN = 0.5_EB*(KPV(-1)+KPV(0)) * (TMPV(0)-TMPV(-1)) * IDX
            CUT_CELL(ICC)%DVOL(JCC) = CUT_CELL(ICC)%DVOL(JCC) + FCT*KPDTDN * AF ! +ve or -ve dot
         END SELECT
      ENDDO

   ELSE
      ! Other boundary conditions:
      DO IFACE=1,CUT_FACE(ICF)%NFACE
         AF = CUT_FACE(ICF)%AREA(IFACE)
         SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
         CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
            ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
            IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
            JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
            CUT_CELL(ICC)%DVOL(JCC) = &
            CUT_CELL(ICC)%DVOL(JCC) - ( B1%AREA_ADJUST*B1%Q_CON_F ) * AF + B1%Q_LEAK * CUT_CELL(ICC)%VOLUME(JCC) !Qconf +ve sgn
                                                                                                     ! is outwards of cut-cell.
         END SELECT
      ENDDO
   ENDIF GASBOUND_IF
ENDDO

! INBOUNDARY cut-faces, loop on CFACE to add BC defined at SOLID phase:
IF (PREDICTOR) THEN
  DO ICF=INTERNAL_CFACE_CELLS_LB+1,INTERNAL_CFACE_CELLS_LB+N_INTERNAL_CFACE_CELLS
     CFA  => CFACE(ICF)
     B1 => BOUNDARY_PROP1(CFA%B1_INDEX)
     IND1 = CFA%CUT_FACE_IND1;                         IND2 = CFA%CUT_FACE_IND2
     ICC  = CUT_FACE(IND1)%CELL_LIST(2,LOW_IND,IND2);  JCC  = CUT_FACE(IND1)%CELL_LIST(3,LOW_IND,IND2)
     CUT_CELL(ICC)%DVOL(JCC)=CUT_CELL(ICC)%DVOL(JCC)-( B1%AREA_ADJUST*B1%Q_CON_F ) * CUT_FACE(IND1)%AREA(IND2) !QCONF(+) into solid.
  ENDDO
ELSE
  DO ICF=INTERNAL_CFACE_CELLS_LB+1,INTERNAL_CFACE_CELLS_LB+N_INTERNAL_CFACE_CELLS
     CFA  => CFACE(ICF)
     B1 => BOUNDARY_PROP1(CFA%B1_INDEX)
     IND1 = CFA%CUT_FACE_IND1;                         IND2 = CFA%CUT_FACE_IND2
     ICC  = CUT_FACE(IND1)%CELL_LIST(2,LOW_IND,IND2);  JCC  = CUT_FACE(IND1)%CELL_LIST(3,LOW_IND,IND2)
     CUT_CELL(ICC)%DVOL(JCC)=CUT_CELL(ICC)%DVOL(JCC)-( B1%AREA_ADJUST*B1%Q_CON_F ) * CUT_FACE(IND1)%AREA(IND2) !QCONF(+) into solid.
  ENDDO
ENDIF

RETURN
END SUBROUTINE CC_CONDUCTION_HEAT_FLUX


END SUBROUTINE CC_DIVERGENCE_PART_1

! ------------------------ GET_CC_CELL_DIFFUSIVITY -------------------------

SUBROUTINE GET_CC_CELL_DIFFUSIVITY(RHO_CELL,D_Z_N,MU_CELL,MU_DNS_CELL,TMP_CELL,D_Z_TEMP)

USE MATH_FUNCTIONS, ONLY: INTERPOLATE1D_UNIFORM
USE MANUFACTURED_SOLUTIONS, ONLY: DIFF_MMS

REAL(EB), INTENT(IN) :: RHO_CELL,D_Z_N(0:I_MAX_TEMP),MU_CELL,MU_DNS_CELL,TMP_CELL
REAL(EB), INTENT(OUT):: D_Z_TEMP

REAL(EB) :: D_Z_TEMP_DNS

SELECT CASE(SIM_MODE)
CASE(LES_MODE)
   CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMP_CELL,D_Z_TEMP_DNS)
   D_Z_TEMP = D_Z_TEMP_DNS + MAX(0._EB,MU_CELL-MU_DNS_CELL)*RSC/RHO_CELL
CASE(DNS_MODE)
   IF(PERIODIC_TEST==7) THEN
      D_Z_TEMP = DIFF_MMS / RHO_CELL
   ELSE
      CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMP_CELL,D_Z_TEMP)
   ENDIF
CASE DEFAULT
   D_Z_TEMP = MU_CELL*RSC/RHO_CELL ! VLES
END SELECT

RETURN
END SUBROUTINE GET_CC_CELL_DIFFUSIVITY

! ----------------------- GET_CC_CELL_CONDUCTIVITY -------------------------

SUBROUTINE GET_CC_CELL_CONDUCTIVITY(ZZ_CELL,MU_CELL,MU_DNS_CELL,TMP_CELL,KP_CELL)

USE PHYSICAL_FUNCTIONS, ONLY: GET_CONDUCTIVITY,GET_SPECIFIC_HEAT

REAL(EB), INTENT(IN)  :: ZZ_CELL(1:N_TRACKED_SPECIES),MU_CELL,MU_DNS_CELL,TMP_CELL
REAL(EB), INTENT(OUT) :: KP_CELL

! Local Vars:
REAL(EB) :: CP_CELL

IF (SIM_MODE==DNS_MODE .OR. SIM_MODE==LES_MODE) THEN
   CALL GET_CONDUCTIVITY(ZZ_CELL,KP_CELL,TMP_CELL)
   IF (SIM_MODE==LES_MODE) THEN
      IF (.NOT.CONSTANT_SPECIFIC_HEAT_RATIO) THEN
         CALL GET_SPECIFIC_HEAT(ZZ_CELL,CP_CELL,TMP_CELL)
         KP_CELL = KP_CELL + MAX(0._EB,MU_CELL-MU_DNS_CELL)*CP_CELL*RPR
      ELSE
         KP_CELL = KP_CELL + MAX(0._EB,MU_CELL-MU_DNS_CELL)*CPOPR
      ENDIF
   ENDIF
ELSE ! VLES
   KP_CELL = MU_CELL*CPOPR
ENDIF

RETURN
END SUBROUTINE GET_CC_CELL_CONDUCTIVITY

! ----------------------- CC_DIFFUSIVE_MASS_FLUXES -------------------------

SUBROUTINE CC_DIFFUSIVE_MASS_FLUXES(NM)

INTEGER, INTENT(IN) :: NM

! NOTE: this routine assumes POINT_TO_MESH(NM) has been previously called.

! Local Variables:
INTEGER :: N,I,J,K,X1AXIS,ISIDE,IFACE,ICC,JCC,ICF
REAL(EB), POINTER, DIMENSION(:,:,:) :: RHOP=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: ZZP=>NULL()
REAL(EB) :: D_Z_N(0:I_MAX_TEMP),CCM1,CCP1,IDX,DIFF_FACE,D_Z_TEMP(-1:0),MUV(-1:0),MU_DNSV(-1:0), &
            RHOPV(-1:0),TMPV(-1:0),ZZPV(-1:0),X1F,PRFCT
REAL(EB), ALLOCATABLE, DIMENSION(:) :: ZZ_GET,RHO_D_DZDN_GET
INTEGER,  ALLOCATABLE, DIMENSION(:) :: N_ZZ_MAX_V
INTEGER :: N_LOOKUP, IW
REAL(EB) :: RHO_D_DZDN, ZZ_FACE, TMP_FACE

SELECT CASE(PREDICTOR)
   CASE(.TRUE.)
      ZZP => ZZS
      RHOP => RHOS
      PRFCT = 0._EB ! Use star cut-cell quantities.
   CASE(.FALSE.)
      ZZP => ZZ
      RHOP => RHO
      PRFCT = 1._EB ! Use end of step cut-cell quantities.
END SELECT

ALLOCATE(ZZ_GET(N_TRACKED_SPECIES),RHO_D_DZDN_GET(N_TRACKED_SPECIES))

! Define species index of max CFACE mass fraction.
ALLOCATE(N_ZZ_MAX_V(N_EXTERNAL_CFACE_CELLS+N_INTWALL_CFACE_CELLS+N_INTERNAL_CFACE_CELLS))
DO ICF=INTERNAL_CFACE_CELLS_LB+1,INTERNAL_CFACE_CELLS_LB+N_INTERNAL_CFACE_CELLS
   CFA => CFACE(ICF)
   B1 => BOUNDARY_PROP1(CFA%B1_INDEX)
   N_ZZ_MAX_V(ICF)=MAXLOC(B1%ZZ_F(1:N_TRACKED_SPECIES),1)
ENDDO

! 1. Diffusive Heat flux = - Grad dot (h_s rho D Grad Z_n):
! In FV form: use faces to add corresponding face integral terms, for face k
! (sum_a{h_{s,a} rho D_a Grad z_a) dot \hat{n}_k A_k, where \hat{n}_k is the versor outside of cell
! at face k.
DIFFUSIVE_FLUX_LOOP: DO N=1,N_TOTAL_SCALARS

   ! Diffusivity lookup table for species N:
   N_LOOKUP = N
   D_Z_N(:) = D_Z(:,N_LOOKUP)

   ! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
   DO IFACE=1,MESHES(NM)%CC_NRCFACE_Z

      IW = RC_FACE(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I      = RC_FACE(IFACE)%IJK(IAXIS)
      J      = RC_FACE(IFACE)%IJK(JAXIS)
      K      = RC_FACE(IFACE)%IJK(KAXIS)
      X1AXIS = RC_FACE(IFACE)%IJK(KAXIS+1)

      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            X1F= MESHES(NM)%X(I)
            IDX = 1._EB / ( RC_FACE(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                            RC_FACE(IFACE)%XCEN(X1AXIS,LOW_IND) )
            ! Linear interpolation coefficients:
            CCM1 = IDX*(RC_FACE(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
            CCP1 = IDX*(X1F -RC_FACE(IFACE)%XCEN(X1AXIS,LOW_IND))

            TMPV(-1:0)  = TMP(I:I+1,J,K)
            RHOPV(-1:0) = RHOP(I:I+1,J,K)
            ZZPV(-1:0)  = ZZP(I:I+1,J,K,N)
            DO ISIDE=-1,0
               SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
               CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
                  ! TMPV(ISIDE) = TMPV(ISIDE)
               CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
                  JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
                  TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
                  RHOPV(ISIDE)=        PRFCT *CUT_CELL(ICC)%RHO(JCC) + &
                                (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
                  ZZPV(ISIDE) =        PRFCT *CUT_CELL(ICC)%ZZ(N,JCC) + &
                                (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
               END SELECT
               CALL GET_CC_CELL_DIFFUSIVITY(RHOPV(ISIDE),D_Z_N,MU(I+1+ISIDE,J,K),&
                                                MU_DNS(I+1+ISIDE,J,K),TMPV(ISIDE),D_Z_TEMP(ISIDE))
            ENDDO

         CASE(JAXIS)
            X1F= MESHES(NM)%Y(J)
            IDX = 1._EB / ( RC_FACE(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                            RC_FACE(IFACE)%XCEN(X1AXIS,LOW_IND) )
            ! Linear interpolation coefficients:
            CCM1 = IDX*(RC_FACE(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
            CCP1 = IDX*(X1F -RC_FACE(IFACE)%XCEN(X1AXIS,LOW_IND))

            TMPV(-1:0)  = TMP(I,J:J+1,K)
            RHOPV(-1:0) = RHOP(I,J:J+1,K)
            ZZPV(-1:0)  = ZZP(I,J:J+1,K,N)
            DO ISIDE=-1,0
               SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
               CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
                  ! TMPV(ISIDE) = TMPV(ISIDE)
                  ! RHOPV(ISIDE)= RHOPV(ISIDE)
               CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
                  JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
                  TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
                  RHOPV(ISIDE)=        PRFCT *CUT_CELL(ICC)%RHO(JCC) + &
                                (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
                  ZZPV(ISIDE) =        PRFCT *CUT_CELL(ICC)%ZZ(N,JCC) + &
                                (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
               END SELECT
               CALL GET_CC_CELL_DIFFUSIVITY(RHOPV(ISIDE),D_Z_N,MU(I,J+1+ISIDE,K),&
                                                MU_DNS(I,J+1+ISIDE,K),TMPV(ISIDE),D_Z_TEMP(ISIDE))
            ENDDO

         CASE(KAXIS)
            X1F= MESHES(NM)%Z(K)
            IDX = 1._EB / ( RC_FACE(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                            RC_FACE(IFACE)%XCEN(X1AXIS,LOW_IND) )
            ! Linear interpolation coefficients:
            CCM1 = IDX*(RC_FACE(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
            CCP1 = IDX*(X1F -RC_FACE(IFACE)%XCEN(X1AXIS,LOW_IND))

            TMPV(-1:0)  = TMP(I,J,K:K+1)
            RHOPV(-1:0) = RHOP(I,J,K:K+1)
            ZZPV(-1:0)  = ZZP(I,J,K:K+1,N)
            DO ISIDE=-1,0
               SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
               CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
                  ! TMPV(ISIDE) = TMPV(ISIDE)
                  ! RHOPV(ISIDE)= RHOPV(ISIDE)
               CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
                  JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
                  TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
                  RHOPV(ISIDE)=        PRFCT *CUT_CELL(ICC)%RHO(JCC) + &
                                (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
                  ZZPV(ISIDE) =        PRFCT *CUT_CELL(ICC)%ZZ(N,JCC) + &
                                (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
               END SELECT
               CALL GET_CC_CELL_DIFFUSIVITY(RHOPV(ISIDE),D_Z_N,MU(I,J,K+1+ISIDE),&
                                                MU_DNS(I,J,K+1+ISIDE),TMPV(ISIDE),D_Z_TEMP(ISIDE))
            ENDDO

      ENDSELECT

      ! One Term defined flux:
      DIFF_FACE = CCM1*RHOPV(-1)*D_Z_TEMP(-1) + CCP1*RHOPV(0)*D_Z_TEMP(0)
      RC_FACE(IFACE)%RHO_D_DZDN(N) = DIFF_FACE*IDX*(ZZPV(0) - ZZPV(-1) ) ! + rho D_a Grad(Y_a)
      RC_FACE(IFACE)%ZZ_FACE(N) = CCM1*ZZPV(-1) + CCP1*ZZPV(0) ! Linear interpolation of ZZ to the face.
      RC_FACE(IFACE)%TMP_FACE = CCM1*TMPV(-1) + CCP1*TMPV(0)   ! Linear interpolation of Temp to the face.

   ENDDO


   ! GASPHASE cut-faces:
   DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH

      IF ( CUT_FACE(ICF)%STATUS /= CC_GASPHASE ) CYCLE
      IW = CUT_FACE(ICF)%IWC
      ! Note: for cut-faces open boundaries are dealt with below in external BC loops:
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I = CUT_FACE(ICF)%IJK(IAXIS)
      J = CUT_FACE(ICF)%IJK(JAXIS)
      K = CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)

      DO IFACE=1,CUT_FACE(ICF)%NFACE

         !AF = CUT_FACE(ICF)%AREA(IFACE)
         X1F= CUT_FACE(ICF)%XYZCEN(X1AXIS,IFACE)
         IDX= 1._EB/ ( CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE) - &
                       CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE) )
         CCM1= IDX*(CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE)-X1F)
         CCP1= IDX*(X1F-CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE))

         SELECT CASE (X1AXIS)
         CASE(IAXIS)
            MUV(-1:0)     =     MU(I:I+1,J,K)
            MU_DNSV(-1:0) = MU_DNS(I:I+1,J,K)
         CASE(JAXIS)
            MUV(-1:0)     =     MU(I,J:J+1,K)
            MU_DNSV(-1:0) = MU_DNS(I,J:J+1,K)
         CASE(KAXIS)
            MUV(-1:0)     =     MU(I,J,K:K+1)
            MU_DNSV(-1:0) = MU_DNS(I,J,K:K+1)
         END SELECT

         ! Interpolate D_Z to the face, linear interpolation:
         TMPV(-1:0)  = -1._EB; RHOPV(-1:0) = -1._EB; ZZPV(-1:0)  = -1._EB
         DO ISIDE=-1,0
            SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
            CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
               JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
               TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
               RHOPV(ISIDE)=        PRFCT *CUT_CELL(ICC)%RHO(JCC) + &
                             (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
               ZZPV(ISIDE) =        PRFCT *CUT_CELL(ICC)%ZZ(N,JCC) + &
                             (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
            END SELECT
            CALL GET_CC_CELL_DIFFUSIVITY(RHOPV(ISIDE),D_Z_N,MUV(ISIDE),MU_DNSV(ISIDE),TMPV(ISIDE),D_Z_TEMP(ISIDE))
         ENDDO

         ! One Term defined flux:
         DIFF_FACE = CCM1*RHOPV(-1)*D_Z_TEMP(-1) + CCP1*RHOPV(0)*D_Z_TEMP(0)
         CUT_FACE(ICF)%RHO_D_DZDN(N,IFACE) = DIFF_FACE*IDX*(ZZPV(0) - ZZPV(-1) ) ! rho D_a Grad(Y_a)
         CUT_FACE(ICF)%ZZ_FACE(N,IFACE) = CCM1*ZZPV(-1) + CCP1*ZZPV(0) ! Linear interpolation of ZZ to the face.
         CUT_FACE(ICF)%TMP_FACE(IFACE)  = CCM1*TMPV(-1) + CCP1*TMPV(0) ! Linear interpolation of TMP to the face.

      ENDDO ! IFACE

   ENDDO ! ICF

   ! Now Boundary Conditions:
   ! CFACES:
   ISIDE=-1
   CFACE_LOOP : DO ICF=INTERNAL_CFACE_CELLS_LB+1,INTERNAL_CFACE_CELLS_LB+N_INTERNAL_CFACE_CELLS
      CFA => CFACE(ICF)
      B1 => BOUNDARY_PROP1(CFA%B1_INDEX)
      ! Use external Gas point data for ZZ_G estimation, consistent with CFA%B1%RDN in the finite difference.
      ! Flux fixing done here for CFACEs:
      RHO_D_DZDN = 2._EB*B1%RHO_D_F(N)*(B1%ZZ_G(N)-B1%ZZ_F(N))*B1%RDN
      IF (N==N_ZZ_MAX_V(ICF)) THEN
         ZZ_GET(1:N_TRACKED_SPECIES) = B1%ZZ_G(1:N_TRACKED_SPECIES)
         RHO_D_DZDN_GET(1:N_TRACKED_SPECIES) = &
         2._EB*B1%RHO_D_F(1:N_TRACKED_SPECIES)*( ZZ_GET(1:N_TRACKED_SPECIES) - B1%ZZ_F(1:N_TRACKED_SPECIES))*B1%RDN
         RHO_D_DZDN = -(SUM(RHO_D_DZDN_GET(1:N_TRACKED_SPECIES))-RHO_D_DZDN)
      ENDIF
      B1%RHO_D_DZDN_F(N) = RHO_D_DZDN

      ! Now add variables from CFACES to INBOUNDARY cut-faces containers:
      CUT_FACE(CFA%CUT_FACE_IND1)%RHO_D_DZDN(N,CFA%CUT_FACE_IND2) = RHO_D_DZDN
      CUT_FACE(CFA%CUT_FACE_IND1)%ZZ_FACE(N,   CFA%CUT_FACE_IND2) = B1%ZZ_F(N)
      CUT_FACE(CFA%CUT_FACE_IND1)%TMP_FACE(    CFA%CUT_FACE_IND2) = B1%TMP_F
   ENDDO CFACE_LOOP

   ! Mesh Boundaries:
   ! Regular Faces:
   ! For Regular Faces connecting regular cells we use the WALL_CELL array to fill RHO_D_DZDN, in the same way as
   ! done in WALL_LOOP_2 of DIVERGENCE_PART_1 (divg.f90):
   ! IAXIS faces:
   X1AXIS = IAXIS
   DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
      IW = CC_REGFACE_IAXIS_Z(IFACE)%IWC; IF(IW<1) CYCLE
      IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE ! Already done on previous loops.
      CALL GET_BBREGFACE_RHO_D_DZDN
      ! NOTE: Boundary condition diffusive mass fluxes are already made realizable:
      CC_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N) = RHO_D_DZDN ! Use single value of RHO_D_DZDN
   ENDDO

   ! JAXIS faces:
   X1AXIS = JAXIS
   DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
      IW = CC_REGFACE_JAXIS_Z(IFACE)%IWC; IF(IW<1) CYCLE
      IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
      CALL GET_BBREGFACE_RHO_D_DZDN
      ! NOTE: Boundary condition diffusive mass fluxes are already made realizable:
      CC_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N) = RHO_D_DZDN ! Use single value of RHO_D_DZDN
   ENDDO

   ! KAXIS faces:
   X1AXIS = KAXIS
   DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
      IW = CC_REGFACE_KAXIS_Z(IFACE)%IWC; IF(IW<1) CYCLE
      IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
      CALL GET_BBREGFACE_RHO_D_DZDN
      ! NOTE: Boundary condition diffusive mass fluxes are already made realizable:
      CC_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N) = RHO_D_DZDN ! Use single value of RHO_D_DZDN
   ENDDO

   ! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
   DO IFACE=1,MESHES(NM)%CC_NBBRCFACE_Z
      IW = MESHES(NM)%RC_FACE(IFACE)%IWC
      IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
      I      = RC_FACE(IFACE)%IJK(IAXIS)
      J      = RC_FACE(IFACE)%IJK(JAXIS)
      K      = RC_FACE(IFACE)%IJK(KAXIS)
      X1AXIS = RC_FACE(IFACE)%IJK(KAXIS+1)
      CALL GET_BBRCFACE_RHO_D_DZDN
      RC_FACE(IFACE)%RHO_D_DZDN(N) = RHO_D_DZDN
      RC_FACE(IFACE)%ZZ_FACE(N)   = ZZ_FACE
      RC_FACE(IFACE)%TMP_FACE     = TMP_FACE
   ENDDO

   ! GASPHASE cut-faces:
   ! In case of Cut Faces and OPEN boundaries redefine the location of the guard cells with atmospheric conditions:
   DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
      IF ( CUT_FACE(ICF)%STATUS /= CC_GASPHASE .OR. MESHES(NM)%CUT_FACE(ICF)%IWC<1) CYCLE
      IW = MESHES(NM)%CUT_FACE(ICF)%IWC
      IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE

      I = CUT_FACE(ICF)%IJK(IAXIS)
      J = CUT_FACE(ICF)%IJK(JAXIS)
      K = CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)

      ! External boundary cut-cells of type OPEN_BOUNDARY:
      GASBOUND_IF : IF(WALL(IW)%BOUNDARY_TYPE==OPEN_BOUNDARY) THEN
         ! Run over local cut-faces:
         DO IFACE=1,CUT_FACE(ICF)%NFACE
            X1F= CUT_FACE(ICF)%XYZCEN(X1AXIS,IFACE)
            IF (BOUNDARY_COORD(WALL(IW)%BC_INDEX)%IOR > 0) THEN
               IDX= 0.5_EB/(CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE)-X1F) ! Assumes DX twice the distance from WALL_CELL to
                                                                      ! internal cut-cell centroid.
            ELSE
               IDX= 0.5_EB/(X1F-CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE))
            ENDIF
            CCM1= 0.5_EB; CCP1= 0.5_EB
            SELECT CASE (X1AXIS)
            CASE(IAXIS)
               MUV(-1:0)       =     MU(I:I+1,J,K)
               MU_DNSV(-1:0)   = MU_DNS(I:I+1,J,K)
               TMPV(-1:0)      =    TMP(I:I+1,J,K)
               RHOPV(-1:0)     =   RHOP(I:I+1,J,K)
               ZZPV(-1:0)      =    ZZP(I:I+1,J,K,N)
            CASE(JAXIS)
               MUV(-1:0)       =     MU(I,J:J+1,K)
               MU_DNSV(-1:0)   = MU_DNS(I,J:J+1,K)
               TMPV(-1:0)      =    TMP(I,J:J+1,K)
               RHOPV(-1:0)     =   RHOP(I,J:J+1,K)
               ZZPV(-1:0)      =    ZZP(I,J:J+1,K,N)
            CASE(KAXIS)
               MUV(-1:0)       =     MU(I,J,K:K+1)
               MU_DNSV(-1:0)   = MU_DNS(I,J,K:K+1)
               TMPV(-1:0)      =    TMP(I,J,K:K+1)
               RHOPV(-1:0)     =   RHOP(I,J,K:K+1)
               ZZPV(-1:0)      =    ZZP(I,J,K:K+1,N)
            END SELECT
            ! Interpolate D_Z to the face, linear interpolation:
            DO ISIDE=-1,0
               SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
               CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
                  JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
                  TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
                  RHOPV(ISIDE)=        PRFCT *CUT_CELL(ICC)%RHO(JCC) + &
                                (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
                  ZZPV(ISIDE) =        PRFCT *CUT_CELL(ICC)%ZZ(N,JCC) + &
                                (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
               END SELECT
               CALL GET_CC_CELL_DIFFUSIVITY(RHOPV(ISIDE),D_Z_N,MUV(ISIDE),&
                                                MU_DNSV(ISIDE),TMPV(ISIDE),D_Z_TEMP(ISIDE))
            ENDDO

            ! One Term defined flux:
            DIFF_FACE = CCM1*RHOPV(-1)*D_Z_TEMP(-1) + CCP1*RHOPV(0)*D_Z_TEMP(0)
            CUT_FACE(ICF)%RHO_D_DZDN(N,IFACE) = DIFF_FACE*IDX*(ZZPV(0) - ZZPV(-1) ) ! rho D_a Grad(Y_a)
            CUT_FACE(ICF)%ZZ_FACE(N,IFACE) = CCM1*ZZPV(-1) + CCP1*ZZPV(0) ! Linear interpolation of ZZ to the face.
            CUT_FACE(ICF)%TMP_FACE(IFACE)  = CCM1*TMPV(-1) + CCP1*TMPV(0) ! Linear interpolation of TMP to the face.

         ENDDO ! IFACE

      ELSE

         ! Other boundary conditions:
         DO IFACE=1,CUT_FACE(ICF)%NFACE
            CALL GET_BBCUTFACE_RHO_D_DZDN
            CUT_FACE(ICF)%RHO_D_DZDN(N,IFACE) = RHO_D_DZDN
            CUT_FACE(ICF)%ZZ_FACE(N,IFACE) = ZZ_FACE
            CUT_FACE(ICF)%TMP_FACE(IFACE)  = TMP_FACE
         ENDDO

      ENDIF GASBOUND_IF

   ENDDO ! ICF

   ! Finally INBOUNDARY cut-faces, compute RHO_D_DZDN using CFACES:
   ! TO DO.

   ! Finally EXIM faces -> we use RHO_D_DZDX,Y,Z previously defined on divg.f90:
   ! No need to do anything on this initial DIFFUSIVE_FLUX_LOOP, as consistency already enforced
   ! on divg.f90.

ENDDO DIFFUSIVE_FLUX_LOOP

DEALLOCATE(ZZ_GET,RHO_D_DZDN_GET,N_ZZ_MAX_V)

RETURN

CONTAINS

SUBROUTINE GET_BBREGFACE_RHO_D_DZDN

INTEGER :: IIG, JJG, KKG, IOR, N_ZZ_MAX
REAL(EB) :: RHO_D_DZDN_GET(1:N_TRACKED_SPECIES)
WC => WALL(IW)
B1 => BOUNDARY_PROP1(WC%B1_INDEX)
BC => BOUNDARY_COORD(WC%BC_INDEX)
IIG = BC%IIG
JJG = BC%JJG
KKG = BC%KKG
IOR = BC%IOR
N_ZZ_MAX = MAXLOC(B1%ZZ_F(1:N_TRACKED_SPECIES),1)
RHO_D_DZDN = 2._EB*B1%RHO_D_F(N)*(ZZP(IIG,JJG,KKG,N)-B1%ZZ_F(N))*B1%RDN
IF (N==N_ZZ_MAX) THEN
   RHO_D_DZDN_GET = 2._EB*B1%RHO_D_F(:)*(ZZP(IIG,JJG,KKG,:)-B1%ZZ_F(:))*B1%RDN
   RHO_D_DZDN = -(SUM(RHO_D_DZDN_GET(:))-RHO_D_DZDN)
ENDIF

IF (IOR < 0) RHO_D_DZDN = -RHO_D_DZDN ! This is to switch the sign of the spatial derivative in high side boundaries.

END SUBROUTINE GET_BBREGFACE_RHO_D_DZDN

SUBROUTINE GET_BBRCFACE_RHO_D_DZDN

INTEGER :: IIG, JJG, KKG, IOR, N_ZZ_MAX
REAL(EB) :: ZZ_G, ZZ_GV(1:N_TRACKED_SPECIES),RHO_D_DZDN_GET(1:N_TRACKED_SPECIES)

WC => WALL(IW)
B1 => BOUNDARY_PROP1(WC%B1_INDEX)
BC => BOUNDARY_COORD(WC%BC_INDEX)
IIG = BC%IIG
JJG = BC%JJG
KKG = BC%KKG
IOR = BC%IOR
! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
!                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
ISIDE = -1 + (SIGN(1,IOR)+1) / 2
SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
CASE(CC_FTYPE_RGGAS) ! Regular cell.
   ZZ_G = ZZP(IIG,JJG,KKG,N)
   ZZ_GV(1:N_TRACKED_SPECIES)= ZZP(IIG,JJG,KKG,1:N_TRACKED_SPECIES)
CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
   ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
   JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
   ZZ_G =               PRFCT *CUT_CELL(ICC)%ZZ(N,JCC) + &
                 (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
   ZZ_GV(1:N_TRACKED_SPECIES)= PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                        (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
END SELECT

SELECT CASE(X1AXIS)
    CASE(IAXIS)
       X1F= MESHES(NM)%X(I)
    CASE(JAXIS)
       X1F= MESHES(NM)%Y(J)
    CASE(KAXIS)
       X1F= MESHES(NM)%Z(K)
END SELECT

IF (IOR > 0) THEN !Cell or cutcell on high side of RC face:
   IDX = 1._EB / (RC_FACE(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
ELSE
   IDX = 1._EB / (X1F-RC_FACE(IFACE)%XCEN(X1AXIS, LOW_IND))
ENDIF

N_ZZ_MAX = MAXLOC(B1%ZZ_F(1:N_TRACKED_SPECIES),1)
RHO_D_DZDN = B1%RHO_D_F(N)*(ZZ_G-B1%ZZ_F(N))*IDX
IF (N==N_ZZ_MAX) THEN
   RHO_D_DZDN_GET = B1%RHO_D_F(:)*(ZZ_GV(:)-B1%ZZ_F(:))*IDX
   RHO_D_DZDN = -(SUM(RHO_D_DZDN_GET(:))-RHO_D_DZDN)
ENDIF

IF (IOR < 0) RHO_D_DZDN = -RHO_D_DZDN ! This is to switch the sign of the spatial derivative in high side boundaries.
DIFF_FACE = B1%RHO_D_F(N)/B1%RHO_F
ZZ_FACE   = B1%ZZ_F(N)
TMP_FACE  = B1%TMP_F

END SUBROUTINE GET_BBRCFACE_RHO_D_DZDN


SUBROUTINE GET_BBCUTFACE_RHO_D_DZDN

INTEGER :: IOR, N_ZZ_MAX
REAL(EB) :: ZZ_G, ZZ_GV(1:N_TRACKED_SPECIES),RHO_D_DZDN_GET(1:N_TRACKED_SPECIES)

WC => WALL(IW)
B1 => BOUNDARY_PROP1(WC%B1_INDEX)
IOR = BOUNDARY_COORD(WC%BC_INDEX)%IOR

X1F= CUT_FACE(ICF)%XYZCEN(X1AXIS,IFACE)
IF (IOR > 0) THEN
   IDX= 1._EB/(CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE)-X1F)
ELSE
   IDX= 1._EB/(X1F-CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE))
ENDIF
! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
!                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
ISIDE = -1 + (SIGN(1,IOR)+1) / 2
SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
   ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
   JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
   ZZ_G =               PRFCT *CUT_CELL(ICC)%ZZ(N,JCC) + &
                 (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
   ZZ_GV(1:N_TRACKED_SPECIES)= PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                        (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
END SELECT

N_ZZ_MAX = MAXLOC(B1%ZZ_F(1:N_TRACKED_SPECIES),1)
RHO_D_DZDN = B1%RHO_D_F(N)*(ZZ_G-B1%ZZ_F(N))*IDX
IF (N==N_ZZ_MAX) THEN
   RHO_D_DZDN_GET = B1%RHO_D_F(:)*(ZZ_GV(:)-B1%ZZ_F(:))*IDX
   RHO_D_DZDN = -(SUM(RHO_D_DZDN_GET(:))-RHO_D_DZDN)
ENDIF

IF (IOR < 0) RHO_D_DZDN = -RHO_D_DZDN ! This is to switch the sign of the spatial derivative in high side boundaries.
DIFF_FACE = B1%RHO_D_F(N)/B1%RHO_F
ZZ_FACE   = B1%ZZ_F(N)
TMP_FACE  = B1%TMP_F

END SUBROUTINE GET_BBCUTFACE_RHO_D_DZDN

END SUBROUTINE CC_DIFFUSIVE_MASS_FLUXES


! ------------------------------ CC_DENSITY -------------------------------

SUBROUTINE CC_DENSITY(T,DT)

USE PHYSICAL_FUNCTIONS, ONLY : GET_SPECIFIC_GAS_CONSTANT
USE MATH_FUNCTIONS, ONLY : EVALUATE_RAMP
USE MPI_F08

REAL(EB), INTENT(IN) :: T,DT

! Local Variables:
INTEGER :: N
INTEGER :: I,J,K,NM,ICC,JCC
REAL(EB) :: ZZ_GET(1:N_TRACKED_SPECIES),VCCELL,TNOW,PBAR_K
! CHARACTER(len=20) :: filename
! LOGICAL, SAVE :: FIRST_CALL = .TRUE.
!

! Dummy on T:
TNOW = T

IF (SOLID_PHASE_ONLY) RETURN

TNOW = CURRENT_TIME()

SELECT CASE (PERIODIC_TEST)
   CASE DEFAULT
      IF (ICYC<=1) RETURN ! In order to avoid instabilities due to unphysical initial flow fields.
   CASE (5,8)
      RETURN
   CASE (4,7,11,21,22)
      ! CONTINUE
END SELECT

! Advance scalars and density, sanitize results if needed:
CALL CC_DENSITY_EXPLICIT(T,DT)

! Compute molecular weight term RSUM=R0*SUM(Y_i/W_i). Here WBAR=1/SUM(Y_i/W_i).
! Compute temperature in regular and cut-cells, from equation of state:
IF (PREDICTOR) THEN

   MESHES_LOOP1 : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      CALL POINT_TO_MESH(NM)

      ! First Regular Cells:
      ! Compute molecular weight term RSUM=R0*SUM(Y_i/W_i).
      ! Extract predicted temperature at next time step from Equation of State
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
               ZZ_GET(1:N_TRACKED_SPECIES) = ZZS(I,J,K,1:N_TRACKED_SPECIES)
               CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,RSUM(I,J,K))
               PBAR_K = PBAR_S(K,PRESSURE_ZONE(I,J,K)) - P_0(K) + P_0_CV(CCVAR(I,J,K,CC_UNKZ)-UNKZ_IND(NM_START))
               TMP(I,J,K) = PBAR_K/(RSUM(I,J,K)*RHOS(I,J,K))
            ENDDO
         ENDDO
      ENDDO

      ! Store RHO*ZZ values at step n:
      IF (.NOT.ALLOCATED(MESHES(NM)%RHO_ZZN)) ALLOCATE(MESHES(NM)%RHO_ZZN(0:IBP1,0:JBP1,0:KBP1,N_TOTAL_SCALARS))
      DO N=1,N_TOTAL_SCALARS
         MESHES(NM)%RHO_ZZN(:,:,:,N) = RHO(:,:,:)*ZZ(:,:,:,N)
      ENDDO

      ! Second cut-cells, these variables being filled are only used for exporting to slices and applying Boundary
      ! conditions on external walls other than NULL or INTERPOLATED in WALL_BC (wall.f90):
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         CC => CUT_CELL(ICC); IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
         I  = CC%IJK(IAXIS); J = CC%IJK(JAXIS); K = CC%IJK(KAXIS)
         VCCELL = 0._EB; TMP(I,J,K)=0._EB; RHOS(I,J,K)=0._EB; ZZS(I,J,K,1:N_TRACKED_SPECIES)=0._EB; RSUM(I,J,K)=0._EB
         DO JCC=1,CC%NCELL
            ! Compute molecular weight term RSUM=R0*SUM(Y_i/W_i).
            ZZ_GET(1:N_TRACKED_SPECIES) = CC%ZZS(1:N_TRACKED_SPECIES,JCC)
            CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,CC%RSUM(JCC))
            ! Extract predicted temperature at next time step from Equation of State
            ! Use for pressure the height of the underlying cartesian cell centroid:
            PBAR_K = PBAR_S(K,PRESSURE_ZONE(I,J,K)) - P_0(K) + P_0_CV(CC%UNKZ(JCC)-UNKZ_IND(NM_START))
            CC%TMP(JCC) = PBAR_K/(CC%RSUM(JCC)*CC%RHOS(JCC))
            TMP(I,J,K) = TMP(I,J,K) + CC%TMP(JCC)*CC%VOLUME(JCC)
            RHOS(I,J,K)= RHOS(I,J,K)+ CC%RHOS(JCC)*CC%VOLUME(JCC)
            ZZS(I,J,K,1:N_TRACKED_SPECIES) = ZZS(I,J,K,1:N_TRACKED_SPECIES) + ZZ_GET(1:N_TRACKED_SPECIES)*CC%VOLUME(JCC)
            RSUM(I,J,K)= RSUM(I,J,K)+ CC%RSUM(JCC)*CC%VOLUME(JCC)

            VCCELL = VCCELL + CC%VOLUME(JCC)
         ENDDO

         ! Volume average cell variables to underlying cell:
         TMP(I,J,K) = TMP(I,J,K)/VCCELL
         RHOS(I,J,K)= RHOS(I,J,K)/VCCELL
         ZZS(I,J,K,1:N_TRACKED_SPECIES)=ZZS(I,J,K,1:N_TRACKED_SPECIES)/VCCELL
         RSUM(I,J,K)=RSUM(I,J,K)/VCCELL

      ENDDO

      ! Finally set to ambient temperature the temp of SOLID cells:
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (CCVAR(I,J,K,CC_CGSC) /= CC_SOLID) CYCLE
               TMP(I,J,K) = TMPA
            ENDDO
         ENDDO
      ENDDO

   ENDDO MESHES_LOOP1

ELSE ! CORRECTOR

   MESHES_LOOP2 : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      CALL POINT_TO_MESH(NM)

      ! Compute molecular weight term RSUM=R0*SUM(Y_i/W_i)
      ! Extract predicted temperature at next time step from Equation of State
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
               ZZ_GET(1:N_TRACKED_SPECIES) = ZZ(I,J,K,1:N_TRACKED_SPECIES)
               CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,RSUM(I,J,K))
               PBAR_K = PBAR(K,PRESSURE_ZONE(I,J,K)) - P_0(K) + P_0_CV(CCVAR(I,J,K,CC_UNKZ)-UNKZ_IND(NM_START))
               TMP(I,J,K) = PBAR_K/(RSUM(I,J,K)*RHO(I,J,K))
            ENDDO
         ENDDO
      ENDDO

      ! Second cut-cells, these variables being filled are only used for exporting to slices and applying Boundary
      ! conditions on external walls other than NULL or INTERPOLATED in WALL_BC (wall.f90):
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         CC => CUT_CELL(ICC); IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
         I  = CC%IJK(IAXIS); J = CC%IJK(JAXIS); K = CC%IJK(KAXIS)
         VCCELL = 0._EB; TMP(I,J,K)=0._EB; RHO(I,J,K)=0._EB; ZZ(I,J,K,1:N_TRACKED_SPECIES)=0._EB; RSUM(I,J,K)=0._EB
         DO JCC=1,CC%NCELL
            ! Compute molecular weight term RSUM=R0*SUM(Y_i/W_i).
            ZZ_GET(1:N_TRACKED_SPECIES) = CC%ZZ(1:N_TRACKED_SPECIES,JCC)
            CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,CC%RSUM(JCC))
            ! Extract predicted temperature at next time step from Equation of State
            ! Use for pressure the height of the underlying cartesian cell centroid:
            PBAR_K = PBAR(K,PRESSURE_ZONE(I,J,K)) - P_0(K) + P_0_CV(CC%UNKZ(JCC)-UNKZ_IND(NM_START))
            CC%TMP(JCC) = PBAR_K/(CC%RSUM(JCC)*CC%RHO(JCC))
            TMP(I,J,K) = TMP(I,J,K) + CC%TMP(JCC)*CC%VOLUME(JCC)
            RHO(I,J,K) = RHO(I,J,K) + CC%RHO(JCC)*CC%VOLUME(JCC)
            ZZ(I,J,K,1:N_TRACKED_SPECIES) = ZZ(I,J,K,1:N_TRACKED_SPECIES) + ZZ_GET(1:N_TRACKED_SPECIES)*CC%VOLUME(JCC)
            RSUM(I,J,K)= RSUM(I,J,K)+ CC%RSUM(JCC)*CC%VOLUME(JCC)

            VCCELL = VCCELL + CC%VOLUME(JCC)

         ENDDO

         ! Volume average cell variables to underlying cell:
         TMP(I,J,K) = TMP(I,J,K)/VCCELL
         RHO(I,J,K) = RHO(I,J,K)/VCCELL
         ZZ(I,J,K,1:N_TRACKED_SPECIES)=ZZ(I,J,K,1:N_TRACKED_SPECIES)/VCCELL
         RSUM(I,J,K)=RSUM(I,J,K)/VCCELL

      ENDDO

      ! Finally set to ambient temperature the temp of SOLID cells:
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (CCVAR(I,J,K,CC_CGSC) /= CC_SOLID) CYCLE
               TMP(I,J,K) = TMPA
            ENDDO
         ENDDO
      ENDDO

   ENDDO MESHES_LOOP2

ENDIF ! PREDICTOR

T_USED(14) = T_USED(14) + CURRENT_TIME() - TNOW
IF (TIME_CC_IBM) T_CC_USED(CC_DENSITY_TIME_INDEX) = T_CC_USED(CC_DENSITY_TIME_INDEX) + CURRENT_TIME() - TNOW
RETURN
END SUBROUTINE CC_DENSITY

! ----------------------------- CC_DENSITY_EXPLICIT ------------------------

SUBROUTINE CC_DENSITY_EXPLICIT(T,DT)

REAL(EB), INTENT(IN) :: T,DT

! Local variables:
INTEGER :: N
INTEGER :: IROW_LOC
REAL(EB):: DUMMYT

! Just to avoid compilation warnings: T might be used to define a time dependent source.
DUMMYT = T

! Loop through species:
! This loop performs an either implicit or explicit time advancement of the transport equations for each
! chemical species on the cut-cell implicit region, plus explicit reaction (as done on FDS).
! Scalar bounds are checked on the implicit region regular and cut-cells:
SPECIES_LOOP: DO N=1,N_TOTAL_SCALARS

   IF( (PREDICTOR.AND.FIRST_PASS) .OR. CORRECTOR) THEN
      ! RHS vector (Adv+diff)*zz+F_BC, derived from boundary conditions on immersed and domain Boundaries:
      F_Z(:) = 0._EB
      CALL GET_EXPLICIT_ADVDIFFVECTOR_SCALAR_3D(N)

      ! Add Advective fluxes for F_Z:
      CALL GET_ADVDIFFVECTOR_SCALAR_3D(N)

      ! Here add the reaction source term M_DOT_PPP, treated explicitly:
      CALL GET_M_DOT_PPP_SCALAR_3D(N)

      IF (PERIODIC_TEST==7) CALL GET_SHUNN3_QZ(T,N)
      IF (PERIODIC_TEST==21 .OR. PERIODIC_TEST==22 .OR. PERIODIC_TEST==23) CALL CC_ROTATED_CUBE_RHS_ZZ(T,N)

      ! Get rho*zz vector at step n:
      CALL GET_RHOZZVECTOR_SCALAR_3D(N)
   ENDIF

   IF (PREDICTOR) THEN
      IF (FIRST_PASS) THEN
         F_Z0(:,N) = F_Z(:)
         RZ_Z0(:,N) = RZ_Z(:)
      ELSE
         F_Z(:) = F_Z0(:,N)
         RZ_Z(:)= RZ_Z0(:,N)
      ENDIF
   ENDIF

   IF (PREDICTOR) THEN

      ! Here F_Z: (Adv+Diff)*(rho z)^n + F^n
      ! Advance with Explicit Euler: RZ_Z = RZ_Z - DT*M_MAT_Z^-1*F_Z: where initially
      ! RZ_Z = (rho z)^n, filled in GET_RHOZZVECTOR_SCALAR_3D
      DO IROW_LOC=1,NUNKZ_LOCAL
         RZ_Z(IROW_LOC) = RZ_Z(IROW_LOC) - DT * F_Z(IROW_LOC) / M_MAT_Z(IROW_LOC)
      ENDDO

   ELSE ! CORRECTOR

      ! Here F_Z: (Adv+Diff)*(rho z)^* + F^*
      ! Advance with Corrector SSPRK2: RZ_Z = RZ_Z - DT/2*M_MAT_Z^-1*F_Z: where initially
      ! RZ_Z = 1/2*((rho z)^n + (rho z)^*)
      DO IROW_LOC=1,NUNKZ_LOCAL
         RZ_Z(IROW_LOC) = RZ_Z(IROW_LOC) - 0.5_EB * DT * F_Z(IROW_LOC) / M_MAT_Z(IROW_LOC)
      ENDDO

   ENDIF

   ! Copy back to RHOZZP and CUT_CELL:
   CALL PUT_RHOZZVECTOR_SCALAR_3D(N)

ENDDO SPECIES_LOOP

! Redistribute densities if needed.
CALL CC_CHECK_MASS_DENSITY

! Recompute RHOP, and check for positivity, define mass fraction ZZ and clip if necessary:
CALL GET_RHOZZ_CC_3D

RETURN
END SUBROUTINE CC_DENSITY_EXPLICIT

! ---------------------------- GET_M_DOT_PPP_SCALAR_3D ---------------------------

SUBROUTINE GET_M_DOT_PPP_SCALAR_3D(N)

INTEGER, INTENT(IN) :: N

! Local Variables:
INTEGER :: NM,I,J,K,IROW,ICC,JCC,NCELL

! Mesh Loop:
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   ! D_SOURCE(:,:,:) and M_DOT_PPP(:,:,:,:) are allocated together,
   ! => if one is not allocated the other also is not allocated.
   IF(.NOT.ALLOCATED(MESHES(NM)%D_SOURCE)) CYCLE MESH_LOOP

   CALL POINT_TO_MESH(NM)

   ! First add M_DOT_PPP on regular cells to source F_Z:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE ! Cycle Reg cells not implicit, cut-cells
                                                  ! underlying Cartesian cells and
                                                  ! solid cells.
            IROW = CCVAR(I,J,K,CC_UNKZ) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
            F_Z(IROW) = F_Z(IROW) - M_DOT_PPP(I,J,K,N)*DX(I)*DY(J)*DZ(K)
         ENDDO
      ENDDO
   ENDDO

   ! Then add Cut-cell contributions to F_Z:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      IF (CELL(CELL_INDEX(CUT_CELL(ICC)%IJK(IAXIS),CUT_CELL(ICC)%IJK(JAXIS),CUT_CELL(ICC)%IJK(KAXIS)))%SOLID) CYCLE
      NCELL=CUT_CELL(ICC)%NCELL
      DO JCC=1,NCELL
         IROW = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
         F_Z(IROW) = F_Z(IROW) - CUT_CELL(ICC)%M_DOT_PPP(N,JCC)*CUT_CELL(ICC)%VOLUME(JCC)
      ENDDO
   ENDDO

   ! Finally if Corrector zero out M_DOT_PPP and D_SOURCE:
   IF (CORRECTOR) THEN
      M_DOT_PPP(:,:,:,N) = 0._EB
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         NCELL=CUT_CELL(ICC)%NCELL
         CUT_CELL(ICC)%M_DOT_PPP(N,1:NCELL) = 0._EB
      ENDDO
      IF (N == N_TOTAL_SCALARS) THEN
         D_SOURCE(:,:,:)  = 0._EB
         DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
            NCELL=CUT_CELL(ICC)%NCELL
            CUT_CELL(ICC)%D_SOURCE(1:NCELL) = 0._EB
         ENDDO
      ENDIF
   ENDIF

ENDDO MESH_LOOP

RETURN
END SUBROUTINE GET_M_DOT_PPP_SCALAR_3D

! ---------------------- GET_EXPLICIT_ADVDIFFVECTOR_SCALAR_3D --------------------

SUBROUTINE GET_EXPLICIT_ADVDIFFVECTOR_SCALAR_3D(N)

INTEGER, INTENT(IN) :: N

! Local Variables:
INTEGER :: NM,I,J,K
REAL(EB):: PRFCT
INTEGER :: X1AXIS,IFACE,IND(LOW_IND:HIGH_IND),IND_LOC(LOW_IND:HIGH_IND),ICF
INTEGER :: LOCROW_1,LOCROW_2,ILOC,IROW,ICC,JCC,ISIDE,IW
REAL(EB):: AF,VELC,RHO_Z_PV(-2:1),RHOPV(-2:1),FCT,ZZ_GET_N,FN_ZZ
REAL(EB), POINTER, DIMENSION(:,:,:)  :: RHOP=>NULL(),UP=>NULL(),VP=>NULL(),WP=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:)  :: UU=>NULL(),VV=>NULL(),WW=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:,:):: ZZP=>NULL()
TYPE(CC_REGFACEZ_TYPE),  POINTER, DIMENSION(:) :: REGFACE_Z=>NULL()
LOGICAL :: DO_LO,DO_HI
INTEGER :: IIG,JJG,KKG,IOR
REAL(EB) :: UN

! Mesh Loop:
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   UU=>WORK1
   VV=>WORK2
   WW=>WORK3

   IF (PREDICTOR) THEN
      ZZP  => ZZ
      RHOP => RHO
      UU   = U
      VV   = V
      WW   = W
      PRFCT= 1._EB
      WALL_LOOP: DO IW=1,N_EXTERNAL_WALL_CELLS+N_INTERNAL_WALL_CELLS
         WC=>WALL(IW)
         IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE WALL_LOOP
         B1 => BOUNDARY_PROP1(WC%B1_INDEX)
         BC=>BOUNDARY_COORD(WC%BC_INDEX)
         IIG = BC%IIG
         JJG = BC%JJG
         KKG = BC%KKG
         IOR = BC%IOR
         SELECT CASE(WC%BOUNDARY_TYPE)
            CASE DEFAULT; CYCLE WALL_LOOP
            ! SOLID_BOUNDARY is not currently functional here, but keep for testing
            CASE(SOLID_BOUNDARY);        UN = -SIGN(1._EB,REAL(IOR,EB))*B1%U_NORMAL
            CASE(INTERPOLATED_BOUNDARY); UN = UVW_SAVE(IW)
         END SELECT
         SELECT CASE(IOR)
            CASE( 1); UU(IIG-1,JJG,KKG) = UN
            CASE(-1); UU(IIG,JJG,KKG)   = UN
            CASE( 2); VV(IIG,JJG-1,KKG) = UN
            CASE(-2); VV(IIG,JJG,KKG)   = UN
            CASE( 3); WW(IIG,JJG,KKG-1) = UN
            CASE(-3); WW(IIG,JJG,KKG)   = UN
         END SELECT
      ENDDO WALL_LOOP

   ELSE
      ZZP  => ZZS
      RHOP => RHOS
      UU   = US
      VV   = VS
      WW   = WS
      PRFCT= 0._EB
      WALL_LOOP_2: DO IW=1,N_EXTERNAL_WALL_CELLS+N_INTERNAL_WALL_CELLS
         WC=>WALL(IW)
         IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE WALL_LOOP_2
         B1 => BOUNDARY_PROP1(WC%B1_INDEX)
         BC=>BOUNDARY_COORD(WC%BC_INDEX)
         IIG = BC%IIG
         JJG = BC%JJG
         KKG = BC%KKG
         IOR = BC%IOR
         SELECT CASE(WC%BOUNDARY_TYPE)
            CASE DEFAULT; CYCLE WALL_LOOP_2
            ! SOLID_BOUNDARY is not currently functional here, but keep for testing
            CASE(SOLID_BOUNDARY);        UN = -SIGN(1._EB,REAL(IOR,EB))*B1%U_NORMAL_S
            CASE(INTERPOLATED_BOUNDARY); UN = UVW_SAVE(IW)
         END SELECT
         SELECT CASE(IOR)
            CASE( 1); UU(IIG-1,JJG,KKG) = UN
            CASE(-1); UU(IIG,JJG,KKG)   = UN
            CASE( 2); VV(IIG,JJG-1,KKG) = UN
            CASE(-2); VV(IIG,JJG,KKG)   = UN
            CASE( 3); WW(IIG,JJG,KKG-1) = UN
            CASE(-3); WW(IIG,JJG,KKG)   = UN
         END SELECT
      ENDDO WALL_LOOP_2
   ENDIF

   ! The use of UU, VV, WW is to maintain the divergence consistent in cells next to INTERPOLATED_BOUNDARY faces, when
   ! The solver being used is the default POISSON solver (i.e. use normal velocities with velocity error).
   UP => UU
   VP => VV
   WP => WW

   ! X direction bounds:
   ILO_FACE = 0                    ! Low mesh boundary face index.
   IHI_FACE = IBAR                 ! High mesh boundary face index.

   ! Y direction bounds:
   JLO_FACE = 0                    ! Low mesh boundary face index.
   JHI_FACE = JBAR                 ! High mesh boundary face index.

   ! Z direction bounds:
   KLO_FACE = 0                    ! Low mesh boundary face index.
   KHI_FACE = KBAR                 ! High mesh boundary face index.

   ! First add advective fluxes to internal and INTERPOLATED_BOUNDARY regular and cut-cells in the CC region:
   ! IAXIS faces:
   X1AXIS = IAXIS
   REGFACE_Z => CC_REGFACE_IAXIS_Z
   DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
      IW = REGFACE_Z(IFACE)%IWC
      IF (IW>0) THEN
         IF (.NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
      ENDIF
      I     = REGFACE_Z(IFACE)%IJK(IAXIS)
      J     = REGFACE_Z(IFACE)%IJK(JAXIS)
      K     = REGFACE_Z(IFACE)%IJK(KAXIS)
      DO_LO = REGFACE_Z(IFACE)%DO_LO_IND
      DO_HI = REGFACE_Z(IFACE)%DO_HI_IND
      ! Unknowns on related cells:
      IND_LOC(LOW_IND) = CCVAR(I  ,J,K,CC_UNKZ) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= CCVAR(I+1,J,K,CC_UNKZ) - UNKZ_IND(NM_START)

      AF = DY(J)*DZ(K)
      IF (DO_LO) F_Z(IND_LOC( LOW_IND)) = F_Z(IND_LOC( LOW_IND)) + REGFACE_Z(IFACE)%RHOZZ_U(N)*AF
      IF (DO_HI) F_Z(IND_LOC(HIGH_IND)) = F_Z(IND_LOC(HIGH_IND)) - REGFACE_Z(IFACE)%RHOZZ_U(N)*AF
   ENDDO

   ! JAXIS faces:
   X1AXIS = JAXIS
   REGFACE_Z => CC_REGFACE_JAXIS_Z
   DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
      IW = REGFACE_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
      I     = REGFACE_Z(IFACE)%IJK(IAXIS)
      J     = REGFACE_Z(IFACE)%IJK(JAXIS)
      K     = REGFACE_Z(IFACE)%IJK(KAXIS)
      DO_LO = REGFACE_Z(IFACE)%DO_LO_IND
      DO_HI = REGFACE_Z(IFACE)%DO_HI_IND
      ! Unknowns on related cells:
      IND_LOC(LOW_IND) = CCVAR(I,J  ,K,CC_UNKZ) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= CCVAR(I,J+1,K,CC_UNKZ) - UNKZ_IND(NM_START)

      AF = DX(I)*DZ(K)
      IF (DO_LO) F_Z(IND_LOC( LOW_IND)) = F_Z(IND_LOC( LOW_IND)) + REGFACE_Z(IFACE)%RHOZZ_U(N)*AF
      IF (DO_HI) F_Z(IND_LOC(HIGH_IND)) = F_Z(IND_LOC(HIGH_IND)) - REGFACE_Z(IFACE)%RHOZZ_U(N)*AF
   ENDDO

   ! KAXIS faces:
   X1AXIS = KAXIS
   REGFACE_Z => CC_REGFACE_KAXIS_Z
   DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
      IW = REGFACE_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
      I     = REGFACE_Z(IFACE)%IJK(IAXIS)
      J     = REGFACE_Z(IFACE)%IJK(JAXIS)
      K     = REGFACE_Z(IFACE)%IJK(KAXIS)
      DO_LO = REGFACE_Z(IFACE)%DO_LO_IND
      DO_HI = REGFACE_Z(IFACE)%DO_HI_IND
      ! Unknowns on related cells:
      IND_LOC(LOW_IND) = CCVAR(I,J,K  ,CC_UNKZ) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= CCVAR(I,J,K+1,CC_UNKZ) - UNKZ_IND(NM_START)

      AF = DX(I)*DY(J)
      IF (DO_LO) F_Z(IND_LOC( LOW_IND)) = F_Z(IND_LOC( LOW_IND)) + REGFACE_Z(IFACE)%RHOZZ_U(N)*AF
      IF (DO_HI) F_Z(IND_LOC(HIGH_IND)) = F_Z(IND_LOC(HIGH_IND)) - REGFACE_Z(IFACE)%RHOZZ_U(N)*AF
   ENDDO

   ! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
   DO IFACE=1,MESHES(NM)%CC_NRCFACE_Z

      IW = MESHES(NM)%RC_FACE(IFACE)%IWC; IF(IW > 0) CYCLE

      I      = MESHES(NM)%RC_FACE(IFACE)%IJK(IAXIS)
      J      = MESHES(NM)%RC_FACE(IFACE)%IJK(JAXIS)
      K      = MESHES(NM)%RC_FACE(IFACE)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%RC_FACE(IFACE)%IJK(KAXIS+1)

      ! Unknowns on related cells:
      IND(LOW_IND)  = MESHES(NM)%RC_FACE(IFACE)%UNKZ(LOW_IND)
      IND(HIGH_IND) = MESHES(NM)%RC_FACE(IFACE)%UNKZ(HIGH_IND)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            AF = DY(J)*DZ(K)
            RHOPV(-2:1)      = RHOP(I-1:I+2,J,K)
            ! First two cells surrounding face:
            DO ISIDE=-1,0
               SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
               CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
                  ZZ_GET_N = ZZP(I+1+ISIDE,J,K,N)
               CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
                  JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
                  RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT) *CUT_CELL(ICC)%RHOS(JCC)
                  ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
               END SELECT
               RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
            ENDDO
            ! Lower cell:
            ISIDE=-2
            IF (CELL(CELL_INDEX(I+1+ISIDE,J,K))%SOLID .OR. CCVAR(I+1+ISIDE,J,K,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE+1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I+1+ISIDE,J,K,N)
               RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
            ENDIF
            ! Upper cell:
            ISIDE=1
            IF (CELL(CELL_INDEX(I+1+ISIDE,J,K))%SOLID .OR. CCVAR(I+1+ISIDE,J,K,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE-1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I+1+ISIDE,J,K,N)
               RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
            ENDIF
            ! Now Godunov flux limited value of rho*zz on face:
            VELC = UU(I,J,K)
            ! bar{rho*zz}:
            Z_TEMP(0:3,1,1) = RHO_Z_PV(-2:1)
            U_TEMP(1,1,1) = VELC
            CALL GET_SCALAR_FACE_VALUE(U_TEMP,Z_TEMP,F_TEMP,1,1,1,1,1,1,1,I_FLUX_LIMITER)
            FN_ZZ = F_TEMP(1,1,1)
         CASE(JAXIS)
            AF = DX(I)*DZ(K)
            RHOPV(-2:1)      = RHOP(I,J-1:J+2,K)
            DO ISIDE=-1,0
               SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
               CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
                  ZZ_GET_N = ZZP(I,J+1+ISIDE,K,N)
               CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
                  JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
                  RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT) *CUT_CELL(ICC)%RHOS(JCC)
                  ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
               END SELECT
               RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
            ENDDO
            ! Lower cell:
            ISIDE=-2
            IF (CELL(CELL_INDEX(I,J+1+ISIDE,K))%SOLID .OR. CCVAR(I,J+1+ISIDE,K,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE+1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I,J+1+ISIDE,K,N)
               RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
            ENDIF
            ! Upper cell:
            ISIDE=1
            IF (CELL(CELL_INDEX(I,J+1+ISIDE,K))%SOLID .OR. CCVAR(I,J+1+ISIDE,K,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE-1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I,J+1+ISIDE,K,N)
               RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
            ENDIF
            ! Now Godunov flux limited value of rho*zz on face:
            VELC = VV(I,J,K)
            ! bar{rho*zz}:
            Z_TEMP(0:3,1,1) = RHO_Z_PV(-2:1)
            U_TEMP(1,1,1) = VELC
            CALL GET_SCALAR_FACE_VALUE(U_TEMP,Z_TEMP,F_TEMP,1,1,1,1,1,1,1,I_FLUX_LIMITER)
            FN_ZZ = F_TEMP(1,1,1)
         CASE(KAXIS)
            AF = DX(I)*DY(J)
            RHOPV(-2:1)      = RHOP(I,J,K-1:K+2)
            DO ISIDE=-1,0
               SELECT CASE(RC_FACE(IFACE)%CELL_LIST(1,ISIDE+2))
               CASE(CC_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
                  ZZ_GET_N = ZZP(I,J,K+1+ISIDE,N)
               CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = RC_FACE(IFACE)%CELL_LIST(2,ISIDE+2)
                  JCC = RC_FACE(IFACE)%CELL_LIST(3,ISIDE+2)
                  RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)* CUT_CELL(ICC)%RHOS(JCC)
                  ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
               END SELECT
               RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
            ENDDO
            ! Lower cell:
            ISIDE=-2
            IF (CELL(CELL_INDEX(I,J,K+1+ISIDE))%SOLID .OR. CCVAR(I,J,K+1+ISIDE,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE+1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I,J,K+1+ISIDE,N)
               RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
            ENDIF
            ! Upper cell:
            ISIDE=1
            IF (CELL(CELL_INDEX(I,J,K+1+ISIDE))%SOLID .OR. CCVAR(I,J,K+1+ISIDE,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE-1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I,J,K+1+ISIDE,N)
               RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
            ENDIF
            ! Now Godunov flux limited value of rho*zz on face:
            VELC = WW(I,J,K)
            ! bar{rho*zz}:
            Z_TEMP(0:3,1,1) = RHO_Z_PV(-2:1)
            U_TEMP(1,1,1) = VELC
            CALL GET_SCALAR_FACE_VALUE(U_TEMP,Z_TEMP,F_TEMP,1,1,1,1,1,1,1,I_FLUX_LIMITER)
            FN_ZZ = F_TEMP(1,1,1)
      END SELECT

      DO ILOC=LOCROW_1,LOCROW_2
         IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
         FCT = REAL(3-2*ILOC,EB)
         F_Z(IROW) = F_Z(IROW) + FCT*FN_ZZ*VELC*AF
      ENDDO

   ENDDO

   ! Now Gasphase CUT_FACES:
   DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH

      IF ( MESHES(NM)%CUT_FACE(ICF)%STATUS /= CC_GASPHASE ) CYCLE

      IW = MESHES(NM)%CUT_FACE(ICF)%IWC; IF(IW > 0) CYCLE

      I = MESHES(NM)%CUT_FACE(ICF)%IJK(IAXIS)
      J = MESHES(NM)%CUT_FACE(ICF)%IJK(JAXIS)
      K = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS+1)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      DO IFACE=1,MESHES(NM)%CUT_FACE(ICF)%NFACE

         ! Unknowns on related cells:
         IND(LOW_IND)  = MESHES(NM)%CUT_FACE(ICF)%UNKZ(LOW_IND,IFACE)
         IND(HIGH_IND) = MESHES(NM)%CUT_FACE(ICF)%UNKZ(HIGH_IND,IFACE)

         IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
         IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

         AF = MESHES(NM)%CUT_FACE(ICF)%AREA(IFACE)

         ! Matrix coefficients for advection:
         VELC =        PRFCT *MESHES(NM)%CUT_FACE(ICF)%VEL(IFACE) + &
                (1._EB-PRFCT)*MESHES(NM)%CUT_FACE(ICF)%VELS(IFACE)

         RHOPV(-1:0)    = -1._EB
         RHO_Z_PV(-1:0) =  0._EB
         DO ISIDE=-1,0
            SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
            CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
               JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
               RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT) *CUT_CELL(ICC)%RHOS(JCC)
               ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
            END SELECT
            RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
         ENDDO
         SELECT CASE(X1AXIS)
         CASE(IAXIS)
            ! Lower cell:
            ISIDE=-2
            IF (CELL(CELL_INDEX(I+1+ISIDE,J,K))%SOLID .OR. CCVAR(I+1+ISIDE,J,K,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE+1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I+1+ISIDE,J,K,N)
               RHO_Z_PV(ISIDE) = RHOP(I+1+ISIDE,J,K)*ZZ_GET_N
            ENDIF
            ! Upper cell:
            ISIDE=1
            IF (CELL(CELL_INDEX(I+1+ISIDE,J,K))%SOLID .OR. CCVAR(I+1+ISIDE,J,K,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE-1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I+1+ISIDE,J,K,N)
               RHO_Z_PV(ISIDE) = RHOP(I+1+ISIDE,J,K)*ZZ_GET_N
            ENDIF
         CASE(JAXIS)
            ! Lower cell:
            ISIDE=-2
            IF (CELL(CELL_INDEX(I,J+1+ISIDE,K))%SOLID .OR. CCVAR(I,J+1+ISIDE,K,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE+1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I,J+1+ISIDE,K,N)
               RHO_Z_PV(ISIDE) = RHOP(I,J+1+ISIDE,K)*ZZ_GET_N
            ENDIF
            ! Upper cell:
            ISIDE=1
            IF (CELL(CELL_INDEX(I,J+1+ISIDE,K))%SOLID .OR. CCVAR(I,J+1+ISIDE,K,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE-1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I,J+1+ISIDE,K,N)
               RHO_Z_PV(ISIDE) = RHOP(I,J+1+ISIDE,K)*ZZ_GET_N
            ENDIF
         CASE(KAXIS)
            ! Lower cell:
            ISIDE=-2
            IF (CELL(CELL_INDEX(I,J,K+1+ISIDE))%SOLID .OR. CCVAR(I,J,K+1+ISIDE,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE+1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I,J,K+1+ISIDE,N)
               RHO_Z_PV(ISIDE) = RHOP(I,J,K+1+ISIDE)*ZZ_GET_N
            ENDIF
            ! Upper cell:
            ISIDE=1
            IF (CELL(CELL_INDEX(I,J,K+1+ISIDE))%SOLID .OR. CCVAR(I,J,K+1+ISIDE,CC_CGSC)==CC_SOLID) THEN
               RHO_Z_PV(ISIDE) = RHO_Z_PV(ISIDE-1) ! Use center cell.
            ELSE
               ZZ_GET_N = ZZP(I,J,K+1+ISIDE,N)
               RHO_Z_PV(ISIDE) = RHOP(I,J,K+1+ISIDE)*ZZ_GET_N
            ENDIF
         END SELECT
         VELC  = PRFCT *CUT_FACE(ICF)%VEL(IFACE) + (1._EB-PRFCT)*CUT_FACE(ICF)%VELS(IFACE)
         ! bar{rho*zz}:
         Z_TEMP(0:3,1,1) = RHO_Z_PV(-2:1)
         U_TEMP(1,1,1) = VELC
         CALL GET_SCALAR_FACE_VALUE(U_TEMP,Z_TEMP,F_TEMP,1,1,1,1,1,1,1,I_FLUX_LIMITER)
         FN_ZZ = F_TEMP(1,1,1)

         DO ILOC=LOCROW_1,LOCROW_2
            IROW=IND_LOC(ILOC)     ! Process Local Unknown number.
            FCT = REAL(3-2*ILOC,EB)
            F_Z(IROW) = F_Z(IROW) + FCT*FN_ZZ*VELC*AF
         ENDDO

      ENDDO

   ENDDO

   ! Then add (Del rho D Del Z)*dv computed on CCDIVERGENCE_PART_1:
   ! Loop over regular cells on CC region:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE ! Cycle Reg cells not implicit, cut-cells
                                                  ! underlying Cartesian cells and
                                                  ! solid cells.
            IROW  = CCVAR(I,J,K,CC_UNKZ) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
            F_Z(IROW) = F_Z(IROW) - DEL_RHO_D_DEL_Z(I,J,K,N)*(DX(I)*DY(J)*DZ(K))
         ENDDO
      ENDDO
   ENDDO

   ! Now cut-cells:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      I = CUT_CELL(ICC)%IJK(IAXIS)
      J = CUT_CELL(ICC)%IJK(JAXIS)
      K = CUT_CELL(ICC)%IJK(KAXIS)
      ! Don't count cut-cells inside an OBST:
      IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
      DO JCC=1,CUT_CELL(ICC)%NCELL
         IROW = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
         F_Z(IROW) = F_Z(IROW) - CUT_CELL(ICC)%DEL_RHO_D_DEL_Z_VOL(N,JCC)
      ENDDO
   ENDDO

ENDDO MESH_LOOP

RETURN
END SUBROUTINE GET_EXPLICIT_ADVDIFFVECTOR_SCALAR_3D

! --------------------------- CC_CHECK_MASS_DENSITY ------------------------

SUBROUTINE CC_CHECK_MASS_DENSITY

INTEGER, PARAMETER :: MAX_SURR_CELLS=20
INTEGER :: NM, NCELL, ICC, JCC, I, J, K, IFC, IFACE, IFC1, JFC1, ICC1, JCC1, IC, LOHI, ILH, X1AXIS, &
           II, JJ, KK, IIF, JJF, KKF, IRC, N
REAL(EB), POINTER, DIMENSION(:,:,:)   :: DELTA_RHO=>NULL(),DELTA_RHO_ZZ=>NULL(),RHOP=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: RHO_ZZ=>NULL()
REAL(EB) :: MASS_C, MASS_N(1:MAX_SURR_CELLS), RHO_CELL(1:MAX_SURR_CELLS), VOL(1:MAX_SURR_CELLS), &
            RHO_CUT, SIGN_FACTOR, SUM_MASS_N, SUM_RHO_ZZ, CONST, PRFCT, CC_RHOP, CC_RHO_ZZP, RHO_ZZ_MIN, &
            RHO_ZZ_MAX, RHO_ZZ_CUT, RHO_ZZ_TEST
LOGICAL :: CLIP_RHOMIN_CC, CLIP_RHOMAX_CC, CLIP_RHO_ZZ, CLIP_RHO_ZZ_SAVE


! Loop meshes:
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   DELTA_RHO => WORK4
   DELTA_RHO =  0._EB
   CLIP_RHOMIN_CC = .FALSE.
   CLIP_RHOMAX_CC = .FALSE.
   IF (PREDICTOR) THEN
      RHOP   => RHOS
      RHO_ZZ => ZZS ! At this stage of the time step, ZZS is actually RHOS*ZZS in cells with UNKZ>0
      PRFCT=  1._EB
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH ! First compute RHOS in cut-cell region:
         CC => CUT_CELL(ICC)
         IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID)  CYCLE
         CC%DELTA_RHO(1:CC%NCELL) = 0._EB
         DO JCC=1,CC%NCELL; CC%RHOS(JCC) = SUM(CC%ZZS(1:N_TRACKED_SPECIES,JCC)); ENDDO
      ENDDO

   ELSE
      RHOP   => RHO
      RHO_ZZ => ZZ ! At this stage of the time step, ZZ is actually RHO*ZZ in cells with UNKZ>0
      PRFCT=  0._EB
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH ! First compute RHO in cut-cell region:
         CC => CUT_CELL(ICC)
         IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID)  CYCLE
         CC%DELTA_RHO(1:CC%NCELL) = 0._EB
         DO JCC=1,CC%NCELL; CC%RHO(JCC) = SUM(CC%ZZ(1:N_TRACKED_SPECIES,JCC)); ENDDO
      ENDDO

   ENDIF

   ! First compute RHOP in cut-cell region regular cells:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CELL(CELL_INDEX(I,J,K))%SOLID .OR. CCVAR(I,J,K,CC_CGSC)/=CC_GASPHASE)  CYCLE
            IF (MESHES(NM)%CCVAR(I,J,K,CC_UNKZ) <= 0) THEN
               ! Bring back ZZ*RHO in regular gas cells from mass fractions computed done in DENSITY.
               RHO_ZZ(I,J,K,1:N_TRACKED_SPECIES) = RHO_ZZ(I,J,K,1:N_TRACKED_SPECIES)*RHOP(I,J,K)
            ELSE
               RHOP(I,J,K) = SUM(RHO_ZZ(I,J,K,1:N_TRACKED_SPECIES))
            ENDIF
         ENDDO
      ENDDO
   ENDDO

   ! Correct density:
   ! Distribute delta_rho to neighbors, including linked cell:
   ! 1. Compute DELTA_RHO in cut-cells and regular cells.
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      CC => CUT_CELL(ICC)
      I=CC%IJK(IAXIS); J=CC%IJK(JAXIS); K=CC%IJK(KAXIS); IC=CELL_INDEX(I,J,K); IF (CELL(IC)%SOLID) CYCLE
      JCC1_LOOP : DO JCC=1,CC%NCELL
         CC_RHOP = PRFCT*CC%RHOS(JCC) + (1._EB-PRFCT)*CC%RHO(JCC)
         IF (CC_RHOP>=RHOMIN .AND. CC_RHOP<=RHOMAX) CYCLE JCC1_LOOP
         IF (CC_RHOP<RHOMIN) THEN
            RHO_CUT = RHOMIN
            SIGN_FACTOR = 1._EB
            CLIP_RHOMIN_CC = .TRUE.
         ELSE
            RHO_CUT = RHOMAX
            SIGN_FACTOR = -1._EB
            CLIP_RHOMAX_CC = .TRUE.
         ENDIF
         MASS_C = ABS(RHO_CUT-CC_RHOP) * CC%VOLUME(JCC)

         ! Now find connected regular and cut-cells and add their contributions to Delta mass:
         MASS_N = 0._EB; NCELL=0
         DO IFC=2,CC%CCELEM(1,JCC)+1
            IFACE = CC%CCELEM(IFC,JCC); IF(CC%FACE_LIST(1,IFACE)==CC_FTYPE_CFINB) CYCLE
            LOHI  = CC%FACE_LIST(2,IFACE)
            ILH   = 2*CC%FACE_LIST(2,IFACE) - 3 ! -1 for LOHI=LOW_IND, 1 for LOHI=HIGH_IND
            X1AXIS= CC%FACE_LIST(3,IFACE)
            IF (CELL(IC)%WALL_INDEX(ILH*X1AXIS)/=0) CYCLE ! There is a wall cell here.
            NCELL=NCELL+1
            SELECT CASE(CC%FACE_LIST(1,IFACE))
            CASE(CC_FTYPE_CFGAS)
               IFC1 = CC%FACE_LIST(4,IFACE); JFC1 = CC%FACE_LIST(5,IFACE)
               ICC1 = CUT_FACE(IFC1)%CELL_LIST(2,LOHI,JFC1); JCC1 = CUT_FACE(IFC1)%CELL_LIST(3,LOHI,JFC1)
               RHO_CELL(NCELL) = PRFCT*CUT_CELL(ICC1)%RHOS(JCC1)+(1._EB-PRFCT)*CUT_CELL(ICC1)%RHO(JCC1)
               VOL(NCELL)      = CUT_CELL(ICC1)%VOLUME(JCC1)
            CASE(CC_FTYPE_RCGAS)
               II=I; JJ=J; KK=K; IIF=I; JJF=J; KKF=K
               SELECT CASE(X1AXIS)
               CASE(IAXIS); IIF = IIF+LOHI-2; II = II+ILH
               CASE(JAXIS); JJF = JJF+LOHI-2; JJ = JJ+ILH
               CASE(KAXIS); KKF = KKF+LOHI-2; KK = KK+ILH
               END SELECT
               IRC = FCVAR(IIF,JJF,KKF,CC_IDRC,X1AXIS)
               SELECT CASE(RC_FACE(IRC)%CELL_LIST(1,LOHI))
               CASE(CC_FTYPE_RGGAS) ! Regular cell
                  RHO_CELL(NCELL) = RHOP(II,JJ,KK); VOL(NCELL) = DX(II)*DY(JJ)*DZ(KK)
               CASE(CC_FTYPE_CFGAS) ! Cut-cell
                  ICC1 = RC_FACE(IRC)%CELL_LIST(2,LOHI);  JCC1 = RC_FACE(IRC)%CELL_LIST(3,LOHI)
                  RHO_CELL(NCELL) = PRFCT*CUT_CELL(ICC1)%RHOS(JCC1)+(1._EB-PRFCT)*CUT_CELL(ICC1)%RHO(JCC1)
                  VOL(NCELL)      = CUT_CELL(ICC1)%VOLUME(JCC1)
               END SELECT
            END SELECT
            MASS_N(NCELL) = ABS(MIN(RHOMAX,MAX(RHOMIN,RHO_CELL(NCELL)))-RHO_CUT) * VOL(NCELL)
         ENDDO

         ! We have MASS_C, MASS_N and NCELL, now distribute:
         SUM_MASS_N = SUM(MASS_N(1:NCELL)); IF (SUM_MASS_N<=TWO_EPSILON_EB) CYCLE
         CONST = SIGN_FACTOR*MIN(1._EB,MASS_C/SUM_MASS_N)

         CC%DELTA_RHO(JCC) = CC%DELTA_RHO(JCC) + CONST*SUM_MASS_N/CC%VOLUME(JCC)
         NCELL=0
         DO IFC=2,CC%CCELEM(1,JCC)+1
            IFACE = CC%CCELEM(IFC,JCC); IF(CC%FACE_LIST(1,IFACE)==CC_FTYPE_CFINB) CYCLE
            LOHI  = CC%FACE_LIST(2,IFACE)
            ILH   = 2*CC%FACE_LIST(2,IFACE) - 3 ! -1 for LOHI=LOW_IND, 1 for LOHI=HIGH_IND
            X1AXIS= CC%FACE_LIST(3,IFACE)
            IF (CELL(IC)%WALL_INDEX(ILH*X1AXIS)/=0) CYCLE ! There is a wall cell here.
            NCELL=NCELL+1
            SELECT CASE(CC%FACE_LIST(1,IFACE))
            CASE(CC_FTYPE_CFGAS)
               IFC1 = CC%FACE_LIST(4,IFACE); JFC1 = CC%FACE_LIST(5,IFACE)
               ICC1 = CUT_FACE(IFC1)%CELL_LIST(2,LOHI,JFC1); JCC1 = CUT_FACE(IFC1)%CELL_LIST(3,LOHI,JFC1)
               CUT_CELL(ICC1)%DELTA_RHO(JCC1) = CUT_CELL(ICC1)%DELTA_RHO(JCC1) - CONST*MASS_N(NCELL)/VOL(NCELL)
            CASE(CC_FTYPE_RCGAS)
               II=I; JJ=J; KK=K; IIF=I; JJF=J; KKF=K
               SELECT CASE(X1AXIS)
               CASE(IAXIS); IIF = IIF+LOHI-2; II = II+ILH
               CASE(JAXIS); JJF = JJF+LOHI-2; JJ = JJ+ILH
               CASE(KAXIS); KKF = KKF+LOHI-2; KK = KK+ILH
               END SELECT
               IRC = FCVAR(IIF,JJF,KKF,CC_IDRC,X1AXIS)
               SELECT CASE(RC_FACE(IRC)%CELL_LIST(1,LOHI))
               CASE(CC_FTYPE_RGGAS) ! Regular cell
                  DELTA_RHO(II,JJ,KK) = DELTA_RHO(II,JJ,KK) - CONST*MASS_N(NCELL)/VOL(NCELL)
               CASE(CC_FTYPE_CFGAS) ! Cut-cell
                  ICC1 = RC_FACE(IRC)%CELL_LIST(2,LOHI);  JCC1 = RC_FACE(IRC)%CELL_LIST(3,LOHI)
                  CUT_CELL(ICC1)%DELTA_RHO(JCC1) = CUT_CELL(ICC1)%DELTA_RHO(JCC1) - CONST*MASS_N(NCELL)/VOL(NCELL)
               END SELECT
            END SELECT
         ENDDO
      ENDDO JCC1_LOOP
   ENDDO

   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (MESHES(NM)%CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
            IF (RHOP(I,J,K)>=RHOMIN .AND. RHOP(I,J,K)<=RHOMAX) CYCLE
            IF (RHOP(I,J,K)<RHOMIN) THEN
               RHO_CUT = RHOMIN
               SIGN_FACTOR = 1._EB
               CLIP_RHOMIN_CC = .TRUE.
            ELSE
               RHO_CUT = RHOMAX
               SIGN_FACTOR = -1._EB
               CLIP_RHOMAX_CC = .TRUE.
            ENDIF
            MASS_C = ABS(RHO_CUT-RHOP(I,J,K)) * (DX(I)*DY(J)*DZ(K))
            ! Neighbor MASS_N contributions:
            MASS_N = 0._EB; NCELL=0
            DO X1AXIS=IAXIS,KAXIS
               DO LOHI=LOW_IND,HIGH_IND
                  ILH   = 2*LOHI - 3
                  IF (CELL(IC)%WALL_INDEX(ILH*X1AXIS)/=0) CYCLE ! There is a wall cell here.
                  NCELL=NCELL+1; II=I; JJ=J; KK=K; IIF=I; JJF=J; KKF=K
                  SELECT CASE(X1AXIS)
                  CASE(IAXIS); IIF = IIF+LOHI-2; II = II+ILH
                  CASE(JAXIS); JJF = JJF+LOHI-2; JJ = JJ+ILH
                  CASE(KAXIS); KKF = KKF+LOHI-2; KK = KK+ILH
                  END SELECT
                  IRC = FCVAR(IIF,JJF,KKF,CC_IDRC,X1AXIS)
                  IF (IRC>0) THEN ! Regular face and cell on the other side.
                     SELECT CASE(RC_FACE(IRC)%CELL_LIST(1,LOHI))
                     CASE(CC_FTYPE_RGGAS) ! Regular cell
                        RHO_CELL(NCELL) = RHOP(II,JJ,KK); VOL(NCELL) = DX(II)*DY(JJ)*DZ(KK)
                     CASE(CC_FTYPE_CFGAS) ! Cut-cell
                        ICC1 = RC_FACE(IRC)%CELL_LIST(2,LOHI);  JCC1 = RC_FACE(IRC)%CELL_LIST(3,LOHI)
                        RHO_CELL(NCELL) = PRFCT*CUT_CELL(ICC1)%RHOS(JCC1)+(1._EB-PRFCT)*CUT_CELL(ICC1)%RHO(JCC1)
                        VOL(NCELL) = CUT_CELL(ICC1)%VOLUME(JCC1)
                     END SELECT
                  ELSE
                     RHO_CELL(NCELL) = RHOP(II,JJ,KK); VOL(NCELL) = DX(II)*DY(JJ)*DZ(KK)
                  ENDIF
                  MASS_N(NCELL) = ABS(MIN(RHOMAX,MAX(RHOMIN,RHO_CELL(NCELL)))-RHO_CUT) * VOL(NCELL)
               ENDDO
            ENDDO
            ! We have MASS_C, MASS_N and NCELL, now distribute:
            SUM_MASS_N = SUM(MASS_N(1:NCELL)); IF (SUM_MASS_N<=TWO_EPSILON_EB) CYCLE
            CONST = SIGN_FACTOR*MIN(1._EB,MASS_C/SUM_MASS_N)
            DELTA_RHO(I,J,K) = DELTA_RHO(I,J,K) + CONST*SUM_MASS_N/(DX(I)*DY(J)*DZ(K))
            ! Neighbor cells:
            NCELL=0
            DO X1AXIS=IAXIS,KAXIS
               DO LOHI=LOW_IND,HIGH_IND
                  ILH   = 2*LOHI - 3
                  IF (CELL(IC)%WALL_INDEX(ILH*X1AXIS)/=0) CYCLE ! There is a wall cell here.
                  NCELL=NCELL+1; II=I; JJ=J; KK=K; IIF=I; JJF=J; KKF=K
                  SELECT CASE(X1AXIS)
                  CASE(IAXIS); IIF = IIF+LOHI-2; II = II+ILH
                  CASE(JAXIS); JJF = JJF+LOHI-2; JJ = JJ+ILH
                  CASE(KAXIS); KKF = KKF+LOHI-2; KK = KK+ILH
                  END SELECT
                  IRC = FCVAR(IIF,JJF,KKF,CC_IDRC,X1AXIS)
                  IF (IRC>0) THEN ! Regular face and cell on the other side.
                     SELECT CASE(RC_FACE(IRC)%CELL_LIST(1,LOHI))
                     CASE(CC_FTYPE_RGGAS) ! Regular cell
                        DELTA_RHO(II,JJ,KK) = DELTA_RHO(II,JJ,KK) - CONST*MASS_N(NCELL)/VOL(NCELL)
                     CASE(CC_FTYPE_CFGAS) ! Cut-cell
                        ICC1 = RC_FACE(IRC)%CELL_LIST(2,LOHI);  JCC1 = RC_FACE(IRC)%CELL_LIST(3,LOHI)
                        CUT_CELL(ICC1)%DELTA_RHO(JCC1) = CUT_CELL(ICC1)%DELTA_RHO(JCC1) - CONST*MASS_N(NCELL)/VOL(NCELL)
                     END SELECT
                  ELSE
                     DELTA_RHO(II,JJ,KK) = DELTA_RHO(II,JJ,KK) - CONST*MASS_N(NCELL)/VOL(NCELL)
                  ENDIF
               ENDDO
            ENDDO
         ENDDO
      ENDDO
   ENDDO

   ! 2. Assign DELTA_RHO to neighboring cells if clipping has been done.
   IF (CLIP_RHOMIN_CC .OR. CLIP_RHOMAX_CC) THEN
      IF (PREDICTOR) THEN
         DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
            CC => CUT_CELL(ICC)
            IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
            DO JCC=1,CC%NCELL; CC%RHOS(JCC) = MIN(RHOMAX,MAX(RHOMIN,CC%RHOS(JCC)+CC%DELTA_RHO(JCC))); ENDDO
         ENDDO
      ELSE
         DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
            CC => CUT_CELL(ICC)
            IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
            DO JCC=1,CC%NCELL; CC%RHO(JCC)  = MIN(RHOMAX,MAX(RHOMIN,CC%RHO(JCC) +CC%DELTA_RHO(JCC))); ENDDO
         ENDDO
      ENDIF
      RHOP(1:IBAR,1:JBAR,1:KBAR) = MIN(RHOMAX,MAX(RHOMIN,RHOP(1:IBAR,1:JBAR,1:KBAR)+DELTA_RHO(1:IBAR,1:JBAR,1:KBAR)))
   ENDIF

   ! If there is only one gas species, set rho*Z=rho and return.
   CLIP_RHOMIN = CLIP_RHOMIN .OR. CLIP_RHOMIN_CC
   CLIP_RHOMAX = CLIP_RHOMAX .OR. CLIP_RHOMAX_CC

   IF (N_TRACKED_SPECIES==1) THEN
      IF (CLIP_RHOMIN_CC .OR. CLIP_RHOMAX_CC) THEN
         IF (PREDICTOR) THEN
            DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
               CC => CUT_CELL(ICC)
               IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
               DO JCC=1,CC%NCELL; CC%ZZS(1,JCC) = CC%RHOS(JCC); ENDDO
            ENDDO
         ELSE
            DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
               CC => CUT_CELL(ICC)
               IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
               DO JCC=1,CC%NCELL; CC%ZZ(1,JCC)  = CC%RHO(JCC); ENDDO
            ENDDO
         ENDIF
         RHO_ZZ(1:IBAR,1:JBAR,1:KBAR,1) = RHOP(1:IBAR,1:JBAR,1:KBAR)
      ENDIF
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (CELL(CELL_INDEX(I,J,K))%SOLID .OR. CCVAR(I,J,K,CC_CGSC)/=CC_GASPHASE)  CYCLE
               IF (MESHES(NM)%CCVAR(I,J,K,CC_UNKZ) <= 0) &
                  RHO_ZZ(I,J,K,1:N_TRACKED_SPECIES) = RHO_ZZ(I,J,K,1:N_TRACKED_SPECIES)/RHOP(I,J,K)
            ENDDO
         ENDDO
      ENDDO
      CYCLE MESH_LOOP
   ENDIF

   ! Correct species mass density
   ! Run through N species
   RHO_ZZ_MIN       =  0._EB
   DELTA_RHO_ZZ     => WORK5
   CLIP_RHO_ZZ_SAVE = .FALSE.
   SPECIES_LOOP: DO N=1,N_TRACKED_SPECIES

      DELTA_RHO_ZZ =  0._EB
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         CUT_CELL(ICC)%DELTA_RHO_ZZ=0._EB
      ENDDO
      CLIP_RHO_ZZ  = .FALSE.

      ! 1. compute DELTA_RHO_ZZ in cut-cells and regular cells.
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         CC => CUT_CELL(ICC)
         I=CC%IJK(IAXIS); J=CC%IJK(JAXIS); K=CC%IJK(KAXIS); IC=CELL_INDEX(I,J,K); IF (CELL(IC)%SOLID) CYCLE
         JCC2_LOOP : DO JCC=1,CC%NCELL
            CC_RHOP    = PRFCT*CC%RHOS(JCC)  + (1._EB-PRFCT)*CC%RHO(JCC); RHO_ZZ_MAX = CC_RHOP
            CC_RHO_ZZP = PRFCT*CC%ZZS(N,JCC) + (1._EB-PRFCT)*CC%ZZ(N,JCC)
            IF (CC_RHO_ZZP>=RHO_ZZ_MIN .AND. CC_RHO_ZZP<=RHO_ZZ_MAX) CYCLE JCC2_LOOP
            CLIP_RHO_ZZ = .TRUE.
            IF (CC_RHO_ZZP<RHO_ZZ_MIN) THEN
               RHO_ZZ_CUT = RHO_ZZ_MIN
               SIGN_FACTOR = 1._EB
            ELSE
               RHO_ZZ_CUT = RHO_ZZ_MAX
               SIGN_FACTOR = -1._EB
            ENDIF
            MASS_C = ABS(RHO_ZZ_CUT-CC_RHO_ZZP) * CC%VOLUME(JCC)

            ! Now find connected regular and cut-cells and add their contributions to Delta mass ZZ:
            MASS_N = 0._EB; NCELL=0
            DO IFC=2,CC%CCELEM(1,JCC)+1
               IFACE = CC%CCELEM(IFC,JCC); IF(CC%FACE_LIST(1,IFACE)==CC_FTYPE_CFINB) CYCLE
               LOHI  = CC%FACE_LIST(2,IFACE)
               ILH   = 2*CC%FACE_LIST(2,IFACE) - 3 ! -1 for LOHI=LOW_IND, 1 for LOHI=HIGH_IND
               X1AXIS= CC%FACE_LIST(3,IFACE)
               IF (CELL(IC)%WALL_INDEX(ILH*X1AXIS)/=0) CYCLE ! There is a wall cell here.
               NCELL=NCELL+1
               SELECT CASE(CC%FACE_LIST(1,IFACE))
               CASE(CC_FTYPE_CFGAS)
                  IFC1 = CC%FACE_LIST(4,IFACE); JFC1 = CC%FACE_LIST(5,IFACE)
                  ICC1 = CUT_FACE(IFC1)%CELL_LIST(2,LOHI,JFC1); JCC1 = CUT_FACE(IFC1)%CELL_LIST(3,LOHI,JFC1)
                  RHO_CELL(NCELL) = PRFCT*CUT_CELL(ICC1)%ZZS(N,JCC1)+(1._EB-PRFCT)*CUT_CELL(ICC1)%ZZ(N,JCC1)
                  VOL(NCELL)      = CUT_CELL(ICC1)%VOLUME(JCC1)
               CASE(CC_FTYPE_RCGAS)
                  II=I; JJ=J; KK=K; IIF=I; JJF=J; KKF=K
                  SELECT CASE(X1AXIS)
                  CASE(IAXIS); IIF = IIF+LOHI-2; II = II+ILH
                  CASE(JAXIS); JJF = JJF+LOHI-2; JJ = JJ+ILH
                  CASE(KAXIS); KKF = KKF+LOHI-2; KK = KK+ILH
                  END SELECT
                  IRC = FCVAR(IIF,JJF,KKF,CC_IDRC,X1AXIS)
                  SELECT CASE(RC_FACE(IRC)%CELL_LIST(1,LOHI))
                  CASE(CC_FTYPE_RGGAS) ! Regular cell
                     RHO_CELL(NCELL) = RHO_ZZ(II,JJ,KK,N); VOL(NCELL) = DX(II)*DY(JJ)*DZ(KK)
                  CASE(CC_FTYPE_CFGAS) ! Cut-cell
                     ICC1 = RC_FACE(IRC)%CELL_LIST(2,LOHI);  JCC1 = RC_FACE(IRC)%CELL_LIST(3,LOHI)
                     RHO_CELL(NCELL) = PRFCT*CUT_CELL(ICC1)%ZZS(N,JCC1)+(1._EB-PRFCT)*CUT_CELL(ICC1)%ZZ(N,JCC1)
                     VOL(NCELL)      = CUT_CELL(ICC1)%VOLUME(JCC1)
                  END SELECT
               END SELECT
               MASS_N(NCELL) = ABS(MIN(RHO_ZZ_MAX,MAX(RHO_ZZ_MIN,RHO_CELL(NCELL)))-RHO_ZZ_CUT) * VOL(NCELL)
            ENDDO

            ! We have MASS_C, MASS_N and NCELL, now distribute:
            SUM_MASS_N = SUM(MASS_N(1:NCELL)); IF (SUM_MASS_N<=TWO_EPSILON_EB) CYCLE
            CONST = SIGN_FACTOR*MIN(1._EB,MASS_C/SUM_MASS_N)

            CC%DELTA_RHO_ZZ(JCC) = CC%DELTA_RHO_ZZ(JCC) + CONST*SUM_MASS_N/CC%VOLUME(JCC)
            NCELL=0
            DO IFC=2,CC%CCELEM(1,JCC)+1
               IFACE = CC%CCELEM(IFC,JCC); IF(CC%FACE_LIST(1,IFACE)==CC_FTYPE_CFINB) CYCLE
               LOHI  = CC%FACE_LIST(2,IFACE)
               ILH   = 2*CC%FACE_LIST(2,IFACE) - 3 ! -1 for LOHI=LOW_IND, 1 for LOHI=HIGH_IND
               X1AXIS= CC%FACE_LIST(3,IFACE)
               IF (CELL(IC)%WALL_INDEX(ILH*X1AXIS)/=0) CYCLE ! There is a wall cell here.
               NCELL=NCELL+1
               SELECT CASE(CC%FACE_LIST(1,IFACE))
               CASE(CC_FTYPE_CFGAS)
                  IFC1 = CC%FACE_LIST(4,IFACE); JFC1 = CC%FACE_LIST(5,IFACE)
                  ICC1 = CUT_FACE(IFC1)%CELL_LIST(2,LOHI,JFC1); JCC1 = CUT_FACE(IFC1)%CELL_LIST(3,LOHI,JFC1)
                  CUT_CELL(ICC1)%DELTA_RHO_ZZ(JCC1) = CUT_CELL(ICC1)%DELTA_RHO_ZZ(JCC1) - CONST*MASS_N(NCELL)/VOL(NCELL)
               CASE(CC_FTYPE_RCGAS)
                  II=I; JJ=J; KK=K; IIF=I; JJF=J; KKF=K
                  SELECT CASE(X1AXIS)
                  CASE(IAXIS); IIF = IIF+LOHI-2; II = II+ILH
                  CASE(JAXIS); JJF = JJF+LOHI-2; JJ = JJ+ILH
                  CASE(KAXIS); KKF = KKF+LOHI-2; KK = KK+ILH
                  END SELECT
                  IRC = FCVAR(IIF,JJF,KKF,CC_IDRC,X1AXIS)
                  SELECT CASE(RC_FACE(IRC)%CELL_LIST(1,LOHI))
                  CASE(CC_FTYPE_RGGAS) ! Regular cell
                     DELTA_RHO_ZZ(II,JJ,KK) = DELTA_RHO_ZZ(II,JJ,KK) - CONST*MASS_N(NCELL)/VOL(NCELL)
                  CASE(CC_FTYPE_CFGAS) ! Cut-cell
                     ICC1 = RC_FACE(IRC)%CELL_LIST(2,LOHI);  JCC1 = RC_FACE(IRC)%CELL_LIST(3,LOHI)
                     CUT_CELL(ICC1)%DELTA_RHO_ZZ(JCC1) = CUT_CELL(ICC1)%DELTA_RHO_ZZ(JCC1) - CONST*MASS_N(NCELL)/VOL(NCELL)
                  END SELECT
               END SELECT
            ENDDO
         ENDDO JCC2_LOOP
      ENDDO
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (MESHES(NM)%CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
               RHO_ZZ_MAX = RHOP(I,J,K)
               IF (RHO_ZZ(I,J,K,N)>=RHO_ZZ_MIN .AND. RHO_ZZ(I,J,K,N)<=RHO_ZZ_MAX) CYCLE
               CLIP_RHO_ZZ = .TRUE.
               IF (RHO_ZZ(I,J,K,N)<RHO_ZZ_MIN) THEN
                  RHO_ZZ_CUT = RHO_ZZ_MIN
                  SIGN_FACTOR = 1._EB
               ELSE
                  RHO_ZZ_CUT = RHO_ZZ_MAX
                  SIGN_FACTOR = -1._EB
               ENDIF
               MASS_C = ABS(RHO_ZZ_CUT-RHO_ZZ(I,J,K,N)) * (DX(I)*DY(J)*DZ(K))
               ! Neighbor MASS_N contributions:
               MASS_N = 0._EB; NCELL=0
               DO X1AXIS=IAXIS,KAXIS
                  DO LOHI=LOW_IND,HIGH_IND
                     ILH   = 2*LOHI - 3
                     IF (CELL(CELL_INDEX(I,J,K))%WALL_INDEX(ILH*X1AXIS)/=0) CYCLE ! There is a wall cell here.
                     NCELL=NCELL+1; II=I; JJ=J; KK=K; IIF=I; JJF=J; KKF=K
                     SELECT CASE(X1AXIS)
                     CASE(IAXIS); IIF = IIF+LOHI-2; II = II+ILH
                     CASE(JAXIS); JJF = JJF+LOHI-2; JJ = JJ+ILH
                     CASE(KAXIS); KKF = KKF+LOHI-2; KK = KK+ILH
                     END SELECT
                     IRC = FCVAR(IIF,JJF,KKF,CC_IDRC,X1AXIS)
                     IF (IRC>0) THEN ! Regular face and cell on the other side.
                        SELECT CASE(RC_FACE(IRC)%CELL_LIST(1,LOHI))
                        CASE(CC_FTYPE_RGGAS) ! Regular cell
                           RHO_CELL(NCELL) = RHO_ZZ(II,JJ,KK,N); VOL(NCELL) = DX(II)*DY(JJ)*DZ(KK)
                        CASE(CC_FTYPE_CFGAS) ! Cut-cell
                           ICC1 = RC_FACE(IRC)%CELL_LIST(2,LOHI);  JCC1 = RC_FACE(IRC)%CELL_LIST(3,LOHI)
                           RHO_CELL(NCELL) = PRFCT*CUT_CELL(ICC1)%ZZS(N,JCC1)+(1._EB-PRFCT)*CUT_CELL(ICC1)%ZZ(N,JCC1)
                           VOL(NCELL) = CUT_CELL(ICC1)%VOLUME(JCC1)
                        END SELECT
                     ELSE
                        RHO_CELL(NCELL) = RHO_ZZ(II,JJ,KK,N); VOL(NCELL) = DX(II)*DY(JJ)*DZ(KK)
                     ENDIF
                     MASS_N(NCELL) = ABS(MIN(RHO_ZZ_MAX,MAX(RHO_ZZ_MIN,RHO_CELL(NCELL)))-RHO_ZZ_CUT) * VOL(NCELL)
                  ENDDO
               ENDDO
               ! We have MASS_C, MASS_N and NCELL, now distribute:
               SUM_MASS_N = SUM(MASS_N(1:NCELL)); IF (SUM_MASS_N<=TWO_EPSILON_EB) CYCLE
               CONST = SIGN_FACTOR*MIN(1._EB,MASS_C/SUM_MASS_N)
               DELTA_RHO_ZZ(I,J,K) = DELTA_RHO_ZZ(I,J,K) + CONST*SUM_MASS_N/(DX(I)*DY(J)*DZ(K))
               ! Neighbor cells:
               NCELL=0
               DO X1AXIS=IAXIS,KAXIS
                  DO LOHI=LOW_IND,HIGH_IND
                     ILH   = 2*LOHI - 3
                     IF (CELL(CELL_INDEX(I,J,K))%WALL_INDEX(ILH*X1AXIS)/=0) CYCLE ! There is a wall cell here.
                     NCELL=NCELL+1; II=I; JJ=J; KK=K; IIF=I; JJF=J; KKF=K
                     SELECT CASE(X1AXIS)
                     CASE(IAXIS); IIF = IIF+LOHI-2; II = II+ILH
                     CASE(JAXIS); JJF = JJF+LOHI-2; JJ = JJ+ILH
                     CASE(KAXIS); KKF = KKF+LOHI-2; KK = KK+ILH
                     END SELECT
                     IRC = FCVAR(IIF,JJF,KKF,CC_IDRC,X1AXIS)
                     IF (IRC>0) THEN ! Regular face and cell on the other side.
                        SELECT CASE(RC_FACE(IRC)%CELL_LIST(1,LOHI))
                        CASE(CC_FTYPE_RGGAS) ! Regular cell
                           DELTA_RHO_ZZ(II,JJ,KK) = DELTA_RHO_ZZ(II,JJ,KK) - CONST*MASS_N(NCELL)/VOL(NCELL)
                        CASE(CC_FTYPE_CFGAS) ! Cut-cell
                           ICC1 = RC_FACE(IRC)%CELL_LIST(2,LOHI);  JCC1 = RC_FACE(IRC)%CELL_LIST(3,LOHI)
                           CUT_CELL(ICC1)%DELTA_RHO_ZZ(JCC1) = CUT_CELL(ICC1)%DELTA_RHO_ZZ(JCC1)-CONST*MASS_N(NCELL)/VOL(NCELL)
                        END SELECT
                     ELSE
                        DELTA_RHO_ZZ(II,JJ,KK) = DELTA_RHO_ZZ(II,JJ,KK) - CONST*MASS_N(NCELL)/VOL(NCELL)
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO

      IF (.NOT.CLIP_RHO_ZZ) THEN
         CYCLE SPECIES_LOOP
      ELSE
         CLIP_RHO_ZZ_SAVE = .TRUE.
      ENDIF

      ! 2. Assign excess/deficit RHO_ZZ neighboring cells
      IF (PREDICTOR) THEN
         DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
            CC => CUT_CELL(ICC)
            IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
            DO JCC=1,CC%NCELL; CC%ZZS(N,JCC) = MIN(CC%RHOS(JCC),MAX(RHO_ZZ_MIN,CC%ZZS(N,JCC)+CC%DELTA_RHO_ZZ(JCC))); ENDDO
         ENDDO
      ELSE
         DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
            CC => CUT_CELL(ICC)
            IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
            DO JCC=1,CC%NCELL; CC%ZZ(N,JCC)  = MIN(CC%RHO(JCC), MAX(RHO_ZZ_MIN,CC%ZZ(N,JCC) +CC%DELTA_RHO_ZZ(JCC))); ENDDO
         ENDDO
      ENDIF
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               RHO_ZZ(I,J,K,N) = MIN(RHOP(I,J,K),MAX(RHO_ZZ_MIN,RHO_ZZ(I,J,K,N)+DELTA_RHO_ZZ(I,J,K)))
            ENDDO
         ENDDO
      ENDDO

   ENDDO SPECIES_LOOP

   ! If nothing has been clipped, return

   IF (.NOT.CLIP_RHOMIN_CC .AND. .NOT.CLIP_RHOMAX_CC .AND. .NOT.CLIP_RHO_ZZ_SAVE) THEN
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (CELL(CELL_INDEX(I,J,K))%SOLID .OR. CCVAR(I,J,K,CC_CGSC)/=CC_GASPHASE)  CYCLE
               IF (MESHES(NM)%CCVAR(I,J,K,CC_UNKZ) <= 0) &
                  RHO_ZZ(I,J,K,1:N_TRACKED_SPECIES) = RHO_ZZ(I,J,K,1:N_TRACKED_SPECIES)/RHOP(I,J,K)
            ENDDO
         ENDDO
      ENDDO
      CYCLE MESH_LOOP
   ENDIF

   ! Final check of RHO_ZZ => SUM(RHO_ZZ) = RHO
   IF (PREDICTOR) THEN
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         CC => CUT_CELL(ICC)
         IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
         DO JCC=1,CC%NCELL
            SUM_RHO_ZZ = SUM(CC%ZZS(1:N_TRACKED_SPECIES,JCC))
            N = MAXLOC(CC%ZZS(1:N_TRACKED_SPECIES,JCC),1)
            RHO_ZZ_TEST = CC%ZZS(N,JCC) + CC%RHOS(JCC) - SUM_RHO_ZZ
            IF (RHO_ZZ_TEST<0._EB .OR. RHO_ZZ_TEST>CC%RHOS(JCC)) THEN  ! Renormalize the original set of RHO_ZZ
               CC%ZZS(1:N_TRACKED_SPECIES,JCC) = CC%RHOS(JCC) * CC%ZZS(1:N_TRACKED_SPECIES,JCC)/SUM_RHO_ZZ
            ELSE  ! Absorb mass deficit/excess into largest RHO_ZZ
               CC%ZZS(N,JCC) = RHO_ZZ_TEST
            ENDIF
         ENDDO
      ENDDO
   ELSE
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         CC => CUT_CELL(ICC)
         IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
         DO JCC=1,CC%NCELL
            SUM_RHO_ZZ = SUM(CC%ZZ(1:N_TRACKED_SPECIES,JCC))
            N = MAXLOC(CC%ZZ(1:N_TRACKED_SPECIES,JCC),1)
            RHO_ZZ_TEST = CC%ZZ(N,JCC) + CC%RHO(JCC) - SUM_RHO_ZZ
            IF (RHO_ZZ_TEST<0._EB .OR. RHO_ZZ_TEST>CC%RHO(JCC)) THEN  ! Renormalize the original set of RHO_ZZ
               CC%ZZ(1:N_TRACKED_SPECIES,JCC) = CC%RHO(JCC) * CC%ZZ(1:N_TRACKED_SPECIES,JCC)/SUM_RHO_ZZ
            ELSE  ! Absorb mass deficit/excess into largest RHO_ZZ
               CC%ZZ(N,JCC) = RHO_ZZ_TEST
            ENDIF
         ENDDO
      ENDDO
   ENDIF
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CELL(CELL_INDEX(I,J,K))%SOLID .OR. CCVAR(I,J,K,CC_CGSC)/=CC_GASPHASE) CYCLE
            SUM_RHO_ZZ = SUM(RHO_ZZ(I,J,K,1:N_TRACKED_SPECIES))
            N = MAXLOC(RHO_ZZ(I,J,K,1:N_TRACKED_SPECIES),1)
            RHO_ZZ_TEST = RHO_ZZ(I,J,K,N) + RHOP(I,J,K) - SUM_RHO_ZZ
            IF (RHO_ZZ_TEST<0._EB .OR. RHO_ZZ_TEST>RHOP(I,J,K)) THEN  ! Renormalize the original set of RHO_ZZ
               RHO_ZZ(I,J,K,1:N_TRACKED_SPECIES) = RHOP(I,J,K) * RHO_ZZ(I,J,K,1:N_TRACKED_SPECIES)/SUM_RHO_ZZ
            ELSE  ! Absorb mass deficit/excess into largest RHO_ZZ
               RHO_ZZ(I,J,K,N) = RHO_ZZ_TEST
            ENDIF
         ENDDO
      ENDDO
   ENDDO

   CALL CC_CV_RHOZZ_AVERAGE

   ! Bring back ZZ in regular gas cells from partial densities.
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CELL(CELL_INDEX(I,J,K))%SOLID .OR. CCVAR(I,J,K,CC_CGSC)/=CC_GASPHASE) CYCLE
            IF (MESHES(NM)%CCVAR(I,J,K,CC_UNKZ) <= 0) &
               RHO_ZZ(I,J,K,1:N_TRACKED_SPECIES) = RHO_ZZ(I,J,K,1:N_TRACKED_SPECIES)/RHOP(I,J,K)
         ENDDO
      ENDDO
   ENDDO

ENDDO MESH_LOOP

RETURN
CONTAINS

SUBROUTINE CC_CV_RHOZZ_AVERAGE

INTEGER :: IROW_LOC

! CV volumes:
RZ_ZS(:) = 0._EB
DO K=1,KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
         IROW_LOC = CCVAR(I,J,K,CC_UNKZ) - UNKZ_IND(NM_START)
         RZ_ZS(IROW_LOC) = RZ_ZS(IROW_LOC) + DX(I)*DY(J)*DZ(K) ! Here store volume in allocated RZ_ZS.
      ENDDO
   ENDDO
ENDDO
DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
   CC => CUT_CELL(ICC); IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
   DO JCC=1,CC%NCELL
      IROW_LOC = CC%UNKZ(JCC) - UNKZ_IND(NM_START)
      RZ_ZS(IROW_LOC) = RZ_ZS(IROW_LOC) + CC%VOLUME(JCC)
   ENDDO
ENDDO

! Loop species:
SPECIES_LOOP: DO N=1,N_TRACKED_SPECIES

   RZ_Z(:) = 0._EB
   ! Add to CV rhoZZ*Vol:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
            IROW_LOC = CCVAR(I,J,K,CC_UNKZ) - UNKZ_IND(NM_START)
            RZ_Z( IROW_LOC) = RZ_Z( IROW_LOC) + RHO_ZZ(I,J,K,N)*DX(I)*DY(J)*DZ(K) ! Known rho*zz
         ENDDO
      ENDDO
   ENDDO
   IF (PREDICTOR) THEN
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         CC => CUT_CELL(ICC); IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
         DO JCC=1,CC%NCELL
            IROW_LOC = CC%UNKZ(JCC) - UNKZ_IND(NM_START)
            RZ_Z(IROW_LOC)  = RZ_Z( IROW_LOC) + CC%ZZS(N,JCC) * CC%VOLUME(JCC) ! Contains rho*zz
         ENDDO
      ENDDO
   ELSE
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         CC => CUT_CELL(ICC); IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
         DO JCC=1,CC%NCELL
            IROW_LOC = CC%UNKZ(JCC) - UNKZ_IND(NM_START)
            RZ_Z(IROW_LOC)  = RZ_Z( IROW_LOC) + CC%ZZ(N,JCC) * CC%VOLUME(JCC) ! Contains rho*zz
         ENDDO
      ENDDO
   ENDIF

   ! Volume average:
   DO IROW_LOC=UNKZ_IND(NM)-UNKZ_IND(NM_START)+1,UNKZ_IND(NM)-UNKZ_IND(NM_START)+NUNKZ_LOC(NM)
      RZ_Z(IROW_LOC)  = RZ_Z( IROW_LOC) / RZ_ZS(IROW_LOC)
   ENDDO

   ! Back to cut/reg cell containers of rhoZZ:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
            RHO_ZZ(I,J,K,N) = RZ_Z(CCVAR(I,J,K,CC_UNKZ)-UNKZ_IND(NM_START))
         ENDDO
      ENDDO
   ENDDO
   IF (PREDICTOR) THEN
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         CC => CUT_CELL(ICC); IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
         DO JCC=1,CC%NCELL; CC%ZZS(N,JCC) = RZ_Z(CC%UNKZ(JCC)-UNKZ_IND(NM_START)); ENDDO
      ENDDO
   ELSE
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         CC => CUT_CELL(ICC); IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
         DO JCC=1,CC%NCELL; CC%ZZ(N,JCC) = RZ_Z(CC%UNKZ(JCC)-UNKZ_IND(NM_START)); ENDDO
      ENDDO
   ENDIF

ENDDO SPECIES_LOOP

RZ_ZS = 0._EB

END SUBROUTINE CC_CV_RHOZZ_AVERAGE

END SUBROUTINE CC_CHECK_MASS_DENSITY


! ------------------------------ GET_RHOZZ_CC_3D ---------------------------

SUBROUTINE GET_RHOZZ_CC_3D

! Local Variables:
INTEGER :: NM,N,I,J,K,ICC,JCC
REAL(EB), POINTER, DIMENSION(:,:,:)   :: RHOP=>NULL(),UP=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: ZZP=>NULL()
REAL(EB) :: VOLTOT
INTEGER :: NMX

! Loop meshes:
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   CALL POINT_TO_MESH(NM)
   IF (PREDICTOR) THEN
      RHOP => RHOS
      ZZP  => ZZS
      UP   => U

      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         CC => CUT_CELL(ICC)
         IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
         DO JCC=1,CC%NCELL
            ! Get rho = sum(rho*z_alpha)
            CC%RHOS(JCC) = SUM(CC%ZZS(1:N_TRACKED_SPECIES,JCC))

            IF (DEBUG_CC_SCALAR_TRANSPORT) THEN
               ! Check mass density for positivity
               IF ( (CC%RHOS(JCC)<RHOMIN) .OR. (CC%RHOS(JCC)>RHOMAX) ) THEN
                  WRITE(LU_ERR,*) 'GET_RHOZZ_CC_3D CC Pred:',ICC,JCC,', Vol Fraction=',&
                  CC%VOLUME(JCC)/(DX(CC%IJK(IAXIS))*DY(CC%IJK(JAXIS))*DZ(CC%IJK(KAXIS))),', UNK_Z=',CC%UNKZ(JCC)
                  WRITE(LU_ERR,*) 'CELL Location=',XC(CC%IJK(IAXIS)),YC(CC%IJK(JAXIS)),ZC(CC%IJK(KAXIS))
                  WRITE(LU_ERR,*) 'RHOP,MIN,MAX=',CC%RHOS(JCC),RHOMIN,RHOMAX
               ENDIF
            ENDIF

            ! Extract z from rho*z
            CC%ZZS(1:N_TOTAL_SCALARS,JCC) = CC%ZZS(1:N_TOTAL_SCALARS,JCC)/CC%RHOS(JCC)

            IF (DEBUG_CC_SCALAR_TRANSPORT) THEN
               ! Check bounds on z:
               DO N=1,N_TOTAL_SCALARS
                  IF ( (CC%ZZS(N,JCC)<(0._EB-GEOMEPS)) .OR. (CC%ZZS(N,JCC)>(1._EB+GEOMEPS)) ) THEN
                     WRITE(LU_ERR,*) 'GET_RHOZZ_CC_3D CC Pred:',ICC,JCC,N
                     WRITE(LU_ERR,*) 'ZZP=',CC%ZZS(N,JCC)
                  ENDIF
               ENDDO
            ELSE
               ! Some z_alpha might be slightly below zero (bounds overrun), assign -ve mass to most abundant species:
               ! Note rho = sum(rho*z_alpha), sum(z_alpha)=1 remain unchanged.
               NMX=MAXLOC(CC%ZZS(1:N_TRACKED_SPECIES,JCC),DIM=1)
               DO N=1,N_TRACKED_SPECIES
                  IF(N==NMX) CYCLE
                  IF ( CC%ZZS(N,JCC) < (0._EB-TWO_EPSILON_EB)) THEN
                     CC%ZZS(NMX,JCC) = CC%ZZS(NMX,JCC) + CC%ZZS(N,JCC)
                     CC%ZZS(N,JCC)   = 0._EB
                  ENDIF
               ENDDO
            ENDIF

            ! Clip passive scalars:
            IF (N_PASSIVE_SCALARS==0) CYCLE
            CC%ZZS(ZETA_INDEX,JCC) = MAX(0._EB,MIN(1._EB,CC%ZZS(ZETA_INDEX,JCC)))
         ENDDO

         ! Dump volume average scalar mass fraction and density to Cartesian container:
         I = CC%IJK(IAXIS); J = CC%IJK(JAXIS); K = CC%IJK(KAXIS)
         VOLTOT = SUM( CC%VOLUME(1:CC%NCELL) )
         RHOP(I,J,K) = SUM( CC%RHOS(1:CC%NCELL)*CC%VOLUME(1:CC%NCELL) )/VOLTOT
         DO N=1,N_TOTAL_SCALARS
            ZZP(I,J,K,N) = SUM( CC%ZZS(N,1:CC%NCELL)*CC%VOLUME(1:CC%NCELL) )/VOLTOT
         ENDDO

      ENDDO

   ELSE
      RHOP => RHO
      ZZP  => ZZ
      UP   => US

      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         CC => CUT_CELL(ICC)
         IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
         DO JCC=1,CC%NCELL
            ! Get rho = sum(rho*z_alpha)
            CC%RHO(JCC) = SUM(CC%ZZ(1:N_TRACKED_SPECIES,JCC))

            IF (DEBUG_CC_SCALAR_TRANSPORT) THEN
               ! Check mass density for positivity
               IF ( (CC%RHO(JCC)<RHOMIN) .OR. (CC%RHO(JCC)>RHOMAX) ) THEN
                  WRITE(LU_ERR,*) 'GET_RHOZZ_CC_3D CC Corr:',ICC,JCC,', Vol Fraction=',&
                  CC%VOLUME(JCC)/(DX(CC%IJK(IAXIS))*DY(CC%IJK(JAXIS))*DZ(CC%IJK(KAXIS))),', UNK_Z=',CC%UNKZ(JCC)
                  WRITE(LU_ERR,*) 'RHOP,MIN,MAX=',CC%RHO(JCC),RHOMIN,RHOMAX
               ENDIF
            ENDIF

            ! Extract z from rho*z
            CC%ZZ(1:N_TOTAL_SCALARS,JCC) = CC%ZZ(1:N_TOTAL_SCALARS,JCC)/CC%RHO(JCC)

            IF (DEBUG_CC_SCALAR_TRANSPORT) THEN
               ! Check bounds on z:
               DO N=1,N_TOTAL_SCALARS
                  IF ( (CC%ZZ(N,JCC)<(0._EB-GEOMEPS)) .OR. (CC%ZZ(N,JCC)>(1._EB+GEOMEPS)) ) THEN
                     WRITE(LU_ERR,*) 'GET_RHOZZ_CC_3D CC Corr:',ICC,JCC,N
                     WRITE(LU_ERR,*) 'ZZP=',CC%ZZ(N,JCC)
                  ENDIF
               ENDDO
            ELSE
               ! Some z_alpha might be slightly below zero (bounds overrun), assign -ve mass to most abundant species:
               ! Note rho = sum(rho*z_alpha), sum(z_alpha)=1 remain unchanged.
               NMX=MAXLOC(CC%ZZ(1:N_TRACKED_SPECIES,JCC),DIM=1)
               DO N=1,N_TRACKED_SPECIES
                  IF(N==NMX) CYCLE
                  IF ( CC%ZZ(N,JCC) < (0._EB-TWO_EPSILON_EB)) THEN
                     CC%ZZ(NMX,JCC) = CC%ZZ(NMX,JCC) + CC%ZZ(N,JCC)
                     CC%ZZ(N,JCC)   = 0._EB
                  ENDIF
               ENDDO
            ENDIF
            ! Clip passive scalars:
            IF (N_PASSIVE_SCALARS==0) CYCLE
            CC%ZZ(ZETA_INDEX,JCC) = MAX(0._EB,MIN(1._EB,CC%ZZ(ZETA_INDEX,JCC)))
         ENDDO

         ! Dump volume average scalar mass fraction and density to Cartesian container:
         I = CC%IJK(IAXIS); J = CC%IJK(JAXIS); K = CC%IJK(KAXIS)
         VOLTOT = SUM( CC%VOLUME(1:CC%NCELL) )
         RHOP(I,J,K) = SUM( CC%RHO(1:CC%NCELL)*CC%VOLUME(1:CC%NCELL) )/VOLTOT
         DO N=1,N_TOTAL_SCALARS
            ZZP(I,J,K,N) = SUM( CC%ZZ(N,1:CC%NCELL)*CC%VOLUME(1:CC%NCELL) )/VOLTOT
         ENDDO

      ENDDO

   ENDIF

   ! Regular Cartesian cells:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (MESHES(NM)%CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE ! Cycle Reg cells not in cc-region, cut-cells
                                                             ! underlying Cartesian cells and
                                                             ! solid cells.

            ! Get rho = sum(rho*z_alpha)
            RHOP(I,J,K) = SUM(ZZP(I,J,K,1:N_TRACKED_SPECIES))

            ! Check mass density for positivity
            IF (DEBUG_CC_SCALAR_TRANSPORT) THEN
               IF ((RHOP(I,J,K)<RHOMIN) .OR. (RHOP(I,J,K)>RHOMAX) ) THEN
                  WRITE(LU_ERR,*) 'GET_RHOZZ_CC_3D Cart:',I,J,K
                  WRITE(LU_ERR,*) 'RHOP,MIN,MAX=',RHOP(I,J,K),RHOMIN,RHOMAX
               ENDIF
            ENDIF

            ! Extract z from rho*z
            ZZP(I,J,K,1:N_TOTAL_SCALARS) = ZZP(I,J,K,1:N_TOTAL_SCALARS)/RHOP(I,J,K)

            IF (DEBUG_CC_SCALAR_TRANSPORT) THEN
               ! Check bounds on z:
               DO N=1,N_TOTAL_SCALARS
                  IF (ZZP(I,J,K,N)<(0._EB-GEOMEPS) .OR. ZZP(I,J,K,N)>(1._EB+GEOMEPS)) THEN
                     WRITE(LU_ERR,*) 'GET_RHOZZ_CC_3D Cart:',I,J,K,N
                     WRITE(LU_ERR,*) 'ZZP=',ZZP(I,J,K,N)
                  ENDIF
               ENDDO
            ELSE
               ! Some z_alpha might be slightly below zero (bounds overrun), assign -ve mass to most abundant species:
               ! Note rho = sum(rho*z_alpha), sum(z_alpha)=1 remain unchanged.
               NMX=MAXLOC(ZZP(I,J,K,1:N_TRACKED_SPECIES),DIM=1)
               DO N=1,N_TRACKED_SPECIES
                  IF(N==NMX) CYCLE
                  IF ( ZZP(I,J,K,N) < (0._EB-TWO_EPSILON_EB)) THEN
                     ZZP(I,J,K,NMX) = ZZP(I,J,K,NMX) + ZZP(I,J,K,N)
                     ZZP(I,J,K,N)   = 0._EB
                  ENDIF
               ENDDO
            ENDIF
            ! Clip passive scalars:
            IF (N_PASSIVE_SCALARS==0) CYCLE
            ZZP(I,J,K,ZETA_INDEX) = MAX(0._EB,MIN(1._EB,ZZP(I,J,K,ZETA_INDEX)))

         ENDDO
      ENDDO
   ENDDO

ENDDO MESH_LOOP

RETURN
END SUBROUTINE GET_RHOZZ_CC_3D


! --------------------------- PUT_RHOZZVECTOR_SCALAR_3D --------------------------

SUBROUTINE PUT_RHOZZVECTOR_SCALAR_3D(N)

INTEGER, INTENT(IN) :: N

! Local Variables:
INTEGER :: NM,I,J,K,IROW_LOC,ICC,JCC
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: ZZP=>NULL()

! Loop meshes:
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   CALL POINT_TO_MESH(NM)
   IF (PREDICTOR) THEN
      ZZP  => ZZS ! Copy rho*z obtained for species N in the end of substep container for z.
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         CC => CUT_CELL(ICC); IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
         DO JCC=1,CC%NCELL
            IROW_LOC      = CC%UNKZ(JCC) - UNKZ_IND(NM_START)
            CC%ZZS(N,JCC) = RZ_Z(IROW_LOC)
         ENDDO
      ENDDO
   ELSE
      ZZP  => ZZ  ! Copy rho*z obtained for species N in the end of substep container for z.
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         CC => CUT_CELL(ICC); IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
         DO JCC=1,CC%NCELL
            IROW_LOC     = CC%UNKZ(JCC) - UNKZ_IND(NM_START)
            CC%ZZ(N,JCC) = RZ_Z(IROW_LOC)
         ENDDO
      ENDDO
   ENDIF

   ! Loop on Cartesian Cells:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
            IROW_LOC     = CCVAR(I,J,K,CC_UNKZ) - UNKZ_IND(NM_START)
            ZZP(I,J,K,N) = RZ_Z(IROW_LOC)
         ENDDO
      ENDDO
   ENDDO

ENDDO MESH_LOOP

RETURN
END SUBROUTINE PUT_RHOZZVECTOR_SCALAR_3D


! --------------------------- GET_RHOZZVECTOR_SCALAR_3D --------------------------

SUBROUTINE GET_RHOZZVECTOR_SCALAR_3D(N)

INTEGER, INTENT(IN) :: N

! Local Variables:
INTEGER :: NM,I,J,K,IROW_LOC,ICC,JCC

! Initialize rho*z:
RZ_Z(:) = 0._EB
RZ_ZS(:) = 0._EB

! Loop meshes:
PREDCORR_IF : IF (PREDICTOR) THEN
   MESH_LOOP_P : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      CALL POINT_TO_MESH(NM)
      ! Loop on Cartesian Cells:
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
               IROW_LOC = CCVAR(I,J,K,CC_UNKZ) - UNKZ_IND(NM_START)
               RZ_ZS(IROW_LOC) = RZ_ZS(IROW_LOC) + DX(I)*DY(J)*DZ(K) ! Here store volume in allocated RZ_ZS.
               RZ_Z( IROW_LOC) = RZ_Z( IROW_LOC) + RHO(I,J,K)*ZZ(I,J,K,N)*DX(I)*DY(J)*DZ(K) ! Known rho*zz^n
            ENDDO
         ENDDO
      ENDDO
      ! Now loop Cut-cells:
      CUTCELL_LOOP : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         CC => CUT_CELL(ICC); IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
         DO JCC=1,CC%NCELL
            IROW_LOC = CC%UNKZ(JCC) - UNKZ_IND(NM_START)
            RZ_ZS(IROW_LOC) = RZ_ZS(IROW_LOC) + CC%VOLUME(JCC)
            RZ_Z(IROW_LOC)  = RZ_Z( IROW_LOC) + CC%RHO(JCC) * CC%ZZ(N,JCC) * CC%VOLUME(JCC)
         ENDDO
      ENDDO CUTCELL_LOOP
   ENDDO MESH_LOOP_P
   ! Volume average:
   DO IROW_LOC=1,NUNKZ_LOCAL
      RZ_Z(IROW_LOC)  = RZ_Z( IROW_LOC) / RZ_ZS(IROW_LOC)
   ENDDO
   RZ_ZS = 0._EB

ELSE PREDCORR_IF

   MESH_LOOP_C : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      CALL POINT_TO_MESH(NM)
      ! Loop on Cartesian Cells:
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE
               IROW_LOC = CCVAR(I,J,K,CC_UNKZ) - UNKZ_IND(NM_START)
               RZ_Z(IROW_LOC) = 0.5_EB*(MESHES(NM)%RHO_ZZN(I,J,K,N)+RHOS(I,J,K)*ZZS(I,J,K,N))
               RZ_ZS(IROW_LOC)= RHOS(I,J,K)*ZZS(I,J,K,N)
            ENDDO
         ENDDO
      ENDDO
      ! Now loop Cut-cells:
      CUTCELL_LOOP2 : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         CC => CUT_CELL(ICC); IF (CELL(CELL_INDEX(CC%IJK(IAXIS),CC%IJK(JAXIS),CC%IJK(KAXIS)))%SOLID) CYCLE
         DO JCC=1,CC%NCELL
            IROW_LOC = CC%UNKZ(JCC) - UNKZ_IND(NM_START)
            RZ_Z(IROW_LOC) = 0.5_EB*(CC%RHO(JCC) * CC%ZZ(N,JCC) + CC%RHOS(JCC) * CC%ZZS(N,JCC))
            RZ_ZS(IROW_LOC)= CC%RHOS(JCC) * CC%ZZS(N,JCC)
         ENDDO
      ENDDO CUTCELL_LOOP2
   ENDDO MESH_LOOP_C

ENDIF PREDCORR_IF

RETURN
END SUBROUTINE GET_RHOZZVECTOR_SCALAR_3D


! ------------------------- GET_ADVDIFFVECTOR_SCALAR_3D -------------------------

SUBROUTINE GET_ADVDIFFVECTOR_SCALAR_3D(N)

INTEGER, INTENT(IN) :: N

! Local Variables:
INTEGER :: NM,I,J,K
REAL(EB):: PRFCT
INTEGER :: X1AXIS,IFACE,IND(LOW_IND:HIGH_IND),IND_LOC(LOW_IND:HIGH_IND),ICF,IND1,IND2,IOR
INTEGER :: LOCROW_1,LOCROW_2,ILOC,IROW,ICC,JCC,IW
REAL(EB):: AF,VELC,RHO_Z,FN_ZZ,FCT
REAL(EB), POINTER, DIMENSION(:,:,:)  :: RHOP=>NULL(),UP=>NULL(),VP=>NULL(),WP=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:,:)::  ZZP=>NULL()
TYPE(CC_REGFACEZ_TYPE),  POINTER, DIMENSION(:) :: REGFACE_Z=>NULL()
LOGICAL :: DO_LO,DO_HI

! This routine computes RHS due to boundary conditions prescribed in immersed solids
! and domain boundaries.

! First Domain Boundaries:
! Mesh Loop, Advective Fluxes:
MESH_LOOP_DBND : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN
      ZZP  => ZZ
      RHOP => RHO
      UP   => U
      VP   => V
      WP   => W
      PRFCT= 1._EB
   ELSE
      ZZP  => ZZS
      RHOP => RHOS
      UP   => US
      VP   => VS
      WP   => WS
      PRFCT= 0._EB
   ENDIF

   ! X direction bounds:
   ILO_FACE = 0                    ! Low mesh boundary face index.
   IHI_FACE = IBAR                 ! High mesh boundary face index.

   ! Y direction bounds:
   JLO_FACE = 0                    ! Low mesh boundary face index.
   JHI_FACE = JBAR                 ! High mesh boundary face index.

   ! Z direction bounds:
   KLO_FACE = 0                    ! Low mesh boundary face index.
   KHI_FACE = KBAR                 ! High mesh boundary face index.

   ! First add advective fluxes to domain boundary regular and cut-cells:
   ! IAXIS faces:
   X1AXIS = IAXIS
   REGFACE_Z => CC_REGFACE_IAXIS_Z
   DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
      IW = REGFACE_Z(IFACE)%IWC; IF(IW<1) CYCLE; WC => WALL(IW)
      IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
      I    = REGFACE_Z(IFACE)%IJK(IAXIS)
      J    = REGFACE_Z(IFACE)%IJK(JAXIS)
      K    = REGFACE_Z(IFACE)%IJK(KAXIS)
      DO_LO= REGFACE_Z(IFACE)%DO_LO_IND
      DO_HI= REGFACE_Z(IFACE)%DO_HI_IND
      ! Unknowns on related cells:
      IND_LOC(LOW_IND) = CCVAR(I  ,J,K,CC_UNKZ) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= CCVAR(I+1,J,K,CC_UNKZ) - UNKZ_IND(NM_START)

      AF = DY(J)*DZ(K)
      IF (DO_LO) F_Z(IND_LOC( LOW_IND)) = F_Z(IND_LOC( LOW_IND)) + REGFACE_Z(IFACE)%RHOZZ_U(N)*AF
      IF (DO_HI) F_Z(IND_LOC(HIGH_IND)) = F_Z(IND_LOC(HIGH_IND)) - REGFACE_Z(IFACE)%RHOZZ_U(N)*AF
   ENDDO

   ! JAXIS faces:
   X1AXIS = JAXIS
   REGFACE_Z => CC_REGFACE_JAXIS_Z
   DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
      IW = REGFACE_Z(IFACE)%IWC; IF(IW<1) CYCLE; WC => WALL(IW)
      IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
      I     = REGFACE_Z(IFACE)%IJK(IAXIS)
      J     = REGFACE_Z(IFACE)%IJK(JAXIS)
      K     = REGFACE_Z(IFACE)%IJK(KAXIS)
      DO_LO = REGFACE_Z(IFACE)%DO_LO_IND
      DO_HI = REGFACE_Z(IFACE)%DO_HI_IND
      ! Unknowns on related cells:
      IND_LOC(LOW_IND) = CCVAR(I,J  ,K,CC_UNKZ) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= CCVAR(I,J+1,K,CC_UNKZ) - UNKZ_IND(NM_START)

      AF = DX(I)*DZ(K)
      IF (DO_LO) F_Z(IND_LOC( LOW_IND)) = F_Z(IND_LOC( LOW_IND)) + REGFACE_Z(IFACE)%RHOZZ_U(N)*AF
      IF (DO_HI) F_Z(IND_LOC(HIGH_IND)) = F_Z(IND_LOC(HIGH_IND)) - REGFACE_Z(IFACE)%RHOZZ_U(N)*AF
   ENDDO

   ! KAXIS faces:
   X1AXIS = KAXIS
   REGFACE_Z => CC_REGFACE_KAXIS_Z
   DO IFACE=1,MESHES(NM)%CC_NREGFACE_Z(X1AXIS)
      IW = REGFACE_Z(IFACE)%IWC; IF(IW<1) CYCLE; WC => WALL(IW)
      IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
      I     = REGFACE_Z(IFACE)%IJK(IAXIS)
      J     = REGFACE_Z(IFACE)%IJK(JAXIS)
      K     = REGFACE_Z(IFACE)%IJK(KAXIS)
      DO_LO = REGFACE_Z(IFACE)%DO_LO_IND
      DO_HI = REGFACE_Z(IFACE)%DO_HI_IND
      ! Unknowns on related cells:
      IND_LOC(LOW_IND) = CCVAR(I,J,K  ,CC_UNKZ) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= CCVAR(I,J,K+1,CC_UNKZ) - UNKZ_IND(NM_START)

      AF = DX(I)*DY(J)
      IF (DO_LO) F_Z(IND_LOC( LOW_IND)) = F_Z(IND_LOC( LOW_IND)) + REGFACE_Z(IFACE)%RHOZZ_U(N)*AF
      IF (DO_HI) F_Z(IND_LOC(HIGH_IND)) = F_Z(IND_LOC(HIGH_IND)) - REGFACE_Z(IFACE)%RHOZZ_U(N)*AF
   ENDDO

   ! Boundary Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
   IFACE_LOOP_RCF1: DO IFACE=1,MESHES(NM)%CC_NRCFACE_Z

      IW=MESHES(NM)%RC_FACE(IFACE)%IWC
      WC=>WALL(IW); IF ( WC%BOUNDARY_TYPE==NULL_BOUNDARY ) CYCLE IFACE_LOOP_RCF1
      B1 => BOUNDARY_PROP1(WC%B1_INDEX)
      BC => BOUNDARY_COORD(WC%BC_INDEX)

      I      = MESHES(NM)%RC_FACE(IFACE)%IJK(IAXIS)
      J      = MESHES(NM)%RC_FACE(IFACE)%IJK(JAXIS)
      K      = MESHES(NM)%RC_FACE(IFACE)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%RC_FACE(IFACE)%IJK(KAXIS+1)

      ! Unknowns on related cells:
      IND(LOW_IND)  = MESHES(NM)%RC_FACE(IFACE)%UNKZ(LOW_IND)
      IND(HIGH_IND) = MESHES(NM)%RC_FACE(IFACE)%UNKZ(HIGH_IND)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND

      IOR = BC%IOR
      ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ILOC=1,
      !                              when sign of IOR is  1 -> use High Side cell -> ILOC=2.
      ILOC = 1 + (SIGN(1,IOR)+1) / 2
      ! First (rho hs)_i,j,k:
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         AF = DY(J)*DZ(K)
         VELC = UP(I,J,K)
      CASE(JAXIS)
         AF = DX(I)*DZ(K)
         VELC = VP(I,J,K)
      CASE(KAXIS)
         AF = DX(I)*DY(J)
         VELC = WP(I,J,K)
      END SELECT
      FN_ZZ           = B1%RHO_F*B1%ZZ_F(N) ! These have been Flux limited in wall.f90
      SELECT CASE(WC%BOUNDARY_TYPE)
         CASE DEFAULT
            ! Already filled in previous X1AXIS select case.
         CASE(SOLID_BOUNDARY)
            IF (PREDICTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*B1%U_NORMAL_S
            IF (CORRECTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*B1%U_NORMAL
         CASE(INTERPOLATED_BOUNDARY)
            VELC = UVW_SAVE(IW)
      END SELECT

      IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
      FCT = REAL(3-2*ILOC,EB)
      F_Z(IROW) = F_Z(IROW) + FCT*FN_ZZ*VELC*AF

   ENDDO IFACE_LOOP_RCF1

   ! Now Boundary Gasphase CUT_FACES:
   ICF_LOOP1: DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
      IF ( MESHES(NM)%CUT_FACE(ICF)%STATUS /= CC_GASPHASE ) CYCLE ICF_LOOP1
      IW=MESHES(NM)%CUT_FACE(ICF)%IWC
      WC=>WALL(IW); IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY ) CYCLE ICF_LOOP1
      B1 => BOUNDARY_PROP1(WC%B1_INDEX)
      BC    => BOUNDARY_COORD(WC%BC_INDEX)
      IOR = BC%IOR
      FN_ZZ           = B1%RHO_F*B1%ZZ_F(N) ! These have been Flux limited in wall.f90
      ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ILOC=1,
      !                              when sign of IOR is  1 -> use High Side cell -> ILOC=2 .
      ILOC = 1 + (SIGN(1,IOR)+1) / 2
      FCT  = REAL(3-2*ILOC,EB)
      DO IFACE=1,CUT_FACE(ICF)%NFACE
         AF   = CUT_FACE(ICF)%AREA(IFACE)
         IF(WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) THEN
            VELC = CUT_FACE(ICF)%VEL_SAVE(IFACE)
         ELSE
            VELC = PRFCT*CUT_FACE(ICF)%VEL(IFACE) + (1._EB-PRFCT)*CUT_FACE(ICF)%VELS(IFACE)
         ENDIF
         ! Unknowns on related cells:
         IND_LOC(ILOC) = MESHES(NM)%CUT_FACE(ICF)%UNKZ(ILOC,IFACE) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
         ! First (rho hs)_i,j,k:
         IF (CUT_FACE(ICF)%CELL_LIST(1,ILOC,IFACE) == CC_FTYPE_CFGAS) THEN
            IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
            F_Z(IROW) = F_Z(IROW) + FCT*FN_ZZ*VELC*AF
         ENDIF
      ENDDO ! IFACE

   ENDDO ICF_LOOP1

   ! INBOUNDARY cut-faces, loop on CFACE to add BC defined at SOLID phase:
   DO ICF=INTERNAL_CFACE_CELLS_LB+1,INTERNAL_CFACE_CELLS_LB+N_INTERNAL_CFACE_CELLS
      CFA  => CFACE(ICF)
      B1 => BOUNDARY_PROP1(CFA%B1_INDEX)
      IND1 = CFA%CUT_FACE_IND1;                         IND2 = CFA%CUT_FACE_IND2
      ICC  = CUT_FACE(IND1)%CELL_LIST(2,LOW_IND,IND2);  JCC  = CUT_FACE(IND1)%CELL_LIST(3,LOW_IND,IND2)
      IROW = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
      IF (PREDICTOR) THEN
         VELC = B1%U_NORMAL
      ELSE
         VELC = B1%U_NORMAL_S
      ENDIF
      IF (VELC>0._EB) THEN
         RHO_Z = PRFCT *CUT_CELL(ICC)% RHO(JCC)*CUT_CELL(ICC)% ZZ(N,JCC) + &
          (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)*CUT_CELL(ICC)%ZZS(N,JCC)
      ELSE
         RHO_Z = B1%RHO_F*B1%ZZ_F(N)
      ENDIF
      F_Z(IROW) = F_Z(IROW) + RHO_Z*VELC*CFA%AREA
   ENDDO

   ! Then add diffusive fluxes through domain boundaries:
   ! Defined in CC_DIVERGENCE_PART_1.

ENDDO MESH_LOOP_DBND

RETURN
END SUBROUTINE GET_ADVDIFFVECTOR_SCALAR_3D


! ---------------------------- CC_VELOCITY_BC -------------------------------

SUBROUTINE CC_VELOCITY_BC(T,NM,APPLY_TO_ESTIMATED_VARIABLES,DO_IBEDGES)

USE TURBULENCE, ONLY : WALL_MODEL
USE PHYSICAL_FUNCTIONS, ONLY: GET_VISCOSITY
REAL(EB), INTENT(IN) :: T
INTEGER, INTENT(IN) :: NM
LOGICAL, INTENT(IN) :: APPLY_TO_ESTIMATED_VARIABLES, DO_IBEDGES

! Local Variables:
INTEGER :: IEDGE,EP,INPE,VIND
INTEGER :: I,J,K,II,JJ,KK,ICF,X1AXIS,IE,IEC,I_SGN,ICD,ICD_SGN,IIF,JJF,KKF,FAXIS,ICDO,ICDO_SGN,IS
REAL(EB), ALLOCATABLE, DIMENSION(:,:,:) :: UVW_EP
REAL(EB), ALLOCATABLE, DIMENSION(:,:,:,:) :: DUVW_EP
REAL(EB), POINTER, DIMENSION(:,:,:) :: UU=>NULL(),VV=>NULL(),WW=>NULL(),RHOP=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: ZZP=>NULL()
REAL(EB) :: NU,MU_FACE,RHO_FACE,DXN_STRM_UB,SLIP_FACTOR,SRGH,U_TAU,Y_PLUS,TNOW,MU_EP,MU_DUIDXJ_USE(2),DUIDXJ_USE(2),&
            DUIDXJ(-2:2),MU_DUIDXJ(-2:2),DXX(2),DF, DE, UE, UF, UB, A_CART, AREATOT, VEL_CART, PRFCT
TYPE(CC_EDGE_TYPE), POINTER :: CC_EDGE
TYPE(CC_CUTEDGE_TYPE), POINTER :: CE
LOGICAL :: IS_RCEDGE

TNOW = T
TNOW = CURRENT_TIME()

IF (APPLY_TO_ESTIMATED_VARIABLES) THEN
   UU   => US
   VV   => VS
   WW   => WS
   ZZP  => ZZS
   RHOP => RHOS
   PRFCT=  1._EB
ELSE
   UU   => U
   VV   => V
   WW   => W
   ZZP  => ZZ
   RHOP => RHO
   PRFCT=  0._EB
ENDIF

ALLOCATE(UVW_EP(IAXIS:KAXIS,0:INT_N_EXT_PTS,0:0))
ALLOCATE(DUVW_EP(IAXIS:KAXIS,IAXIS:KAXIS,0:INT_N_EXT_PTS,0:0))

! Ghost cut-face velocities:
! This is done for cut-faces that live in the first layer of ghost-cells, needed in VELOCITY_FLUX.
! Note approximation from cartesian face velocities which have been filled in MESH_EXCHANGE before CC_END_STEP.
CUTFACE_LOOP : DO ICF=MESHES(NM)%N_CUTFACE_MESH+1,MESHES(NM)%N_CUTFACE_MESH+MESHES(NM)%N_GCCUTFACE_MESH
   CF => CUT_FACE(ICF); IF (CF%STATUS /= CC_GASPHASE) CYCLE
   I  =  CF%IJK(IAXIS); IF(I<0 .OR. I>IBP1) CYCLE
   J  =  CF%IJK(JAXIS); IF(J<0 .OR. J>JBP1) CYCLE
   K  =  CF%IJK(KAXIS); IF(K<0 .OR. K>KBP1) CYCLE
   X1AXIS = CF%IJK(KAXIS+1); AREATOT= SUM(CF%AREA(1:CF%NFACE))
   SELECT CASE(X1AXIS)
   CASE(IAXIS); VEL_CART = UU(I,J,K); A_CART   = DY(J)*DZ(K)
   CASE(JAXIS); VEL_CART = VV(I,J,K); A_CART   = DZ(K)*DX(I)
   CASE(KAXIS); VEL_CART = WW(I,J,K); A_CART   = DX(I)*DY(J)
   END SELECT
   CF%VEL_CRT= VEL_CART; CF%VEL_CF = A_CART/AREATOT*VEL_CART
   IF (APPLY_TO_ESTIMATED_VARIABLES) THEN; CF%VELS(1:CF%NFACE) = CF%VEL_CF ! Assign to all cut-faces same velocity.
   ELSE;                                   CF%VEL(1:CF%NFACE)  = CF%VEL_CF
   ENDIF
ENDDO CUTFACE_LOOP

! Dump cut-face velocities in UU, VV, WW arrays in case of unstructured projection:
CALL CUTFACE_VELOCITIES(NM,UU,VV,WW,CUTFACES=.TRUE.)

! Compute initial DUIDXJ, MUDUIDXJ in RCEDGES:
IS_RCEDGE = .TRUE.
RCEDGE_LOOP_1 : DO IEDGE=1,MESHES(NM)%CC_NRCEDGE
   CC_EDGE => CC_RCEDGE(IEDGE)
   CALL CC_RCEDGE_DUIDXJ
ENDDO RCEDGE_LOOP_1

! Compute DUIDXJ in gas cut-edges:
CUTEDGE_LOOP_1 : DO IEDGE=1,MESHES(NM)%N_CUTEDGE_MESH
   CE => CUT_EDGE(IEDGE)
   CALL CC_CUTEDGE_DUIDXJ_TAU_OMG
ENDDO CUTEDGE_LOOP_1

! Wall Model to compute DUIDXJ, MUDUIDXJ in boundary B, extrapolate from External point and B to IBEDGE and compute TAU, OMG.
IF (DO_IBEDGES) THEN
   IS_RCEDGE = .FALSE.
   IBEDGE_LOOP_1 : DO IEDGE=1,MESHES(NM)%CC_NIBEDGE
      CC_EDGE => CC_IBEDGE(IEDGE)
      CALL CC_EDGE_TAU_OMG
   ENDDO IBEDGE_LOOP_1
ENDIF

! Recompute DUIDXJ, MUDUIDXJ in RCEDGES if needed:
IS_RCEDGE = .TRUE.
RCEDGE_LOOP_2 : DO IEDGE=1,MESHES(NM)%CC_NRCEDGE
   CC_EDGE => CC_RCEDGE(IEDGE)
   CALL CC_RCEDGE_TAU_OMG
ENDDO RCEDGE_LOOP_2

! Retrieve cartesian velocities in UU, VV, WW arrays in case of unstructured projection:
CALL CUTFACE_VELOCITIES(NM,UU,VV,WW,CUTFACES=.FALSE.)

DEALLOCATE(UVW_EP,DUVW_EP)

T_USED(14) = T_USED(14) + CURRENT_TIME() - TNOW

RETURN

CONTAINS

SUBROUTINE CC_CUTEDGE_DUIDXJ_TAU_OMG

INTEGER :: IOE,X1AXIS,X2AXIS,X3AXIS,X1BAR,X2BAR,X3BAR,ICF,JCF,JEDGE
REAL(EB):: VEL_GAS(-2:2),MU_RC
INTEGER, PARAMETER :: ICDOV(1:2) = (/2,1/)

! Drop non gasphase or ghost-cell cut-edges.
IF (CE%STATUS/=CC_GASPHASE .OR. TWO_D .OR. CE%IE==0) RETURN
X1AXIS=CE%IJK(KAXIS+1)
SELECT CASE(X1AXIS)
CASE(IAXIS); X1BAR=IBAR; X2AXIS=JAXIS; X2BAR=JBAR; X3AXIS=KAXIS; X3BAR=KBAR
CASE(JAXIS); X1BAR=JBAR; X2AXIS=KAXIS; X2BAR=KBAR; X3AXIS=IAXIS; X3BAR=IBAR
CASE(KAXIS); X1BAR=KBAR; X2AXIS=IAXIS; X2BAR=IBAR; X3AXIS=JAXIS; X3BAR=JBAR
END SELECT
IF(CE%IJK(X1AXIS)<1 .OR. CE%IJK(X1AXIS)>X1BAR) RETURN
IF(CE%IJK(X2AXIS)<0 .OR. CE%IJK(X2AXIS)>X2BAR) RETURN
IF(CE%IJK(X3AXIS)<0 .OR. CE%IJK(X3AXIS)>X3BAR) RETURN

IE     = CE%IE
II     = EDGE(IE)%I
JJ     = EDGE(IE)%J
KK     = EDGE(IE)%K
IEC    = EDGE(IE)%AXIS

! We Keep viscosity outside of JEDGE loop for the moment.
SELECT CASE(IEC)
   CASE(IAXIS); MU_RC = 0.25_EB*(MU(II,JJ,KK)+MU(II,JJ+1,KK)+MU(II,JJ+1,KK+1)+MU(II,JJ,KK+1))
   CASE(JAXIS); MU_RC = 0.25_EB*(MU(II,JJ,KK)+MU(II+1,JJ,KK)+MU(II+1,JJ,KK+1)+MU(II,JJ,KK+1))
   CASE(KAXIS); MU_RC = 0.25_EB*(MU(II,JJ,KK)+MU(II+1,JJ,KK)+MU(II+1,JJ+1,KK)+MU(II,JJ+1,KK))
END SELECT

DO JEDGE=1,CE%NEDGE
   VEL_GAS(-2:2) = 0._EB
   ORIENTATION_LOOP: DO IS=1,3
      IF (IS==IEC) CYCLE ORIENTATION_LOOP
      SIGN_LOOP: DO I_SGN=-1,1,2
         ! Determine Index_Coordinate_Direction
         ! IEC=1, ICD=1 refers to DWDY; ICD=2 refers to DVDZ
         ! IEC=2, ICD=1 refers to DUDZ; ICD=2 refers to DWDX
         ! IEC=3, ICD=1 refers to DVDX; ICD=2 refers to DUDY
         IF (IS>IEC) ICD = IS-IEC
         IF (IS<IEC) ICD = IS-IEC+3
         ICD_SGN = I_SGN * ICD

         ICF = CE%FACE_LIST(1,ICD_SGN,JEDGE) ! Only one gas cut-edge per cartesian edge.
         JCF = CE%FACE_LIST(2,ICD_SGN,JEDGE)
         IF(ICF>0) VEL_GAS(ICD_SGN) = PRFCT*CUT_FACE(ICF)%VELS(JCF) + (1._EB-PRFCT)*CUT_FACE(ICF)%VEL(JCF)
      ENDDO SIGN_LOOP
   ENDDO ORIENTATION_LOOP

   ! IEC = IAXIS : DWDY (IOE=1), DVDZ (IOE=2):
   ! IEC = JAXIS : DUDZ (IOE=1), DWDX (IOE=2):
   ! IEC = KAXIS : DUDY (IOE=1), DVDX (IOE=2):
   DO IOE = 1,2
      CE%DUIDXJ((/-IOE,IOE/),JEDGE)    = (VEL_GAS(IOE)-VEL_GAS(-IOE))/CE%DXX(IOE,JEDGE)
      CE%MU_DUIDXJ((/-IOE,IOE/),JEDGE) = MU_RC*CE%DUIDXJ((/-IOE,IOE/),JEDGE)
   ENDDO
ENDDO

! For TAU OMGGA on the whole cartesian edge use value of JEDGE=1. Note this would be changed when each cut-edge
! contributes to corresponfing cut-faces forces (completely unstructured momentum).
JEDGE=1
SIGN_LOOP_2: DO I_SGN=-1,1,2
   ORIENTATION_LOOP_2: DO ICD=1,2
      ICDO = ICDOV(ICD)
      ICD_SGN = I_SGN*ICD
         DUIDXJ_USE(ICD) =     CE%DUIDXJ(ICD_SGN,JEDGE)
      MU_DUIDXJ_USE(ICD) =  CE%MU_DUIDXJ(ICD_SGN,JEDGE)
      ICDO_SGN = I_SGN*ICDO
         DUIDXJ_USE(ICDO)=    CE%DUIDXJ(ICDO_SGN,JEDGE)
      MU_DUIDXJ_USE(ICDO)= CE%MU_DUIDXJ(ICDO_SGN,JEDGE)
      EDGE(IE)%OMEGA(ICD_SGN) = DUIDXJ_USE(1) -    DUIDXJ_USE(2)
      EDGE(IE)%TAU(ICD_SGN)   = MU_DUIDXJ_USE(1) + MU_DUIDXJ_USE(2)
   ENDDO ORIENTATION_LOOP_2
ENDDO SIGN_LOOP_2

END SUBROUTINE CC_CUTEDGE_DUIDXJ_TAU_OMG


SUBROUTINE CC_RCEDGE_DUIDXJ

INTEGER :: IOE
REAL(EB):: VEL_GAS(-2:2),XB_IB(-2:2),MU_RC,DEL_RC

IE  = CC_EDGE%IE
II  = EDGE(IE)%I
JJ  = EDGE(IE)%J
KK  = EDGE(IE)%K
IEC = EDGE(IE)%AXIS

VEL_GAS(-2:2) = 0._EB; XB_IB(-2:2) = 0._EB
ORIENTATION_LOOP: DO IS=1,3
   IF (IS==IEC) CYCLE ORIENTATION_LOOP
   SIGN_LOOP: DO I_SGN=-1,1,2

      ! Determine Index_Coordinate_Direction
      ! IEC=1, ICD=1 refers to DWDY; ICD=2 refers to DVDZ
      ! IEC=2, ICD=1 refers to DUDZ; ICD=2 refers to DWDX
      ! IEC=3, ICD=1 refers to DVDX; ICD=2 refers to DUDY

      IF (IS>IEC) ICD = IS-IEC
      IF (IS<IEC) ICD = IS-IEC+3
      ICD_SGN = I_SGN * ICD

      ! With ICD_SGN check if face:
      ! IBEDGE IEC=IAXIS => ICD_SGN=-2 => FACE  low Z normal to JAXIS.
      !                     ICD_SGN=-1 => FACE  low Y normal to KAXIS.
      !                     ICD_SGN= 1 => FACE high Y normal to KAXIS.
      !                     ICD_SGN= 2 => FACE high Z normal to JAXIS.
      ! IBEDGE IEC=JAXIS => ICD_SGN=-2 => FACE  low X normal to KAXIS.
      !                     ICD_SGN=-1 => FACE  low Z normal to IAXIS.
      !                     ICD_SGN= 1 => FACE high Z normal to IAXIS.
      !                     ICD_SGN= 2 => FACE high X normal to KAXIS.
      ! IBEDGE IEC=KAXIS => ICD_SGN=-2 => FACE  low Y normal to IAXIS.
      !                     ICD_SGN=-1 => FACE  low X normal to JAXIS.
      !                     ICD_SGN= 1 => FACE high X normal to JAXIS.
      !                     ICD_SGN= 2 => FACE high Y normal to IAXIS.
      ! is GASPHASE cut-face.
      XB_IB(ICD_SGN) = CC_EDGE%XB_IB(ICD_SGN)
      IEC_SELECT: SELECT CASE(IEC)
         CASE(IAXIS)
            ! Define Face indexes and normal axis FAXIS.
            SELECT CASE(ICD_SGN)
               CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
               CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
               CASE( 1); IIF=II  ; JJF=JJ+1; KKF=KK  ; FAXIS=KAXIS
               CASE( 2); IIF=II  ; JJF=JJ  ; KKF=KK+1; FAXIS=JAXIS
            END SELECT
            !DXX(1)  = DY(JJF); DXX(2)  = DZ(KKF)
            IF (FAXIS==JAXIS) THEN
                VEL_GAS(ICD_SGN)   = VV(IIF,JJF,KKF)
            ELSE ! IF(FAXIS==KAXIS) THEN
                VEL_GAS(ICD_SGN)   = WW(IIF,JJF,KKF)
            ENDIF

         CASE(JAXIS)
            ! Define Face indexes and normal axis FAXIS.
            SELECT CASE(ICD_SGN)
               CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
               CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=IAXIS
               CASE( 1); IIF=II  ; JJF=JJ  ; KKF=KK+1; FAXIS=IAXIS
               CASE( 2); IIF=II+1; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
            END SELECT
            !DXX(1)  = DZ(KKF); DXX(2)  = DX(IIF)
            IF (FAXIS==KAXIS) THEN
               VEL_GAS(ICD_SGN)   = WW(IIF,JJF,KKF)
            ELSE ! IF(FAXIS==IAXIS) THEN
               VEL_GAS(ICD_SGN)   = UU(IIF,JJF,KKF)
            ENDIF

         CASE(KAXIS)
            ! Define Face indexes and normal axis FAXIS.
            SELECT CASE(ICD_SGN)
               CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=IAXIS
               CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
               CASE( 1); IIF=II+1; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
               CASE( 2); IIF=II  ; JJF=JJ+1; KKF=KK  ; FAXIS=IAXIS
            END SELECT
            !DXX(1)  = DX(IIF); DXX(2)  = DY(JJF)
            IF (FAXIS==IAXIS) THEN
               VEL_GAS(ICD_SGN)   = UU(IIF,JJF,KKF)
            ELSE ! IF(FAXIS==JAXIS) THEN
               VEL_GAS(ICD_SGN)   = VV(IIF,JJF,KKF)
            ENDIF

      END SELECT IEC_SELECT

      ! Divide distance to boundary (cut-face) or DXX (reg face) by 2 to get collocation point position:
      XB_IB(ICD_SGN) = XB_IB(ICD_SGN)/2._EB

   ENDDO SIGN_LOOP
ENDDO ORIENTATION_LOOP

SELECT CASE(IEC)
   CASE(IAXIS); MU_RC = 0.25_EB*(MU(II,JJ,KK)+MU(II,JJ+1,KK)+MU(II,JJ+1,KK+1)+MU(II,JJ,KK+1))
   CASE(JAXIS); MU_RC = 0.25_EB*(MU(II,JJ,KK)+MU(II+1,JJ,KK)+MU(II+1,JJ,KK+1)+MU(II,JJ,KK+1))
   CASE(KAXIS); MU_RC = 0.25_EB*(MU(II,JJ,KK)+MU(II+1,JJ,KK)+MU(II+1,JJ+1,KK)+MU(II,JJ+1,KK))
END SELECT

! IEC = IAXIS : DWDY (IOE=1), DVDZ (IOE=2):
! IEC = JAXIS : DUDZ (IOE=1), DWDX (IOE=2):
! IEC = KAXIS : DUDY (IOE=1), DVDX (IOE=2):
DO IOE = 1,2
   DEL_RC= XB_IB(-IOE)+XB_IB(IOE) ! Sum of 1/2*DY (IOE=1) or, 1/2*DZ (IOE=2), when IEC=IAXIS, etc.
   CC_EDGE%DUIDXJ((/-IOE,IOE/))    = (VEL_GAS(IOE)-VEL_GAS(-IOE))/DEL_RC
   CC_EDGE%MU_DUIDXJ((/-IOE,IOE/)) = MU_RC*CC_EDGE%DUIDXJ((/-IOE,IOE/))
ENDDO

RETURN
END SUBROUTINE CC_RCEDGE_DUIDXJ

SUBROUTINE CC_RCEDGE_TAU_OMG

IE = CC_EDGE%IE
SIGN_LOOP_2: DO I_SGN=-1,1,2
   ORIENTATION_LOOP_2: DO ICD=1,2
      IF (ICD==1) THEN
         ICDO=2
      ELSE ! ICD=2
         ICDO=1
      ENDIF
      ICD_SGN = I_SGN*ICD
         DUIDXJ_USE(ICD) =   CC_EDGE%DUIDXJ(ICD_SGN)
      MU_DUIDXJ_USE(ICD) = CC_EDGE%MU_DUIDXJ(ICD_SGN)
      ICDO_SGN = I_SGN*ICDO
         DUIDXJ_USE(ICDO)=   CC_EDGE%DUIDXJ(ICDO_SGN)
      MU_DUIDXJ_USE(ICDO)= CC_EDGE%MU_DUIDXJ(ICDO_SGN)
      EDGE(IE)%OMEGA(ICD_SGN) = DUIDXJ_USE(1) -    DUIDXJ_USE(2)
      EDGE(IE)%TAU(ICD_SGN)   = MU_DUIDXJ_USE(1) + MU_DUIDXJ_USE(2)

   ENDDO ORIENTATION_LOOP_2
ENDDO SIGN_LOOP_2

END SUBROUTINE CC_RCEDGE_TAU_OMG

SUBROUTINE CC_EDGE_TAU_OMG

REAL(EB) :: VEL_T,VEL_GHOST,MUA,UUP(2),UUM(2)
INTEGER  :: IEP,JEP,KEP,SURF_INDEX,ITMP,SKIP_FCT,NPE_LIST_START,NPE_LIST_COUNT,IRCEDG,IRC,JRC,KRC,&
            N_SOLID_CELLS_ON_EDGE,IOR,IVL,IIGM,IIGP,JJGM,JJGP,KKGM,KKGP,ICMM,ICMP,ICPM,ICPP
LOGICAL :: ALTERED_GRADIENT(-2:2),CORNER_EDGE
REAL(EB):: XB_IB,OMEV_EP(-2:2),TAUV_EP(-2:2),DWDY,DVDZ,DUDZ,DWDX,DUDY,DVDX, &
           DUIDXJ_EP(-2:2),MU_DUIDXJ_EP(-2:2),EC_B(-2:2),EC_EP(-2:2),DEL_EP,VEL_GAS,CEP,CB,U1_T,U2_T
TYPE(SURFACE_TYPE), POINTER :: SF=>NULL()
REAL(EB) :: VLG(-2:2),NUV(-2:2),RGH(-2:2),UTA(-2:2)
VLG(-2:2)=0._EB; NUV(-2:2)=0._EB; RGH(-2:2)=0._EB; UTA(-2:2)=0._EB

! Set these to zero for now:
VEL_T = 0._EB; SRGH = 0._EB

IE   = CC_EDGE%IE
II   = EDGE(IE)%I
JJ   = EDGE(IE)%J
KK   = EDGE(IE)%K
IEC  = EDGE(IE)%AXIS
ICMM = EDGE(IE)%CELL_INDEX_MM
ICPM = EDGE(IE)%CELL_INDEX_PM
ICMP = EDGE(IE)%CELL_INDEX_MP
ICPP = EDGE(IE)%CELL_INDEX_PP

! Get the velocity components at the appropriate cell faces

COMPONENT: SELECT CASE(IEC)
   CASE(1) COMPONENT
      UUP(1)  = VV(II,JJ,KK+1)
      UUM(1)  = VV(II,JJ,KK)
      UUP(2)  = WW(II,JJ+1,KK)
      UUM(2)  = WW(II,JJ,KK)
      DXX(1)  = DY(JJ)
      DXX(2)  = DZ(KK)
   CASE(2) COMPONENT
      UUP(1)  = WW(II+1,JJ,KK)
      UUM(1)  = WW(II,JJ,KK)
      UUP(2)  = UU(II,JJ,KK+1)
      UUM(2)  = UU(II,JJ,KK)
      DXX(1)  = DZ(KK)
      DXX(2)  = DX(II)
   CASE(3) COMPONENT
      UUP(1)  = UU(II,JJ+1,KK)
      UUM(1)  = UU(II,JJ,KK)
      UUP(2)  = VV(II+1,JJ,KK)
      UUM(2)  = VV(II,JJ,KK)
      DXX(1)  = DX(II)
      DXX(2)  = DY(JJ)
END SELECT COMPONENT

! Loop over all possible orientations of edge and reassign velocity gradients if appropriate
EP=1
ALTERED_GRADIENT(-2:2) = .FALSE.
OMEV_EP(-2:2) = 0._EB; TAUV_EP(-2:2) = 0._EB; EC_B(-2:2) = 0._EB; EC_EP(-2:2) = 0._EB
DUIDXJ_EP(-2:2) = 0._EB; MU_DUIDXJ_EP(-2:2) = 0._EB; DUIDXJ(-2:2) = 0._EB; MU_DUIDXJ(-2:2) = 0._EB
ORIENTATION_LOOP: DO IS=1,3
   IF (IS==IEC) CYCLE ORIENTATION_LOOP
   SIGN_LOOP: DO I_SGN=-1,1,2

      ! IOR is the orientation of the wall cells adjacent to the edge

      IOR = I_SGN*IS

      ! Determine Index_Coordinate_Direction
      ! IEC=1, ICD=1 refers to DWDY; ICD=2 refers to DVDZ
      ! IEC=2, ICD=1 refers to DUDZ; ICD=2 refers to DWDX
      ! IEC=3, ICD=1 refers to DVDX; ICD=2 refers to DUDY

      IF (IS>IEC) ICD = IS-IEC
      IF (IS<IEC) ICD = IS-IEC+3
      ICD_SGN = I_SGN * ICD

      ! Define the appropriate gas and ghost velocity

      IF (ICD==1) THEN ! Used to pick the appropriate velocity component
         IVL=2
      ELSE !ICD==2
         IVL=1
      ENDIF

      IF (IOR<0) THEN
         VEL_GAS   = UUM(IVL)
         VEL_GHOST = UUP(IVL)
         IIGM = CELL(ICMM)%I
         JJGM = CELL(ICMM)%J
         KKGM = CELL(ICMM)%K
         IF (ICD==1) THEN
            IIGP = CELL(ICMP)%I
            JJGP = CELL(ICMP)%J
            KKGP = CELL(ICMP)%K
         ELSE ! ICD==2
            IIGP = CELL(ICPM)%I
            JJGP = CELL(ICPM)%J
            KKGP = CELL(ICPM)%K
         ENDIF
      ELSE
         VEL_GAS   = UUP(IVL)
         VEL_GHOST = UUM(IVL)
         IF (ICD==1) THEN
            IIGM = CELL(ICPM)%I
            JJGM = CELL(ICPM)%J
            KKGM = CELL(ICPM)%K
         ELSE ! ICD==2
            IIGM = CELL(ICMP)%I
            JJGM = CELL(ICMP)%J
            KKGM = CELL(ICMP)%K
         ENDIF
         IIGP = CELL(ICPP)%I
         JJGP = CELL(ICPP)%J
         KKGP = CELL(ICPP)%K
      ENDIF

      IF(.NOT.CC_EDGE%PROCESS_EDGE_ORIENTATION(ICD_SGN)) CYCLE SIGN_LOOP

      ! With ICD_SGN check if face:
      ! IBEDGE IEC=IAXIS => ICD_SGN=-2 => FACE  low Z normal to JAXIS.
      !                     ICD_SGN=-1 => FACE  low Y normal to KAXIS.
      !                     ICD_SGN= 1 => FACE high Y normal to KAXIS.
      !                     ICD_SGN= 2 => FACE high Z normal to JAXIS.
      ! IBEDGE IEC=JAXIS => ICD_SGN=-2 => FACE  low X normal to KAXIS.
      !                     ICD_SGN=-1 => FACE  low Z normal to IAXIS.
      !                     ICD_SGN= 1 => FACE high Z normal to IAXIS.
      !                     ICD_SGN= 2 => FACE high X normal to KAXIS.
      ! IBEDGE IEC=KAXIS => ICD_SGN=-2 => FACE  low Y normal to IAXIS.
      !                     ICD_SGN=-1 => FACE  low X normal to JAXIS.
      !                     ICD_SGN= 1 => FACE high X normal to JAXIS.
      !                     ICD_SGN= 2 => FACE high Y normal to IAXIS.
      ! is GASPHASE cut-face.
      XB_IB      = CC_EDGE%XB_IB(ICD_SGN) ! Coordinate centroid of IBEDGE resp to Boundary (note, either zero or negative).
      SURF_INDEX = CC_EDGE%SURF_INDEX(ICD_SGN)
      IEC_SELECT: SELECT CASE(IEC)
         CASE(IAXIS) IEC_SELECT
            ! Define Face indexes and normal axis FAXIS.
            SELECT CASE(ICD_SGN)
               CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
               CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
               CASE( 1); IIF=II  ; JJF=JJ+1; KKF=KK  ; FAXIS=KAXIS
               CASE( 2); IIF=II  ; JJF=JJ  ; KKF=KK+1; FAXIS=JAXIS
            END SELECT
            IF(FCVAR(IIF,JJF,KKF,CC_FGSC,FAXIS)/=CC_CUTCFE) CYCLE SIGN_LOOP
            DXX(1)  = DY(JJF); DXX(2)  = DZ(KKF)

            ! Compute TAUV_EP, OMEV_EP, MU_FC, DXN_STRM_UB, VEL_GAS:
            SKIP_FCT = 1
            IF (FAXIS==JAXIS) THEN
               ITMP = MIN(I_MAX_TEMP,NINT(0.5_EB*(TMP(IIF,JJF,KKF)+TMP(IIF,JJF+1,KKF))))
               MU_FACE = MU_RSQMW_Z(ITMP,1)/RSQ_MW_Z(1)
               RHO_FACE = 0.5_EB*(  RHOP(IIF,JJF,KKF)+  RHOP(IIF,JJF+1,KKF))
               MUA = 0.5_EB*(MU(IIF,JJF,KKF) + MU(IIF,JJF+1,KKF))

               DXN_STRM_UB = DXX(2)
               ! Linear :
               DF     = DXX(2) - ABS(XB_IB)
               DE     = DXN_STRM_UB
               UF     = VV(IIF,JJF,KKF);  UE     = UF
               IF (.NOT.( (KKF+I_SGN>KBP1) .OR. (KKF+I_SGN<0) )) THEN
                  DE     = DZ(KKF+I_SGN) ! Should be one up from DXX(2).
                  UE     = VV(IIF,JJF,KKF+I_SGN)
               ENDIF
               UB     = VEL_T
               VEL_GAS  = 2._EB/(DF+DE)*((DE/2._EB+DF)*UF-DF/2._EB*UE) - 2._EB/(DF+DE)*(UF-UE)*(DXN_STRM_UB/2._EB)

               DEL_EP = DXX(2) - ABS(XB_IB)
               IF( DEL_EP < THRES_FCT_EP*DXX(2) ) THEN; SKIP_FCT = 2; DEL_EP = DEL_EP + DXX(2); ENDIF
               IEP=II; JEP=JJ; KEP=KK+SKIP_FCT*I_SGN

            ELSE ! IF(FAXIS==KAXIS) THEN
               ITMP = MIN(I_MAX_TEMP,NINT(0.5_EB*(TMP(IIF,JJF,KKF)+TMP(IIF,JJF,KKF+1))))
               MU_FACE = MU_RSQMW_Z(ITMP,1)/RSQ_MW_Z(1)
               RHO_FACE = 0.5_EB*(  RHOP(IIF,JJF,KKF)+  RHOP(IIF,JJF,KKF+1))
               MUA = 0.5_EB*(MU(IIF,JJF,KKF) + MU(IIF,JJF,KKF+1))

               DXN_STRM_UB = DXX(1)
               ! Linear :
               DF     = DXX(1) - ABS(XB_IB)
               DE     = DXN_STRM_UB
               UF     = WW(IIF,JJF,KKF);  UE     = UF
               IF (.NOT.( (JJF+I_SGN>JBP1) .OR. (JJF+I_SGN<0) )) THEN
                  DE     = DY(JJF+I_SGN) ! Should be one up from DXX(1).
                  UE     = WW(IIF,JJF+I_SGN,KKF)
               ENDIF
               UB     = VEL_T
               VEL_GAS  = 2._EB/(DF+DE)*((DE/2._EB+DF)*UF-DF/2._EB*UE) - 2._EB/(DF+DE)*(UF-UE)*(DXN_STRM_UB/2._EB)

               DEL_EP = DXX(1) - ABS(XB_IB)
               IF( DEL_EP < THRES_FCT_EP*DXX(1) ) THEN; SKIP_FCT = 2; DEL_EP = DEL_EP + DXX(1); ENDIF
               IEP=II; JEP=JJ+SKIP_FCT*I_SGN; KEP=KK

            ENDIF

            IF (CC_EDGE%EDGE_IN_MESH(ICD_SGN)) THEN ! Regular computation of MU and velocity derivatives:
               MU_EP= 0.25_EB*(MU(IEP,JEP,KEP)+MU(IEP,JEP+1,KEP)+MU(IEP,JEP+1,KEP+1)+MU(IEP,JEP,KEP+1))
               IRCEDG = ECVAR(IEP,JEP,KEP,CC_IDCE,IEC)
               IF (IRCEDG>0) THEN
                  IF(ECVAR(IEP,JEP,KEP,CC_EGSC,IEC)==CC_GASPHASE) THEN
                     DWDY = CC_RCEDGE(IRCEDG)%DUIDXJ(1); DVDZ = CC_RCEDGE(IRCEDG)%DUIDXJ(2)
                  ELSEIF(ECVAR(IEP,JEP,KEP,CC_EGSC,IEC)==CC_CUTCFE) THEN
                     IF (CUT_EDGE(IRCEDG)%IE>0) THEN
                        DWDY = CUT_EDGE(IRCEDG)%DUIDXJ(1,1); DVDZ = CUT_EDGE(IRCEDG)%DUIDXJ(2,1)
                     ELSE
                        DWDY = (WW(IEP,JEP+1,KEP)-WW(IEP,JEP,KEP))/DXX(1)
                        DVDZ = (VV(IEP,JEP,KEP+1)-VV(IEP,JEP,KEP))/DXX(2)
                     ENDIF
                  ENDIF
               ELSE
                  DWDY = (WW(IEP,JEP+1,KEP)-WW(IEP,JEP,KEP))/DXX(1); DVDZ = (VV(IEP,JEP,KEP+1)-VV(IEP,JEP,KEP))/DXX(2)
               ENDIF
            ELSE
               MU_EP = 0._EB; DWDY = 0._EB; DVDZ = 0._EB
               ! First MU_EP:
               VIND=0
               NPE_LIST_START = CC_EDGE%INT_NPE(LOW_IND,VIND,EP,ICD_SGN)
               NPE_LIST_COUNT = CC_EDGE%INT_NPE(HIGH_IND,VIND,EP,ICD_SGN)
               IF (NPE_LIST_COUNT>0) THEN
                 DO INPE=NPE_LIST_START+1,NPE_LIST_START+NPE_LIST_COUNT
                    MU_EP = MU_EP + CC_EDGE%INT_CVARS(INT_MU_IND,INPE)
                 ENDDO
                 MU_EP = MU_EP / REAL(NPE_LIST_COUNT,EB)
               ENDIF
               ! Then DWDY:
               VIND=KAXIS
               NPE_LIST_START = CC_EDGE%INT_NPE(LOW_IND,VIND,EP,ICD_SGN)
               NPE_LIST_COUNT = CC_EDGE%INT_NPE(HIGH_IND,VIND,EP,ICD_SGN)
               DO INPE=NPE_LIST_START+1,NPE_LIST_START+NPE_LIST_COUNT
                  DWDY = DWDY + CC_EDGE%INT_DCOEF(INPE,1)*CC_EDGE%INT_FVARS(INT_VEL_IND,INPE)
               ENDDO
               ! Finally DVDZ:
               VIND=JAXIS
               NPE_LIST_START = CC_EDGE%INT_NPE(LOW_IND,VIND,EP,ICD_SGN)
               NPE_LIST_COUNT = CC_EDGE%INT_NPE(HIGH_IND,VIND,EP,ICD_SGN)
               DO INPE=NPE_LIST_START+1,NPE_LIST_START+NPE_LIST_COUNT
                  DVDZ = DVDZ + CC_EDGE%INT_DCOEF(INPE,1)*CC_EDGE%INT_FVARS(INT_VEL_IND,INPE)
               ENDDO
            ENDIF

            OMEV_EP(ICD_SGN) = DWDY - DVDZ
            TAUV_EP(ICD_SGN) = MU_EP*(DWDY + DVDZ)
            IF (FAXIS==JAXIS) THEN
               DUIDXJ_EP(ICD_SGN)    = DVDZ
            ELSE ! IF(FAXIS==KAXIS) THEN
               DUIDXJ_EP(ICD_SGN)    = DWDY
            ENDIF

         CASE(JAXIS) IEC_SELECT
            ! Define Face indexes and normal axis FAXIS.
            SELECT CASE(ICD_SGN)
               CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
               CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=IAXIS
               CASE( 1); IIF=II  ; JJF=JJ  ; KKF=KK+1; FAXIS=IAXIS
               CASE( 2); IIF=II+1; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
            END SELECT
            IF(FCVAR(IIF,JJF,KKF,CC_FGSC,FAXIS)/=CC_CUTCFE) CYCLE SIGN_LOOP
            DXX(1)  = DZ(KKF); DXX(2)  = DX(IIF)

            ! Compute TAUV_EP, OMEV_EP, MU_FC, DXN_STRM_UB, VEL_GAS:
            SKIP_FCT = 1
            IF (FAXIS==KAXIS) THEN
               ITMP = MIN(I_MAX_TEMP,NINT(0.5_EB*(TMP(IIF,JJF,KKF)+TMP(IIF,JJF,KKF+1))))
               MU_FACE = MU_RSQMW_Z(ITMP,1)/RSQ_MW_Z(1)
               RHO_FACE = 0.5_EB*(  RHOP(IIF,JJF,KKF)+  RHOP(IIF,JJF,KKF+1))
               MUA = 0.5_EB*(MU(IIF,JJF,KKF) +  MU(IIF,JJF,KKF+1))

               DXN_STRM_UB = DXX(2)
               ! Linear :
               DF     = DXX(2) - ABS(XB_IB)
               DE     = DXN_STRM_UB
               UF     = WW(IIF,JJF,KKF);  UE     = UF
               IF (.NOT.( (IIF+I_SGN>IBP1) .OR. (IIF+I_SGN<0) )) THEN
                  DE     = DX(IIF+I_SGN) ! Should be one up from DXX(2).
                  UE     = WW(IIF+I_SGN,JJF,KKF)
               ENDIF
               UB     = VEL_T
               VEL_GAS  = 2._EB/(DF+DE)*((DE/2._EB+DF)*UF-DF/2._EB*UE) - 2._EB/(DF+DE)*(UF-UE)*(DXN_STRM_UB/2._EB)

               DEL_EP = DXX(2) - ABS(XB_IB)
               IF( DEL_EP < THRES_FCT_EP*DXX(2) ) THEN; SKIP_FCT = 2; DEL_EP = DEL_EP + DXX(2); ENDIF
               IEP=II+SKIP_FCT*I_SGN; JEP=JJ; KEP=KK

            ELSE ! IF(FAXIS==IAXIS) THEN
               ITMP = MIN(I_MAX_TEMP,NINT(0.5_EB*(TMP(IIF,JJF,KKF)+TMP(IIF+1,JJF,KKF))))
               MU_FACE = MU_RSQMW_Z(ITMP,1)/RSQ_MW_Z(1)
               RHO_FACE = 0.5_EB*(  RHOP(IIF,JJF,KKF)+  RHOP(IIF+1,JJF,KKF))
               MUA = 0.5_EB*(MU(IIF,JJF,KKF) +  MU(IIF+1,JJF,KKF))

               DXN_STRM_UB = DXX(1)
               ! Linear :
               DF     = DXX(1) - ABS(XB_IB)
               DE     = DXN_STRM_UB
               UF     = UU(IIF,JJF,KKF);  UE     = UF
               IF (.NOT.( (KKF+I_SGN>KBP1) .OR. (KKF+I_SGN<0) )) THEN
                  DE     = DZ(KKF+I_SGN) ! Should be one up from DXX(1).
                  UE     = UU(IIF,JJF,KKF+I_SGN)
               ENDIF
               UB     = VEL_T
               VEL_GAS  = 2._EB/(DF+DE)*((DE/2._EB+DF)*UF-DF/2._EB*UE) - 2._EB/(DF+DE)*(UF-UE)*(DXN_STRM_UB/2._EB)

               DEL_EP = DXX(1) - ABS(XB_IB)
               IF( DEL_EP < THRES_FCT_EP*DXX(1) ) THEN; SKIP_FCT = 2; DEL_EP = DEL_EP + DXX(1); ENDIF
               IEP=II; JEP=JJ; KEP=KK+SKIP_FCT*I_SGN

            ENDIF

            IF (CC_EDGE%EDGE_IN_MESH(ICD_SGN)) THEN ! Regular computation of MU and velocity derivatives:
               MU_EP= 0.25_EB*(MU(IEP,JEP,KEP)+MU(IEP+1,JEP,KEP)+MU(IEP+1,JEP,KEP+1)+MU(IEP,JEP,KEP+1))
               IRCEDG = ECVAR(IEP,JEP,KEP,CC_IDCE,IEC)
               IF (IRCEDG>0) THEN
                  IF(ECVAR(IEP,JEP,KEP,CC_EGSC,IEC)==CC_GASPHASE) THEN
                     DUDZ = CC_RCEDGE(IRCEDG)%DUIDXJ(1); DWDX = CC_RCEDGE(IRCEDG)%DUIDXJ(2)
                  ELSEIF(ECVAR(IEP,JEP,KEP,CC_EGSC,IEC)==CC_CUTCFE) THEN
                     IF (CUT_EDGE(IRCEDG)%IE>0) THEN
                        DUDZ = CUT_EDGE(IRCEDG)%DUIDXJ(1,1); DWDX = CUT_EDGE(IRCEDG)%DUIDXJ(2,1)
                     ELSE
                        DUDZ = (UU(IEP,JEP,KEP+1)-UU(IEP,JEP,KEP))/DXX(1)
                        DWDX = (WW(IEP+1,JEP,KEP)-WW(IEP,JEP,KEP))/DXX(2)
                     ENDIF
                  ENDIF
               ELSE
                  DUDZ = (UU(IEP,JEP,KEP+1)-UU(IEP,JEP,KEP))/DXX(1); DWDX = (WW(IEP+1,JEP,KEP)-WW(IEP,JEP,KEP))/DXX(2)
               ENDIF
            ELSE
               MU_EP = 0._EB; DUDZ = 0._EB; DWDX = 0._EB
               ! First MU_EP:
               VIND=0
               NPE_LIST_START = CC_EDGE%INT_NPE(LOW_IND,VIND,EP,ICD_SGN)
               NPE_LIST_COUNT = CC_EDGE%INT_NPE(HIGH_IND,VIND,EP,ICD_SGN)
               IF (NPE_LIST_COUNT>0) THEN
                 DO INPE=NPE_LIST_START+1,NPE_LIST_START+NPE_LIST_COUNT
                    MU_EP = MU_EP + CC_EDGE%INT_CVARS(INT_MU_IND,INPE)
                 ENDDO
                 MU_EP = MU_EP / REAL(NPE_LIST_COUNT,EB)
               ENDIF
               ! Then DUDZ:
               VIND=IAXIS
               NPE_LIST_START = CC_EDGE%INT_NPE(LOW_IND,VIND,EP,ICD_SGN)
               NPE_LIST_COUNT = CC_EDGE%INT_NPE(HIGH_IND,VIND,EP,ICD_SGN)
               DO INPE=NPE_LIST_START+1,NPE_LIST_START+NPE_LIST_COUNT
                  DUDZ = DUDZ + CC_EDGE%INT_DCOEF(INPE,1)*CC_EDGE%INT_FVARS(INT_VEL_IND,INPE)
               ENDDO
               ! Finally DWDX:
               VIND=KAXIS
               NPE_LIST_START = CC_EDGE%INT_NPE(LOW_IND,VIND,EP,ICD_SGN)
               NPE_LIST_COUNT = CC_EDGE%INT_NPE(HIGH_IND,VIND,EP,ICD_SGN)
               DO INPE=NPE_LIST_START+1,NPE_LIST_START+NPE_LIST_COUNT
                  DWDX = DWDX + CC_EDGE%INT_DCOEF(INPE,1)*CC_EDGE%INT_FVARS(INT_VEL_IND,INPE)
               ENDDO
            ENDIF

            OMEV_EP(ICD_SGN) = DUDZ - DWDX
            TAUV_EP(ICD_SGN) = MU_EP*(DUDZ + DWDX)
            IF (FAXIS==KAXIS) THEN
               DUIDXJ_EP(ICD_SGN)    = DWDX
            ELSE ! IF(FAXIS==IAXIS) THEN
               DUIDXJ_EP(ICD_SGN)    = DUDZ
            ENDIF

            !  IF(NM==1 .AND. II==41 .AND. JJ==20 .AND. KK==32 .AND. FAXIS==IAXIS) THEN
            !    WRITE(LU_ERR,*) '>>>> ICD_SGN, FAXIS, VEL_GAS=',ICD_SGN,FAXIS,IEP,JEP,KEP
            !    WRITE(LU_ERR,*) '                          =',XB_IB,DXN_STRM_UB,ZETA,USTR_1,USTR_2,VEL_GAS
            !    WRITE(LU_ERR,*) 'DF,DE,UF,VV(IIF,JJF,KKF),UE,UB=',DF,DE,UF,UU(IIF,JJF,KKF),UE,UB
            !    WRITE(LU_ERR,*) 'ICD_SGN,DUIDXJ_EP(ICD_SGN)=',ICD_SGN,DUIDXJ_EP(ICD_SGN)
            !    WRITE(LU_ERR,*) 'DE,DEZ+1=',KKF,I_SGN,DZ(KKF),DZ(KKF+I_SGN)
            ! ENDIF

         CASE(KAXIS) IEC_SELECT
            ! Define Face indexes and normal axis FAXIS.
            SELECT CASE(ICD_SGN)
               CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=IAXIS
               CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
               CASE( 1); IIF=II+1; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
               CASE( 2); IIF=II  ; JJF=JJ+1; KKF=KK  ; FAXIS=IAXIS
            END SELECT
            IF(FCVAR(IIF,JJF,KKF,CC_FGSC,FAXIS)/=CC_CUTCFE) CYCLE SIGN_LOOP
            DXX(1)  = DX(IIF); DXX(2)  = DY(JJF)

            ! Compute TAUV_EP, OMEV_EP, MU_FC, DXN_STRM_UB, VEL_GAS:
            SKIP_FCT = 1
            IF (FAXIS==IAXIS) THEN
               ITMP = MIN(I_MAX_TEMP,NINT(0.5_EB*(TMP(IIF,JJF,KKF)+TMP(IIF+1,JJF,KKF))))
               MU_FACE = MU_RSQMW_Z(ITMP,1)/RSQ_MW_Z(1)
               RHO_FACE = 0.5_EB*(  RHOP(IIF,JJF,KKF)+  RHOP(IIF+1,JJF,KKF))
               MUA = 0.5_EB*(MU(IIF,JJF,KKF) +  MU(IIF+1,JJF,KKF))

               DXN_STRM_UB = DXX(2)
               ! Linear :
               DF     = DXX(2) - ABS(XB_IB)
               DE     = DXN_STRM_UB
               UF     = UU(IIF,JJF,KKF);  UE     = UF
               IF (.NOT.( (JJF+I_SGN>JBP1) .OR. (JJF+I_SGN<0) )) THEN
                  DE     = DY(JJF+I_SGN) ! Should be one up from DXX(2).
                  UE     = UU(IIF,JJF+I_SGN,KKF)
               ENDIF
               UB     = VEL_T
               VEL_GAS  = 2._EB/(DF+DE)*((DE/2._EB+DF)*UF-DF/2._EB*UE) - 2._EB/(DF+DE)*(UF-UE)*(DXN_STRM_UB/2._EB)

               DEL_EP = DXX(2) - ABS(XB_IB)
               IF( DEL_EP < THRES_FCT_EP*DXX(2) ) THEN; SKIP_FCT = 2; DEL_EP = DEL_EP + DXX(2); ENDIF
               IEP=II; JEP=JJ+SKIP_FCT*I_SGN; KEP=KK

            ELSE ! IF(FAXIS==JAXIS) THEN
               ITMP = MIN(I_MAX_TEMP,NINT(0.5_EB*(TMP(IIF,JJF,KKF)+TMP(IIF,JJF+1,KKF))))
               MU_FACE = MU_RSQMW_Z(ITMP,1)/RSQ_MW_Z(1)
               RHO_FACE = 0.5_EB*(  RHOP(IIF,JJF,KKF)+  RHOP(IIF,JJF+1,KKF))
               MUA = 0.5_EB*(MU(IIF,JJF,KKF) +  MU(IIF,JJF+1,KKF))

               DXN_STRM_UB = DXX(1)
               ! Linear :
               DF     = DXX(1) - ABS(XB_IB)
               DE     = DXN_STRM_UB
               UF     = VV(IIF,JJF,KKF);  UE     = UF
               IF (.NOT.( (IIF+I_SGN>IBP1) .OR. (IIF+I_SGN<0) )) THEN
                  DE     = DX(IIF+I_SGN) ! Should be one up from DXX(1).
                  UE     = VV(IIF+I_SGN,JJF,KKF)
               ENDIF
               UB     = VEL_T
               VEL_GAS  = 2._EB/(DF+DE)*((DE/2._EB+DF)*UF-DF/2._EB*UE) - 2._EB/(DF+DE)*(UF-UE)*(DXN_STRM_UB/2._EB)

               DEL_EP = DXX(1) - ABS(XB_IB)
               IF( DEL_EP < THRES_FCT_EP*DXX(1) ) THEN; SKIP_FCT = 2; DEL_EP = DEL_EP + DXX(1); ENDIF
               IEP=II+SKIP_FCT*I_SGN; JEP=JJ; KEP=KK

            ENDIF

            IF (CC_EDGE%EDGE_IN_MESH(ICD_SGN)) THEN ! Regular computation of MU and velocity derivatives:
               MU_EP= 0.25_EB*(MU(IEP,JEP,KEP)+MU(IEP+1,JEP,KEP)+MU(IEP+1,JEP+1,KEP)+MU(IEP,JEP+1,KEP))
               IRCEDG = ECVAR(IEP,JEP,KEP,CC_IDCE,IEC)
               IF (IRCEDG>0) THEN
                  IF(ECVAR(IEP,JEP,KEP,CC_EGSC,IEC)==CC_GASPHASE) THEN
                     DVDX = CC_RCEDGE(IRCEDG)%DUIDXJ(1); DUDY = CC_RCEDGE(IRCEDG)%DUIDXJ(2)
                  ELSEIF(ECVAR(IEP,JEP,KEP,CC_EGSC,IEC)==CC_CUTCFE) THEN
                     IF (CUT_EDGE(IRCEDG)%IE>0) THEN
                        DVDX = CUT_EDGE(IRCEDG)%DUIDXJ(1,1); DUDY = CUT_EDGE(IRCEDG)%DUIDXJ(2,1)
                     ELSE
                        DVDX = (VV(IEP+1,JEP,KEP)-VV(IEP,JEP,KEP))/DXX(1)
                        DUDY = (UU(IEP,JEP+1,KEP)-UU(IEP,JEP,KEP))/DXX(2)
                     ENDIF
                  ENDIF
               ELSE
                  DVDX = (VV(IEP+1,JEP,KEP)-VV(IEP,JEP,KEP))/DXX(1); DUDY = (UU(IEP,JEP+1,KEP)-UU(IEP,JEP,KEP))/DXX(2)
               ENDIF
            ELSE
               MU_EP = 0._EB; DVDX = 0._EB; DUDY = 0._EB
               ! First MU_EP:
               VIND=0
               NPE_LIST_START = CC_EDGE%INT_NPE(LOW_IND,VIND,EP,ICD_SGN)
               NPE_LIST_COUNT = CC_EDGE%INT_NPE(HIGH_IND,VIND,EP,ICD_SGN)
               IF (NPE_LIST_COUNT>0) THEN
                 DO INPE=NPE_LIST_START+1,NPE_LIST_START+NPE_LIST_COUNT
                    MU_EP = MU_EP + CC_EDGE%INT_CVARS(INT_MU_IND,INPE)
                 ENDDO
                 MU_EP = MU_EP / REAL(NPE_LIST_COUNT,EB)
               ENDIF
               ! Then DVDX:
               VIND=JAXIS
               NPE_LIST_START = CC_EDGE%INT_NPE(LOW_IND,VIND,EP,ICD_SGN)
               NPE_LIST_COUNT = CC_EDGE%INT_NPE(HIGH_IND,VIND,EP,ICD_SGN)
               DO INPE=NPE_LIST_START+1,NPE_LIST_START+NPE_LIST_COUNT
                  DVDX = DVDX + CC_EDGE%INT_DCOEF(INPE,1)*CC_EDGE%INT_FVARS(INT_VEL_IND,INPE)
               ENDDO
               ! Finally DUDY:
               VIND=IAXIS
               NPE_LIST_START = CC_EDGE%INT_NPE(LOW_IND,VIND,EP,ICD_SGN)
               NPE_LIST_COUNT = CC_EDGE%INT_NPE(HIGH_IND,VIND,EP,ICD_SGN)
               DO INPE=NPE_LIST_START+1,NPE_LIST_START+NPE_LIST_COUNT
                  DUDY = DUDY + CC_EDGE%INT_DCOEF(INPE,1)*CC_EDGE%INT_FVARS(INT_VEL_IND,INPE)
               ENDDO
            ENDIF

            OMEV_EP(ICD_SGN) = DVDX - DUDY
            TAUV_EP(ICD_SGN) = MU_EP*(DVDX + DUDY)
            IF (FAXIS==IAXIS) THEN
               DUIDXJ_EP(ICD_SGN)    = DUDY
            ELSE ! IF(FAXIS==JAXIS) THEN
               DUIDXJ_EP(ICD_SGN)    = DVDX
            ENDIF

      END SELECT IEC_SELECT

      ICF = FCVAR(IIF,JJF,KKF,CC_IDCF,FAXIS)
      !IF ( ANY(CUT_FACE(ICF)%UNKF(1:CUT_FACE(ICF)%NFACE)==0)) CYCLE ! Cycle if any face has no UNKF (unlinked).
      !IF ( CUT_FACE(ICF)%ALPHA_CF < 0.05_EB ) CYCLE ! Cycle if cut-face size is less than 0.001 cartesian face.
      IF ( CUT_FACE(ICF)%ALPHA_CF > CCVOL_LINK ) THEN ! Large cut-face.
         VEL_GAS     = UF
         DXN_STRM_UB = DF
      ELSE
          VEL_GAS     = (UF*DF + UE*DE)/(DF+DE)
          DXN_STRM_UB = (DF+DE)
      ENDIF

      ! Make collocated velocity point distance, half DELTA gas CF size:
      DXN_STRM_UB = DXN_STRM_UB/2._EB

      ! Define mu*Gradient:
      MU_DUIDXJ_EP(ICD_SGN) = MU_EP*DUIDXJ_EP(ICD_SGN)

      ! Here we have a cut-face, and OME and TAU in an external EDGE for extrapolation to IBEDGE.
      ! Now get value at the boundary using wall model:
      VEL_GHOST = 0._EB
      SF=>SURFACE(SURF_INDEX)
      SELECT CASE(SF%VELOCITY_BC_INDEX)
         CASE (FREE_SLIP_BC)
            VEL_GHOST = VEL_GAS
            DUIDXJ(ICD_SGN) = I_SGN*(VEL_GAS-VEL_GHOST)/(2._EB*DXN_STRM_UB)
            MU_DUIDXJ(ICD_SGN) = MUA*DUIDXJ(ICD_SGN)
            ALTERED_GRADIENT(ICD_SGN) = .TRUE.
         CASE (NO_SLIP_BC)
            VEL_GHOST = 2._EB*VEL_T - VEL_GAS
            DUIDXJ(ICD_SGN) = I_SGN*(VEL_GAS-VEL_GHOST)/(2._EB*DXN_STRM_UB)
            MU_DUIDXJ(ICD_SGN) = MUA*DUIDXJ(ICD_SGN)
            ALTERED_GRADIENT(ICD_SGN) = .TRUE.
         CASE (WALL_MODEL_BC)
            ! Determine if the cell edge is an external corner:
            CORNER_EDGE=.FALSE.
            N_SOLID_CELLS_ON_EDGE=0
            SELECT CASE(IEC)
               CASE(1)
                  N_SOLID_CELLS_ON_EDGE=COUNT(CCVAR(II,JJ:JJ+1,KK:KK+1,CC_CGSC)==CC_SOLID)
               CASE(2)
                  N_SOLID_CELLS_ON_EDGE=COUNT(CCVAR(II:II+1,JJ,KK:KK+1,CC_CGSC)==CC_SOLID)
               CASE(3)
                  N_SOLID_CELLS_ON_EDGE=COUNT(CCVAR(II:II+1,JJ:JJ+1,KK,CC_CGSC)==CC_SOLID)
            END SELECT
            IF (N_SOLID_CELLS_ON_EDGE==1) CORNER_EDGE=.TRUE.

            NU = MU_FACE/RHO_FACE
            CALL WALL_MODEL(SLIP_FACTOR,U_TAU,Y_PLUS,NU,SF%ROUGHNESS,DXN_STRM_UB,VEL_GAS-VEL_T)
            ! Finally OMEGA, TAU:
            ! SLIP_COEF = -1, no slip,   VEL_GHOST = 2*VEL_T - VEL_GAS
            ! SLIP_COEF =  0, half slip, VEL_GHOST = VEL_T
            ! SLIP_COEF =  1, free slip, VEL_GHOST = VEL_GAS
            IF (CORNER_EDGE) SLIP_FACTOR = 0 ! corner (done to match VELOCITY_BC)
            VEL_GHOST = VEL_T + SLIP_FACTOR*(VEL_GAS-VEL_T)
            DUIDXJ(ICD_SGN) = I_SGN*(VEL_GAS-VEL_GHOST)/(2._EB*DXN_STRM_UB)
            MU_DUIDXJ(ICD_SGN) = RHO_FACE*U_TAU**2 * SIGN(1._EB,DUIDXJ(ICD_SGN))
            ALTERED_GRADIENT(ICD_SGN) = .TRUE.
         CASE (BOUNDARY_FUEL_MODEL_BC)
            U1_T = 0._EB; U2_T = 0._EB
            SELECT CASE(IEC)
               CASE(IAXIS);              U1_T = UU(IIGM,JJGM,KKGM)**2
                  IF(FAXIS==JAXIS) THEN; U2_T = VV(IIGM,JJGM,KKGM)**2; ELSE; U2_T = WW(IIGM,JJGM,KKGM)**2; ENDIF
               CASE(JAXIS);              U1_T = VV(IIGM,JJGM,KKGM)**2
                  IF(FAXIS==IAXIS) THEN; U2_T = UU(IIGM,JJGM,KKGM)**2; ELSE; U2_T = WW(IIGM,JJGM,KKGM)**2; ENDIF
            END SELECT
            VEL_T = SQRT(U1_T+U2_T)
            DUIDXJ(ICD_SGN)    = 0._EB
            IF (SF%VEG_LSET_SPREAD) THEN
               MU_DUIDXJ(ICD_SGN) = I_SGN*0.5_EB*RHO_FACE*SF%DRAG_COEFFICIENT*SF%SHAPE_FACTOR*SF%VEG_LSET_HT*&
                                    SF%VEG_LSET_BETA*(SF%VEG_LSET_SIGMA*100._EB)*VEL_GAS*VEL_T
            ELSE
               MU_DUIDXJ(ICD_SGN) = I_SGN*0.5_EB*RHO_FACE*SF%DRAG_COEFFICIENT*SF%SHAPE_FACTOR*SF%LAYER_THICKNESS(1)*&
                     SF%PACKING_RATIO(1)*SF%SURFACE_VOLUME_RATIO(1)*VEL_GAS*VEL_T
            ENDIF
            ALTERED_GRADIENT(ICD_SGN) = .TRUE.
      END SELECT

      ! VLG(ICD_SGN)=VEL_GAS
      ! NUV(ICD_SGN)=MU_FACE  ! NU
      ! RGH(ICD_SGN)=RHO_FACE ! SURFACE(SURF_INDEX)%ROUGHNESS
      ! UTA(ICD_SGN)=U_TAU

      ! Extrapolation coefficients for the IBEDGE:
      IF(DEL_EP > STM_THRESH_EXTRP*DE) THEN
         EC_B(ICD_SGN) = (DEL_EP + ABS(XB_IB))/DEL_EP
         EC_EP(ICD_SGN)= 1._EB - EC_B(ICD_SGN)
      ELSE
         EC_B(ICD_SGN) = 1._EB
         EC_EP(ICD_SGN)= 0._EB
      ENDIF

      ! If needed re-interpolate stress and duidxj to RC EDGE:
      IEC_SELECT_2: SELECT CASE(IEC)
         CASE(IAXIS) IEC_SELECT_2
            ! Define Face indexes and normal axis FAXIS.
            SELECT CASE(ICD_SGN)
               CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
               CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
               CASE( 1); IIF=II  ; JJF=JJ+1; KKF=KK  ; FAXIS=KAXIS
               CASE( 2); IIF=II  ; JJF=JJ  ; KKF=KK+1; FAXIS=JAXIS
            END SELECT
            IF(FCVAR(IIF,JJF,KKF,CC_FGSC,FAXIS)/=CC_CUTCFE) CYCLE SIGN_LOOP
            DXX(1)  = DY(JJF); DXX(2)  = DZ(KKF)
            IF (FAXIS==JAXIS) THEN
               DEL_EP = DXX(2) - ABS(XB_IB)
               IF( DEL_EP < THRES_FCT_EP*DXX(2) ) THEN
                  DEL_EP = DEL_EP + DXX(2);
                  IRC=II; JRC=JJ; KRC=KK+I_SGN
                  IRCEDG = ECVAR(IRC,JRC,KRC,CC_IDCE,IEC)
                  IF (IRCEDG>0 .AND. ECVAR(IRC,JRC,KRC,CC_EGSC,IEC)==CC_GASPHASE) THEN
                     CEP = (DXX(2) - ABS(XB_IB))/DEL_EP; CB=DXX(2)/DEL_EP
                     CC_RCEDGE(IRCEDG)%DUIDXJ((/ -ICD, ICD /))    = 0.5_EB*(CC_RCEDGE(IRCEDG)%DUIDXJ(ICD_SGN) + &
                                                                     CEP*   DUIDXJ_EP(ICD_SGN) + CB*   DUIDXJ(ICD_SGN))
                     CC_RCEDGE(IRCEDG)%MU_DUIDXJ((/ -ICD, ICD /)) = 0.5_EB*(CC_RCEDGE(IRCEDG)%MU_DUIDXJ(ICD_SGN) + &
                                                                     CEP*MU_DUIDXJ_EP(ICD_SGN) + CB*MU_DUIDXJ(ICD_SGN))
                  ENDIF
               ENDIF
            ELSE ! IF(FAXIS==KAXIS) THEN
               DEL_EP = DXX(1) - ABS(XB_IB)
               IF( DEL_EP < THRES_FCT_EP*DXX(1) ) THEN
                  DEL_EP = DEL_EP + DXX(1);
                  IRC=II; JRC=JJ+I_SGN; KRC=KK
                  IRCEDG = ECVAR(IRC,JRC,KRC,CC_IDCE,IEC)
                  IF (IRCEDG>0 .AND. ECVAR(IRC,JRC,KRC,CC_EGSC,IEC)==CC_GASPHASE) THEN
                     CEP = (DXX(1) - ABS(XB_IB))/DEL_EP; CB=DXX(1)/DEL_EP
                     CC_RCEDGE(IRCEDG)%DUIDXJ((/ -ICD, ICD /))    = 0.5_EB*(CC_RCEDGE(IRCEDG)%DUIDXJ(ICD_SGN) + &
                                                                     CEP*   DUIDXJ_EP(ICD_SGN) + CB*   DUIDXJ(ICD_SGN))
                     CC_RCEDGE(IRCEDG)%MU_DUIDXJ((/ -ICD, ICD /)) = 0.5_EB*(CC_RCEDGE(IRCEDG)%MU_DUIDXJ(ICD_SGN) + &
                                                                     CEP*MU_DUIDXJ_EP(ICD_SGN) + CB*MU_DUIDXJ(ICD_SGN))
                  ENDIF
               ENDIF
            ENDIF
         CASE(JAXIS) IEC_SELECT_2
            ! Define Face indexes and normal axis FAXIS.
            SELECT CASE(ICD_SGN)
               CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
               CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=IAXIS
               CASE( 1); IIF=II  ; JJF=JJ  ; KKF=KK+1; FAXIS=IAXIS
               CASE( 2); IIF=II+1; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
            END SELECT
            IF(FCVAR(IIF,JJF,KKF,CC_FGSC,FAXIS)/=CC_CUTCFE) CYCLE SIGN_LOOP
            DXX(1)  = DZ(KKF); DXX(2)  = DX(IIF)
            IF (FAXIS==KAXIS) THEN
               DEL_EP = DXX(2) - ABS(XB_IB)
               IF( DEL_EP < THRES_FCT_EP*DXX(2) ) THEN
                  DEL_EP = DEL_EP + DXX(2);
                  IRC=II+I_SGN; JRC=JJ; KRC=KK
                  IRCEDG = ECVAR(IRC,JRC,KRC,CC_IDCE,IEC)
                  IF (IRCEDG>0 .AND. ECVAR(IRC,JRC,KRC,CC_EGSC,IEC)==CC_GASPHASE) THEN
                     CEP = (DXX(2) - ABS(XB_IB))/DEL_EP; CB=DXX(2)/DEL_EP
                     CC_RCEDGE(IRCEDG)%DUIDXJ((/ -ICD, ICD /))    = 0.5_EB*(CC_RCEDGE(IRCEDG)%DUIDXJ(ICD_SGN) + &
                                                                     CEP*   DUIDXJ_EP(ICD_SGN) + CB*   DUIDXJ(ICD_SGN))
                     CC_RCEDGE(IRCEDG)%MU_DUIDXJ((/ -ICD, ICD /)) = 0.5_EB*(CC_RCEDGE(IRCEDG)%MU_DUIDXJ(ICD_SGN) + &
                                                                     CEP*MU_DUIDXJ_EP(ICD_SGN) + CB*MU_DUIDXJ(ICD_SGN))
                  ENDIF
               ENDIF
            ELSE ! IF(FAXIS==IAXIS) THEN
               DEL_EP = DXX(1) - ABS(XB_IB)
               IF( DEL_EP < THRES_FCT_EP*DXX(1) ) THEN
                  DEL_EP = DEL_EP + DXX(1);
                  IRC=II; JRC=JJ; KRC=KK+I_SGN
                  IRCEDG = ECVAR(IRC,JRC,KRC,CC_IDCE,IEC)
                  IF (IRCEDG>0 .AND. ECVAR(IRC,JRC,KRC,CC_EGSC,IEC)==CC_GASPHASE) THEN
                     CEP = (DXX(1) - ABS(XB_IB))/DEL_EP; CB=DXX(1)/DEL_EP
                     ! WRITE(LU_ERR,*) ' '
                     ! WRITE(LU_ERR,*) 'EDGE JAXIS=',IRC,JRC,KRC,CEP,CB
                     ! WRITE(LU_ERR,*) 'OLD DUIDXJ=',CC_RCEDGE(IRCEDG)%DUIDXJ(ICD_SGN),CC_RCEDGE(IRCEDG)%MU_DUIDXJ(ICD_SGN)
                     ! WRITE(LU_ERR,*) 'EP  DUIDXJ=',DUIDXJ_EP(ICD_SGN),MU_DUIDXJ_EP(ICD_SGN)
                     ! WRITE(LU_ERR,*) 'B   DUIDXJ=',DUIDXJ (ICD_SGN),MU_DUIDXJ (ICD_SGN)
                     CC_RCEDGE(IRCEDG)%DUIDXJ((/ -ICD, ICD /))     = 0.5_EB*(CC_RCEDGE(IRCEDG)%DUIDXJ(ICD_SGN) + &
                                                                      CEP*   DUIDXJ_EP(ICD_SGN) + CB*   DUIDXJ(ICD_SGN))
                     CC_RCEDGE(IRCEDG)%MU_DUIDXJ((/ -ICD, ICD /))  = 0.5_EB*(CC_RCEDGE(IRCEDG)%MU_DUIDXJ(ICD_SGN) + &
                                                                      CEP*MU_DUIDXJ_EP(ICD_SGN) + CB*MU_DUIDXJ(ICD_SGN))
                     ! WRITE(LU_ERR,*) 'NEW   DUIDXJ=',CC_RCEDGE(IRCEDG)%DUIDXJ(ICD_SGN), CC_RCEDGE(IRCEDG)%MU_DUIDXJ(ICD_SGN)
                     ! WRITE(LU_ERR,*) 'OTHER DUIDXJ=',CC_RCEDGE(IRCEDG)%DUIDXJ(-ICD_SGN),CC_RCEDGE(IRCEDG)%MU_DUIDXJ(-ICD_SGN)
                  ENDIF
               ENDIF
            ENDIF
         CASE(KAXIS) IEC_SELECT_2
            ! Define Face indexes and normal axis FAXIS.
            SELECT CASE(ICD_SGN)
               CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=IAXIS
               CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
               CASE( 1); IIF=II+1; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
               CASE( 2); IIF=II  ; JJF=JJ+1; KKF=KK  ; FAXIS=IAXIS
            END SELECT
            IF(FCVAR(IIF,JJF,KKF,CC_FGSC,FAXIS)/=CC_CUTCFE) CYCLE SIGN_LOOP
            DXX(1)  = DX(IIF); DXX(2)  = DY(JJF)

            IF (FAXIS==IAXIS) THEN
               DEL_EP = DXX(2) - ABS(XB_IB)
               IF( DEL_EP < THRES_FCT_EP*DXX(2) ) THEN
                  DEL_EP = DEL_EP + DXX(2);
                  IRC=II; JRC=JJ+I_SGN; KRC=KK
                  IRCEDG = ECVAR(IRC,JRC,KRC,CC_IDCE,IEC)
                  IF (IRCEDG>0 .AND. ECVAR(IRC,JRC,KRC,CC_EGSC,IEC)==CC_GASPHASE) THEN
                     CEP = (DXX(2) - ABS(XB_IB))/DEL_EP; CB=DXX(2)/DEL_EP
                     CC_RCEDGE(IRCEDG)%DUIDXJ((/ -ICD, ICD /))    = 0.5_EB*(CC_RCEDGE(IRCEDG)%DUIDXJ(ICD_SGN) + &
                                                                     CEP*   DUIDXJ_EP(ICD_SGN) + CB*   DUIDXJ(ICD_SGN))
                     CC_RCEDGE(IRCEDG)%MU_DUIDXJ((/ -ICD, ICD /)) = 0.5_EB*(CC_RCEDGE(IRCEDG)%MU_DUIDXJ(ICD_SGN) + &
                                                                     CEP*MU_DUIDXJ_EP(ICD_SGN) + CB*MU_DUIDXJ(ICD_SGN))
                  ENDIF
               ENDIF
            ELSE ! IF(FAXIS==JAXIS) THEN
               DEL_EP = DXX(1) - ABS(XB_IB)
               IF( DEL_EP < THRES_FCT_EP*DXX(1) ) THEN
                  DEL_EP = DEL_EP + DXX(1);
                  IRC=II+I_SGN; JRC=JJ; KRC=KK
                  IRCEDG = ECVAR(IRC,JRC,KRC,CC_IDCE,IEC)
                  IF (IRCEDG>0 .AND. ECVAR(IRC,JRC,KRC,CC_EGSC,IEC)==CC_GASPHASE) THEN
                     CEP = (DXX(1) - ABS(XB_IB))/DEL_EP; CB=DXX(1)/DEL_EP
                     CC_RCEDGE(IRCEDG)%DUIDXJ((/ -ICD, ICD /))    = 0.5_EB*(CC_RCEDGE(IRCEDG)%DUIDXJ(ICD_SGN) + &
                                                                     CEP*   DUIDXJ_EP(ICD_SGN) + CB*   DUIDXJ(ICD_SGN))
                     CC_RCEDGE(IRCEDG)%MU_DUIDXJ((/ -ICD, ICD /)) = 0.5_EB*(CC_RCEDGE(IRCEDG)%MU_DUIDXJ(ICD_SGN) + &
                                                                     CEP*MU_DUIDXJ_EP(ICD_SGN) + CB*MU_DUIDXJ(ICD_SGN))
                  ENDIF
               ENDIF
            ENDIF
      END SELECT IEC_SELECT_2

   ENDDO SIGN_LOOP
ENDDO ORIENTATION_LOOP

! Cycle out of the EDGE_LOOP if no tangential gradients have been altered.

IF (.NOT.ANY(ALTERED_GRADIENT)) RETURN

! Loop over all 4 normal directions and compute vorticity and stress tensor components for each

SIGN_LOOP_2: DO I_SGN=-1,1,2
   ORIENTATION_LOOP_2: DO ICD=1,2
      IF (ICD==1) THEN
         ICDO=2
      ELSE ! ICD=2
         ICDO=1
      ENDIF
      ICD_SGN = I_SGN*ICD
      IF (ALTERED_GRADIENT(ICD_SGN)) THEN ! Note, altered gradients are extrapolated to IB edge using boundary B and external EP.
            !DUIDXJ_USE(ICD) = EC_B(ICD_SGN)*DUIDXJ(ICD_SGN)  +  EC_EP(ICD_SGN)*DUIDXJ_EP(ICD_SGN)
            DUIDXJ_USE(ICD) =               DUIDXJ(ICD_SGN)
         MU_DUIDXJ_USE(ICD) = EC_B(ICD_SGN)*MU_DUIDXJ(ICD_SGN)  + EC_EP(ICD_SGN)*MU_DUIDXJ_EP(ICD_SGN)
      ELSEIF (ALTERED_GRADIENT(-ICD_SGN)) THEN
            !DUIDXJ_USE(ICD) = EC_B(-ICD_SGN)*DUIDXJ(-ICD_SGN) + EC_EP(-ICD_SGN)*DUIDXJ_EP(-ICD_SGN)
            DUIDXJ_USE(ICD) =                DUIDXJ(-ICD_SGN)
         MU_DUIDXJ_USE(ICD) = EC_B(-ICD_SGN)*MU_DUIDXJ(-ICD_SGN) + EC_EP(-ICD_SGN)*MU_DUIDXJ_EP(-ICD_SGN)
      ELSE
         CYCLE ORIENTATION_LOOP_2
      ENDIF
      ICDO_SGN = I_SGN*ICDO
      IF (ALTERED_GRADIENT(ICDO_SGN) .AND. .NOT.CC_EDGE%SIDE_IN_GEOM(ICDO_SGN)) THEN
            !DUIDXJ_USE(ICDO) = EC_B(ICDO_SGN)*DUIDXJ(ICDO_SGN)  +  EC_EP(ICDO_SGN)*DUIDXJ_EP(ICDO_SGN)
            DUIDXJ_USE(ICDO) =                 DUIDXJ(ICDO_SGN)
         MU_DUIDXJ_USE(ICDO) = EC_B(ICDO_SGN)*MU_DUIDXJ(ICDO_SGN) + EC_EP(ICDO_SGN)*MU_DUIDXJ_EP(ICDO_SGN)
      ELSEIF (ALTERED_GRADIENT(-ICDO_SGN) .AND. .NOT.CC_EDGE%SIDE_IN_GEOM(-ICDO_SGN)) THEN
            !DUIDXJ_USE(ICDO) = EC_B(-ICDO_SGN)*DUIDXJ(-ICDO_SGN) + EC_EP(-ICDO_SGN)*DUIDXJ_EP(-ICDO_SGN)
            DUIDXJ_USE(ICDO) =                 DUIDXJ(-ICDO_SGN)
         MU_DUIDXJ_USE(ICDO) = EC_B(-ICDO_SGN)*MU_DUIDXJ(-ICDO_SGN) + EC_EP(-ICDO_SGN)*MU_DUIDXJ_EP(-ICDO_SGN)
      ELSE
            DUIDXJ_USE(ICDO) = 0._EB
         MU_DUIDXJ_USE(ICDO) = 0._EB
      ENDIF
      EDGE(IE)%OMEGA(ICD_SGN) =    DUIDXJ_USE(1) -    DUIDXJ_USE(2)
      EDGE(IE)%TAU(ICD_SGN)   = MU_DUIDXJ_USE(1) + MU_DUIDXJ_USE(2)
   ENDDO ORIENTATION_LOOP_2
ENDDO SIGN_LOOP_2

END SUBROUTINE CC_EDGE_TAU_OMG

! SUBROUTINE GET_QUAD_VEL(DF,DE,UF,UE,UB,USTR_2)
!
! REAL(EB), INTENT(IN) :: DF,DE,UF,UE,UB
! REAL(EB), INTENT(OUT):: USTR_2
! ! Local variables:
! REAL(EB) :: B_POLY, C_POLY
!
! B_POLY = -(2._EB*(DE**2*UB + 2._EB*DF**2*UB - DE**2*UF + DF**2*UE - 3._EB*DF**2*UF + &
!                   3._EB*DE*DF*UB - 3._EB*DE*DF*UF))/(DF*(DE + DF)**2 + TWO_EPSILON_EB)
! C_POLY =  (3._EB*(DE*UB + DF*UB - DE*UF + DF*UE - 2._EB*DF*UF))/(DF*(DE + DF)**2 + TWO_EPSILON_EB)
! USTR_2  =  UB + B_POLY*DXN_STRM_UB/2._EB + C_POLY*(DXN_STRM_UB/2._EB)**2
!
! RETURN
! END SUBROUTINE GET_QUAD_VEL

END SUBROUTINE CC_VELOCITY_BC

! ! ------------------------- CC_RESCALE_FACE_FORCE ---------------------------
!
! SUBROUTINE CC_RESCALE_FACE_FORCE(NM)
!
! INTEGER, INTENT(IN) :: NM
!
! ! Local Vars:
! INTEGER :: ICF,I,J,K,X1AXIS
! !REAL(EB):: AREA_CF
!
! CUTFACE_LOOP : DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
!
!    IF ( CUT_FACE(ICF)%STATUS /= CC_GASPHASE) CYCLE
!    ! IW = CUT_FACE(ICF)%IWC
!    ! IF ( (IW > 0) .AND. (WALL(IW)%BOUNDARY_TYPE==SOLID_BOUNDARY   .OR. &
!    !                      WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY    .OR. &
!    !                      WALL(IW)%BOUNDARY_TYPE==MIRROR_BOUNDARY) ) CYCLE ! Here force Open boundaries.
!
!    I      = CUT_FACE(ICF)%IJK(IAXIS)
!    J      = CUT_FACE(ICF)%IJK(JAXIS)
!    K      = CUT_FACE(ICF)%IJK(KAXIS)
!    X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)
!    ! AREA_CF   = SUM(CUT_FACE(ICF)%AREA(1:CUT_FACE(ICF)%NFACE))
!
!    SELECT CASE(X1AXIS)
!    CASE(IAXIS); FVX(I,J,K) = FVX(I,J,K)*CUT_FACE(ICF)%VOLFCT_CRF !AREA_CF/(DY(J)*DZ(K))
!    CASE(JAXIS); FVY(I,J,K) = FVY(I,J,K)*CUT_FACE(ICF)%VOLFCT_CRF !AREA_CF/(DX(I)*DZ(K))
!    CASE(KAXIS); FVZ(I,J,K) = FVZ(I,J,K)*CUT_FACE(ICF)%VOLFCT_CRF !AREA_CF/(DX(I)*DY(J))
!    END SELECT
!
! ENDDO CUTFACE_LOOP
!
!
! RETURN
! END SUBROUTINE CC_RESCALE_FACE_FORCE


! --------------------------- CC_VELOCITY_FLUX ------------------------------

SUBROUTINE CC_VELOCITY_FLUX(NM,DT,APPLY_TO_ESTIMATED_VARIABLES,RHOP,CORRECT_GRAV,GX,GY,GZ)

! Assumes POINT_TO_MESH has been called.

INTEGER, INTENT(IN) :: NM
LOGICAL, INTENT(IN) :: APPLY_TO_ESTIMATED_VARIABLES,CORRECT_GRAV
REAL(EB),INTENT(IN) :: DT
REAL(EB),INTENT(IN), OPTIONAL :: GX(0:IBAR_MAX),GY(0:IBAR_MAX),GZ(0:IBAR_MAX)
REAL(EB), INTENT(IN), POINTER, DIMENSION(:,:,:) :: RHOP

! Local Variables:
INTEGER  :: ICF,IRC,I,J,K,X1AXIS,JCF,ICC,JCC,ISIDE !,IOR,IW
REAL(EB) :: TNOW, TNOW2, RRHO, X1F, IDX, CCM1, CCP1, RHOV(-1:0), RHO0V(-1:0), FVCC, PRFCT

IF ( FREEZE_VELOCITY .OR. SOLID_PHASE_ONLY ) RETURN
IF (PERIODIC_TEST == 103 .OR. PERIODIC_TEST == 11 .OR. PERIODIC_TEST==7) RETURN

! Dummy for now:
TNOW = DT
TNOW = CURRENT_TIME()

CORRECT_GRAV_IF : IF(CORRECT_GRAV) THEN

PRFCT = 0._EB; IF(APPLY_TO_ESTIMATED_VARIABLES) PRFCT=1._EB
WHERE(FCVAR(0:IBAR,1:JBAR,1:KBAR,CC_FGSC,IAXIS)==CC_SOLID) FVX(0:IBAR,1:JBAR,1:KBAR) = 0._EB
WHERE(FCVAR(1:IBAR,0:JBAR,1:KBAR,CC_FGSC,JAXIS)==CC_SOLID) FVY(1:IBAR,0:JBAR,1:KBAR) = 0._EB
WHERE(FCVAR(1:IBAR,1:JBAR,0:KBAR,CC_FGSC,KAXIS)==CC_SOLID) FVZ(1:IBAR,1:JBAR,0:KBAR) = 0._EB
! Correct the gravity terms for RC and cut-faces:
CUTFACE_LOOP_0 : DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
   CF => CUT_FACE(ICF); IF(CF%STATUS /= CC_GASPHASE) CYCLE CUTFACE_LOOP_0
   I = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
   ! Define cut-face gravity terms sum:
   DO JCF=1,CF%NFACE
      X1F= CF%XYZCEN(X1AXIS,JCF)
      IDX= 1._EB/(CF%XCENHIGH(X1AXIS,JCF)-CF%XCENLOW(X1AXIS,JCF) )
      CCM1= IDX*(CF%XCENHIGH(X1AXIS,JCF)-X1F); CCP1= IDX*(X1F-CF%XCENLOW(X1AXIS, JCF))
      RHOV(-1:0) = 0._EB; RHO0V(-1:0) = 0._EB
      DO ISIDE=-1,0
         SELECT CASE(CF%CELL_LIST(1,ISIDE+2,JCF))
         CASE(CC_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
            ICC = CF%CELL_LIST(2,ISIDE+2,JCF); CC=>CUT_CELL(ICC)
            JCC = CF%CELL_LIST(3,ISIDE+2,JCF)
            RHOV(ISIDE) = PRFCT*CC%RHOS(JCC) + (1._EB-PRFCT)*CC%RHO(JCC)
            RHO0V(ISIDE)= CC%RHO_0(JCC)
         END SELECT
      ENDDO
      ! RHO_FACE =  CCM1*RHOV(-1) +  CCP1*RHOV(0); RHO0_FACE= CCM1*RHO0V(-1) + CCP1*RHO0V(0)
      CF%FN(JCF) = (CCM1*RHO0V(-1) + CCP1*RHO0V(0)) / (CCM1*RHOV(-1) + CCP1*RHOV(0))
   ENDDO
   FVCC = DOT_PRODUCT(CF%FN(1:CF%NFACE),CF%AREA(1:CF%NFACE)) / SUM(CF%AREA(1:CF%NFACE))
   ! Apply unstructured - cartesian correction:
   SELECT CASE(X1AXIS)
   CASE(IAXIS)
      RRHO       = 2._EB / (RHOP(I,J,K)+RHOP(I+1,J,K))
      FVX(I,J,K) = FVX(I,J,K) + GX(I)*(FVCC - RRHO*RHO_0(K))
   CASE(JAXIS)
      RRHO       = 2._EB / (RHOP(I,J,K)+RHOP(I,J+1,K))
      FVY(I,J,K) = FVY(I,J,K) + GY(I)*(FVCC - RRHO*RHO_0(K))
   CASE(KAXIS)
      RRHO       = 2._EB / (RHOP(I,J,K)+RHOP(I,J,K+1))
      FVZ(I,J,K) = FVZ(I,J,K) + GZ(I)*(FVCC - RRHO*0.5_EB*(RHO_0(K)+RHO_0(K+1)))
   END SELECT
ENDDO CUTFACE_LOOP_0

RC_FACE_LOOP : DO IRC=1,MESHES(NM)%CC_NRCFACE_Z
   RCF    =>RC_FACE(IRC)
   I      = RCF%IJK(IAXIS); J = RCF%IJK(JAXIS); K = RCF%IJK(KAXIS); X1AXIS = RCF%IJK(KAXIS+1)
   IDX = 1._EB/(RCF%XCEN(X1AXIS,HIGH_IND)-RCF%XCEN(X1AXIS,LOW_IND))
   SELECT CASE(X1AXIS)
   CASE(IAXIS)
      CCM1= IDX*(RCF%XCEN(X1AXIS,HIGH_IND)-X(I))
      CCP1= IDX*(X(I)-RCF%XCEN(X1AXIS,LOW_IND) )
      RHOV(-1:0) = RHOP(I:I+1,J,K); RHO0V(-1:0) = RHO_0(K)
      IF(CCVAR(I  ,J,K,CC_UNKZ)>0) RHO0V(-1) = RHO_0_CV( CCVAR(I  ,J,K,CC_UNKZ)-UNKZ_IND(NM_START) )
      IF(CCVAR(I+1,J,K,CC_UNKZ)>0) RHO0V( 0) = RHO_0_CV( CCVAR(I+1,J,K,CC_UNKZ)-UNKZ_IND(NM_START) )
      DO ISIDE=-1,0
         SELECT CASE(RCF%CELL_LIST(1,ISIDE+2))
         CASE(CC_FTYPE_CFGAS) ! Cut-cell
            ICC = RCF%CELL_LIST(2,ISIDE+2); JCC = RCF%CELL_LIST(3,ISIDE+2); CC=>CUT_CELL(ICC)
            RHOV(ISIDE) = PRFCT *CC%RHOS(JCC) + (1._EB-PRFCT) *CC%RHO(JCC)
            RHO0V(ISIDE)= CC%RHO_0(JCC)
         END SELECT
      ENDDO
      FVCC = (CCM1*RHO0V(-1) + CCP1*RHO0V(0)) / (CCM1*RHOV(-1) + CCP1*RHOV(0))
      RRHO = 2._EB / (RHOP(I,J,K)+RHOP(I+1,J,K))
      FVX(I,J,K) = FVX(I,J,K) + GX(I)*(FVCC - RRHO*RHO_0(K))
   CASE(JAXIS)
      CCM1= IDX*(RCF%XCEN(X1AXIS,HIGH_IND)-Y(J))
      CCP1= IDX*(Y(J)-RCF%XCEN(X1AXIS,LOW_IND) )
      RHOV(-1:0) = RHOP(I,J:J+1,K); RHO0V(-1:0) = RHO_0(K)
      IF(CCVAR(I,J  ,K,CC_UNKZ)>0) RHO0V(-1) = RHO_0_CV( CCVAR(I,J  ,K,CC_UNKZ)-UNKZ_IND(NM_START) )
      IF(CCVAR(I,J+1,K,CC_UNKZ)>0) RHO0V( 0) = RHO_0_CV( CCVAR(I,J+1,K,CC_UNKZ)-UNKZ_IND(NM_START) )
      DO ISIDE=-1,0
         SELECT CASE(RCF%CELL_LIST(1,ISIDE+2))
         CASE(CC_FTYPE_CFGAS) ! Cut-cell
            ICC = RCF%CELL_LIST(2,ISIDE+2); JCC = RCF%CELL_LIST(3,ISIDE+2); CC=>CUT_CELL(ICC)
            RHOV(ISIDE) = PRFCT *CC%RHOS(JCC) + (1._EB-PRFCT) *CC%RHO(JCC)
            RHO0V(ISIDE)= CC%RHO_0(JCC)
         END SELECT
      ENDDO
      FVCC = (CCM1*RHO0V(-1) + CCP1*RHO0V(0)) / (CCM1*RHOV(-1) + CCP1*RHOV(0))
      RRHO = 2._EB / (RHOP(I,J,K)+RHOP(I,J+1,K))
      FVY(I,J,K) = FVY(I,J,K) + GY(I)*(FVCC - RRHO*RHO_0(K))
   CASE(KAXIS)
      CCM1= IDX*(RCF%XCEN(X1AXIS,HIGH_IND)-Z(K))
      CCP1= IDX*(Z(K)-RCF%XCEN(X1AXIS,LOW_IND) )
      RHOV(-1:0) = RHOP(I,J,K:K+1); RHO0V(-1:0) = RHO_0(K:K+1)
      IF(CCVAR(I,J,K  ,CC_UNKZ)>0) RHO0V(-1) = RHO_0_CV( CCVAR(I,J,K  ,CC_UNKZ)-UNKZ_IND(NM_START) )
      IF(CCVAR(I,J,K+1,CC_UNKZ)>0) RHO0V( 0) = RHO_0_CV( CCVAR(I,J,K+1,CC_UNKZ)-UNKZ_IND(NM_START) )
      DO ISIDE=-1,0
         SELECT CASE(RCF%CELL_LIST(1,ISIDE+2))
         CASE(CC_FTYPE_CFGAS) ! Cut-cell
            ICC = RCF%CELL_LIST(2,ISIDE+2); JCC = RCF%CELL_LIST(3,ISIDE+2); CC=>CUT_CELL(ICC)
            RHOV(ISIDE) = PRFCT *CC%RHOS(JCC) + (1._EB-PRFCT) *CC%RHO(JCC)
            RHO0V(ISIDE)= CC%RHO_0(JCC)
         END SELECT
      ENDDO
      FVCC = (CCM1*RHO0V(-1) + CCP1*RHO0V(0)) / (CCM1*RHOV(-1) + CCP1*RHOV(0))
      RRHO = 2._EB / (RHOP(I,J,K)+RHOP(I,J,K+1))
      FVZ(I,J,K) = FVZ(I,J,K) + GZ(I)*(FVCC - RRHO*0.5_EB*(RHO_0(K)+RHO_0(K+1)))
   END SELECT
ENDDO RC_FACE_LOOP

! Faces with two regular gas cells, one of them belonging to a linked control volume:
CCM1=0.5_EB; CCP1=0.5_EB
DO K=1,KBAR
   DO J=1,JBAR
      DO I=0,IBAR
         IF(ANY(CCVAR(I:I+1,J,K,CC_CGSC) /= CC_GASPHASE)) CYCLE
         IF(ALL(CCVAR(I:I+1,J,K,CC_UNKZ) <= 0)) CYCLE
         RHOV(-1:0) = RHOP(I:I+1,J,K); RHO0V(-1:0) = RHO_0(K)
         IF(CCVAR(I  ,J,K,CC_UNKZ)>0) RHO0V(-1) = RHO_0_CV( CCVAR(I  ,J,K,CC_UNKZ)-UNKZ_IND(NM_START) )
         IF(CCVAR(I+1,J,K,CC_UNKZ)>0) RHO0V( 0) = RHO_0_CV( CCVAR(I+1,J,K,CC_UNKZ)-UNKZ_IND(NM_START) )
         FVCC = (CCM1*RHO0V(-1) + CCP1*RHO0V(0)) / (CCM1*RHOV(-1) + CCP1*RHOV(0))
         RRHO = 2._EB / (RHOP(I,J,K)+RHOP(I+1,J,K))
         FVX(I,J,K) = FVX(I,J,K) + GX(I)*(FVCC - RRHO*RHO_0(K))
      ENDDO
   ENDDO
ENDDO

DO K=1,KBAR
   DO J=0,JBAR
      DO I=1,IBAR
         IF(ANY(CCVAR(I,J:J+1,K,CC_CGSC) /= CC_GASPHASE)) CYCLE
         IF(ALL(CCVAR(I,J:J+1,K,CC_UNKZ) <= 0)) CYCLE
         RHOV(-1:0) = RHOP(I,J:J+1,K); RHO0V(-1:0) = RHO_0(K)
         IF(CCVAR(I,J  ,K,CC_UNKZ)>0) RHO0V(-1) = RHO_0_CV( CCVAR(I,J  ,K,CC_UNKZ)-UNKZ_IND(NM_START) )
         IF(CCVAR(I,J+1,K,CC_UNKZ)>0) RHO0V( 0) = RHO_0_CV( CCVAR(I,J+1,K,CC_UNKZ)-UNKZ_IND(NM_START) )
         FVCC = (CCM1*RHO0V(-1) + CCP1*RHO0V(0)) / (CCM1*RHOV(-1) + CCP1*RHOV(0))
         RRHO = 2._EB / (RHOP(I,J,K)+RHOP(I,J+1,K))
         FVY(I,J,K) = FVY(I,J,K) + GY(I)*(FVCC - RRHO*RHO_0(K))
      ENDDO
   ENDDO
ENDDO

DO K=0,KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         IF(ANY(CCVAR(I,J,K:K+1,CC_CGSC) /= CC_GASPHASE)) CYCLE
         IF(ALL(CCVAR(I,J,K:K+1,CC_UNKZ) <= 0)) CYCLE
         RHOV(-1:0) = RHOP(I,J,K:K+1); RHO0V(-1:0) = RHO_0(K:K+1)
         IF(CCVAR(I,J,K  ,CC_UNKZ)>0) RHO0V(-1) = RHO_0_CV( CCVAR(I,J,K  ,CC_UNKZ)-UNKZ_IND(NM_START) )
         IF(CCVAR(I,J,K+1,CC_UNKZ)>0) RHO0V( 0) = RHO_0_CV( CCVAR(I,J,K+1,CC_UNKZ)-UNKZ_IND(NM_START) )
         FVCC = (CCM1*RHO0V(-1) + CCP1*RHO0V(0)) / (CCM1*RHOV(-1) + CCP1*RHOV(0))
         RRHO = 2._EB / (RHOP(I,J,K)+RHOP(I,J,K+1))
         FVZ(I,J,K) = FVZ(I,J,K) + GZ(I)*(FVCC - RRHO*0.5_EB*(RHO_0(K)+RHO_0(K+1)))
      ENDDO
   ENDDO
ENDDO

ELSE CORRECT_GRAV_IF

! For now add the value of FV into CUT_FACE(ICF)%FN
CALL CC_STORE_FACE_FV(NM,SUBSTRACT_BAROCLINIC=.FALSE.)

CUTFACE_LOOP : DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
   IF ( CUT_FACE(ICF)%STATUS /= CC_GASPHASE) CYCLE CUTFACE_LOOP
   CUT_FACE(ICF)%FN(1:CUT_FACE(ICF)%NFACE) = CUT_FACE(ICF)%FV
ENDDO CUTFACE_LOOP

ENDIF CORRECT_GRAV_IF

T_USED(14) = T_USED(14) + CURRENT_TIME() - TNOW
IF (TIME_CC_IBM) T_CC_USED(CC_VELOCITY_FLUX_TIME_INDEX) = T_CC_USED(CC_VELOCITY_FLUX_TIME_INDEX) + CURRENT_TIME() - TNOW2
RETURN
END SUBROUTINE CC_VELOCITY_FLUX


SUBROUTINE GET_LINKED_FV(NM,DO_BAROCLINIC)

! This routine assumes POINT_TO_MESH(NM) has been called.

INTEGER, INTENT(IN) :: NM
LOGICAL, INTENT(IN) :: DO_BAROCLINIC

INTEGER :: I, J, K, ICF, JCF, X1AXIS
REAL(EB), ALLOCATABLE, DIMENSION(:) :: FLINK,ALINK
REAL(EB), POINTER, DIMENSION(:,:,:) :: FVXP, FVYP, FVZP

CALL POINT_TO_MESH(NM)

ALLOCATE(FLINK(0:MESHES(NM)%NUNK_F),ALINK(0:MESHES(NM)%NUNK_F)); FLINK = 0._EB; ALINK = 0._EB

IF (DO_BAROCLINIC) THEN
   FVXP => FVX_B; FVYP => FVY_B; FVZP => FVZ_B
ELSE
   FVXP => FVX  ; FVYP => FVY  ; FVZP => FVZ
ENDIF

! Regular faces:
DO K=0,KBAR
   DO J=0,JBAR
      DO I=0,IBAR
         ! X face:
         IF (FCVAR(I,J,K,CC_UNKF,IAXIS)>0) THEN
            FLINK(FCVAR(I,J,K,CC_UNKF,IAXIS)) = FLINK(FCVAR(I,J,K,CC_UNKF,IAXIS)) + FVXP(I,J,K)*DY(J)*DZ(K)
            ALINK(FCVAR(I,J,K,CC_UNKF,IAXIS)) = ALINK(FCVAR(I,J,K,CC_UNKF,IAXIS)) + DY(J)*DZ(K)
         ENDIF
         ! Y face:
         IF (FCVAR(I,J,K,CC_UNKF,JAXIS)>0) THEN
            FLINK(FCVAR(I,J,K,CC_UNKF,JAXIS)) = FLINK(FCVAR(I,J,K,CC_UNKF,JAXIS)) + FVYP(I,J,K)*DX(I)*DZ(K)
            ALINK(FCVAR(I,J,K,CC_UNKF,JAXIS)) = ALINK(FCVAR(I,J,K,CC_UNKF,JAXIS)) + DX(I)*DZ(K)
         ENDIF
         ! Z face:
         IF (FCVAR(I,J,K,CC_UNKF,KAXIS)>0) THEN
            FLINK(FCVAR(I,J,K,CC_UNKF,KAXIS)) = FLINK(FCVAR(I,J,K,CC_UNKF,KAXIS)) + FVZP(I,J,K)*DX(I)*DY(J)
            ALINK(FCVAR(I,J,K,CC_UNKF,KAXIS)) = ALINK(FCVAR(I,J,K,CC_UNKF,KAXIS)) + DX(I)*DY(J)
         ENDIF
      ENDDO
   ENDDO
ENDDO
! RC faces:
DO ICF=1,MESHES(NM)%CC_NRCFACE_Z
   IF(RC_FACE(ICF)%UNKF<1) CYCLE
   I = RC_FACE(ICF)%IJK(IAXIS); J = RC_FACE(ICF)%IJK(JAXIS); K = RC_FACE(ICF)%IJK(KAXIS)
   X1AXIS = RC_FACE(ICF)%IJK(KAXIS+1)
   SELECT CASE(X1AXIS)
   CASE(IAXIS)
      FLINK(RC_FACE(ICF)%UNKF) = FLINK(RC_FACE(ICF)%UNKF) + FVXP(I,J,K)*DY(J)*DZ(K)
      ALINK(RC_FACE(ICF)%UNKF) = ALINK(RC_FACE(ICF)%UNKF) + DY(J)*DZ(K)
   CASE(JAXIS)
      FLINK(RC_FACE(ICF)%UNKF) = FLINK(RC_FACE(ICF)%UNKF) + FVYP(I,J,K)*DX(I)*DZ(K)
      ALINK(RC_FACE(ICF)%UNKF) = ALINK(RC_FACE(ICF)%UNKF) + DX(I)*DZ(K)
   CASE(KAXIS)
      FLINK(RC_FACE(ICF)%UNKF) = FLINK(RC_FACE(ICF)%UNKF) + FVZP(I,J,K)*DX(I)*DY(J)
      ALINK(RC_FACE(ICF)%UNKF) = ALINK(RC_FACE(ICF)%UNKF) + DX(I)*DY(J)
   END SELECT
ENDDO
! Cut-faces:
IF(DO_BAROCLINIC) THEN
   DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      CF => CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE
      IF(TWO_D .AND. CF%IJK(KAXIS+1)==JAXIS) CYCLE
      DO JCF=1,CF%NFACE
         FLINK(CF%UNKF(JCF)) = FLINK(CF%UNKF(JCF)) + CF%FN_B(JCF)*CF%AREA(JCF)
         ALINK(CF%UNKF(JCF)) = ALINK(CF%UNKF(JCF)) + CF%AREA(JCF)
      ENDDO
   ENDDO
ELSE
   DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      CF => CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE
      IF(TWO_D .AND. CF%IJK(KAXIS+1)==JAXIS) CYCLE
      DO JCF=1,CF%NFACE
         FLINK(CF%UNKF(JCF)) = FLINK(CF%UNKF(JCF)) + CF%FN(JCF)*CF%AREA(JCF)
         ALINK(CF%UNKF(JCF)) = ALINK(CF%UNKF(JCF)) + CF%AREA(JCF)
      ENDDO
   ENDDO
ENDIF

! Area Average F:
FLINK(0) = 0._EB ! Unlinked small faces.
DO I=1,MESHES(NM)%NUNK_F
  FLINK(I) = FLINK(I) / ALINK(I)
ENDDO

! Restore Linked F values:
DO K=0,KBAR
   DO J=0,JBAR
      DO I=0,IBAR
         IF (FCVAR(I,J,K,CC_UNKF,IAXIS)>0)                  FVXP(I,J,K) = FLINK(FCVAR(I,J,K,CC_UNKF,IAXIS))
         IF (FCVAR(I,J,K,CC_UNKF,JAXIS)>0 .AND. .NOT.TWO_D) FVYP(I,J,K) = FLINK(FCVAR(I,J,K,CC_UNKF,JAXIS))
         IF (FCVAR(I,J,K,CC_UNKF,KAXIS)>0)                  FVZP(I,J,K) = FLINK(FCVAR(I,J,K,CC_UNKF,KAXIS))
      ENDDO
   ENDDO
ENDDO
DO ICF=1,MESHES(NM)%CC_NRCFACE_Z
   IF(RC_FACE(ICF)%UNKF<1) CYCLE
   I = RC_FACE(ICF)%IJK(IAXIS); J = RC_FACE(ICF)%IJK(JAXIS); K = RC_FACE(ICF)%IJK(KAXIS)
   X1AXIS = RC_FACE(ICF)%IJK(KAXIS+1)
   SELECT CASE(X1AXIS)
   CASE(IAXIS); FVXP(I,J,K) = FLINK(RC_FACE(ICF)%UNKF)
   CASE(JAXIS); IF(.NOT.TWO_D) FVYP(I,J,K) = FLINK(RC_FACE(ICF)%UNKF)
   CASE(KAXIS); FVZP(I,J,K) = FLINK(RC_FACE(ICF)%UNKF)
   END SELECT
ENDDO
IF(DO_BAROCLINIC) THEN
   DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      CF => CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE
      IF(TWO_D .AND. CF%IJK(KAXIS+1)==JAXIS) CYCLE
      I = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
      DO JCF=1,CF%NFACE; CF%FN_B(JCF) = FLINK(CF%UNKF(JCF)); ENDDO
      CF%FV_B = DOT_PRODUCT(CF%FN_B(1:CF%NFACE),CF%AREA(1:CF%NFACE))/SUM(CF%AREA(1:CF%NFACE))
      SELECT CASE(X1AXIS)
      CASE(IAXIS); FVXP(I,J,K) = CF%FV_B
      CASE(JAXIS); FVYP(I,J,K) = CF%FV_B
      CASE(KAXIS); FVZP(I,J,K) = CF%FV_B
      END SELECT
   ENDDO
ELSE
   DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      CF => CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE
      IF(TWO_D .AND. CF%IJK(KAXIS+1)==JAXIS) CYCLE
      I = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
      DO JCF=1,CF%NFACE; CF%FN(JCF) = FLINK(CF%UNKF(JCF)); ENDDO
      CF%FV = DOT_PRODUCT(CF%FN(1:CF%NFACE),CF%AREA(1:CF%NFACE))/SUM(CF%AREA(1:CF%NFACE))
      SELECT CASE(X1AXIS)
      CASE(IAXIS); FVXP(I,J,K) = CF%FV
      CASE(JAXIS); FVYP(I,J,K) = CF%FV
      CASE(KAXIS); FVZP(I,J,K) = CF%FV
      END SELECT
   ENDDO
ENDIF

DEALLOCATE(FLINK,ALINK)

END SUBROUTINE GET_LINKED_FV


! ! ---------------------------- DEBUG_WAIT ---------------------------------------
!
! #if defined(DEBUG_CC_INTERPOLATION)
! SUBROUTINE DEBUG_WAIT
! USE COMP_FUNCTIONS, ONLY: FDS_SLEEP
! INTEGER I
! INTEGER, PARAMETER :: N_SEG=20
! WRITE(LU_ERR,'(A,I6,A,I2,A)') 'Process ID=',MY_RANK,'; execution halted for ',N_SEG,' seconds : '
! DO I=1,N_SEG
!    CALL FDS_SLEEP(1)
!    IF (I<N_SEG) THEN
!       WRITE(LU_ERR,'(I2,A)',ADVANCE="no") I,', '
!    ELSE
!       WRITE(LU_ERR,'(I2,A)') I,'.'
!    ENDIF
! ENDDO
! RETURN
! END SUBROUTINE DEBUG_WAIT
! #endif /* defined(DEBUG_CC_INTERPOLATION) */

! ! ---------------------------- GET_LOCAL_VELOCITY ------------------------------

! SUBROUTINE GET_LOCAL_VELOCITY(U_RELA,NN,TT,SS,U_NORM,U_ORTH,U_STRM)
! USE MATH_FUNCTIONS, ONLY: CROSS_PRODUCT

! REAL(EB), INTENT(IN) :: NN(IAXIS:KAXIS), U_RELA(IAXIS:KAXIS)
! REAL(EB), INTENT(OUT):: TT(IAXIS:KAXIS), SS(IAXIS:KAXIS), U_NORM, U_ORTH, U_STRM

! ! Local Variables:
! REAL(EB), DIMENSION(3), PARAMETER :: E1=(/1._EB,0._EB,0._EB/),E2=(/0._EB,1._EB,0._EB/),E3=(/0._EB,0._EB,1._EB/)
! REAL(EB), DIMENSION(3,3) :: C

! ! find a vector TT in the tangent plane of the surface and orthogonal to U_VELO-U_SURF
! CALL CROSS_PRODUCT(TT,NN,U_RELA) ! TT = NN x U_RELA
! IF (ABS(NORM2(TT))<=TWO_EPSILON_EB) THEN
!    ! tangent vector is completely arbitrary, just perpendicular to NN
!    IF (ABS(NN(1))>=TWO_EPSILON_EB .OR.  ABS(NN(2))>=TWO_EPSILON_EB) TT = (/NN(2),-NN(1),0._EB/)
!    IF (ABS(NN(1))<=TWO_EPSILON_EB .AND. ABS(NN(2))<=TWO_EPSILON_EB) TT = (/NN(3),0._EB,-NN(1)/)
! ENDIF
! TT = TT/NORM2(TT) ! normalize to unit vector
! CALL CROSS_PRODUCT(SS,TT,NN) ! define the streamwise unit vector SS

! ! directional cosines (see Pope, Eq. A.11)
! C(1,1) = DOT_PRODUCT(E1,SS)
! C(1,2) = DOT_PRODUCT(E1,TT)
! C(1,3) = DOT_PRODUCT(E1,NN)
! C(2,1) = DOT_PRODUCT(E2,SS)
! C(2,2) = DOT_PRODUCT(E2,TT)
! C(2,3) = DOT_PRODUCT(E2,NN)
! C(3,1) = DOT_PRODUCT(E3,SS)
! C(3,2) = DOT_PRODUCT(E3,TT)
! C(3,3) = DOT_PRODUCT(E3,NN)

! ! transform velocity (see Pope, Eq. A.17)
! U_STRM = C(1,1)*U_RELA(1) + C(2,1)*U_RELA(2) + C(3,1)*U_RELA(3)
! U_ORTH = C(1,2)*U_RELA(1) + C(2,2)*U_RELA(2) + C(3,2)*U_RELA(3)
! U_NORM = C(1,3)*U_RELA(1) + C(2,3)*U_RELA(2) + C(3,3)*U_RELA(3)

! RETURN
! END SUBROUTINE GET_LOCAL_VELOCITY


! ------------------------------- CC_NO_FLUX ---------------------------------

SUBROUTINE CC_NO_FLUX(DT,NM,FORCE_FLG)

! Force to zero velocities on faces of type CC_SOLID.

INTEGER, INTENT(IN) :: NM
REAL(EB), INTENT(IN):: DT
LOGICAL, INTENT(IN) :: FORCE_FLG

! Local Variables:
REAL(EB), POINTER, DIMENSION(:,:,:) :: HP
REAL(EB):: U_IBM,V_IBM,W_IBM,DUUDT,DVVDT,DWWDT,RFODT,TNOW,UN,AFCT,IDX
INTEGER :: I,J,K,II,JJ,KK,IOR,IW,ICF,JCF,X1AXIS,NOM,IFACE,JFACE
TYPE(WALL_TYPE), POINTER :: WC
TYPE(EXTERNAL_WALL_TYPE), POINTER :: EWC
TYPE(CFACE_TYPE), POINTER :: CFA


! This is the CCIBM forcing routine for momentum eqns.

IF (SOLID_PHASE_ONLY .OR. FREEZE_VELOCITY) RETURN
IF ( PERIODIC_TEST == 103 .OR. PERIODIC_TEST == 11 .OR. PERIODIC_TEST==7) RETURN

TNOW=CURRENT_TIME()

RFODT = RELAXATION_FACTOR/DT

CALL POINT_TO_MESH(NM)

IF (PREDICTOR) HP => H
IF (CORRECTOR) HP => HS

FORCE_IF : IF (FORCE_FLG) THEN

   U_IBM = 0._EB; V_IBM = 0._EB; W_IBM = 0._EB
   IF (PRESSURE_ITERATIONS==1) THEN
      CUTFACE_LOOP_2A : DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
         CF => CUT_FACE(ICF); IF ( CF%STATUS /= CC_GASPHASE) CYCLE CUTFACE_LOOP_2A
         I      = CF%IJK(IAXIS)
         J      = CF%IJK(JAXIS)
         K      = CF%IJK(KAXIS)
         X1AXIS = CF%IJK(KAXIS+1)
         SELECT CASE(X1AXIS)
               CASE(IAXIS)
                  IF (CF%ALPHA_CF > A_THRESH_FORCING) CYCLE CUTFACE_LOOP_2A
                  CF%FN(1:CF%NFACE) = 0._EB; CF%FN_B(1:CF%NFACE) = 0._EB
                  IDX = RDXN(I)
                  DO JCF=1,CF%NFACE
                     IF (PREDICTOR) DUUDT = (U_IBM-CF%VEL(JCF))/DT
                     IF (CORRECTOR) DUUDT = (2._EB*U_IBM-(CF%VEL(JCF)+CF%VELS(JCF)))/DT
                     IDX=1._EB/(CF%XCENHIGH(X1AXIS,JCF) - CF%XCENLOW( X1AXIS,JCF))
                     CF%FN(JCF)   = -IDX*(HP(I+1,J,K)-HP(I,J,K)) - DUUDT
                     CF%FN_B(JCF) = 0._EB
                  ENDDO
               CASE(JAXIS)
                  IF (CF%ALPHA_CF > A_THRESH_FORCING) CYCLE CUTFACE_LOOP_2A
                  CF%FN(1:CF%NFACE) = 0._EB; CF%FN_B(1:CF%NFACE) = 0._EB
                  IDX = RDYN(J)
                  DO JCF=1,CF%NFACE
                     IF (PREDICTOR) DVVDT = (V_IBM-CF%VEL(JCF))/DT
                     IF (CORRECTOR) DVVDT = (2._EB*V_IBM-(CF%VEL(JCF)+CF%VELS(JCF)))/DT
                     IDX=1._EB/(CF%XCENHIGH(X1AXIS,JCF) - CF%XCENLOW( X1AXIS,JCF))
                     CF%FN(JCF)   = -IDX*(HP(I,J+1,K)-HP(I,J,K)) - DVVDT
                     CF%FN_B(JCF) = 0._EB
                  ENDDO
               CASE(KAXIS)
                  IF (CF%ALPHA_CF > A_THRESH_FORCING) CYCLE CUTFACE_LOOP_2A
                  CF%FN(1:CF%NFACE) = 0._EB; CF%FN_B(1:CF%NFACE) = 0._EB
                  IDX = RDZN(K)
                  DO JCF=1,CF%NFACE
                     IF (PREDICTOR) DWWDT = (W_IBM-CF%VEL(JCF))/DT
                     IF (CORRECTOR) DWWDT = (2._EB*W_IBM-(CF%VEL(JCF)+CF%VELS(JCF)))/DT
                     IDX=1._EB/(CF%XCENHIGH(X1AXIS,JCF) - CF%XCENLOW( X1AXIS,JCF))
                     CF%FN(JCF)   = -IDX*(HP(I,J,K+1)-HP(I,J,K)) - DWWDT
                     CF%FN_B(JCF) = 0._EB
                  ENDDO
            END SELECT
      ENDDO CUTFACE_LOOP_2A
   ENDIF

ELSE FORCE_IF

! Here for External CFACEs use the unstructured acceleration in defining F:
CFACE_LOOP : DO ICF=1,N_EXTERNAL_CFACE_CELLS+N_INTWALL_CFACE_CELLS+N_INTERNAL_CFACE_CELLS
   CFA  =>CFACE(ICF)
   IW   =CUT_FACE(CFA%CUT_FACE_IND1)%IWC ! Index of underlaying wall cell.
   IFACE=CFA%CUT_FACE_IND1
   JFACE=CFA%CUT_FACE_IND2
   BC => BOUNDARY_COORD(CFA%BC_INDEX)
   II = BC%II; JJ = BC%JJ; KK = BC%KK; IOR = BC%IOR
   IF ( .NOT.(CFA%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. CFA%BOUNDARY_TYPE==PERIODIC_BOUNDARY) ) THEN
      NOM=0; IF(ICF<=N_EXTERNAL_CFACE_CELLS) NOM = EXTERNAL_WALL(IW)%NOM
      II  = BC%II
      JJ  = BC%JJ
      KK  = BC%KK

      B1 => BOUNDARY_PROP1(CFA%B1_INDEX)
      IF (NOM/=0 .OR. ANY(CFA%BOUNDARY_TYPE==(/SOLID_BOUNDARY,NULL_BOUNDARY,MIRROR_BOUNDARY/))) THEN
         AFCT = 1._EB
         IF(ICF<=N_EXTERNAL_CFACE_CELLS+N_INTWALL_CFACE_CELLS) AFCT = -SIGN(1._EB,REAL(IOR,EB))
         IF (PREDICTOR) THEN
            UN    = AFCT*B1%U_NORMAL_S
            DUUDT = RFODT*(UN-CUT_FACE(IFACE)%VEL(JFACE))
         ELSE
            UN = AFCT*B1%U_NORMAL
            DUUDT = 2._EB*RFODT*(UN-0.5_EB*(CUT_FACE(IFACE)%VEL(JFACE)+CUT_FACE(IFACE)%VELS(JFACE)))
         ENDIF
         CUT_FACE(IFACE)%FN(JFACE) = - DUUDT
      ENDIF
   ENDIF
ENDDO CFACE_LOOP

! Now set WALL_WORK(IW) to zero in EXTERNAL WALL CELLS of type CC_SOLID:
! This Follows what is being done for external boundaries inside OBSTS (NULL_BOUNDARY).
EWC_LOOP : DO IW=1,N_EXTERNAL_WALL_CELLS
   WC => WALL(IW)
   IF (.NOT.(WC%BOUNDARY_TYPE==NULL_BOUNDARY .OR. WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY)) CYCLE
   EWC=>EXTERNAL_WALL(IW)

   BC=>BOUNDARY_COORD(WC%BC_INDEX)
   II = BC%II
   JJ = BC%JJ
   KK = BC%KK
   IOR = BC%IOR

   SELECT CASE(IOR)
   CASE( IAXIS)
      IF(FCVAR(II  ,JJ,KK,CC_FGSC,IAXIS)==CC_SOLID) WALL_WORK1(IW) = 0._EB
   CASE(-IAXIS)
      IF(FCVAR(II-1,JJ,KK,CC_FGSC,IAXIS)==CC_SOLID) WALL_WORK1(IW) = 0._EB
   CASE( JAXIS)
      IF(FCVAR(II,JJ  ,KK,CC_FGSC,JAXIS)==CC_SOLID) WALL_WORK1(IW) = 0._EB
   CASE(-JAXIS)
      IF(FCVAR(II,JJ-1,KK,CC_FGSC,JAXIS)==CC_SOLID) WALL_WORK1(IW) = 0._EB
   CASE( KAXIS)
      IF(FCVAR(II,JJ,KK  ,CC_FGSC,KAXIS)==CC_SOLID) WALL_WORK1(IW) = 0._EB
   CASE(-KAXIS)
      IF(FCVAR(II,JJ,KK-1,CC_FGSC,KAXIS)==CC_SOLID) WALL_WORK1(IW) = 0._EB
   END SELECT

ENDDO EWC_LOOP

ENDIF FORCE_IF

T_USED(14) = T_USED(14) + CURRENT_TIME() - TNOW
IF (TIME_CC_IBM) T_CC_USED(CC_NO_FLUX_TIME_INDEX) = T_CC_USED(CC_NO_FLUX_TIME_INDEX) + CURRENT_TIME() - TNOW
RETURN
END SUBROUTINE CC_NO_FLUX




SUBROUTINE CC_STORE_FACE_FV(NM,SUBSTRACT_BAROCLINIC)

INTEGER, INTENT(IN) :: NM
LOGICAL, INTENT(IN) :: SUBSTRACT_BAROCLINIC

INTEGER :: ICF, I, J, K, X1AXIS

IF (.NOT.SUBSTRACT_BAROCLINIC) THEN

   CF_LOOP_1 : DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      IF ( CUT_FACE(ICF)%STATUS /= CC_GASPHASE) CYCLE CF_LOOP_1
      CUT_FACE(ICF)%FV = 0._EB
      IF(CUT_FACE(ICF)%IWC>0) THEN; IF(WALL(CUT_FACE(ICF)%IWC)%BOUNDARY_TYPE==MIRROR_BOUNDARY) CYCLE CF_LOOP_1; ENDIF
      I      = CUT_FACE(ICF)%IJK(IAXIS)
      J      = CUT_FACE(ICF)%IJK(JAXIS)
      K      = CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)
      SELECT CASE(X1AXIS)
            CASE(IAXIS)
               CUT_FACE(ICF)%FV = FVX(I,J,K)
            CASE(JAXIS)
               CUT_FACE(ICF)%FV = FVY(I,J,K)
            CASE(KAXIS)
               CUT_FACE(ICF)%FV = FVZ(I,J,K)
         END SELECT
   ENDDO CF_LOOP_1

ELSE

   CF_LOOP_2 : DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      IF ( CUT_FACE(ICF)%STATUS /= CC_GASPHASE) CYCLE CF_LOOP_2
      CUT_FACE(ICF)%FV = 0._EB
      IF(CUT_FACE(ICF)%IWC>0) THEN; IF(WALL(CUT_FACE(ICF)%IWC)%BOUNDARY_TYPE==MIRROR_BOUNDARY) CYCLE CF_LOOP_2; ENDIF
      I      = CUT_FACE(ICF)%IJK(IAXIS)
      J      = CUT_FACE(ICF)%IJK(JAXIS)
      K      = CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)
      SELECT CASE(X1AXIS)
            CASE(IAXIS)
               CUT_FACE(ICF)%FV = FVX(I,J,K) - FVX_B(I,J,K)
            CASE(JAXIS)
               CUT_FACE(ICF)%FV = FVY(I,J,K) - FVY_B(I,J,K)
            CASE(KAXIS)
               CUT_FACE(ICF)%FV = FVZ(I,J,K) - FVZ_B(I,J,K)
         END SELECT
   ENDDO CF_LOOP_2

ENDIF

RETURN
END SUBROUTINE CC_STORE_FACE_FV

! ------------------------- CC_COMPUTE_VELOCITY_ERROR -------------------------

SUBROUTINE CC_COMPUTE_VELOCITY_ERROR(DT,NM)

! Compute velocity error on faces of type CC_SOLID.

INTEGER, INTENT(IN) :: NM
REAL(EB), INTENT(IN) :: DT

! Local Variables:
INTEGER :: I,J,K,IW,II,JJ,KK,IOR,X1AXIS,ICF,JCF,IIO,JJO,KKO,IIO1,IIO2,JJO1,JJO2,KKO1,KKO2
REAL(EB):: ITERATIVE_FACTOR, UN_NEW, UN_NEW_OTHER, VELOCITY_ERROR, IDX, DUDT, DVDT, DWDT, DA_OTHER, AREA_FC, TNOW
TYPE(OMESH_TYPE), POINTER :: OM
TYPE(MESH_TYPE), POINTER :: M2
TYPE(WALL_TYPE), POINTER :: WC
TYPE(BOUNDARY_COORD_TYPE), POINTER :: BC
TYPE(BOUNDARY_PROP1_TYPE), POINTER :: B1
TYPE(CC_CUTFACE_TYPE), POINTER :: CF,CF2

IF (SOLID_PHASE_ONLY) RETURN
IF (FREEZE_VELOCITY)  RETURN

TNOW = CURRENT_TIME()

CALL POINT_TO_MESH(NM)

! Here we recompute the average velocity error in external gas cut-faces, and test against other mesh.
! The corresponding WALL_WORK1(IW) term for pressure boundary conditions is updated where necessary.
IF (PREDICTOR) THEN
   ITERATIVE_FACTOR = 0.25_EB
ELSE
   ITERATIVE_FACTOR = 0.50_EB
ENDIF

! Loop over wall cells and check velocity error.

CHECK_WALL_LOOP: DO IW=1,N_EXTERNAL_WALL_CELLS

   WC=>WALL(IW)
   IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY .OR. WC%CUT_FACE_INDEX<1) CYCLE CHECK_WALL_LOOP

   EWC=>EXTERNAL_WALL(IW)
   IF (EWC%AREA_RATIO<0.9_EB) CYCLE CHECK_WALL_LOOP
   OM => OMESH(EWC%NOM)
   M2 => MESHES(EWC%NOM)
   B1 => BOUNDARY_PROP1(WC%B1_INDEX)
   BC => BOUNDARY_COORD(WC%BC_INDEX)

   II  = BC%II
   JJ  = BC%JJ
   KK  = BC%KK
   IOR = BC%IOR

   CF => CUT_FACE(WC%CUT_FACE_INDEX)
   I  = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
   UN_NEW = 0._EB
   ! Update normal component of velocity at the mesh boundary
   IF (PREDICTOR) THEN
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         DO JCF=1,CF%NFACE
            IDX = 1._EB/(CF%XCENHIGH(X1AXIS,JCF)-CF%XCENLOW(X1AXIS,JCF))
            UN_NEW = UN_NEW + (CF%VEL(JCF)-DT*(CF%FN(JCF)+IDX*(H(I+1,J,K)-H(I,J,K))))*CF%AREA(JCF)
         ENDDO
      CASE(JAXIS)
         DO JCF=1,CF%NFACE
            IDX = 1._EB/(CF%XCENHIGH(X1AXIS,JCF)-CF%XCENLOW(X1AXIS,JCF))
            UN_NEW = UN_NEW + (CF%VEL(JCF)-DT*(CF%FN(JCF)+IDX*(H(I,J+1,K)-H(I,J,K))))*CF%AREA(JCF)
         ENDDO
      CASE(KAXIS)
         DO JCF=1,CF%NFACE
            IDX = 1._EB/(CF%XCENHIGH(X1AXIS,JCF)-CF%XCENLOW(X1AXIS,JCF))
            UN_NEW = UN_NEW + (CF%VEL(JCF)-DT*(CF%FN(JCF)+IDX*(H(I,J,K+1)-H(I,J,K))))*CF%AREA(JCF)
         ENDDO
      END SELECT
   ELSE
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         DO JCF=1,CF%NFACE
            IDX = 1._EB/(CF%XCENHIGH(X1AXIS,JCF)-CF%XCENLOW(X1AXIS,JCF))
            UN_NEW = UN_NEW + 0.5_EB*(CF%VEL(JCF)+CF%VELS(JCF)-DT*(CF%FN(JCF)+IDX*(HS(I+1,J,K)-HS(I,J,K))))*CF%AREA(JCF)
         ENDDO
      CASE(JAXIS)
         DO JCF=1,CF%NFACE
            IDX = 1._EB/(CF%XCENHIGH(X1AXIS,JCF)-CF%XCENLOW(X1AXIS,JCF))
            UN_NEW = UN_NEW + 0.5_EB*(CF%VEL(JCF)+CF%VELS(JCF)-DT*(CF%FN(JCF)+IDX*(HS(I,J+1,K)-HS(I,J,K))))*CF%AREA(JCF)
         ENDDO
      CASE(KAXIS)
         DO JCF=1,CF%NFACE
            IDX = 1._EB/(CF%XCENHIGH(X1AXIS,JCF)-CF%XCENLOW(X1AXIS,JCF))
            UN_NEW = UN_NEW + 0.5_EB*(CF%VEL(JCF)+CF%VELS(JCF)-DT*(CF%FN(JCF)+IDX*(HS(I,J,K+1)-HS(I,J,K))))*CF%AREA(JCF)
         ENDDO
      END SELECT

   ENDIF
   UN_NEW = UN_NEW / SUM(CF%AREA(1:CF%NFACE))

   ! At interpolated boundaries, compare updated normal component of velocity with that of the other mesh

   ! NOTE: WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY

   UN_NEW_OTHER = 0._EB
   DA_OTHER = 0._EB

   EWC  =>EXTERNAL_WALL(IW)
   IIO1 = EWC%IIO_MIN
   JJO1 = EWC%JJO_MIN
   KKO1 = EWC%KKO_MIN
   IIO2 = EWC%IIO_MAX
   JJO2 = EWC%JJO_MAX
   KKO2 = EWC%KKO_MAX

   PREDICTOR_IF: IF (PREDICTOR) THEN
      IOR_SELECT_1: SELECT CASE(IOR)
         CASE( 1)
            DO KKO=KKO1,KKO2
               DO JJO=JJO1,JJO2
                  DO IIO=IIO1,IIO2
                     IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                     IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,X1AXIS)==CC_SOLID) CYCLE

                     ICF = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,X1AXIS)
                     IF (ICF>0) THEN
                        CF2 =>M2%CUT_FACE(ICF); IDX = M2%RDXN(IIO)
                        DO JCF=1,CF2%NFACE
                              DA_OTHER = DA_OTHER  + CF2%AREA(JCF)
                              IDX = 1._EB/(CF2%XCENHIGH(X1AXIS,JCF)-CF2%XCENLOW(X1AXIS,JCF))
                              DUDT = -CF2%FN_OMESH(JCF) - IDX*(OM%H(IIO+1,JJO,KKO)-OM%H(IIO,JJO,KKO))
                              UN_NEW_OTHER = UN_NEW_OTHER + (CF2%VEL_OMESH(JCF) + DT*DUDT)*CF2%AREA(JCF)
                        ENDDO
                     ELSE
                        AREA_FC  = M2%DY(JJO)*M2%DZ(KKO); DA_OTHER = DA_OTHER + AREA_FC
                        DUDT = -OM%FVX(IIO,JJO,KKO) - M2%RDXN(IIO)*(OM%H(IIO+1,JJO,KKO)-OM%H(IIO,JJO,KKO))
                        UN_NEW_OTHER = UN_NEW_OTHER + (OM%U(IIO,JJO,KKO) + DT*DUDT)*AREA_FC
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         CASE(-1)
            DO KKO=KKO1,KKO2
               DO JJO=JJO1,JJO2
                  DO IIO=IIO1,IIO2
                     IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                     IF (M2%FCVAR(IIO-1,JJO,KKO,CC_FGSC,X1AXIS)==CC_SOLID) CYCLE

                     ICF = M2%FCVAR(IIO-1,JJO,KKO,CC_IDCF,X1AXIS)
                     IF (ICF>0) THEN
                        CF2 =>M2%CUT_FACE(ICF); IDX = M2%RDXN(IIO-1)
                        DO JCF=1,CF2%NFACE
                              DA_OTHER = DA_OTHER  + CF2%AREA(JCF)
                              IDX = 1._EB/(CF2%XCENHIGH(X1AXIS,JCF)-CF2%XCENLOW(X1AXIS,JCF))
                              DUDT = -CF2%FN_OMESH(JCF) - IDX*(OM%H(IIO,JJO,KKO)-OM%H(IIO-1,JJO,KKO))
                              UN_NEW_OTHER = UN_NEW_OTHER + (CF2%VEL_OMESH(JCF) + DT*DUDT)*CF2%AREA(JCF)
                        ENDDO
                     ELSE
                        AREA_FC  = M2%DY(JJO)*M2%DZ(KKO); DA_OTHER = DA_OTHER + AREA_FC
                        DUDT = -OM%FVX(IIO-1,JJO,KKO) - M2%RDXN(IIO-1)*(OM%H(IIO,JJO,KKO)-OM%H(IIO-1,JJO,KKO))
                        UN_NEW_OTHER = UN_NEW_OTHER + (OM%U(IIO-1,JJO,KKO) + DT*DUDT)*AREA_FC
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         CASE( 2)
            DO KKO=KKO1,KKO2
               DO JJO=JJO1,JJO2
                  DO IIO=IIO1,IIO2
                     IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                     IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,X1AXIS)==CC_SOLID) CYCLE

                     ICF = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,X1AXIS)
                     IF (ICF>0) THEN
                        CF2 =>M2%CUT_FACE(ICF); IDX = M2%RDYN(JJO)
                        DO JCF=1,CF2%NFACE
                              DA_OTHER = DA_OTHER  + CF2%AREA(JCF)
                              IDX = 1._EB/(CF2%XCENHIGH(X1AXIS,JCF)-CF2%XCENLOW(X1AXIS,JCF))
                              DVDT = -CF2%FN_OMESH(JCF) - IDX*(OM%H(IIO,JJO+1,KKO)-OM%H(IIO,JJO,KKO))
                              UN_NEW_OTHER = UN_NEW_OTHER + (CF2%VEL_OMESH(JCF) + DT*DVDT)*CF2%AREA(JCF)
                        ENDDO
                     ELSE
                        AREA_FC  = M2%DX(IIO)*M2%DZ(KKO); DA_OTHER = DA_OTHER + AREA_FC
                        DVDT = -OM%FVY(IIO,JJO,KKO) - M2%RDYN(JJO)*(OM%H(IIO,JJO+1,KKO)-OM%H(IIO,JJO,KKO))
                        UN_NEW_OTHER = UN_NEW_OTHER + (OM%V(IIO,JJO,KKO) + DT*DVDT)*AREA_FC
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         CASE(-2)
            DO KKO=KKO1,KKO2
               DO JJO=JJO1,JJO2
                  DO IIO=IIO1,IIO2
                     IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                     IF (M2%FCVAR(IIO,JJO-1,KKO,CC_FGSC,X1AXIS)==CC_SOLID) CYCLE

                     ICF = M2%FCVAR(IIO,JJO-1,KKO,CC_IDCF,X1AXIS)
                     IF (ICF>0) THEN
                        CF2 =>M2%CUT_FACE(ICF); IDX = M2%RDYN(JJO-1)
                        DO JCF=1,CF2%NFACE
                              DA_OTHER = DA_OTHER  + CF2%AREA(JCF)
                              IDX = 1._EB/(CF2%XCENHIGH(X1AXIS,JCF)-CF2%XCENLOW(X1AXIS,JCF))
                              DVDT = -CF2%FN_OMESH(JCF) - IDX*(OM%H(IIO,JJO,KKO)-OM%H(IIO,JJO-1,KKO))
                              UN_NEW_OTHER = UN_NEW_OTHER + (CF2%VEL_OMESH(JCF) + DT*DVDT)*CF2%AREA(JCF)
                        ENDDO
                     ELSE
                        AREA_FC  = M2%DX(IIO)*M2%DZ(KKO); DA_OTHER = DA_OTHER + AREA_FC
                        DVDT = -OM%FVY(IIO,JJO-1,KKO) - M2%RDYN(JJO-1)*(OM%H(IIO,JJO,KKO)-OM%H(IIO,JJO-1,KKO))
                        UN_NEW_OTHER = UN_NEW_OTHER + (OM%V(IIO,JJO-1,KKO) + DT*DVDT)*AREA_FC
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         CASE( 3)
            DO KKO=KKO1,KKO2
               DO JJO=JJO1,JJO2
                  DO IIO=IIO1,IIO2
                     IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                     IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,X1AXIS)==CC_SOLID) CYCLE

                     ICF = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,X1AXIS)
                     IF (ICF>0) THEN
                        CF2 =>M2%CUT_FACE(ICF); IDX = M2%RDZN(KKO)
                        DO JCF=1,CF2%NFACE
                              DA_OTHER = DA_OTHER  + CF2%AREA(JCF)
                              IDX = 1._EB/(CF2%XCENHIGH(X1AXIS,JCF)-CF2%XCENLOW(X1AXIS,JCF))
                              DWDT = -CF2%FN_OMESH(JCF) - IDX*(OM%H(IIO,JJO,KKO+1)-OM%H(IIO,JJO,KKO))
                              UN_NEW_OTHER = UN_NEW_OTHER + (CF2%VEL_OMESH(JCF) + DT*DWDT)*CF2%AREA(JCF)
                        ENDDO
                     ELSE
                        AREA_FC  = M2%DX(IIO)*M2%DY(JJO); DA_OTHER = DA_OTHER + AREA_FC
                        DWDT = -OM%FVZ(IIO,JJO,KKO) - M2%RDZN(KKO)*(OM%H(IIO,JJO,KKO+1)-OM%H(IIO,JJO,KKO))
                        UN_NEW_OTHER = UN_NEW_OTHER + (OM%W(IIO,JJO,KKO) + DT*DWDT)*AREA_FC
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         CASE(-3)
            DO KKO=KKO1,KKO2
               DO JJO=JJO1,JJO2
                  DO IIO=IIO1,IIO2
                     IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                     IF (M2%FCVAR(IIO,JJO,KKO-1,CC_FGSC,X1AXIS)==CC_SOLID) CYCLE

                     ICF = M2%FCVAR(IIO,JJO,KKO-1,CC_IDCF,X1AXIS)
                     IF (ICF>0) THEN
                        CF2 =>M2%CUT_FACE(ICF); IDX = M2%RDZN(KKO-1)
                        DO JCF=1,CF2%NFACE
                              DA_OTHER = DA_OTHER  + CF2%AREA(JCF)
                              IDX = 1._EB/(CF2%XCENHIGH(X1AXIS,JCF)-CF2%XCENLOW(X1AXIS,JCF))
                              DWDT = -CF2%FN_OMESH(JCF) - IDX*(OM%H(IIO,JJO,KKO)-OM%H(IIO,JJO,KKO-1))
                              UN_NEW_OTHER = UN_NEW_OTHER + (CF2%VEL_OMESH(JCF) + DT*DWDT)*CF2%AREA(JCF)
                        ENDDO
                     ELSE
                        AREA_FC  = M2%DX(IIO)*M2%DY(JJO); DA_OTHER = DA_OTHER + AREA_FC
                        DWDT = -OM%FVZ(IIO,JJO,KKO-1) - M2%RDZN(KKO-1)*(OM%H(IIO,JJO,KKO)-OM%H(IIO,JJO,KKO-1))
                        UN_NEW_OTHER = UN_NEW_OTHER + (OM%W(IIO,JJO,KKO-1) + DT*DWDT)*AREA_FC
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
      END SELECT IOR_SELECT_1
   ELSE PREDICTOR_IF
      IOR_SELECT_2: SELECT CASE(IOR)
         CASE( 1)
            DO KKO=KKO1,KKO2
               DO JJO=JJO1,JJO2
                  DO IIO=IIO1,IIO2
                     IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                     IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,X1AXIS)==CC_SOLID) CYCLE

                     ICF = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,X1AXIS)
                     IF (ICF>0) THEN
                        CF2 =>M2%CUT_FACE(ICF); IDX = M2%RDXN(IIO)
                        DO JCF=1,CF2%NFACE
                              DA_OTHER = DA_OTHER  + CF2%AREA(JCF)
                              IDX = 1._EB/(CF2%XCENHIGH(X1AXIS,JCF)-CF2%XCENLOW(X1AXIS,JCF))
                              DUDT = -CF2%FN_OMESH(JCF) - IDX*(OM%HS(IIO+1,JJO,KKO)-OM%HS(IIO,JJO,KKO))
                              UN_NEW_OTHER = UN_NEW_OTHER + &
                              0.5_EB*( CF2%VEL_OMESH(JCF)+CF2%VELS_OMESH(JCF) + DT*DUDT )*CF2%AREA(JCF)
                        ENDDO
                     ELSE
                        AREA_FC  = M2%DY(JJO)*M2%DZ(KKO); DA_OTHER = DA_OTHER + AREA_FC
                        DUDT = -OM%FVX(IIO,JJO,KKO) - M2%RDXN(IIO)*(OM%HS(IIO+1,JJO,KKO)-OM%HS(IIO,JJO,KKO))
                        UN_NEW_OTHER = UN_NEW_OTHER + &
                        0.5_EB*(OM%U(IIO,JJO,KKO)+OM%US(IIO,JJO,KKO) + DT*DUDT)*AREA_FC
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         CASE(-1)
            DO KKO=KKO1,KKO2
               DO JJO=JJO1,JJO2
                  DO IIO=IIO1,IIO2
                     IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                     IF (M2%FCVAR(IIO-1,JJO,KKO,CC_FGSC,X1AXIS)==CC_SOLID) CYCLE

                     ICF = M2%FCVAR(IIO-1,JJO,KKO,CC_IDCF,X1AXIS)
                     IF (ICF>0) THEN
                        CF2 =>M2%CUT_FACE(ICF); IDX = M2%RDXN(IIO-1)
                        DO JCF=1,CF2%NFACE
                              DA_OTHER = DA_OTHER  + CF2%AREA(JCF)
                              IDX = 1._EB/(CF2%XCENHIGH(X1AXIS,JCF)-CF2%XCENLOW(X1AXIS,JCF))
                              DUDT = -CF2%FN_OMESH(JCF) - IDX*(OM%HS(IIO,JJO,KKO)-OM%HS(IIO-1,JJO,KKO))
                              UN_NEW_OTHER = UN_NEW_OTHER + &
                              0.5_EB*( CF2%VEL_OMESH(JCF)+CF2%VELS_OMESH(JCF) + DT*DUDT )*CF2%AREA(JCF)
                        ENDDO
                     ELSE
                        AREA_FC  = M2%DY(JJO)*M2%DZ(KKO); DA_OTHER = DA_OTHER + AREA_FC
                        DUDT = -OM%FVX(IIO-1,JJO,KKO) - M2%RDXN(IIO-1)*(OM%HS(IIO,JJO,KKO)-OM%HS(IIO-1,JJO,KKO))
                        UN_NEW_OTHER = UN_NEW_OTHER + &
                        0.5_EB*(OM%U(IIO-1,JJO,KKO)+OM%US(IIO-1,JJO,KKO) + DT*DUDT)*AREA_FC
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         CASE( 2)
            DO KKO=KKO1,KKO2
               DO JJO=JJO1,JJO2
                  DO IIO=IIO1,IIO2
                     IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                     IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,X1AXIS)==CC_SOLID) CYCLE

                     ICF = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,X1AXIS)
                     IF (ICF>0) THEN
                        CF2 =>M2%CUT_FACE(ICF); IDX = M2%RDYN(JJO)
                        DO JCF=1,CF2%NFACE
                              DA_OTHER = DA_OTHER  + CF2%AREA(JCF)
                              IDX = 1._EB/(CF2%XCENHIGH(X1AXIS,JCF)-CF2%XCENLOW(X1AXIS,JCF))
                              DVDT = -CF2%FN_OMESH(JCF) - IDX*(OM%HS(IIO,JJO+1,KKO)-OM%HS(IIO,JJO,KKO))
                              UN_NEW_OTHER = UN_NEW_OTHER + &
                              0.5_EB*( CF2%VEL_OMESH(JCF)+CF2%VELS_OMESH(JCF) + DT*DVDT )*CF2%AREA(JCF)
                        ENDDO
                     ELSE
                        AREA_FC  = M2%DX(IIO)*M2%DZ(KKO); DA_OTHER = DA_OTHER + AREA_FC
                        DVDT = -OM%FVY(IIO,JJO,KKO) - M2%RDYN(JJO)*(OM%HS(IIO,JJO+1,KKO)-OM%HS(IIO,JJO,KKO))
                        UN_NEW_OTHER = UN_NEW_OTHER + &
                        0.5_EB*(OM%V(IIO,JJO,KKO)+OM%VS(IIO,JJO,KKO) + DT*DVDT)*AREA_FC
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         CASE(-2)
            DO KKO=KKO1,KKO2
               DO JJO=JJO1,JJO2
                  DO IIO=IIO1,IIO2
                     IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                     IF (M2%FCVAR(IIO,JJO-1,KKO,CC_FGSC,X1AXIS)==CC_SOLID) CYCLE

                     ICF = M2%FCVAR(IIO,JJO-1,KKO,CC_IDCF,X1AXIS)
                     IF (ICF>0) THEN
                        CF2 =>M2%CUT_FACE(ICF); IDX = M2%RDYN(JJO-1)
                        DO JCF=1,CF2%NFACE
                              DA_OTHER = DA_OTHER  + CF2%AREA(JCF)
                              IDX = 1._EB/(CF2%XCENHIGH(X1AXIS,JCF)-CF2%XCENLOW(X1AXIS,JCF))
                              DVDT = -CF2%FN_OMESH(JCF) - IDX*(OM%HS(IIO,JJO,KKO)-OM%HS(IIO,JJO-1,KKO))
                              UN_NEW_OTHER = UN_NEW_OTHER + &
                              0.5_EB*( CF2%VEL_OMESH(JCF)+CF2%VELS_OMESH(JCF) + DT*DVDT )*CF2%AREA(JCF)
                        ENDDO
                     ELSE
                        AREA_FC  = M2%DX(IIO)*M2%DZ(KKO); DA_OTHER = DA_OTHER + AREA_FC
                        DVDT = -OM%FVY(IIO,JJO-1,KKO) - M2%RDYN(JJO-1)*(OM%HS(IIO,JJO,KKO)-OM%HS(IIO,JJO-1,KKO))
                        UN_NEW_OTHER = UN_NEW_OTHER + &
                        0.5_EB*(OM%V(IIO,JJO-1,KKO)+OM%VS(IIO,JJO-1,KKO) + DT*DVDT)*AREA_FC
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         CASE( 3)
            DO KKO=KKO1,KKO2
               DO JJO=JJO1,JJO2
                  DO IIO=IIO1,IIO2
                     IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                     IF (M2%FCVAR(IIO,JJO,KKO,CC_FGSC,X1AXIS)==CC_SOLID) CYCLE

                     ICF = M2%FCVAR(IIO,JJO,KKO,CC_IDCF,X1AXIS)
                     IF (ICF>0) THEN
                        CF2 =>M2%CUT_FACE(ICF); IDX = M2%RDZN(KKO)
                        DO JCF=1,CF2%NFACE
                              DA_OTHER = DA_OTHER  + CF2%AREA(JCF)
                              IDX = 1._EB/(CF2%XCENHIGH(X1AXIS,JCF)-CF2%XCENLOW(X1AXIS,JCF))
                              DWDT = -CF2%FN_OMESH(JCF) - IDX*(OM%HS(IIO,JJO,KKO+1)-OM%HS(IIO,JJO,KKO))
                              UN_NEW_OTHER = UN_NEW_OTHER + &
                              0.5_EB*( CF2%VEL_OMESH(JCF)+CF2%VELS_OMESH(JCF) + DT*DWDT )*CF2%AREA(JCF)
                        ENDDO
                     ELSE
                        AREA_FC  = M2%DX(IIO)*M2%DY(JJO); DA_OTHER = DA_OTHER + AREA_FC
                        DWDT = -OM%FVZ(IIO,JJO,KKO) - M2%RDZN(KKO)*(OM%HS(IIO,JJO,KKO+1)-OM%HS(IIO,JJO,KKO))
                        UN_NEW_OTHER = UN_NEW_OTHER + &
                        0.5_EB*(OM%W(IIO,JJO,KKO)+OM%WS(IIO,JJO,KKO) + DT*DWDT)*AREA_FC
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         CASE(-3)
            DO KKO=KKO1,KKO2
               DO JJO=JJO1,JJO2
                  DO IIO=IIO1,IIO2
                     IF (M2%CELL(M2%CELL_INDEX(IIO,JJO,KKO))%SOLID) CYCLE
                     IF (M2%FCVAR(IIO,JJO,KKO-1,CC_FGSC,X1AXIS)==CC_SOLID) CYCLE

                     ICF = M2%FCVAR(IIO,JJO,KKO-1,CC_IDCF,X1AXIS)
                     IF (ICF>0) THEN
                        CF2 =>M2%CUT_FACE(ICF); IDX = M2%RDZN(KKO-1)
                        DO JCF=1,CF2%NFACE
                              DA_OTHER = DA_OTHER  + CF2%AREA(JCF)
                              IDX = 1._EB/(CF2%XCENHIGH(X1AXIS,JCF)-CF2%XCENLOW(X1AXIS,JCF))
                              DWDT = -CF2%FN_OMESH(JCF) - IDX*(OM%HS(IIO,JJO,KKO)-OM%HS(IIO,JJO,KKO-1))
                              UN_NEW_OTHER = UN_NEW_OTHER + &
                              0.5_EB*( CF2%VEL_OMESH(JCF)+CF2%VELS_OMESH(JCF) + DT*DWDT )*CF2%AREA(JCF)
                        ENDDO
                     ELSE
                        AREA_FC  = M2%DX(IIO)*M2%DY(JJO); DA_OTHER = DA_OTHER + AREA_FC
                        DWDT = -OM%FVZ(IIO,JJO,KKO-1) - M2%RDZN(KKO-1)*(OM%HS(IIO,JJO,KKO)-OM%HS(IIO,JJO,KKO-1))
                        UN_NEW_OTHER = UN_NEW_OTHER + &
                        0.5_EB*(OM%W(IIO,JJO,KKO-1)+OM%WS(IIO,JJO,KKO-1) + DT*DWDT)*AREA_FC
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
      END SELECT IOR_SELECT_2
   ENDIF PREDICTOR_IF

   UN_NEW_OTHER = UN_NEW_OTHER/DA_OTHER

   ! Compute velocity difference

   VELOCITY_ERROR = UN_NEW - UN_NEW_OTHER
   B1%VEL_ERR_NEW = VELOCITY_ERROR
   IDX = 0._EB
   DO JCF=1,CF%NFACE
      IDX = IDX + 1._EB/(CF%XCENHIGH(X1AXIS,JCF)-CF%XCENLOW(X1AXIS,JCF))*CF%AREA(JCF)
   ENDDO
   IDX = IDX / SUM(CF%AREA(1:CF%NFACE))
   WALL_WORK1(IW) = -SIGN(1._EB,REAL(IOR,EB))*ITERATIVE_FACTOR*VELOCITY_ERROR/(IDX*DT)

   ! If the grid cells in the current mesh are smaller than those of the other mesh, do not include in error tolerance

   IF (WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) THEN
      IF (OM%NIC_R>OM%NIC_S) CYCLE CHECK_WALL_LOOP
   ENDIF

   IF (ABS(VELOCITY_ERROR)>VELOCITY_ERROR_MAX(NM)) THEN
      VELOCITY_ERROR_MAX_LOC(1,NM) = I
      VELOCITY_ERROR_MAX_LOC(2,NM) = J
      VELOCITY_ERROR_MAX_LOC(3,NM) = K
      VELOCITY_ERROR_MAX(NM)       = ABS(VELOCITY_ERROR)
   ENDIF

ENDDO CHECK_WALL_LOOP

T_USED(14) = T_USED(14) + CURRENT_TIME() - TNOW
IF (TIME_CC_IBM) &
   T_CC_USED(CC_COMPUTE_VELOCITY_ERROR_TIME_INDEX) = T_CC_USED(CC_COMPUTE_VELOCITY_ERROR_TIME_INDEX) + CURRENT_TIME() - TNOW
RETURN
END SUBROUTINE CC_COMPUTE_VELOCITY_ERROR

! ------------------------------- GET_BOUND_VEL ---------------------------------

SUBROUTINE GET_BOUND_VEL(X1AXIS,INBFC_CFCEN,XYZ_PP,VELX1)

INTEGER, INTENT(IN) :: X1AXIS,INBFC_CFCEN(1:3)
REAL(EB),INTENT(IN) :: XYZ_PP(IAXIS:KAXIS)
REAL(EB),INTENT(OUT):: VELX1

! Local Variables
REAL(EB) :: DUMMY
INTEGER  :: IND1,IND2,ICF

VELX1 = 0._EB
! This routine computes boundary velocity of a boundary point on INBFC_CFCEN(1:3) INBOUNDARY cut-face
! with coordinates XYZ_PP. Will make use of velocity field defined on GEOMETRY.

! For now Set to CFACEs U_NORMAL or U_NORMAL_S depending on predictor or corrector:
DUMMY = XYZ_PP(X1AXIS) ! Dummy to avoid compilation warning on currently unused point location within cut-face.

! Inboundary cut-face indexes:
! INBFC_CFCEN(1) is either a point inside the Cartesian cell CC_FTYPE_CFINB, or a point in a Cartesian cell
! vertex CC_FTYPE_SVERT:
IND1=INBFC_CFCEN(2)
IND2=INBFC_CFCEN(3)
IF(IND1<=0 .OR. IND2<=0) RETURN ! If boundary cut-face undefined, with VELX1 set to 0._EB.
IF(CUT_FACE(IND1)%STATUS/=CC_INBOUNDARY) RETURN ! Return if face is not inboundary face.

ICF = CUT_FACE(IND1)%CFACE_INDEX(IND2)

IF (ICF <=0) RETURN ! This uses VELX1 = 0._EB when the inboundary cut-face used in the interpolation is located on
                    ! a ghost cell (no CFACEs are defined in ghost cells).

CFA => CFACE(ICF)
B1 => BOUNDARY_PROP1(CFA%B1_INDEX)
BC => BOUNDARY_COORD(CFA%BC_INDEX)
! Velocity into Gas Region, component along X1AXIS:
IF (PREDICTOR) THEN
   VELX1 = -B1%U_NORMAL * BC%NVEC(X1AXIS)
ELSE
   VELX1 = -B1%U_NORMAL_S* BC%NVEC(X1AXIS)
ENDIF

RETURN
END SUBROUTINE GET_BOUND_VEL


! -------------------------- CC_CHECK_DIVERGENCE -----------------------------

SUBROUTINE CC_CHECK_DIVERGENCE(T,DT,PREDVEL)

USE MPI_F08

! This routine is to be used at the end of predictor or corrector:
REAL(EB),INTENT(IN) :: T,DT
LOGICAL, INTENT(IN) :: PREDVEL

! Local Variables:
INTEGER :: NM, I, J, K, ICC, NCELL, JCC, IPZ

REAL(EB):: PRFCT, DIV, RES, DIVVOL, DIV_JCC, VOL, DPCC, DIV2,TLOC,DTLOC

REAL(EB), POINTER, DIMENSION(:,:,:)  :: UP=>NULL(), VP=>NULL(), WP=>NULL(), DP=>NULL()
REAL(EB), ALLOCATABLE, DIMENSION(:)  :: RESMAXV, RESVOLMX
REAL(EB), ALLOCATABLE, DIMENSION(:,:):: DIVMNX, DIVVOLMNX, VOLMNX
INTEGER,  ALLOCATABLE, DIMENSION(:,:):: IJKRM, RESICJCMX
INTEGER,  ALLOCATABLE, DIMENSION(:,:,:):: IJKMNX    , DIVVOLIJKMNX    , DIVVOLICJCMNX     ,DIVICJCMNX
REAL(EB), ALLOCATABLE, DIMENSION(:,:,:):: XYZMNX
INTEGER :: NMV(1), IERR
REAL(EB), ALLOCATABLE, DIMENSION(:)  :: RESMAXV_AUX, RESVOLMX_AUX
REAL(EB), ALLOCATABLE, DIMENSION(:,:):: DIVMNX_AUX, DIVVOLMNX_AUX, VOLMNX_AUX
INTEGER,  ALLOCATABLE, DIMENSION(:,:):: IJKRM_AUX, RESICJCMX_AUX
INTEGER,  ALLOCATABLE, DIMENSION(:,:,:):: IJKMNX_AUX, DIVVOLIJKMNX_AUX, DIVVOLICJCMNX_AUX ,DIVICJCMNX_AUX
REAL(EB), ALLOCATABLE, DIMENSION(:,:,:):: XYZMNX_AUX
REAL(EB), POINTER, DIMENSION(:) :: D_PBAR_DT_P

! Allocate div Containers
ALLOCATE( RESMAXV(NMESHES), DIVMNX(LOW_IND:HIGH_IND,NMESHES), DIVVOLMNX(LOW_IND:HIGH_IND,NMESHES) )
ALLOCATE( IJKRM(MAX_DIM,NMESHES), IJKMNX(MAX_DIM,LOW_IND:HIGH_IND,NMESHES), XYZMNX(MAX_DIM,LOW_IND:HIGH_IND,NMESHES), &
          DIVVOLIJKMNX(MAX_DIM,LOW_IND:HIGH_IND,NMESHES),  DIVVOLICJCMNX(2,LOW_IND:HIGH_IND,1:NMESHES), &
          DIVICJCMNX(2,LOW_IND:HIGH_IND,1:NMESHES) ,  VOLMNX(LOW_IND:HIGH_IND,1:NMESHES) )
ALLOCATE( RESICJCMX(1:2,1:NMESHES), RESVOLMX(1:NMESHES) )

IF(STORE_CUTCELL_DIVERGENCE) CCVELDIV = 1.E6_EB

! Initialize div containers
RESMAXV(1:NMESHES) = 0._EB
DIVMNX(LOW_IND:HIGH_IND,1:NMESHES)    = 0._EB
DIVVOLMNX(LOW_IND:HIGH_IND,1:NMESHES) = 0._EB
IJKRM(IAXIS:KAXIS,1:NMESHES)                         = 0
IJKMNX(IAXIS:KAXIS,LOW_IND:HIGH_IND,1:NMESHES)       = 0
DIVVOLIJKMNX(IAXIS:KAXIS,LOW_IND:HIGH_IND,1:NMESHES) = 0
DIVVOLICJCMNX(1:2,LOW_IND:HIGH_IND,1:NMESHES)        = 0
DIVICJCMNX(1:2,LOW_IND:HIGH_IND,1:NMESHES)           = 0
RESICJCMX(1:2,1:NMESHES)                             = 0
VOLMNX(LOW_IND:HIGH_IND,1:NMESHES)                   = 0._EB
RESVOLMX(1:NMESHES)                                  = 0._EB
XYZMNX(IAXIS:KAXIS,LOW_IND:HIGH_IND,1:NMESHES)       = 0._EB
TLOC = T
DTLOC= DT
! Meshes Loop:
MESHES_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   DIVMNX(HIGH_IND,NM)     = -10000._EB
   DIVMNX(LOW_IND ,NM)     =  10000._EB
   DIVVOLMNX(HIGH_IND,NM)  = -10000._EB
   DIVVOLMNX(LOW_IND ,NM)  =  10000._EB

   CALL POINT_TO_MESH(NM)

   IF (PREDVEL) THEN ! Take divergence from predicted velocities
      UP => US
      VP => VS
      WP => WS
      DP => DS ! Thermodynamic divergence
      D_PBAR_DT_P => D_PBAR_DT_S
      PRFCT= 1._EB
   ELSE ! Take divergence from final velocities
      UP => U
      VP => V
      WP => W
      DP => D !DDT
      D_PBAR_DT_P => D_PBAR_DT
      PRFCT= 0._EB
   ENDIF

   ! First Regular GASPHASE cells:
   DO K=1,KBAR
      DO J=1,JBAR
         LOOP1: DO I=1,IBAR
            IF ( CCVAR(I,J,K,CC_CGSC) /= CC_GASPHASE ) CYCLE
            IF ( CELL(CELL_INDEX(I,J,K))%SOLID ) CYCLE
            ! 3D Cartesian divergence:
            DIV = (UP(I,J,K)-UP(I-1,J,K))*RDX(I) + &
                  (VP(I,J,K)-VP(I,J-1,K))*RDY(J) + &
                  (WP(I,J,K)-WP(I,J,K-1))*RDZ(K)
            RES = ABS(DIV-DP(I,J,K))
            IF (RES >= RESMAXV(NM)) THEN
               RESMAXV(NM) = RES
               IJKRM(IAXIS:KAXIS,NM)= (/ I,J,K /)
               RESVOLMX(NM) = DX(I)*DY(J)*DZ(K)
            ENDIF
            IF (DIV >= DIVMNX(HIGH_IND,NM)) THEN
               DIVMNX(HIGH_IND,NM) = DIV
               IJKMNX(IAXIS:KAXIS,HIGH_IND,NM) = (/ I,J,K /)
               XYZMNX(IAXIS:KAXIS,HIGH_IND,NM) = (/ XC(I),YC(J),ZC(K) /)
               VOLMNX(HIGH_IND,NM) = DX(I)*DY(J)*DZ(K)
            ENDIF
            IF (DIV < DIVMNX(LOW_IND ,NM)) THEN
               DIVMNX(LOW_IND ,NM) = DIV
               IJKMNX(IAXIS:KAXIS,LOW_IND ,NM) = (/ I,J,K /)
               XYZMNX(IAXIS:KAXIS,LOW_IND ,NM) = (/ XC(I),YC(J),ZC(K) /)
               VOLMNX(LOW_IND,NM) = DX(I)*DY(J)*DZ(K)
            ENDIF
            DIVVOL = DIV*DX(I)*DY(J)*DZ(K)
            IF (DIVVOL >= DIVVOLMNX(HIGH_IND,NM)) THEN
               DIVVOLMNX(HIGH_IND,NM) = DIVVOL
               DIVVOLIJKMNX(IAXIS:KAXIS,HIGH_IND,NM) = (/ I,J,K /)
            ENDIF
            IF (DIVVOL < DIVVOLMNX(LOW_IND ,NM)) THEN
               DIVVOLMNX(LOW_IND ,NM) = DIVVOL
               DIVVOLIJKMNX(IAXIS:KAXIS,LOW_IND ,NM) = (/ I,J,K /)
            ENDIF
         ENDDO LOOP1
      ENDDO
   ENDDO

   ! Then cut-cells:
   ICC_LOOP : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      NCELL  = CUT_CELL(ICC)%NCELL
      I      = CUT_CELL(ICC)%IJK(IAXIS)
      J      = CUT_CELL(ICC)%IJK(JAXIS)
      K      = CUT_CELL(ICC)%IJK(KAXIS)
      IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
      IPZ = PRESSURE_ZONE(I,J,K)
      DIVVOL = 0._EB
      DPCC   = 0._EB
      VOL    = 0._EB
      JCC_LOOP : DO JCC=1,NCELL
         VOL  = VOL + CUT_CELL(ICC)%VOLUME(JCC)
         CALL GET_VELOC_DIVERGENCE_CUTCELL(ICC,JCC,PRFCT,DIV_JCC)
         DIVVOL = DIVVOL + DIV_JCC*CUT_CELL(ICC)%VOLUME(JCC)
         ! Thermodynamic divergence * vol:
         DPCC= DPCC + ((1._EB-PRFCT)*CUT_CELL(ICC)%D(JCC)+PRFCT*CUT_CELL(ICC)%DS(JCC))*CUT_CELL(ICC)%VOLUME(JCC)
      ENDDO JCC_LOOP

      DIV = DIVVOL / (DX(I)*DY(J)*DZ(K))
      RES = ABS(DIVVOL-DPCC)/(DX(I)*DY(J)*DZ(K))
      DIV2 = (UP(I,J,K)-UP(I-1,J,K))*RDX(I) + &
             (VP(I,J,K)-VP(I,J-1,K))*RDY(J) + &
             (WP(I,J,K)-WP(I,J,K-1))*RDZ(K)

      IF(STORE_CUTCELL_DIVERGENCE) CCVELDIV(I,J,K) = DIVVOL/VOL

      IF (RES >= RESMAXV(NM)) THEN
         RESMAXV(NM) = RES
         IJKRM(IAXIS:KAXIS,NM)= (/ I,J,K /)
         RESICJCMX(1:2,NM) = (/ ICC, NCELL /)
         RESVOLMX(NM) = VOL !CUT_CELL(ICC)%VOLUME(JCC)
      ENDIF
      IF (DIV >= DIVMNX(HIGH_IND,NM)) THEN
         DIVMNX(HIGH_IND,NM) = DIV
         IJKMNX(IAXIS:KAXIS,HIGH_IND,NM) = (/ I,J,K /)
         XYZMNX(IAXIS:KAXIS,HIGH_IND,NM) = (/ XC(I),YC(J),ZC(K) /)
         DIVICJCMNX(1:2,HIGH_IND,NM) = (/ ICC, NCELL /)
         VOLMNX(HIGH_IND,NM) = VOL !CUT_CELL(ICC)%VOLUME(JCC)
      ENDIF
      IF (DIV < DIVMNX(LOW_IND ,NM)) THEN
         DIVMNX(LOW_IND ,NM) = DIV
         IJKMNX(IAXIS:KAXIS,LOW_IND ,NM) = (/ I,J,K /)
         XYZMNX(IAXIS:KAXIS,LOW_IND ,NM) = (/ XC(I),YC(J),ZC(K) /)
         DIVICJCMNX(1:2,LOW_IND,NM) = (/ ICC, NCELL /)
         VOLMNX(LOW_IND,NM) = VOL !CUT_CELL(ICC)%VOLUME(JCC)
      ENDIF
      IF (DIVVOL >= DIVVOLMNX(HIGH_IND,NM)) THEN
         DIVVOLMNX(HIGH_IND,NM) = DIVVOL
         DIVVOLIJKMNX(IAXIS:KAXIS,HIGH_IND,NM) = (/ I,J,K /)
         DIVVOLICJCMNX(1:2,HIGH_IND,NM) = (/ ICC, NCELL/)
      ENDIF
      IF (DIVVOL < DIVVOLMNX(LOW_IND ,NM)) THEN
         DIVVOLMNX(LOW_IND ,NM) = DIVVOL
         DIVVOLIJKMNX(IAXIS:KAXIS,LOW_IND ,NM) = (/ I,J,K /)
         DIVVOLICJCMNX(1:2,LOW_IND,NM) = (/ ICC, NCELL /)
      ENDIF
   ENDDO ICC_LOOP

   IF(STORE_CARTESIAN_DIVERGENCE) THEN
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (CELL(CELL_INDEX(I,J,K))%SOLID .OR. CCVAR(I,J,K,CC_CGSC)==CC_SOLID) CARTVELDIV(I,J,K) = 0._EB
            ENDDO
         ENDDO
      ENDDO
   ENDIF

   ! Assign max residual and divergence to corresponding location in MESHES(NM):
   RESMAX = RESMAXV(NM)
   IRM = IJKRM(IAXIS,NM)
   JRM = IJKRM(JAXIS,NM)
   KRM = IJKRM(KAXIS,NM)

   DIVMN = DIVMNX(LOW_IND ,NM)
   IMN = IJKMNX(IAXIS,LOW_IND ,NM)
   JMN = IJKMNX(JAXIS,LOW_IND ,NM)
   KMN = IJKMNX(KAXIS,LOW_IND ,NM)

   DIVMX = DIVMNX(HIGH_IND ,NM)
   IMX = IJKMNX(IAXIS,HIGH_IND ,NM)
   JMX = IJKMNX(JAXIS,HIGH_IND ,NM)
   KMX = IJKMNX(KAXIS,HIGH_IND ,NM)

ENDDO MESHES_LOOP

! Here All_Reduce SUM all mesh values to write if GET_CUTCELLS_VERBOSE:
DEBUG_CC_SCALAR_TRANSPORT_IF : IF (DEBUG_CC_SCALAR_TRANSPORT) THEN
   IF (GET_CUTCELLS_VERBOSE) THEN
      IF (N_MPI_PROCESSES>1) THEN
         ! Allocate aux div Containers
         ALLOCATE( RESMAXV_AUX(NMESHES), DIVMNX_AUX(LOW_IND:HIGH_IND,NMESHES), DIVVOLMNX_AUX(LOW_IND:HIGH_IND,NMESHES) )
         ALLOCATE( IJKRM_AUX(MAX_DIM,NMESHES), IJKMNX_AUX(MAX_DIM,LOW_IND:HIGH_IND,NMESHES), &
                   XYZMNX_AUX(MAX_DIM,LOW_IND:HIGH_IND,NMESHES),&
                   DIVVOLIJKMNX_AUX(MAX_DIM,LOW_IND:HIGH_IND,NMESHES),  DIVVOLICJCMNX_AUX(2,LOW_IND:HIGH_IND,1:NMESHES), &
                   DIVICJCMNX_AUX(2,LOW_IND:HIGH_IND,1:NMESHES) ,  VOLMNX_AUX(LOW_IND:HIGH_IND,1:NMESHES) )
         ALLOCATE( RESICJCMX_AUX(1:2,1:NMESHES), RESVOLMX_AUX(1:NMESHES) )
         RESMAXV_AUX(:)           = RESMAXV(:)
         DIVMNX_AUX(:,:)          = DIVMNX(:,:)
         DIVVOLMNX_AUX(:,:)       = DIVVOLMNX(:,:)
         IJKRM_AUX(:,:)           = IJKRM(:,:)
         IJKMNX_AUX(:,:,:)        = IJKMNX(:,:,:)
         XYZMNX_AUX(:,:,:)        = XYZMNX(:,:,:)
         DIVVOLIJKMNX_AUX(:,:,:)  = DIVVOLIJKMNX(:,:,:)
         DIVVOLICJCMNX_AUX(:,:,:) = DIVVOLICJCMNX(:,:,:)
         DIVICJCMNX_AUX(:,:,:)    = DIVICJCMNX(:,:,:)
         VOLMNX_AUX(:,:)          = VOLMNX(:,:)
         RESICJCMX_AUX(:,:)       = RESICJCMX(:,:)
         RESVOLMX_AUX(:)          = RESVOLMX(:)
         ! Reals:
         CALL MPI_ALLREDUCE(RESMAXV_AUX(1) , RESMAXV(1) ,   NMESHES, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD, IERR)
         CALL MPI_ALLREDUCE(DIVMNX_AUX(1,1), DIVMNX(1,1), 2*NMESHES, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD, IERR)
         CALL MPI_ALLREDUCE(DIVVOLMNX_AUX(1,1), DIVVOLMNX(1,1), 2*NMESHES, MPI_DOUBLE_PRECISION, MPI_SUM, &
                            MPI_COMM_WORLD, IERR)
         CALL MPI_ALLREDUCE(VOLMNX_AUX(1,1), VOLMNX(1,1), 2*NMESHES, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD, IERR)
         CALL MPI_ALLREDUCE(RESVOLMX_AUX(1), RESVOLMX(1),   NMESHES, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD, IERR)
         CALL MPI_ALLREDUCE(XYZMNX_AUX(1,1,1), XYZMNX(1,1,1), MAX_DIM*2*NMESHES, MPI_DOUBLE_PRECISION, MPI_SUM, &
                            MPI_COMM_WORLD, IERR)
         ! Integers:
         CALL MPI_ALLREDUCE(IJKRM_AUX(1,1), IJKRM(1,1), MAX_DIM*NMESHES, MPI_INTEGER, MPI_SUM, MPI_COMM_WORLD, IERR)
         CALL MPI_ALLREDUCE(IJKMNX_AUX(1,1,1), IJKMNX(1,1,1), MAX_DIM*2*NMESHES, MPI_INTEGER, MPI_SUM, MPI_COMM_WORLD, IERR)
         CALL MPI_ALLREDUCE(DIVVOLIJKMNX_AUX(1,1,1), DIVVOLIJKMNX(1,1,1), MAX_DIM*2*NMESHES, MPI_INTEGER, MPI_SUM, &
                            MPI_COMM_WORLD, IERR)
         CALL MPI_ALLREDUCE(DIVVOLICJCMNX_AUX(1,1,1), DIVVOLICJCMNX(1,1,1), 2*2*NMESHES, MPI_INTEGER, MPI_SUM, &
                            MPI_COMM_WORLD, IERR)
         CALL MPI_ALLREDUCE(DIVICJCMNX_AUX(1,1,1), DIVICJCMNX(1,1,1), 2*2*NMESHES, MPI_INTEGER, MPI_SUM, MPI_COMM_WORLD, IERR)
         CALL MPI_ALLREDUCE(RESICJCMX_AUX(1,1), RESICJCMX(1,1), 2*NMESHES, MPI_INTEGER, MPI_SUM, MPI_COMM_WORLD, IERR)

         DEALLOCATE(RESMAXV_AUX, DIVMNX_AUX, DIVVOLMNX_AUX, IJKRM_AUX, IJKMNX_AUX, DIVVOLIJKMNX_AUX, DIVVOLICJCMNX_AUX, &
                    DIVICJCMNX_AUX, VOLMNX_AUX, RESICJCMX_AUX, RESVOLMX_AUX, XYZMNX_AUX)
      ENDIF
      IF (MY_RANK==0) THEN
         WRITE(LU_ERR,*) ' '
         WRITE(LU_ERR,*) "N Step    =",ICYC," T, DT=",TLOC,DTLOC
         NMV(1)=MINLOC(DIVMNX(LOW_IND ,1:NMESHES),DIM=1)
         WRITE(LU_ERR,*) "Div Min   =",NMV(1),DIVMNX(LOW_IND ,NMV(1)),IJKMNX(IAXIS:KAXIS,LOW_IND ,NMV(1)),&
         XYZMNX(IAXIS:KAXIS,LOW_IND ,NMV(1)),&
         DIVICJCMNX(1:2,LOW_IND,NMV(1)),VOLMNX(LOW_IND,NMV(1))
         NMV(1)=MAXLOC(DIVMNX(HIGH_IND ,1:NMESHES),DIM=1)
         WRITE(LU_ERR,*) "Div Max   =",NMV(1),DIVMNX(HIGH_IND,NMV(1)),IJKMNX(IAXIS:KAXIS,HIGH_IND,NMV(1)),&
         XYZMNX(IAXIS:KAXIS,HIGH_IND,NMV(1)),&
         DIVICJCMNX(1:2,HIGH_IND,NMV(1)),VOLMNX(HIGH_IND,NMV(1))

         NMV(1)=MAXLOC(RESMAXV(1:NMESHES),DIM=1)
         WRITE(LU_ERR,*) "Res Max   =",NMV(1),RESMAXV(NMV(1)),IJKRM(IAXIS:KAXIS,NMV(1)),RESICJCMX(1:2,NMV(1)),RESVOLMX(NMV(1))

         NMV(1)=MINLOC(DIVVOLMNX(LOW_IND ,1:NMESHES),DIM=1)
         WRITE(LU_ERR,*) "DivVol Min=",NMV(1),DIVVOLMNX(LOW_IND ,NMV(1)),DIVVOLIJKMNX(IAXIS:KAXIS,LOW_IND ,NMV(1)),&
         DIVVOLICJCMNX(1:2,LOW_IND,NMV(1))
         NMV(1)=MAXLOC(DIVVOLMNX(HIGH_IND ,1:NMESHES),DIM=1)
         WRITE(LU_ERR,*) "DivVol Max=",NMV(1),DIVVOLMNX(HIGH_IND,NMV(1)),DIVVOLIJKMNX(IAXIS:KAXIS,HIGH_IND,NMV(1)),&
         DIVVOLICJCMNX(1:2,HIGH_IND,NMV(1))
      ENDIF
   ENDIF
ENDIF DEBUG_CC_SCALAR_TRANSPORT_IF

! DeAllocate div Containers
DEALLOCATE( RESMAXV, DIVMNX, DIVVOLMNX )
DEALLOCATE( IJKRM, IJKMNX, DIVVOLIJKMNX, DIVVOLICJCMNX, RESVOLMX, RESICJCMX )
DEALLOCATE( XYZMNX )
RETURN
END SUBROUTINE  CC_CHECK_DIVERGENCE

! ----------------------- GET_VELOC_DIVERGENCE_CUTCELL --------------------------

SUBROUTINE GET_VELOC_DIVERGENCE_CUTCELL(ICC,JCC,PRFCT,DIV_JCC)

! NOTE : This routine assumes POINT_TO_MESH(NM) has been called.
! ICC,JCC = Indexes of particular cut-cell in CUT_CELL(ICC)%CCELEM(:,JCC)
! PRFCT   = PREDICTOR/CORRECTOR REAL(EB) factor, if US,VS,WS => PRFCT= 1._EB, elseid U,V,W PRFCT= 0._EB
! DIV_JCC = Velocity divergence in cut-cell ICC,JCC

INTEGER, INTENT(IN) :: ICC, JCC
REAL(EB),INTENT(IN) :: PRFCT
REAL(EB),INTENT(OUT):: DIV_JCC

! Local Variables:
INTEGER :: IFACE, IFC, LOWHIGH, X1AXIS, ILH, IFC2, IFACE2, ICFA, I, J, K
REAL(EB):: AF, VELN, FCT

I      = CUT_CELL(ICC)%IJK(IAXIS)
J      = CUT_CELL(ICC)%IJK(JAXIS)
K      = CUT_CELL(ICC)%IJK(KAXIS)

DIV_JCC = 0._EB
IFC_LOOP : DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
   IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
   AF     = 0._EB
   VELN   = 0._EB
   SELECT CASE(CUT_CELL(ICC)%FACE_LIST(1,IFACE))
   CASE(CC_FTYPE_RCGAS) ! REGULAR GASPHASE
      LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
      X1AXIS  = CUT_CELL(ICC)%FACE_LIST(3,IFACE)
      ILH     =        LOWHIGH - 1
      FCT     = REAL(2*LOWHIGH - 3, EB)
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         AF   = DY(J)*DZ(K)
         VELN = FCT*(PRFCT*US(I-1+ILH,J,K) + (1._EB-PRFCT)*U(I-1+ILH,J,K))
      CASE(JAXIS)
         AF   = DX(I)*DZ(K)
         VELN = FCT*(PRFCT*VS(I,J-1+ILH,K) + (1._EB-PRFCT)*V(I,J-1+ILH,K))
      CASE(KAXIS)
         AF   = DX(I)*DY(J)
         VELN = FCT*(PRFCT*WS(I,J,K-1+ILH) + (1._EB-PRFCT)*W(I,J,K-1+ILH))
      END SELECT
   CASE(CC_FTYPE_CFGAS) ! GASPHASE CUT FACE:
      LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
      FCT     = REAL(2*LOWHIGH - 3, EB)
      IFC2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
      IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
      AF      = CUT_FACE(IFC2)%AREA(IFACE2)
      VELN    = FCT*((1._EB-PRFCT)*CUT_FACE(IFC2)%VEL( IFACE2) + &
                            PRFCT *CUT_FACE(IFC2)%VELS(IFACE2))
   CASE(CC_FTYPE_CFINB) ! INBOUNDARY CUT FACE: Note here we add U_NORMAL with Transpiration velocity due to
                         ! Poisson solver velocity error.
      FCT     = 1._EB ! Normal velocity defined into the body.
      IFC2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
      IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
      ICFA    = CUT_FACE(IFC2)%CFACE_INDEX(IFACE2)
      AF      = CUT_FACE(IFC2)%AREA(IFACE2)
      VELN    = FCT*((1._EB-PRFCT)*CUT_FACE(IFC2)%VEL( IFACE2) + PRFCT *CUT_FACE(IFC2)%VELS(IFACE2))
   END SELECT
   DIV_JCC = DIV_JCC + AF*VELN
ENDDO IFC_LOOP

DIV_JCC = DIV_JCC / CUT_CELL(ICC)%VOLUME(JCC)

END SUBROUTINE GET_VELOC_DIVERGENCE_CUTCELL


! ----------------------- GET_FN_DIVERGENCE_CUTCELL --------------------------

SUBROUTINE GET_FN_DIVERGENCE_CUTCELL(ICC,JCC,DIV_FN,SUBSTRACT_BAROCLINIC)

! NOTE : This routine assumes POINT_TO_MESH(NM) has been called.
! ICC,JCC = Indexes of particular cut-cell in CUT_CELL(ICC)%CCELEM(:,JCC)
! DIV_FN  = FN divergence in cut-cell ICC,JCC

INTEGER, INTENT(IN) :: ICC, JCC
REAL(EB),INTENT(OUT):: DIV_FN
LOGICAL, INTENT(IN) :: SUBSTRACT_BAROCLINIC

! Local Variables:
INTEGER :: IFACE, IFC, LOWHIGH, X1AXIS, ILH, IFC2, IFACE2, ICFA, I, J, K
REAL(EB):: AF, FN, FCT, SUB_FCT

SUB_FCT = 0._EB; IF (SUBSTRACT_BAROCLINIC) SUB_FCT = 1._EB

I      = CUT_CELL(ICC)%IJK(IAXIS)
J      = CUT_CELL(ICC)%IJK(JAXIS)
K      = CUT_CELL(ICC)%IJK(KAXIS)

DIV_FN = 0._EB
IFC_LOOP : DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
   IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
   AF     = 0._EB
   FN   = 0._EB
   SELECT CASE(CUT_CELL(ICC)%FACE_LIST(1,IFACE))
   CASE(CC_FTYPE_RCGAS) ! REGULAR GASPHASE
      LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
      X1AXIS  = CUT_CELL(ICC)%FACE_LIST(3,IFACE)
      ILH     =        LOWHIGH - 1
      FCT     = REAL(2*LOWHIGH - 3, EB)
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         AF   = DY(J)*DZ(K)
         FN   = FCT*(FVX(I-1+ILH,J,K) - SUB_FCT*FVX_B(I-1+ILH,J,K))
      CASE(JAXIS)
         AF   = DX(I)*DZ(K)
         FN   = FCT*(FVY(I,J-1+ILH,K) - SUB_FCT*FVY_B(I,J-1+ILH,K))
      CASE(KAXIS)
         AF   = DX(I)*DY(J)
         FN   = FCT*(FVZ(I,J,K-1+ILH) - SUB_FCT*FVZ_B(I,J,K-1+ILH))
      END SELECT
   CASE(CC_FTYPE_CFGAS) ! GASPHASE CUT FACE:
      LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
      FCT     = REAL(2*LOWHIGH - 3, EB)
      IFC2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
      IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
      AF      = CUT_FACE(IFC2)%AREA(IFACE2)
      FN      = FCT*(CUT_FACE(IFC2)%FN( IFACE2) - SUB_FCT*CUT_FACE(IFC2)%FN_B( IFACE2))
   CASE(CC_FTYPE_CFINB) ! INBOUNDARY CUT FACE
      FCT     = 1._EB    ! Normal vector defined into the body.
      IFC2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
      IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
      ICFA    = CUT_FACE(IFC2)%CFACE_INDEX(IFACE2)
      AF      = CUT_FACE(IFC2)%AREA(IFACE2)
      FN      = FCT*(CUT_FACE(IFC2)%FN( IFACE2) - SUB_FCT*CUT_FACE(IFC2)%FN_B( IFACE2))
   END SELECT
   DIV_FN = DIV_FN + AF*FN
ENDDO IFC_LOOP

DIV_FN = DIV_FN / CUT_CELL(ICC)%VOLUME(JCC)

END SUBROUTINE GET_FN_DIVERGENCE_CUTCELL


! --------------------------- GET_CRTCFCC_INT_STENCILS -----------------------------

SUBROUTINE GET_CRTCFCC_INT_STENCILS

USE GEOMETRY_FUNCTIONS, ONLY : SEARCH_OTHER_MESHES

! Local variables:
INTEGER :: NM
INTEGER :: X1AXIS
INTEGER, ALLOCATABLE, DIMENSION(:,:,:,:)   :: IJKCELL
INTEGER :: I,J,K,NCELL,ICC,JCC,IJK(MAX_DIM),ICF,IFACE
INTEGER :: ISTR, IEND, JSTR, JEND, KSTR, KEND
LOGICAL :: FOUND_POINT, INSEG, FOUNDPT
REAL(EB):: XYZ(MAX_DIM),XYZ_PP(MAX_DIM),XYZ_IP(MAX_DIM),DV(MAX_DIM),NVEC(MAX_DIM)
REAL(EB):: P0(MAX_DIM),P1(MAX_DIM),DIST,DISTANCE,DIR_FCT,NORM_DV,LASTDOTNVEC,DOTNVEC
INTEGER :: FOUND_INBFC(1:3), BODTRI(1:2)
INTEGER :: CCFC,NFC_CC,ICFC,INBFC,INBFC_LOC,IFCPT,IFCPT_LOC,IBOD,IWSEL,ICELL
INTEGER :: TESTVAR

INTEGER :: IW,II,JJ,KK,IGC
REAL(EB) :: MIN_DIST_VEL

! OMESH related arrays:
INTEGER, ALLOCATABLE, DIMENSION(:,:,:,:,:) :: IJKFACE2
INTEGER :: IIO,JJO,KKO,NOM
LOGICAL :: FLGX,FLGY,FLGZ,INNM

INTEGER, ALLOCATABLE, DIMENSION(:) :: IIO_FC_R_AUX,JJO_FC_R_AUX,KKO_FC_R_AUX,AXS_FC_R_AUX
INTEGER, ALLOCATABLE, DIMENSION(:) :: IIO_CC_R_AUX,JJO_CC_R_AUX,KKO_CC_R_AUX
INTEGER :: SIZE_REC

INTEGER, PARAMETER :: DELTA_FC = 200

INTEGER :: VIND,EP,INPE,INT_NPE_LO,INT_NPE_HI,NPE_LIST_START,NPE_LIST_COUNT,SZ_1,SZ_2,NPE_COUNT,IEDGE
INTEGER,  ALLOCATABLE, DIMENSION(:,:,:,:) :: INT_NPE
INTEGER,  ALLOCATABLE, DIMENSION(:,:)     :: INT_IJK, INT_NOMIND
REAL(EB), ALLOCATABLE, DIMENSION(:)       :: INT_COEF
REAL(EB), ALLOCATABLE, DIMENSION(:,:)     :: INT_NOUT, INT_DCOEF
REAL(EB) :: DELN,INT_XN(0:INT_N_EXT_PTS),INT_CN(0:INT_N_EXT_PTS)
INTEGER, ALLOCATABLE, DIMENSION(:,:) :: INT_IJK_AUX
REAL(EB),ALLOCATABLE, DIMENSION(:)   :: INT_COEF_AUX
INTEGER :: N_CVAR_START, N_CVAR_COUNT, N_FVAR_START, N_FVAR_COUNT
LOGICAL, ALLOCATABLE, DIMENSION(:) :: EP_TAG

INTEGER :: IS,I_SGN,ICD,ICD_SGN,IIF,JJF,KKF,FAXIS,IEC,IE,SKIP_FCT,IEP,JEP,KEP,INDS(1:2,IAXIS:KAXIS),AX,ICEDG,JCEDG,LOHI
REAL(EB):: DXX(2),AREA_CF,XB_IB,DEL_EP,DEL_IBEDGE,XYZ1(IAXIS:KAXIS),XYZ2(IAXIS:KAXIS)

TYPE(CC_CUTEDGE_TYPE), POINTER :: CE=>NULL()

REAL(EB) CPUTIME,CPUTIME_START,CPUTIME_START_LOOP
CHARACTER(100) :: MSEGS_FILE
INTEGER :: ECOUNT

! Case of periodic test 103, return. No IBM interpolation needed as there are no immersed Bodies:
IF(PERIODIC_TEST==103 .OR. PERIODIC_TEST==11 .OR. PERIODIC_TEST==7) RETURN

! Total number of cell centered variables to be exchanges into external normal probe points of CFACES.
N_INT_CVARS = INT_P_IND + N_TRACKED_SPECIES

! Total number of cell centered variables to be exchanged in cut-cell interpolation:
N_INT_CCVARS= INT_WCEN_IND

IF(GET_CUTCELLS_VERBOSE) THEN
   WRITE(LU_SETCC,*) ' '; WRITE(LU_SETCC,'(A)') ' 5. In GET_CRTCFCC_INT_STENCILS, tasks to define IBM stencils:'
   CALL CPU_TIME(CPUTIME_START)
   CPUTIME_START_LOOP = CPUTIME_START
   WRITE(LU_SETCC,'(A)',advance='no') &
   ' - Into Mesh Loop: definition of Interpolation stencils for cut-cells and faces..'
ENDIF

! Then, second mesh loop:
IF( ASSOCIATED(X1FACEP)) NULLIFY(X1FACEP)
IF( ASSOCIATED(X2FACEP)) NULLIFY(X2FACEP)
IF( ASSOCIATED(X3FACEP)) NULLIFY(X3FACEP)
IF( ASSOCIATED(X2CELLP)) NULLIFY(X2CELLP)
IF( ASSOCIATED(X3CELLP)) NULLIFY(X3CELLP)
MESHES_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! Mesh sizes:
   NXB=IBAR
   NYB=JBAR
   NZB=KBAR

   ! X direction bounds:
   ILO_FACE = 0                    ! Low mesh boundary face index.
   IHI_FACE = IBAR                 ! High mesh boundary face index.
   ILO_CELL = ILO_FACE + 1     ! First internal cell index. See notes.
   IHI_CELL = IHI_FACE ! Last internal cell index.
   ISTR     = ILO_FACE - NGUARD    ! Allocation start x arrays.
   IEND     = IHI_FACE + NGUARD    ! Allocation end x arrays.

   ! Y direction bounds:
   JLO_FACE = 0                    ! Low mesh boundary face index.
   JHI_FACE = JBAR                 ! High mesh boundary face index.
   JLO_CELL = JLO_FACE + 1     ! First internal cell index. See notes.
   JHI_CELL = JHI_FACE ! Last internal cell index.
   JSTR     = JLO_FACE - NGUARD    ! Allocation start y arrays.
   JEND     = JHI_FACE + NGUARD    ! Allocation end y arrays.

   ! Z direction bounds:
   KLO_FACE = 0                    ! Low mesh boundary face index.
   KHI_FACE = KBAR                 ! High mesh boundary face index.
   KLO_CELL = KLO_FACE + 1     ! First internal cell index. See notes.
   KHI_CELL = KHI_FACE ! Last internal cell index.
   KSTR     = KLO_FACE - NGUARD    ! Allocation start z arrays.
   KEND     = KHI_FACE + NGUARD    ! Allocation end z arrays.

   ! Define grid arrays for this mesh:
   ! Populate position and cell size arrays: Uniform grid implementation.
   ! X direction:
   ALLOCATE(DXCELL(ISTR:IEND)); DXCELL(ILO_CELL-1:IHI_CELL+1) = DX(ILO_CELL-1:IHI_CELL+1)
   DO IGC=2,NGUARD
      DXCELL(ILO_CELL-IGC)=DXCELL(ILO_CELL-IGC+1)
      DXCELL(IHI_CELL+IGC)=DXCELL(IHI_CELL+IGC-1)
   ENDDO
   ALLOCATE(DXFACE(ISTR:IEND)); DXFACE(ILO_FACE:IHI_FACE)= DXN(ILO_FACE:IHI_FACE)
   DO IGC=1,NGUARD
      DXFACE(ILO_FACE-IGC)=DXFACE(ILO_FACE-IGC+1)
      DXFACE(IHI_FACE+IGC)=DXFACE(ILO_FACE+IGC-1)
   ENDDO
   ALLOCATE(XCELL(ISTR:IEND));  XCELL = 1._EB/GEOMEPS ! Initialize huge.
   XCELL(ILO_CELL-1:IHI_CELL+1) = XC(ILO_CELL-1:IHI_CELL+1)
   DO IGC=2,NGUARD
      XCELL(ILO_CELL-IGC)=XCELL(ILO_CELL-IGC+1)-DXFACE(ILO_FACE-IGC+1)
      XCELL(IHI_CELL+IGC)=XCELL(IHI_CELL+IGC-1)+DXFACE(IHI_FACE+IGC-1)
   ENDDO
   ALLOCATE(XFACE(ISTR:IEND));  XFACE = 1._EB/GEOMEPS ! Initialize huge.
   XFACE(ILO_FACE:IHI_FACE) = X(ILO_FACE:IHI_FACE)
   DO IGC=1,NGUARD
      XFACE(ILO_FACE-IGC)=XFACE(ILO_FACE-IGC+1)-DXCELL(ILO_CELL-IGC)
      XFACE(IHI_FACE+IGC)=XFACE(IHI_FACE+IGC-1)+DXCELL(IHI_CELL+IGC)
   ENDDO

   ! Y direction:
   ALLOCATE(DYCELL(JSTR:JEND)); DYCELL(JLO_CELL-1:JHI_CELL+1)= DY(JLO_CELL-1:JHI_CELL+1)
   DO IGC=2,NGUARD
      DYCELL(JLO_CELL-IGC)=DYCELL(JLO_CELL-IGC+1)
      DYCELL(JHI_CELL+IGC)=DYCELL(JHI_CELL+IGC-1)
   ENDDO
   ALLOCATE(DYFACE(JSTR:JEND)); DYFACE(JLO_FACE:JHI_FACE)= DYN(JLO_FACE:JHI_FACE)
   DO IGC=1,NGUARD
      DYFACE(JLO_FACE-IGC)=DYFACE(JLO_FACE-IGC+1)
      DYFACE(JHI_FACE+IGC)=DYFACE(JHI_FACE+IGC-1)
   ENDDO
   ALLOCATE(YCELL(JSTR:JEND));  YCELL = 1._EB/GEOMEPS ! Initialize huge.
   YCELL(JLO_CELL-1:JHI_CELL+1) = YC(JLO_CELL-1:JHI_CELL+1)
   DO IGC=2,NGUARD
      YCELL(JLO_CELL-IGC)=YCELL(JLO_CELL-IGC+1)-DYFACE(JLO_FACE-IGC+1)
      YCELL(JHI_CELL+IGC)=YCELL(JHI_CELL+IGC-1)+DYFACE(JHI_FACE+IGC-1)
   ENDDO
   ALLOCATE(YFACE(JSTR:JEND));  YFACE = 1._EB/GEOMEPS ! Initialize huge.
   YFACE(JLO_FACE:JHI_FACE) = Y(JLO_FACE:JHI_FACE)
   DO IGC=1,NGUARD
      YFACE(JLO_FACE-IGC)=YFACE(JLO_FACE-IGC+1)-DYCELL(JLO_CELL-IGC)
      YFACE(JHI_FACE+IGC)=YFACE(JHI_FACE+IGC-1)+DYCELL(JHI_CELL+IGC)
   ENDDO

   ! Z direction:
   ALLOCATE(DZCELL(KSTR:KEND)); DZCELL(KLO_CELL-1:KHI_CELL+1)= DZ(KLO_CELL-1:KHI_CELL+1)
   DO IGC=2,NGUARD
      DZCELL(KLO_CELL-IGC)=DZCELL(KLO_CELL-IGC+1)
      DZCELL(KHI_CELL+IGC)=DZCELL(KHI_CELL+IGC-1)
   ENDDO
   ALLOCATE(DZFACE(KSTR:KEND)); DZFACE(KLO_FACE:KHI_FACE)= DZN(KLO_FACE:KHI_FACE)
   DO IGC=1,NGUARD
      DZFACE(KLO_FACE-IGC)=DZFACE(KLO_FACE-IGC+1)
      DZFACE(KHI_FACE+IGC)=DZFACE(KHI_FACE+IGC-1)
   ENDDO
   ALLOCATE(ZCELL(KSTR:KEND));  ZCELL = 1._EB/GEOMEPS ! Initialize huge.
   ZCELL(KLO_CELL-1:KHI_CELL+1) = ZC(KLO_CELL-1:KHI_CELL+1)
   DO IGC=2,NGUARD
      ZCELL(KLO_CELL-IGC)=ZCELL(KLO_CELL-IGC+1)-DZFACE(KLO_FACE-IGC+1)
      ZCELL(KHI_CELL+IGC)=ZCELL(KHI_CELL+IGC-1)+DZFACE(KHI_FACE+IGC-1)
   ENDDO
   ALLOCATE(ZFACE(KSTR:KEND));  ZFACE = 1._EB/GEOMEPS ! Initialize huge.
   ZFACE(KLO_FACE:KHI_FACE) = Z(KLO_FACE:KHI_FACE)
   DO IGC=1,NGUARD
      ZFACE(KLO_FACE-IGC)=ZFACE(KLO_FACE-IGC+1)-DZCELL(KLO_CELL-IGC)
      ZFACE(KHI_FACE+IGC)=ZFACE(KHI_FACE+IGC-1)+DZCELL(KHI_CELL+IGC)
   ENDDO

   ! Initialize CC_IDRC to CC_FGSC, this is to discard from the onset faces that can not be used in interpolation
   ! stencils (i.e. not fluid points). Faces allowed for interpolation stencils must be type CC_GASPHASE:
   FCVAR(:,:,:,CC_IDRC,IAXIS:KAXIS) = FCVAR(:,:,:,CC_FGSC,IAXIS:KAXIS)

   ! 1.:
   ! Loop by CUT_CELL, define interpolation stencils in Cartesian and cut
   ! cell centroids using the corresponding cells INBOUNDARY cut-faces:
   ! to be used for interpolation of H, etc.
   TESTVAR = CC_CGSC
   CUT_CELL_LOOP2 : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH

      NCELL = MESHES(NM)%CUT_CELL(ICC)%NCELL
      IJK(IAXIS:KAXIS) = MESHES(NM)%CUT_CELL(ICC)%IJK(IAXIS:KAXIS)
      I = IJK(IAXIS); J = IJK(JAXIS); K = IJK(KAXIS)
      IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
      MIN_DIST_VEL = DIST_THRES*MIN(DXCELL(I),DYCELL(J),DZCELL(K))

      ! First Cartesian centroid:
      XYZ(IAXIS:KAXIS) = (/ XCELL(I), YCELL(J), ZCELL(K) /)

      NPE_LIST_START = 0
      ALLOCATE(INT_NPE(LOW_IND:HIGH_IND,0:0,1:INT_N_EXT_PTS,0:CUT_CELL(ICC)%NCELL), &
               INT_IJK(IAXIS:KAXIS,(CUT_CELL(ICC)%NCELL+1)*DELTA_INT),                      &
               INT_COEF((CUT_CELL(ICC)%NCELL+1)*DELTA_INT),INT_NOUT(IAXIS:KAXIS,0:CUT_CELL(ICC)%NCELL))

      ! Now cut-cell volumes:
      ICELL_LOOP : DO ICELL=0,NCELL

         IF(ICELL > 0) XYZ(IAXIS:KAXIS)=MESHES(NM)%CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,ICELL)

         ! Initialize closest inboundary point data:
         DISTANCE            = 1._EB / GEOMEPS
         LASTDOTNVEC         =-1._EB / GEOMEPS
         FOUND_POINT         = .FALSE.
         XYZ_PP(IAXIS:KAXIS) = 0._EB
         FOUND_INBFC(1:3)    = 0

         JCC_LOOP : DO JCC=1,NCELL

            ! Find closest point and Inboundary cut-face:
            NFC_CC = MESHES(NM)%CUT_CELL(ICC)%CCELEM(1,JCC)
            DO CCFC=1,NFC_CC

               ICFC = MESHES(NM)%CUT_CELL(ICC)%CCELEM(CCFC+1,JCC)
               IF ( MESHES(NM)%CUT_CELL(ICC)%FACE_LIST(1,ICFC) /= CC_FTYPE_CFINB) CYCLE

               ! Inboundary face number in CUT_FACE:
               INBFC     = MESHES(NM)%CUT_CELL(ICC)%FACE_LIST(4,ICFC)
               INBFC_LOC = MESHES(NM)%CUT_CELL(ICC)%FACE_LIST(5,ICFC)

               CALL GET_CLSPT_INBCF(NM,XYZ,INBFC,INBFC_LOC,XYZ_IP,DIST,FOUNDPT,INSEG)
               IF (FOUNDPT .AND. ((DIST-DISTANCE) < GEOMEPS)) THEN
                   IF (INSEG) THEN
                       BODTRI(1:2)  = CUT_FACE(INBFC)%BODTRI(1:2,INBFC_LOC)
                       ! normal vector to boundary surface triangle:
                       IBOD    = BODTRI(1)
                       IWSEL   = BODTRI(2)
                       NVEC(IAXIS:KAXIS) = GEOMETRY(IBOD)%FACES_NORMAL(IAXIS:KAXIS,IWSEL)
                       DV(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS) - XYZ_IP(IAXIS:KAXIS)
                       NORM_DV = SQRT( DV(IAXIS)**2._EB + DV(JAXIS)**2._EB + DV(KAXIS)**2._EB )
                       IF(NORM_DV > GEOMEPS) THEN ! Point in segment not same as pt to interp to.
                          DV(IAXIS:KAXIS) = (1._EB / NORM_DV) * DV(IAXIS:KAXIS)
                          DOTNVEC = NVEC(IAXIS)*DV(IAXIS) + NVEC(JAXIS)*DV(JAXIS) + NVEC(KAXIS)*DV(KAXIS)
                          IF (DOTNVEC <= LASTDOTNVEC) CYCLE
                          LASTDOTNVEC = DOTNVEC
                       ENDIF
                   ENDIF
                   DISTANCE = DIST
                   XYZ_PP(IAXIS:KAXIS)   = XYZ_IP(IAXIS:KAXIS)
                   FOUND_INBFC(1:3) = (/ CC_FTYPE_CFINB, INBFC, INBFC_LOC /) ! Inbound cut-face in CUT_FACE.
                   FOUND_POINT = .TRUE.
               ENDIF

            ENDDO

            ! If point not found, all cut-faces boundary of the icc, jcc volume
            ! are GASPHASE. There must be a SOLID point in the boundary of the
            ! underlying Cartesian cell. this is the closest point:
            IF (.NOT.FOUND_POINT) THEN
                ! Search for for CUT_CELL(icc) vertex points or other solid points:
                CALL GET_CLOSEPT_CCVT(NM,XYZ,ICC,XYZ_IP,DIST,FOUNDPT,IFCPT,IFCPT_LOC)
                IF (FOUNDPT .AND. ((DIST-DISTANCE) < GEOMEPS)) THEN
                   DISTANCE = DIST
                   XYZ_PP(IAXIS:KAXIS)   = XYZ_IP(IAXIS:KAXIS)
                   FOUND_INBFC(1:3) = (/ CC_FTYPE_SVERT, IFCPT, IFCPT_LOC /) ! SOLID vertex in CUT_FACE.
                   FOUND_POINT = .TRUE.
                ENDIF
            ENDIF

         ENDDO JCC_LOOP

         IF (.NOT.FOUND_POINT .AND. GET_CUTCELLS_VERBOSE) THEN
            IF(ICELL==0) THEN
               WRITE(LU_ERR,*) 'CF: Havent found closest point CART CELL. ICC=',ICC
            ELSE
               WRITE(LU_ERR,*) 'CF: Havent found closest point CUT CELL. ICC,JCC=',ICC,JCC
            ENDIF
         ENDIF

         ! Here test if point in boundary and interpolation point coincide:
         IF (DISTANCE <= MIN_DIST_VEL) THEN

            INT_NOUT(IAXIS:KAXIS,ICELL) = 0._EB
            INT_XN(0:INT_N_EXT_PTS) = 0._EB
            INT_CN(0:INT_N_EXT_PTS) = 0._EB; INT_CN(0) = 1._EB ! Boundary point coefficient:
            VIND = 0
            DO EP=1,INT_N_EXT_PTS  ! External point for face IFACE
                NPE_LIST_COUNT = 0
                INT_NPE(LOW_IND,VIND,EP,ICELL)  = NPE_LIST_START
                INT_NPE(HIGH_IND,VIND,EP,ICELL) = NPE_LIST_COUNT
                NPE_LIST_START = NPE_LIST_START + NPE_LIST_COUNT
            ENDDO

         ELSE ! DISTANCE <= MIN_DIST_VEL

            ! After this loop we have the closest boundary point to xyz and the
            ! cut-face it belongs. We need to use the normal out of the face (or the
            ! vertex to xyz direction to find fluid points on the stencil:
            ! The fluid points are points that lay on the plane outside in the
            ! largest Cartesian component direction of the normal.
            DIR_FCT = 1._EB
            IF (FOUND_INBFC(1) == CC_FTYPE_CFINB) THEN ! closest point in INBOUNDARY cut-face.
                BODTRI(1:2) = CUT_FACE(FOUND_INBFC(2))%BODTRI(1:2,FOUND_INBFC(3))
                ! normal vector to boundary surface triangle:
                IBOD    = BODTRI(1)
                IWSEL   = BODTRI(2)
                NVEC(IAXIS:KAXIS) = GEOMETRY(IBOD)%FACES_NORMAL(IAXIS:KAXIS,IWSEL)
                DV(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS) - XYZ_PP(IAXIS:KAXIS)
                DOTNVEC = NVEC(IAXIS)*DV(IAXIS) + NVEC(JAXIS)*DV(JAXIS) + NVEC(KAXIS)*DV(KAXIS)

                IF (DOTNVEC < 0._EB) DIR_FCT = -1._EB ! if normal to triangle has opposite dir change
                                                      ! search direction.
            ENDIF

            ! Versor to GASPHASE:
            IF (DIR_FCT > 0._EB) THEN ! Versor from boundary point to centroid
                P0(IAXIS:KAXIS) = XYZ_PP(IAXIS:KAXIS)
                P1(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS)
            ELSE ! Viceversa
                P0(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS)
                P1(IAXIS:KAXIS) = XYZ_PP(IAXIS:KAXIS)
            ENDIF
            DV(IAXIS:KAXIS)   = DIR_FCT * ( XYZ(IAXIS:KAXIS) - XYZ_PP(IAXIS:KAXIS) )
            NORM_DV           = SQRT( DV(IAXIS)**2._EB + DV(JAXIS)**2._EB + DV(KAXIS)**2._EB )
            DV(IAXIS:KAXIS) = (1._EB / NORM_DV) * DV(IAXIS:KAXIS) ! NOUT

            CALL GET_DELN(1.001_EB,DELN,DXCELL(I),DYCELL(J),DZCELL(K),NVEC=DV,CLOSE_PT=.TRUE.)

            ! Location of interpolation point XYZ(IAXIS:KAXIS) along the DV direction, origin in
            ! boundary point XYZ_PP(IAXIS:KAXIS):
            INT_NOUT(IAXIS:KAXIS,ICELL) = DV(IAXIS:KAXIS)
            INT_XN(0)               = DIR_FCT * NORM_DV
            INT_XN(1:INT_N_EXT_PTS) = 0._EB
            ! Initialize interpolation coefficients along the normal probe direction DV
            INT_CN(0) = 0._EB; ! Boundary point interpolation coefficient
            INT_CN(1:INT_N_EXT_PTS) = 0._EB;
            VIND = 0
            DO EP=1,INT_N_EXT_PTS  ! External point for face IFACE
               INT_XN(EP) = REAL(EP,EB)*DELN
               CALL GET_INTSTENCILS_EP(.FALSE.,VIND,XYZ_PP,INT_XN(EP),DV, &
                                       NPE_LIST_START,NPE_LIST_COUNT,INT_IJK,INT_COEF)
               ! Start position for interpolation stencil related to VIND=0, of external
               ! point EP related to cut-cell ICELL:
               INT_NPE(LOW_IND,VIND,EP,ICELL)  = NPE_LIST_START
               ! Number of stencil points on stencil for said cc.
               INT_NPE(HIGH_IND,VIND,EP,ICELL) = NPE_LIST_COUNT
               NPE_LIST_START = NPE_LIST_START + NPE_LIST_COUNT
            ENDDO

         ENDIF ! DISTANCE <= MIN_DIST_VEL

         CUT_CELL(ICC)%INT_XYZBF(IAXIS:KAXIS,ICELL) = XYZ_PP(IAXIS:KAXIS) ! xyz of boundary pt.
         CUT_CELL(ICC)%INT_INBFC(1:3,ICELL)         = FOUND_INBFC(1:3)  ! which INB cut-face bndry pt belongs to.
         CUT_CELL(ICC)%INT_NOUT(IAXIS:KAXIS,ICELL)  = INT_NOUT(IAXIS:KAXIS,ICELL)
         CUT_CELL(ICC)%INT_XN(0:INT_N_EXT_PTS,ICELL)= INT_XN(0:INT_N_EXT_PTS)
         CUT_CELL(ICC)%INT_CN(0:INT_N_EXT_PTS,ICELL)= INT_CN(0:INT_N_EXT_PTS)
         ! If size of CUT_CELL(ICC)%INT_IJK,DIM=2 is less than the size of INT_IJK, reallocate:
         SZ_1 = SIZE(CUT_CELL(ICC)%INT_IJK,DIM=2)
         SZ_2 = SIZE(INT_IJK,DIM=2)
         IF(SZ_2 > SZ_1) THEN
            ALLOCATE(INT_IJK_AUX(IAXIS:KAXIS,SZ_1),INT_COEF_AUX(1:SZ_1))
            INT_IJK_AUX(IAXIS:KAXIS,1:SZ_1)  = CUT_CELL(ICC)%INT_IJK(IAXIS:KAXIS,1:SZ_1)
            INT_COEF_AUX(1:SZ_1)             = CUT_CELL(ICC)%INT_COEF(1:SZ_1)
            DEALLOCATE(CUT_CELL(ICC)%INT_IJK, CUT_CELL(ICC)%INT_COEF)
            ALLOCATE(CUT_CELL(ICC)%INT_IJK(IAXIS:KAXIS,SZ_2)); CUT_CELL(ICC)%INT_IJK = CC_UNDEFINED
            ALLOCATE(CUT_CELL(ICC)%INT_COEF(1:SZ_2)); CUT_CELL(ICC)%INT_COEF = 0._EB
            CUT_CELL(ICC)%INT_IJK(IAXIS:KAXIS,1:SZ_1)  = INT_IJK_AUX(IAXIS:KAXIS,1:SZ_1)
            CUT_CELL(ICC)%INT_COEF(1:SZ_1)             = INT_COEF_AUX(1:SZ_1)
            DEALLOCATE(INT_IJK_AUX,INT_COEF_AUX)
            DEALLOCATE(CUT_CELL(ICC)%INT_CCVARS,CUT_CELL(ICC)%INT_NOMIND)
            ALLOCATE(CUT_CELL(ICC)%INT_CCVARS(1:N_INT_CCVARS,SZ_2)); CUT_CELL(ICC)%INT_CCVARS=0._EB
            ALLOCATE(CUT_CELL(ICC)%INT_NOMIND(LOW_IND:HIGH_IND,SZ_2)); CUT_CELL(ICC)%INT_NOMIND = CC_UNDEFINED
         ENDIF
         VIND = 0
         DO EP=1,INT_N_EXT_PTS  ! External point for CELL ICELL
            INT_NPE_LO = INT_NPE(LOW_IND,VIND,EP,ICELL)
            INT_NPE_HI = INT_NPE(HIGH_IND,VIND,EP,ICELL)
            CUT_CELL(ICC)%INT_NPE(LOW_IND,VIND,EP,ICELL) = INT_NPE_LO
            CUT_CELL(ICC)%INT_NPE(HIGH_IND,VIND,EP,ICELL)= INT_NPE_HI
            DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
               CUT_CELL(ICC)%INT_IJK(IAXIS:KAXIS,INPE)  = INT_IJK(IAXIS:KAXIS,INPE)
               CUT_CELL(ICC)%INT_COEF(INPE)             = INT_COEF(INPE)
            ENDDO
         ENDDO

      ENDDO ICELL_LOOP
      DEALLOCATE(INT_NPE,INT_IJK,INT_COEF,INT_NOUT)

   ENDDO CUT_CELL_LOOP2

   ! Compute stencils for RCEDGES, regular edges connecting cut and regular faces, and IBEDGES, solid edges next to cut-faces:
   RCEDGE_LOOP_1 : DO IEDGE=1,MESHES(NM)%CC_NRCEDGE
      ALLOCATE(CC_RCEDGE(IEDGE)%XB_IB(-2:2),CC_RCEDGE(IEDGE)%SURF_INDEX(-2:2),&
      CC_RCEDGE(IEDGE)%DUIDXJ(-2:2),CC_RCEDGE(IEDGE)%MU_DUIDXJ(-2:2))
      ALLOCATE(CC_RCEDGE(IEDGE)%INT_NPE(LOW_IND:HIGH_IND,0:KAXIS,1:INT_N_EXT_PTS,-2:2))
      CC_RCEDGE(IEDGE)%XB_IB(-2:2)      = 0._EB
      CC_RCEDGE(IEDGE)%SURF_INDEX(-2:2) = -1
      ! CC_RCEDGE(IEDGE)%PROCESS_EDGE_ORIENTATION(-2:2) = .FALSE. ! Process Orientation in double loop.
      ! CC_RCEDGE(IEDGE)%EDGE_IN_MESH(-2:2)             = .TRUE.  ! Always true for RCEDGES, no need to mesh_cc_exchange variables.
      CC_RCEDGE(IEDGE)%INT_NPE                          = 0       ! Required to avoid segfault in comm.

      IE  = MESHES(NM)%CC_RCEDGE(IEDGE)%IE
      II  = EDGE(IE)%I
      JJ  = EDGE(IE)%J
      KK  = EDGE(IE)%K
      IEC = EDGE(IE)%AXIS

      ! First: Loop over all possible face orientations of edge to define XB_IB, SURF_INDEX, PROCESS_EDGE_ORIENTATION:
      ORIENTATION_LOOP_RC_1: DO IS=1,3
         IF (IS==IEC) CYCLE ORIENTATION_LOOP_RC_1
         SIGN_LOOP_RC_1: DO I_SGN=-1,1,2

            ! Determine Index_Coordinate_Direction
            ! IEC=1, ICD=1 refers to DWDY; ICD=2 refers to DVDZ
            ! IEC=2, ICD=1 refers to DUDZ; ICD=2 refers to DWDX
            ! IEC=3, ICD=1 refers to DVDX; ICD=2 refers to DUDY

            IF (IS>IEC) ICD = IS-IEC
            IF (IS<IEC) ICD = IS-IEC+3
            ICD_SGN = I_SGN * ICD

            ! With ICD_SGN check if face:
            ! IBEDGE IEC=IAXIS => ICD_SGN=-2 => FACE  low Z normal to JAXIS.
            !                     ICD_SGN=-1 => FACE  low Y normal to KAXIS.
            !                     ICD_SGN= 1 => FACE high Y normal to KAXIS.
            !                     ICD_SGN= 2 => FACE high Z normal to JAXIS.
            ! IBEDGE IEC=JAXIS => ICD_SGN=-2 => FACE  low X normal to KAXIS.
            !                     ICD_SGN=-1 => FACE  low Z normal to IAXIS.
            !                     ICD_SGN= 1 => FACE high Z normal to IAXIS.
            !                     ICD_SGN= 2 => FACE high X normal to KAXIS.
            ! IBEDGE IEC=KAXIS => ICD_SGN=-2 => FACE  low Y normal to IAXIS.
            !                     ICD_SGN=-1 => FACE  low X normal to JAXIS.
            !                     ICD_SGN= 1 => FACE high X normal to JAXIS.
            !                     ICD_SGN= 2 => FACE high Y normal to IAXIS.
            ! is GASPHASE cut-face.
            SELECT CASE(IEC)
               CASE(IAXIS)
                  ! Define Face indexes and normal axis FAXIS.
                  SELECT CASE(ICD_SGN)
                     CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
                     CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
                     CASE( 1); IIF=II  ; JJF=JJ+1; KKF=KK  ; FAXIS=KAXIS
                     CASE( 2); IIF=II  ; JJF=JJ  ; KKF=KK+1; FAXIS=JAXIS
                  END SELECT
                  ! Compute XB_IB: For XB_IB we use the sum of gas cut-faces in the face and compare it with the face AREA:
                  AREA_CF = 0._EB; DXX(1)  = DY(JJF); DXX(2)  = DZ(KKF); DEL_IBEDGE = DX(IIF)
                  ICF = FCVAR(IIF,JJF,KKF,CC_IDCF,FAXIS)
                  IF(ICF>0) THEN
                     AREA_CF = SUM(CUT_FACE(ICF)%AREA(1:CUT_FACE(ICF)%NFACE))
                     DEL_IBEDGE = ABS(MAXVAL(CUT_FACE(ICF)%XYZVERT(IAXIS,1:CUT_FACE(ICF)%NVERT)) - &
                                      MINVAL(CUT_FACE(ICF)%XYZVERT(IAXIS,1:CUT_FACE(ICF)%NVERT))) + TWO_EPSILON_EB
                  ENDIF
                  IF (FAXIS==JAXIS) THEN
                     CC_RCEDGE(IEDGE)%XB_IB(ICD_SGN) = DXX(2) ! Twice Distance to velocity collocation point.
                     IF(FCVAR(IIF,JJF,KKF,CC_FGSC,FAXIS)==CC_CUTCFE) THEN
                        CC_RCEDGE(IEDGE)%XB_IB(ICD_SGN)=(AREA_CF/DEL_IBEDGE)
                        ! SURF_INDEX:
                        IF (CCVAR(IIF,JJF,KKF,CC_IDCF)>0) THEN
                           ! Low side cut-cell: Load first cut-face SURF_INDEX:
                           CC_RCEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF,KKF,CC_IDCF))%SURF_INDEX(1)
                        ELSEIF(CCVAR(IIF,JJF+1,KKF,CC_IDCF)>0) THEN
                           ! High side cut-cell: Load first cut-face SURF_INDEX:
                           CC_RCEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF+1,KKF,CC_IDCF))%SURF_INDEX(1)
                        ENDIF
                     ENDIF
                  ELSE ! IF(FAXIS==KAXIS) THEN
                     CC_RCEDGE(IEDGE)%XB_IB(ICD_SGN) = DXX(1) ! Twice Distance to velocity collocation point.
                     IF(FCVAR(IIF,JJF,KKF,CC_FGSC,FAXIS)==CC_CUTCFE) THEN
                        CC_RCEDGE(IEDGE)%XB_IB(ICD_SGN)=(AREA_CF/DEL_IBEDGE)
                        ! SURF_INDEX:
                        IF (CCVAR(IIF,JJF,KKF,CC_IDCF)>0) THEN
                           CC_RCEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF,KKF,CC_IDCF))%SURF_INDEX(1)
                        ELSEIF(CCVAR(IIF,JJF,KKF+1,CC_IDCF)>0) THEN
                           CC_RCEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF,KKF+1,CC_IDCF))%SURF_INDEX(1)
                        ENDIF
                     ENDIF
                  ENDIF

               CASE(JAXIS)
                  ! Define Face indexes and normal axis FAXIS.
                  SELECT CASE(ICD_SGN)
                     CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
                     CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=IAXIS
                     CASE( 1); IIF=II  ; JJF=JJ  ; KKF=KK+1; FAXIS=IAXIS
                     CASE( 2); IIF=II+1; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
                  END SELECT
                  ! Compute XB_IB: For XB_IB we use the sum of gas cut-faces in the face and compare it with the face AREA:
                  AREA_CF = 0._EB; DXX(1)  = DZ(KKF); DXX(2)  = DX(IIF); DEL_IBEDGE = DY(JJF)
                  ICF = FCVAR(IIF,JJF,KKF,CC_IDCF,FAXIS)
                  IF(ICF>0) THEN
                     AREA_CF = SUM(CUT_FACE(ICF)%AREA(1:CUT_FACE(ICF)%NFACE))
                     DEL_IBEDGE = ABS(MAXVAL(CUT_FACE(ICF)%XYZVERT(JAXIS,1:CUT_FACE(ICF)%NVERT)) - &
                                      MINVAL(CUT_FACE(ICF)%XYZVERT(JAXIS,1:CUT_FACE(ICF)%NVERT))) + TWO_EPSILON_EB
                  ENDIF
                  IF (FAXIS==KAXIS) THEN
                     CC_RCEDGE(IEDGE)%XB_IB(ICD_SGN) = DXX(2) ! Twice Distance to velocity collocation point.
                     IF(FCVAR(IIF,JJF,KKF,CC_FGSC,FAXIS)==CC_CUTCFE) THEN
                        CC_RCEDGE(IEDGE)%XB_IB(ICD_SGN)=(AREA_CF/DEL_IBEDGE)
                        ! SURF_INDEX:
                        IF (CCVAR(IIF,JJF,KKF,CC_IDCF)>0) THEN
                           CC_RCEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF,KKF,CC_IDCF))%SURF_INDEX(1)
                        ELSEIF(CCVAR(IIF,JJF,KKF+1,CC_IDCF)>0) THEN
                           CC_RCEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF,KKF+1,CC_IDCF))%SURF_INDEX(1)
                        ENDIF
                     ENDIF
                  ELSE ! IF(FAXIS==IAXIS) THEN
                     CC_RCEDGE(IEDGE)%XB_IB(ICD_SGN) = DXX(1) ! Twice Distance to velocity collocation point.
                     IF(FCVAR(IIF,JJF,KKF,CC_FGSC,FAXIS)==CC_CUTCFE) THEN
                        CC_RCEDGE(IEDGE)%XB_IB(ICD_SGN)=(AREA_CF/DEL_IBEDGE)
                        ! SURF_INDEX:
                        IF (CCVAR(IIF,JJF,KKF,CC_IDCF)>0) THEN
                           CC_RCEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF,KKF,CC_IDCF))%SURF_INDEX(1)
                        ELSEIF(CCVAR(IIF+1,JJF,KKF,CC_IDCF)>0) THEN
                           CC_RCEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF+1,JJF,KKF,CC_IDCF))%SURF_INDEX(1)
                        ENDIF
                     ENDIF
                  ENDIF

               CASE(KAXIS)
                  ! Define Face indexes and normal axis FAXIS.
                  SELECT CASE(ICD_SGN)
                     CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=IAXIS
                     CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
                     CASE( 1); IIF=II+1; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
                     CASE( 2); IIF=II  ; JJF=JJ+1; KKF=KK  ; FAXIS=IAXIS
                  END SELECT
                  ! Compute XB_IB: For XB_IB we use the sum of gas cut-faces in the face and compare it with the face AREA:
                  AREA_CF = 0._EB; DXX(1)  = DX(IIF); DXX(2)  = DY(JJF); DEL_IBEDGE = DZ(KKF)
                  ICF = FCVAR(IIF,JJF,KKF,CC_IDCF,FAXIS)
                  IF(ICF>0) THEN
                     AREA_CF = SUM(CUT_FACE(ICF)%AREA(1:CUT_FACE(ICF)%NFACE))
                     DEL_IBEDGE = ABS(MAXVAL(CUT_FACE(ICF)%XYZVERT(KAXIS,1:CUT_FACE(ICF)%NVERT)) - &
                                      MINVAL(CUT_FACE(ICF)%XYZVERT(KAXIS,1:CUT_FACE(ICF)%NVERT))) + TWO_EPSILON_EB
                  ENDIF
                  IF (FAXIS==IAXIS) THEN
                     CC_RCEDGE(IEDGE)%XB_IB(ICD_SGN) = DXX(2) ! Twice Distance to velocity collocation point.
                     IF(FCVAR(IIF,JJF,KKF,CC_FGSC,FAXIS)==CC_CUTCFE) THEN
                        CC_RCEDGE(IEDGE)%XB_IB(ICD_SGN)=(AREA_CF/DEL_IBEDGE)
                        ! SURF_INDEX:
                        IF (CCVAR(IIF,JJF,KKF,CC_IDCF)>0) THEN
                           CC_RCEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF,KKF,CC_IDCF))%SURF_INDEX(1)
                        ELSEIF(CCVAR(IIF+1,JJF,KKF,CC_IDCF)>0) THEN
                           CC_RCEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF+1,JJF,KKF,CC_IDCF))%SURF_INDEX(1)
                        ENDIF
                     ENDIF
                  ELSE ! IF(FAXIS==JAXIS) THEN
                     CC_RCEDGE(IEDGE)%XB_IB(ICD_SGN) = DXX(1) ! Twice Distance to velocity collocation point.
                     IF(FCVAR(IIF,JJF,KKF,CC_FGSC,FAXIS)==CC_CUTCFE) THEN
                        CC_RCEDGE(IEDGE)%XB_IB(ICD_SGN)=(AREA_CF/DEL_IBEDGE)
                        ! SURF_INDEX:
                        IF (CCVAR(IIF,JJF,KKF,CC_IDCF)>0) THEN
                           CC_RCEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF,KKF,CC_IDCF))%SURF_INDEX(1)
                        ELSEIF(CCVAR(IIF,JJF+1,KKF,CC_IDCF)>0) THEN
                           CC_RCEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF+1,KKF,CC_IDCF))%SURF_INDEX(1)
                        ENDIF
                     ENDIF
                  ENDIF

             END SELECT

          ENDDO SIGN_LOOP_RC_1
       ENDDO ORIENTATION_LOOP_RC_1

   ENDDO RCEDGE_LOOP_1

   ! Dummy allocation for now:
   IBEDGE_LOOP1 : DO IEDGE=1,MESHES(NM)%CC_NIBEDGE

      ALLOCATE(CC_IBEDGE(IEDGE)%XB_IB(-2:2),CC_IBEDGE(IEDGE)%SURF_INDEX(-2:2),&
               CC_IBEDGE(IEDGE)%PROCESS_EDGE_ORIENTATION(-2:2),CC_IBEDGE(IEDGE)%EDGE_IN_MESH(-2:2),&
               CC_IBEDGE(IEDGE)%SIDE_IN_GEOM(-2:2))
      ALLOCATE(CC_IBEDGE(IEDGE)%INT_NPE(LOW_IND:HIGH_IND,0:KAXIS,1:INT_N_EXT_PTS,-2:2))
      CC_IBEDGE(IEDGE)%XB_IB(-2:2)      = 0._EB
      CC_IBEDGE(IEDGE)%SURF_INDEX(-2:2) = 0
      CC_IBEDGE(IEDGE)%PROCESS_EDGE_ORIENTATION(-2:2) = .FALSE. ! Process Orientation in double loop.
      CC_IBEDGE(IEDGE)%EDGE_IN_MESH(-2:2)             = .FALSE. ! If true, no need to mesh_cc_exchange variables.
      CC_IBEDGE(IEDGE)%SIDE_IN_GEOM(-2:2)             = .TRUE.  ! If true, this side of Cartesian edge looks inside the geometry.
                                                                ! else there is a boundary edge on its position for this side.
      CC_IBEDGE(IEDGE)%INT_NPE                        = 0 ! Required to avoid segfault in comm.

      IE  = MESHES(NM)%CC_IBEDGE(IEDGE)%IE
      II  = EDGE(IE)%I
      JJ  = EDGE(IE)%J
      KK  = EDGE(IE)%K
      IEC = EDGE(IE)%AXIS

      ! Edge nodes location:
      XYZ1 = (/ X(II), Y(JJ), Z(KK) /); XYZ2 = XYZ1
      SELECT CASE(IEC)
         CASE(IAXIS); XYZ1(IAXIS) = X(II-1)
         CASE(JAXIS); XYZ1(JAXIS) = Y(JJ-1)
         CASE(KAXIS); XYZ1(KAXIS) = Z(KK-1)
      END SELECT

      ! First: Loop over all possible face orientations of edge to define XB_IB, SURF_INDEX, PROCESS_EDGE_ORIENTATION:
      ORIENTATION_LOOP_1: DO IS=1,3
         IF (IS==IEC) CYCLE ORIENTATION_LOOP_1
         SIGN_LOOP_1: DO I_SGN=-1,1,2

            ! Determine Index_Coordinate_Direction
            ! IEC=1, ICD=1 refers to DWDY; ICD=2 refers to DVDZ
            ! IEC=2, ICD=1 refers to DUDZ; ICD=2 refers to DWDX
            ! IEC=3, ICD=1 refers to DVDX; ICD=2 refers to DUDY

            IF (IS>IEC) ICD = IS-IEC
            IF (IS<IEC) ICD = IS-IEC+3
            ICD_SGN = I_SGN * ICD

            ! With ICD_SGN check if face:
            ! IBEDGE IEC=IAXIS => ICD_SGN=-2 => FACE  low Z normal to JAXIS.
            !                     ICD_SGN=-1 => FACE  low Y normal to KAXIS.
            !                     ICD_SGN= 1 => FACE high Y normal to KAXIS.
            !                     ICD_SGN= 2 => FACE high Z normal to JAXIS.
            ! IBEDGE IEC=JAXIS => ICD_SGN=-2 => FACE  low X normal to KAXIS.
            !                     ICD_SGN=-1 => FACE  low Z normal to IAXIS.
            !                     ICD_SGN= 1 => FACE high Z normal to IAXIS.
            !                     ICD_SGN= 2 => FACE high X normal to KAXIS.
            ! IBEDGE IEC=KAXIS => ICD_SGN=-2 => FACE  low Y normal to IAXIS.
            !                     ICD_SGN=-1 => FACE  low X normal to JAXIS.
            !                     ICD_SGN= 1 => FACE high X normal to JAXIS.
            !                     ICD_SGN= 2 => FACE high Y normal to IAXIS.
            ! is GASPHASE cut-face.
            SELECT CASE(IEC)
               CASE(IAXIS)
                  ! Define Face indexes and normal axis FAXIS.
                  SELECT CASE(ICD_SGN)
                     CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
                     CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
                     CASE( 1); IIF=II  ; JJF=JJ+1; KKF=KK  ; FAXIS=KAXIS
                     CASE( 2); IIF=II  ; JJF=JJ  ; KKF=KK+1; FAXIS=JAXIS
                  END SELECT
                  ! Drop if face is not type CUTCFE:
                  IF(FCVAR(IIF,JJF,KKF,CC_FGSC,FAXIS)/=CC_CUTCFE) CYCLE SIGN_LOOP_1
                  ! Compute XB_IB, SURF_INDEX:
                  ! For XB_IB we use the sum of gas cut-faces in the face and compare it with the face AREA:
                  AREA_CF = 0._EB; DXX(1)  = DY(JJF); DXX(2)  = DZ(KKF); DEL_IBEDGE = DX(IIF)
                  ICF = FCVAR(IIF,JJF,KKF,CC_IDCF,FAXIS)
                  IF(ICF>0) THEN
                     AREA_CF = SUM(CUT_FACE(ICF)%AREA(1:CUT_FACE(ICF)%NFACE))
                     DEL_IBEDGE = ABS(MAXVAL(CUT_FACE(ICF)%XYZVERT(IAXIS,1:CUT_FACE(ICF)%NVERT)) - &
                                      MINVAL(CUT_FACE(ICF)%XYZVERT(IAXIS,1:CUT_FACE(ICF)%NVERT))) + TWO_EPSILON_EB
                     ICEDG = FCVAR(IIF,JJF,KKF,CC_IDCE,FAXIS)
                     IF(ICEDG>0) THEN
                        CE => CUT_EDGE(ICEDG)
                        JEDG_LOOP_1 : DO JCEDG=1,CE%NEDGE
                           DO LOHI=1,2; DO AX=IAXIS,KAXIS
                           IF( ABS(XYZ1(AX)-CE%XYZVERT(AX,CE%CEELEM(LOHI,JCEDG)))>GEOMEPS .AND. &
                               ABS(XYZ2(AX)-CE%XYZVERT(AX,CE%CEELEM(LOHI,JCEDG)))>GEOMEPS ) CYCLE JEDG_LOOP_1
                           ENDDO; ENDDO
                           CC_IBEDGE(IEDGE)%SIDE_IN_GEOM(ICD_SGN) = .FALSE. ! This side of Cartesian edge looks into the gasphase.
                        ENDDO JEDG_LOOP_1
                     ENDIF
                  ENDIF
                  IF (FAXIS==JAXIS) THEN
                     ! XB_IB:
                     CC_IBEDGE(IEDGE)%XB_IB(ICD_SGN) = -(DXX(2)-AREA_CF/DEL_IBEDGE) !-ve dist Bound to IBEDGE opposed to normal.
                     ! SURF_INDEX:
                     IF (CCVAR(IIF,JJF,KKF,CC_IDCF)>0) THEN
                        ! Low side cut-cell: Load first cut-face SURF_INDEX:
                        CC_IBEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF,KKF,CC_IDCF))%SURF_INDEX(1)
                     ELSEIF(CCVAR(IIF,JJF+1,KKF,CC_IDCF)>0) THEN
                        ! High side cut-cell: Load first cut-face SURF_INDEX:
                        CC_IBEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF+1,KKF,CC_IDCF))%SURF_INDEX(1)
                     ENDIF
                  ELSE ! IF(FAXIS==KAXIS) THEN
                     ! XB_IB:
                     CC_IBEDGE(IEDGE)%XB_IB(ICD_SGN) = -(DXX(1)-AREA_CF/DEL_IBEDGE) !-ve dist Bound to IBEDGE opposed to normal.
                     ! SURF_INDEX:
                     IF (CCVAR(IIF,JJF,KKF,CC_IDCF)>0) THEN
                        CC_IBEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF,KKF,CC_IDCF))%SURF_INDEX(1)
                     ELSEIF(CCVAR(IIF,JJF,KKF+1,CC_IDCF)>0) THEN
                        CC_IBEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF,KKF+1,CC_IDCF))%SURF_INDEX(1)
                     ENDIF
                  ENDIF

                  ! Now search where the EP external stress edge will be defined:
                  XB_IB = CC_IBEDGE(IEDGE)%XB_IB(ICD_SGN)
                  SKIP_FCT = 1
                  IF (FAXIS==JAXIS) THEN
                     DEL_EP = DXX(2) - ABS(XB_IB)
                     IF( DEL_EP < THRES_FCT_EP*DXX(2) ) SKIP_FCT = 2 ! Pick next EP point +2*I_SGN
                     JEP=JJ; KEP=KK+SKIP_FCT*I_SGN
                  ELSE ! IF(FAXIS==KAXIS) THEN
                     DEL_EP = DXX(1) - ABS(XB_IB)
                     IF( DEL_EP < THRES_FCT_EP*DXX(1) ) SKIP_FCT = 2 ! Pick next EP point +2*I_SGN
                     JEP=JJ+SKIP_FCT*I_SGN; KEP=KK
                  ENDIF
                  IF( JEP<=JBAR .AND. JEP>=0 .AND. KEP<=KBAR .AND. KEP>=0 ) CC_IBEDGE(IEDGE)%EDGE_IN_MESH(ICD_SGN) = .TRUE.

               CASE(JAXIS)
                  ! Define Face indexes and normal axis FAXIS.
                  SELECT CASE(ICD_SGN)
                     CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
                     CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=IAXIS
                     CASE( 1); IIF=II  ; JJF=JJ  ; KKF=KK+1; FAXIS=IAXIS
                     CASE( 2); IIF=II+1; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
                  END SELECT
                  IF(FCVAR(IIF,JJF,KKF,CC_FGSC,FAXIS)/=CC_CUTCFE) CYCLE SIGN_LOOP_1
                  ! Compute XB_IB, SURF_INDEX:
                  ! For XB_IB we use the sum of gas cut-faces in the face and compare it with the face AREA:
                  AREA_CF = 0._EB; DXX(1)  = DZ(KKF); DXX(2)  = DX(IIF); DEL_IBEDGE = DY(JJF)
                  ICF = FCVAR(IIF,JJF,KKF,CC_IDCF,FAXIS)
                  IF(ICF>0) THEN
                     AREA_CF = SUM(CUT_FACE(ICF)%AREA(1:CUT_FACE(ICF)%NFACE))
                     DEL_IBEDGE = ABS(MAXVAL(CUT_FACE(ICF)%XYZVERT(JAXIS,1:CUT_FACE(ICF)%NVERT)) - &
                                      MINVAL(CUT_FACE(ICF)%XYZVERT(JAXIS,1:CUT_FACE(ICF)%NVERT))) + TWO_EPSILON_EB
                     ICEDG = FCVAR(IIF,JJF,KKF,CC_IDCE,FAXIS)
                     IF(ICEDG>0) THEN
                        CE => CUT_EDGE(ICEDG)
                        JEDG_LOOP_2 : DO JCEDG=1,CE%NEDGE
                           DO LOHI=1,2; DO AX=IAXIS,KAXIS
                           IF( ABS(XYZ1(AX)-CE%XYZVERT(AX,CE%CEELEM(LOHI,JCEDG)))>GEOMEPS .AND. &
                               ABS(XYZ2(AX)-CE%XYZVERT(AX,CE%CEELEM(LOHI,JCEDG)))>GEOMEPS ) CYCLE JEDG_LOOP_2
                           ENDDO; ENDDO
                           CC_IBEDGE(IEDGE)%SIDE_IN_GEOM(ICD_SGN) = .FALSE. ! This side of Cartesian edge looks into the gasphase.
                        ENDDO JEDG_LOOP_2
                     ENDIF
                  ENDIF
                  IF (FAXIS==KAXIS) THEN
                     ! XB_IB:
                     CC_IBEDGE(IEDGE)%XB_IB(ICD_SGN) = -(DXX(2)-AREA_CF/DEL_IBEDGE) !-ve dist Bound to IBEDGE opposed to normal.
                     ! SURF_INDEX:
                     IF (CCVAR(IIF,JJF,KKF,CC_IDCF)>0) THEN
                        CC_IBEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF,KKF,CC_IDCF))%SURF_INDEX(1)
                     ELSEIF(CCVAR(IIF,JJF,KKF+1,CC_IDCF)>0) THEN
                        CC_IBEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF,KKF+1,CC_IDCF))%SURF_INDEX(1)
                     ENDIF
                  ELSE ! IF(FAXIS==IAXIS) THEN
                     ! XB_IB:
                     CC_IBEDGE(IEDGE)%XB_IB(ICD_SGN) = -(DXX(1)-AREA_CF/DEL_IBEDGE) !-ve dist Bound to IBEDGE opposed to normal.
                     ! SURF_INDEX:
                     IF (CCVAR(IIF,JJF,KKF,CC_IDCF)>0) THEN
                        CC_IBEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF,KKF,CC_IDCF))%SURF_INDEX(1)
                     ELSEIF(CCVAR(IIF+1,JJF,KKF,CC_IDCF)>0) THEN
                        CC_IBEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF+1,JJF,KKF,CC_IDCF))%SURF_INDEX(1)
                     ENDIF
                  ENDIF

                  ! Now search where the EP external stress edge will be defined:
                  XB_IB = CC_IBEDGE(IEDGE)%XB_IB(ICD_SGN)
                  SKIP_FCT = 1
                  IF (FAXIS==KAXIS) THEN
                     DEL_EP = DXX(2) - ABS(XB_IB)
                     IF( DEL_EP < THRES_FCT_EP*DXX(2) ) SKIP_FCT = 2 ! Pick next EP point +2*I_SGN
                     IEP=II+SKIP_FCT*I_SGN; KEP=KK
                  ELSE ! IF(FAXIS==IAXIS) THEN
                     DEL_EP = DXX(1) - ABS(XB_IB)
                     IF( DEL_EP < THRES_FCT_EP*DXX(1) ) SKIP_FCT = 2 ! Pick next EP point +2*I_SGN
                     IEP=II; KEP=KK+SKIP_FCT*I_SGN
                  ENDIF
                  IF( IEP<=IBAR .AND. IEP>=0 .AND. KEP<=KBAR .AND. KEP>=0 ) CC_IBEDGE(IEDGE)%EDGE_IN_MESH(ICD_SGN) = .TRUE.

               CASE(KAXIS)
                  ! Define Face indexes and normal axis FAXIS.
                  SELECT CASE(ICD_SGN)
                     CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=IAXIS
                     CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
                     CASE( 1); IIF=II+1; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
                     CASE( 2); IIF=II  ; JJF=JJ+1; KKF=KK  ; FAXIS=IAXIS
                  END SELECT
                  IF(FCVAR(IIF,JJF,KKF,CC_FGSC,FAXIS)/=CC_CUTCFE) CYCLE SIGN_LOOP_1
                  ! Compute XB_IB, SURF_INDEX:
                  ! For XB_IB we use the sum of gas cut-faces in the face and compare it with the face AREA:
                  AREA_CF = 0._EB; DXX(1)  = DX(IIF); DXX(2)  = DY(JJF); DEL_IBEDGE = DZ(KKF)
                  ICF = FCVAR(IIF,JJF,KKF,CC_IDCF,FAXIS)
                  IF(ICF>0) THEN
                     AREA_CF = SUM(CUT_FACE(ICF)%AREA(1:CUT_FACE(ICF)%NFACE))
                     DEL_IBEDGE = ABS(MAXVAL(CUT_FACE(ICF)%XYZVERT(KAXIS,1:CUT_FACE(ICF)%NVERT)) - &
                                      MINVAL(CUT_FACE(ICF)%XYZVERT(KAXIS,1:CUT_FACE(ICF)%NVERT))) + TWO_EPSILON_EB
                     ICEDG = FCVAR(IIF,JJF,KKF,CC_IDCE,FAXIS)
                     IF(ICEDG>0) THEN
                        CE => CUT_EDGE(ICEDG)
                        JEDG_LOOP_3 : DO JCEDG=1,CE%NEDGE
                           DO LOHI=1,2; DO AX=IAXIS,KAXIS
                           IF( ABS(XYZ1(AX)-CE%XYZVERT(AX,CE%CEELEM(LOHI,JCEDG)))>GEOMEPS .AND. &
                               ABS(XYZ2(AX)-CE%XYZVERT(AX,CE%CEELEM(LOHI,JCEDG)))>GEOMEPS ) CYCLE JEDG_LOOP_3
                           ENDDO; ENDDO
                           CC_IBEDGE(IEDGE)%SIDE_IN_GEOM(ICD_SGN) = .FALSE. ! This side of Cartesian edge looks into the gasphase.
                        ENDDO JEDG_LOOP_3
                     ENDIF
                  ENDIF
                  IF (FAXIS==IAXIS) THEN
                     ! XB_IB:
                     CC_IBEDGE(IEDGE)%XB_IB(ICD_SGN) = -(DXX(2)-AREA_CF/DEL_IBEDGE) !-ve dist Bound to IBEDGE opposed to normal.
                     ! SURF_INDEX:
                     IF (CCVAR(IIF,JJF,KKF,CC_IDCF)>0) THEN
                        CC_IBEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF,KKF,CC_IDCF))%SURF_INDEX(1)
                     ELSEIF(CCVAR(IIF+1,JJF,KKF,CC_IDCF)>0) THEN
                        CC_IBEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF+1,JJF,KKF,CC_IDCF))%SURF_INDEX(1)
                     ENDIF
                  ELSE ! IF(FAXIS==JAXIS) THEN
                     ! XB_IB:
                     CC_IBEDGE(IEDGE)%XB_IB(ICD_SGN) = -(DXX(1)-AREA_CF/DEL_IBEDGE) !-ve dist Bound to IBEDGE opposed to normal.
                     ! SURF_INDEX:
                     IF (CCVAR(IIF,JJF,KKF,CC_IDCF)>0) THEN
                        CC_IBEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF,KKF,CC_IDCF))%SURF_INDEX(1)
                     ELSEIF(CCVAR(IIF,JJF+1,KKF,CC_IDCF)>0) THEN
                        CC_IBEDGE(IEDGE)%SURF_INDEX(ICD_SGN) = CUT_FACE(CCVAR(IIF,JJF+1,KKF,CC_IDCF))%SURF_INDEX(1)
                     ENDIF
                  ENDIF

                  ! Now search where the EP external stress edge will be defined:
                  XB_IB = CC_IBEDGE(IEDGE)%XB_IB(ICD_SGN)
                  SKIP_FCT = 1
                  IF (FAXIS==IAXIS) THEN
                     DEL_EP = DXX(2) - ABS(XB_IB)
                     IF( DEL_EP < THRES_FCT_EP*DXX(2) ) SKIP_FCT = 2 ! Pick next EP point +2*I_SGN
                     IEP=II; JEP=JJ+SKIP_FCT*I_SGN
                  ELSE ! IF(FAXIS==JAXIS) THEN
                     DEL_EP = DXX(1) - ABS(XB_IB)
                     IF( DEL_EP < THRES_FCT_EP*DXX(1) ) SKIP_FCT = 2 ! Pick next EP point +2*I_SGN
                     IEP=II+SKIP_FCT*I_SGN; JEP=JJ
                  ENDIF
                  IF( IEP<=IBAR .AND. IEP>=0 .AND. JEP<=JBAR .AND. JEP>=0 ) CC_IBEDGE(IEDGE)%EDGE_IN_MESH(ICD_SGN) = .TRUE.

            END SELECT

            CC_IBEDGE(IEDGE)%PROCESS_EDGE_ORIENTATION(ICD_SGN) = .TRUE.

         ENDDO SIGN_LOOP_1
      ENDDO ORIENTATION_LOOP_1

      ! If the edge orientation is not EDGE_IN_MESH, velocity, MU data for EP is communicated:
      NPE_LIST_START = 0
      ALLOCATE(INT_NPE(LOW_IND:HIGH_IND,0:KAXIS,1:INT_N_EXT_PTS,-2:2),INT_IJK(IAXIS:KAXIS,32)); INT_NPE = 0; INT_IJK = 0;
      ALLOCATE(INT_DCOEF(32,1)); INT_DCOEF = 0._EB
      ! First cell centered Variable MU:
      EP   = 1; N_CVAR_START = NPE_LIST_START
      ORIENTATION_LOOP_2: DO IS=1,3
         IF (IS==IEC) CYCLE ORIENTATION_LOOP_2
         SIGN_LOOP_2: DO I_SGN=-1,1,2
            IF (IS>IEC) ICD = IS-IEC
            IF (IS<IEC) ICD = IS-IEC+3
            ICD_SGN = I_SGN * ICD

            IF(.NOT.CC_IBEDGE(IEDGE)%PROCESS_EDGE_ORIENTATION(ICD_SGN)) CYCLE SIGN_LOOP_2
            IF(CC_IBEDGE(IEDGE)%EDGE_IN_MESH(ICD_SGN)) CYCLE SIGN_LOOP_2

            XB_IB = CC_IBEDGE(IEDGE)%XB_IB(ICD_SGN)

            SELECT CASE(IEC)
               CASE(IAXIS)
                  ! Define Face indexes and normal axis FAXIS.
                  SELECT CASE(ICD_SGN)
                     CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
                     CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
                     CASE( 1); IIF=II  ; JJF=JJ+1; KKF=KK  ; FAXIS=KAXIS
                     CASE( 2); IIF=II  ; JJF=JJ  ; KKF=KK+1; FAXIS=JAXIS
                  END SELECT
                  DXX(1)  = DY(JJF); DXX(2)  = DZ(KKF)
                  SKIP_FCT = 1
                  IF (FAXIS==JAXIS) THEN
                     DEL_EP = DXX(2) - ABS(XB_IB)
                     IF( DEL_EP < THRES_FCT_EP*DXX(2) ) SKIP_FCT = 2 ! Pick next EP point +2*I_SGN
                     IEP=II; JEP=JJ; KEP=KK+SKIP_FCT*I_SGN
                  ELSE ! IF(FAXIS==KAXIS) THEN
                     DEL_EP = DXX(1) - ABS(XB_IB)
                     IF( DEL_EP < THRES_FCT_EP*DXX(1) ) SKIP_FCT = 2 ! Pick next EP point +2*I_SGN
                     IEP=II; JEP=JJ+SKIP_FCT*I_SGN; KEP=KK
                  ENDIF
                  ! Add I,J,K locations of cells:
                  INDS(1:2,IAXIS) = (/0, 0/)
                  INDS(1:2,JAXIS) = (/0, 1/)
                  INDS(1:2,KAXIS) = (/0, 1/)

               CASE(JAXIS)
                  ! Define Face indexes and normal axis FAXIS.
                  SELECT CASE(ICD_SGN)
                     CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
                     CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=IAXIS
                     CASE( 1); IIF=II  ; JJF=JJ  ; KKF=KK+1; FAXIS=IAXIS
                     CASE( 2); IIF=II+1; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
                  END SELECT
                  DXX(1)  = DZ(KKF); DXX(2)  = DX(IIF)
                  SKIP_FCT = 1
                  IF (FAXIS==KAXIS) THEN
                     DEL_EP = DXX(2) - ABS(XB_IB)
                     IF( DEL_EP < THRES_FCT_EP*DXX(2) ) SKIP_FCT = 2 ! Pick next EP point +2*I_SGN
                     IEP=II+SKIP_FCT*I_SGN; JEP=JJ; KEP=KK
                  ELSE ! IF(FAXIS==IAXIS) THEN
                     DEL_EP = DXX(1) - ABS(XB_IB)
                     IF( DEL_EP < THRES_FCT_EP*DXX(1) ) SKIP_FCT = 2 ! Pick next EP point +2*I_SGN
                     IEP=II; JEP=JJ; KEP=KK+SKIP_FCT*I_SGN
                  ENDIF
                  ! Add I,J,K locations of cells:
                  INDS(1:2,IAXIS) = (/0, 1/)
                  INDS(1:2,JAXIS) = (/0, 0/)
                  INDS(1:2,KAXIS) = (/0, 1/)

               CASE(KAXIS)
                  ! Define Face indexes and normal axis FAXIS.
                  SELECT CASE(ICD_SGN)
                     CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=IAXIS
                     CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
                     CASE( 1); IIF=II+1; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
                     CASE( 2); IIF=II  ; JJF=JJ+1; KKF=KK  ; FAXIS=IAXIS
                  END SELECT
                  DXX(1)  = DX(IIF); DXX(2)  = DY(JJF)
                  SKIP_FCT = 1
                  IF (FAXIS==IAXIS) THEN
                     DEL_EP = DXX(2) - ABS(XB_IB)
                     IF( DEL_EP < THRES_FCT_EP*DXX(2) ) SKIP_FCT = 2 ! Pick next EP point +2*I_SGN
                     IEP=II; JEP=JJ+SKIP_FCT*I_SGN; KEP=KK
                  ELSE ! IF(FAXIS==JAXIS) THEN
                     DEL_EP = DXX(1) - ABS(XB_IB)
                     IF( DEL_EP < THRES_FCT_EP*DXX(1) ) SKIP_FCT = 2 ! Pick next EP point +2*I_SGN
                     IEP=II+SKIP_FCT*I_SGN; JEP=JJ; KEP=KK
                  ENDIF
                  ! Add I,J,K locations of cells:
                  INDS(1:2,IAXIS) = (/0, 1/)
                  INDS(1:2,JAXIS) = (/0, 1/)
                  INDS(1:2,KAXIS) = (/0, 0/)

            END SELECT

            ! ADD all
            VIND = 0; NPE_LIST_COUNT  = 0
            DO K=INDS(1,KAXIS),INDS(2,KAXIS)
               DO J=INDS(1,JAXIS),INDS(2,JAXIS)
                  DO I=INDS(1,IAXIS),INDS(2,IAXIS)
                     ! IF(CELL(CELL_INDEX(IEP+I,JEP+J,KEP+K))%SOLID) CYCLE ! Cycle solid cells. Can't use it here as is (overrun).
                     IF(CCVAR(IEP+I,JEP+J,KEP+K,CC_CGSC)==CC_SOLID) CYCLE
                     NPE_LIST_COUNT = NPE_LIST_COUNT + 1
                     INT_IJK(IAXIS:KAXIS,NPE_LIST_START+NPE_LIST_COUNT) = (/IEP+I,JEP+J,KEP+K/)
                  ENDDO
               ENDDO
            ENDDO
            ! Start position and number of points for cell centered vars related to EP edge of ICD_SGN orientation:
            INT_NPE(LOW_IND,VIND,EP,ICD_SGN)  = NPE_LIST_START
            INT_NPE(HIGH_IND,VIND,EP,ICD_SGN) = NPE_LIST_COUNT
            NPE_LIST_START = NPE_LIST_START + NPE_LIST_COUNT

         ENDDO SIGN_LOOP_2
      ENDDO ORIENTATION_LOOP_2
      ! Number of cell centered stencil points:
      N_CVAR_COUNT = NPE_LIST_START

      ! Now add Face Variables for the two directions normal to IEC:
      N_FVAR_START = N_CVAR_START + N_CVAR_COUNT
      ORIENTATION_LOOP_3: DO IS=1,3
         IF (IS==IEC) CYCLE ORIENTATION_LOOP_3
         SIGN_LOOP_3: DO I_SGN=-1,1,2
            IF (IS>IEC) ICD = IS-IEC
            IF (IS<IEC) ICD = IS-IEC+3
            ICD_SGN = I_SGN * ICD

            IF(.NOT.CC_IBEDGE(IEDGE)%PROCESS_EDGE_ORIENTATION(ICD_SGN)) CYCLE SIGN_LOOP_3
            IF(CC_IBEDGE(IEDGE)%EDGE_IN_MESH(ICD_SGN)) CYCLE SIGN_LOOP_3

            XB_IB = CC_IBEDGE(IEDGE)%XB_IB(ICD_SGN)

            SELECT CASE(IEC)
               CASE(IAXIS)
                  ! Define Face indexes and normal axis FAXIS.
                  SELECT CASE(ICD_SGN)
                     CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
                     CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
                     CASE( 1); IIF=II  ; JJF=JJ+1; KKF=KK  ; FAXIS=KAXIS
                     CASE( 2); IIF=II  ; JJF=JJ  ; KKF=KK+1; FAXIS=JAXIS
                  END SELECT
                  DXX(1)  = DY(JJF); DXX(2)  = DZ(KKF)
                  SKIP_FCT = 1
                  IF (FAXIS==JAXIS) THEN
                     DEL_EP = DXX(2) - ABS(XB_IB)
                     IF( DEL_EP < THRES_FCT_EP*DXX(2) ) SKIP_FCT = 2 ! Pick next EP point +2*I_SGN
                     IEP=II; JEP=JJ; KEP=KK+SKIP_FCT*I_SGN
                  ELSE ! IF(FAXIS==KAXIS) THEN
                     DEL_EP = DXX(1) - ABS(XB_IB)
                     IF( DEL_EP < THRES_FCT_EP*DXX(1) ) SKIP_FCT = 2 ! Pick next EP point +2*I_SGN
                     IEP=II; JEP=JJ+SKIP_FCT*I_SGN; KEP=KK
                  ENDIF

                  ! V velocities in EP for KEP,KEP+1:
                  VIND = JAXIS; NPE_LIST_COUNT = 0
                  DO K=0,1
                    NPE_LIST_COUNT = NPE_LIST_COUNT + 1
                    INT_IJK(IAXIS:KAXIS,NPE_LIST_START+NPE_LIST_COUNT) = (/IEP  ,JEP  ,KEP+K/)
                    INT_DCOEF(NPE_LIST_START+NPE_LIST_COUNT,1) = REAL(2*K-1,EB)/DXX(2)
                  ENDDO
                  INT_NPE(LOW_IND,VIND,EP,ICD_SGN)  = NPE_LIST_START
                  INT_NPE(HIGH_IND,VIND,EP,ICD_SGN) = NPE_LIST_COUNT
                  NPE_LIST_START                    = NPE_LIST_START + NPE_LIST_COUNT

                  ! W Velocities in EP for JEP,JEP+1:
                  VIND = KAXIS; NPE_LIST_COUNT = 0
                  DO J=0,1
                     NPE_LIST_COUNT = NPE_LIST_COUNT + 1
                     INT_IJK(IAXIS:KAXIS,NPE_LIST_START+NPE_LIST_COUNT) = (/IEP  ,JEP+J,KEP  /)
                     INT_DCOEF(NPE_LIST_START+NPE_LIST_COUNT,1) = REAL(2*J-1,EB)/DXX(1)
                  ENDDO
                  INT_NPE(LOW_IND,VIND,EP,ICD_SGN)  = NPE_LIST_START
                  INT_NPE(HIGH_IND,VIND,EP,ICD_SGN) = NPE_LIST_COUNT
                  NPE_LIST_START                    = NPE_LIST_START + NPE_LIST_COUNT

               CASE(JAXIS)
                  ! Define Face indexes and normal axis FAXIS.
                  SELECT CASE(ICD_SGN)
                     CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
                     CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=IAXIS
                     CASE( 1); IIF=II  ; JJF=JJ  ; KKF=KK+1; FAXIS=IAXIS
                     CASE( 2); IIF=II+1; JJF=JJ  ; KKF=KK  ; FAXIS=KAXIS
                  END SELECT
                  DXX(1)  = DZ(KKF); DXX(2)  = DX(IIF)
                  SKIP_FCT = 1
                  IF (FAXIS==KAXIS) THEN
                     DEL_EP = DXX(2) - ABS(XB_IB)
                     IF( DEL_EP < THRES_FCT_EP*DXX(2) ) SKIP_FCT = 2 ! Pick next EP point +2*I_SGN
                     IEP=II+SKIP_FCT*I_SGN; JEP=JJ; KEP=KK
                  ELSE ! IF(FAXIS==IAXIS) THEN
                     DEL_EP = DXX(1) - ABS(XB_IB)
                     IF( DEL_EP < THRES_FCT_EP*DXX(1) ) SKIP_FCT = 2 ! Pick next EP point +2*I_SGN
                     IEP=II; JEP=JJ; KEP=KK+SKIP_FCT*I_SGN
                  ENDIF

                  ! W Velocities in EP for IEP,IEP+1:
                  VIND = KAXIS; NPE_LIST_COUNT = 0
                  DO I=0,1
                     NPE_LIST_COUNT = NPE_LIST_COUNT + 1
                     INT_IJK(IAXIS:KAXIS,NPE_LIST_START+NPE_LIST_COUNT) = (/IEP+I,JEP  ,KEP  /)
                     INT_DCOEF(NPE_LIST_START+NPE_LIST_COUNT,1) = REAL(2*I-1,EB)/DXX(2)
                  ENDDO
                  INT_NPE(LOW_IND,VIND,EP,ICD_SGN)  = NPE_LIST_START
                  INT_NPE(HIGH_IND,VIND,EP,ICD_SGN) = NPE_LIST_COUNT
                  NPE_LIST_START                    = NPE_LIST_START + NPE_LIST_COUNT

                  ! U Velocities in EP for KEP,KEP+1:
                  VIND = IAXIS; NPE_LIST_COUNT = 0
                  DO K=0,1
                     NPE_LIST_COUNT = NPE_LIST_COUNT + 1
                     INT_IJK(IAXIS:KAXIS,NPE_LIST_START+NPE_LIST_COUNT) = (/IEP  ,JEP  ,KEP+K/)
                     INT_DCOEF(NPE_LIST_START+NPE_LIST_COUNT,1) = REAL(2*K-1,EB)/DXX(1)
                  ENDDO
                  INT_NPE(LOW_IND,VIND,EP,ICD_SGN)  = NPE_LIST_START
                  INT_NPE(HIGH_IND,VIND,EP,ICD_SGN) = NPE_LIST_COUNT
                  NPE_LIST_START                    = NPE_LIST_START + NPE_LIST_COUNT

               CASE(KAXIS)
                  ! Define Face indexes and normal axis FAXIS.
                  SELECT CASE(ICD_SGN)
                     CASE(-2); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=IAXIS
                     CASE(-1); IIF=II  ; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
                     CASE( 1); IIF=II+1; JJF=JJ  ; KKF=KK  ; FAXIS=JAXIS
                     CASE( 2); IIF=II  ; JJF=JJ+1; KKF=KK  ; FAXIS=IAXIS
                  END SELECT
                  DXX(1)  = DX(IIF); DXX(2)  = DY(JJF)
                  SKIP_FCT = 1
                  IF (FAXIS==IAXIS) THEN
                     DEL_EP = DXX(2) - ABS(XB_IB)
                     IF( DEL_EP < THRES_FCT_EP*DXX(2) ) SKIP_FCT = 2 ! Pick next EP point +2*I_SGN
                     IEP=II; JEP=JJ+SKIP_FCT*I_SGN; KEP=KK
                  ELSE ! IF(FAXIS==JAXIS) THEN
                     DEL_EP = DXX(1) - ABS(XB_IB)
                     IF( DEL_EP < THRES_FCT_EP*DXX(1) ) SKIP_FCT = 2 ! Pick next EP point +2*I_SGN
                     IEP=II+SKIP_FCT*I_SGN; JEP=JJ; KEP=KK
                  ENDIF

                  ! U Velocities in EP for JEP,JEP+1:
                  VIND = IAXIS; NPE_LIST_COUNT = 0
                  DO J=0,1
                     NPE_LIST_COUNT = NPE_LIST_COUNT + 1
                     INT_IJK(IAXIS:KAXIS,NPE_LIST_START+NPE_LIST_COUNT) = (/IEP  ,JEP+J,KEP  /)
                     INT_DCOEF(NPE_LIST_START+NPE_LIST_COUNT,1) = REAL(2*J-1,EB)/DXX(2)
                  ENDDO
                  INT_NPE(LOW_IND,VIND,EP,ICD_SGN)  = NPE_LIST_START
                  INT_NPE(HIGH_IND,VIND,EP,ICD_SGN) = NPE_LIST_COUNT
                  NPE_LIST_START                    = NPE_LIST_START + NPE_LIST_COUNT

                  ! V velocities in EP for IEP,IEP+1:
                  VIND = JAXIS; NPE_LIST_COUNT = 0
                  DO I=0,1
                    NPE_LIST_COUNT = NPE_LIST_COUNT + 1
                    INT_IJK(IAXIS:KAXIS,NPE_LIST_START+NPE_LIST_COUNT) = (/IEP+I,JEP  ,KEP  /)
                    INT_DCOEF(NPE_LIST_START+NPE_LIST_COUNT,1) = REAL(2*I-1,EB)/DXX(1)
                  ENDDO
                  INT_NPE(LOW_IND,VIND,EP,ICD_SGN)  = NPE_LIST_START
                  INT_NPE(HIGH_IND,VIND,EP,ICD_SGN) = NPE_LIST_COUNT
                  NPE_LIST_START                    = NPE_LIST_START + NPE_LIST_COUNT

            END SELECT

         ENDDO SIGN_LOOP_3
      ENDDO ORIENTATION_LOOP_3
      N_FVAR_COUNT = NPE_LIST_START - N_FVAR_START

      IF (NPE_LIST_START > 0) THEN
         ! Allocate INT_IJK, INT_CVARS, INT_FVARS:
         ALLOCATE(CC_IBEDGE(IEDGE)%INT_IJK(IAXIS:KAXIS,NPE_LIST_START))
         ALLOCATE(CC_IBEDGE(IEDGE)%INT_CVARS(1:N_INT_EP_CVARS,N_CVAR_START+1:N_CVAR_START+N_CVAR_COUNT))
         ALLOCATE(CC_IBEDGE(IEDGE)%INT_FVARS(1:N_INT_EP_FVARS,N_FVAR_START+1:N_FVAR_START+N_FVAR_COUNT))
         CC_IBEDGE(IEDGE)%INT_NPE(LOW_IND:HIGH_IND,0:KAXIS,1:INT_N_EXT_PTS,-2:2) = &
                           INT_NPE(LOW_IND:HIGH_IND,0:KAXIS,1:INT_N_EXT_PTS,-2:2)
         CC_IBEDGE(IEDGE)%INT_IJK(IAXIS:KAXIS,1:NPE_LIST_START) = INT_IJK(IAXIS:KAXIS,1:NPE_LIST_START)
         CC_IBEDGE(IEDGE)%INT_CVARS = 0._EB; CC_IBEDGE(IEDGE)%INT_FVARS = 0._EB
         ALLOCATE(CC_IBEDGE(IEDGE)%INT_NOMIND(LOW_IND:HIGH_IND,NPE_LIST_START)); CC_IBEDGE(IEDGE)%INT_NOMIND = CC_UNDEFINED
         ALLOCATE(CC_IBEDGE(IEDGE)%INT_DCOEF(NPE_LIST_START,1));
         CC_IBEDGE(IEDGE)%INT_DCOEF(1:NPE_LIST_START,1) = INT_DCOEF(1:NPE_LIST_START,1)
      ENDIF

      DEALLOCATE(INT_NPE,INT_IJK,INT_DCOEF)

   ENDDO IBEDGE_LOOP1

   ! Up to this point we have cut-cells, regular, immersed edges.
   ! 1. CUT_CELL
   ! 2. CC_RCEDGE
   ! 3. CC_IBEDGE

   DO NOM=1,NMESHES
      ! Also considers the case NOM==NM as a regular case.
      ! Face Variables:
      ALLOCATE(MESHES(NM)%OMESH(NOM)%IIO_FC_R(DELTA_FC))
      ALLOCATE(MESHES(NM)%OMESH(NOM)%JJO_FC_R(DELTA_FC))
      ALLOCATE(MESHES(NM)%OMESH(NOM)%KKO_FC_R(DELTA_FC))
      ALLOCATE(MESHES(NM)%OMESH(NOM)%AXS_FC_R(DELTA_FC))
      ! Cell Variables:
      ALLOCATE(MESHES(NM)%OMESH(NOM)%IIO_CC_R(DELTA_FC))
      ALLOCATE(MESHES(NM)%OMESH(NOM)%JJO_CC_R(DELTA_FC))
      ALLOCATE(MESHES(NM)%OMESH(NOM)%KKO_CC_R(DELTA_FC))
   ENDDO

   ! Figure out which Regular face locations for this mesh are required for interpolation:
   ALLOCATE(IJKFACE2(LOW_IND:HIGH_IND,ISTR:IEND,JSTR:JEND,KSTR:KEND,IAXIS:KAXIS)); IJKFACE2 = CC_UNDEFINED

   ! Figure out which other meshes this mesh will receive face centered variables from:
   ! 1. RCEDGES:
   DO IEDGE=1,MESHES(NM)%CC_NRCEDGE
      DO EP=1,INT_N_EXT_PTS  ! External point for IEDGE
         DO VIND=IAXIS,KAXIS ! Velocity component U, V or W for external point EP
            INT_NPE_LO = CC_RCEDGE(IEDGE)%INT_NPE(LOW_IND,VIND,EP,0)
            INT_NPE_HI = CC_RCEDGE(IEDGE)%INT_NPE(HIGH_IND,VIND,EP,0); IF (INT_NPE_HI<1) CYCLE
            X1AXIS = VIND
            ALLOCATE(EP_TAG(INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)); EP_TAG(:)=.FALSE.
            DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
               I = CC_RCEDGE(IEDGE)%INT_IJK(IAXIS,INPE)
               J = CC_RCEDGE(IEDGE)%INT_IJK(JAXIS,INPE)
               K = CC_RCEDGE(IEDGE)%INT_IJK(KAXIS,INPE)
               SELECT CASE(X1AXIS)
               CASE(IAXIS)
                  IF (IJKFACE2(LOW_IND,I,J,K,X1AXIS) < 1 ) THEN
                     FLGX = (I >= ILO_FACE) .AND. (I <= IHI_FACE)
                     FLGY = (J >= JLO_CELL) .AND. (J <= JHI_CELL)
                     FLGZ = (K >= KLO_CELL) .AND. (K <= KHI_CELL)
                     INNM = FLGX .AND. FLGY .AND. FLGZ
                     IF (INNM) THEN
                        NOM=NM; IIO=I; JJO=J; KKO=K
                     ELSE
                        CALL SEARCH_OTHER_MESHES_FACE(NM,X1AXIS,XFACE(I),YCELL(J),ZCELL(K),NOM,IIO,JJO,KKO)
                     ENDIF
                     IF(NOM==0) EP_TAG(INPE) = .TRUE.
                     CALL ASSIGN_TO_FC_R
                  ENDIF
               CASE(JAXIS)
                  IF (IJKFACE2(LOW_IND,I,J,K,X1AXIS) < 1 ) THEN
                     FLGX = (I >= ILO_CELL) .AND. (I <= IHI_CELL)
                     FLGY = (J >= JLO_FACE) .AND. (J <= JHI_FACE)
                     FLGZ = (K >= KLO_CELL) .AND. (K <= KHI_CELL)
                     INNM = FLGX .AND. FLGY .AND. FLGZ
                     IF (INNM) THEN
                        NOM=NM; IIO=I; JJO=J; KKO=K
                     ELSE
                        CALL SEARCH_OTHER_MESHES_FACE(NM,X1AXIS,XCELL(I),YFACE(J),ZCELL(K),NOM,IIO,JJO,KKO)
                     ENDIF
                     IF(NOM==0) EP_TAG(INPE) = .TRUE.
                     CALL ASSIGN_TO_FC_R
                  ENDIF
               CASE(KAXIS)
                  IF (IJKFACE2(LOW_IND,I,J,K,X1AXIS) < 1 ) THEN
                     FLGX = (I >= ILO_CELL) .AND. (I <= IHI_CELL)
                     FLGY = (J >= JLO_CELL) .AND. (J <= JHI_CELL)
                     FLGZ = (K >= KLO_FACE) .AND. (K <= KHI_FACE)
                     INNM = FLGX .AND. FLGY .AND. FLGZ
                     IF (INNM) THEN
                        NOM=NM; IIO=I; JJO=J; KKO=K
                     ELSE
                        CALL SEARCH_OTHER_MESHES_FACE(NM,X1AXIS,XCELL(I),YCELL(J),ZFACE(K),NOM,IIO,JJO,KKO)
                     ENDIF
                     IF(NOM==0) EP_TAG(INPE) = .TRUE.
                     CALL ASSIGN_TO_FC_R
                  ENDIF
               END SELECT
               CC_RCEDGE(IEDGE)%INT_NOMIND(LOW_IND:HIGH_IND,INPE) = IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS)
            ENDDO
            ! Now restrict count on cut-face :
            IF(ANY(EP_TAG .EQV. .TRUE.)) CALL RESTRICT_EP(CC_ETYPE_RCGAS)
            DEALLOCATE(EP_TAG)
            ! Compute derivative coefficients.
            CALL COMPUTE_DCOEF(CC_ETYPE_RCGAS)
         ENDDO
      ENDDO
   ENDDO
   ! 2. IBEDGES:
   DO IEDGE=1,MESHES(NM)%CC_NIBEDGE
      DO ICD_SGN=-2,2
         IF(ICD_SGN==0) CYCLE
         DO EP=1,INT_N_EXT_PTS  ! External point for IEDGE
            DO VIND=IAXIS,KAXIS ! Velocity component U, V or W for external point EP
               INT_NPE_HI = CC_IBEDGE(IEDGE)%INT_NPE(HIGH_IND,VIND,EP,ICD_SGN); IF (INT_NPE_HI<1) CYCLE
               INT_NPE_LO = CC_IBEDGE(IEDGE)%INT_NPE(LOW_IND,VIND,EP,ICD_SGN)
               X1AXIS = VIND
               ALLOCATE(EP_TAG(INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)); EP_TAG(:)=.FALSE.
               DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
                  I = CC_IBEDGE(IEDGE)%INT_IJK(IAXIS,INPE)
                  J = CC_IBEDGE(IEDGE)%INT_IJK(JAXIS,INPE)
                  K = CC_IBEDGE(IEDGE)%INT_IJK(KAXIS,INPE)
                  SELECT CASE(X1AXIS)
                  CASE(IAXIS)
                     IF (IJKFACE2(LOW_IND,I,J,K,X1AXIS) < 1 ) THEN
                        FLGX = (I >= ILO_FACE) .AND. (I <= IHI_FACE)
                        FLGY = (J >= JLO_CELL) .AND. (J <= JHI_CELL)
                        FLGZ = (K >= KLO_CELL) .AND. (K <= KHI_CELL)
                        INNM = FLGX .AND. FLGY .AND. FLGZ
                        IF (INNM) THEN
                           NOM=NM; IIO=I; JJO=J; KKO=K
                        ELSE
                           CALL SEARCH_OTHER_MESHES_FACE(NM,X1AXIS,XFACE(I),YCELL(J),ZCELL(K),NOM,IIO,JJO,KKO)
                        ENDIF
                        IF(NOM==0) EP_TAG(INPE) = .TRUE.
                        CALL ASSIGN_TO_FC_R
                     ENDIF
                  CASE(JAXIS)
                     IF (IJKFACE2(LOW_IND,I,J,K,X1AXIS) < 1 ) THEN
                        FLGX = (I >= ILO_CELL) .AND. (I <= IHI_CELL)
                        FLGY = (J >= JLO_FACE) .AND. (J <= JHI_FACE)
                        FLGZ = (K >= KLO_CELL) .AND. (K <= KHI_CELL)
                        INNM = FLGX .AND. FLGY .AND. FLGZ
                        IF (INNM) THEN
                           NOM=NM; IIO=I; JJO=J; KKO=K
                        ELSE
                           CALL SEARCH_OTHER_MESHES_FACE(NM,X1AXIS,XCELL(I),YFACE(J),ZCELL(K),NOM,IIO,JJO,KKO)
                        ENDIF
                        IF(NOM==0) EP_TAG(INPE) = .TRUE.
                        CALL ASSIGN_TO_FC_R
                     ENDIF
                  CASE(KAXIS)
                     IF (IJKFACE2(LOW_IND,I,J,K,X1AXIS) < 1 ) THEN
                        FLGX = (I >= ILO_CELL) .AND. (I <= IHI_CELL)
                        FLGY = (J >= JLO_CELL) .AND. (J <= JHI_CELL)
                        FLGZ = (K >= KLO_FACE) .AND. (K <= KHI_FACE)
                        INNM = FLGX .AND. FLGY .AND. FLGZ
                        IF (INNM) THEN
                           NOM=NM; IIO=I; JJO=J; KKO=K
                        ELSE
                           CALL SEARCH_OTHER_MESHES_FACE(NM,X1AXIS,XCELL(I),YCELL(J),ZFACE(K),NOM,IIO,JJO,KKO)
                        ENDIF
                        IF(NOM==0) EP_TAG(INPE) = .TRUE.
                        CALL ASSIGN_TO_FC_R
                     ENDIF
                  END SELECT
                  CC_IBEDGE(IEDGE)%INT_NOMIND(LOW_IND:HIGH_IND,INPE) = IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS)
               ENDDO
               ! Now restrict count on cut-face :
               IF(ANY(EP_TAG .EQV. .TRUE.)) CALL RESTRICT_EP(CC_ETYPE_EP)
               DEALLOCATE(EP_TAG)
            ENDDO
         ENDDO
      ENDDO
   ENDDO

   DEALLOCATE(IJKFACE2)

   ! Now Cell Variables:
   ALLOCATE(IJKCELL(LOW_IND:HIGH_IND,ISTR:IEND,JSTR:JEND,KSTR:KEND)); IJKCELL = CC_UNDEFINED

   ! 1. Cut-cells:
   VIND = 0
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      I = CUT_CELL(ICC)%IJK(IAXIS)
      J = CUT_CELL(ICC)%IJK(JAXIS)
      K = CUT_CELL(ICC)%IJK(KAXIS)
      ! Don't count cut-cells inside an OBST:
      IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
      DO ICELL=0,CUT_CELL(ICC)%NCELL
         DO EP=1,INT_N_EXT_PTS  ! External point for face IFACE
            INT_NPE_LO = CUT_CELL(ICC)%INT_NPE(LOW_IND,VIND,EP,ICELL)
            INT_NPE_HI = CUT_CELL(ICC)%INT_NPE(HIGH_IND,VIND,EP,ICELL)
            X1AXIS = VIND
            ALLOCATE(EP_TAG(INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)); EP_TAG(:)=.FALSE.
            DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
               I = CUT_CELL(ICC)%INT_IJK(IAXIS,INPE)
               J = CUT_CELL(ICC)%INT_IJK(JAXIS,INPE)
               K = CUT_CELL(ICC)%INT_IJK(KAXIS,INPE)
               ! If cell not counted yet:
               IF (IJKCELL(LOW_IND,I,J,K) < 1 ) THEN
                  FLGX = (I >= ILO_CELL) .AND. (I <= IHI_CELL)
                  FLGY = (J >= JLO_CELL) .AND. (J <= JHI_CELL)
                  FLGZ = (K >= KLO_CELL) .AND. (K <= KHI_CELL)
                  INNM = FLGX .AND. FLGY .AND. FLGZ
                  IF (INNM) THEN
                     NOM=NM; IIO=I; JJO=J; KKO=K
                  ELSE
                     CALL SEARCH_OTHER_MESHES(XCELL(I),YCELL(J),ZCELL(K),NOM,IIO,JJO,KKO)
                  ENDIF
                  IF(NOM==0) EP_TAG(INPE) = .TRUE.
                  CALL ASSIGN_TO_CC_R
               ENDIF
               CUT_CELL(ICC)%INT_NOMIND(LOW_IND:HIGH_IND,INPE) = IJKCELL(LOW_IND:HIGH_IND,I,J,K)
            ENDDO
            ! Now restrict count on cut-face :
            IF(ANY(EP_TAG .EQV. .TRUE.)) CALL RESTRICT_EP(CC_FTYPE_CCGAS)
            DEALLOCATE(EP_TAG)
         ENDDO
      ENDDO
   ENDDO

   ! 2. Cell-centered variables for IBEDGES:
   VIND = 0
   DO IEDGE=1,MESHES(NM)%CC_NIBEDGE
      DO ICD_SGN=-2,2
         IF(ICD_SGN==0) CYCLE
         DO EP=1,INT_N_EXT_PTS  ! External point for IEDGE
            INT_NPE_HI = CC_IBEDGE(IEDGE)%INT_NPE(HIGH_IND,VIND,EP,ICD_SGN); IF (INT_NPE_HI<1) CYCLE
            INT_NPE_LO = CC_IBEDGE(IEDGE)%INT_NPE(LOW_IND,VIND,EP,ICD_SGN)
            X1AXIS = VIND
            ALLOCATE(EP_TAG(INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)); EP_TAG(:)=.FALSE.
            DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
               I = CC_IBEDGE(IEDGE)%INT_IJK(IAXIS,INPE)
               J = CC_IBEDGE(IEDGE)%INT_IJK(JAXIS,INPE)
               K = CC_IBEDGE(IEDGE)%INT_IJK(KAXIS,INPE)
               ! If cell not counted yet:
               IF (IJKCELL(LOW_IND,I,J,K) < 1 ) THEN
                  FLGX = (I >= ILO_CELL) .AND. (I <= IHI_CELL)
                  FLGY = (J >= JLO_CELL) .AND. (J <= JHI_CELL)
                  FLGZ = (K >= KLO_CELL) .AND. (K <= KHI_CELL)
                  INNM = FLGX .AND. FLGY .AND. FLGZ
                  IF (INNM) THEN
                     NOM=NM; IIO=I; JJO=J; KKO=K
                  ELSE
                     CALL SEARCH_OTHER_MESHES(XCELL(I),YCELL(J),ZCELL(K),NOM,IIO,JJO,KKO)
                  ENDIF
                  IF(NOM==0) EP_TAG(INPE) = .TRUE.
                  CALL ASSIGN_TO_CC_R
               ENDIF
               CC_IBEDGE(IEDGE)%INT_NOMIND(LOW_IND:HIGH_IND,INPE) = IJKCELL(LOW_IND:HIGH_IND,I,J,K)
            ENDDO
            ! Now restrict count on cut-face :
            IF(ANY(EP_TAG .EQV. .TRUE.)) CALL RESTRICT_EP(CC_ETYPE_EP)
            DEALLOCATE(EP_TAG)
         ENDDO
      ENDDO
   ENDDO

   ! Add ghost-cells which are of type CC_CUTCFE or next to one cell type CC_CUTCFE:
   ! First record size of interpolation cells to be reveiced from OMESHES:
   DO NOM=1,NMESHES
      OMESH(NOM)%NCC_INT_R=OMESH(NOM)%NFCC_R(2)
   ENDDO
   ! Now loop INTERPOLATED WALL_CELLs:
   EXT_WALL_LOOP : DO IW=1,N_EXTERNAL_WALL_CELLS

      WC=>WALL(IW)
      EWC=>EXTERNAL_WALL(IW)
      IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE EXT_WALL_LOOP

      BC=>BOUNDARY_COORD(WC%BC_INDEX)
      II = BC%II
      JJ = BC%JJ
      KK = BC%KK
      NOM = EWC%NOM
      IF (NOM <= 0) CYCLE EXT_WALL_LOOP

      IF(ANY(CCVAR(II-1:II+1,JJ-1:JJ+1,KK-1:KK+1,CC_CGSC)==CC_CUTCFE)) THEN
         DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
            DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
               DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                OMESH(NOM)%NFCC_R(2)= OMESH(NOM)%NFCC_R(2) + 1
                SIZE_REC=SIZE(OMESH(NOM)%IIO_CC_R,DIM=1)
                IF(OMESH(NOM)%NFCC_R(2) > SIZE_REC) THEN
                    ALLOCATE(IIO_CC_R_AUX(SIZE_REC),JJO_CC_R_AUX(SIZE_REC),KKO_CC_R_AUX(SIZE_REC));
                    IIO_CC_R_AUX(1:SIZE_REC)=OMESH(NOM)%IIO_CC_R(1:SIZE_REC)
                    JJO_CC_R_AUX(1:SIZE_REC)=OMESH(NOM)%JJO_CC_R(1:SIZE_REC)
                    KKO_CC_R_AUX(1:SIZE_REC)=OMESH(NOM)%KKO_CC_R(1:SIZE_REC)
                    DEALLOCATE(OMESH(NOM)%IIO_CC_R); ALLOCATE(OMESH(NOM)%IIO_CC_R(SIZE_REC+DELTA_FC))
                    OMESH(NOM)%IIO_CC_R(1:SIZE_REC)=IIO_CC_R_AUX(1:SIZE_REC)
                    DEALLOCATE(OMESH(NOM)%JJO_CC_R); ALLOCATE(OMESH(NOM)%JJO_CC_R(SIZE_REC+DELTA_FC))
                    OMESH(NOM)%JJO_CC_R(1:SIZE_REC)=JJO_CC_R_AUX(1:SIZE_REC)
                    DEALLOCATE(OMESH(NOM)%KKO_CC_R); ALLOCATE(OMESH(NOM)%KKO_CC_R(SIZE_REC+DELTA_FC))
                    OMESH(NOM)%KKO_CC_R(1:SIZE_REC)=KKO_CC_R_AUX(1:SIZE_REC)
                    DEALLOCATE(IIO_CC_R_AUX,JJO_CC_R_AUX,KKO_CC_R_AUX)
                ENDIF
                OMESH(NOM)%IIO_CC_R(OMESH(NOM)%NFCC_R(2)) = IIO
                OMESH(NOM)%JJO_CC_R(OMESH(NOM)%NFCC_R(2)) = JJO
                OMESH(NOM)%KKO_CC_R(OMESH(NOM)%NFCC_R(2)) = KKO
               ENDDO
            ENDDO
         ENDDO
       ENDIF
   ENDDO EXT_WALL_LOOP
   DEALLOCATE(IJKCELL)

   ! WRITE(LU_ERR,*) ' MY_RANK,   NM,   NOM,   OMESH(NOM)%NFC_R,  OMESH(NOM)%NCC_R'
   ! DO NOM=1,NMESHES
   !    WRITE(LU_ERR,*) MY_RANK,NM,NOM,OMESH(NOM)%NFC_R,OMESH(NOM)%NCC_R
   ! ENDDO
   ! WRITE(LU_ERR,*) ' '

   ! Quality control:
   ! print*, 'MESHES(NM)%CC_NRCELL_H=',MESHES(NM)%CC_NRCELL_H
   ! IRC=176 ! Last entry for mesh 24x24x24 on sphre_air_demo_1.fds
   ! print*,' '
   ! print*,'RCELL=',IRC
   ! print*,'IJK=',MESHES(NM)%CC_RCELL_H(IRC)%IJK(IAXIS:KAXIS)
   ! print*,'NCCELL=',MESHES(NM)%CC_RCELL_H(IRC)%NCCELL
   ! print*,'CELL_LIST=',MESHES(NM)%CC_RCELL_H(IRC)%CELL_LIST(1:MESHES(NM)%CC_RCELL_H(IRC)%NCCELL)
   ! print*,'INBFC_CARTCEN(1:3)=',MESHES(NM)%CC_RCELL_H(IRC)%INBFC_CARTCEN(1:3)
   ! print*,'INTCOEF_CARTCEN(1:5)=',MESHES(NM)%CC_RCELL_H(IRC)%INTCOEF_CARTCEN(1:5)


   ! Deallocate arrays:
   ! Face centered positions and cell sizes:
   IF (ALLOCATED(XFACE)) DEALLOCATE(XFACE)
   IF (ALLOCATED(YFACE)) DEALLOCATE(YFACE)
   IF (ALLOCATED(ZFACE)) DEALLOCATE(ZFACE)
   IF (ALLOCATED(DXFACE)) DEALLOCATE(DXFACE)
   IF (ALLOCATED(DYFACE)) DEALLOCATE(DYFACE)
   IF (ALLOCATED(DZFACE)) DEALLOCATE(DZFACE)

   ! Cell centered positions and cell sizes:
   IF (ALLOCATED(XCELL)) DEALLOCATE(XCELL)
   IF (ALLOCATED(YCELL)) DEALLOCATE(YCELL)
   IF (ALLOCATED(ZCELL)) DEALLOCATE(ZCELL)
   IF (ALLOCATED(DXCELL)) DEALLOCATE(DXCELL)
   IF (ALLOCATED(DYCELL)) DEALLOCATE(DYCELL)
   IF (ALLOCATED(DZCELL)) DEALLOCATE(DZCELL)

ENDDO MESHES_LOOP

IF(GET_CUTCELLS_VERBOSE) THEN
   CALL CPU_TIME(CPUTIME)
   WRITE(LU_SETCC,'(A,F8.3,A)') ' done. Time taken : ',CPUTIME-CPUTIME_START_LOOP,' sec.'
   WRITE(LU_SETCC,'(A)') &
   ' - Into FILL_IJKO_INTERP_STENCILS MPI communication..'
   CALL CPU_TIME(CPUTIME_START_LOOP)
ENDIF

! Finally Exchange info on messages to send among MPI processes:
! Populates OMESH(NOM)% : NFCC_S, IIO_FCC_S, JJO_FCC_S, KKO_FCC_S, AXS_FCC_S
CALL FILL_IJKO_INTERP_STENCILS

! Fill unpacking arrays
CALL CC_EXCHANGE_UNPACKING_ARRAYS


IF(GET_CUTCELLS_VERBOSE) THEN
   CALL CPU_TIME(CPUTIME)
   WRITE(LU_SETCC,'(A,F8.3,A)') '   Done FILL_IJKO_INTERP_STENCILS. Time taken : ',CPUTIME-CPUTIME_START_LOOP,' sec.'
ENDIF

IF (DEBUG_CC_INTERPOLATION) THEN
   ! Write IBSEGS normals:
   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      WRITE(MSEGS_FILE,'(A,A,I4.4,A)') TRIM(CHID),'_ibsegns_mesh_',NM,'.dat'
      LU_DB_CCIB = GET_FILE_NUMBER()
      OPEN(LU_DB_CCIB,FILE=TRIM(MSEGS_FILE),STATUS='UNKNOWN')
      DO ECOUNT=1,MESHES(NM)%CC_NIBEDGE
         WRITE(LU_DB_CCIB,'(5F13.8)') 0.,0.,0.,0.,0.
      ENDDO
      CLOSE(LU_DB_CCIB)
   ENDDO
ENDIF

RETURN

CONTAINS

! ----------------------------- COMPUTE_DCOEF ----------------------------------

SUBROUTINE COMPUTE_DCOEF(DATA_IN)

INTEGER, INTENT(IN) :: DATA_IN

INTEGER, ALLOCATABLE, DIMENSION(:,:,:)   :: MASK_IJK
REAL(EB),ALLOCATABLE, DIMENSION(:,:,:)   :: N2
INTEGER  :: ILO,IHI,JLO,JHI,KLO,KHI
INTEGER  :: II,JJ,KK,DUMAXIS,COUNT,NEDGI
REAL(EB),ALLOCATABLE, DIMENSION(:,:,:,:) :: RAW_DCOEF
REAL(EB) :: XYZ_LOHI(LOW_IND:HIGH_IND,IAXIS:KAXIS),XYZE(IAXIS:KAXIS),X_P(IAXIS:KAXIS)
LOGICAL :: EVAL=.FALSE.

IF(DATA_IN==CC_ETYPE_RCGAS) THEN
   IF(ALLOCATED(CC_RCEDGE(IEDGE)%INT_DCOEF)) EVAL = .TRUE.
ELSE
   IF(ALLOCATED(CUT_FACE(ICF)%INT_DCOEF)) EVAL = .TRUE.
ENDIF

IF(EVAL) THEN
   IF(DATA_IN==CC_ETYPE_RCGAS) THEN
      NPE_COUNT = CC_RCEDGE(IEDGE)%INT_NPE(HIGH_IND,VIND,EP,0)
      IF(NPE_COUNT==0) RETURN
      ! Zero DCOEF if any of the box edges vertices is missing:
      ILO = MINVAL(CC_RCEDGE(IEDGE)%INT_IJK(IAXIS,INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT))
      IHI = MAXVAL(CC_RCEDGE(IEDGE)%INT_IJK(IAXIS,INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT))
      JLO = MINVAL(CC_RCEDGE(IEDGE)%INT_IJK(JAXIS,INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT))
      JHI = MAXVAL(CC_RCEDGE(IEDGE)%INT_IJK(JAXIS,INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT))
      KLO = MINVAL(CC_RCEDGE(IEDGE)%INT_IJK(KAXIS,INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT))
      KHI = MAXVAL(CC_RCEDGE(IEDGE)%INT_IJK(KAXIS,INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT))
   ELSEIF(DATA_IN==CC_ETYPE_SCINB) THEN
      NPE_COUNT = CC_IBEDGE(IEDGE)%INT_NPE(HIGH_IND,VIND,EP,0)
      IF(NPE_COUNT==0) RETURN
      ! Zero DCOEF if any of the box edges vertices is missing:
      ILO = MINVAL(CC_IBEDGE(IEDGE)%INT_IJK(IAXIS,INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT))
      IHI = MAXVAL(CC_IBEDGE(IEDGE)%INT_IJK(IAXIS,INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT))
      JLO = MINVAL(CC_IBEDGE(IEDGE)%INT_IJK(JAXIS,INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT))
      JHI = MAXVAL(CC_IBEDGE(IEDGE)%INT_IJK(JAXIS,INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT))
      KLO = MINVAL(CC_IBEDGE(IEDGE)%INT_IJK(KAXIS,INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT))
      KHI = MAXVAL(CC_IBEDGE(IEDGE)%INT_IJK(KAXIS,INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT))
   ELSE
      NPE_COUNT = CUT_FACE(ICF)%INT_NPE(HIGH_IND,VIND,EP,IFACE)
      IF(NPE_COUNT==0) RETURN
      ! Zero DCOEF if any of the box edges vertices is missing:
      ILO = MINVAL(CUT_FACE(ICF)%INT_IJK(IAXIS,INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT))
      IHI = MAXVAL(CUT_FACE(ICF)%INT_IJK(IAXIS,INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT))
      JLO = MINVAL(CUT_FACE(ICF)%INT_IJK(JAXIS,INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT))
      JHI = MAXVAL(CUT_FACE(ICF)%INT_IJK(JAXIS,INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT))
      KLO = MINVAL(CUT_FACE(ICF)%INT_IJK(KAXIS,INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT))
      KHI = MAXVAL(CUT_FACE(ICF)%INT_IJK(KAXIS,INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT))
   ENDIF

   ALLOCATE(INT_DCOEF(IAXIS:KAXIS,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI))
   INT_DCOEF = 0._EB
   ALLOCATE(MASK_IJK(ILO:IHI,JLO:JHI,KLO:KHI)); MASK_IJK = 0
   ALLOCATE(RAW_DCOEF(IAXIS:KAXIS,ILO:IHI,JLO:JHI,KLO:KHI)); RAW_DCOEF=0._EB;
   ALLOCATE(N2(ILO:IHI,JLO:JHI,KLO:KHI))

   IF(VIND==IAXIS) THEN
      XYZ_LOHI(LOW_IND:HIGH_IND,IAXIS) = (/ XFACE(ILO), XFACE(IHI) /)
   ELSE
      XYZ_LOHI(LOW_IND:HIGH_IND,IAXIS) = (/ XCELL(ILO), XCELL(IHI) /)
   ENDIF
   IF(VIND==JAXIS) THEN
      XYZ_LOHI(LOW_IND:HIGH_IND,JAXIS) = (/ YFACE(JLO), YFACE(JHI) /)
   ELSE
      XYZ_LOHI(LOW_IND:HIGH_IND,JAXIS) = (/ YCELL(JLO), YCELL(JHI) /)
   ENDIF
   IF(VIND==KAXIS) THEN
      XYZ_LOHI(LOW_IND:HIGH_IND,KAXIS) = (/ ZFACE(KLO), ZFACE(KHI) /)
   ELSE
      XYZ_LOHI(LOW_IND:HIGH_IND,KAXIS) = (/ ZCELL(KLO), ZCELL(KHI) /)
   ENDIF

   ! Define external point:
   IF(DATA_IN==CC_ETYPE_RCGAS) THEN
      XYZE(IAXIS:KAXIS) = CC_RCEDGE(IEDGE)%INT_XYZBF(IAXIS:KAXIS,0) + &
      CC_RCEDGE(IEDGE)%INT_XN(EP,0)*CC_RCEDGE(IEDGE)%INT_NOUT(IAXIS:KAXIS,0)
   ELSEIF(DATA_IN==CC_ETYPE_SCINB) THEN
      XYZE(IAXIS:KAXIS) = CC_IBEDGE(IEDGE)%INT_XYZBF(IAXIS:KAXIS,0) + &
      CC_IBEDGE(IEDGE)%INT_XN(EP,0)*CC_IBEDGE(IEDGE)%INT_NOUT(IAXIS:KAXIS,0)
   ELSE
      XYZE(IAXIS:KAXIS) = CUT_FACE(ICF)%INT_XYZBF(IAXIS:KAXIS,IFACE) + &
      CUT_FACE(ICF)%INT_XN(EP,IFACE)*CUT_FACE(ICF)%INT_NOUT(IAXIS:KAXIS,IFACE)
   ENDIF

   ! Masked Trilinear interpolation coefficients:
   X_P(IAXIS:KAXIS) = 0._EB
   DO DUMAXIS=IAXIS,KAXIS
      IF(ABS(XYZ_LOHI(HIGH_IND,DUMAXIS)-XYZ_LOHI(LOW_IND,DUMAXIS)) > TWO_EPSILON_EB) &
      X_P(DUMAXIS) = (XYZE(DUMAXIS)-XYZ_LOHI(LOW_IND,DUMAXIS)) / &
                     (XYZ_LOHI(HIGH_IND,DUMAXIS)-XYZ_LOHI(LOW_IND,DUMAXIS))
   ENDDO

   IF(DATA_IN==CC_ETYPE_RCGAS) THEN
      DO INPE=INT_NPE_LO+1,INT_NPE_LO+NPE_COUNT
      MASK_IJK(CC_RCEDGE(IEDGE)%INT_IJK(IAXIS,INPE),CC_RCEDGE(IEDGE)%INT_IJK(JAXIS,INPE),CC_RCEDGE(IEDGE)%INT_IJK(KAXIS,INPE))=1
      ENDDO
   ELSEIF(DATA_IN==CC_ETYPE_SCINB) THEN
      DO INPE=INT_NPE_LO+1,INT_NPE_LO+NPE_COUNT
      MASK_IJK(CC_IBEDGE(IEDGE)%INT_IJK(IAXIS,INPE),CC_IBEDGE(IEDGE)%INT_IJK(JAXIS,INPE),CC_IBEDGE(IEDGE)%INT_IJK(KAXIS,INPE))=1
      ENDDO
   ELSE
      DO INPE=INT_NPE_LO+1,INT_NPE_LO+NPE_COUNT
      MASK_IJK(CUT_FACE(ICF)%INT_IJK(IAXIS,INPE),CUT_FACE(ICF)%INT_IJK(JAXIS,INPE),CUT_FACE(ICF)%INT_IJK(KAXIS,INPE))=1
      ENDDO
   ENDIF

   ! d/dx : First look at which Points are present as both ends of X edges:
   NEDGI = 0
   DO KK = KLO,KHI
      DO JJ = JLO,JHI
         IF(MASK_IJK(ILO,JJ,KK) == 1 .AND. MASK_IJK(IHI,JJ,KK) == 1) THEN ! Both points on edge are populated:
            NEDGI = NEDGI + 1
            RAW_DCOEF(IAXIS,IHI,JJ,KK) = 1._EB/DXCELL(ILO)
            RAW_DCOEF(IAXIS,ILO,JJ,KK) =-1._EB/DXCELL(ILO)
         ENDIF
      ENDDO
   ENDDO
   ! Regarding the number of Edges interpolate:
   IF (NEDGI > 0 .AND. NEDGI < 4) THEN ! Simple average:
      DO KK = KLO,KHI
         DO JJ = JLO,JHI
            DO II = ILO,IHI
               RAW_DCOEF(IAXIS,II,JJ,KK) = RAW_DCOEF(IAXIS,II,JJ,KK)/REAL(NEDGI,EB)
            ENDDO
         ENDDO
      ENDDO
   ELSE ! Bilinear in y, z directions:
      N2(ILO:IHI,JLO,KLO) = (1._EB-X_P(JAXIS))*(1._EB-X_P(KAXIS))
      N2(ILO:IHI,JHI,KLO) = (      X_P(JAXIS))*(1._EB-X_P(KAXIS))
      N2(ILO:IHI,JLO,KHI) = (1._EB-X_P(JAXIS))*(      X_P(KAXIS))
      N2(ILO:IHI,JHI,KHI) = (      X_P(JAXIS))*(      X_P(KAXIS))
      DO KK = KLO,KHI
         DO JJ = JLO,JHI
            DO II = ILO,IHI
               RAW_DCOEF(IAXIS,II,JJ,KK) = N2(II,JJ,KK)*RAW_DCOEF(IAXIS,II,JJ,KK)
            ENDDO
         ENDDO
      ENDDO
   ENDIF
   ! d/dy : First look at which Points are present as both ends of Y edges:
   NEDGI = 0
   DO KK = KLO,KHI
      DO II = ILO,IHI
         IF(MASK_IJK(II,JLO,KK) == 1 .AND. MASK_IJK(II,JHI,KK) == 1) THEN ! Both points on edge are populated:
            NEDGI = NEDGI + 1
            RAW_DCOEF(JAXIS,II,JHI,KK) = 1._EB/DYCELL(JLO)
            RAW_DCOEF(JAXIS,II,JLO,KK) =-1._EB/DYCELL(JLO)
         ENDIF
      ENDDO
   ENDDO
   ! Regarding the number of Edges interpolate:
   IF (NEDGI > 0 .AND. NEDGI < 4) THEN ! Simple average:
      DO KK = KLO,KHI
         DO JJ = JLO,JHI
            DO II = ILO,IHI
               RAW_DCOEF(JAXIS,II,JJ,KK) = RAW_DCOEF(JAXIS,II,JJ,KK)/REAL(NEDGI,EB)
            ENDDO
         ENDDO
      ENDDO
   ELSE ! Bilinear in x, z directions:
      N2(ILO,JLO:JHI,KLO) = (1._EB-X_P(IAXIS))*(1._EB-X_P(KAXIS))
      N2(IHI,JLO:JHI,KLO) = (      X_P(IAXIS))*(1._EB-X_P(KAXIS))
      N2(ILO,JLO:JHI,KHI) = (1._EB-X_P(IAXIS))*(      X_P(KAXIS))
      N2(IHI,JLO:JHI,KHI) = (      X_P(IAXIS))*(      X_P(KAXIS))
      DO KK = KLO,KHI
         DO JJ = JLO,JHI
            DO II = ILO,IHI
               RAW_DCOEF(JAXIS,II,JJ,KK) = N2(II,JJ,KK)*RAW_DCOEF(JAXIS,II,JJ,KK)
            ENDDO
         ENDDO
      ENDDO
   ENDIF
   ! d/dz : First look at which Points are present as both ends of Z edges:
   NEDGI = 0
   DO JJ = JLO,JHI
      DO II = ILO,IHI
         IF(MASK_IJK(II,JJ,KLO) == 1 .AND. MASK_IJK(II,JJ,KHI) == 1) THEN ! Both points on edge are populated:
            NEDGI = NEDGI + 1
            RAW_DCOEF(KAXIS,II,JJ,KHI) = 1._EB/DZCELL(KLO)
            RAW_DCOEF(KAXIS,II,JJ,KLO) =-1._EB/DZCELL(KLO)
         ENDIF
      ENDDO
   ENDDO
   ! Regarding the number of Edges interpolate:
   IF (NEDGI > 0 .AND. NEDGI < 4) THEN ! Simple average:
      DO KK = KLO,KHI
         DO JJ = JLO,JHI
            DO II = ILO,IHI
               RAW_DCOEF(KAXIS,II,JJ,KK) = RAW_DCOEF(KAXIS,II,JJ,KK)/REAL(NEDGI,EB)
            ENDDO
         ENDDO
      ENDDO
   ELSE ! Bilinear in x, y directions:
      N2(ILO,JLO,KLO:KHI) = (1._EB-X_P(IAXIS))*(1._EB-X_P(JAXIS))
      N2(IHI,JLO,KLO:KHI) = (      X_P(IAXIS))*(1._EB-X_P(JAXIS))
      N2(ILO,JHI,KLO:KHI) = (1._EB-X_P(IAXIS))*(      X_P(JAXIS))
      N2(IHI,JHI,KLO:KHI) = (      X_P(IAXIS))*(      X_P(JAXIS))
      DO KK = KLO,KHI
         DO JJ = JLO,JHI
            DO II = ILO,IHI
               RAW_DCOEF(KAXIS,II,JJ,KK) = N2(II,JJ,KK)*RAW_DCOEF(KAXIS,II,JJ,KK)
            ENDDO
         ENDDO
      ENDDO
   ENDIF
   ! Finally populate INT_DCOEF:
   COUNT = 0
   DO KK = KLO,KHI
      DO JJ = JLO,JHI
         DO II = ILO,IHI
            IF(MASK_IJK(II,JJ,KK) == 1) THEN
               COUNT = COUNT + 1
               INT_DCOEF(IAXIS:KAXIS,INT_NPE_LO+COUNT) = RAW_DCOEF(IAXIS:KAXIS,II,JJ,KK)
            ENDIF
         ENDDO
      ENDDO
   ENDDO
   IF(DATA_IN==CC_ETYPE_RCGAS) THEN
      CC_RCEDGE(IEDGE)%INT_DCOEF(IAXIS:KAXIS,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI) = &
      INT_DCOEF(IAXIS:KAXIS,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)
   ELSEIF(DATA_IN==CC_ETYPE_SCINB) THEN
      CC_IBEDGE(IEDGE)%INT_DCOEF(IAXIS:KAXIS,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI) = &
      INT_DCOEF(IAXIS:KAXIS,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)
   ELSE
      CUT_FACE(ICF)%INT_DCOEF(IAXIS:KAXIS,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI) = &
      INT_DCOEF(IAXIS:KAXIS,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)
   ENDIF
   DEALLOCATE(INT_DCOEF,MASK_IJK,N2,RAW_DCOEF)
ENDIF

RETURN
END SUBROUTINE COMPUTE_DCOEF

! ------------------------------ RESTRICT_EP ----------------------------------

SUBROUTINE RESTRICT_EP(CFRC_FLG)

INTEGER, INTENT(IN) :: CFRC_FLG

REAL(EB):: PROD_COEF

! Apply restriction to stencil points with NOM>0:
ALLOCATE(INT_IJK(IAXIS:KAXIS,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI),   &
         INT_COEF(INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI),              &
         INT_NOMIND(LOW_IND:HIGH_IND,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI))
INT_IJK = CC_UNDEFINED; INT_COEF = 0._EB; INT_NOMIND = CC_UNDEFINED
NPE_COUNT = 0
PROD_COEF= 0._EB
SELECT CASE(CFRC_FLG)
CASE(CC_FTYPE_CFGAS,CC_FTYPE_CFINB)
   DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
      IF(.NOT.EP_TAG(INPE)) THEN ! Point has a NOM /= 0
         NPE_COUNT = NPE_COUNT + 1
         INT_IJK(IAXIS:KAXIS,INT_NPE_LO+NPE_COUNT) = CUT_FACE(ICF)%INT_IJK(IAXIS:KAXIS,INPE)
         INT_COEF(INT_NPE_LO+NPE_COUNT) = CUT_FACE(ICF)%INT_COEF(INPE)
         PROD_COEF = PROD_COEF + INT_COEF(INT_NPE_LO+NPE_COUNT)
         INT_NOMIND(LOW_IND:HIGH_IND,INT_NPE_LO+NPE_COUNT) = &
         CUT_FACE(ICF)%INT_NOMIND(LOW_IND:HIGH_IND,INPE)
      ENDIF
   ENDDO
   IF (ABS(PROD_COEF) < TWO_EPSILON_EB) THEN ! Any viable points throught EP_TAG have been discarded by IJKFACE2.
      INT_IJK=CC_UNDEFINED; INT_COEF=0._EB; INT_NOMIND=CC_UNDEFINED; NPE_COUNT=0
   ENDIF
   CUT_FACE(ICF)%INT_IJK(IAXIS:KAXIS,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI) = &
   INT_IJK(IAXIS:KAXIS,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)
   CUT_FACE(ICF)%INT_NOMIND(LOW_IND:HIGH_IND,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI) = &
   INT_NOMIND(LOW_IND:HIGH_IND,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)
   CUT_FACE(ICF)%INT_NPE(HIGH_IND,VIND,EP,IFACE) = NPE_COUNT

   IF (NPE_COUNT > 0) &
   INT_COEF(INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT) = INT_COEF(INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT)/PROD_COEF

   CUT_FACE(ICF)%INT_COEF(INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI) = &
   INT_COEF(INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)

CASE(CC_ETYPE_RCGAS)
   DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
      IF(.NOT.EP_TAG(INPE)) THEN ! Point has a NOM /= 0
         NPE_COUNT = NPE_COUNT + 1
         INT_IJK(IAXIS:KAXIS,INT_NPE_LO+NPE_COUNT) = CC_RCEDGE(IEDGE)%INT_IJK(IAXIS:KAXIS,INPE)
         INT_COEF(INT_NPE_LO+NPE_COUNT) = CC_RCEDGE(IEDGE)%INT_COEF(INPE)
         PROD_COEF = PROD_COEF + INT_COEF(INT_NPE_LO+NPE_COUNT)
         INT_NOMIND(LOW_IND:HIGH_IND,INT_NPE_LO+NPE_COUNT) = &
         CC_RCEDGE(IEDGE)%INT_NOMIND(LOW_IND:HIGH_IND,INPE)
      ENDIF
   ENDDO
   IF (ABS(PROD_COEF) < TWO_EPSILON_EB) THEN ! Any viable points throught EP_TAG have been discarded by IJKFACE2.
      INT_IJK=CC_UNDEFINED; INT_COEF=0._EB; INT_NOMIND=CC_UNDEFINED; NPE_COUNT=0
   ENDIF
   CC_RCEDGE(IEDGE)%INT_IJK(IAXIS:KAXIS,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI) = &
   INT_IJK(IAXIS:KAXIS,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)
   CC_RCEDGE(IEDGE)%INT_NOMIND(LOW_IND:HIGH_IND,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI) = &
   INT_NOMIND(LOW_IND:HIGH_IND,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)
   CC_RCEDGE(IEDGE)%INT_NPE(HIGH_IND,VIND,EP,0) = NPE_COUNT

   IF (NPE_COUNT > 0) &
   INT_COEF(INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT) = INT_COEF(INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT)/PROD_COEF

   CC_RCEDGE(IEDGE)%INT_COEF(INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI) = &
   INT_COEF(INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)

CASE(CC_ETYPE_SCINB)
   DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
      IF(.NOT.EP_TAG(INPE)) THEN ! Point has a NOM /= 0
         NPE_COUNT = NPE_COUNT + 1
         INT_IJK(IAXIS:KAXIS,INT_NPE_LO+NPE_COUNT) = CC_IBEDGE(IEDGE)%INT_IJK(IAXIS:KAXIS,INPE)
         INT_COEF(INT_NPE_LO+NPE_COUNT) = CC_IBEDGE(IEDGE)%INT_COEF(INPE)
         PROD_COEF = PROD_COEF + INT_COEF(INT_NPE_LO+NPE_COUNT)
         INT_NOMIND(LOW_IND:HIGH_IND,INT_NPE_LO+NPE_COUNT) = &
         CC_IBEDGE(IEDGE)%INT_NOMIND(LOW_IND:HIGH_IND,INPE)
      ENDIF
   ENDDO
   IF (ABS(PROD_COEF) < TWO_EPSILON_EB) THEN ! Any viable points throught EP_TAG have been discarded by IJKFACE2.
      INT_IJK=CC_UNDEFINED; INT_COEF=0._EB; INT_NOMIND=CC_UNDEFINED; NPE_COUNT=0
   ENDIF
   CC_IBEDGE(IEDGE)%INT_IJK(IAXIS:KAXIS,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI) = &
   INT_IJK(IAXIS:KAXIS,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)
   CC_IBEDGE(IEDGE)%INT_NOMIND(LOW_IND:HIGH_IND,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI) = &
   INT_NOMIND(LOW_IND:HIGH_IND,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)
   CC_IBEDGE(IEDGE)%INT_NPE(HIGH_IND,VIND,EP,0) = NPE_COUNT

   IF (NPE_COUNT > 0) &
   INT_COEF(INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT) = INT_COEF(INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT)/PROD_COEF

   CC_IBEDGE(IEDGE)%INT_COEF(INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI) = &
   INT_COEF(INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)

CASE(CC_ETYPE_EP)
   DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
      IF(.NOT.EP_TAG(INPE)) THEN ! Point has a NOM /= 0
         NPE_COUNT = NPE_COUNT + 1
         INT_IJK(IAXIS:KAXIS,INT_NPE_LO+NPE_COUNT) = CC_IBEDGE(IEDGE)%INT_IJK(IAXIS:KAXIS,INPE)
         INT_NOMIND(LOW_IND:HIGH_IND,INT_NPE_LO+NPE_COUNT) = &
         CC_IBEDGE(IEDGE)%INT_NOMIND(LOW_IND:HIGH_IND,INPE)
         INT_COEF(INT_NPE_LO+NPE_COUNT) = CC_IBEDGE(IEDGE)%INT_DCOEF(INPE,1)
      ENDIF
   ENDDO
   CC_IBEDGE(IEDGE)%INT_IJK(IAXIS:KAXIS,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI) = &
   INT_IJK(IAXIS:KAXIS,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)
   CC_IBEDGE(IEDGE)%INT_NOMIND(LOW_IND:HIGH_IND,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI) = &
   INT_NOMIND(LOW_IND:HIGH_IND,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)
   CC_IBEDGE(IEDGE)%INT_DCOEF(INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI,1) = INT_COEF(INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)
   CC_IBEDGE(IEDGE)%INT_NPE(HIGH_IND,VIND,EP,ICD_SGN) = NPE_COUNT

CASE(CC_FTYPE_RCGAS) ! Skip.
CASE(CC_FTYPE_CCGAS)
   DO INPE=INT_NPE_LO+1,INT_NPE_LO+INT_NPE_HI
      IF(.NOT.EP_TAG(INPE)) THEN ! Point has a NOM /= 0
         NPE_COUNT = NPE_COUNT + 1
         INT_IJK(IAXIS:KAXIS,INT_NPE_LO+NPE_COUNT) = CUT_CELL(ICC)%INT_IJK(IAXIS:KAXIS,INPE)
         INT_COEF(INT_NPE_LO+NPE_COUNT) = CUT_CELL(ICC)%INT_COEF(INPE)
         PROD_COEF = PROD_COEF + INT_COEF(INT_NPE_LO+NPE_COUNT)
         INT_NOMIND(LOW_IND:HIGH_IND,INT_NPE_LO+NPE_COUNT) = &
         CUT_CELL(ICC)%INT_NOMIND(LOW_IND:HIGH_IND,INPE)
      ENDIF
   ENDDO
   IF (ABS(PROD_COEF) < TWO_EPSILON_EB) THEN ! Any viable points throught EP_TAG have been discarded by IJKCELL.
      INT_IJK=CC_UNDEFINED; INT_COEF=0._EB; INT_NOMIND=CC_UNDEFINED; NPE_COUNT=0
   ENDIF
   CUT_CELL(ICC)%INT_IJK(IAXIS:KAXIS,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI) = &
   INT_IJK(IAXIS:KAXIS,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)
   CUT_CELL(ICC)%INT_NOMIND(LOW_IND:HIGH_IND,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI) = &
   INT_NOMIND(LOW_IND:HIGH_IND,INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)
   CUT_CELL(ICC)%INT_NPE(HIGH_IND,VIND,EP,ICELL) = NPE_COUNT

   IF (NPE_COUNT > 0) &
   INT_COEF(INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT) = INT_COEF(INT_NPE_LO+1:INT_NPE_LO+NPE_COUNT)/PROD_COEF

   CUT_CELL(ICC)%INT_COEF(INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI) = &
   INT_COEF(INT_NPE_LO+1:INT_NPE_LO+INT_NPE_HI)

END SELECT

DEALLOCATE(INT_IJK,INT_NOMIND,INT_COEF)

RETURN
END SUBROUTINE RESTRICT_EP

! ------------------------------- GET_DELN ------------------------------------

SUBROUTINE GET_DELN(FCTN_IN,DELN,DXLOC,DYLOC,DZLOC,NVEC,CLOSE_PT)

REAL(EB), INTENT(IN) :: FCTN_IN,DXLOC,DYLOC,DZLOC
REAL(EB), OPTIONAL, INTENT(IN) :: NVEC(MAX_DIM)
LOGICAL, OPTIONAL, INTENT(IN) :: CLOSE_PT
REAL(EB), INTENT(OUT) :: DELN

! Local Variables:
REAL(EB) :: FCTN
FCTN = FCTN_IN
IF (PRESENT(NVEC)) THEN
   IF( .NOT.PRESENT(CLOSE_PT) .AND. (ABS(NVEC(IAXIS))>GEOMEPS) .AND. &
   (ABS(NVEC(JAXIS))>GEOMEPS) .AND. (ABS(NVEC(KAXIS))>GEOMEPS)) FCTN=SQRT(3._EB)
   ! IF(PRESENT(CLOSE_PT)) THEN
   !    IF(CLOSE_PT) FCTN = 1._EB
   ! ENDIF
   DELN = FCTN*(DXLOC*ABS(NVEC(IAXIS))+DYLOC*ABS(NVEC(JAXIS))+DZLOC*ABS(NVEC(KAXIS)))
ELSE
   DELN = SQRT(DXLOC**2._EB+DYLOC**2._EB+DZLOC**2._EB)
ENDIF
RETURN
END SUBROUTINE GET_DELN

! ---------------------------- ASSIGN_TO_CC_R ---------------------------------

SUBROUTINE ASSIGN_TO_CC_R

 IF (NOM > 0) THEN ! Add to IIO_FC_R,JJO_FC_R,KKO_FC_R,AXIS_FC_R list,
                   ! and add 1 to NFC_R for OMESH(NOM).
    ! Use Automatic reallocation:
    OMESH(NOM)%NFCC_R(2)= OMESH(NOM)%NFCC_R(2) + 1
    SIZE_REC=SIZE(OMESH(NOM)%IIO_CC_R,DIM=1)
    IF(OMESH(NOM)%NFCC_R(2) > SIZE_REC) THEN
        ALLOCATE(IIO_CC_R_AUX(SIZE_REC),JJO_CC_R_AUX(SIZE_REC),KKO_CC_R_AUX(SIZE_REC));
        IIO_CC_R_AUX(1:SIZE_REC)=OMESH(NOM)%IIO_CC_R(1:SIZE_REC)
        JJO_CC_R_AUX(1:SIZE_REC)=OMESH(NOM)%JJO_CC_R(1:SIZE_REC)
        KKO_CC_R_AUX(1:SIZE_REC)=OMESH(NOM)%KKO_CC_R(1:SIZE_REC)
        DEALLOCATE(OMESH(NOM)%IIO_CC_R); ALLOCATE(OMESH(NOM)%IIO_CC_R(SIZE_REC+DELTA_FC))
        OMESH(NOM)%IIO_CC_R(1:SIZE_REC)=IIO_CC_R_AUX(1:SIZE_REC)
        DEALLOCATE(OMESH(NOM)%JJO_CC_R); ALLOCATE(OMESH(NOM)%JJO_CC_R(SIZE_REC+DELTA_FC))
        OMESH(NOM)%JJO_CC_R(1:SIZE_REC)=JJO_CC_R_AUX(1:SIZE_REC)
        DEALLOCATE(OMESH(NOM)%KKO_CC_R); ALLOCATE(OMESH(NOM)%KKO_CC_R(SIZE_REC+DELTA_FC))
        OMESH(NOM)%KKO_CC_R(1:SIZE_REC)=KKO_CC_R_AUX(1:SIZE_REC)
        DEALLOCATE(IIO_CC_R_AUX,JJO_CC_R_AUX,KKO_CC_R_AUX)
    ENDIF
    OMESH(NOM)%IIO_CC_R(OMESH(NOM)%NFCC_R(2)) = IIO
    OMESH(NOM)%JJO_CC_R(OMESH(NOM)%NFCC_R(2)) = JJO
    OMESH(NOM)%KKO_CC_R(OMESH(NOM)%NFCC_R(2)) = KKO
    IJKCELL(LOW_IND:HIGH_IND,I,J,K) = (/ NOM, OMESH(NOM)%NFCC_R(2) /)
 ENDIF

RETURN
END SUBROUTINE ASSIGN_TO_CC_R

! ---------------------------- ASSIGN_TO_FC_R ---------------------------------

SUBROUTINE ASSIGN_TO_FC_R

IF (NOM > 0) THEN
   ! Use Automatic reallocation:
   OMESH(NOM)%NFCC_R(1)= OMESH(NOM)%NFCC_R(1) + 1
   SIZE_REC=SIZE(OMESH(NOM)%IIO_FC_R,DIM=1)
   IF(OMESH(NOM)%NFCC_R(1) > SIZE_REC) THEN
       ALLOCATE(IIO_FC_R_AUX(SIZE_REC),JJO_FC_R_AUX(SIZE_REC),KKO_FC_R_AUX(SIZE_REC));
       ALLOCATE(AXS_FC_R_AUX(SIZE_REC))
       IIO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%IIO_FC_R(1:SIZE_REC)
       JJO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%JJO_FC_R(1:SIZE_REC)
       KKO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%KKO_FC_R(1:SIZE_REC)
       AXS_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%AXS_FC_R(1:SIZE_REC)
       DEALLOCATE(OMESH(NOM)%IIO_FC_R); ALLOCATE(OMESH(NOM)%IIO_FC_R(SIZE_REC+DELTA_FC))
       OMESH(NOM)%IIO_FC_R(1:SIZE_REC)=IIO_FC_R_AUX(1:SIZE_REC)
       DEALLOCATE(OMESH(NOM)%JJO_FC_R); ALLOCATE(OMESH(NOM)%JJO_FC_R(SIZE_REC+DELTA_FC))
       OMESH(NOM)%JJO_FC_R(1:SIZE_REC)=JJO_FC_R_AUX(1:SIZE_REC)
       DEALLOCATE(OMESH(NOM)%KKO_FC_R); ALLOCATE(OMESH(NOM)%KKO_FC_R(SIZE_REC+DELTA_FC))
       OMESH(NOM)%KKO_FC_R(1:SIZE_REC)=KKO_FC_R_AUX(1:SIZE_REC)
       DEALLOCATE(OMESH(NOM)%AXS_FC_R); ALLOCATE(OMESH(NOM)%AXS_FC_R(SIZE_REC+DELTA_FC))
       OMESH(NOM)%AXS_FC_R(1:SIZE_REC)=AXS_FC_R_AUX(1:SIZE_REC)
       DEALLOCATE(IIO_FC_R_AUX,JJO_FC_R_AUX,KKO_FC_R_AUX,AXS_FC_R_AUX)
   ENDIF
   OMESH(NOM)%IIO_FC_R(OMESH(NOM)%NFCC_R(1)) = IIO
   OMESH(NOM)%JJO_FC_R(OMESH(NOM)%NFCC_R(1)) = JJO
   OMESH(NOM)%KKO_FC_R(OMESH(NOM)%NFCC_R(1)) = KKO
   OMESH(NOM)%AXS_FC_R(OMESH(NOM)%NFCC_R(1)) = X1AXIS
   IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS) = (/ NOM, OMESH(NOM)%NFCC_R(1) /)
ENDIF

RETURN
END SUBROUTINE ASSIGN_TO_FC_R

! ---------------------------- GET_INTSTENCILS_EP -------------------------------

SUBROUTINE GET_INTSTENCILS_EP(MASK_FLG,VIND,XYZ_PP,INTXN,NVEC,NPE_LIST_START,NPE_LIST_COUNT,&
INT_IJK,INT_COEF)

! This routine provides a set of interpolation points for an external normal point EP,
! located at position XYZE(IAXIS:KAXIS) = XYZ_PP(IAXIS:KAXIS) + INTXN*NVEC(IAXIS:KAXIS):
! The points will be face centered when:
!     VIND = IAXIS => X faces
!            JAXIS => Y faces
!            KAXIS => Z faces
! And cell centered when VIND = 0.
! The number of interpolation points is provided in variable NPE_LIST_COUNT.
! The IJK indexes on mesh of these points is defined in:
! INT_IJK(IAXIS:KAXIS,NPE_LIST_START+1:NPE_LIST_START+NPE_LIST_COUNT)
! INT_COEF(NPE_LIST_START+1:NPE_LIST_START+NPE_LIST_COUNT)

LOGICAL, INTENT(IN) :: MASK_FLG
INTEGER, INTENT(IN) :: VIND,NPE_LIST_START
INTEGER, INTENT(OUT):: NPE_LIST_COUNT
REAL(EB),INTENT(IN) :: XYZ_PP(IAXIS:KAXIS), NVEC(IAXIS:KAXIS), INTXN
INTEGER, INTENT(INOUT), ALLOCATABLE, DIMENSION(:,:) :: INT_IJK
REAL(EB), INTENT(INOUT),ALLOCATABLE, DIMENSION(:)   :: INT_COEF


! Local variables:
REAL(EB) :: XYZE(IAXIS:KAXIS)
LOGICAL  :: IS_FACE_X,IS_FACE_Y,IS_FACE_Z
INTEGER  :: INDX,INDY,INDZ,DIM_NPE,ILO,IHI,JLO,JHI,KLO,KHI,ILO_2,IHI_2,JLO_2,JHI_2,KLO_2,KHI_2
INTEGER  :: II,JJ,KK,DUMAXIS,COUNT
INTEGER, ALLOCATABLE, DIMENSION(:,:,:) :: MASK_IJK
REAL(EB),ALLOCATABLE, DIMENSION(:,:,:) :: RAW_COEF
REAL(EB) :: XYZ_LOHI(LOW_IND:HIGH_IND,IAXIS:KAXIS),X_P(IAXIS:KAXIS),RED_COEF

LOGICAL, PARAMETER :: DO_TRILINEAR = .TRUE.

! Default number of interpolation stencil points:
NPE_LIST_COUNT = 0

! Define external point:
XYZE(IAXIS:KAXIS) = XYZ_PP(IAXIS:KAXIS) + INTXN*NVEC(IAXIS:KAXIS)

! Find closest point on mesh NM to point:
IS_FACE_X=.FALSE.;IS_FACE_Y=.FALSE.;IS_FACE_Z=.FALSE.
IF(VIND==IAXIS) IS_FACE_X=.TRUE.
IF(VIND==JAXIS) IS_FACE_Y=.TRUE.
IF(VIND==KAXIS) IS_FACE_Z=.TRUE.
CALL GET_X_IND(XYZE,IS_FACE_X,INDX)
CALL GET_Y_IND(XYZE,IS_FACE_Y,INDY)
CALL GET_Z_IND(XYZE,IS_FACE_Z,INDZ)

IF(INDX == INDEX_UNDEFINED) RETURN
IF(INDY == INDEX_UNDEFINED) RETURN
IF(INDZ == INDEX_UNDEFINED) RETURN

! Define stencil points:
DIM_NPE = SIZE(INT_IJK, DIM=2)
IF(NPE_LIST_START+MAX_INTERP_POINTS > DIM_NPE) THEN ! Reallocate size of INT_IJK, INT_COEF
   ALLOCATE(INT_IJK_AUX(IAXIS:KAXIS,DIM_NPE),INT_COEF_AUX(1:DIM_NPE))
   INT_IJK_AUX(IAXIS:KAXIS,1:DIM_NPE) = INT_IJK(IAXIS:KAXIS,1:DIM_NPE)
   INT_COEF_AUX(1:DIM_NPE)            = INT_COEF(1:DIM_NPE)
   DEALLOCATE(INT_IJK, INT_COEF)
   ALLOCATE(INT_IJK(IAXIS:KAXIS,NPE_LIST_START+MAX_INTERP_POINTS+DELTA_VERT)); INT_IJK = CC_UNDEFINED
   ALLOCATE(INT_COEF(1:NPE_LIST_START+MAX_INTERP_POINTS+DELTA_VERT)); INT_COEF = 0._EB
   INT_IJK(IAXIS:KAXIS,1:DIM_NPE) = INT_IJK_AUX(IAXIS:KAXIS,1:DIM_NPE)
   INT_COEF(1:DIM_NPE)            = INT_COEF_AUX(1:DIM_NPE)
   DEALLOCATE(INT_IJK_AUX,INT_COEF_AUX)
ENDIF

! Linear interpolation bounds:
ILO = INDX-1;  IHI = INDX
JLO = INDY-1;  JHI = INDY
KLO = INDZ-1;  KHI = INDZ
! Other interpolation bounds:
IF (STENCIL_INTERPOLATION /= CC_LINEAR_INTERPOLATION) THEN ! Either QUADRATIC_INTERPOLATION,WLS_INTERPOLATION.
   ILO_2 = ILO_CELL; IHI_2 = IHI_CELL
   JLO_2 = JLO_CELL; JHI_2 = JHI_CELL
   KLO_2 = KLO_CELL; KHI_2 = KHI_CELL
   SELECT CASE(VIND)
   CASE(IAXIS)
      ILO_2 = ILO_FACE; IHI_2 = IHI_FACE
   CASE(JAXIS)
      JLO_2 = JLO_FACE; JHI_2 = JHI_FACE
   CASE(KAXIS)
      KLO_2 = KLO_FACE; KHI_2 = KHI_FACE
   END SELECT
   IF(IHI == IHI_2+NGUARD ) THEN
      ILO = ILO - 1
   ELSEIF(ILO >= ILO_2-NGUARD ) THEN
      IHI = IHI + 1
   ENDIF
   IF(JHI == JHI_2+NGUARD ) THEN
      JLO = JLO - 1
   ELSEIF(JLO >= JLO_2-NGUARD ) THEN
      JHI = JHI + 1
   ENDIF
   IF(KHI == KHI_2+NGUARD ) THEN
      KLO = KLO - 1
   ELSEIF(KLO >= KLO_2-NGUARD ) THEN
      KHI = KHI + 1
   ENDIF

ENDIF

! Allocate stencil Allocatable arrays:
ALLOCATE(MASK_IJK(ILO:IHI,JLO:JHI,KLO:KHI)); MASK_IJK=0;
ALLOCATE(RAW_COEF(ILO:IHI,JLO:JHI,KLO:KHI)); RAW_COEF=0._EB;

! Add collocation points to interpolation stencil:
! Face vars:
IF(VIND > 0) THEN
   IF (MASK_FLG) THEN
      DO KK = KLO,KHI
         DO JJ = JLO,JHI
            DO II = ILO,IHI
               IF(FCVAR(II,JJ,KK,CC_IDRC,VIND) /= CC_GASPHASE) CYCLE ! Cycle if facevar is masked by CC_IDRC.
               NPE_LIST_COUNT = NPE_LIST_COUNT + 1
               INT_IJK(IAXIS:KAXIS,NPE_LIST_START+NPE_LIST_COUNT) = (/ II, JJ, KK /)
               ! Coeff computation left for the end.
               MASK_IJK(II,JJ,KK) = 1
            ENDDO
         ENDDO
      ENDDO
   ELSE
      DO KK = KLO,KHI
         DO JJ = JLO,JHI
            DO II = ILO,IHI
               IF(FCVAR(II,JJ,KK,CC_FGSC,VIND) == CC_SOLID) CYCLE ! Cycle solid faces.
               NPE_LIST_COUNT = NPE_LIST_COUNT + 1
               INT_IJK(IAXIS:KAXIS,NPE_LIST_START+NPE_LIST_COUNT) = (/ II, JJ, KK /)
               ! Coeff computation left for the end.
               MASK_IJK(II,JJ,KK) = 1
            ENDDO
         ENDDO
      ENDDO
   ENDIF ! MASK_FLG
ELSE ! Centered vars:
   DO KK = KLO,KHI
      DO JJ = JLO,JHI
         DO II = ILO,IHI
            IF(CCVAR(II,JJ,KK,CC_CGSC) == CC_SOLID) CYCLE ! Cycle solid cells.
            NPE_LIST_COUNT = NPE_LIST_COUNT + 1
            INT_IJK(IAXIS:KAXIS,NPE_LIST_START+NPE_LIST_COUNT) = (/ II, JJ, KK /)
            ! Coeff computation left for the end.
            MASK_IJK(II,JJ,KK) = 1
         ENDDO
      ENDDO
   ENDDO
ENDIF

! If NPE_LIST_COUNT == 0 return. Will use boundary value only on interpolated face:
IF (NPE_LIST_COUNT == 0) THEN
   DEALLOCATE(MASK_IJK,RAW_COEF)
   RETURN
ENDIF


! At this point we have the interpolation stencil points for EP and VIND mesh.
! Regarding the interpolation type chosen produce the interpolation coefficients in INT_COEFF.
! Define Bounding Box of the Stencil:
IF(VIND==IAXIS) THEN
   XYZ_LOHI(LOW_IND:HIGH_IND,IAXIS) = (/ XFACE(ILO), XFACE(IHI) /)
ELSE
   XYZ_LOHI(LOW_IND:HIGH_IND,IAXIS) = (/ XCELL(ILO), XCELL(IHI) /)
ENDIF
IF(VIND==JAXIS) THEN
   XYZ_LOHI(LOW_IND:HIGH_IND,JAXIS) = (/ YFACE(JLO), YFACE(JHI) /)
ELSE
   XYZ_LOHI(LOW_IND:HIGH_IND,JAXIS) = (/ YCELL(JLO), YCELL(JHI) /)
ENDIF
IF(VIND==KAXIS) THEN
   XYZ_LOHI(LOW_IND:HIGH_IND,KAXIS) = (/ ZFACE(KLO), ZFACE(KHI) /)
ELSE
   XYZ_LOHI(LOW_IND:HIGH_IND,KAXIS) = (/ ZCELL(KLO), ZCELL(KHI) /)
ENDIF

! Masked Trilinear interpolation coefficients:
IF (STENCIL_INTERPOLATION == CC_LINEAR_INTERPOLATION) THEN
   DO DUMAXIS=IAXIS,KAXIS
      X_P(DUMAXIS) = (XYZE(DUMAXIS)-XYZ_LOHI(LOW_IND,DUMAXIS))/(XYZ_LOHI(HIGH_IND,DUMAXIS)-XYZ_LOHI(LOW_IND,DUMAXIS))
   ENDDO

   ! Case of Trilinear interpolation:
   DO_TRILINEAR_COND : IF (DO_TRILINEAR) THEN
      ! Masked trilinear interpolation:
      DO KK = KLO,KHI
         DO JJ = JLO,JHI
            DO II = ILO,IHI
               RAW_COEF(II,JJ,KK) = (REAL(II-ILO,EB)*X_P(IAXIS)+REAL(IHI-II,EB)*(1._EB-X_P(IAXIS))) * &
                                    (REAL(JJ-JLO,EB)*X_P(JAXIS)+REAL(JHI-JJ,EB)*(1._EB-X_P(JAXIS))) * &
                                    (REAL(KK-KLO,EB)*X_P(KAXIS)+REAL(KHI-KK,EB)*(1._EB-X_P(KAXIS)))
            ENDDO
         ENDDO
      ENDDO
      ! Rescale remaining coefficients:
      RED_COEF = 0._EB
      DO KK = KLO,KHI
         DO JJ = JLO,JHI
            DO II = ILO,IHI
               IF (MASK_IJK(II,JJ,KK) == 1) RED_COEF = RED_COEF + RAW_COEF(II,JJ,KK)
            ENDDO
         ENDDO
      ENDDO
      IF (ABS(RED_COEF) < TWO_EPSILON_EB) THEN
         NPE_LIST_COUNT = 0
         DEALLOCATE(MASK_IJK,RAW_COEF)
         RETURN
      ENDIF
      DO KK = KLO,KHI
         DO JJ = JLO,JHI
            DO II = ILO,IHI
               IF (MASK_IJK(II,JJ,KK) == 1) THEN
                  RAW_COEF(II,JJ,KK) = RAW_COEF(II,JJ,KK)/RED_COEF
               ELSE
                  RAW_COEF(II,JJ,KK) = 0._EB
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      ! Finally add coefficients to INT_COEF:
      COUNT = 0
      DO KK = KLO,KHI
         DO JJ = JLO,JHI
            DO II = ILO,IHI
               IF(MASK_IJK(II,JJ,KK) == 1) THEN
                  COUNT = COUNT + 1
                  INT_COEF(NPE_LIST_START+COUNT) = RAW_COEF(II,JJ,KK)
               ENDIF
            ENDDO
         ENDDO
      ENDDO

   ! Case of Least Squares interpolation with up to 8 stencil points:
   ELSE
      ! To do.

   ENDIF DO_TRILINEAR_COND
   DEALLOCATE(MASK_IJK,RAW_COEF)
   RETURN
ENDIF

! Other interpolation schemes:
! To do.

DEALLOCATE(MASK_IJK,RAW_COEF)
RETURN
END SUBROUTINE GET_INTSTENCILS_EP

SUBROUTINE GET_X_IND(XYZE,IS_FACE,INDX)
REAL(EB),INTENT(IN) :: XYZE(IAXIS:KAXIS)
LOGICAL, INTENT(IN) :: IS_FACE
INTEGER, INTENT(OUT):: INDX
INTEGER :: IEP
INDX = INDEX_UNDEFINED
IF (IS_FACE) THEN ! X face.
   IF(XYZE(IAXIS) >= XFACE(ILO_FACE-NGUARD)) THEN
      DO IEP=ILO_FACE-CCGUARD,IHI_FACE+CCGUARD
         IF (XYZE(IAXIS)+GEOFCT*GEOMEPS < XFACE(IEP)) THEN ! First X index that XYZ(IAXIS) is smaller.
            INDX = IEP; RETURN
         ENDIF
      ENDDO
   ENDIF
ELSE ! X center.
   IF(XYZE(IAXIS) >= XCELL(ILO_CELL-NGUARD)) THEN
      DO IEP=ILO_CELL-CCGUARD,IHI_CELL+CCGUARD
         IF (XYZE(IAXIS)+GEOFCT*GEOMEPS < XCELL(IEP)) THEN ! First X index that XYZ(IAXIS) is smaller.
            INDX = IEP; RETURN
         ENDIF
      ENDDO
   ENDIF
ENDIF
END SUBROUTINE GET_X_IND

SUBROUTINE GET_Y_IND(XYZE,IS_FACE,INDY)
REAL(EB),INTENT(IN) :: XYZE(IAXIS:KAXIS)
LOGICAL, INTENT(IN) :: IS_FACE
INTEGER, INTENT(OUT):: INDY
INTEGER :: IEP
INDY = INDEX_UNDEFINED
IF (IS_FACE) THEN ! Y face.
   IF(XYZE(JAXIS) >= YFACE(JLO_FACE-NGUARD)) THEN
      DO IEP=JLO_FACE-CCGUARD,JHI_FACE+CCGUARD
         IF (XYZE(JAXIS)+GEOFCT*GEOMEPS < YFACE(IEP)) THEN ! First Y index that XYZ(JAXIS) is smaller.
            INDY = IEP; RETURN
         ENDIF
      ENDDO
   ENDIF
ELSE ! Y center.
   IF(XYZE(JAXIS) >= YCELL(JLO_CELL-NGUARD)) THEN
      DO IEP=JLO_CELL-CCGUARD,JHI_CELL+CCGUARD
         IF (XYZE(JAXIS)+GEOFCT*GEOMEPS < YCELL(IEP)) THEN ! First Y index that XYZ(JAXIS) is smaller.
            INDY = IEP; RETURN
         ENDIF
      ENDDO
   ENDIF
ENDIF
END SUBROUTINE GET_Y_IND

SUBROUTINE GET_Z_IND(XYZE,IS_FACE,INDZ)
REAL(EB),INTENT(IN) :: XYZE(IAXIS:KAXIS)
LOGICAL, INTENT(IN) :: IS_FACE
INTEGER, INTENT(OUT):: INDZ
INTEGER :: IEP
INDZ = INDEX_UNDEFINED
IF (IS_FACE) THEN ! Z face.
   IF(XYZE(KAXIS) >= ZFACE(KLO_FACE-NGUARD)) THEN
      DO IEP=KLO_FACE-CCGUARD,KHI_FACE+CCGUARD
         IF (XYZE(KAXIS)+GEOFCT*GEOMEPS < ZFACE(IEP)) THEN ! First Z index that XYZ(KAXIS) is smaller.
            INDZ = IEP; RETURN
         ENDIF
      ENDDO
   ENDIF
ELSE ! Z center.
   IF(XYZE(KAXIS) >= ZCELL(KLO_CELL-NGUARD)) THEN
      DO IEP=KLO_CELL-CCGUARD,KHI_CELL+CCGUARD
         IF (XYZE(KAXIS)+GEOFCT*GEOMEPS < ZCELL(IEP)) THEN ! First Z index that XYZ(KAXIS) is smaller.
            INDZ = IEP; RETURN
         ENDIF
      ENDDO
   ENDIF
ENDIF
END SUBROUTINE GET_Z_IND


END SUBROUTINE GET_CRTCFCC_INT_STENCILS


! -------------------------------- FILL_IJKO_INTERP_STENCILS ----------------------------

SUBROUTINE FILL_IJKO_INTERP_STENCILS

USE MPI_F08

! Local Variables:
INTEGER :: NM,NOM,N,IERR
TYPE (OMESH_TYPE), POINTER :: M2,M3
TYPE (MPI_REQUEST), ALLOCATABLE, DIMENSION(:) :: REQ0,REQ0DUM
INTEGER :: N_REQ0
REAL(EB) CPUTIME, CPUTIME_START
LOGICAL :: PROCESS_SENDREC

IF (N_MPI_PROCESSES>1) ALLOCATE(REQ0(NMESHES))

N_REQ0 = 0

IF(GET_CUTCELLS_VERBOSE) THEN
   WRITE(LU_SETCC,'(A)',advance='no') '   > First loop, CC info..'
   CALL CPU_TIME(CPUTIME_START)
ENDIF

! Exchange number of cut-cells information to be exchanged between MESH and OMESHES:
DO NM=1,NMESHES
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      PROCESS_SENDREC = .FALSE.
      DO N=1,MESHES(NM)%N_NEIGHBORING_MESHES
         IF (NOM==MESHES(NM)%NEIGHBORING_MESH(N)) PROCESS_SENDREC = .TRUE.
      ENDDO
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MY_RANK  .AND. PROCESS_SENDREC) THEN
         M2 => MESHES(NOM)%OMESH(NM)
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_IRECV(M2%NFCC_S(1),2,MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ENDIF
   ENDDO
ENDDO

IF(GET_CUTCELLS_VERBOSE) THEN
   CALL CPU_TIME(CPUTIME)
   WRITE(LU_SETCC,'(A,F8.3,A)') ' done. Time taken : ',CPUTIME-CPUTIME_START,' sec.'
   CALL CPU_TIME(CPUTIME_START)
   WRITE(LU_SETCC,'(A)',advance='no') '   > Second loop, Barrier and isend..'
ENDIF

! DEFINITION NCCC_S:   MESHES(NOM)%OMESH(NM)%NFCC_S   = MESHES(NM)%OMESH(NOM)%NFCC_R

DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   IF (PROCESS(NM)/=MY_RANK) CYCLE
   DO NOM=1,NMESHES
      PROCESS_SENDREC = .FALSE.
      DO N=1,MESHES(NOM)%N_NEIGHBORING_MESHES
         IF (NM==MESHES(NOM)%NEIGHBORING_MESH(N)) PROCESS_SENDREC = .TRUE.
      ENDDO
      IF (.NOT.PROCESS_SENDREC) CYCLE
      M3 => MESHES(NM)%OMESH(NOM)
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NOM)/=MY_RANK) THEN
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_ISEND(M3%NFCC_R(1),2,MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ELSE
         M2 => MESHES(NOM)%OMESH(NM)
         M2%NFCC_S(1:2) = M3%NFCC_R(1:2)
      ENDIF
   ENDDO
ENDDO

IF(GET_CUTCELLS_VERBOSE) THEN
   CALL CPU_TIME(CPUTIME)
   WRITE(LU_SETCC,'(A,F8.3,A)') ' done. Time taken : ',CPUTIME-CPUTIME_START,' sec.'
   CALL CPU_TIME(CPUTIME_START)
   WRITE(LU_SETCC,'(A)',advance='no') '   > MPI_WAITALL and Alloc..'
ENDIF

IF ( (N_REQ0>0) .AND. (N_MPI_PROCESSES>1) ) CALL MPI_WAITALL(N_REQ0,REQ0(1:N_REQ0),MPI_STATUSES_IGNORE,IERR)

! At this point values of M2%NFCC_S should have been received.

! Definition: MESHES(NOM)%OMESH(NM)%IIO_FC_S(:) = MESHES(NM)%OMESH(NOM)%IIO_FC_R(:)
!             MESHES(NOM)%OMESH(NM)%JJO_FC_S(:) = MESHES(NM)%OMESH(NOM)%JJO_FC_R(:)
!             MESHES(NOM)%OMESH(NM)%KKO_FC_S(:) = MESHES(NM)%OMESH(NOM)%KKO_FC_R(:)
!             MESHES(NOM)%OMESH(NM)%AXS_FC_S(:) = MESHES(NM)%OMESH(NOM)%AXS_FC_R(:)

! Exchange list of face and cutcells data:
DO NM=1,NMESHES
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      M2 => MESHES(NOM)%OMESH(NM)
      IF (M2%NFCC_S(1)>0) THEN
         ALLOCATE(M2%IIO_FC_S(M2%NFCC_S(1)))
         ALLOCATE(M2%JJO_FC_S(M2%NFCC_S(1)))
         ALLOCATE(M2%KKO_FC_S(M2%NFCC_S(1)))
         ALLOCATE(M2%AXS_FC_S(M2%NFCC_S(1)))
      ENDIF
      IF (M2%NFCC_S(2)>0) THEN
         ALLOCATE(M2%IIO_CC_S(M2%NFCC_S(2)))
         ALLOCATE(M2%JJO_CC_S(M2%NFCC_S(2)))
         ALLOCATE(M2%KKO_CC_S(M2%NFCC_S(2)))
      ENDIF
   ENDDO
ENDDO

IF(GET_CUTCELLS_VERBOSE) THEN
   CALL CPU_TIME(CPUTIME)
   WRITE(LU_SETCC,'(A,F8.3,A)') ' done. Time taken : ',CPUTIME-CPUTIME_START,' sec.'
   CALL CPU_TIME(CPUTIME_START)
   WRITE(LU_SETCC,'(A)',advance='no') '   > Faces non-blocking send-receives..'
ENDIF

! Faces:
N_REQ0 = 0
DO NM=1,NMESHES
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      M2 => MESHES(NOM)%OMESH(NM)
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MY_RANK .AND. M2%NFCC_S(1)>0) THEN
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_IRECV(M2%IIO_FC_S(1),M2%NFCC_S(1),MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_IRECV(M2%JJO_FC_S(1),M2%NFCC_S(1),MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_IRECV(M2%KKO_FC_S(1),M2%NFCC_S(1),MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_IRECV(M2%AXS_FC_S(1),M2%NFCC_S(1),MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ENDIF
   ENDDO
ENDDO
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   DO NOM=1,NMESHES
      M3 => MESHES(NM)%OMESH(NOM)
      IF (M3%NFCC_R(1)<1) CYCLE
      IF (PROCESS(NOM)/=MY_RANK) THEN
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_ISEND(M3%IIO_FC_R(1),M3%NFCC_R(1),MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_ISEND(M3%JJO_FC_R(1),M3%NFCC_R(1),MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_ISEND(M3%KKO_FC_R(1),M3%NFCC_R(1),MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_ISEND(M3%AXS_FC_R(1),M3%NFCC_R(1),MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ELSE
         M2 => MESHES(NOM)%OMESH(NM)
         M2%IIO_FC_S(1:M2%NFCC_S(1)) = M3%IIO_FC_R(1:M3%NFCC_R(1))
         M2%JJO_FC_S(1:M2%NFCC_S(1)) = M3%JJO_FC_R(1:M3%NFCC_R(1))
         M2%KKO_FC_S(1:M2%NFCC_S(1)) = M3%KKO_FC_R(1:M3%NFCC_R(1))
         M2%AXS_FC_S(1:M2%NFCC_S(1)) = M3%AXS_FC_R(1:M3%NFCC_R(1))
      ENDIF
   ENDDO
ENDDO

IF(GET_CUTCELLS_VERBOSE) THEN
   CALL CPU_TIME(CPUTIME)
   WRITE(LU_SETCC,'(A,F8.3,A)') ' done. Time taken : ',CPUTIME-CPUTIME_START,' sec.'
   CALL CPU_TIME(CPUTIME_START)
   WRITE(LU_SETCC,'(A)',advance='no') '   > MPI_WAITALL Faces..'
ENDIF

IF ( (N_REQ0>0) .AND. (N_MPI_PROCESSES>1) ) CALL MPI_WAITALL(N_REQ0,REQ0(1:N_REQ0),MPI_STATUSES_IGNORE,IERR)

IF(GET_CUTCELLS_VERBOSE) THEN
   CALL CPU_TIME(CPUTIME)
   WRITE(LU_SETCC,'(A,F8.3,A)') ' done. Time taken : ',CPUTIME-CPUTIME_START,' sec.'
   CALL CPU_TIME(CPUTIME_START)
   WRITE(LU_SETCC,'(A)',advance='no') '   > Cells non-blocking send-receives..'
ENDIF

! Cells:
N_REQ0 = 0
DO NM=1,NMESHES
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      M2 => MESHES(NOM)%OMESH(NM)
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MY_RANK .AND. M2%NFCC_S(2)>0) THEN
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_IRECV(M2%IIO_CC_S(1),M2%NFCC_S(2),MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_IRECV(M2%JJO_CC_S(1),M2%NFCC_S(2),MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_IRECV(M2%KKO_CC_S(1),M2%NFCC_S(2),MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ENDIF
   ENDDO
ENDDO
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   DO NOM=1,NMESHES
      M3 => MESHES(NM)%OMESH(NOM)
      IF (M3%NFCC_R(2)<1) CYCLE
      IF (PROCESS(NOM)/=MY_RANK) THEN
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_ISEND(M3%IIO_CC_R(1),M3%NFCC_R(2),MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_ISEND(M3%JJO_CC_R(1),M3%NFCC_R(2),MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_ISEND(M3%KKO_CC_R(1),M3%NFCC_R(2),MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ELSE
         M2 => MESHES(NOM)%OMESH(NM)
         M2%IIO_CC_S(1:M2%NFCC_S(2)) = M3%IIO_CC_R(1:M3%NFCC_R(2))
         M2%JJO_CC_S(1:M2%NFCC_S(2)) = M3%JJO_CC_R(1:M3%NFCC_R(2))
         M2%KKO_CC_S(1:M2%NFCC_S(2)) = M3%KKO_CC_R(1:M3%NFCC_R(2))
      ENDIF
   ENDDO
ENDDO

IF(GET_CUTCELLS_VERBOSE) THEN
   CALL CPU_TIME(CPUTIME)
   WRITE(LU_SETCC,'(A,F8.3,A)') ' done. Time taken : ',CPUTIME-CPUTIME_START,' sec.'
   CALL CPU_TIME(CPUTIME_START)
   WRITE(LU_SETCC,'(A)',advance='no') '   > MPI_WAITALL Cells..'
ENDIF

IF ( (N_REQ0>0) .AND. (N_MPI_PROCESSES>1) ) CALL MPI_WAITALL(N_REQ0,REQ0(1:N_REQ0),MPI_STATUSES_IGNORE,IERR)

IF(GET_CUTCELLS_VERBOSE) THEN
   CALL CPU_TIME(CPUTIME)
   WRITE(LU_SETCC,'(A,F8.3,A)') ' done. Time taken : ',CPUTIME-CPUTIME_START,' sec.'
ENDIF

IF(ALLOCATED(REQ0)) DEALLOCATE(REQ0)

RETURN

CONTAINS
SUBROUTINE CHECK_REQ0_SIZE
IF(N_REQ0>SIZE(REQ0,DIM=1)) THEN
   ALLOCATE(REQ0DUM(SIZE(REQ0,DIM=1)+NMESHES))
   REQ0DUM(1:N_REQ0-1) = REQ0(1:N_REQ0-1)
   CALL MOVE_ALLOC(REQ0DUM,REQ0)
ENDIF
END SUBROUTINE CHECK_REQ0_SIZE

END SUBROUTINE FILL_IJKO_INTERP_STENCILS


! --------------------------- GET_CLSPT_INBCF -----------------------------------

SUBROUTINE GET_CLSPT_INBCF(NM,XYZ,INBFC,INBFC_LOC,XYZ_IP,DIST,FOUNDPT,INSEG,INSEG2)

INTEGER,  INTENT(IN) :: NM, INBFC, INBFC_LOC
REAL(EB), INTENT(IN) :: XYZ(MAX_DIM)
REAL(EB), INTENT(OUT):: XYZ_IP(MAX_DIM), DIST
LOGICAL,  INTENT(OUT):: FOUNDPT, INSEG
LOGICAL,  OPTIONAL, INTENT(OUT):: INSEG2

! Local Variables:
INTEGER :: BODTRI(1:2),VERT_CUTFACE
INTEGER, ALLOCATABLE, DIMENSION(:) :: CFELEM
INTEGER :: X1AXIS,X2AXIS,X3AXIS
INTEGER :: IBOD,IWSEL,NVFACE,IPT,NVERT
REAL(EB):: NVEC(MAX_DIM),ANVEC(MAX_DIM),P0(MAX_DIM),A,B,C,D,PROJ_COEFF,XYZ_P(MAX_DIM)
REAL(EB):: PTCEN(IAXIS:JAXIS) !,AREAI,V1(IAXIS:JAXIS),V2(IAXIS:JAXIS)
REAL(EB):: SQRDIST, SQRDISTI, X2X3_1(IAXIS:JAXIS), X2X3_2(IAXIS:JAXIS)
REAL(EB):: DP(IAXIS:JAXIS),PCM1(IAXIS:JAXIS),PCM2(IAXIS:JAXIS),X2X3_IP(IAXIS:JAXIS)
REAL(EB):: T,DPDOTDP,SLOC,ATEST
REAL(EB):: P(IAXIS:KAXIS),DPP(IAXIS:KAXIS)
LOGICAL :: IN_POLY

! Initialize:
XYZ_IP(IAXIS:KAXIS) = 0._EB
DIST    = 1._EB / GEOMEPS
FOUNDPT = .FALSE.
INSEG   = .FALSE.
IF(PRESENT(INSEG2)) INSEG2=.FALSE.

VERT_CUTFACE = SIZE(MESHES(NM)%CUT_FACE(INBFC)%CFELEM, DIM=1); ALLOCATE(CFELEM(1:VERT_CUTFACE+1))
CFELEM(1:VERT_CUTFACE)  = MESHES(NM)%CUT_FACE(INBFC)%CFELEM(1:VERT_CUTFACE,INBFC_LOC)
BODTRI(1:2)  = MESHES(NM)%CUT_FACE(INBFC)%BODTRI(1:2,INBFC_LOC)

! normal vector to boundary surface triangle:
IBOD    = BODTRI(1)
IWSEL   = BODTRI(2)
NVEC(IAXIS:KAXIS)    = GEOMETRY(IBOD)%FACES_NORMAL(IAXIS:KAXIS,IWSEL)
NVFACE  = CFELEM(1);   CFELEM(NVFACE+2)=CFELEM(2)

! Plane equation for INBOUNDARY cut-face plane:
! Location of first point in cf polygon is P0:
IPT = 1
P0(IAXIS:KAXIS) = MESHES(NM)%CUT_FACE(INBFC)%XYZVERT(IAXIS:KAXIS,CFELEM(IPT+1))
A = NVEC(IAXIS)
B = NVEC(JAXIS)
C = NVEC(KAXIS)
D = -(A*P0(IAXIS) + B*P0(JAXIS) + C*P0(KAXIS))

! Project xyz point into plane of cf polygon:
PROJ_COEFF = (A*XYZ(IAXIS)+B*XYZ(JAXIS)+C*XYZ(KAXIS)) + D ! /dot(n,n) = 1
XYZ_P(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS) - PROJ_COEFF*NVEC(IAXIS:KAXIS)

! Which Cartesian plane we project to?
ANVEC(IAXIS) = ABS(NVEC(IAXIS)); ANVEC(JAXIS) = ABS(NVEC(JAXIS)); ANVEC(KAXIS) = ABS(NVEC(KAXIS))
IF ( MAX(ANVEC(IAXIS),MAX(ANVEC(JAXIS),ANVEC(KAXIS))) == ANVEC(IAXIS) ) THEN
   X1AXIS = IAXIS; X2AXIS = JAXIS; X3AXIS = KAXIS
ELSEIF ( MAX(ANVEC(IAXIS),MAX(ANVEC(JAXIS),ANVEC(KAXIS))) == ANVEC(JAXIS) ) THEN
   X1AXIS = JAXIS; X2AXIS = KAXIS; X3AXIS = IAXIS
ELSE
   X1AXIS = KAXIS; X2AXIS = IAXIS; X3AXIS = JAXIS
ENDIF

! Now find closest point in projected plane:
! First: Test if point is inside cf area: Compute area of triangles formed
! by projected point xyz_p in x2,x3 plane and cf XYZvert, resp to
! CUT_FACE.area*nvec(x1axis), i.e. cut-face area projected on the Cartesian
! plane orthogonal to x1axis:
PTCEN(IAXIS:JAXIS) = XYZ_P( (/ X2AXIS, X3AXIS /) )
NVERT = SIZE(MESHES(NM)%CUT_FACE(INBFC)%XYZVERT,DIM=2)
ATEST = MESHES(NM)%CUT_FACE(INBFC)%AREA(INBFC_LOC)*ANVEC(X1AXIS) ! Test Area is projected area into X1AXIS.
CALL POINT_IN_POLYGON(PTCEN,VERT_CUTFACE+1,CFELEM,NVERT,X2AXIS,X3AXIS,MESHES(NM)%CUT_FACE(INBFC)%XYZVERT,IN_POLY)

! Test if inside:
IF (IN_POLY) THEN
   ! Same areas, xyz_p inside INBOUNDARY cut-face:
   XYZ_IP(IAXIS:KAXIS) = XYZ_P(IAXIS:KAXIS)
   DIST   = SQRT( (XYZ(IAXIS)-XYZ_IP(IAXIS))**2._EB + &
                  (XYZ(JAXIS)-XYZ_IP(JAXIS))**2._EB + &
                  (XYZ(KAXIS)-XYZ_IP(KAXIS))**2._EB )
   FOUNDPT= .TRUE.
   ! Now check if point is in segment:
   IF (PRESENT(INSEG2)) THEN
      DO IPT=1,NVFACE
          P(IAXIS:KAXIS)  = MESHES(NM)%CUT_FACE(INBFC)%XYZVERT(IAXIS:KAXIS,CFELEM(IPT+1))
          DPP(IAXIS:KAXIS)= MESHES(NM)%CUT_FACE(INBFC)%XYZVERT(IAXIS:KAXIS,CFELEM(IPT+2))-P(IAXIS:KAXIS)
          IF (NORM2(DPP(IAXIS:KAXIS)) < TWO_EPSILON_EB) CYCLE
          DPP(IAXIS:KAXIS)=DPP(IAXIS:KAXIS)/NORM2(DPP(IAXIS:KAXIS))
          P = XYZ_IP - (P + DOT_PRODUCT(DPP,XYZ_IP-P)*DPP)
          IF (NORM2(P(IAXIS:KAXIS)) < GEOMEPS) THEN
             INSEG = .TRUE.
             INSEG2= .TRUE.
             EXIT
          ENDIF
      ENDDO
   ENDIF
   DEALLOCATE(CFELEM)
   RETURN
ENDIF

! Second, test against segments: Find closest point in segments in x2,x3 plane:
SQRDIST = 1._EB / GEOMEPS
DO IPT=1,NVFACE

    X2X3_1(IAXIS:JAXIS) = MESHES(NM)%CUT_FACE(INBFC)%XYZVERT((/ X2AXIS, X3AXIS /) ,CFELEM(IPT+1))
    X2X3_2(IAXIS:JAXIS) = MESHES(NM)%CUT_FACE(INBFC)%XYZVERT((/ X2AXIS, X3AXIS /) ,CFELEM(IPT+2))

    ! Smallest distance from point PC to segment x2x3_1-x2x3_2:
    DP(IAXIS:JAXIS)     = X2X3_2(IAXIS:JAXIS) - X2X3_1(IAXIS:JAXIS)
    PCM1(IAXIS:JAXIS)   =  PTCEN(IAXIS:JAXIS) - X2X3_1(IAXIS:JAXIS)
    T      = DP(IAXIS)*PCM1(IAXIS) + DP(JAXIS)*PCM1(JAXIS)
    DPDOTDP= DP(IAXIS)**2._EB + DP(JAXIS)**2._EB

    IF ( T < GEOMEPS ) THEN
        SQRDISTI = PCM1(IAXIS)**2._EB + PCM1(JAXIS)**2._EB ! x2x3_1 is closest pt.
        T = 0._EB
    ELSEIF ( T >= DPDOTDP ) THEN
        PCM2(IAXIS:JAXIS) = PTCEN(IAXIS:JAXIS) - X2X3_2(IAXIS:JAXIS)
        SQRDISTI = PCM2(IAXIS)**2._EB + PCM2(JAXIS)**2._EB ! x2x3_2 is closest pt.
        T = DPDOTDP
    ELSE
        SQRDISTI =(PCM1(IAXIS)**2._EB + PCM1(JAXIS)**2._EB) - T**2._EB/DPDOTDP
    ENDIF

    ! Test:
    IF ( SQRDISTI < SQRDIST ) THEN
        SQRDIST = SQRDISTI
        SLOC    = T/(DPDOTDP+TWO_EPSILON_EB)
        X2X3_IP(IAXIS:JAXIS) = X2X3_1(IAXIS:JAXIS) + SLOC * DP(IAXIS:JAXIS) ! intersection point in segment,
                                                                            ! plane x2,x3
        FOUNDPT= .TRUE.
        INSEG  = .TRUE.
    ENDIF
ENDDO

! Now pass x2x3 intersection point to 3D:
IF (FOUNDPT) THEN
    SELECT CASE(X1AXIS)
        CASE(IAXIS)
            XYZ_IP(JAXIS) = X2X3_IP(IAXIS)
            XYZ_IP(KAXIS) = X2X3_IP(JAXIS)
            XYZ_IP(IAXIS) = (-B*XYZ_IP(JAXIS) -C*XYZ_IP(KAXIS) - D)/A
        CASE(JAXIS)
            XYZ_IP(KAXIS) = X2X3_IP(IAXIS)
            XYZ_IP(IAXIS) = X2X3_IP(JAXIS)
            XYZ_IP(JAXIS) = (-A*XYZ_IP(IAXIS) -C*XYZ_IP(KAXIS) - D)/B
        CASE(KAXIS)
            XYZ_IP(IAXIS) = X2X3_IP(IAXIS)
            XYZ_IP(JAXIS) = X2X3_IP(JAXIS)
            XYZ_IP(KAXIS) = (-A*XYZ_IP(IAXIS) -B*XYZ_IP(JAXIS) - D)/C
    END SELECT
    DIST   = SQRT( (XYZ(IAXIS)-XYZ_IP(IAXIS))**2._EB + &
                   (XYZ(JAXIS)-XYZ_IP(JAXIS))**2._EB + &
                   (XYZ(KAXIS)-XYZ_IP(KAXIS))**2._EB )
ENDIF

DEALLOCATE(CFELEM)

RETURN
END SUBROUTINE GET_CLSPT_INBCF


! -------------------------- GET_CLOSEPT_CCVT -----------------------------------

SUBROUTINE GET_CLOSEPT_CCVT(NM,XYZ,ICC,XYZ_IP,DIST,FOUNDPT,IFCPT,IFCPT_LOC)

INTEGER,  INTENT(IN) :: NM, ICC
REAL(EB), INTENT(IN) :: XYZ(MAX_DIM)
REAL(EB), INTENT(OUT):: XYZ_IP(MAX_DIM), DIST
INTEGER,  INTENT(OUT):: IFCPT, IFCPT_LOC
LOGICAL,  INTENT(OUT):: FOUNDPT

! Local Variables:
INTEGER :: I,J,K,IJK(MAX_DIM),IJK_CELL(MAX_DIM),LOWHIGH,IND_ADD
INTEGER :: X1AXIS,X2AXIS,X3AXIS,XIAXIS,XJAXIS,XKAXIS,CEI,ICF,IX2,IX3
LOGICAL :: INLIST, ISCORN
INTEGER :: INDXI(MAX_DIM),IPT,IVERT,ICORN,INDI,INDJ,INDK
REAL(EB), POINTER, DIMENSION(:) :: X2FC,X3FC!,X1FC,X1CL,X2CL,X3CL,DX1FC,DX2FC,DX3FC,DX1CL,DX2CL,DX3CL
REAL(EB):: DV(MAX_DIM),XY1(1:4,IAXIS:JAXIS)
INTEGER :: JJ,KK,INDXI1(IAXIS:JAXIS),INDXI2(IAXIS:JAXIS),INDXI3(IAXIS:JAXIS),INDXI4(IAXIS:JAXIS)
LOGICAL :: CEIFLG

! Initialize:
XYZ_IP(IAXIS:KAXIS) = 0._EB
DIST    = 1._EB / GEOMEPS
FOUNDPT = .FALSE.
IFCPT   = 0; IFCPT_LOC = 0

! Here we need to look at Cartesian faces that are boundary of
! CUT_CELL(icc) (which has only regular or Gasphase cut-faces of regular
! size and find if a corner point (or sigular point) is type SOLID. The
! point found provides xyz_ip:
IJK_CELL(IAXIS:KAXIS) = MESHES(NM)%CUT_CELL(ICC)%IJK(IAXIS:KAXIS)

! Loop on different planes:
LOWHIGH_IND_LOOP : DO LOWHIGH=LOW_IND,HIGH_IND

   IND_ADD = LOWHIGH - LOW_IND  ! Index to add for face LOW-HIGH resp to cell.

   X1AXIS_LOOP : DO X1AXIS=IAXIS,KAXIS

      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         I = IJK_CELL(IAXIS)-1+IND_ADD
         J = IJK_CELL(JAXIS)
         K = IJK_CELL(KAXIS)
         X2AXIS = JAXIS; X3AXIS = KAXIS
         ! location in I,J,K of x1,x2,x3 axes:
         XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS
         ! Centroid coordinates in x1,x2,x3 axes:
         ! X2CL => YCELL; DX2CL => DYCELL
         ! X3CL => ZCELL; DX3CL => DZCELL
         ! X1FC => XFACE
         X2FC => YFACE
         X3FC => ZFACE

      CASE(JAXIS)
         I = IJK_CELL(IAXIS)
         J = IJK_CELL(JAXIS)-1+IND_ADD
         K = IJK_CELL(KAXIS)
         X2AXIS = KAXIS; X3AXIS = IAXIS
         ! location in I,J,K of x1,x2,x3 axes:
         XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS
         ! Centroid coordinates in x1,x2,x3 axes:
         ! X2CL => ZCELL; DX2CL => DZCELL
         ! X3CL => XCELL; DX3CL => DXCELL
         ! X1FC => YFACE;
         X2FC => ZFACE;
         X3FC => XFACE;
      CASE(KAXIS)

         I = IJK_CELL(IAXIS)
         J = IJK_CELL(JAXIS)
         K = IJK_CELL(KAXIS)-1+IND_ADD
         X2AXIS = IAXIS; X3AXIS = JAXIS
         ! location in I,J,K of x1,x2,x3 axes:
         XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS
         ! Face coordinates in x1,x2,x3 axes:
         ! X2CL => XCELL; DX2CL => DXCELL
         ! X3CL => YCELL; DX3CL => DYCELL
         ! X1FC => ZFACE
         X2FC => XFACE
         X3FC => YFACE

      END SELECT

      ! Drop if face is regular GASPHASE or SOLID:
      IF ( MESHES(NM)%FCVAR(I,J,K,CC_FGSC,X1AXIS) /= CC_CUTCFE ) CYCLE

      ! Face IJK:
      IJK(IAXIS:KAXIS) = (/ I, J, K /)

      ! Cartesian Face centroid location x2-x3 plane:
      CEI = MESHES(NM)%FCVAR(I,J,K,CC_IDCE,X1AXIS)
      ICF = MESHES(NM)%FCVAR(I,J,K,CC_IDCF,X1AXIS)

      ! We might have single point CEIs:
      CEIFLG = .FALSE.
      IF (CEI <= 0) THEN
         CEIFLG = .TRUE.
      ELSEIF ( MESHES(NM)%CUT_EDGE(CEI)%NVERT == 1 ) THEN
         CEIFLG = .TRUE.
      ENDIF

      IF (CEIFLG) THEN ! Cut face is one regular face, with one SOLID vertex.

         ! Figure out which vertex is SOLID and location:
         INLIST = .FALSE.
         DO IX3=0,1
            DO IX2=0,1
               ! Vertex axes:
               INDXI(IAXIS:KAXIS) = (/ IJK(X1AXIS), IJK(X2AXIS)-1+IX2, IJK(X3AXIS)-1+IX3 /) ! x1,x2,x3
               INDI = INDXI(XIAXIS)
               INDJ = INDXI(XJAXIS)
               INDK = INDXI(XKAXIS)
               IF ( MESHES(NM)%VERTVAR(INDI,INDJ,INDK,CC_VGSC) == CC_SOLID ) THEN
                  INLIST = .TRUE.
                  EXIT
               ENDIF
            ENDDO
            IF (INLIST) THEN
               XYZ_IP(IAXIS:KAXIS)  = (/ XFACE(INDI), YFACE(INDJ), ZFACE(INDK) /)
               DIST   = SQRT( (XYZ(IAXIS)-XYZ_IP(IAXIS))**2._EB + &
                              (XYZ(JAXIS)-XYZ_IP(JAXIS))**2._EB + &
                              (XYZ(KAXIS)-XYZ_IP(KAXIS))**2._EB )
               IFCPT  = ICF
               ! Find local point:
               DO IPT=1,MESHES(NM)%CUT_FACE(ICF)%NVERT
                  DV = MESHES(NM)%CUT_FACE(ICF)%XYZVERT(IAXIS:KAXIS,IPT) - XYZ_IP(IAXIS:KAXIS)
                  IF( (ABS(DV(IAXIS))+ABS(DV(JAXIS))+ABS(DV(KAXIS))) < GEOMEPS ) THEN
                     IFCPT_LOC = IPT
                     EXIT
                  ENDIF
               ENDDO
               FOUNDPT = .TRUE.
               RETURN
            ENDIF
         ENDDO

         ! Check if there are more than 4 vertices, get vertex that is not in corners:
         IF ( MESHES(NM)%CUT_FACE(ICF)%NVERT > 4 ) THEN

            JJ = IJK(X2AXIS); KK = IJK(X3AXIS)
            ! Vertex at index jj-1,kk-1:
            INDXI1(IAXIS:JAXIS) = (/ JJ-1  , KK-1   /) ! Local x2,x3
            ! Vertex at index jj,kk-1:
            INDXI2(IAXIS:JAXIS) = (/ JJ    , KK-1   /) ! Local x2,x3
            ! Vertex at index jj,kk:
            INDXI3(IAXIS:JAXIS) = (/ JJ    , KK     /) ! Local x2,x3
            ! Vertex at index jj-1,kk:
            INDXI4(IAXIS:JAXIS) = (/ JJ-1  , KK     /) ! Local x2,x3

            XY1(1:4,IAXIS) = (/ X2FC(INDXI1(IAXIS)), X2FC(INDXI2(IAXIS)), &
                                X2FC(INDXI3(IAXIS)), X2FC(INDXI4(IAXIS)) /)
            XY1(1:4,JAXIS) = (/ X3FC(INDXI1(JAXIS)), X3FC(INDXI2(JAXIS)), &
                                X3FC(INDXI3(JAXIS)), X3FC(INDXI4(JAXIS)) /)

            ! Find vertex:
            DO IVERT=1,MESHES(NM)%CUT_FACE(ICF)%NVERT
               ISCORN = .FALSE.
               DO ICORN=1,4
                  IF( SQRT( (XY1(ICORN,IAXIS)-MESHES(NM)%CUT_FACE(ICF)%XYZVERT(X2AXIS,IVERT))**2._EB + &
                            (XY1(ICORN,JAXIS)-MESHES(NM)%CUT_FACE(ICF)%XYZVERT(X3AXIS,IVERT))**2._EB ) &
                            < GEOMEPS) THEN
                     ISCORN = .TRUE.
                     EXIT
                  ENDIF
               ENDDO
               IF (.NOT.ISCORN) THEN
                  XYZ_IP(IAXIS:KAXIS) = MESHES(NM)%CUT_FACE(ICF)%XYZVERT(IAXIS:KAXIS,IVERT)
                  INLIST = .TRUE.
                  EXIT
               ENDIF
            ENDDO
            IF (INLIST) THEN
               DIST   = SQRT( (XYZ(IAXIS)-XYZ_IP(IAXIS))**2._EB + &
                              (XYZ(JAXIS)-XYZ_IP(JAXIS))**2._EB + &
                              (XYZ(KAXIS)-XYZ_IP(KAXIS))**2._EB )
               IFCPT     = ICF
               IFCPT_LOC = IVERT
               FOUNDPT   = .TRUE.
               RETURN
            ENDIF

         ENDIF

      ENDIF ! CEI <= 0

      !NULLIFY(X2CL,X3CL,DX2CL,DX3CL,X1FC,X2FC,X3FC)
      NULLIFY(X2FC,X3FC)

   ENDDO X1AXIS_LOOP

ENDDO LOWHIGH_IND_LOOP


RETURN
END SUBROUTINE GET_CLOSEPT_CCVT


! ----------------------- SET_CC_MATVEC_DATA ---------------------------------

SUBROUTINE SET_CC_MATVEC_DATA

USE MPI_F08

! Local variables:
INTEGER :: NM, I, IPROC, IERR

! 1. Define unknown numbers for Scalars:
CALL GET_LINKED_MATRIX_INDEXES_Z

! 2. For each CC_GASPHASE (cut or regular) face, find global numeration of the volumes
! that share it, store a list of areas and centroids for diffussion operator in FV form.
! 3. Get CC_GASPHASE regular faces data, for scalars Z:
CALL GET_GASPHASE_REGRCFACES_DATA

! 4. Get CC_GASPHASE cut-faces data:
CALL GET_GASPHASE_CUTFACES_DATA ! Here there is no need to populate CELL_LIST on CUT_FACE,
                                ! list of low/high cut-cell volumes that share the cut-face, as
                                ! this has been done before calling SET_CC_MATVEC_DATA, when calling
                                ! GET_CRTCFCC_INT_STENCILS.

! 6. Exchange information at block boundaries for RC_FACE, CUT_FACE
! fields on each mesh:
CALL DEFINE_SHARED_FACES
CALL GET_RCEDGE_FACE_LIST ! This routine makes use of RCFACES index defined in ECVAR(:,:,:,CC_IDRC,:) in the previous.

! 6.5 Link faces for momentum transport if unstructured projection:
CALL GET_LINKED_FACE_INDEXES_F

! 7. Get nonzeros graph of the scalar diffusion/advection matrix, defined as:
!    - NNZ_D_MAT_Z(1:NUNKZ_LOCAL) Number of nonzeros on per matrix row.
!    - JD_MAT_Z(1:NNZ_ROW_Z,1:NUNKZ_LOCAL) Column location of nonzeros, global numeration.
NUNKZ_LOCAL = sum(NUNKZ_LOC(1:NMESHES)) ! Filled in GET_MATRIX_INDEXES, only nonzeros are for meshes
                                        ! that belong to this process.
NUNKZ_TOTAL = sum(NUNKZ_TOT(1:NMESHES))

IF (GET_CUTCELLS_VERBOSE) THEN
   IF (MY_RANK==0) THEN
      WRITE(LU_ERR,*) ' '
      WRITE(LU_ERR,'(A)') ' Cut-cell region scalar transport advanced explicitly.'
      WRITE(LU_ERR,'(A)') ' List of Scalar unknown numbers per proc:'
   ENDIF
   DO IPROC=0,N_MPI_PROCESSES-1
      CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
      IF(MY_RANK==IPROC) WRITE(LU_ERR,'(A,I8,A,I8)') ' MY_RANK=',MY_RANK,', NUNKZ_LOCAL=',NUNKZ_LOCAL
   ENDDO
ENDIF

! Allocate NNZ_D_MAT_Z, JD_MAT_Z:
ALLOCATE( NNZ_D_MAT_Z(1:NUNKZ_LOCAL) )
ALLOCATE( JD_MAT_Z(1:NNZ_ROW_Z,1:NUNKZ_LOCAL) ) ! Contains on first index nonzeros per local row.
NNZ_D_MAT_Z(:) = 0
JD_MAT_Z(:,:)  = HUGE(I)

! Find NM_START: first mesh that belongs to the processor.
NM_START = CC_UNDEFINED
DO NM=1,NMESHES
   IF (PROCESS(NM)/=MY_RANK) CYCLE
   NM_START = NM
   EXIT
ENDDO

! 8. Build Mass (volumes) matrix for scalars:
CALL GET_MMATRIX_SCALAR_3D

! Allocate rhs and solution arrays for species:
ALLOCATE( F_Z(1:NUNKZ_LOCAL) , F_Z0(1:NUNKZ_LOCAL,1:N_TOTAL_SCALARS) , RZ_Z(1:NUNKZ_LOCAL) , RZ_ZS(1:NUNKZ_LOCAL) )
ALLOCATE( RZ_Z0(1:NUNKZ_LOCAL,1:N_TOTAL_SCALARS) )
ALLOCATE( P_0_CV(1:NUNKZ_LOCAL), TMP_0_CV(1:NUNKZ_LOCAL), RHO_0_CV(1:NUNKZ_LOCAL), ZCEN_CV(1:NUNKZ_LOCAL) )

RETURN
END SUBROUTINE SET_CC_MATVEC_DATA


! ------------------------- GET_RCEDGE_FACE_LIST --------------------------------

SUBROUTINE GET_RCEDGE_FACE_LIST

INTEGER :: NM,ICF,JCF,I,J,K,X1AXIS,EAXIS,LOHI_AXIS,IRC,ISIDE,HILO
TYPE(MESH_TYPE), POINTER :: M=>NULL()

MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   M=>MESHES(NM)
   ! X axis edges:
   EAXIS = IAXIS
   DO K=0,M%KBAR
      DO J=0,M%JBAR
         DO I=1,M%IBAR
            IRC = M%ECVAR(I,J,K,CC_IDCE,EAXIS)
            IF (M%ECVAR(I,J,K,CC_EGSC,EAXIS)/=CC_GASPHASE .OR. IRC<1) CYCLE
            ALLOCATE(M%CC_RCEDGE(IRC)%FACE_LIST(1:3,-2:2)); M%CC_RCEDGE(IRC)%FACE_LIST = CC_UNDEFINED
            ! Faces -1 and 1 : KAXIS, I,J,K and KAXIS I,J+1,K
            X1AXIS = KAXIS; LOHI_AXIS = JAXIS
            DO ISIDE=0,1
               IF(M%FCVAR(I,J+ISIDE,K,CC_IDCF,X1AXIS)>0) THEN ! CUT_FACE
                  ICF = M%FCVAR(I,J+ISIDE,K,CC_IDCF,X1AXIS)
                  ! Find which cut-face in ICF entry has the RCEDGE(IRC) as boundary:
                  HILO=2-ISIDE ! 2=HIGH_IND side reg edge for face; 1=LOW_IND reg side edge.
                  CALL GET_RCEDGE_CUTFACE(NM,LOHI_AXIS,HILO,ICF,JCF)
                  M%CC_RCEDGE(IRC)%FACE_LIST(1:3,2*ISIDE-1) = (/ CC_FTYPE_CFGAS, ICF, JCF /)
               ELSEIF (M%FCVAR(I,J+ISIDE,K,CC_IDRC,X1AXIS)>0) THEN ! RCFACE
                  ICF = M%FCVAR(I,J+ISIDE,K,CC_IDRC,X1AXIS)
                  M%CC_RCEDGE(IRC)%FACE_LIST(1:3,2*ISIDE-1) = (/ CC_FTYPE_RCGAS, ICF,   0 /)
               ELSE ! Regular gas face. There can be no solid faces adjacent to an RCEDGE.
                  M%CC_RCEDGE(IRC)%FACE_LIST(1:3,2*ISIDE-1) = (/ CC_FTYPE_RGGAS,   0,   0 /)
               ENDIF
            ENDDO
            ! Faces -2 and 2 : JAXIS, I,J,K and JAXIS I,J,K+1
            X1AXIS = JAXIS; LOHI_AXIS = KAXIS
            DO ISIDE=0,1
               IF(M%FCVAR(I,J,K+ISIDE,CC_IDCF,X1AXIS)>0) THEN ! CUT_FACE
                  ICF = M%FCVAR(I,J,K+ISIDE,CC_IDCF,X1AXIS)
                  ! Find which cut-face in ICF entry has the RCEDGE(IRC) as boundary:
                  HILO=2-ISIDE ! 2=HIGH_IND side reg edge for face; 1=LOW_IND reg side edge.
                  CALL GET_RCEDGE_CUTFACE(NM,LOHI_AXIS,HILO,ICF,JCF)
                  M%CC_RCEDGE(IRC)%FACE_LIST(1:3,4*ISIDE-2) = (/ CC_FTYPE_CFGAS, ICF, JCF /)
               ELSEIF (M%FCVAR(I,J,K+ISIDE,CC_IDRC,X1AXIS)>0) THEN ! RCFACE
                  ICF = M%FCVAR(I,J,K+ISIDE,CC_IDRC,X1AXIS)
                  M%CC_RCEDGE(IRC)%FACE_LIST(1:3,4*ISIDE-2) = (/ CC_FTYPE_RCGAS, ICF,   0 /)
               ELSE ! Regular gas face. There can be no solid faces adjacent to an RCEDGE.
                  M%CC_RCEDGE(IRC)%FACE_LIST(1:3,4*ISIDE-2) = (/ CC_FTYPE_RGGAS,   0,   0 /)
               ENDIF
            ENDDO
         ENDDO
      ENDDO
   ENDDO

   ! Y axis edges:
   EAXIS = JAXIS
   DO K=0,M%KBAR
      DO J=1,M%JBAR
         DO I=0,M%IBAR
            IRC = M%ECVAR(I,J,K,CC_IDCE,EAXIS)
            IF (M%ECVAR(I,J,K,CC_EGSC,EAXIS)/=CC_GASPHASE .OR. IRC<1) CYCLE
            ALLOCATE(M%CC_RCEDGE(IRC)%FACE_LIST(1:3,-2:2)); M%CC_RCEDGE(IRC)%FACE_LIST = CC_UNDEFINED
            ! Faces -1 and 1 : IAXIS, I,J,K and IAXIS I,J,K+1
            X1AXIS = IAXIS; LOHI_AXIS = KAXIS
            DO ISIDE=0,1
               IF(M%FCVAR(I,J,K+ISIDE,CC_IDCF,X1AXIS)>0) THEN ! CUT_FACE
                  ICF = M%FCVAR(I,J,K+ISIDE,CC_IDCF,X1AXIS)
                  ! Find which cut-face in ICF entry has the RCEDGE(IRC) as boundary:
                  HILO=2-ISIDE ! 2=HIGH_IND side reg edge for face; 1=LOW_IND reg side edge.
                  CALL GET_RCEDGE_CUTFACE(NM,LOHI_AXIS,HILO,ICF,JCF)
                  M%CC_RCEDGE(IRC)%FACE_LIST(1:3,2*ISIDE-1) = (/ CC_FTYPE_CFGAS, ICF, JCF /)
               ELSEIF (M%FCVAR(I,J,K+ISIDE,CC_IDRC,X1AXIS)>0) THEN ! RCFACE
                  ICF = M%FCVAR(I,J,K+ISIDE,CC_IDRC,X1AXIS)
                  M%CC_RCEDGE(IRC)%FACE_LIST(1:3,2*ISIDE-1) = (/ CC_FTYPE_RCGAS, ICF,   0 /)
               ELSE ! Regular gas face. There can be no solid faces adjacent to an RCEDGE.
                  M%CC_RCEDGE(IRC)%FACE_LIST(1:3,2*ISIDE-1) = (/ CC_FTYPE_RGGAS,   0,   0 /)
               ENDIF
            ENDDO
            ! Faces -2 and 2 : KAXIS, I,J,K and KAXIS I+1,J,K
            X1AXIS = KAXIS; LOHI_AXIS = IAXIS
            DO ISIDE=0,1
               IF(M%FCVAR(I+ISIDE,J,K,CC_IDCF,X1AXIS)>0) THEN ! CUT_FACE
                  ICF = M%FCVAR(I+ISIDE,J,K,CC_IDCF,X1AXIS)
                  ! Find which cut-face in ICF entry has the RCEDGE(IRC) as boundary:
                  HILO=2-ISIDE ! 2=HIGH_IND side reg edge for face; 1=LOW_IND reg side edge.
                  CALL GET_RCEDGE_CUTFACE(NM,LOHI_AXIS,HILO,ICF,JCF)
                  M%CC_RCEDGE(IRC)%FACE_LIST(1:3,4*ISIDE-2) = (/ CC_FTYPE_CFGAS, ICF, JCF /)
               ELSEIF (M%FCVAR(I+ISIDE,J,K,CC_IDRC,X1AXIS)>0) THEN ! RCFACE
                  ICF = M%FCVAR(I+ISIDE,J,K,CC_IDRC,X1AXIS)
                  M%CC_RCEDGE(IRC)%FACE_LIST(1:3,4*ISIDE-2) = (/ CC_FTYPE_RCGAS, ICF,   0 /)
               ELSE ! Regular gas face. There can be no solid faces adjacent to an RCEDGE.
                  M%CC_RCEDGE(IRC)%FACE_LIST(1:3,4*ISIDE-2) = (/ CC_FTYPE_RGGAS,   0,   0 /)
               ENDIF
            ENDDO
         ENDDO
      ENDDO
   ENDDO

   ! Z axis edges:
   EAXIS = KAXIS
   DO K=1,M%KBAR
      DO J=0,M%JBAR
         DO I=0,M%IBAR
            IRC = M%ECVAR(I,J,K,CC_IDCE,EAXIS)
            IF (M%ECVAR(I,J,K,CC_EGSC,EAXIS)/=CC_GASPHASE .OR. IRC<1) CYCLE
            ALLOCATE(M%CC_RCEDGE(IRC)%FACE_LIST(1:3,-2:2)); M%CC_RCEDGE(IRC)%FACE_LIST = CC_UNDEFINED
            ! Faces -1 and 1 : JAXIS, I,J,K and JAXIS I+1,J,K
            X1AXIS = JAXIS; LOHI_AXIS = IAXIS
            DO ISIDE=0,1
               IF(M%FCVAR(I+ISIDE,J,K,CC_IDCF,X1AXIS)>0) THEN ! CUT_FACE
                  ICF = M%FCVAR(I+ISIDE,J,K,CC_IDCF,X1AXIS)
                  ! Find which cut-face in ICF entry has the RCEDGE(IRC) as boundary:
                  HILO=2-ISIDE ! 2=HIGH_IND side reg edge for face; 1=LOW_IND reg side edge.
                  CALL GET_RCEDGE_CUTFACE(NM,LOHI_AXIS,HILO,ICF,JCF)
                  M%CC_RCEDGE(IRC)%FACE_LIST(1:3,2*ISIDE-1) = (/ CC_FTYPE_CFGAS, ICF, JCF /)
               ELSEIF (M%FCVAR(I+ISIDE,J,K,CC_IDRC,X1AXIS)>0) THEN ! RCFACE
                  ICF = M%FCVAR(I+ISIDE,J,K,CC_IDRC,X1AXIS)
                  M%CC_RCEDGE(IRC)%FACE_LIST(1:3,2*ISIDE-1) = (/ CC_FTYPE_RCGAS, ICF,   0 /)
               ELSE ! Regular gas face. There can be no solid faces adjacent to an RCEDGE.
                  M%CC_RCEDGE(IRC)%FACE_LIST(1:3,2*ISIDE-1) = (/ CC_FTYPE_RGGAS,   0,   0 /)
               ENDIF
            ENDDO
            ! Faces -2 and 2 : IAXIS, I,J,K and IAXIS I,J+1,K
            X1AXIS = IAXIS; LOHI_AXIS = JAXIS
            DO ISIDE=0,1
               IF(M%FCVAR(I,J+ISIDE,K,CC_IDCF,X1AXIS)>0) THEN ! CUT_FACE
                  ICF = M%FCVAR(I,J+ISIDE,K,CC_IDCF,X1AXIS)
                  ! Find which cut-face in ICF entry has the RCEDGE(IRC) as boundary:
                  HILO=2-ISIDE ! 2=HIGH_IND side reg edge for face; 1=LOW_IND reg side edge.
                  CALL GET_RCEDGE_CUTFACE(NM,LOHI_AXIS,HILO,ICF,JCF)
                  M%CC_RCEDGE(IRC)%FACE_LIST(1:3,4*ISIDE-2) = (/ CC_FTYPE_CFGAS, ICF, JCF /)
               ELSEIF (M%FCVAR(I,J+ISIDE,K,CC_IDRC,X1AXIS)>0) THEN ! RCFACE
                  ICF = M%FCVAR(I,J+ISIDE,K,CC_IDRC,X1AXIS)
                  M%CC_RCEDGE(IRC)%FACE_LIST(1:3,4*ISIDE-2) = (/ CC_FTYPE_RCGAS, ICF,   0 /)
               ELSE ! Regular gas face. There can be no solid faces adjacent to an RCEDGE.
                  M%CC_RCEDGE(IRC)%FACE_LIST(1:3,4*ISIDE-2) = (/ CC_FTYPE_RGGAS,   0,   0 /)
               ENDIF
            ENDDO
         ENDDO
      ENDDO
   ENDDO

   ! DO IRC=1,M%CC_NRCEDGE_Z
   !    WRITE(LU_ERR,*) ' '
   !    WRITE(LU_ERR,*) 'IRC=',IRC,M%CC_RCEDGE(IRC)%IJK(1:4)
   !    WRITE(LU_ERR,*) '-2 =',M%CC_RCEDGE(IRC)%FACE_LIST(1:3,-2)
   !    WRITE(LU_ERR,*) '-1 =',M%CC_RCEDGE(IRC)%FACE_LIST(1:3,-1)
   !    WRITE(LU_ERR,*) ' 1 =',M%CC_RCEDGE(IRC)%FACE_LIST(1:3, 1)
   !    WRITE(LU_ERR,*) ' 2 =',M%CC_RCEDGE(IRC)%FACE_LIST(1:3, 2)
   ! ENDDO

ENDDO MESH_LOOP

END SUBROUTINE GET_RCEDGE_FACE_LIST


! ------------------------------ GET_RCEDGE_CUTFACE -----------------------------------

SUBROUTINE GET_RCEDGE_CUTFACE(NM,AXIS,SIDE,ICF,JCF)

INTEGER, INTENT(IN) :: NM,AXIS,SIDE,ICF
INTEGER, INTENT(OUT):: JCF

INTEGER :: IED,IEDGE
TYPE(CC_CUTFACE_TYPE), POINTER :: CF

CF=> MESHES(NM)%CUT_FACE(ICF)
DO JCF=1,CF%NFACE
   DO IED=2,CF%CEDGES(1,JCF)+1
      IEDGE=CF%CEDGES(IED,JCF)
      IF(CF%EDGE_LIST(1,IEDGE)/=CC_ETYPE_RGGAS) CYCLE  ! Regular gas edge, RCEDGES defined like this in
                                                        ! GET_CARTFACE_CUTFACES.
      IF(CF%EDGE_LIST(2,IEDGE)/=SIDE)            CYCLE  ! Edge in low or high side of face.
      IF(CF%EDGE_LIST(3,IEDGE)/=AXIS)            CYCLE  ! Direction in which edge is low or high resp to face.
      RETURN
   ENDDO
ENDDO

END SUBROUTINE GET_RCEDGE_CUTFACE


! ------------------------- DEFINE_SHARED_FACES --------------------------------
SUBROUTINE DEFINE_SHARED_FACES

! Once cells have been linked, regular and RC faces shared by linked cells are defined as SHARED=.TRUE.

INTEGER :: NM,ICF,JCF,I,J,K,X1AXIS

DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   CALL POINT_TO_MESH(NM)
   ! First cut-faces:
   DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      IF(CUT_FACE(ICF)%STATUS/=CC_GASPHASE) CYCLE
      CUT_FACE(ICF)%SHARED = .FALSE.
      DO JCF=1,CUT_FACE(ICF)%NFACE
         IF(CUT_FACE(ICF)%UNKZ(LOW_IND,JCF)==CUT_FACE(ICF)%UNKZ(HIGH_IND,JCF)) &
         CUT_FACE(ICF)%SHARED(JCF) = .TRUE. ! This face is shared by two linked cut-cells.
      ENDDO
   ENDDO
   ! Then RC faces:
   FCVAR(:,:,:,CC_IDRC,:) = 0
   DO ICF=1,MESHES(NM)%CC_NRCFACE_Z
      ! Add ICF position in FCVAR(I,J,K,CC_IDRC,X1AXIS):
      I      = RC_FACE(ICF)%IJK(IAXIS)
      J      = RC_FACE(ICF)%IJK(JAXIS)
      K      = RC_FACE(ICF)%IJK(KAXIS)
      X1AXIS = RC_FACE(ICF)%IJK(KAXIS+1)
      FCVAR(I,J,K,CC_IDRC,X1AXIS) = ICF
      ! Then set if SHARED:
      IF(RC_FACE(ICF)%UNKZ(LOW_IND)==RC_FACE(ICF)%UNKZ(HIGH_IND)) RC_FACE(ICF)%SHAREDZ = .TRUE.
   ENDDO

ENDDO

RETURN
END SUBROUTINE DEFINE_SHARED_FACES

! --------------------- GET_BOUNDFACE_GEOM_INFO_H --------------------------------
SUBROUTINE GET_BOUNDFACE_GEOM_INFO_H

! Work deferred.

RETURN
END SUBROUTINE GET_BOUNDFACE_GEOM_INFO_H

! ----------------------- FILL_UNKZ_GUARDCELLS ---------------------------------
SUBROUTINE FILL_UNKZ_GUARDCELLS

USE MPI_F08

! Local Variables:
INTEGER :: NM,NOM,IERR
TYPE (MESH_TYPE), POINTER :: M
TYPE (OMESH_TYPE), POINTER :: M2,M3
TYPE (MPI_REQUEST), ALLOCATABLE, DIMENSION(:) :: REQ0,REQ0DUM
INTEGER :: N_REQ0, NICC_R, ICC, ICC1, NCELL, JCC, NICF_R, ICF
INTEGER, ALLOCATABLE, DIMENSION(:) :: NCC_SV
INTEGER :: ISTR,IEND,JSTR,JEND,KSTR,KEND,IIO,JJO,KKO,IOR,IW,N_INT,IIOF,JJOF,KKOF,X1AXIS
LOGICAL :: ALL_FLG
INTEGER, ALLOCATABLE, DIMENSION(:) :: INT1D


! First allocate buffers to receive UNKZ information:
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   DO NOM=1,NMESHES
      IF (MESHES(NM)%OMESH(NOM)%NIC_R>0) THEN
         M3 => MESHES(NM)%OMESH(NOM)
         ALLOCATE(M3%UNKZ_CT_R(M3%NIC_R))
      ENDIF
      IF (MESHES(NM)%OMESH(NOM)%NICC_R(1)>0) THEN
         M3 => MESHES(NM)%OMESH(NOM)
         ALLOCATE(M3%ICC_UNKZ_CC_R(3*M3%NICC_R(1))); M3%ICC_UNKZ_CC_R = CC_UNDEFINED
         ALLOCATE(M3%UNKZ_CC_R(M3%NICC_R(2)))

         ! Dump cut-cell indexes on sending mesh NOM, whose info will be received:
         NICC_R = 0
         CALL POINT_TO_MESH(NM)
         ! Loop over cut-cells:
         EXTERNAL_WALL_LOOP_1A : DO IW=1,N_EXTERNAL_WALL_CELLS
            WC=>WALL(IW)
            IF (.NOT.ANY(WC%BOUNDARY_TYPE==(/INTERPOLATED_BOUNDARY,MIRROR_BOUNDARY/))) CYCLE EXTERNAL_WALL_LOOP_1A
            EWC=>EXTERNAL_WALL(IW); BC=>BOUNDARY_COORD(WC%BC_INDEX)
            IF ( WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY ) THEN
               IF (EWC%NOM/=NOM) CYCLE EXTERNAL_WALL_LOOP_1A
               IF (CCVAR(BC%II,BC%JJ,BC%KK,CC_CGSC) /= CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_1A
               DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
                  DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                     DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                       ICC   = MESHES(NOM)%CCVAR(IIO,JJO,KKO,CC_IDCC)
                       IF (ICC > 0) THEN
                          NICC_R = NICC_R + 1
                          M3%ICC_UNKZ_CC_R(3*NICC_R-2:3*NICC_R) = (/ IIO, JJO, KKO /) ! Note : This ICC index refers to NOM mesh.
                       ENDIF
                     ENDDO
                  ENDDO
               ENDDO
            ELSEIF ( WC%BOUNDARY_TYPE==MIRROR_BOUNDARY ) THEN
               IF (NM/=NOM) CYCLE EXTERNAL_WALL_LOOP_1A
               IF (CCVAR(BC%II,BC%JJ,BC%KK,CC_CGSC) /= CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_1A
               IIO = BC%IIG; JJO = BC%JJG; KKO = BC%KKG; IOR = BC%IOR
               ! CYCLE if OBJECT face is in the Mirror Boundary, normal out into ghost-cell:
               SELECT CASE(IOR)
               CASE( IAXIS); IF(FCVAR(IIO-1,JJO  ,KKO  ,CC_FGSC,IAXIS) == CC_SOLID) CYCLE EXTERNAL_WALL_LOOP_1A
               CASE(-IAXIS); IF(FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,IAXIS) == CC_SOLID) CYCLE EXTERNAL_WALL_LOOP_1A
               CASE( JAXIS); IF(FCVAR(IIO  ,JJO-1,KKO  ,CC_FGSC,JAXIS) == CC_SOLID) CYCLE EXTERNAL_WALL_LOOP_1A
               CASE(-JAXIS); IF(FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,JAXIS) == CC_SOLID) CYCLE EXTERNAL_WALL_LOOP_1A
               CASE( KAXIS); IF(FCVAR(IIO  ,JJO  ,KKO-1,CC_FGSC,KAXIS) == CC_SOLID) CYCLE EXTERNAL_WALL_LOOP_1A
               CASE(-KAXIS); IF(FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,KAXIS) == CC_SOLID) CYCLE EXTERNAL_WALL_LOOP_1A
               END SELECT
               ICC = MESHES(NOM)%CCVAR(IIO,JJO,KKO,CC_IDCC); IF (ICC<1) CYCLE
               NICC_R = NICC_R + 1
               M3%ICC_UNKZ_CC_R(3*NICC_R-2:3*NICC_R) = (/ IIO, JJO, KKO /) ! Note : This ICC index refers to NOM==NM mesh.
            ENDIF
         ENDDO EXTERNAL_WALL_LOOP_1A
      ENDIF

      ! Count and add interpolated boundary cut-faces:
      MESHES(NM)%OMESH(NOM)%NICF_R(1) = 0
      MESHES(NM)%OMESH(NOM)%NICF_R(2) = 0
      CALL POINT_TO_MESH(NM)
      ! Loop over cut-cells:
      DO IW=1,N_EXTERNAL_WALL_CELLS
         WC=>WALL(IW); IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE
         EWC=>EXTERNAL_WALL(IW); IF (EWC%NOM/=NOM) CYCLE
         BC=>BOUNDARY_COORD(WC%BC_INDEX); IIO = BC%IIG; JJO = BC%JJG; KKO = BC%KKG
         SELECT CASE(BC%IOR)
         CASE( IAXIS); IF(FCVAR(IIO-1,JJO  ,KKO  ,CC_FGSC,IAXIS) /= CC_CUTCFE) CYCLE
         CASE(-IAXIS); IF(FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,IAXIS) /= CC_CUTCFE) CYCLE
         CASE( JAXIS); IF(FCVAR(IIO  ,JJO-1,KKO  ,CC_FGSC,JAXIS) /= CC_CUTCFE) CYCLE
         CASE(-JAXIS); IF(FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,JAXIS) /= CC_CUTCFE) CYCLE
         CASE( KAXIS); IF(FCVAR(IIO  ,JJO  ,KKO-1,CC_FGSC,KAXIS) /= CC_CUTCFE) CYCLE
         CASE(-KAXIS); IF(FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,KAXIS) /= CC_CUTCFE) CYCLE
         END SELECT
         DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
            DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
               DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                SELECT CASE(-BC%IOR)
                CASE( IAXIS); ICF=MESHES(NOM)%FCVAR(IIO-1,JJO  ,KKO  ,CC_IDCF,IAXIS)
                CASE(-IAXIS); ICF=MESHES(NOM)%FCVAR(IIO  ,JJO  ,KKO  ,CC_IDCF,IAXIS)
                CASE( JAXIS); ICF=MESHES(NOM)%FCVAR(IIO  ,JJO-1,KKO  ,CC_IDCF,JAXIS)
                CASE(-JAXIS); ICF=MESHES(NOM)%FCVAR(IIO  ,JJO  ,KKO  ,CC_IDCF,JAXIS)
                CASE( KAXIS); ICF=MESHES(NOM)%FCVAR(IIO  ,JJO  ,KKO-1,CC_IDCF,KAXIS)
                CASE(-KAXIS); ICF=MESHES(NOM)%FCVAR(IIO  ,JJO  ,KKO  ,CC_IDCF,KAXIS)
                END SELECT
                IF (ICF > 0) THEN
                   MESHES(NM)%OMESH(NOM)%NICF_R(1) = MESHES(NM)%OMESH(NOM)%NICF_R(1) + 1
                   MESHES(NM)%OMESH(NOM)%NICF_R(2) = MESHES(NM)%OMESH(NOM)%NICF_R(2) + &
                                                     MESHES(NOM)%CUT_FACE(ICF)%NFACE
                ENDIF
               ENDDO
            ENDDO
         ENDDO
      ENDDO
      IF (MESHES(NM)%OMESH(NOM)%NICF_R(1)>0) THEN
         M3 => MESHES(NM)%OMESH(NOM)
         ALLOCATE(M3%ICF_UFFB_CF_R(4*M3%NICF_R(1)))
         ! Dump cut-cell indexes on sending mesh NOM, whose info will be received:
         NICF_R = 0
         CALL POINT_TO_MESH(NM)
         ! Loop over cut-cells:
         EXTERNAL_WALL_LOOP_1B : DO IW=1,N_EXTERNAL_WALL_CELLS
            WC=>WALL(IW)
            IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE EXTERNAL_WALL_LOOP_1B
            EWC=>EXTERNAL_WALL(IW); IF (EWC%NOM/=NOM) CYCLE EXTERNAL_WALL_LOOP_1B
            BC=>BOUNDARY_COORD(WC%BC_INDEX)
            IIO = BC%IIG; JJO = BC%JJG; KKO = BC%KKG
            SELECT CASE(BC%IOR)
            CASE( IAXIS); IF(FCVAR(IIO-1,JJO  ,KKO  ,CC_FGSC,IAXIS) /= CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_1B
            CASE(-IAXIS); IF(FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,IAXIS) /= CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_1B
            CASE( JAXIS); IF(FCVAR(IIO  ,JJO-1,KKO  ,CC_FGSC,JAXIS) /= CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_1B
            CASE(-JAXIS); IF(FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,JAXIS) /= CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_1B
            CASE( KAXIS); IF(FCVAR(IIO  ,JJO  ,KKO-1,CC_FGSC,KAXIS) /= CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_1B
            CASE(-KAXIS); IF(FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,KAXIS) /= CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_1B
            END SELECT
            DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
               DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
                  DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                   IIOF=IIO; JJOF=JJO; KKOF=KKO
                   SELECT CASE(-BC%IOR)
                   CASE( IAXIS); IIOF=IIO-1
                   CASE( JAXIS); JJOF=JJO-1
                   CASE( KAXIS); KKOF=KKO-1
                   END SELECT
                   ICF=MESHES(NOM)%FCVAR(IIOF,JJOF,KKOF,CC_IDCF,ABS(BC%IOR))
                   IF (ICF > 0) THEN
                      NICF_R = NICF_R + 1
                      M3%ICF_UFFB_CF_R(4*NICF_R-3:4*NICF_R) = (/IIOF,JJOF,KKOF,ABS(BC%IOR)/) ! Note:ICF index refers to NOM mesh
                      CF => MESHES(NOM)%CUT_FACE(ICF)
                      IF(ALLOCATED(CF%VELS_OMESH)) DEALLOCATE(CF%VELS_OMESH)
                      IF(ALLOCATED(CF% VEL_OMESH)) DEALLOCATE(CF% VEL_OMESH)
                      IF(ALLOCATED(CF% VEL_LNK)) DEALLOCATE(CF% VEL_LNK) ! For special cases of grid refinement.
                      IF(ALLOCATED(CF% VEL_LNK_OMESH)) DEALLOCATE(CF% VEL_LNK_OMESH)
                      IF(ALLOCATED(CF%  FN_OMESH)) DEALLOCATE(CF%  FN_OMESH)
                      ALLOCATE(CF%VELS_OMESH(1:CF%NFACE));     CF%   VELS_OMESH = 0._EB
                      ALLOCATE(CF% VEL_OMESH(1:CF%NFACE));     CF%    VEL_OMESH = 0._EB
                      ALLOCATE(CF% VEL_LNK(1:CF%NFACE));       CF%      VEL_LNK = 0._EB
                      ALLOCATE(CF% VEL_LNK_OMESH(1:CF%NFACE)); CF%VEL_LNK_OMESH = 0._EB
                      ALLOCATE(CF%  FN_OMESH(1:CF%NFACE));     CF%     FN_OMESH = 0._EB
                   ENDIF
                  ENDDO
               ENDDO
            ENDDO
         ENDDO EXTERNAL_WALL_LOOP_1B
      ENDIF

      ! Here allocate in M3 U_LNK,V_LNK,W_LNK if necessary:
      ! Here test should be done to figure out if any of the faces exchanged is actually a linked face.
      ! For now assume there are:
      IF (MESHES(NM)%OMESH(NOM)%NIC_R > 0) THEN ! There are velocity variables to receive from NOM.
         M3 => MESHES(NM)%OMESH(NOM)
         M3%NLKF_R = (M3%I_MAX_R-M3%I_MIN_R+1)*(M3%J_MAX_R-M3%J_MIN_R+1)*(M3%K_MAX_R-M3%K_MIN_R+1)
         IF(ALLOCATED(M3%U_LNK)) DEALLOCATE(M3%U_LNK)
         IF(ALLOCATED(M3%V_LNK)) DEALLOCATE(M3%V_LNK)
         IF(ALLOCATED(M3%W_LNK)) DEALLOCATE(M3%W_LNK)
         ALLOCATE(M3%U_LNK(M3%I_MIN_R:M3%I_MAX_R,M3%J_MIN_R:M3%J_MAX_R,M3%K_MIN_R:M3%K_MAX_R))
         ALLOCATE(M3%V_LNK(M3%I_MIN_R:M3%I_MAX_R,M3%J_MIN_R:M3%J_MAX_R,M3%K_MIN_R:M3%K_MAX_R))
         ALLOCATE(M3%W_LNK(M3%I_MIN_R:M3%I_MAX_R,M3%J_MIN_R:M3%J_MAX_R,M3%K_MIN_R:M3%K_MAX_R))
         M3%U_LNK = 0._EB; M3%V_LNK = 0._EB; M3%W_LNK = 0._EB
      ENDIF
      IF (MESHES(NM)%OMESH(NOM)%NIC_S>0) THEN
         M3 => MESHES(NM)%OMESH(NOM)
         M3%NLKF_S = (M3%I_MAX_S-M3%I_MIN_S+1)*(M3%J_MAX_S-M3%J_MIN_S+1)*(M3%K_MAX_S-M3%K_MIN_S+1)
      ENDIF
   ENDDO
ENDDO

CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)

IF (N_MPI_PROCESSES>1) ALLOCATE(REQ0(NMESHES))
! Exchange number of cut-cells information to be exchanged between MESH and OMESHES:
N_REQ0 = 0
DO NM=1,NMESHES
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MY_RANK .AND. MESHES(NOM)%CONNECTED_MESH(NM)) THEN
         M2 => MESHES(NOM)%OMESH(NM)
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_IRECV(M2%NICC_S(1),2,MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ENDIF
   ENDDO
ENDDO
! DEFINITION NCC_S:   MESHES(NOM)%OMESH(NM)%NCC_S   = MESHES(NM)%OMESH(NOM)%NCC_R
DO NM=1,NMESHES
   CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)  ! This call orders the sending mesh by mesh.
   IF (PROCESS(NM)/=MY_RANK) CYCLE
   DO NOM=1,NMESHES
      IF (NM/=NOM .AND. .NOT.MESHES(NM)%CONNECTED_MESH(NOM)) CYCLE
      M3 => MESHES(NM)%OMESH(NOM)
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NOM)/=MY_RANK .AND. MESHES(NM)%CONNECTED_MESH(NOM)) THEN
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_ISEND(M3%NICC_R(1),2,MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ELSE
         ! 2D, NM/NOM, CONNECTED_MESH=F and Several MPI process run.
         IF(.NOT. ALLOCATED(MESHES(NOM)%OMESH)) CYCLE
         M2 => MESHES(NOM)%OMESH(NM)
         M2%NICC_S(1:2) = M3%NICC_R(1:2)
      ENDIF
   ENDDO
ENDDO
IF ((N_REQ0>0) .AND. (N_MPI_PROCESSES>1)) CALL MPI_WAITALL(N_REQ0,REQ0(1:N_REQ0),MPI_STATUSES_IGNORE,IERR)
! At this point values of M2%NICC_S should have been received.
! Definition: MESHES(NOM)%OMESH(NM)%UNKZ_CT_S(:) = MESHES(NM)%OMESH(NOM)%UNKZ_CT_R(:)
!             MESHES(NOM)%OMESH(NM)%UNKZ_CC_S(:) = MESHES(NM)%OMESH(NOM)%UNKZ_CC_R(:)
! Now allocate buffers to send UNKZ information:
DO NM=1,NMESHES
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      IF (MESHES(NOM)%OMESH(NM)%NIC_S>0) THEN
         M2 => MESHES(NOM)%OMESH(NM)
         ALLOCATE(M2%UNKZ_CT_S(M2%NIC_S))
      ENDIF

      IF (MESHES(NOM)%OMESH(NM)%NICC_S(1)>0) THEN
         M2 => MESHES(NOM)%OMESH(NM)
         ALLOCATE(M2%ICC_UNKZ_CC_S(3*M2%NICC_S(1))); M2%ICC_UNKZ_CC_S = CC_UNDEFINED
         ALLOCATE(M2%UNKZ_CC_S(M2%NICC_S(2)))
      ENDIF
   ENDDO
ENDDO

! Exchange list of cutcells in ICC_UNKZ_CC_S/R:
N_REQ0 = 0
DO NM=1,NMESHES
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      M2 => MESHES(NOM)%OMESH(NM)
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MY_RANK .AND. M2%NICC_S(1)>0) THEN
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_IRECV(M2%ICC_UNKZ_CC_S(1),3*M2%NICC_S(1),MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ENDIF
   ENDDO
ENDDO
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   DO NOM=1,NMESHES
      M3 => MESHES(NM)%OMESH(NOM)
      IF (M3%NICC_R(1)<1) CYCLE
      IF (PROCESS(NOM)/=MY_RANK) THEN
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_ISEND(M3%ICC_UNKZ_CC_R(1),3*M3%NICC_R(1),MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ELSE
         M2 => MESHES(NOM)%OMESH(NM)
         M2%ICC_UNKZ_CC_S(1:3*M2%NICC_S(1)) = M3%ICC_UNKZ_CC_R(1:3*M3%NICC_R(1))
         ! Here write the ICC into ICC_UNKZ_CC_S for OMESH NM:
         M => MESHES(NOM); DO ICC1=1,M2%NICC_S(1)
            IIO=M2%ICC_UNKZ_CC_S(3*ICC1-2)
            JJO=M2%ICC_UNKZ_CC_S(3*ICC1-1)
            KKO=M2%ICC_UNKZ_CC_S(3*ICC1  )
            M2%ICC_UNKZ_CC_S(ICC1) = M%CCVAR(IIO,JJO,KKO,CC_IDCC)
         ENDDO
         ALLOCATE(INT1D(1:M2%NICC_S(1))); INT1D(1:M2%NICC_S(1)) = M2%ICC_UNKZ_CC_S(1:M2%NICC_S(1))
         CALL MOVE_ALLOC(FROM=INT1D,TO=M2%ICC_UNKZ_CC_S)
      ENDIF
   ENDDO
ENDDO
IF ((N_REQ0>0) .AND. (N_MPI_PROCESSES>1)) CALL MPI_WAITALL(N_REQ0,REQ0(1:N_REQ0),MPI_STATUSES_IGNORE,IERR)

DO NM=1,NMESHES
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      M2 => MESHES(NOM)%OMESH(NM)
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MY_RANK .AND. M2%NICC_S(1)>0) THEN
         ! Here write the ICC into ICC_UNKZ_CC_S for OMESH NM:
         M => MESHES(NOM); DO ICC1=1,M2%NICC_S(1)
            IIO=M2%ICC_UNKZ_CC_S(3*ICC1-2)
            JJO=M2%ICC_UNKZ_CC_S(3*ICC1-1)
            KKO=M2%ICC_UNKZ_CC_S(3*ICC1  )
            M2%ICC_UNKZ_CC_S(ICC1) = M%CCVAR(IIO,JJO,KKO,CC_IDCC)
         ENDDO
         ALLOCATE(INT1D(1:M2%NICC_S(1))); INT1D(1:M2%NICC_S(1)) = M2%ICC_UNKZ_CC_S(1:M2%NICC_S(1))
         CALL MOVE_ALLOC(FROM=INT1D,TO=M2%ICC_UNKZ_CC_S)
      ENDIF
   ENDDO
ENDDO
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   DO NOM=1,NMESHES
      M3 => MESHES(NM)%OMESH(NOM)
      IF (M3%NICC_R(1)<1) CYCLE
      M => MESHES(NOM); DO ICC1=1,M3%NICC_R(1)
         IIO=M3%ICC_UNKZ_CC_R(3*ICC1-2)
         JJO=M3%ICC_UNKZ_CC_R(3*ICC1-1)
         KKO=M3%ICC_UNKZ_CC_R(3*ICC1  )
         M3%ICC_UNKZ_CC_R(ICC1) = M%CCVAR(IIO,JJO,KKO,CC_IDCC)
      ENDDO
      ALLOCATE(INT1D(1:M3%NICC_R(1))); INT1D(1:M3%NICC_R(1)) = M3%ICC_UNKZ_CC_R(1:M3%NICC_R(1))
      CALL MOVE_ALLOC(FROM=INT1D,TO=M3%ICC_UNKZ_CC_R)
   ENDDO
ENDDO

! Then exchange cut-face ICF values:
N_REQ0 = 0
DO NM=1,NMESHES
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MY_RANK .AND. MESHES(NOM)%CONNECTED_MESH(NM)) THEN
         M2 => MESHES(NOM)%OMESH(NM)
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_IRECV(M2%NICF_S(1),2,MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ENDIF
   ENDDO
ENDDO
DO NM=1,NMESHES
   CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)  ! This call orders the sending mesh by mesh.
   IF (PROCESS(NM)/=MY_RANK) CYCLE
   DO NOM=1,NMESHES
      IF (NM/=NOM .AND. .NOT.MESHES(NM)%CONNECTED_MESH(NOM)) CYCLE
      M3 => MESHES(NM)%OMESH(NOM)
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NOM)/=MY_RANK .AND. MESHES(NM)%CONNECTED_MESH(NOM)) THEN
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_ISEND(M3%NICF_R(1),2,MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ELSE
         ! 2D, NM/NOM, CONNECTED_MESH=F and Several MPI process run.
         IF(.NOT. ALLOCATED(MESHES(NOM)%OMESH)) CYCLE
         M2 => MESHES(NOM)%OMESH(NM)
         M2%NICF_S(1:2) = M3%NICF_R(1:2)
      ENDIF
   ENDDO
ENDDO
IF ((N_REQ0>0) .AND. (N_MPI_PROCESSES>1)) CALL MPI_WAITALL(N_REQ0,REQ0(1:N_REQ0),MPI_STATUSES_IGNORE,IERR)

! Now allocate buffers to send ICF information:
DO NM=1,NMESHES
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      IF (MESHES(NOM)%OMESH(NM)%NICF_S(1)>0) THEN
         M2 => MESHES(NOM)%OMESH(NM)
         ALLOCATE(M2%ICF_UFFB_CF_S(4*M2%NICF_S(1)))
      ENDIF
   ENDDO
ENDDO
N_REQ0 = 0
DO NM=1,NMESHES
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      M2 => MESHES(NOM)%OMESH(NM)
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MY_RANK .AND. M2%NICF_S(1)>0) THEN
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_IRECV(M2%ICF_UFFB_CF_S(1),4*M2%NICF_S(1),MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ENDIF
   ENDDO
ENDDO
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   DO NOM=1,NMESHES
      M3 => MESHES(NM)%OMESH(NOM)
      IF (M3%NICF_R(1)<1) CYCLE
      IF (PROCESS(NOM)/=MY_RANK) THEN
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_ISEND(M3%ICF_UFFB_CF_R(1),4*M3%NICF_R(1),MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ELSE
         M2 => MESHES(NOM)%OMESH(NM)
         M2%ICF_UFFB_CF_S(1:4*M2%NICF_S(1)) = M3%ICF_UFFB_CF_R(1:4*M3%NICF_R(1))
         ! Here write the ICF into ICF_UFFB_CF_S for OMESH NM:
         M => MESHES(NOM); DO ICF=1,M2%NICF_S(1)
            IIOF= M2%ICF_UFFB_CF_S(4*ICF-3)
            JJOF= M2%ICF_UFFB_CF_S(4*ICF-2)
            KKOF= M2%ICF_UFFB_CF_S(4*ICF-1)
            X1AXIS=M2%ICF_UFFB_CF_S(4*ICF)
            M2%ICF_UFFB_CF_S(ICF) = M%FCVAR(IIOF,JJOF,KKOF,CC_IDCF,X1AXIS)
         ENDDO
         ALLOCATE(INT1D(1:M2%NICF_S(1))); INT1D(1:M2%NICF_S(1)) = M2%ICF_UFFB_CF_S(1:M2%NICF_S(1))
         CALL MOVE_ALLOC(FROM=INT1D,TO=M2%ICF_UFFB_CF_S)
      ENDIF
   ENDDO
ENDDO
IF ((N_REQ0>0) .AND. (N_MPI_PROCESSES>1)) CALL MPI_WAITALL(N_REQ0,REQ0(1:N_REQ0),MPI_STATUSES_IGNORE,IERR)
DO NM=1,NMESHES
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      M2 => MESHES(NOM)%OMESH(NM)
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MY_RANK .AND. M2%NICF_S(1)>0) THEN
         ! Here write the ICF into ICF_UFFB_CF_S for OMESH NM:
         M => MESHES(NOM); DO ICF=1,M2%NICF_S(1)
            IIOF= M2%ICF_UFFB_CF_S(4*ICF-3)
            JJOF= M2%ICF_UFFB_CF_S(4*ICF-2)
            KKOF= M2%ICF_UFFB_CF_S(4*ICF-1)
            X1AXIS=M2%ICF_UFFB_CF_S(4*ICF)
            M2%ICF_UFFB_CF_S(ICF) = M%FCVAR(IIOF,JJOF,KKOF,CC_IDCF,X1AXIS)
         ENDDO
         ALLOCATE(INT1D(1:M2%NICF_S(1))); INT1D(1:M2%NICF_S(1)) = M2%ICF_UFFB_CF_S(1:M2%NICF_S(1))
         CALL MOVE_ALLOC(FROM=INT1D,TO=M2%ICF_UFFB_CF_S)
      ENDIF
   ENDDO
ENDDO
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   DO NOM=1,NMESHES
      M3 => MESHES(NM)%OMESH(NOM)
      IF (M3%NICF_R(1)<1) CYCLE
      M => MESHES(NOM); DO ICF=1,M3%NICF_R(1)
         IIOF= M3%ICF_UFFB_CF_R(4*ICF-3)
         JJOF= M3%ICF_UFFB_CF_R(4*ICF-2)
         KKOF= M3%ICF_UFFB_CF_R(4*ICF-1)
         X1AXIS=M3%ICF_UFFB_CF_R(4*ICF)
         M3%ICF_UFFB_CF_R(ICF) = M%FCVAR(IIOF,JJOF,KKOF,CC_IDCF,X1AXIS)
      ENDDO
      ALLOCATE(INT1D(1:M3%NICF_R(1))); INT1D(1:M3%NICF_R(1)) = M3%ICF_UFFB_CF_R(1:M3%NICF_R(1))
      CALL MOVE_ALLOC(FROM=INT1D,TO=M3%ICF_UFFB_CF_R)
   ENDDO
ENDDO

! Allocate VEL_LNK on Sending cut-faces if not yet allocated:
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   DO NOM=1,NMESHES
      M3 => MESHES(NM)%OMESH(NOM)
      IF (M3%NICF_S(1)>0) THEN
         DO IW=1,M3%NICF_S(1)
            ICF=  M3%ICF_UFFB_CF_S(IW)
            IF (ICF<1) CYCLE
            CF => MESHES(NM)%CUT_FACE(ICF)
            IF(.NOT.ALLOCATED(MESHES(NM)%CUT_FACE(ICF)%VEL_LNK)) ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%VEL_LNK(1:CF%NFACE))
            MESHES(NM)%CUT_FACE(ICF)%VEL_LNK = 0._EB
         ENDDO
      ENDIF
   ENDDO
ENDDO

! Senders populate UNKZ_CC_S with computed UNKZ values:
ALLOCATE(NCC_SV(1:NMESHES));
DO NM=1,NMESHES
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      M2 => MESHES(NOM)%OMESH(NM)
      IF (M2%NICC_S(1)<1) CYCLE
      M => MESHES(NOM)
      NCC_SV(NOM) = 0
      DO ICC1=1,M2%NICC_S(1)
         ICC = M2%ICC_UNKZ_CC_S(ICC1)
         NCELL=M%CUT_CELL(ICC)%NCELL
         DO JCC=1,NCELL
            NCC_SV(NOM) = NCC_SV(NOM) + 1
            M2%UNKZ_CC_S(NCC_SV(NOM)) = M%CUT_CELL(ICC)%UNKZ(JCC)
         ENDDO
      ENDDO
   ENDDO
ENDDO
DEALLOCATE(NCC_SV)

! Finally exchange UNKZ values:
N_REQ0 = 0
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   DO NOM=1,NMESHES
      M3 => MESHES(NM)%OMESH(NOM)
      IF (M3%NICC_R(1)<1) CYCLE
      IF (PROCESS(NOM)/=MY_RANK) THEN
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_IRECV(M3%UNKZ_CC_R(1),M3%NICC_R(2),MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ELSE
         M2 => MESHES(NOM)%OMESH(NM)
         M3%UNKZ_CC_R(1:M3%NICC_R(2)) = M2%UNKZ_CC_S(1:M2%NICC_S(2))
      ENDIF
   ENDDO
ENDDO
DO NM=1,NMESHES
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      M2 => MESHES(NOM)%OMESH(NM)
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MY_RANK .AND. M2%NICC_S(1)>0) THEN
         N_REQ0 = N_REQ0 + 1; CALL CHECK_REQ0_SIZE
         CALL MPI_ISEND(M2%UNKZ_CC_S(1),M2%NICC_S(2),MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ENDIF
   ENDDO
ENDDO
IF ( (N_REQ0>0) .AND. (N_MPI_PROCESSES>1) ) CALL MPI_WAITALL(N_REQ0,REQ0(1:N_REQ0),MPI_STATUSES_IGNORE,IERR)

! Copy to guard-cell cut-cells:
ALLOCATE(NCC_SV(1:NMESHES));
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   M => MESHES(NM)
   NCC_SV(:)=0
   CALL POINT_TO_MESH(NM)
   ! Loop over cut-cells:
   EXTERNAL_WALL_LOOP_2 : DO IW=1,N_EXTERNAL_WALL_CELLS
      WC=>WALL(IW)
      EWC=>EXTERNAL_WALL(IW)
      BC=>BOUNDARY_COORD(WC%BC_INDEX)
      IF (.NOT.(WC%BOUNDARY_TYPE == INTERPOLATED_BOUNDARY .OR. &
                WC%BOUNDARY_TYPE == MIRROR_BOUNDARY) ) CYCLE EXTERNAL_WALL_LOOP_2
      IF ( WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY ) THEN
         IF (CCVAR(BC%II,BC%JJ,BC%KK,CC_CGSC) /= CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_2
         NOM = EWC%NOM
         DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
            DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
               DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                 ICC   = MESHES(NOM)%CCVAR(IIO,JJO,KKO,CC_IDCC)
                 IF (ICC > 0) THEN
                    DO JCC=1,MESHES(NOM)%CUT_CELL(ICC)%NCELL
                       NCC_SV(NOM)=NCC_SV(NOM)+1
                       MESHES(NOM)%CUT_CELL(ICC)%UNKZ(JCC) = M%OMESH(NOM)%UNKZ_CC_R(NCC_SV(NOM))
                    ENDDO
                 ENDIF
               ENDDO
            ENDDO
         ENDDO
      ELSEIF ( WC%BOUNDARY_TYPE==MIRROR_BOUNDARY ) THEN
         IIO = BC%IIG; JJO = BC%JJG; KKO = BC%KKG
         IF (CCVAR(BC%II,BC%JJ,BC%KK,CC_CGSC) /= CC_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_2
         ! CYCLE if OBJECT face is in the Mirror Boundary, normal out into ghost-cell:
         SELECT CASE(BC%IOR)
         CASE( IAXIS); IF(FCVAR(IIO-1,JJO  ,KKO  ,CC_FGSC,IAXIS) == CC_SOLID) CYCLE EXTERNAL_WALL_LOOP_2
         CASE(-IAXIS); IF(FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,IAXIS) == CC_SOLID) CYCLE EXTERNAL_WALL_LOOP_2
         CASE( JAXIS); IF(FCVAR(IIO  ,JJO-1,KKO  ,CC_FGSC,JAXIS) == CC_SOLID) CYCLE EXTERNAL_WALL_LOOP_2
         CASE(-JAXIS); IF(FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,JAXIS) == CC_SOLID) CYCLE EXTERNAL_WALL_LOOP_2
         CASE( KAXIS); IF(FCVAR(IIO  ,JJO  ,KKO-1,CC_FGSC,KAXIS) == CC_SOLID) CYCLE EXTERNAL_WALL_LOOP_2
         CASE(-KAXIS); IF(FCVAR(IIO  ,JJO  ,KKO  ,CC_FGSC,KAXIS) == CC_SOLID) CYCLE EXTERNAL_WALL_LOOP_2
         END SELECT
         NOM = NM; ICC = MESHES(NOM)%CCVAR(IIO,JJO,KKO,CC_IDCC)
         IF (ICC > 0) THEN
            DO JCC=1,MESHES(NOM)%CUT_CELL(ICC)%NCELL
               NCC_SV(NOM)=NCC_SV(NOM)+1
               MESHES(NOM)%CUT_CELL(ICC)%UNKZ(JCC) = M%OMESH(NOM)%UNKZ_CC_R(NCC_SV(NOM))
            ENDDO
         ENDIF
      ENDIF
   ENDDO EXTERNAL_WALL_LOOP_2
ENDDO
DEALLOCATE(NCC_SV)

! Finally Exchange Cartesian cell UNKZ:
IF (N_MPI_PROCESSES>1) THEN
   DO NM=1,NMESHES
      IF (MPI_COMM_NEIGHBORS(NM)==MPI_COMM_NULL) CYCLE
      M => MESHES(NM)
      ! X direction bounds:
      ILO_FACE = 0                    ! Low mesh boundary face index.
      IHI_FACE = M%IBAR               ! High mesh boundary face index.
      ISTR     = ILO_FACE - NGUARD    ! Allocation start x arrays.
      IEND     = IHI_FACE + NGUARD    ! Allocation end x arrays.

      ! Y direction bounds:
      JLO_FACE = 0                    ! Low mesh boundary face index.
      JHI_FACE = M%JBAR               ! High mesh boundary face index.
      JSTR     = JLO_FACE - NGUARD    ! Allocation start y arrays.
      JEND     = JHI_FACE + NGUARD    ! Allocation end y arrays.

      ! Z direction bounds:
      KLO_FACE = 0                    ! Low mesh boundary face index.
      KHI_FACE = M%KBAR               ! High mesh boundary face index.
      KSTR     = KLO_FACE - NGUARD    ! Allocation start z arrays.
      KEND     = KHI_FACE + NGUARD    ! Allocation end z arrays.

      ALL_FLG = .FALSE.
      IF (.NOT.ALLOCATED(M%CCVAR)) THEN; ALL_FLG=.TRUE.; ALLOCATE(M%CCVAR(ISTR:IEND,JSTR:JEND,KSTR:KEND,CC_UNKZ:CC_UNKZ)); ENDIF
      N_INT = (IEND-ISTR+1)*(JEND-JSTR+1)*(KEND-KSTR+1)
      CALL MPI_BCAST(M%CCVAR(ISTR,JSTR,KSTR,CC_UNKZ),N_INT,MPI_INTEGER,MPI_COMM_NEIGHBORS_ROOT(NM),MPI_COMM_NEIGHBORS(NM),IERR)
      IF (ALL_FLG) DEALLOCATE(M%CCVAR)
   ENDDO
ENDIF

IF (N_MPI_PROCESSES>1) THEN
   DEALLOCATE(REQ0)
   CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
ENDIF

RETURN

CONTAINS
SUBROUTINE CHECK_REQ0_SIZE
IF(N_REQ0>SIZE(REQ0,DIM=1)) THEN
   ALLOCATE(REQ0DUM(SIZE(REQ0,DIM=1)+NMESHES))
   REQ0DUM(1:N_REQ0-1) = REQ0(1:N_REQ0-1)
   CALL MOVE_ALLOC(REQ0DUM,REQ0)
ENDIF
END SUBROUTINE CHECK_REQ0_SIZE

END SUBROUTINE FILL_UNKZ_GUARDCELLS

! ----------------------------- GET_CC_UNKH ------------------------------------

SUBROUTINE GET_CC_UNKH(I,J,K,IUNKH)

INTEGER, INTENT(IN) :: I,J,K
INTEGER, INTENT(OUT):: IUNKH

! Local variable:
INTEGER :: ICC

IUNKH    = CC_UNDEFINED ! This is < 0.
! Regular gas cell, taken care of before.
! Check cut-cell:
ICC = CCVAR(I,J,K,CC_IDCC)
! If theres is a cut-cell ICC then CUT_CELL(ICC)%UNKH(1) has been populated.
IF (ICC > 0) IUNKH = CUT_CELL(ICC)%UNKH(1)

RETURN
END SUBROUTINE GET_CC_UNKH


! ----------------------------- GET_CC_IROW ------------------------------------

SUBROUTINE GET_CC_IROW(I,J,K,IPZ,IROW)

INTEGER, INTENT(IN) :: I,J,K,IPZ
INTEGER, INTENT(OUT):: IROW

! Local variable:
INTEGER :: ICC
IROW = CC_UNDEFINED ! This is < 0.
ICC  = CCVAR(I,J,K,CC_IDCC)
! If theres is a cut-cell ICC then CUT_CELL(ICC)%UNKH(1) has been populated.
IF (ICC > 0) IROW     = CUT_CELL(ICC)%UNKH(1) - ZONE_SOLVE(IPZ)%UNKH_IND(NM_START)

RETURN
END SUBROUTINE GET_CC_IROW

! ----------------------------- GET_CUTCELL_HP ------------------------------------


SUBROUTINE GET_CUTCELL_HP(NM,IPZ,HP)

INTEGER, INTENT(IN) :: NM,IPZ
REAL(EB), INTENT(INOUT), POINTER, DIMENSION(:,:,:) :: HP

! Local Variables:
INTEGER :: I,J,K,IROW,ICC

IF (PREDICTOR) THEN

   ! Note does not take into account ONE_UNKH_PER_CUTCELL:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      CC => MESHES(NM)%CUT_CELL(ICC); I = CC%IJK(IAXIS); J = CC%IJK(JAXIS); K = CC%IJK(KAXIS)
      IF(CELL(CELL_INDEX(I,J,K))%SOLID .OR. ZONE_SOLVE(PRESSURE_ZONE(I,J,K))%CONNECTED_ZONE_PARENT/=IPZ) CYCLE
      IROW = CC%UNKH(1) - ZONE_SOLVE(IPZ)%UNKH_IND(NM_START)
      ! Assign to cut-cell H:
      CC%H(1:CC%NCELL) = -ZONE_SOLVE(IPZ)%X_H(IROW)
      ! Assign to HP:
      HP(I,J,K) = -ZONE_SOLVE(IPZ)%X_H(IROW)
   ENDDO

ELSE

   ! Note does not take into account ONE_UNKH_PER_CUTCELL:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      CC => MESHES(NM)%CUT_CELL(ICC); I = CC%IJK(IAXIS); J = CC%IJK(JAXIS); K = CC%IJK(KAXIS)
      IF(CELL(CELL_INDEX(I,J,K))%SOLID .OR. ZONE_SOLVE(PRESSURE_ZONE(I,J,K))%CONNECTED_ZONE_PARENT/=IPZ) CYCLE
      IROW     = CC%UNKH(1) - ZONE_SOLVE(IPZ)%UNKH_IND(NM_START)
      ! Assign to cut-cell HS:
      CC%HS(1:CC%NCELL) = -ZONE_SOLVE(IPZ)%X_H(IROW)
      ! Assign to HP:
      HP(I,J,K) = -ZONE_SOLVE(IPZ)%X_H(IROW)
   ENDDO

ENDIF

RETURN
END SUBROUTINE GET_CUTCELL_HP

! ----------------------------- GET_CUTCELL_FH ------------------------------------

SUBROUTINE GET_CUTCELL_FH(NM,NUNKH,IPZ,F_H)

! NOTE : Assumes POINT_TO_MESH(NM) has been called.

INTEGER, INTENT(IN)     :: NM,NUNKH,IPZ
REAL(EB), INTENT(INOUT) :: F_H(1:NUNKH)

! Local Variables:
INTEGER :: IROW,ICC,JCC,I,J,K
REAL(EB):: DIV_FN, DIV_FN_VOL

CUTCELL_LOOP_A : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
   CC   => CUT_CELL(ICC); I = CC%IJK(IAXIS); J = CC%IJK(JAXIS); K = CC%IJK(KAXIS)
   IF(CELL(CELL_INDEX(I,J,K))%SOLID .OR. ZONE_SOLVE(PRESSURE_ZONE(I,J,K))%CONNECTED_ZONE_PARENT/=IPZ) CYCLE
   IROW =  CC%UNKH(1) - ZONE_SOLVE(IPZ)%UNKH_IND(NM_START)
   ! Here we add div(F) in the cut-cell and DDDT:
   DIV_FN_VOL = 0._EB
   DO JCC=1,CC%NCELL
      CALL GET_FN_DIVERGENCE_CUTCELL(ICC,JCC,DIV_FN,SUBSTRACT_BAROCLINIC=.FALSE.)
      DIV_FN_VOL = DIV_FN_VOL + DIV_FN*CC%VOLUME(JCC)
   ENDDO
   ! Add to F_H:
   F_H(IROW) = -(CC%DDDTVOL(1) + DIV_FN_VOL)
ENDDO CUTCELL_LOOP_A

RETURN
END SUBROUTINE GET_CUTCELL_FH

! ---------------------------- GET_H_MATRIX_CC ------------------------------------

SUBROUTINE GET_H_MATRIX_CC(NM,NM1,IPZ,D_MAT_HP)

! This routine assumes the calling subroutine has called POINT_TO_MESH for NM.

INTEGER, INTENT(IN) :: NM,NM1,IPZ
REAL(EB), POINTER, DIMENSION(:,:) :: D_MAT_HP

! Local Variables:
INTEGER :: X1AXIS,IFACE,ICF,I,J,K,IND(LOW_IND:HIGH_IND),IND_LOC(LOW_IND:HIGH_IND)
INTEGER :: LOCROW_1,LOCROW_2,ILOC,JLOC,JCOL,IROW
REAL(EB) :: AF,IDX,BIJ,KFACE(2,2)

IF (.NOT. ASSOCIATED(D_MAT_HP)) THEN
   WRITE(LU_ERR,*) 'GET_H_MATRIX_CC in geom.f90: Pointer D_MAT_HP not associated.'
   RETURN
ENDIF

! X direction bounds:
ILO_FACE = 0                ! Low mesh boundary face index.
IHI_FACE = IBAR             ! High mesh boundary face index.
ILO_CELL = ILO_FACE + 1     ! First internal cell index. See notes.
IHI_CELL = IHI_FACE         ! Last internal cell index.
! Y direction bounds:
JLO_FACE = 0                ! Low mesh boundary face index.
JHI_FACE = JBAR             ! High mesh boundary face index.
JLO_CELL = JLO_FACE + 1     ! First internal cell index. See notes.
JHI_CELL = JHI_FACE         ! Last internal cell index.
! Z direction bounds:
KLO_FACE = 0                ! Low mesh boundary face index.
KHI_FACE = KBAR             ! High mesh boundary face index.
KLO_CELL = KLO_FACE + 1     ! First internal cell index. See notes.
KHI_CELL = KHI_FACE         ! Last internal cell index.

! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
DO IFACE=1,MESHES(NM)%CC_NRCFACE_H
   RCF => RC_FACE(MESHES(NM)%RCF_H(IFACE));
   I   = RCF%IJK(IAXIS); J = RCF%IJK(JAXIS); K = RCF%IJK(KAXIS); X1AXIS = RCF%IJK(KAXIS+1)
   IF(ZONE_SOLVE(PRESSURE_ZONE(I,J,K))%CONNECTED_ZONE_PARENT/=IPZ) CYCLE
   ! Unknowns on related cells:
   IND(LOW_IND)  = RCF%UNKH(LOW_IND)
   IND(HIGH_IND) = RCF%UNKH(HIGH_IND)
   IND_LOC(LOW_IND) = IND(LOW_IND) - ZONE_SOLVE(IPZ)%UNKH_IND(NM1) ! All row indexes must refer to ind_loc.
   IND_LOC(HIGH_IND)= IND(HIGH_IND)- ZONE_SOLVE(IPZ)%UNKH_IND(NM1)
   ! Row ind(1),ind(2):
   LOCROW_1 = LOW_IND; LOCROW_2 = HIGH_IND
   SELECT CASE(X1AXIS)
      CASE(IAXIS)
         AF  = DY(J)*DZ(K)
         IDX = RDXN(I)
         IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
         IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
      CASE(JAXIS)
         AF  = DX(I)*DZ(K)
         IDX = RDYN(J)
         IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
         IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
      CASE(KAXIS)
         AF  = DX(I)*DY(J)
         IDX = RDZN(K)
         IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
         IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row.
   ENDSELECT
   IDX = 1._EB / ( RCF%XCEN(X1AXIS,HIGH_IND) - RCF%XCEN(X1AXIS,LOW_IND) )

   ! Now add to Adiff corresponding coeff:
   BIJ   = IDX*AF
   !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
   KFACE(1,1) = BIJ; KFACE(2,1) =-BIJ; KFACE(1,2) =-BIJ; KFACE(2,2) = BIJ
   DO ILOC=LOCROW_1,LOCROW_2   ! Local row number in Kface
      DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
          IROW=IND_LOC(ILOC)                                ! Process Local Unknown number.
          JCOL=RCF%JDH(ILOC,JLOC) ! Local position of coef in D_MAT_H
          ! Add coefficient:
          D_MAT_HP(JCOL,IROW) = D_MAT_HP(JCOL,IROW) + KFACE(ILOC,JLOC)
      ENDDO
   ENDDO
ENDDO

! Now Gasphase CUT_FACES:
DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
   CF =>  MESHES(NM)%CUT_FACE(ICF); IF ( CF%STATUS /= CC_GASPHASE ) CYCLE
   ! Drop if cut-face on a wall-cell, and type different than INTERPOLATED_BOUNDARY or PERIODIC_BOUNDARY.
   IF( CF%IWC > 0 ) THEN
      WC=>MESHES(NM)%WALL(CF%IWC)
      IF (.NOT.( WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) ) CYCLE
   ENDIF
   I = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
   IF(ZONE_SOLVE(PRESSURE_ZONE(I,J,K))%CONNECTED_ZONE_PARENT/=IPZ) CYCLE
   ! Row ind(1),ind(2):
   LOCROW_1 = LOW_IND; LOCROW_2 = HIGH_IND
   SELECT CASE(X1AXIS)
      CASE(IAXIS)
         IDX = RDXN(I)
         IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
         IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
      CASE(JAXIS)
         IDX = RDYN(J)
         IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
         IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
      CASE(KAXIS)
         IDX = RDZN(K)
         IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
         IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row.
   ENDSELECT
   DO IFACE=1,CF%NFACE
      ! Unknowns on related cells:
      IND(LOW_IND)     = CF%UNKH(LOW_IND,IFACE)
      IND(HIGH_IND)    = CF%UNKH(HIGH_IND,IFACE)
      IND_LOC(LOW_IND) = IND(LOW_IND) - ZONE_SOLVE(IPZ)%UNKH_IND(NM1) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- ZONE_SOLVE(IPZ)%UNKH_IND(NM1)
      AF = CF%AREA(IFACE)
      IDX= 1._EB/ ( CF%XCENHIGH(X1AXIS,IFACE) - CF%XCENLOW(X1AXIS, IFACE) )

      ! Now add to Adiff corresponding coeff:
      BIJ   = IDX*AF
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = BIJ; KFACE(2,1) =-BIJ; KFACE(1,2) =-BIJ; KFACE(2,2) = BIJ
      DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
         DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
               IROW=IND_LOC(ILOC)
               JCOL=CF%JDH(ILOC,JLOC,IFACE)
               ! Add coefficient:
               D_MAT_HP(JCOL,IROW) = D_MAT_HP(JCOL,IROW) + KFACE(ILOC,JLOC)
         ENDDO
      ENDDO
   ENDDO
ENDDO
RETURN
END SUBROUTINE GET_H_MATRIX_CC


! -------------------------- GET_CC_MATRIXGRAPH_H ---------------------------------

SUBROUTINE GET_CC_MATRIXGRAPH_H(NM,NM1,IPZ,LOOP_FLAG)

INTEGER, INTENT(IN) :: NM,NM1,IPZ
LOGICAL, INTENT(IN) :: LOOP_FLAG

! Local Variables:
INTEGER :: X1AXIS,IFACE,ICF,I,J,K,IND(LOW_IND:HIGH_IND),IND_LOC(LOW_IND:HIGH_IND)
INTEGER :: LOCROW_1,LOCROW_2,LOCROW,IIND,NII,ILOC

! X direction bounds:
ILO_FACE = 0                    ! Low mesh boundary face index.
IHI_FACE = MESHES(NM)%IBAR      ! High mesh boundary face index.
ILO_CELL = ILO_FACE + 1     ! First internal cell index. See notes.
IHI_CELL = IHI_FACE ! Last internal cell index.

! Y direction bounds:
JLO_FACE = 0                    ! Low mesh boundary face index.
JHI_FACE = MESHES(NM)%JBAR      ! High mesh boundary face index.
JLO_CELL = JLO_FACE + 1     ! First internal cell index. See notes.
JHI_CELL = JHI_FACE ! Last internal cell index.

! Z direction bounds:
KLO_FACE = 0                    ! Low mesh boundary face index.
KHI_FACE = MESHES(NM)%KBAR      ! High mesh boundary face index.
KLO_CELL = KLO_FACE + 1     ! First internal cell index. See notes.
KHI_CELL = KHI_FACE ! Last internal cell index.

LOOP_FLAG_COND : IF ( LOOP_FLAG ) THEN ! MESH_LOOP_1 in calling routine.
   ! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
   DO IFACE=1,MESHES(NM)%CC_NRCFACE_H
      RCF => RC_FACE(MESHES(NM)%RCF_H(IFACE));
      I   = RCF%IJK(IAXIS); J = RCF%IJK(JAXIS); K = RCF%IJK(KAXIS); X1AXIS = RCF%IJK(KAXIS+1)
      IF(ZONE_SOLVE(PRESSURE_ZONE(I,J,K))%CONNECTED_ZONE_PARENT/=IPZ) CYCLE
      ! Unknowns on related cells:
      IND(LOW_IND)  = RCF%UNKH(LOW_IND)
      IND(HIGH_IND) = RCF%UNKH(HIGH_IND)
      IND_LOC(LOW_IND) = IND(LOW_IND) - ZONE_SOLVE(IPZ)%UNKH_IND(NM1) ! Row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- ZONE_SOLVE(IPZ)%UNKH_IND(NM1)
      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
         CASE(JAXIS)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
         CASE(KAXIS)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row.
      ENDSELECT
      ! Add to global matrix arrays:
      CALL ADD_INPLACE_NNZ_H_WHLDOM(LOCROW_1,LOCROW_2,IND,IND_LOC,IPZ)
   ENDDO

   DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
      CF => MESHES(NM)%CUT_FACE(ICF); IF (CF%STATUS/=CC_GASPHASE) CYCLE
      ! Drop if cut-face on a wall-cell, and type different than INTERPOLATED_BOUNDARY or PERIODIC_BOUNDARY.
      IF(CF%IWC>0) THEN
         WC=>MESHES(NM)%WALL(CF%IWC)
         IF (.NOT.(WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
      ENDIF
      I = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
      IF(ZONE_SOLVE(PRESSURE_ZONE(I,J,K))%CONNECTED_ZONE_PARENT/=IPZ) CYCLE
      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND; LOCROW_2 = HIGH_IND
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
         CASE(JAXIS)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
         CASE(KAXIS)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row.
      ENDSELECT
      DO IFACE=1,CF%NFACE
         !% Unknowns on related cells:
         IND(LOW_IND)     = CF%UNKH(LOW_IND,IFACE)
         IND(HIGH_IND)    = CF%UNKH(HIGH_IND,IFACE)
         IND_LOC(LOW_IND) = IND(LOW_IND) - ZONE_SOLVE(IPZ)%UNKH_IND(NM1) ! Row indexes refer to ind_loc.
         IND_LOC(HIGH_IND)= IND(HIGH_IND)- ZONE_SOLVE(IPZ)%UNKH_IND(NM1)
         ! Add to global matrix arrays:
         CALL ADD_INPLACE_NNZ_H_WHLDOM(LOCROW_1,LOCROW_2,IND,IND_LOC,IPZ)
      ENDDO
   ENDDO

ELSE ! MESH_LOOP_2 in calling routine.

   ! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
   DO IFACE=1,MESHES(NM)%CC_NRCFACE_H
      RCF => RC_FACE(MESHES(NM)%RCF_H(IFACE));
      I   = RCF%IJK(IAXIS); J = RCF%IJK(JAXIS); K = RCF%IJK(KAXIS); X1AXIS = RCF%IJK(KAXIS+1)
      IF(ZONE_SOLVE(PRESSURE_ZONE(I,J,K))%CONNECTED_ZONE_PARENT/=IPZ) CYCLE
      ! Unknowns on related cells:
      IND(LOW_IND)  = RCF%UNKH(LOW_IND)
      IND(HIGH_IND) = RCF%UNKH(HIGH_IND)
      IND_LOC(LOW_IND) = IND(LOW_IND) - ZONE_SOLVE(IPZ)%UNKH_IND(NM1) ! Row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- ZONE_SOLVE(IPZ)%UNKH_IND(NM1)
      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
         CASE(JAXIS)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
         CASE(KAXIS)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row.
      ENDSELECT
      RCF%JDH(1:2,1:2) = 0
      ! Add to global matrix arrays:
      DO LOCROW=LOCROW_1,LOCROW_2
         DO IIND=LOW_IND,HIGH_IND
            NII = ZONE_SOLVE(IPZ)%NNZ_D_MAT_H(IND_LOC(LOCROW))
            DO ILOC=1,NII
               IF ( IND(IIND) == ZONE_SOLVE(IPZ)%JD_MAT_H(ILOC,IND_LOC(LOCROW)) ) THEN
                   RCF%JDH(LOCROW,IIND) = ILOC
                   EXIT
               ENDIF
            ENDDO
         ENDDO
      ENDDO
   ENDDO

   ! Now Gasphase CUT_FACES:
   DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
      CF => MESHES(NM)%CUT_FACE(ICF); IF (CF%STATUS/=CC_GASPHASE) CYCLE
      ! Drop if cut-face on a wall-cell, and type different than INTERPOLATED_BOUNDARY or PERIODIC_BOUNDARY.
      IF(CF%IWC>0) THEN
         WC=>MESHES(NM)%WALL(CF%IWC)
         IF (.NOT.(WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
      ENDIF
      I = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
      IF(ZONE_SOLVE(PRESSURE_ZONE(I,J,K))%CONNECTED_ZONE_PARENT/=IPZ) CYCLE
      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND; LOCROW_2 = HIGH_IND
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
         CASE(JAXIS)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
         CASE(KAXIS)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row.
      ENDSELECT
      CF%JDH(:,:,:) = 0
      DO IFACE=1,CF%NFACE
         !% Unknowns on related cells:
         IND(LOW_IND)     = CF%UNKH(LOW_IND,IFACE)
         IND(HIGH_IND)    = CF%UNKH(HIGH_IND,IFACE)
         IND_LOC(LOW_IND) = IND(LOW_IND) - ZONE_SOLVE(IPZ)%UNKH_IND(NM1) ! Row indexes refer to ind_loc.
         IND_LOC(HIGH_IND)= IND(HIGH_IND)- ZONE_SOLVE(IPZ)%UNKH_IND(NM1)
         ! Add to global matrix arrays:
         DO LOCROW=LOCROW_1,LOCROW_2
            DO IIND=LOW_IND,HIGH_IND
               NII = ZONE_SOLVE(IPZ)%NNZ_D_MAT_H(IND_LOC(LOCROW))
               DO ILOC=1,NII
                  IF ( IND(IIND) == ZONE_SOLVE(IPZ)%JD_MAT_H(ILOC,IND_LOC(LOCROW)) ) THEN
                        CF%JDH(LOCROW,IIND,IFACE) = ILOC
                        EXIT
                  ENDIF
               ENDDO
            ENDDO
         ENDDO
      ENDDO
   ENDDO
ENDIF LOOP_FLAG_COND

RETURN
END SUBROUTINE GET_CC_MATRIXGRAPH_H

! ------------------------ ADD_INPLACE_NNZ_H_WHLDOM -------------------------------

SUBROUTINE ADD_INPLACE_NNZ_H_WHLDOM(LOCROW_1,LOCROW_2,IND,IND_LOC,IPZ)

INTEGER, INTENT(IN) :: LOCROW_1,LOCROW_2,IND(LOW_IND:HIGH_IND),IND_LOC(LOW_IND:HIGH_IND),IPZ

! Local Variables:
INTEGER LOCROW, IIND, NII, ILOC, JLOC
LOGICAL INLIST

LOCROW_LOOP : DO LOCROW=LOCROW_1,LOCROW_2
   DO IIND=LOW_IND,HIGH_IND
      NII = ZONE_SOLVE(IPZ)%NNZ_D_MAT_H(IND_LOC(LOCROW))
      ! Check that column index hasn't been already counted:
      INLIST = .FALSE.
      DO ILOC=1,NII
         IF ( IND(IIND) == ZONE_SOLVE(IPZ)%JD_MAT_H(ILOC,IND_LOC(LOCROW)) ) THEN
            INLIST = .TRUE.
            EXIT
         ENDIF
      ENDDO
      IF ( INLIST ) CYCLE

      ! Now add in place:
      NII = NII + 1
      DO ILOC=1,NII
          IF ( ZONE_SOLVE(IPZ)%JD_MAT_H(ILOC,IND_LOC(LOCROW)) > IND(IIND) ) EXIT
      ENDDO
      DO JLOC=NII,ILOC+1,-1
         ZONE_SOLVE(IPZ)%JD_MAT_H(JLOC,IND_LOC(LOCROW)) = ZONE_SOLVE(IPZ)%JD_MAT_H(JLOC-1,IND_LOC(LOCROW))
      ENDDO
      ZONE_SOLVE(IPZ)%NNZ_D_MAT_H(IND_LOC(LOCROW))   = NII
      ZONE_SOLVE(IPZ)%JD_MAT_H(ILOC,IND_LOC(LOCROW)) = IND(IIND)
   ENDDO
ENDDO LOCROW_LOOP

RETURN
END SUBROUTINE ADD_INPLACE_NNZ_H_WHLDOM


! --------------------------- GET_MMATRIX_SCALAR_3D -------------------------------

SUBROUTINE GET_MMATRIX_SCALAR_3D


! Local Variables:
INTEGER :: NM
INTEGER :: I,J,K,IROW,IROW_LOC,ICC,ICC2

! INTEGER :: ILK

! Allocate mass matrix: Diagonal containing cell volumes on implicit region:
ALLOCATE(  M_MAT_Z(1:NUNKZ_LOCAL) );  M_MAT_Z = 0._EB
ALLOCATE( JM_MAT_Z(1:NUNKZ_LOCAL) ); JM_MAT_Z = 0 ! local index of diagonal entry in JD_MAT_Z

! Mesh Loop:
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! 1. Number Regular GASPHASE cells:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,CC_UNKZ) <= 0) CYCLE ! Either explicit region or solid cell.
            IROW     = CCVAR(I,J,K,CC_UNKZ)
            IROW_LOC = IROW - UNKZ_IND(NM_START)
            M_MAT_Z(IROW_LOC) = M_MAT_Z(IROW_LOC) + DX(I)*DY(J)*DZ(K)
         ENDDO
      ENDDO
   ENDDO

   ! 2. Now Cut cells:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      CC => CUT_CELL(ICC); I = CC%IJK(IAXIS); J = CC%IJK(JAXIS); K = CC%IJK(KAXIS)
      ! Drop cut-cells inside an OBST:
      IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
      DO ICC2 = 1,CC%NCELL
         IROW     = CC%UNKZ(ICC2)
         IROW_LOC = IROW - UNKZ_IND(NM_START)
         M_MAT_Z(IROW_LOC) = M_MAT_Z(IROW_LOC) + CC%VOLUME(ICC2)
      ENDDO
   ENDDO

ENDDO MESH_LOOP

RETURN
END SUBROUTINE GET_MMATRIX_SCALAR_3D


! --------------------------- GET_H_CUTFACES ------------------------------------

SUBROUTINE GET_H_CUTFACES(ONE_NM)

INTEGER, OPTIONAL, INTENT(IN) :: ONE_NM

! Local variables:
INTEGER :: NM,NM_LO,NM_HI
INTEGER :: NCELL,ICC,JCC,IFC,IFACE,LOWHIGH,ICF1,ICF2,IRC
INTEGER :: IW,II,JJ,KK,IIF,JJF,KKF,IOR,LOWHIGH_TEST,X1AXIS

IF (PRESENT(ONE_NM)) THEN
   NM_LO = ONE_NM
   NM_HI = ONE_NM
ELSE
   NM_LO = LOWER_MESH_INDEX
   NM_HI = UPPER_MESH_INDEX
ENDIF

! Mesh loop:
MAIN_MESH_LOOP : DO NM=NM_LO,NM_HI

   CALL POINT_TO_MESH(NM)

   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      NCELL = CUT_CELL(ICC)%NCELL
      DO JCC=1,NCELL
         DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
            IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
            ! If face type in face_list is not CC_FTYPE_CFGAS, drop:
            IF ( CUT_CELL(ICC)%FACE_LIST(1,IFACE) /= CC_FTYPE_CFGAS ) CYCLE

            ! Which face?
            LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
            ICF1    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
            ICF2    = CUT_CELL(ICC)%FACE_LIST(5,IFACE)

            IF ( LOWHIGH == LOW_IND) THEN ! Cut-face on low side of cut-cell:
               CUT_FACE(ICF1)%UNKH(HIGH_IND,ICF2) = CUT_CELL(ICC)%UNKH(JCC)
            ELSE ! HIGH
               CUT_FACE(ICF1)%UNKH(LOW_IND,ICF2) = CUT_CELL(ICC)%UNKH(JCC)
            ENDIF

         ENDDO
      ENDDO
   ENDDO

   ! Now Apply external wall cell loop for guard-cell cut cells:
   ULMAT_IF : IF (PRES_FLAG/=ULMAT_FLAG) THEN
      GUARD_CUT_CELL_LOOP :  DO IW=1,N_EXTERNAL_WALL_CELLS
         WC=>WALL(IW)
         IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE GUARD_CUT_CELL_LOOP

         BC => BOUNDARY_COORD(WC%BC_INDEX)
         II  = BC%II
         JJ  = BC%JJ
         KK  = BC%KK
         IOR = BC%IOR

         ! Drop if face is not of type CC_CUTCFE:
         X1AXIS=ABS(IOR)
         SELECT CASE(IOR)
         CASE( IAXIS)
            IIF=II  ; JJF=JJ  ; KKF=KK
            LOWHIGH_TEST=HIGH_IND ! Face on high side of Guard-Cell
         CASE(-IAXIS)
            IIF=II-1; JJF=JJ  ; KKF=KK
            LOWHIGH_TEST=LOW_IND
         CASE( JAXIS)
            IIF=II  ; JJF=JJ  ; KKF=KK
            LOWHIGH_TEST=HIGH_IND
         CASE(-JAXIS)
            IIF=II  ; JJF=JJ-1; KKF=KK
            LOWHIGH_TEST=LOW_IND
         CASE( KAXIS)
            IIF=II  ; JJF=JJ  ; KKF=KK
            LOWHIGH_TEST=HIGH_IND
         CASE(-KAXIS)
            IIF=II  ; JJF=JJ  ; KKF=KK-1
            LOWHIGH_TEST=LOW_IND
         END SELECT

         ! Copy CCVAR(II,JJ,KK,CC_CGSC) to guard cell:
         ICC = MESHES(NM)%CCVAR(II,JJ,KK,CC_IDCC)

         IF (FCVAR(IIF,JJF,KKF,CC_FGSC,X1AXIS) == CC_CUTCFE) THEN

         DO JCC=1,CUT_CELL(ICC)%NCELL
            ! Loop faces and test:
            DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
               IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
               ! Which face ?
               LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
               IF ( CUT_CELL(ICC)%FACE_LIST(1,IFACE) /= CC_FTYPE_CFGAS) CYCLE ! Must Be gasphase cut-face
               IF ( LOWHIGH                              /= LOWHIGH_TEST) CYCLE ! In same side as EWC from guard-cell
               IF ( CUT_CELL(ICC)%FACE_LIST(3,IFACE) /= X1AXIS) CYCLE ! Normal to same axis as EWC
               ICF1    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
               ICF2    = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
               IF ( LOWHIGH == LOW_IND) THEN ! Cut-face on low side of cut-cell:
                  CUT_FACE(ICF1)%UNKH(HIGH_IND,ICF2) = CUT_CELL(ICC)%UNKH(JCC)
               ELSE ! HIGH
                  CUT_FACE(ICF1)%UNKH(LOW_IND,ICF2) = CUT_CELL(ICC)%UNKH(JCC)
               ENDIF
            ENDDO
         ENDDO

         ELSEIF (FCVAR(IIF,JJF,KKF,CC_IDRC,X1AXIS) > 0) THEN ! RC_FACE
            IRC = FCVAR(IIF,JJF,KKF,CC_IDRC,X1AXIS)
            IF(ICC>0) THEN
               DO JCC=1,CUT_CELL(ICC)%NCELL
                  ! Loop faces and test:
                  DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
                     IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
                     ! Which face ?
                     LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
                     IF ( CUT_CELL(ICC)%FACE_LIST(1,IFACE) /= CC_FTYPE_RCGAS) CYCLE ! Must Be gasphase rc-face
                     IF ( LOWHIGH                          /= LOWHIGH_TEST) CYCLE ! In same side as EWC from guard-cell
                     IF ( CUT_CELL(ICC)%FACE_LIST(3,IFACE) /= X1AXIS) CYCLE ! Normal to same axis as EWC
                     MESHES(NM)%RC_FACE(IRC)%UNKH(3-LOWHIGH_TEST)  = CUT_CELL(ICC)%UNKH(JCC)
                  ENDDO
               ENDDO
            ELSE
               MESHES(NM)%RC_FACE(IRC)%UNKH(3-LOWHIGH_TEST)  = CCVAR(II,JJ,KK,CC_UNKH)
            ENDIF
         ENDIF

      ENDDO GUARD_CUT_CELL_LOOP
   ENDIF ULMAT_IF

ENDDO MAIN_MESH_LOOP


RETURN
END SUBROUTINE GET_H_CUTFACES

! ---------------------- GET_GASPHASE_CUTFACES_DATA -----------------------------

SUBROUTINE GET_GASPHASE_CUTFACES_DATA

USE MPI_F08

! Local variables:
INTEGER :: NM
INTEGER :: NCELL,ICC,JCC,IFC,IFACE,LOWHIGH,ICF1,ICF2
INTEGER :: IW,II,JJ,KK,IIF,JJF,KKF,IOR,IIG,JJG,KKG,LOWHIGH_TEST,LOWHIGH_TEST_G,X1AXIS
INTEGER :: IERR

! Mesh loop:
MAIN_MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! First Scalars:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      NCELL = CUT_CELL(ICC)%NCELL
      DO JCC=1,NCELL
         DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
            IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
            ! If face type in face_list is not CC_FTYPE_CFGAS, drop:
            IF ( CUT_CELL(ICC)%FACE_LIST(1,IFACE) /= CC_FTYPE_CFGAS ) CYCLE
            ! Which face?
            LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
            ICF1    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
            ICF2    = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
            SELECT CASE(LOWHIGH)
            CASE( LOW_IND); CUT_FACE(ICF1)%UNKZ(HIGH_IND,ICF2) = CUT_CELL(ICC)%UNKZ(JCC) !Cutface on low side of cutcell
            CASE(HIGH_IND); CUT_FACE(ICF1)%UNKZ( LOW_IND,ICF2) = CUT_CELL(ICC)%UNKZ(JCC) !CF on high side of CC.
            END SELECT
         ENDDO
      ENDDO
   ENDDO

   ! Now Apply wall cell loop for cut cells:
   WALL_CUTFACE_LOOP :  DO IW=1,N_EXTERNAL_WALL_CELLS+N_INTERNAL_WALL_CELLS
      WC=>WALL(IW)
      BC => BOUNDARY_COORD(WC%BC_INDEX)
      II  = BC%II
      JJ  = BC%JJ
      KK  = BC%KK
      IOR = BC%IOR

      ! Drop if face is not of type CC_CUTCFE:
      X1AXIS=ABS(IOR)
      SELECT CASE(IOR)                                           ! V Face on high side of Guard-Cell
      CASE( IAXIS); IIF=II  ; JJF=JJ  ; KKF=KK  ; LOWHIGH_TEST = HIGH_IND; LOWHIGH_TEST_G =  LOW_IND
      CASE(-IAXIS); IIF=II-1; JJF=JJ  ; KKF=KK  ; LOWHIGH_TEST =  LOW_IND; LOWHIGH_TEST_G = HIGH_IND
      CASE( JAXIS); IIF=II  ; JJF=JJ  ; KKF=KK  ; LOWHIGH_TEST = HIGH_IND; LOWHIGH_TEST_G =  LOW_IND
      CASE(-JAXIS); IIF=II  ; JJF=JJ-1; KKF=KK  ; LOWHIGH_TEST =  LOW_IND; LOWHIGH_TEST_G = HIGH_IND
      CASE( KAXIS); IIF=II  ; JJF=JJ  ; KKF=KK  ; LOWHIGH_TEST = HIGH_IND; LOWHIGH_TEST_G =  LOW_IND
      CASE(-KAXIS); IIF=II  ; JJF=JJ  ; KKF=KK-1; LOWHIGH_TEST =  LOW_IND; LOWHIGH_TEST_G = HIGH_IND
      END SELECT

      IF (FCVAR(IIF,JJF,KKF,CC_FGSC,X1AXIS) /= CC_CUTCFE) CYCLE WALL_CUTFACE_LOOP

      BC => BOUNDARY_COORD(WC%BC_INDEX)
      IIG  = BC%IIG
      JJG  = BC%JJG
      KKG  = BC%KKG

      ! Add IWC field to CUT_FACE from internal cell:
      ICC = MESHES(NM)%CCVAR(IIG,JJG,KKG,CC_IDCC)
      DO JCC=1,CUT_CELL(ICC)%NCELL
         ! Loop faces and test:
         DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
            IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
            ! Which face ?
            LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
            IF ( CUT_CELL(ICC)%FACE_LIST(1,IFACE) /= CC_FTYPE_CFGAS) CYCLE ! Must Be gasphase cut-face
            IF ( LOWHIGH                          /=  LOWHIGH_TEST_G) CYCLE ! In same side as EWC from internal cell
            IF ( CUT_CELL(ICC)%FACE_LIST(3,IFACE) /= X1AXIS) CYCLE ! Normal to same axis as EWC
            ICF1    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
            CUT_FACE(ICF1)%IWC = IW   ! Rest of info from internal cut-cell has been filled in previous ICC loop.
            WC%CUT_FACE_INDEX  = ICF1 ! Add CUT_FACE index in WALL(:) array.
         ENDDO
      ENDDO

      ! Now CCVAR(II,JJ,KK,CC_CGSC) from guard cell:
      IF (CELL(CELL_INDEX(II,JJ,KK))%SOLID) CYCLE WALL_CUTFACE_LOOP
      ICC = MESHES(NM)%CCVAR(II,JJ,KK,CC_IDCC)
      DO JCC=1,CUT_CELL(ICC)%NCELL
         ! Loop faces and test:
         DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
            IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
            ! Which face ?
            LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
            IF ( CUT_CELL(ICC)%FACE_LIST(1,IFACE) /= CC_FTYPE_CFGAS) CYCLE ! Must Be gasphase cut-face
            IF ( LOWHIGH                              /= LOWHIGH_TEST) CYCLE ! In same side as EWC from guard-cell
            IF ( CUT_CELL(ICC)%FACE_LIST(3,IFACE) /= X1AXIS) CYCLE ! Normal to same axis as EWC

            ICF1    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
            ICF2    = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
            SELECT CASE(LOWHIGH)
            CASE( LOW_IND); CUT_FACE(ICF1)%UNKZ(HIGH_IND,ICF2) = CUT_CELL(ICC)%UNKZ(JCC) !Cutface on low side of cutcell
            CASE(HIGH_IND); CUT_FACE(ICF1)%UNKZ( LOW_IND,ICF2) = CUT_CELL(ICC)%UNKZ(JCC)
            END SELECT
         ENDDO
      ENDDO

   ENDDO WALL_CUTFACE_LOOP

ENDDO MAIN_MESH_LOOP

IF (DEBUG_MATVEC_DATA) THEN
   DBG_MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
      IF(MY_RANK==PROCESS(NM)) THEN
      CALL POINT_TO_MESH(NM)
      WRITE(LU_ERR,*) ' '
      WRITE(LU_ERR,*) 'MY_RANK, NM, N_BBCUTFACE_MESH : ',MY_RANK,NM,MESHES(NM)%N_BBCUTFACE_MESH
      DO IFC=1,MESHES(NM)%N_BBCUTFACE_MESH
         IF(CUT_FACE(IFC)%STATUS/=CC_GASPHASE) CYCLE
         WRITE(LU_ERR,*) 'BB CUT_FACE, IFC, IWC=',IFC,CUT_FACE(IFC)%IWC,CUT_FACE(IFC)%STATUS
      ENDDO
      ENDIF
      CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
   ENDDO DBG_MESH_LOOP
ENDIF

RETURN
END SUBROUTINE GET_GASPHASE_CUTFACES_DATA


! ---------------------------- GET_RCFACES_H ------------------------------------

SUBROUTINE GET_RCFACES_H(NM)

INTEGER, INTENT(IN) :: NM

! Local Variables:
INTEGER :: IRC,IIFC,X1AXIS,X2AXIS,X3AXIS
INTEGER, ALLOCATABLE, DIMENSION(:,:,:,:) :: IJKFACE
INTEGER :: ICC,JCC,IJK(MAX_DIM),IFC,IFACE,LOWHIGH,IADD,JADD,KADD
INTEGER :: XIAXIS,XJAXIS,XKAXIS,INDXI1(MAX_DIM),INCELL,JNCELL,KNCELL,INFACE,JNFACE,KNFACE
INTEGER :: ISTR, IEND, JSTR, JEND, KSTR, KEND
LOGICAL :: INLIST

INTEGER :: IW,II,JJ,KK,IIF,JJF,KKF,IOR,LOWHIGH_TEST,CELL_UNKH
TYPE (WALL_TYPE), POINTER :: WC
TYPE (MESH_TYPE), POINTER :: M

! Test for Pressure Solver:
SELECT CASE(PRES_FLAG)
   CASE DEFAULT; RETURN ! no need to build unstructured matrix
   CASE (UGLMAT_FLAG,ULMAT_FLAG)
END SELECT

M => MESHES(NM)

! Mesh sizes:
NXB=M%IBAR; NYB=M%JBAR; NZB=M%KBAR

! X direction bounds:
ILO_FACE = 0                    ! Low mesh boundary face index.
IHI_FACE = M%IBAR               ! High mesh boundary face index.
ILO_CELL = ILO_FACE + 1         ! First internal cell index. See notes.
IHI_CELL = IHI_FACE             ! Last internal cell index.
ISTR     = ILO_FACE - NGUARD    ! Allocation start x arrays.
IEND     = IHI_FACE + NGUARD    ! Allocation end x arrays.

! Y direction bounds:
JLO_FACE = 0                    ! Low mesh boundary face index.
JHI_FACE = M%JBAR               ! High mesh boundary face index.
JLO_CELL = JLO_FACE + 1         ! First internal cell index. See notes.
JHI_CELL = JHI_FACE             ! Last internal cell index.
JSTR     = JLO_FACE - NGUARD    ! Allocation start y arrays.
JEND     = JHI_FACE + NGUARD    ! Allocation end y arrays.

! Z direction bounds:
KLO_FACE = 0                    ! Low mesh boundary face index.
KHI_FACE = M%KBAR               ! High mesh boundary face index.
KLO_CELL = KLO_FACE + 1         ! First internal cell index. See notes.
KHI_CELL = KHI_FACE             ! Last internal cell index.
KSTR     = KLO_FACE - NGUARD    ! Allocation start z arrays.
KEND     = KHI_FACE + NGUARD    ! Allocation end z arrays.

! First count for allocation:
ALLOCATE( IJKFACE(ILO_FACE:IHI_FACE,JLO_FACE:JHI_FACE,KLO_FACE:KHI_FACE,IAXIS:KAXIS) )
IJKFACE(:,:,:,:) = 0
DO ICC=1,M%N_CUTCELL_MESH
   CC => M%CUT_CELL(ICC); IJK(IAXIS:KAXIS) = CC%IJK(IAXIS:KAXIS)
   IF(CELL(CELL_INDEX(IJK(IAXIS),IJK(JAXIS),IJK(KAXIS)))%SOLID) CYCLE
   DO JCC=1,CC%NCELL
      ! Loop faces and test:
      DO IFC=1,CC%CCELEM(1,JCC)
         IFACE = CC%CCELEM(IFC+1,JCC)
         ! If face type in face_list is not CC_FTYPE_RCGAS, drop:
         IF(CC%FACE_LIST(1,IFACE) /= CC_FTYPE_RCGAS) CYCLE
         ! Which face?
         LOWHIGH = CC%FACE_LIST(2,IFACE)
         X1AXIS  = CC%FACE_LIST(3,IFACE)
         SELECT CASE(X1AXIS)
         CASE(IAXIS)
            X2AXIS = JAXIS; X3AXIS = KAXIS
            ! location in I,J,K od x2,x2,x3 axes:
            XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS
         CASE(JAXIS)
            X2AXIS = KAXIS; X3AXIS = IAXIS
            ! location in I,J,K od x2,x2,x3 axes:
            XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS
         CASE(KAXIS)
            X2AXIS = IAXIS; X3AXIS = JAXIS
            ! location in I,J,K od x2,x2,x3 axes:
            XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS
         END SELECT

         IF (LOWHIGH == LOW_IND) THEN
            ! Face indexes:
            INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-1, IJK(X2AXIS), IJK(X3AXIS) /)
            INFACE = INDXI1(XIAXIS); JNFACE = INDXI1(XJAXIS); KNFACE = INDXI1(XKAXIS)

            ! Location of next Cartesian cell:
            INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-1, IJK(X2AXIS), IJK(X3AXIS) /)
            INCELL = INDXI1(XIAXIS); JNCELL = INDXI1(XJAXIS); KNCELL = INDXI1(XKAXIS)

            IF (PRES_FLAG==UGLMAT_FLAG) CELL_UNKH = M%CCVAR(INCELL,JNCELL,KNCELL,CC_UNKH)
            IF (PRES_FLAG== ULMAT_FLAG) CELL_UNKH = M%MUNKH(INCELL,JNCELL,KNCELL)
            IF ( CELL_UNKH > 0 ) THEN
               IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS) = 1
            ELSEIF ( M%CCVAR(INCELL,JNCELL,KNCELL,CC_CGSC) == CC_CUTCFE ) THEN ! Cut-cell.
               IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS) = 1
            ENDIF
         ELSE ! HIGH_IND
            ! Face indexes:
            INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS), IJK(X2AXIS), IJK(X3AXIS) /)
            INFACE = INDXI1(XIAXIS); JNFACE = INDXI1(XJAXIS); KNFACE = INDXI1(XKAXIS)

            ! Location of next Cartesian cell:
            INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)+1, IJK(X2AXIS), IJK(X3AXIS) /)
            INCELL = INDXI1(XIAXIS); JNCELL = INDXI1(XJAXIS); KNCELL = INDXI1(XKAXIS)

            IF (PRES_FLAG==UGLMAT_FLAG) CELL_UNKH = M%CCVAR(INCELL,JNCELL,KNCELL,CC_UNKH)
            IF (PRES_FLAG== ULMAT_FLAG) CELL_UNKH = M%MUNKH(INCELL,JNCELL,KNCELL)
            IF ( CELL_UNKH > 0 ) THEN
               IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS) = 1
            ELSEIF ( M%CCVAR(INCELL,JNCELL,KNCELL,CC_CGSC) == CC_CUTCFE ) THEN ! Cut-cell.
               IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS) = 1
            ENDIF
         ENDIF

      ENDDO
   ENDDO
ENDDO

! Check for RCF_H on the boundary of the domain, where the cut-cell is in the cut-cell region.
! Now Apply external wall cell loop for guard-cell cut cells:
GRD_CC_LOOP_1 :  DO IW=1,M%N_EXTERNAL_WALL_CELLS+M%N_INTERNAL_WALL_CELLS
   WC=>M%WALL(IW); BC => M%BOUNDARY_COORD(WC%BC_INDEX); II = BC%II; JJ = BC%JJ; KK = BC%KK; IOR = BC%IOR
   ! Which face:
   X1AXIS=ABS(IOR)
   IADD = 0; JADD = 0; KADD = 0
   SELECT CASE(IOR)
   CASE( IAXIS); IIF=II  ; JJF=JJ  ; KKF=KK  ; IADD=-1
   CASE(-IAXIS); IIF=II-1; JJF=JJ  ; KKF=KK  ; IADD=-1
   CASE( JAXIS); IIF=II  ; JJF=JJ  ; KKF=KK  ; JADD=-1
   CASE(-JAXIS); IIF=II  ; JJF=JJ-1; KKF=KK  ; JADD=-1
   CASE( KAXIS); IIF=II  ; JJF=JJ  ; KKF=KK  ; KADD=-1
   CASE(-KAXIS); IIF=II  ; JJF=JJ  ; KKF=KK-1; KADD=-1
   END SELECT
   IF(ALL(CCVAR(IIF+IADD:IIF,JJF+JADD:JJF,KKF+KADD:KKF,CC_CGSC)==CC_SOLID)) CYCLE GRD_CC_LOOP_1
   IF( PRES_FLAG==UGLMAT_FLAG .AND. &
      (WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY) ) THEN
      ! Drop if FACE is not type CC_GASPHASE
      IF (M%FCVAR(IIF,JJF,KKF,CC_FGSC,X1AXIS) /= CC_GASPHASE) CYCLE GRD_CC_LOOP_1
      ! Is this an actual RCF_H laying on the mesh boundary, where the cut-cell is in the guard-cell region?
      IF(.NOT.((M%CCVAR(II,JJ,KK,CC_CGSC)==CC_CUTCFE).AND.(M%CCVAR(BC%IIG,BC%JJG,BC%KKG,CC_CGSC)==CC_GASPHASE))) &
      CYCLE GRD_CC_LOOP_1
      IJKFACE(IIF,JJF,KKF,X1AXIS) = 1

   ELSE ! All other types of BCs (SOLID_BOUNDARY, NULL_BOUNDARY, OPEN_BOUNDARY) will not be added to RCF_H.
      IJKFACE(IIF,JJF,KKF,X1AXIS) = 0

   ENDIF
ENDDO GRD_CC_LOOP_1

IRC = SUM(IJKFACE(:,:,:,:))
IF (IRC == 0) THEN
   DEALLOCATE(IJKFACE)
   RETURN
ELSE
   ! Compute xc, yc, zc:
   ! Populate position and cell size arrays: Uniform grid implementation.
   ! X direction:
   ALLOCATE(XCELL(ISTR:IEND));  XCELL = 1._EB/GEOMEPS ! Initialize huge.
   XCELL(ILO_CELL-1:IHI_CELL+1) = M%XC(ILO_CELL-1:IHI_CELL+1)

   ! Y direction:
   ALLOCATE(YCELL(JSTR:JEND));  YCELL = 1._EB/GEOMEPS ! Initialize huge.
   YCELL(JLO_CELL-1:JHI_CELL+1) = M%YC(JLO_CELL-1:JHI_CELL+1)

   ! Z direction:
   ALLOCATE(ZCELL(KSTR:KEND));  ZCELL = 1._EB/GEOMEPS ! Initialize huge.
   ZCELL(KLO_CELL-1:KHI_CELL+1) = M%ZC(KLO_CELL-1:KHI_CELL+1)
ENDIF

M%CC_NRCFACE_H = IRC ! Same number of regular - cut cell faces as scalars.
IF (ALLOCATED(M%RCF_H)) DEALLOCATE(M%RCF_H); ALLOCATE( M%RCF_H(IRC) )
IRC = 0
DO ICC=1,M%N_CUTCELL_MESH
   CC => M%CUT_CELL(ICC); IJK(IAXIS:KAXIS) = CC%IJK(IAXIS:KAXIS)
   IF(CELL(CELL_INDEX(IJK(IAXIS),IJK(JAXIS),IJK(KAXIS)))%SOLID) CYCLE
   DO JCC=1,CC%NCELL
      ! Loop faces and test:
      DO IFC=1,CC%CCELEM(1,JCC)
         IFACE = CC%CCELEM(IFC+1,JCC)
         ! If face type in face_list is not CC_FTYPE_RCGAS, drop:
         IF(CC%FACE_LIST(1,IFACE) /= CC_FTYPE_RCGAS) CYCLE
         ! Which face?
         LOWHIGH = CC%FACE_LIST(2,IFACE)
         X1AXIS  = CC%FACE_LIST(3,IFACE)
         SELECT CASE(X1AXIS)
         CASE(IAXIS)
            X2AXIS = JAXIS; X3AXIS = KAXIS
            ! location in I,J,K od x2,x2,x3 axes:
            XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS
         CASE(JAXIS)
            X2AXIS = KAXIS; X3AXIS = IAXIS
            ! location in I,J,K od x2,x2,x3 axes:
            XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS
         CASE(KAXIS)
            X2AXIS = IAXIS; X3AXIS = JAXIS
            ! location in I,J,K od x2,x2,x3 axes:
            XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS
         END SELECT

         IF_LOW_HIGH_H : IF (LOWHIGH == LOW_IND) THEN

            ! Face indexes:
            INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-1, IJK(X2AXIS), IJK(X3AXIS) /)
            INFACE = INDXI1(XIAXIS); JNFACE = INDXI1(XJAXIS); KNFACE = INDXI1(XKAXIS)

            IF(IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS) /= 1) CYCLE ! This is to cycle external WALL CELLs of types other
                                                                ! than INTERPOLATED_BOUNDARY or PERIODIC_BOUNDARY.

            ! Location of next Cartesian cell:
            INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-1, IJK(X2AXIS), IJK(X3AXIS) /)
            INCELL = INDXI1(XIAXIS); JNCELL = INDXI1(XJAXIS); KNCELL = INDXI1(XKAXIS)

            IF (PRES_FLAG==UGLMAT_FLAG) CELL_UNKH = M%CCVAR(INCELL,JNCELL,KNCELL,CC_UNKH)
            IF (PRES_FLAG== ULMAT_FLAG) CELL_UNKH = M%MUNKH(INCELL,JNCELL,KNCELL)
            IF ( CELL_UNKH > 0 ) THEN
               ! Add face to RCF_H list:
               IRC = IRC + 1
               M%RCF_H(IRC) = FCVAR(INFACE,JNFACE,KNFACE,CC_IDRC,X1AXIS)
               ! Cell at i-1, i.e. regular GASPHASE:
               M%RC_FACE(M%RCF_H(IRC))%UNKH(LOW_IND) = CELL_UNKH
               ! Cell at i+1, i.e. cut-cell:
               M%RC_FACE(M%RCF_H(IRC))%UNKH(HIGH_IND) = CC%UNKH(JCC)

            ELSEIF ( M%CCVAR(INCELL,JNCELL,KNCELL,CC_CGSC) == CC_CUTCFE ) THEN ! Cut-cell.
               ! Test that Cut-cell to Cut-cell reg face hasn't been added before:
               INLIST = .FALSE.
               DO IIFC=1,IRC
                  IF ( M%RC_FACE(M%RCF_H(IIFC))%IJK(IAXIS)   /= INFACE ) CYCLE
                  IF ( M%RC_FACE(M%RCF_H(IIFC))%IJK(JAXIS)   /= JNFACE ) CYCLE
                  IF ( M%RC_FACE(M%RCF_H(IIFC))%IJK(KAXIS)   /= KNFACE ) CYCLE
                  IF ( M%RC_FACE(M%RCF_H(IIFC))%IJK(KAXIS+1) /= X1AXIS ) CYCLE
                  INLIST = .TRUE.
                  EXIT
               ENDDO
               IF (INLIST) THEN
                  ! Cell at i+1, i.e. cut-cell:
                  M%RC_FACE(M%RCF_H(IIFC))%UNKH(HIGH_IND) = CC%UNKH(JCC)
                  CYCLE
               ENDIF
               ! Add face to RCF_H list:
               IRC = IRC + 1
               M%RCF_H(IRC) = FCVAR(INFACE,JNFACE,KNFACE,CC_IDRC,X1AXIS)
               ! Cell at i+1, i.e. cut-cell:
               M%RC_FACE(M%RCF_H(IRC))%UNKH(HIGH_IND) = CC%UNKH(JCC)

            ENDIF

         ELSE ! IF_LOW_HIGH_H : HIGH_IND

            ! Face indexes:
            INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS), IJK(X2AXIS), IJK(X3AXIS) /)
            INFACE = INDXI1(XIAXIS); JNFACE = INDXI1(XJAXIS); KNFACE = INDXI1(XKAXIS)

            IF(IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS) /= 1) CYCLE ! This is to cycle external WALL CELLs of types other
                                                                ! than INTERPOLATED_BOUNDARY of PERIODIC_BOUNDARY.

            ! Location of next Cartesian cell:
            INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)+1, IJK(X2AXIS), IJK(X3AXIS) /)
            INCELL = INDXI1(XIAXIS); JNCELL = INDXI1(XJAXIS); KNCELL = INDXI1(XKAXIS)

            IF (PRES_FLAG==UGLMAT_FLAG) CELL_UNKH = M%CCVAR(INCELL,JNCELL,KNCELL,CC_UNKH)
            IF (PRES_FLAG== ULMAT_FLAG) CELL_UNKH = M%MUNKH(INCELL,JNCELL,KNCELL)
            IF ( CELL_UNKH > 0 ) THEN
               ! Add face to RCF_H list:
               IRC = IRC + 1
               M%RCF_H(IRC) = FCVAR(INFACE,JNFACE,KNFACE,CC_IDRC,X1AXIS)
               ! Cell at i-1, i.e. cut-cell:
               M%RC_FACE(M%RCF_H(IRC))%UNKH(LOW_IND) = CC%UNKH(JCC)
               ! Cell at i+1, i.e. regular GASPHASE:
               M%RC_FACE(M%RCF_H(IRC))%UNKH(HIGH_IND) = CELL_UNKH

            ELSEIF ( M%CCVAR(INCELL,JNCELL,KNCELL,CC_CGSC) == CC_CUTCFE ) THEN ! Cut-cell.
               ! Test that Cut-cell to Cut-cell reg face hasn't been added before:
               INLIST = .FALSE.
               DO IIFC=1,IRC
                  IF ( M%RC_FACE(M%RCF_H(IIFC))%IJK(IAXIS)   /= INFACE ) CYCLE
                  IF ( M%RC_FACE(M%RCF_H(IIFC))%IJK(JAXIS)   /= JNFACE ) CYCLE
                  IF ( M%RC_FACE(M%RCF_H(IIFC))%IJK(KAXIS)   /= KNFACE ) CYCLE
                  IF ( M%RC_FACE(M%RCF_H(IIFC))%IJK(KAXIS+1) /= X1AXIS ) CYCLE
                  INLIST = .TRUE.
                  EXIT
               ENDDO
               IF (INLIST) THEN
                  ! Cell at i-1, i.e. cut-cell:
                  M%RC_FACE(M%RCF_H(IIFC))%UNKH(LOW_IND) = CC%UNKH(JCC)
                  CYCLE
               ENDIF
               ! Add face to RCF_H list:
               IRC = IRC + 1
               M%RCF_H(IRC) = FCVAR(INFACE,JNFACE,KNFACE,CC_IDRC,X1AXIS)
               ! Cell at i-1, i.e. cut-cell:
               M%RC_FACE(M%RCF_H(IRC))%UNKH(LOW_IND) = CC%UNKH(JCC)

            ENDIF
         ENDIF IF_LOW_HIGH_H

      ENDDO
   ENDDO
ENDDO

IF (PRES_FLAG==UGLMAT_FLAG) THEN
   GRD_CC_LOOP_2 :  DO IW=1,M%N_EXTERNAL_WALL_CELLS
      WC=>M%WALL(IW)
      IF(.NOT.(WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY.OR.WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE GRD_CC_LOOP_2
      BC => M%BOUNDARY_COORD(WC%BC_INDEX); II = BC%II; JJ = BC%JJ; KK = BC%KK; IOR = BC%IOR

      ! Which face:
      X1AXIS=ABS(IOR)
      SELECT CASE(IOR)
      CASE( IAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK  ; LOWHIGH_TEST=HIGH_IND ! Face on high side of Guard-Cell
      CASE(-IAXIS)
         IIF=II-1; JJF=JJ  ; KKF=KK  ; LOWHIGH_TEST= LOW_IND
      CASE( JAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK  ; LOWHIGH_TEST=HIGH_IND
      CASE(-JAXIS)
         IIF=II  ; JJF=JJ-1; KKF=KK  ; LOWHIGH_TEST= LOW_IND
      CASE( KAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK  ; LOWHIGH_TEST=HIGH_IND
      CASE(-KAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK-1; LOWHIGH_TEST= LOW_IND
      END SELECT

      ! Drop if FACE is not type CC_GASPHASE
      IF (M%FCVAR(IIF,JJF,KKF,CC_FGSC,X1AXIS) /= CC_GASPHASE) CYCLE GRD_CC_LOOP_2

      ! Is this an actual RCF_H laying on the mesh boundary, where the cut-cell is in the guard-cell region?
      IF(.NOT.((M%CCVAR(II,JJ,KK,CC_CGSC)==CC_CUTCFE).AND.(M%CCVAR(BC%IIG,BC%JJG,BC%KKG,CC_UNKH)>0))) &
      CYCLE GRD_CC_LOOP_2

      CC => M%CUT_CELL(M%CCVAR(II,JJ,KK,CC_IDCC))
      DO JCC=1,CC%NCELL
         ! Loop faces and test:
         DO IFC=1,CC%CCELEM(1,JCC)
            IFACE = CC%CCELEM(IFC+1,JCC)
            ! Which face ?
            LOWHIGH = CC%FACE_LIST(2,IFACE)
            IF ( CC%FACE_LIST(1,IFACE) /= CC_FTYPE_RCGAS) CYCLE  ! Must Be gasphase RCFACE
            IF ( LOWHIGH                              /= LOWHIGH_TEST) CYCLE ! In same side as EWC from guard-cell
            IF ( CC%FACE_LIST(3,IFACE) /= X1AXIS) CYCLE           ! Normal to same axis as EWC

             ! If so, we need to add it to RCF_H list:
            IF (LOWHIGH == LOW_IND) THEN ! Face on low side of guard cut-cell
               IRC = IRC + 1
               M%RCF_H(IRC) = M%FCVAR(IIF,JJF,KKF,CC_IDRC,X1AXIS)
               ! Cell at i-1, i.e. regular GASPHASE:
               M%RC_FACE(M%RCF_H(IRC))%UNKH(LOW_IND)  = M%CCVAR(BC%IIG,BC%JJG,BC%KKG,CC_UNKH)
               ! Cell at i+1, i.e. cut-cell:
               M%RC_FACE(M%RCF_H(IRC))%UNKH(HIGH_IND) = CC%UNKH(JCC)

            ELSEIF(LOWHIGH == HIGH_IND) THEN ! Face on high side of guard cut-cell
               IRC = IRC + 1
               M%RCF_H(IRC) = M%FCVAR(IIF,JJF,KKF,CC_IDRC,X1AXIS)
               ! Cell at i-1, i.e. cut-cell:
               M%RC_FACE(M%RCF_H(IRC))%UNKH(LOW_IND)  = CC%UNKH(JCC)
               ! Cell at i+1, i.e. regular GASPHASE:
               M%RC_FACE(M%RCF_H(IRC))%UNKH(HIGH_IND) = M%CCVAR(BC%IIG,BC%JJG,BC%KKG,CC_UNKH)

            ENDIF
            ! At this point the face has been found, cycle:
            CYCLE GRD_CC_LOOP_2
         ENDDO
      ENDDO

   ENDDO GRD_CC_LOOP_2
ENDIF

DEALLOCATE(XCELL,YCELL,ZCELL)
DEALLOCATE(IJKFACE)

RETURN
END SUBROUTINE GET_RCFACES_H


! ---------------------- GET_GASPHASE_REGRCFACES_DATA -----------------------------

SUBROUTINE GET_GASPHASE_REGRCFACES_DATA

USE MPI_F08

! Local variables:
INTEGER :: NM
INTEGER :: ILO,IHI,JLO,JHI,KLO,KHI
INTEGER :: I,J,K,II,IREG,IRC,IIFC,X1AXIS,X2AXIS,X3AXIS
INTEGER, ALLOCATABLE, DIMENSION(:,:) :: IJKBUFFER
LOGICAL, ALLOCATABLE, DIMENSION(:,:) :: LOHIBUFF
INTEGER, ALLOCATABLE, DIMENSION(:,:,:,:,:) :: IJKFACE
INTEGER :: ICC,JCC,IJK(MAX_DIM),IFC,IFACE,LOWHIGH
INTEGER :: XIAXIS,XJAXIS,XKAXIS,INDXI1(MAX_DIM),INCELL,JNCELL,KNCELL,INFACE,JNFACE,KNFACE
INTEGER :: ISTR, IEND, JSTR, JEND, KSTR, KEND
LOGICAL :: INLIST

INTEGER :: IW,JJ,KK,IIF,JJF,KKF,IOR,LOWHIGH_TEST,IIG,JJG,KKG
INTEGER :: IBNDINT,IC,IC2
LOGICAL :: FLGIN
INTEGER, PARAMETER :: OZPOS=0, ICPOS=1, JCPOS=2, IFPOS=3
INTEGER :: IERR
TYPE(MESH_TYPE), POINTER :: M=>NULL()

! Mesh loop:
MAIN_MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   M => MESHES(NM)
   CALL POINT_TO_MESH(NM)

   ! Mesh sizes:
   NXB=IBAR
   NYB=JBAR
   NZB=KBAR

   ! X direction bounds:
   ILO_FACE = 0                    ! Low mesh boundary face index.
   IHI_FACE = IBAR                 ! High mesh boundary face index.
   ILO_CELL = ILO_FACE + 1     ! First internal cell index. See notes.
   IHI_CELL = IHI_FACE ! Last internal cell index.
   ISTR     = ILO_FACE - NGUARD    ! Allocation start x arrays.
   IEND     = IHI_FACE + NGUARD    ! Allocation end x arrays.


   ! Y direction bounds:
   JLO_FACE = 0                    ! Low mesh boundary face index.
   JHI_FACE = JBAR                 ! High mesh boundary face index.
   JLO_CELL = JLO_FACE + 1     ! First internal cell index. See notes.
   JHI_CELL = JHI_FACE ! Last internal cell index.
   JSTR     = JLO_FACE - NGUARD    ! Allocation start y arrays.
   JEND     = JHI_FACE + NGUARD    ! Allocation end y arrays.

   ! Z direction bounds:
   KLO_FACE = 0                    ! Low mesh boundary face index.
   KHI_FACE = KBAR                 ! High mesh boundary face index.
   KLO_CELL = KLO_FACE + 1     ! First internal cell index. See notes.
   KHI_CELL = KHI_FACE ! Last internal cell index.
   KSTR     = KLO_FACE - NGUARD    ! Allocation start z arrays.
   KEND     = KHI_FACE + NGUARD    ! Allocation end z arrays.

   ! Define grid arrays for this mesh:
   ! Populate position and cell size arrays: Uniform grid implementation.
   ! X direction:
   ALLOCATE(XCELL(ISTR:IEND));  XCELL = 1._EB/GEOMEPS ! Initialize huge.
   XCELL(ILO_CELL-1:IHI_CELL+1) = M%XC(ILO_CELL-1:IHI_CELL+1)

   ! Y direction:
   ALLOCATE(YCELL(JSTR:JEND));  YCELL = 1._EB/GEOMEPS ! Initialize huge.
   YCELL(JLO_CELL-1:JHI_CELL+1) = M%YC(JLO_CELL-1:JHI_CELL+1)

   ! Z direction:
   ALLOCATE(ZCELL(KSTR:KEND));  ZCELL = 1._EB/GEOMEPS ! Initialize huge.
   ZCELL(KLO_CELL-1:KHI_CELL+1) = M%ZC(KLO_CELL-1:KHI_CELL+1)

   ! Set starting number of regular faces for NM to zero:
   M%CC_NREGFACE_Z(IAXIS:KAXIS) = 0

   ! 1. Regular GASPHASE faces connected to Gasphase cells:
   ALLOCATE(IJKBUFFER(IAXIS:KAXIS+1,1:(NXB+1)*(NYB+1)*(NZB+1)))
   ALLOCATE(LOHIBUFF(LOW_IND:HIGH_IND,1:(NXB+1)*(NYB+1)*(NZB+1)))

   ! First Scalars:
   ! axis = IAXIS:
   X1AXIS = IAXIS
   IJKBUFFER(:,:)=0; LOHIBUFF(:,:)=.FALSE.; IREG = 0
   ! First Reg Faces in mesh block boundaries, then inside mesh. Count for allocation:
   IBNDINT_LOOP_X : DO IBNDINT=1,3
      IF(IBNDINT==3) M%CC_NBBREGFACE_Z(X1AXIS)=IREG ! REG faces in block boundaries.
      SELECT CASE(IBNDINT)
      CASE(1)
         ILO = ILO_FACE; IHI = ILO_FACE
         JLO = JLO_CELL; JHI = JHI_CELL
         KLO = KLO_CELL; KHI = KHI_CELL
         DO K=KLO,KHI
            DO J=JLO,JHI
               DO I=ILO,IHI
                  IF ( CCVAR(I  ,J,K,CC_CGSC) /= CC_GASPHASE ) CYCLE
                  IF ( CCVAR(I+1,J,K,CC_CGSC) /= CC_GASPHASE ) CYCLE
                  IF ( CCVAR(I+1,J,K,CC_UNKZ)<=0 ) CYCLE ! Either face out of CCREGION or EXIM face with CCREGION outside of mesh.
                  IREG = IREG + 1
                  IF ( CCVAR(I  ,J,K,CC_UNKZ)>0 ) LOHIBUFF(LOW_IND,IREG) = .TRUE.
                  IF ( CCVAR(I+1,J,K,CC_UNKZ)>0 ) LOHIBUFF(HIGH_IND,IREG)= .TRUE.
                  IC   = CELL_INDEX(I+1  ,J,K)
                  IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, CELL(IC)%WALL_INDEX(-X1AXIS) /) ! Face on low side of cell.
               ENDDO
            ENDDO
         ENDDO
      CASE(2)
         ILO = IHI_FACE; IHI = IHI_FACE
         JLO = JLO_CELL; JHI = JHI_CELL
         KLO = KLO_CELL; KHI = KHI_CELL
         DO K=KLO,KHI
            DO J=JLO,JHI
               DO I=ILO,IHI
                  IF ( CCVAR(I  ,J,K,CC_CGSC) /= CC_GASPHASE ) CYCLE
                  IF ( CCVAR(I+1,J,K,CC_CGSC) /= CC_GASPHASE ) CYCLE
                  IF ( CCVAR(I  ,J,K,CC_UNKZ)<=0 ) CYCLE ! Either face out of CCREGION or EXIM face with CCREGION outside of mesh.
                  IREG = IREG + 1
                  IF ( CCVAR(I  ,J,K,CC_UNKZ)>0 ) LOHIBUFF(LOW_IND,IREG) = .TRUE.
                  IF ( CCVAR(I+1,J,K,CC_UNKZ)>0 ) LOHIBUFF(HIGH_IND,IREG)= .TRUE.
                  IC = CELL_INDEX(I,J,K)
                  IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, CELL(IC)%WALL_INDEX( X1AXIS) /) ! Face on high side of cell.
               ENDDO
            ENDDO
         ENDDO
      CASE(3)
         ILO = ILO_FACE+1; IHI = IHI_FACE-1
         JLO = JLO_CELL;   JHI = JHI_CELL
         KLO = KLO_CELL;   KHI = KHI_CELL
         DO K=KLO,KHI
            DO J=JLO,JHI
               DO I=ILO,IHI
                  IF ( CCVAR(I  ,J,K,CC_CGSC) /= CC_GASPHASE ) CYCLE
                  IF ( CCVAR(I+1,J,K,CC_CGSC) /= CC_GASPHASE ) CYCLE
                  IF ( (CCVAR(I,J,K,CC_UNKZ)<=0) .AND. (CCVAR(I+1,J,K,CC_UNKZ)<=0) ) CYCLE
                  IREG = IREG + 1
                  IF ( CCVAR(I  ,J,K,CC_UNKZ)>0 ) LOHIBUFF(LOW_IND,IREG) = .TRUE.
                  IF ( CCVAR(I+1,J,K,CC_UNKZ)>0 ) LOHIBUFF(HIGH_IND,IREG)= .TRUE.
                  IC = CELL_INDEX(I,J,K)
                  IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, CELL(IC)%WALL_INDEX( X1AXIS) /)
                  IC2 =  CELL_INDEX(I+1,J,K)
                  IF(CELL(IC)%WALL_INDEX( X1AXIS)>0 .AND. CELL(IC2)%WALL_INDEX(-X1AXIS)>0) THEN
                     IREG = IREG + 1
                     LOHIBUFF(LOW_IND,IREG) = LOHIBUFF(LOW_IND,IREG-1)
                     LOHIBUFF(HIGH_IND,IREG)= LOHIBUFF(HIGH_IND,IREG-1)
                     IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, CELL(IC2)%WALL_INDEX(-X1AXIS) /)
                  ELSEIF(CELL(IC2)%WALL_INDEX(-X1AXIS)>0) THEN
                     IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, CELL(IC2)%WALL_INDEX(-X1AXIS) /)
                  ENDIF
               ENDDO
            ENDDO
         ENDDO
      END SELECT
   ENDDO IBNDINT_LOOP_X
   M%CC_NREGFACE_Z(X1AXIS) = IREG
   IF(ALLOCATED(M%CC_REGFACE_IAXIS_Z)) DEALLOCATE(M%CC_REGFACE_IAXIS_Z)
   ALLOCATE(M%CC_REGFACE_IAXIS_Z(IREG))
   DO II=1,IREG
      M%CC_REGFACE_IAXIS_Z(II)%IJK(IAXIS:KAXIS) = IJKBUFFER(IAXIS:KAXIS,II)
      M%CC_REGFACE_IAXIS_Z(II)%IWC              = IJKBUFFER(KAXIS+1,II)
      M%CC_REGFACE_IAXIS_Z(II)%DO_LO_IND        = LOHIBUFF(LOW_IND,II)
      M%CC_REGFACE_IAXIS_Z(II)%DO_HI_IND        = LOHIBUFF(HIGH_IND,II)
      ALLOCATE(M%CC_REGFACE_IAXIS_Z(II)%RHOZZ_U(1:N_TOTAL_SCALARS)   ,&
               M%CC_REGFACE_IAXIS_Z(II)%FN_ZZ(1:N_TOTAL_SCALARS)     ,&
               M%CC_REGFACE_IAXIS_Z(II)%RHO_D_DZDN(1:N_TOTAL_SCALARS),&
               M%CC_REGFACE_IAXIS_Z(II)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))
      M%CC_REGFACE_IAXIS_Z(II)%RHOZZ_U      = 0._EB
      M%CC_REGFACE_IAXIS_Z(II)%FN_ZZ        = 0._EB
      M%CC_REGFACE_IAXIS_Z(II)%RHO_D_DZDN   = 0._EB
      M%CC_REGFACE_IAXIS_Z(II)%H_RHO_D_DZDN = 0._EB
   ENDDO

   ! axis = JAXIS:
   X1AXIS = JAXIS
   IJKBUFFER(:,:)=0; LOHIBUFF(:,:)=.FALSE.; IREG = 0
   ! First Reg Faces in mesh block boundaries, then inside mesh. Count for allocation:
   IBNDINT_LOOP_Y : DO IBNDINT=1,3
      IF(IBNDINT==3) M%CC_NBBREGFACE_Z(X1AXIS)=IREG ! REG faces in block boundaries.
      SELECT CASE(IBNDINT)
      CASE(1)
         ILO = ILO_CELL; IHI = IHI_CELL
         JLO = JLO_FACE; JHI = JLO_FACE
         KLO = KLO_CELL; KHI = KHI_CELL
         DO K=KLO,KHI
            DO J=JLO,JHI
               DO I=ILO,IHI
                  IF ( CCVAR(I,J  ,K,CC_CGSC) /= CC_GASPHASE ) CYCLE
                  IF ( CCVAR(I,J+1,K,CC_CGSC) /= CC_GASPHASE ) CYCLE
                  IF ( CCVAR(I,J+1,K,CC_UNKZ)<=0 ) CYCLE ! Either face out of CCREGION or EXIM face with CCREGION outside of mesh.
                  IREG = IREG + 1
                  IF ( CCVAR(I,J  ,K,CC_UNKZ)>0 ) LOHIBUFF(LOW_IND,IREG) = .TRUE.
                  IF ( CCVAR(I,J+1,K,CC_UNKZ)>0 ) LOHIBUFF(HIGH_IND,IREG)= .TRUE.
                  IC   = CELL_INDEX(I,J+1  ,K)
                  IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, CELL(IC)%WALL_INDEX(-X1AXIS) /) ! Face on low side of cell.
               ENDDO
            ENDDO
         ENDDO
      CASE(2)
         ILO = ILO_CELL; IHI = IHI_CELL
         JLO = JHI_FACE; JHI = JHI_FACE
         KLO = KLO_CELL; KHI = KHI_CELL
         DO K=KLO,KHI
            DO J=JLO,JHI
               DO I=ILO,IHI
                  IF ( CCVAR(I,J  ,K,CC_CGSC) /= CC_GASPHASE ) CYCLE
                  IF ( CCVAR(I,J+1,K,CC_CGSC) /= CC_GASPHASE ) CYCLE
                  IF ( CCVAR(I,J  ,K,CC_UNKZ)<=0 ) CYCLE ! Either face out of CCREGION or EXIM face with CCREGION outside of mesh.
                  IREG = IREG + 1
                  IF ( CCVAR(I,J  ,K,CC_UNKZ)>0 ) LOHIBUFF(LOW_IND,IREG) = .TRUE.
                  IF ( CCVAR(I,J+1,K,CC_UNKZ)>0 ) LOHIBUFF(HIGH_IND,IREG)= .TRUE.
                  IC   = CELL_INDEX(I,J,K)
                  IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, CELL(IC)%WALL_INDEX( X1AXIS) /) ! Face on high side of cell.
               ENDDO
            ENDDO
         ENDDO
      CASE(3)
         ILO = ILO_CELL;   IHI = IHI_CELL
         JLO = JLO_FACE+1; JHI = JHI_FACE-1
         KLO = KLO_CELL;   KHI = KHI_CELL
         DO K=KLO,KHI
            DO J=JLO,JHI
               DO I=ILO,IHI
                  IF ( CCVAR(I,J  ,K,CC_CGSC) /= CC_GASPHASE ) CYCLE
                  IF ( CCVAR(I,J+1,K,CC_CGSC) /= CC_GASPHASE ) CYCLE
                  IF ( (CCVAR(I,J,K,CC_UNKZ)<=0) .AND. (CCVAR(I,J+1,K,CC_UNKZ)<=0) ) CYCLE
                  IREG = IREG + 1
                  IF ( CCVAR(I,J  ,K,CC_UNKZ)>0 ) LOHIBUFF(LOW_IND,IREG) = .TRUE.
                  IF ( CCVAR(I,J+1,K,CC_UNKZ)>0 ) LOHIBUFF(HIGH_IND,IREG)= .TRUE.
                  IC   = CELL_INDEX(I,J,K)
                  IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, CELL(IC)%WALL_INDEX( X1AXIS) /)
                  IC2 =  CELL_INDEX(I,J+1,K)
                  IF(CELL(IC)%WALL_INDEX( X1AXIS)>0 .AND. CELL(IC2)%WALL_INDEX(-X1AXIS)>0) THEN
                     IREG = IREG + 1
                     LOHIBUFF(LOW_IND,IREG) = LOHIBUFF(LOW_IND,IREG-1)
                     LOHIBUFF(HIGH_IND,IREG)= LOHIBUFF(HIGH_IND,IREG-1)
                     IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, CELL(IC2)%WALL_INDEX(-X1AXIS) /)
                  ELSEIF(CELL(IC2)%WALL_INDEX(-X1AXIS)>0) THEN
                     IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, CELL(IC2)%WALL_INDEX(-X1AXIS) /)
                  ENDIF
               ENDDO
            ENDDO
         ENDDO
      END SELECT
   ENDDO IBNDINT_LOOP_Y
   M%CC_NREGFACE_Z(X1AXIS) = IREG
   IF(ALLOCATED(M%CC_REGFACE_JAXIS_Z)) DEALLOCATE(M%CC_REGFACE_JAXIS_Z)
   ALLOCATE(M%CC_REGFACE_JAXIS_Z(IREG))
   DO II=1,IREG
      M%CC_REGFACE_JAXIS_Z(II)%IJK(IAXIS:KAXIS) = IJKBUFFER(IAXIS:KAXIS,II)
      M%CC_REGFACE_JAXIS_Z(II)%IWC              = IJKBUFFER(KAXIS+1,II)
      M%CC_REGFACE_JAXIS_Z(II)%DO_LO_IND        = LOHIBUFF(LOW_IND,II)
      M%CC_REGFACE_JAXIS_Z(II)%DO_HI_IND        = LOHIBUFF(HIGH_IND,II)
      ALLOCATE(M%CC_REGFACE_JAXIS_Z(II)%RHOZZ_U(1:N_TOTAL_SCALARS)   ,&
               M%CC_REGFACE_JAXIS_Z(II)%FN_ZZ(1:N_TOTAL_SCALARS)     ,&
               M%CC_REGFACE_JAXIS_Z(II)%RHO_D_DZDN(1:N_TOTAL_SCALARS),&
               M%CC_REGFACE_JAXIS_Z(II)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))
      M%CC_REGFACE_JAXIS_Z(II)%RHOZZ_U      = 0._EB
      M%CC_REGFACE_JAXIS_Z(II)%FN_ZZ        = 0._EB
      M%CC_REGFACE_JAXIS_Z(II)%RHO_D_DZDN   = 0._EB
      M%CC_REGFACE_JAXIS_Z(II)%H_RHO_D_DZDN = 0._EB
   ENDDO

   ! axis = KAXIS:
   X1AXIS = KAXIS
   IJKBUFFER(:,:)=0; LOHIBUFF(:,:)=.FALSE.; IREG = 0
   ! First Reg Faces in mesh block boundaries, then inside mesh.
   IBNDINT_LOOP_Z : DO IBNDINT=1,3
      IF(IBNDINT==3) M%CC_NBBREGFACE_Z(X1AXIS)=IREG ! REG faces in block boundaries.
      SELECT CASE(IBNDINT)
      CASE(1)
         ILO = ILO_CELL; IHI = IHI_CELL
         JLO = JLO_CELL; JHI = JHI_CELL
         KLO = KLO_FACE; KHI = KLO_FACE
         DO K=KLO,KHI
            DO J=JLO,JHI
               DO I=ILO,IHI
                  IF ( CCVAR(I,J,K  ,CC_CGSC) /= CC_GASPHASE ) CYCLE
                  IF ( CCVAR(I,J,K+1,CC_CGSC) /= CC_GASPHASE ) CYCLE
                  IF ( CCVAR(I,J,K+1,CC_UNKZ)<=0 ) CYCLE ! Either face out of CCREGION or EXIM face with CCREGION outside of mesh.
                  IREG = IREG + 1
                  IF ( CCVAR(I,J,K  ,CC_UNKZ)>0 ) LOHIBUFF(LOW_IND,IREG) = .TRUE.
                  IF ( CCVAR(I,J,K+1,CC_UNKZ)>0 ) LOHIBUFF(HIGH_IND,IREG)= .TRUE.
                  IC   = CELL_INDEX(I,J,K+1 )
                  IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, CELL(IC)%WALL_INDEX(-X1AXIS) /)  ! Face on low side of cell.
               ENDDO
            ENDDO
         ENDDO
      CASE(2)
         ILO = ILO_CELL; IHI = IHI_CELL
         JLO = JLO_CELL; JHI = JHI_CELL
         KLO = KHI_FACE; KHI = KHI_FACE
         DO K=KLO,KHI
            DO J=JLO,JHI
               DO I=ILO,IHI
                  IF ( CCVAR(I,J,K  ,CC_CGSC) /= CC_GASPHASE ) CYCLE
                  IF ( CCVAR(I,J,K+1,CC_CGSC) /= CC_GASPHASE ) CYCLE
                  IF ( CCVAR(I,J,K  ,CC_UNKZ)<=0 ) CYCLE ! Either face out of CCREGION or EXIM face with CCREGION outside of mesh.
                  IREG = IREG + 1
                  IF ( CCVAR(I,J,K  ,CC_UNKZ)>0 ) LOHIBUFF(LOW_IND,IREG) = .TRUE.
                  IF ( CCVAR(I,J,K+1,CC_UNKZ)>0 ) LOHIBUFF(HIGH_IND,IREG)= .TRUE.
                  IC   = CELL_INDEX(I,J,K)
                  IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, CELL(IC)%WALL_INDEX( X1AXIS) /)  ! Face on high side of cell.
               ENDDO
            ENDDO
         ENDDO
      CASE(3)
         ILO = ILO_CELL;   IHI = IHI_CELL
         JLO = JLO_CELL;   JHI = JHI_CELL
         KLO = KLO_FACE+1; KHI = KHI_FACE-1
         DO K=KLO,KHI
            DO J=JLO,JHI
               DO I=ILO,IHI
                  IF ( CCVAR(I,J,K  ,CC_CGSC) /= CC_GASPHASE ) CYCLE
                  IF ( CCVAR(I,J,K+1,CC_CGSC) /= CC_GASPHASE ) CYCLE
                  IF ( (CCVAR(I,J,K,CC_UNKZ)<=0) .AND. (CCVAR(I,J,K+1,CC_UNKZ)<=0) ) CYCLE
                  IREG = IREG + 1
                  IF ( CCVAR(I,J,K  ,CC_UNKZ)>0 ) LOHIBUFF(LOW_IND,IREG) = .TRUE.
                  IF ( CCVAR(I,J,K+1,CC_UNKZ)>0 ) LOHIBUFF(HIGH_IND,IREG)= .TRUE.
                  IC   = CELL_INDEX(I,J,K)
                  IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, CELL(IC)%WALL_INDEX( X1AXIS) /)
                  IC2 =  CELL_INDEX(I,J,K+1)
                  IF(CELL(IC)%WALL_INDEX( X1AXIS)>0 .AND. CELL(IC2)%WALL_INDEX(-X1AXIS)>0) THEN
                     IREG = IREG + 1
                     LOHIBUFF(LOW_IND,IREG) = LOHIBUFF(LOW_IND,IREG-1)
                     LOHIBUFF(HIGH_IND,IREG)= LOHIBUFF(HIGH_IND,IREG-1)
                     IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, CELL(IC2)%WALL_INDEX(-X1AXIS) /)
                  ELSEIF(CELL(IC2)%WALL_INDEX(-X1AXIS)>0) THEN
                     IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, CELL(IC2)%WALL_INDEX(-X1AXIS) /)
                  ENDIF
               ENDDO
            ENDDO
         ENDDO
      END SELECT
   ENDDO IBNDINT_LOOP_Z
   M%CC_NREGFACE_Z(X1AXIS) = IREG
   IF(ALLOCATED(M%CC_REGFACE_KAXIS_Z)) DEALLOCATE(M%CC_REGFACE_KAXIS_Z)
   ALLOCATE(M%CC_REGFACE_KAXIS_Z(IREG))
   DO II=1,IREG
      M%CC_REGFACE_KAXIS_Z(II)%IJK(IAXIS:KAXIS) = IJKBUFFER(IAXIS:KAXIS,II)
      M%CC_REGFACE_KAXIS_Z(II)%IWC              = IJKBUFFER(KAXIS+1,II)
      M%CC_REGFACE_KAXIS_Z(II)%DO_LO_IND        = LOHIBUFF(LOW_IND,II)
      M%CC_REGFACE_KAXIS_Z(II)%DO_HI_IND        = LOHIBUFF(HIGH_IND,II)
      ALLOCATE(M%CC_REGFACE_KAXIS_Z(II)%RHOZZ_U(1:N_TOTAL_SCALARS)   ,&
               M%CC_REGFACE_KAXIS_Z(II)%FN_ZZ(1:N_TOTAL_SCALARS)     ,&
               M%CC_REGFACE_KAXIS_Z(II)%RHO_D_DZDN(1:N_TOTAL_SCALARS),&
               M%CC_REGFACE_KAXIS_Z(II)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))
      M%CC_REGFACE_KAXIS_Z(II)%RHOZZ_U      = 0._EB
      M%CC_REGFACE_KAXIS_Z(II)%FN_ZZ        = 0._EB
      M%CC_REGFACE_KAXIS_Z(II)%RHO_D_DZDN   = 0._EB
      M%CC_REGFACE_KAXIS_Z(II)%H_RHO_D_DZDN = 0._EB
   ENDDO

   ! 2. Lists of Regular Gasphase faces, connected to one regular gasphase and one cut-cell:
   ! First count for allocation:
   ALLOCATE( IJKFACE(ILO_FACE:IHI_FACE,JLO_FACE:JHI_FACE,KLO_FACE:KHI_FACE,IAXIS:KAXIS,OZPOS:IFPOS) )
   IJKFACE(:,:,:,:,:) = 0
   DO ICC=1,M%N_CUTCELL_MESH
      CC => CUT_CELL(ICC); IJK(IAXIS:KAXIS) = CC%IJK(IAXIS:KAXIS)
      DO JCC=1,CC%NCELL
         ! Loop faces and test:
         DO IFC=1,CC%CCELEM(1,JCC)
            IFACE = CC%CCELEM(IFC+1,JCC)
            ! If face type in face_list is not CC_FTYPE_RCGAS, drop:
            IF(CC%FACE_LIST(1,IFACE) /= CC_FTYPE_RCGAS) CYCLE
            ! Which face?
            LOWHIGH = CC%FACE_LIST(2,IFACE)
            X1AXIS  = CC%FACE_LIST(3,IFACE)
            SELECT CASE(X1AXIS)
            CASE(IAXIS)
               X2AXIS = JAXIS; X3AXIS = KAXIS
               ! location in I,J,K od x2,x2,x3 axes:
               XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS
            CASE(JAXIS)
               X2AXIS = KAXIS; X3AXIS = IAXIS
               ! location in I,J,K od x2,x2,x3 axes:
               XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS
            CASE(KAXIS)
               X2AXIS = IAXIS; X3AXIS = JAXIS
               ! location in I,J,K od x2,x2,x3 axes:
               XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS
            END SELECT

            ! Face indexes:
            INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-1+(LOWHIGH-1), IJK(X2AXIS), IJK(X3AXIS) /)
            INFACE = INDXI1(XIAXIS)
            JNFACE = INDXI1(XJAXIS)
            KNFACE = INDXI1(XKAXIS)

            IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,OZPOS) = 1
            IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,ICPOS) = ICC
            IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,JCPOS) = JCC
            IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,IFPOS) = IFACE

         ENDDO
      ENDDO
   ENDDO

   ! Check for RC_FACE on the boundary of the domain, where the cut-cell is in the guard-cell region.
   ! Now Apply external wall cell loop for guard-cell cut cells:
   GUARD_CUT_CELL_LOOP_1A :  DO IW=1,N_EXTERNAL_WALL_CELLS
      WC=>WALL(IW)
      BC => BOUNDARY_COORD(WC%BC_INDEX)
      II = BC%II
      JJ = BC%JJ
      KK = BC%KK
      IOR = BC%IOR

      ! Which face:
      X1AXIS=ABS(IOR)
      SELECT CASE(IOR)
      CASE( IAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=HIGH_IND ! Face on high side of Guard-Cell
      CASE(-IAXIS)
         IIF=II-1; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=LOW_IND
      CASE( JAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=HIGH_IND
      CASE(-JAXIS)
         IIF=II  ; JJF=JJ-1; KKF=KK
         LOWHIGH_TEST=LOW_IND
      CASE( KAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=HIGH_IND
      CASE(-KAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK-1
         LOWHIGH_TEST=LOW_IND
      END SELECT

      ! Drop if FACE is not type CC_GASPHASE
      IF (FCVAR(IIF,JJF,KKF,CC_FGSC,X1AXIS) /= CC_GASPHASE) CYCLE GUARD_CUT_CELL_LOOP_1A

      IIG  = BC%IIG
      JJG  = BC%JJG
      KKG  = BC%KKG

      ! Is this an actual RCFACE laying on the mesh boundary, where the cut-cell is in the guard-cell region?
      FLGIN = (CCVAR(II,JJ,KK,CC_CGSC)==CC_CUTCFE) ! Note that this will overrride the Cut-cell to cut-cell case in
                                                     ! the block boundary, picked up in previous loop. Thats fine.

      IF(.NOT.FLGIN) CYCLE GUARD_CUT_CELL_LOOP_1A

      ICC=CCVAR(II,JJ,KK,CC_IDCC)
      DO JCC=1,CUT_CELL(ICC)%NCELL
         ! Loop faces and test:
         DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
            IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
            ! Which face ?
            LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
            IF ( CUT_CELL(ICC)%FACE_LIST(1,IFACE) /= CC_FTYPE_RCGAS) CYCLE ! Must Be gasphase cut-face
            IF ( LOWHIGH                             /= LOWHIGH_TEST) CYCLE ! In same side as EWC from guard-cell
            IF ( CUT_CELL(ICC)%FACE_LIST(3,IFACE) /= X1AXIS) CYCLE ! Normal to same axis as EWC

            IJKFACE(IIF,JJF,KKF,X1AXIS,OZPOS) = 1
            IJKFACE(IIF,JJF,KKF,X1AXIS,ICPOS) = ICC
            IJKFACE(IIF,JJF,KKF,X1AXIS,JCPOS) = JCC
            IJKFACE(IIF,JJF,KKF,X1AXIS,IFPOS) = IFACE

            CYCLE GUARD_CUT_CELL_LOOP_1A
         ENDDO
      ENDDO

   ENDDO GUARD_CUT_CELL_LOOP_1A

   IRC = SUM(IJKFACE(:,:,:,:,OZPOS))
   IF (IRC == 0) THEN
      DEALLOCATE(XCELL,YCELL,ZCELL)
      DEALLOCATE(IJKBUFFER,LOHIBUFF,IJKFACE)
      CYCLE
   ENDIF

   ! Now actual computation for Scalars:
   ALLOCATE( M%RC_FACE(IRC) )
   DO II=1,IRC
      ALLOCATE(M%RC_FACE(II)%ZZ_FACE(1:N_TOTAL_SCALARS)   ,&
               M%RC_FACE(II)%RHO_D_DZDN(1:N_TOTAL_SCALARS),&
               M%RC_FACE(II)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))
      M%RC_FACE(II)%ZZ_FACE      = 0._EB
      M%RC_FACE(II)%RHO_D_DZDN   = 0._EB
      M%RC_FACE(II)%H_RHO_D_DZDN = 0._EB
   ENDDO
   IRC = 0
   ! Start with external wall cells:
   GUARD_CUT_CELL_LOOP_1B :  DO IW=1,N_EXTERNAL_WALL_CELLS+N_INTERNAL_WALL_CELLS
      WC=>WALL(IW); BC => BOUNDARY_COORD(WC%BC_INDEX); II = BC%II; JJ = BC%JJ; KK = BC%KK; IOR = BC%IOR
      ! Which face:
      X1AXIS=ABS(IOR)
      SELECT CASE(IOR)
      CASE( IAXIS); IIF=II  ; JJF=JJ  ; KKF=KK  ; LOWHIGH_TEST=HIGH_IND ! Face on high side of Guard-Cell
      CASE(-IAXIS); IIF=II-1; JJF=JJ  ; KKF=KK  ; LOWHIGH_TEST= LOW_IND
      CASE( JAXIS); IIF=II  ; JJF=JJ  ; KKF=KK  ; LOWHIGH_TEST=HIGH_IND
      CASE(-JAXIS); IIF=II  ; JJF=JJ-1; KKF=KK  ; LOWHIGH_TEST= LOW_IND
      CASE( KAXIS); IIF=II  ; JJF=JJ  ; KKF=KK  ; LOWHIGH_TEST=HIGH_IND
      CASE(-KAXIS); IIF=II  ; JJF=JJ  ; KKF=KK-1; LOWHIGH_TEST= LOW_IND
      END SELECT

      IF(IJKFACE(IIF,JJF,KKF,X1AXIS,OZPOS) < 1) CYCLE GUARD_CUT_CELL_LOOP_1B ! Not an RC_FACE.

      ! None of the following defined RCFACES in block boundaries have been added to RC_FACE before:
      ICC   = IJKFACE(IIF,JJF,KKF,X1AXIS,ICPOS)
      JCC   = IJKFACE(IIF,JJF,KKF,X1AXIS,JCPOS)
      IFACE = IJKFACE(IIF,JJF,KKF,X1AXIS,IFPOS)
      IJK(IAXIS:KAXIS) = CUT_CELL(ICC)%IJK(IAXIS:KAXIS)
      ! Which face?
      LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)

      ! Add face to RC face:
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         X2AXIS = JAXIS
         X3AXIS = KAXIS
         ! location in I,J,K od x2,x2,x3 axes:
         XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS
      CASE(JAXIS)
         X2AXIS = KAXIS
         X3AXIS = IAXIS
         ! location in I,J,K od x2,x2,x3 axes:
         XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS
      CASE(KAXIS)
         X2AXIS = IAXIS
         X3AXIS = JAXIS
         ! location in I,J,K od x2,x2,x3 axes:
         XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS
      END SELECT

      IF_LOW_HIGH_1B : IF (LOWHIGH == LOW_IND) THEN

         ! Face indexes:
         INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-1, IJK(X2AXIS), IJK(X3AXIS) /)
         INFACE = INDXI1(XIAXIS)
         JNFACE = INDXI1(XJAXIS)
         KNFACE = INDXI1(XKAXIS)

         ! Location of next Cartesian cell:
         INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-1, IJK(X2AXIS), IJK(X3AXIS) /)
         INCELL = INDXI1(XIAXIS)
         JNCELL = INDXI1(XJAXIS)
         KNCELL = INDXI1(XKAXIS)

         ! Scalar:
         IF (CCVAR(INCELL,JNCELL,KNCELL,CC_CGSC) == CC_GASPHASE ) THEN ! next cell is reg-cell:

            ! Set OZPOS to 2, to be used in next cycle:
            IJKFACE(IIF,JJF,KKF,X1AXIS,OZPOS) = 2
            ! Add face to RC_FACE data structure:
            IRC = IRC + 1
            M%RC_FACE(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)
            M%RC_FACE(IRC)%IWC = IW ! Locate WALL CELL for boundary M%RC_FACE(IRC).

            ! Add all info required for matrix build:
            ! Cell at i-1, i.e. regular GASPHASE:
            M%RC_FACE(IRC)%UNKZ(LOW_IND)                     = CCVAR(INCELL,JNCELL,KNCELL,CC_UNKZ)
            M%RC_FACE(IRC)%XCEN(IAXIS:KAXIS,LOW_IND)         = (/ XCELL(INCELL), YCELL(JNCELL), ZCELL(KNCELL) /)
            M%RC_FACE(IRC)%CELL_LIST(IAXIS:KAXIS+1, LOW_IND) = (/ CC_FTYPE_RGGAS, INCELL, JNCELL, KNCELL /)

            ! Cell at i+1, i.e. cut-cell:
            M%RC_FACE(IRC)%UNKZ(HIGH_IND)                    = CUT_CELL(ICC)%UNKZ(JCC)
            M%RC_FACE(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND)        = CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)
            M%RC_FACE(IRC)%CELL_LIST(IAXIS:KAXIS+1,HIGH_IND) = (/ CC_FTYPE_CFGAS, ICC, JCC, IFC /)

            ! Modify FACE_LIST for the given cut-cell:
            CUT_CELL(ICC)%FACE_LIST(4,IFACE) = IRC
         ELSEIF(CCVAR(INCELL,JNCELL,KNCELL,CC_CGSC) == CC_CUTCFE) THEN ! next cell is cc:

            ! Set OZPOS to 2, to be used in next cycle:
            IJKFACE(IIF,JJF,KKF,X1AXIS,OZPOS) = 2
            ! Add face to RC_FACE  data structure:
            IRC = IRC + 1
            M%RC_FACE(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)
            M%RC_FACE(IRC)%IWC = IW ! Locate WALL CELL for boundary M%RC_FACE(IRC).

            ! Add all info required for matrix build:
            ! Cell at i+1, i.e. cut-cell:
            M%RC_FACE(IRC)%UNKZ(HIGH_IND)                    = CUT_CELL(ICC)%UNKZ(JCC)
            M%RC_FACE(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND)        = CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)
            M%RC_FACE(IRC)%CELL_LIST(IAXIS:KAXIS+1,HIGH_IND) = (/ CC_FTYPE_CFGAS, ICC, JCC, IFC /)

            ! Modify FACE_LIST for the given cut-cell:
            CUT_CELL(ICC)%FACE_LIST(4,IFACE) = IRC
         ELSE
            WRITE(LU_ERR,*) 'MISSING BOUNDARY RCFACE',IIF,JJF,KKF,X1AXIS
         ENDIF

      ELSE ! IF_LOW_HIGH : HIGH_IND

         ! Face indexes:
         INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS), IJK(X2AXIS), IJK(X3AXIS) /)
         INFACE = INDXI1(XIAXIS)
         JNFACE = INDXI1(XJAXIS)
         KNFACE = INDXI1(XKAXIS)

         ! Location of next Cartesian cell:
         INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)+1, IJK(X2AXIS), IJK(X3AXIS) /)
         INCELL = INDXI1(XIAXIS)
         JNCELL = INDXI1(XJAXIS)
         KNCELL = INDXI1(XKAXIS)

         IF (CCVAR(INCELL,JNCELL,KNCELL,CC_CGSC) == CC_GASPHASE ) THEN

            ! Set OZPOS to 2, to be used in next cycle:
            IJKFACE(IIF,JJF,KKF,X1AXIS,OZPOS) = 2
            ! Add face to RC_FACE data structure:
            IRC = IRC + 1
            M%RC_FACE(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)
            M%RC_FACE(IRC)%IWC = IW ! Locate WALL CELL for boundary M%RC_FACE(IRC).

            ! Add all info required for matrix build:
            ! Cell at i-1, i.e. cut-cell:
            M%RC_FACE(IRC)%UNKZ(LOW_IND)                     = CUT_CELL(ICC)%UNKZ(JCC)
            M%RC_FACE(IRC)%XCEN(IAXIS:KAXIS,LOW_IND)         = CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)
            M%RC_FACE(IRC)%CELL_LIST(IAXIS:KAXIS+1, LOW_IND) = (/ CC_FTYPE_CFGAS, ICC, JCC, IFC /)
            ! Modify FACE_LIST for the given cut-cell:
            CUT_CELL(ICC)%FACE_LIST(4,IFACE) = IRC

            ! Cell at i+1, i.e. regular GASPHASE:
            M%RC_FACE(IRC)%UNKZ(HIGH_IND)                    = CCVAR(INCELL,JNCELL,KNCELL,CC_UNKZ)
            M%RC_FACE(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND)        = (/ XCELL(INCELL), YCELL(JNCELL), ZCELL(KNCELL) /)
            M%RC_FACE(IRC)%CELL_LIST(IAXIS:KAXIS+1,HIGH_IND) = (/ CC_FTYPE_RGGAS, INCELL, JNCELL, KNCELL /)

         ELSEIF(CCVAR(INCELL,JNCELL,KNCELL,CC_CGSC) == CC_CUTCFE) THEN ! next cell is cc:

            ! Set OZPOS to 2, to be used in next cycle:
            IJKFACE(IIF,JJF,KKF,X1AXIS,OZPOS) = 2
            ! Add face to RC_FACE data structure:
            IRC = IRC + 1
            M%RC_FACE(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)
            M%RC_FACE(IRC)%IWC = IW ! Locate WALL CELL for boundary M%RC_FACE(IRC).

            ! Add high cell info required for matrix build:
            ! Cell at i-1, i.e. cut-cell:
            M%RC_FACE(IRC)%UNKZ(LOW_IND)                     = CUT_CELL(ICC)%UNKZ(JCC)
            M%RC_FACE(IRC)%XCEN(IAXIS:KAXIS,LOW_IND)         = CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)
            M%RC_FACE(IRC)%CELL_LIST(IAXIS:KAXIS+1, LOW_IND) = (/ CC_FTYPE_CFGAS, ICC, JCC, IFC /)

            ! Modify FACE_LIST for the given cut-cell:
            CUT_CELL(ICC)%FACE_LIST(4,IFACE) = IRC
           ELSE
              WRITE(LU_ERR,*) 'MISSING BOUNDARY RCFACE',IIF,JJF,KKF,X1AXIS
         ENDIF
      ENDIF IF_LOW_HIGH_1B

   ENDDO GUARD_CUT_CELL_LOOP_1B

   ! Number of RC faces defined in block boundaries:
   M%CC_NBBRCFACE_Z = IRC

   ! Now run regular cut-cell loop to define internal RCFACES:
   DO ICC=1,M%N_CUTCELL_MESH
      CC => CUT_CELL(ICC); IJK(IAXIS:KAXIS) = CC%IJK(IAXIS:KAXIS)
      DO JCC=1,CC%NCELL
         ! Loop faces and test:
         IFC_LOOP : DO IFC=1,CC%CCELEM(1,JCC)
            IFACE = CC%CCELEM(IFC+1,JCC)
            ! If face type in face_list is not CC_FTYPE_RCGAS, drop:
            IF(CC%FACE_LIST(1,IFACE) /= CC_FTYPE_RCGAS) CYCLE IFC_LOOP

            ! Which face?
            LOWHIGH = CC%FACE_LIST(2,IFACE)
            X1AXIS  = CC%FACE_LIST(3,IFACE)

            SELECT CASE(X1AXIS)
            CASE(IAXIS)
               X2AXIS = JAXIS
               X3AXIS = KAXIS
               ! location in I,J,K od x2,x2,x3 axes:
               XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS
            CASE(JAXIS)
               X2AXIS = KAXIS
               X3AXIS = IAXIS
               ! location in I,J,K od x2,x2,x3 axes:
               XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS
            CASE(KAXIS)
               X2AXIS = IAXIS
               X3AXIS = JAXIS
               ! location in I,J,K od x2,x2,x3 axes:
               XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS
            END SELECT

            IF_LOW_HIGH : IF (LOWHIGH == LOW_IND) THEN

               ! Face indexes:
               INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-1, IJK(X2AXIS), IJK(X3AXIS) /)
               INFACE = INDXI1(XIAXIS)
               JNFACE = INDXI1(XJAXIS)
               KNFACE = INDXI1(XKAXIS)

               ! Location of next Cartesian cell:
               INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-1, IJK(X2AXIS), IJK(X3AXIS) /)
               INCELL = INDXI1(XIAXIS)
               JNCELL = INDXI1(XJAXIS)
               KNCELL = INDXI1(XKAXIS)

               ! Scalar:
               IF (CCVAR(INCELL,JNCELL,KNCELL,CC_UNKZ) > 0 ) THEN ! next cell is reg-cell:

                  IF(IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,OZPOS) == 2) CYCLE IFC_LOOP ! CC-REG face already counted in
                                                                                     ! external boundary loop.

                  ! Add face to RC_FACE data structure:
                  IRC = IRC + 1
                  M%RC_FACE(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)

                  ! Add all info required for matrix build:
                  ! Cell at i-1, i.e. regular GASPHASE:
                  M%RC_FACE(IRC)%UNKZ(LOW_IND)                     = CCVAR(INCELL,JNCELL,KNCELL,CC_UNKZ)
                  M%RC_FACE(IRC)%XCEN(IAXIS:KAXIS,LOW_IND)         = (/ XCELL(INCELL), YCELL(JNCELL), ZCELL(KNCELL) /)
                  M%RC_FACE(IRC)%CELL_LIST(IAXIS:KAXIS+1,LOW_IND)  = (/ CC_FTYPE_RGGAS, INCELL, JNCELL, KNCELL /)

                  ! Cell at i+1, i.e. cut-cell:
                  M%RC_FACE(IRC)%UNKZ(HIGH_IND)                    = CC%UNKZ(JCC)
                  M%RC_FACE(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND)        = CC%XYZCEN(IAXIS:KAXIS,JCC)
                  M%RC_FACE(IRC)%CELL_LIST(IAXIS:KAXIS+1,HIGH_IND) = (/ CC_FTYPE_CFGAS, ICC, JCC, IFC /)

                  ! Modify FACE_LIST for the given cut-cell:
                  CC%FACE_LIST(4,IFACE) = IRC
               ELSEIF(CCVAR(INCELL,JNCELL,KNCELL,CC_CGSC) == CC_CUTCFE) THEN ! next cell is cc:

                  ! Test that Cut-cell to Cut-cell reg face hasn't been added before:
                  INLIST = .FALSE.
                  DO IIFC=1,IRC
                     IF ( M%RC_FACE(IIFC)%IJK(IAXIS)   /= INFACE ) CYCLE
                     IF ( M%RC_FACE(IIFC)%IJK(JAXIS)   /= JNFACE ) CYCLE
                     IF ( M%RC_FACE(IIFC)%IJK(KAXIS)   /= KNFACE ) CYCLE
                     IF ( M%RC_FACE(IIFC)%IJK(KAXIS+1) /= X1AXIS ) CYCLE
                     INLIST = .TRUE.
                     EXIT
                  ENDDO
                  IF (INLIST) THEN
                     ! This cut-cell is on the high side of face iifc:
                     ! Cell at i+1, i.e. cut-cell:
                     M%RC_FACE(IIFC)%UNKZ(HIGH_IND)                    = CC%UNKZ(JCC)
                     M%RC_FACE(IIFC)%XCEN(IAXIS:KAXIS,HIGH_IND)        = CC%XYZCEN(IAXIS:KAXIS,JCC)
                     M%RC_FACE(IIFC)%CELL_LIST(IAXIS:KAXIS+1,HIGH_IND) = (/ CC_FTYPE_CFGAS, ICC, JCC, IFC /)
                     ! Modify FACE_LIST for the given cut-cell:
                     CC%FACE_LIST(4,IFACE) = IIFC
                     CYCLE IFC_LOOP
                  ENDIF

                  ! Add face to RC_FACE  data structure:
                  IRC = IRC + 1
                  M%RC_FACE(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)

                  ! Add all info required for matrix build:
                  ! Cell at i+1, i.e. cut-cell:
                  M%RC_FACE(IRC)%UNKZ(HIGH_IND)                        = CC%UNKZ(JCC)
                  M%RC_FACE(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND)            = CC%XYZCEN(IAXIS:KAXIS,JCC)
                  M%RC_FACE(IRC)%CELL_LIST(IAXIS:KAXIS+1,HIGH_IND)     = (/ CC_FTYPE_CFGAS, ICC, JCC, IFC /)

                  ! Modify FACE_LIST for the given cut-cell:
                  CC%FACE_LIST(4,IFACE) = IRC
               ENDIF

            ELSE ! IF_LOW_HIGH : HIGH_IND

               ! Face indexes:
               INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS), IJK(X2AXIS), IJK(X3AXIS) /)
               INFACE = INDXI1(XIAXIS)
               JNFACE = INDXI1(XJAXIS)
               KNFACE = INDXI1(XKAXIS)

               ! Location of next Cartesian cell:
               INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)+1, IJK(X2AXIS), IJK(X3AXIS) /)
               INCELL = INDXI1(XIAXIS)
               JNCELL = INDXI1(XJAXIS)
               KNCELL = INDXI1(XKAXIS)

               IF (CCVAR(INCELL,JNCELL,KNCELL,CC_UNKZ) > 0 ) THEN

                  IF(IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,OZPOS) == 2) CYCLE IFC_LOOP ! CC-REG face already counted in
                                                                                     ! external boundary loop.

                  ! Add face to RC_FACE data structure:
                  IRC = IRC + 1
                  M%RC_FACE(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)

                  ! Add all info required for matrix build:
                  ! Cell at i-1, i.e. cut-cell:
                  M%RC_FACE(IRC)%UNKZ(LOW_IND)                     = CC%UNKZ(JCC)
                  M%RC_FACE(IRC)%XCEN(IAXIS:KAXIS,LOW_IND)         = CC%XYZCEN(IAXIS:KAXIS,JCC)
                  M%RC_FACE(IRC)%CELL_LIST(IAXIS:KAXIS+1,LOW_IND)  = (/ CC_FTYPE_CFGAS, ICC, JCC, IFC /)
                  ! Modify FACE_LIST for the given cut-cell:
                  CC%FACE_LIST(4,IFACE) = IRC

                  ! Cell at i+1, i.e. regular GASPHASE:
                  M%RC_FACE(IRC)%UNKZ(HIGH_IND)                    = CCVAR(INCELL,JNCELL,KNCELL,CC_UNKZ)
                  M%RC_FACE(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND)        = (/ XCELL(INCELL), YCELL(JNCELL), ZCELL(KNCELL) /)
                  M%RC_FACE(IRC)%CELL_LIST(IAXIS:KAXIS+1,HIGH_IND) = (/ CC_FTYPE_RGGAS, INCELL, JNCELL, KNCELL /)

               ELSEIF(CCVAR(INCELL,JNCELL,KNCELL,CC_CGSC) == CC_CUTCFE) THEN ! next cell is cc:

                  ! Test that Cut-cell to Cut-cell reg face hasn't been added before:
                  INLIST = .FALSE.
                  DO IIFC=1,IRC
                     IF ( M%RC_FACE(IIFC)%IJK(IAXIS)   /= INFACE ) CYCLE
                     IF ( M%RC_FACE(IIFC)%IJK(JAXIS)   /= JNFACE ) CYCLE
                     IF ( M%RC_FACE(IIFC)%IJK(KAXIS)   /= KNFACE ) CYCLE
                     IF ( M%RC_FACE(IIFC)%IJK(KAXIS+1) /= X1AXIS ) CYCLE
                     INLIST = .TRUE.
                     EXIT
                  ENDDO
                  IF (INLIST) THEN
                     ! This cut-cell is on the high side of face iifc:
                     ! Cell at i-1, i.e. cut-cell:
                     M%RC_FACE(IIFC)%UNKZ(LOW_IND)                     = CC%UNKZ(JCC)
                     M%RC_FACE(IIFC)%XCEN(IAXIS:KAXIS,LOW_IND)         = CC%XYZCEN(IAXIS:KAXIS,JCC)
                     M%RC_FACE(IIFC)%CELL_LIST(IAXIS:KAXIS+1, LOW_IND) = (/ CC_FTYPE_CFGAS, ICC, JCC, IFC /)
                     ! Modify FACE_LIST for the given cut-cell:
                     CC%FACE_LIST(4,IFACE) = IIFC
                     CYCLE IFC_LOOP
                  ENDIF

                  ! Add face to RC_FACE data structure:
                  IRC = IRC + 1
                  M%RC_FACE(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)

                  ! Add high cell info required for matrix build:
                  ! Cell at i-1, i.e. cut-cell:
                  M%RC_FACE(IRC)%UNKZ(LOW_IND)                         = CC%UNKZ(JCC)
                  M%RC_FACE(IRC)%XCEN(IAXIS:KAXIS,LOW_IND)             = CC%XYZCEN(IAXIS:KAXIS,JCC)
                  M%RC_FACE(IRC)%CELL_LIST(IAXIS:KAXIS+1, LOW_IND)     = (/ CC_FTYPE_CFGAS, ICC, JCC, IFC /)
                  ! Modify FACE_LIST for the given cut-cell:
                  CC%FACE_LIST(4,IFACE) = IRC
               ENDIF
            ENDIF IF_LOW_HIGH

         ENDDO IFC_LOOP

      ENDDO
   ENDDO

   ! Final number of RC faces:
   M%CC_NRCFACE_Z = IRC

   ! Note WALL_CELLs for internal RC_FACES:
   DO IRC=M%CC_NBBRCFACE_Z+1,M%CC_NRCFACE_Z
      RCF => M%RC_FACE(IRC);
      I = RCF%IJK(IAXIS); J = RCF%IJK(JAXIS); K = RCF%IJK(KAXIS); X1AXIS = RCF%IJK(KAXIS+1)
      ! Don't count cut-faces inside an OBST, or don't lay on a WALL_CELL:
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         IF (ALL(CELL(CELL_INDEX(I:I+1,J,K))%SOLID) .OR. ALL(.NOT.CELL(CELL_INDEX(I:I+1,J,K))%SOLID)) THEN; CYCLE
         ELSEIF(    CELL(CELL_INDEX(I,J,K))%SOLID .AND. .NOT.CELL(CELL_INDEX(I+1,J,K))%SOLID) THEN
            IW = CELL(CELL_INDEX(I+1,J,K))%WALL_INDEX(-X1AXIS) ! Low face of I+1 cell.
         ELSEIF(.NOT.CELL(CELL_INDEX(I,J,K))%SOLID .AND.     CELL(CELL_INDEX(I+1,J,K))%SOLID) THEN
            IW = CELL(CELL_INDEX(I  ,J,K))%WALL_INDEX( X1AXIS) ! High face of I cell.
         ENDIF
      CASE(JAXIS)
         IF (ALL(CELL(CELL_INDEX(I,J:J+1,K))%SOLID) .OR. ALL(.NOT.CELL(CELL_INDEX(I,J:J+1,K))%SOLID)) THEN; CYCLE
         ELSEIF(    CELL(CELL_INDEX(I,J,K))%SOLID .AND. .NOT.CELL(CELL_INDEX(I,J+1,K))%SOLID) THEN
            IW = CELL(CELL_INDEX(I,J+1,K))%WALL_INDEX(-X1AXIS) ! Low face of J+1 cell.
         ELSEIF(.NOT.CELL(CELL_INDEX(I,J,K))%SOLID .AND.     CELL(CELL_INDEX(I,J+1,K))%SOLID) THEN
            IW = CELL(CELL_INDEX(I,J  ,K))%WALL_INDEX( X1AXIS) ! High face of J cell.
         ENDIF
      CASE(KAXIS)
         IF (ALL(CELL(CELL_INDEX(I,J,K:K+1))%SOLID) .OR. ALL(.NOT.CELL(CELL_INDEX(I,J,K:K+1))%SOLID)) THEN; CYCLE
         ELSEIF(    CELL(CELL_INDEX(I,J,K))%SOLID .AND. .NOT.CELL(CELL_INDEX(I,J,K+1))%SOLID) THEN
            IW = CELL(CELL_INDEX(I,J,K+1))%WALL_INDEX(-X1AXIS) ! Low face of K+1 cell.
         ELSEIF(.NOT.CELL(CELL_INDEX(I,J,K))%SOLID .AND.     CELL(CELL_INDEX(I,J,K+1))%SOLID) THEN
            IW = CELL(CELL_INDEX(I,J,K  ))%WALL_INDEX( X1AXIS) ! High face of K cell.
         ENDIF
      END SELECT
      IF(IW>0) RCF%IWC=IW
   ENDDO

   ! Cell centered positions and cell sizes:
   IF (ALLOCATED(XCELL)) DEALLOCATE(XCELL)
   IF (ALLOCATED(YCELL)) DEALLOCATE(YCELL)
   IF (ALLOCATED(ZCELL)) DEALLOCATE(ZCELL)
   IF (ALLOCATED(IJKBUFFER)) DEALLOCATE(IJKBUFFER)
   IF (ALLOCATED(LOHIBUFF))  DEALLOCATE(LOHIBUFF)
   IF (ALLOCATED(IJKFACE))   DEALLOCATE(IJKFACE)

ENDDO MAIN_MESH_LOOP


IF (DEBUG_MATVEC_DATA) THEN
   DBG_MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
      IF(MY_RANK/=PROCESS(NM)) CYCLE DBG_MESH_LOOP
      CALL POINT_TO_MESH(NM)
      WRITE(LU_ERR,*) ' '
      WRITE(LU_ERR,*) 'MY_RANK, NM : ',MY_RANK,NM
      WRITE(LU_ERR,*) 'CC_NBBREGFACE(1:3) : ',M%CC_NBBREGFACE_Z(IAXIS:KAXIS)
      WRITE(LU_ERR,*) 'CC_NREGFACE(1:3)   : ',M%CC_NREGFACE_Z(IAXIS:KAXIS)
      WRITE(LU_ERR,*) 'CC_NRCFACE_Z, CC_NBBRCFACE_Z : ', &
                       M%CC_NRCFACE_Z,M%CC_NBBRCFACE_Z
   ENDDO DBG_MESH_LOOP
ENDIF

RETURN
END SUBROUTINE GET_GASPHASE_REGRCFACES_DATA


! ------------------ NUMBER_UNKH_CUTCELLS ---------------------------

SUBROUTINE NUMBER_UNKH_CUTCELLS(FLAG12,NM,IPZ,NUNKH_LC)

LOGICAL, INTENT(IN) :: FLAG12
INTEGER, INTENT(IN) :: NM,IPZ
INTEGER, INTENT(INOUT) :: NUNKH_LC(LOWER_MESH_INDEX:UPPER_MESH_INDEX)

! Local Variables:
INTEGER :: ICC, JCC, I, J, K

FLAG12_COND : IF (FLAG12) THEN
   ! Initialize Cut-cell unknown numbers as undefined.
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      CUT_CELL(ICC)%UNKH(:) = CC_UNDEFINED
   ENDDO
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      CC => CUT_CELL(ICC); I=CC%IJK(IAXIS); J=CC%IJK(JAXIS); K=CC%IJK(KAXIS); IF(CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
      IF(ZONE_SOLVE(PRESSURE_ZONE(I,J,K))%CONNECTED_ZONE_PARENT/=IPZ ) CYCLE
      NUNKH_LC(NM) = NUNKH_LC(NM) + 1
      CUT_CELL(ICC)%UNKH(1:CC%NCELL) = NUNKH_LC(NM)
   ENDDO
ELSE
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      CC => CUT_CELL(ICC); I=CC%IJK(IAXIS); J=CC%IJK(JAXIS); K=CC%IJK(KAXIS); IF(CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
      IF(ZONE_SOLVE(PRESSURE_ZONE(I,J,K))%CONNECTED_ZONE_PARENT/=IPZ ) CYCLE
      DO JCC=1,CC%NCELL
         CUT_CELL(ICC)%UNKH(JCC) = CUT_CELL(ICC)%UNKH(JCC) + ZONE_SOLVE(IPZ)%UNKH_IND(NM)
      ENDDO
   ENDDO
ENDIF FLAG12_COND

RETURN
END SUBROUTINE NUMBER_UNKH_CUTCELLS

! ------------------- COPY_CC_HS_TO_UNKH ----------------------------

SUBROUTINE COPY_CC_HS_TO_UNKH(NM)

INTEGER, INTENT(IN) :: NM

! Local Variables:
INTEGER :: NOM,ICC,II,JJ,KK,IOR,IW,IIO,JJO,KKO
TYPE (OMESH_TYPE), POINTER :: OM

! Loop over external wall cells:
EXTERNAL_WALL_LOOP: DO IW=1,N_EXTERNAL_WALL_CELLS

   WC=>WALL(IW)
   EWC=>EXTERNAL_WALL(IW)
   IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE EXTERNAL_WALL_LOOP

   BC => BOUNDARY_COORD(WC%BC_INDEX)
   II = BC%II
   JJ = BC%JJ
   KK = BC%KK
   IOR = BC%IOR
   NOM = EWC%NOM
   OM => OMESH(NOM)

   ! This assumes all meshes at the same level of refinement:
   KKO=EWC%KKO_MIN
   JJO=EWC%JJO_MIN
   IIO=EWC%IIO_MIN

   ICC=CCVAR(II,JJ,KK,CC_IDCC)

   IF (ICC > 0) THEN ! Cut-cells on this guard-cell Cartesian cell.
      MESHES(NM)%CUT_CELL(ICC)%UNKH(1) = INT(OM%HS(IIO,JJO,KKO))
   ELSE
      MESHES(NM)%CCVAR(II,JJ,KK,CC_UNKH) = INT(OM%HS(IIO,JJO,KKO))
   ENDIF

ENDDO EXTERNAL_WALL_LOOP

! Loop over external wall cells:
EXTERNAL_WALL_LOOP2: DO IW=1,N_EXTERNAL_WALL_CELLS
   WC=>WALL(IW)
   EWC=>EXTERNAL_WALL(IW)
   IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE EXTERNAL_WALL_LOOP2
   NOM = EWC%NOM; OM => OMESH(NOM)
   KKO=EWC%KKO_MIN; JJO=EWC%JJO_MIN; IIO=EWC%IIO_MIN
   OM%HS(IIO,JJO,KKO) = 0._EB ! (VAR_CC == UNKH)
ENDDO EXTERNAL_WALL_LOOP2

RETURN
END SUBROUTINE COPY_CC_HS_TO_UNKH

! ------------------- COPY_CC_UNKH_TO_HS ----------------------------

SUBROUTINE COPY_CC_UNKH_TO_HS(NM)

INTEGER, INTENT(IN) :: NM

! Local Variables:
INTEGER :: I,J,K,ICC

DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
   I = MESHES(NM)%CUT_CELL(ICC)%IJK(IAXIS)
   J = MESHES(NM)%CUT_CELL(ICC)%IJK(JAXIS)
   K = MESHES(NM)%CUT_CELL(ICC)%IJK(KAXIS)
   HS(I,J,K)= REAL(MESHES(NM)%CUT_CELL(ICC)%UNKH(1),EB)
ENDDO

RETURN
END SUBROUTINE COPY_CC_UNKH_TO_HS


! ----------------------------- GET_LINKED_MATRIX_INDEXES_Z ---------------------------------
SUBROUTINE GET_LINKED_MATRIX_INDEXES_Z
USE MPI_F08

! Local variables:
INTEGER :: NM
INTEGER :: X1AXIS,I,J,K,ICC,JCC,ICC2,JCC2,ILEV,INGH,JNGH,KNGH,IERR

! Linking variables associated data:
INTEGER, ALLOCATABLE, DIMENSION(:) :: CELLPUNKZ, INDUNKZ
INTEGER :: COUNT, ICF, CF_STATUS

! Define local number of cut-cell:
IF (ALLOCATED(NUNKZ_LOC)) DEALLOCATE(NUNKZ_LOC)
ALLOCATE(NUNKZ_LOC(1:NMESHES)); NUNKZ_LOC = 0

! Cell numbers for Scalar equations:
MAIN_MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   CALL POINT_TO_MESH(NM)

   ! Reset UNKZ to CC_UNDEFINED:
   CCVAR(:,:,:,CC_UNKZ) = CC_UNDEFINED
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      CUT_CELL(ICC)%UNKZ(:) = CC_UNDEFINED
   ENDDO

   ! 1. Number regular GASPHASE cells:
   IF (PERIODIC_TEST==103 .OR. PERIODIC_TEST==11 .OR. PERIODIC_TEST==7) THEN
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               ! If regular cell centroid is outside the test box + DELTA -> drop:
               IF(XC(I) < (VAL_TESTX_LOW-DX(I) +GEOMEPS)) CYCLE; IF(XC(I) > (VAL_TESTX_HIGH+DX(I)-GEOMEPS)) CYCLE
               IF(YC(J) < (VAL_TESTY_LOW-DY(J) +GEOMEPS)) CYCLE; IF(YC(J) > (VAL_TESTY_HIGH+DY(J)-GEOMEPS)) CYCLE
               IF(ZC(K) < (VAL_TESTZ_LOW-DZ(K) +GEOMEPS)) CYCLE; IF(ZC(K) > (VAL_TESTZ_HIGH+DZ(K)-GEOMEPS)) CYCLE
               IF(CCVAR(I,J,K,CC_CGSC) /= CC_GASPHASE) CYCLE
               NUNKZ_LOC(NM) = NUNKZ_LOC(NM) + 1
               CCVAR(I,J,K,CC_UNKZ) = NUNKZ_LOC(NM)
            ENDDO
         ENDDO
      ENDDO
   ENDIF

   ! Loop on cut-cells and surrounding cartesian cells, number unknowns for cells in LINK_LEV=0:
   DO K=0,KBP1
      DO J=0,JBP1
         DO I=0,IBP1
            ! Drop if cartesian cell is not type CC_CUTCFE:
            IF (  CCVAR(I,J,K,CC_CGSC) /= CC_CUTCFE ) CYCLE
            ! First Add the Cut-Cell:
            ICC  = CCVAR(I,J,K,CC_IDCC) ! The following test excludes GC cut-cells from numbering.
            IF (ICC <= MESHES(NM)%N_CUTCELL_MESH .AND. .NOT.CELL(CELL_INDEX(I,J,K))%SOLID ) THEN
               DO JCC=1,CUT_CELL(ICC)%NCELL
                  IF ( CUT_CELL(ICC)%LINK_LEV(JCC)/=0) CYCLE ! Linked cell, dealt with later.
                  NUNKZ_LOC(NM) = NUNKZ_LOC(NM) + 1
                  CUT_CELL(ICC)%UNKZ(JCC) = NUNKZ_LOC(NM)
               ENDDO
            ENDIF
            ! Surrounding regular cells:
            DO KNGH=K-1,K+1
               IF ( (KNGH < 1) .OR. (KNGH > KBAR) ) CYCLE
               DO JNGH=J-1,J+1
                  IF ( (JNGH < 1) .OR. (JNGH > JBAR) ) CYCLE
                  DO INGH=I-1,I+1
                     ! Either not GASPHASE or already counted:
                     IF ((CCVAR(INGH,JNGH,KNGH,CC_CGSC)/=CC_GASPHASE) .OR. (CCVAR(INGH,JNGH,KNGH,CC_UNKZ)>0)) CYCLE
                     IF ( (INGH < 1) .OR. (INGH > IBAR) ) CYCLE
                     IF (CELL(CELL_INDEX(INGH,JNGH,KNGH))%SOLID) CYCLE
                     ! Add Scalar unknown:
                     NUNKZ_LOC(NM) = NUNKZ_LOC(NM) + 1
                     CCVAR(INGH,JNGH,KNGH,CC_UNKZ) = NUNKZ_LOC(NM)
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO
   ENDDO

   ! The do all link tree levels from -1 to FINEST_LINK_LEV:
   LINK_LEV_DO : DO ILEV=-1,MESHES(NM)%FINEST_LINK_LEV,-1
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            IF (CUT_CELL(ICC)%LINK_LEV(JCC) /= ILEV) CYCLE

            ! Find master cell for this CC:
            I = CUT_CELL(ICC)%IJK_LINK(2,JCC); J = CUT_CELL(ICC)%IJK_LINK(3,JCC); K = CUT_CELL(ICC)%IJK_LINK(4,JCC)
            SELECT CASE(CUT_CELL(ICC)%IJK_LINK(1,JCC))
            CASE(CC_GASPHASE)
               CUT_CELL(ICC)%UNKZ(JCC) = CCVAR(I,J,K,CC_UNKZ)
            CASE(CC_CUTCFE)
               ICC2 = CCVAR(I,J,K,CC_IDCC); JCC2 = CUT_CELL(ICC)%IJK_LINK(5,JCC)
               CUT_CELL(ICC)%UNKZ(JCC) = CUT_CELL(ICC2)%UNKZ(JCC2)
            END SELECT

         ENDDO
      ENDDO
   ENDDO LINK_LEV_DO

ENDDO MAIN_MESH_LOOP

! After fixing cut-cell unkz for a given Cartesian cells there might be UNKZ values that haven't been assigned.
! Condense:
REIND_MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   IF(NUNKZ_LOC(NM) == 0) CYCLE
   CALL POINT_TO_MESH(NM)
   ALLOCATE(CELLPUNKZ(1:NUNKZ_LOC(NM)), INDUNKZ(1:NUNKZ_LOC(NM))); CELLPUNKZ = 0; INDUNKZ = 0;
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF(CCVAR(I,J,K,CC_UNKZ) > 0) CELLPUNKZ(CCVAR(I,J,K,CC_UNKZ)) = CELLPUNKZ(CCVAR(I,J,K,CC_UNKZ)) + 1
         ENDDO
      ENDDO
   ENDDO
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      DO JCC=1,CUT_CELL(ICC)%NCELL
         IF (CUT_CELL(ICC)%UNKZ(JCC) > 0) CELLPUNKZ(CUT_CELL(ICC)%UNKZ(JCC)) = CELLPUNKZ(CUT_CELL(ICC)%UNKZ(JCC)) + 1
      ENDDO
   ENDDO
   ! Now re-index:
   COUNT=0
   DO I=1,NUNKZ_LOC(NM)
      IF(CELLPUNKZ(I) == 0) CYCLE ! This UNKZ_LOC value has no cells associated to it.
      COUNT = COUNT + 1; INDUNKZ(I) = COUNT
   ENDDO
   NUNKZ_LOC(NM) = COUNT
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF(CCVAR(I,J,K,CC_UNKZ) > 0) CCVAR(I,J,K,CC_UNKZ) = INDUNKZ(CCVAR(I,J,K,CC_UNKZ)) ! Condensed value.
         ENDDO
      ENDDO
   ENDDO
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      DO JCC=1,CUT_CELL(ICC)%NCELL
         IF (CUT_CELL(ICC)%UNKZ(JCC) > 0) CUT_CELL(ICC)%UNKZ(JCC) = INDUNKZ(CUT_CELL(ICC)%UNKZ(JCC)) ! Condensed value.
      ENDDO
   ENDDO
   DEALLOCATE(CELLPUNKZ,INDUNKZ)
ENDDO REIND_MESH_LOOP

! Define total number of unknowns and global unknown index start per MESH:
IF (ALLOCATED(NUNKZ_TOT)) DEALLOCATE(NUNKZ_TOT)
ALLOCATE(NUNKZ_TOT(1:NMESHES)); NUNKZ_TOT = 0
IF (N_MPI_PROCESSES > 1) THEN
   CALL MPI_ALLREDUCE(NUNKZ_LOC(1), NUNKZ_TOT(1), NMESHES, MPI_INTEGER, MPI_SUM, MPI_COMM_WORLD, IERR)
ELSE
   NUNKZ_TOT = NUNKZ_LOC
ENDIF
! Define global start indexes for each mesh:
IF (ALLOCATED(UNKZ_ILC)) DEALLOCATE(UNKZ_ILC)
ALLOCATE(UNKZ_ILC(1:NMESHES)); UNKZ_ILC(1:NMESHES) = 0
IF (ALLOCATED(UNKZ_IND)) DEALLOCATE(UNKZ_IND)
ALLOCATE(UNKZ_IND(1:NMESHES)); UNKZ_IND(1:NMESHES) = 0
DO NM=2,NMESHES
   UNKZ_ILC(NM) = UNKZ_ILC(NM-1) + NUNKZ_LOC(NM-1)
   UNKZ_IND(NM) = UNKZ_IND(NM-1) + NUNKZ_TOT(NM-1)
ENDDO

! Cell numbers for Scalar equations in global numeration:
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   CALL POINT_TO_MESH(NM)
   ! 1. Number regular GASPHASE cells within the implicit region:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,CC_CGSC) /= CC_GASPHASE .OR. CCVAR(I,J,K,CC_UNKZ) <= 0 ) CYCLE
            CCVAR(I,J,K,CC_UNKZ) = CCVAR(I,J,K,CC_UNKZ) + UNKZ_IND(NM)
         ENDDO
      ENDDO
   ENDDO
   ! 2. Number cut-cells:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      CC => CUT_CELL(ICC); I = CC%IJK(IAXIS); J = CC%IJK(JAXIS); K = CC%IJK(KAXIS)
      IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
      DO JCC=1,CC%NCELL; CC%UNKZ(JCC) = CC%UNKZ(JCC) + UNKZ_IND(NM); ENDDO
   ENDDO
ENDDO

! Exchange Guardcell + guard cc information on CC_UNKZ:
CALL FILL_UNKZ_GUARDCELLS

! Finally set to solid Gasphase cut-faces which have a surrounding cut-cell inside an OBST:
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   CALL POINT_TO_MESH(NM)
   DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      IF (CUT_FACE(ICF)%STATUS /= CC_GASPHASE) CYCLE
      I=CUT_FACE(ICF)%IJK(IAXIS); J=CUT_FACE(ICF)%IJK(JAXIS); K=CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS=CUT_FACE(ICF)%IJK(KAXIS+1)
      CF_STATUS = CC_GASPHASE
      SELECT CASE(X1AXIS)
      CASE(IAXIS); IF ( CELL(CELL_INDEX(I,J,K))%SOLID .AND. CELL(CELL_INDEX(I+1,J,K))%SOLID ) CF_STATUS = CC_SOLID
      CASE(JAXIS); IF ( CELL(CELL_INDEX(I,J,K))%SOLID .AND. CELL(CELL_INDEX(I,J+1,K))%SOLID ) CF_STATUS = CC_SOLID
      CASE(KAXIS); IF ( CELL(CELL_INDEX(I,J,K))%SOLID .AND. CELL(CELL_INDEX(I,J,K+1))%SOLID ) CF_STATUS = CC_SOLID
      END SELECT
      CUT_FACE(ICF)%STATUS = CF_STATUS
   ENDDO
ENDDO

RETURN
END SUBROUTINE GET_LINKED_MATRIX_INDEXES_Z


SUBROUTINE GET_LINKED_FACE_INDEXES_F

INTEGER :: NM,I,J,K,X1AXIS,X2AXIS,X3AXIS,ICF,JCF,LO_UNKZ,HI_UNKZ,IEC,IEDGE,LOHI,II,JJ,KK,IIO,JJO,KKO,IERC,&
           OFACE(3),OLO_UNKZ,OHI_UNKZ,OICF,OJCF,IECE,JECE,ILINK,ICC,JCC,IW,COUNT
REAL(EB):: ACRT,CCVOL_THRES
LOGICAL :: ALL_FLG,CC_LINKED
TYPE(MESH_TYPE), POINTER :: M=>NULL()
INTEGER :: ILOC,SIZE_FACE
INTEGER, ALLOCATABLE, DIMENSION(:,:) :: FACE_LIST,FACELAUX
REAL(EB), ALLOCATABLE,DIMENSION(:)   :: FACE_AREA,FACEARAUX
TYPE(CC_CUTFACE_TYPE),       POINTER :: CF2

LOGICAL, PARAMETER :: NO_FACE_LINKING = .FALSE.

SIZE_FACE = 20; ALLOCATE(FACE_LIST(4,SIZE_FACE),FACE_AREA(SIZE_FACE))

! Define Face Linking:
! Important approximation: As we do not compute cut-face volumes from the computational geometry engine (4 times cost),
! face volumes are assumed to be composed of Area*DXN; DXN is the cartesian cell size in the normal face direction.
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   M => MESHES(NM)

   ! 1. Run across gasphase cut-faces and number those which have Area*DXN > CCVOL_LINK*DX(I)*DX(2)*DX(3):
   M%NUNK_F = 0
   FACE_LINK_IF : IF (NO_FACE_LINKING) THEN

      ICF_LOOP_0 : DO ICF=1,M%N_CUTFACE_MESH
         CF => M%CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE ICF_LOOP_0
         IF(TWO_D .AND. CF%IJK(KAXIS+1)==JAXIS) CYCLE ICF_LOOP_0
         DO JCF=1,CF%NFACE; M%NUNK_F = M%NUNK_F+1; CF%UNKF(JCF)=M%NUNK_F; CF%LINK_LEV(JCF)=0; ENDDO
      ENDDO ICF_LOOP_0

   ELSE FACE_LINK_IF

   ICF_LOOP_1 : DO ICF=1,M%N_CUTFACE_MESH
      CF => M%CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE ICF_LOOP_1
      IF(TWO_D .AND. CF%IJK(KAXIS+1)==JAXIS) CYCLE ICF_LOOP_1
      ! Give the mesh boundary cut-faces with boundary not periodic or interpolated their own unlinked UNKF.
      IF(CF%IWC>0) THEN
         IF( .NOT.ANY(M%WALL(CF%IWC)%BOUNDARY_TYPE == (/PERIODIC_BOUNDARY,INTERPOLATED_BOUNDARY,OPEN_BOUNDARY/)) ) THEN
            DO JCF=1,CF%NFACE; M%NUNK_F = M%NUNK_F+1; CF%UNKF(JCF)=M%NUNK_F; CF%LINK_LEV(JCF)=0; ENDDO
            CYCLE ICF_LOOP_1
         ENDIF
      ENDIF
      I  = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS)
      SELECT CASE(CF%IJK(KAXIS+1))
      CASE(IAXIS); ACRT = M%DY(J)*M%DZ(K)
      CASE(JAXIS); ACRT = M%DX(I)*M%DZ(K)
      CASE(KAXIS); ACRT = M%DY(J)*M%DX(I)
      END SELECT
      DO JCF=1,CF%NFACE
         ! Test if any of surrounding cut-cells are linked. If any link attempt to link cut-face.
         CC_LINKED = .FALSE.
         DO LOHI=LOW_IND,HIGH_IND
            ICC = CF%CELL_LIST(2,LOHI,JCF); JCC = CF%CELL_LIST(3,LOHI,JCF); CC => M%CUT_CELL(ICC)
            CCVOL_THRES = CCVOL_LINK * (M%DX(CC%IJK(IAXIS))*M%DY(CC%IJK(JAXIS))*M%DZ(CC%IJK(KAXIS)))
            IF ( CC%VOLUME(JCC) <= CCVOL_THRES ) THEN; CC_LINKED = .TRUE.; EXIT; ENDIF
         ENDDO
         ! If surrounding cut-cells not linked, face UNKF not numbered and Area over threshold, add to NUNK_F:
         IF(CF%UNKF(JCF)<1 .AND. CF%AREA(JCF)>CCVOL_LINK*ACRT .AND. .NOT.CC_LINKED) THEN
            M%NUNK_F = M%NUNK_F + 1
            CF%UNKF(JCF) = M%NUNK_F
            CF%LINK_LEV(JCF) = 0
         ENDIF
      ENDDO
   ENDDO ICF_LOOP_1

   ! 2. Link small faces with neighbor faces that share CV, and then Link small faces with neighbor faces:
   ALL_FLG=.FALSE.
   LINK_ITER : DO ILINK=1,N_LINK_ATTMP_F
      IF(ILINK>3) ALL_FLG=.TRUE.
      CALL LINK_FACES_TO_NEIGHBORS(ALL_FLG)
      ! Test For remaining unlinked faces:
      DO ICF=1,M%N_CUTFACE_MESH
         CF => M%CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE
         IF(TWO_D .AND. CF%IJK(KAXIS+1)==JAXIS) CYCLE
         DO JCF=1,CF%NFACE
            IF(CF%UNKF(JCF)<1) CYCLE LINK_ITER
         ENDDO
      ENDDO
      EXIT LINK_ITER
   ENDDO LINK_ITER

   ! Finally force link small unlinked faces or set their UNKF, LINK_LEV=0.
   DO ICF=1,M%N_CUTFACE_MESH
      CF => M%CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE
      IF(TWO_D .AND. CF%IJK(KAXIS+1)==JAXIS) CYCLE
      I = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
      DO JCF=1,CF%NFACE
         IF(CF%UNKF(JCF)>0) CYCLE
         NULLIFY(CF2)
         SELECT CASE(X1AXIS)
         CASE(IAXIS)
            IF(I>0) THEN
               IF(M%FCVAR(I-1,J,K,CC_IDCF,IAXIS)>0) THEN
                  CF2=>M%CUT_FACE(M%FCVAR(I-1,J,K,CC_IDCF,IAXIS))
               ELSEIF(M%FCVAR(I-1,J,K,CC_FGSC,IAXIS)==CC_GASPHASE) THEN
                  IF(M%FCVAR(I-1,J,K,CC_UNKF,IAXIS)<1)THEN; M%NUNK_F=M%NUNK_F+1; M%FCVAR(I-1,J,K,CC_UNKF,IAXIS)=M%NUNK_F; ENDIF
                  CF%UNKF(JCF)=M%FCVAR(I-1,J,K,CC_UNKF,IAXIS); CYCLE
               ENDIF
            ELSEIF(I<M%IBAR) THEN
               IF(M%FCVAR(I+1,J,K,CC_IDCF,IAXIS)>0) THEN
                  CF2=>M%CUT_FACE(M%FCVAR(I+1,J,K,CC_IDCF,IAXIS))
               ELSEIF(M%FCVAR(I+1,J,K,CC_FGSC,IAXIS)==CC_GASPHASE) THEN
                  IF(M%FCVAR(I+1,J,K,CC_UNKF,IAXIS)<1)THEN; M%NUNK_F=M%NUNK_F+1; M%FCVAR(I+1,J,K,CC_UNKF,IAXIS)=M%NUNK_F; ENDIF
                  CF%UNKF(JCF)=M%FCVAR(I+1,J,K,CC_UNKF,IAXIS); CYCLE
               ENDIF
            ENDIF
         CASE(JAXIS)
            IF(J>0) THEN
               IF(M%FCVAR(I,J-1,K,CC_IDCF,JAXIS)>0) THEN
                  CF2=>M%CUT_FACE(M%FCVAR(I,J-1,K,CC_IDCF,JAXIS))
               ELSEIF(M%FCVAR(I,J-1,K,CC_FGSC,JAXIS)==CC_GASPHASE) THEN
                  IF(M%FCVAR(I,J-1,K,CC_UNKF,JAXIS)<1)THEN; M%NUNK_F=M%NUNK_F+1; M%FCVAR(I,J-1,K,CC_UNKF,JAXIS)=M%NUNK_F; ENDIF
                  CF%UNKF(JCF)=M%FCVAR(I,J-1,K,CC_UNKF,JAXIS); CYCLE
               ENDIF
            ELSEIF(J<M%JBAR) THEN
               IF(M%FCVAR(I,J+1,K,CC_IDCF,JAXIS)>0) THEN
                  CF2=>M%CUT_FACE(M%FCVAR(I,J+1,K,CC_IDCF,JAXIS))
               ELSEIF(M%FCVAR(I,J+1,K,CC_FGSC,JAXIS)==CC_GASPHASE) THEN
                  IF(M%FCVAR(I,J+1,K,CC_UNKF,JAXIS)<1)THEN; M%NUNK_F=M%NUNK_F+1; M%FCVAR(I,J+1,K,CC_UNKF,JAXIS)=M%NUNK_F; ENDIF
                  CF%UNKF(JCF)=M%FCVAR(I,J+1,K,CC_UNKF,JAXIS); CYCLE
               ENDIF
            ENDIF
         CASE(KAXIS)
            IF(K>0) THEN
               IF(M%FCVAR(I,J,K-1,CC_IDCF,KAXIS)>0) THEN
                  CF2=>M%CUT_FACE(M%FCVAR(I,J,K-1,CC_IDCF,KAXIS))
               ELSEIF(M%FCVAR(I,J,K-1,CC_FGSC,KAXIS)==CC_GASPHASE) THEN
                  IF(M%FCVAR(I,J,K-1,CC_UNKF,KAXIS)<1)THEN; M%NUNK_F=M%NUNK_F+1; M%FCVAR(I,J,K-1,CC_UNKF,KAXIS)=M%NUNK_F; ENDIF
                  CF%UNKF(JCF)=M%FCVAR(I,J,K-1,CC_UNKF,KAXIS); CYCLE
               ENDIF
            ELSEIF(K<M%KBAR) THEN
               IF(M%FCVAR(I,J,K+1,CC_IDCF,KAXIS)>0) THEN
                  CF2=>M%CUT_FACE(M%FCVAR(I,J,K+1,CC_IDCF,KAXIS))
               ELSEIF(M%FCVAR(I,J,K+1,CC_FGSC,KAXIS)==CC_GASPHASE) THEN
                  IF(M%FCVAR(I,J,K+1,CC_UNKF,KAXIS)<1)THEN; M%NUNK_F=M%NUNK_F+1; M%FCVAR(I,J,K+1,CC_UNKF,KAXIS)=M%NUNK_F; ENDIF
                  CF%UNKF(JCF)=M%FCVAR(I,J,K+1,CC_UNKF,KAXIS); CYCLE
               ENDIF
            ENDIF
         END SELECT
         IF(ASSOCIATED(CF2)) THEN
            IF(CF2%UNKF(1)>0) THEN; CF%UNKF(JCF)=CF2%UNKF(1); CF%LINK_LEV(JCF)=CF2%LINK_LEV(1)-1; ENDIF
         ENDIF
         IF(CF%UNKF(JCF)<1) THEN; CF%UNKF(JCF)=0; CF%LINK_LEV(JCF)=0; ENDIF
      ENDDO
   ENDDO


   ! I = 0; J = 0; K = 0
   ! DO ICF=1,M%N_CUTFACE_MESH
   !    CF => M%CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE
   !    IF(TWO_D .AND. CF%IJK(KAXIS+1)==JAXIS) CYCLE
   !    DO JCF=1,CF%NFACE
   !       IF(CF%UNKF(JCF)>0) THEN
   !          IF(CF%IJK(KAXIS+1)==IAXIS) I=I+1
   !          IF(CF%IJK(KAXIS+1)==JAXIS) J=J+1
   !          IF(CF%IJK(KAXIS+1)==KAXIS) K=K+1
   !          WRITE(LU_ERR,*) ICF,JCF,CF%IJK(1:4),CF%UNKF(JCF)
   !       ENDIF
   !    ENDDO
   ! ENDDO
   ! WRITE(LU_ERR,*) 'N_CUTFACE_MESH,Unassigned CFs,NUNK_F=',ILINK,':',M%N_CUTFACE_MESH,I,J,K,I+J+K,';',M%NUNK_F
   !
   ! DO K=1,M%KBAR
   !    DO J=1,M%JBAR
   !       DO I=0,M%IBAR
   !          IF(M%FCVAR(I,J,K,CC_UNKF,IAXIS)>0) WRITE(LU_ERR,*) 'CRT=',I,J,K,IAXIS,M%FCVAR(I,J,K,CC_UNKF,X1AXIS)
   !       ENDDO
   !    ENDDO
   ! ENDDO

  ENDIF FACE_LINK_IF

  ! Allocate linked face velocity arrays:
  IF(ALLOCATED(M%EWC_UN_LNK)) DEALLOCATE(M%EWC_UN_LNK)
  IF(ALLOCATED(M%UN_LNK)) DEALLOCATE(M%UN_LNK)
  ALLOCATE(M%EWC_UN_LNK(0:M%N_EXTERNAL_WALL_CELLS)); M%EWC_UN_LNK = 0._EB
  ALLOCATE(M%UN_LNK(0:M%NUNK_F)); M%UN_LNK = 0._EB
  DO IW=1,M%N_EXTERNAL_WALL_CELLS
     IF(M%WALL(IW)%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY .OR. M%WALL(IW)%CUT_FACE_INDEX<1) CYCLE
     CF => M%CUT_FACE(M%WALL(IW)%CUT_FACE_INDEX)
     IF(.NOT.ALLOCATED(CF%VEL_LNK)) ALLOCATE(CF%VEL_LNK(1:CF%NFACE)); CF%VEL_LNK = 0._EB
  ENDDO

  ! Allocate UN_ULNK:
  COUNT=0
  DO K=0,M%KBAR
     DO J=0,M%JBAR
        DO I=0,M%IBAR
           IF (M%FCVAR(I,J,K,CC_UNKF,IAXIS)>0) COUNT = COUNT+1
           IF (M%FCVAR(I,J,K,CC_UNKF,JAXIS)>0 .AND. .NOT.TWO_D) COUNT = COUNT+1
           IF (M%FCVAR(I,J,K,CC_UNKF,KAXIS)>0) COUNT = COUNT+1
        ENDDO
     ENDDO
  ENDDO
  DO ICF=1,M%CC_NRCFACE_Z
     IF(M%RC_FACE(ICF)%UNKF<1) CYCLE
     I = M%RC_FACE(ICF)%IJK(IAXIS); J = M%RC_FACE(ICF)%IJK(JAXIS); K = M%RC_FACE(ICF)%IJK(KAXIS)
     X1AXIS = M%RC_FACE(ICF)%IJK(KAXIS+1)
     SELECT CASE(X1AXIS)
     CASE(IAXIS); COUNT = COUNT+1
     CASE(JAXIS); IF(.NOT.TWO_D) COUNT = COUNT+1
     CASE(KAXIS); COUNT = COUNT+1
     END SELECT
  ENDDO
  DO ICF=1,M%N_CUTFACE_MESH
     CF => M%CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE
     IF(TWO_D .AND. CF%IJK(KAXIS+1)==JAXIS) CYCLE
     I = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
     DO JCF=1,CF%NFACE
        IF (CF%UNKF(JCF)<1) CYCLE
        COUNT = COUNT+1
     ENDDO
  ENDDO
  DO IW=1,M%N_EXTERNAL_WALL_CELLS
     WC=>M%WALL(IW)
     IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE
     EWC=>M%EXTERNAL_WALL(IW)
     BC =>M%BOUNDARY_COORD(WC%BC_INDEX)
     I  = BC%II; J = BC%JJ; K = BC%KK; X1AXIS = ABS(BC%IOR)
     SELECT CASE(BC%IOR)
     CASE(-IAXIS); I=I-1
     CASE(-JAXIS); J=J-1
     CASE(-KAXIS); K=K-1
     END SELECT
     IF(M%FCVAR(I,J,K,CC_IDCF,X1AXIS)>0) THEN ! Cut-face.
        ICF=M%FCVAR(I,J,K,CC_IDCF,X1AXIS)
        COUNT=COUNT+M%CUT_FACE(ICF)%NFACE
     ELSE ! All other reg faces.
        COUNT = COUNT + 1
     ENDIF
  ENDDO
  IF(ALLOCATED(M%UN_ULNK)) DEALLOCATE(M%UN_ULNK)
  ALLOCATE(M%UN_ULNK(COUNT)); M%UN_ULNK = 0._EB

ENDDO MESH_LOOP
DEALLOCATE(FACE_LIST,FACE_AREA)

RETURN
CONTAINS

SUBROUTINE LINK_FACES_TO_NEIGHBORS(ALL_FLG)

LOGICAL, INTENT(IN) :: ALL_FLG

LOGICAL, PARAMETER  :: CANDIDATE_LIST=.TRUE.

IF(.NOT.CANDIDATE_LIST) THEN

ICF_LOOP_2 : DO ICF=1,M%N_CUTFACE_MESH
   CF => M%CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE ICF_LOOP_2
   I  = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
   SELECT CASE(X1AXIS)
   CASE(IAXIS) ! Face in X axis:
       ACRT = M%DY(J)*M%DZ(K)
       IAXIS_JCF_LOOP : DO JCF=1,CF%NFACE
          IF(CF%UNKF(JCF)<1) THEN ! .AND. CF%AREA(JCF) < CCVOL_LINK*ACRT+TWO_EPSILON_EB) THEN
             LO_UNKZ = CF%UNKZ(LOW_IND, JCF)
             HI_UNKZ = CF%UNKZ(HIGH_IND,JCF)
             ! Loop edges to find next face in X2AXIS, X3AXIS plane:
             IAXIS_IEC_LOOP : DO IEC=2,CF%CEDGES(1,JCF)+1
                IEDGE = CF%CEDGES(IEC,JCF)
                IAXIS_IEC_SELECT : SELECT CASE(CF%EDGE_LIST(1,IEDGE))
                CASE(CC_ETYPE_RGGAS) IAXIS_IEC_SELECT ! Cut-faces Regular Gas Edge.
                   LOHI   = CF%EDGE_LIST(2,IEDGE)
                   X2AXIS = CF%EDGE_LIST(3,IEDGE)
                   IF (X2AXIS==JAXIS) THEN ! Edge pointed in X3AXIS=KAXIS direction.
                      X3AXIS = KAXIS; II=I; JJ=J; KK=K; IF(LOHI==LOW_IND) JJ=J-1
                      IERC   = M%ECVAR(II,JJ,KK,CC_IDCE,X3AXIS); IF(IERC==0) CYCLE IAXIS_IEC_LOOP ! Index in CC_RCEDGE
                      IF(LOHI==LOW_IND) THEN ! Indexes of other Cartesian face @ J-1
                         IIO=I; JJO=J-1; KKO=K; OFACE(1:3) = M%CC_RCEDGE(IERC)%FACE_LIST(1:3,-2) ! X Face in low J
                      ELSE ! Indexes of other Cartesian face @ J+1
                         IIO=I; JJO=J+1; KKO=K; OFACE(1:3) = M%CC_RCEDGE(IERC)%FACE_LIST(1:3, 2) ! X Face in high J
                      ENDIF
                      IF(JJO<1 .OR. JJO>M%JBAR) CYCLE IAXIS_IEC_LOOP
                   ELSEIF(X2AXIS==KAXIS) THEN ! Edge pointed in X3AXIS=JAXIS direction.
                      X3AXIS = JAXIS; II=I; JJ=J; KK=K; IF(LOHI==LOW_IND) KK=K-1
                      IERC   = M%ECVAR(II,JJ,KK,CC_IDCE,X3AXIS); IF(IERC==0) CYCLE IAXIS_IEC_LOOP
                      IF(LOHI==LOW_IND) THEN ! Indexes of other Cartesian face @ K-1
                         IIO=I; JJO=J; KKO=K-1; OFACE(1:3) = M%CC_RCEDGE(IERC)%FACE_LIST(1:3,-1) ! Face in low K
                      ELSE ! Indexes of other Cartesian face @ K+1
                         IIO=I; JJO=J; KKO=K+1; OFACE(1:3) = M%CC_RCEDGE(IERC)%FACE_LIST(1:3, 1) ! Face in high K
                      ENDIF
                      IF(KKO<1 .OR. KKO>M%KBAR) CYCLE IAXIS_IEC_LOOP
                   ENDIF
                   ! Now look for other potential face and link CF%UNKF(JCF):
                   IAXIS_OFACE_SELECT : SELECT CASE (OFACE(1))
                   CASE(CC_FTYPE_RGGAS) IAXIS_OFACE_SELECT
                      OLO_UNKZ = M%CCVAR(IIO  ,JJO  ,KKO  ,CC_UNKZ)
                      OHI_UNKZ = M%CCVAR(IIO+1,JJO  ,KKO  ,CC_UNKZ)
                      IF(LO_UNKZ==OLO_UNKZ .OR. HI_UNKZ==OHI_UNKZ .OR. ALL_FLG) THEN ! Link cut-face to regular face:
                         IF(M%FCVAR(IIO,JJO,KKO,CC_UNKF,X1AXIS)<1) THEN
                             M%NUNK_F = M%NUNK_F + 1
                             M%FCVAR(IIO,JJO,KKO,CC_UNKF,X1AXIS) = M%NUNK_F
                         ENDIF
                         CF%UNKF(JCF)     = M%FCVAR(IIO,JJO,KKO,CC_UNKF,X1AXIS)
                         CF%LINK_LEV(JCF) = -1
                         CYCLE IAXIS_JCF_LOOP
                      ENDIF
                   CASE(CC_FTYPE_RCGAS) IAXIS_OFACE_SELECT
                      OICF     = OFACE(2)
                      OLO_UNKZ = M%RC_FACE(OICF)%UNKZ(LOW_IND)
                      OHI_UNKZ = M%RC_FACE(OICF)%UNKZ(HIGH_IND)
                      IF(LO_UNKZ==OLO_UNKZ .OR. HI_UNKZ==OHI_UNKZ .OR. ALL_FLG) THEN ! Link cut-face to RC face:
                         IF(M%RC_FACE(OICF)%UNKF<1) THEN
                             M%NUNK_F = M%NUNK_F + 1
                             M%RC_FACE(OICF)%UNKF = M%NUNK_F
                         ENDIF
                         CF%UNKF(JCF)     = M%RC_FACE(OICF)%UNKF
                         CF%LINK_LEV(JCF) = -1
                         CYCLE IAXIS_JCF_LOOP
                      ENDIF
                   CASE(CC_FTYPE_CFGAS) IAXIS_OFACE_SELECT
                      OICF     = OFACE(2); OJCF     = OFACE(3)
                      OLO_UNKZ = M%CUT_FACE(OICF)%UNKZ(LOW_IND,OJCF)
                      OHI_UNKZ = M%CUT_FACE(OICF)%UNKZ(HIGH_IND,OJCF)
                      IF(LO_UNKZ==OLO_UNKZ .OR. HI_UNKZ==OHI_UNKZ .OR. ALL_FLG) THEN ! Link cut-face to other cut-face:
                          IF(M%CUT_FACE(OICF)%UNKF(OJCF)>0) THEN
                             CF%UNKF(JCF)     = M%CUT_FACE(OICF)%UNKF(OJCF)
                             CF%LINK_LEV(JCF) = M%CUT_FACE(OICF)%LINK_LEV(OJCF) - 1
                             CYCLE IAXIS_JCF_LOOP
                          ELSEIF(CF%AREA(JCF)+M%CUT_FACE(OICF)%AREA(OJCF) > CCVOL_LINK * ACRT) THEN
                             M%NUNK_F = M%NUNK_F + 1
                             CF%UNKF(JCF) = M%NUNK_F; M%CUT_FACE(OICF)%UNKF(OJCF) = M%NUNK_F
                             CF%LINK_LEV(JCF) = -1; M%CUT_FACE(OICF)%LINK_LEV(OJCF) = -1
                             CYCLE IAXIS_JCF_LOOP
                          ENDIF
                      ENDIF
                   END SELECT IAXIS_OFACE_SELECT

                CASE(CC_ETYPE_CFGAS) IAXIS_IEC_SELECT ! Gas cut-edge.
                   IECE = CF%EDGE_LIST(2,IEDGE); JECE = CF%EDGE_LIST(3,IEDGE)
                   II=M%CUT_EDGE(IECE)%IJK(IAXIS); JJ=M%CUT_EDGE(IECE)%IJK(JAXIS); KK=M%CUT_EDGE(IECE)%IJK(KAXIS);
                   X3AXIS = M%CUT_EDGE(IECE)%IJK(KAXIS+1);
                   IF (X3AXIS==KAXIS) THEN ! X3AXIS==Edge Axis, X2AXIS = JAXIS
                      IF(JJ==J-1) THEN ! LOWER cut-face in the J direction.
                         IIO = I; JJO = J-1; KKO = K ! Indexes of other Cartesian face @ J-1
                         OFACE(2:3) = M%CUT_EDGE(IECE)%FACE_LIST(1:2,-2, JECE) ! X Face in low J
                      ELSEIF(JJ==J) THEN ! UPPER cut-face in the J direction.
                         IIO = I; JJO = J+1; KKO = K ! Indexes of other Cartesian face @ J+1
                         OFACE(2:3) = M%CUT_EDGE(IECE)%FACE_LIST(1:2, 2, JECE) ! X Face in high J
                      ENDIF
                      IF(JJO<1 .OR. JJO>M%JBAR) CYCLE IAXIS_IEC_LOOP
                   ELSEIF (X3AXIS==JAXIS) THEN ! X2AXIS = KAXIS
                      IF(KK==K-1) THEN ! LOWER cut-face in the K direction.
                         IIO = I; JJO = J; KKO = K-1 ! Indexes of other Cartesian face @ K-1
                         OFACE(2:3) = M%CUT_EDGE(IECE)%FACE_LIST(1:2,-1, JECE) ! X Face in low K
                      ELSEIF(KK==K) THEN ! UPPER cut-face in the K direction.
                         IIO = I; JJO = J; KKO = K+1 ! Indexes of other Cartesian face @ K+1
                         OFACE(2:3) = M%CUT_EDGE(IECE)%FACE_LIST(1:2, 1, JECE) ! X Face in high K
                      ENDIF
                      IF(KKO<1 .OR. KKO>M%KBAR) CYCLE IAXIS_IEC_LOOP
                   ENDIF
                   OICF     = OFACE(2); OJCF     = OFACE(3)
                   IF(OICF<1 .OR. OJCF<1) CYCLE IAXIS_IEC_LOOP
                   OLO_UNKZ = M%CUT_FACE(OICF)%UNKZ(LOW_IND,OJCF)
                   OHI_UNKZ = M%CUT_FACE(OICF)%UNKZ(HIGH_IND,OJCF)
                   IF(LO_UNKZ==OLO_UNKZ .OR. HI_UNKZ==OHI_UNKZ .OR. ALL_FLG) THEN ! Link cut-face to other cut-face:
                       IF(M%CUT_FACE(OICF)%UNKF(OJCF)>0) THEN
                          CF%UNKF(JCF)     = M%CUT_FACE(OICF)%UNKF(OJCF)
                          CF%LINK_LEV(JCF) = M%CUT_FACE(OICF)%LINK_LEV(OJCF) - 1
                          CYCLE IAXIS_JCF_LOOP
                       ELSEIF(CF%AREA(JCF)+M%CUT_FACE(OICF)%AREA(OJCF) > CCVOL_LINK * ACRT) THEN
                          M%NUNK_F = M%NUNK_F + 1
                          CF%UNKF(JCF) = M%NUNK_F; M%CUT_FACE(OICF)%UNKF(OJCF) = M%NUNK_F
                          CF%LINK_LEV(JCF) = -1; M%CUT_FACE(OICF)%LINK_LEV(OJCF) = -1
                          CYCLE IAXIS_JCF_LOOP
                       ENDIF
                   ENDIF
                END SELECT IAXIS_IEC_SELECT
             ENDDO IAXIS_IEC_LOOP
          ENDIF
       ENDDO IAXIS_JCF_LOOP
   CASE(JAXIS)
       IF (TWO_D) CYCLE ICF_LOOP_2
       ACRT = M%DX(I)*M%DZ(K)
       JAXIS_JCF_LOOP : DO JCF=1,CF%NFACE
          IF(CF%UNKF(JCF)<1) THEN ! .AND. CF%AREA(JCF) < CCVOL_LINK*ACRT+TWO_EPSILON_EB) THEN
             LO_UNKZ = CF%UNKZ(LOW_IND, JCF)
             HI_UNKZ = CF%UNKZ(HIGH_IND,JCF)
             ! Loop edges to find next face in X2AXIS, X3AXIS plane:
             JAXIS_IEC_LOOP : DO IEC=2,CF%CEDGES(1,JCF)+1
                IEDGE = CF%CEDGES(IEC,JCF)
                JAXIS_IEC_SELECT : SELECT CASE(CF%EDGE_LIST(1,IEDGE))
                CASE(CC_ETYPE_RGGAS) JAXIS_IEC_SELECT ! Cut-faces Regular Gas Edge.
                   LOHI   = CF%EDGE_LIST(2,IEDGE)
                   X2AXIS = CF%EDGE_LIST(3,IEDGE)
                   IF (X2AXIS==IAXIS) THEN ! Edge pointed in X3AXIS=KAXIS direction.
                      X3AXIS = KAXIS; II=I; JJ=J; KK=K; IF(LOHI==LOW_IND) II=I-1
                      IERC   = M%ECVAR(II,JJ,KK,CC_IDCE,X3AXIS); IF(IERC==0) CYCLE JAXIS_IEC_LOOP ! Index in CC_RCEDGE
                      IF(LOHI==LOW_IND) THEN ! Indexes of other Cartesian face @ I-1
                         IIO=I-1; JJO=J; KKO=K; OFACE(1:3) = M%CC_RCEDGE(IERC)%FACE_LIST(1:3,-1) ! Y Face in low I
                      ELSE ! Indexes of other Cartesian face @ I+1
                         IIO=I+1; JJO=J; KKO=K; OFACE(1:3) = M%CC_RCEDGE(IERC)%FACE_LIST(1:3, 1) ! Y Face in high I
                      ENDIF
                      IF(IIO<1 .OR. IIO>M%IBAR) CYCLE JAXIS_IEC_LOOP
                   ELSEIF(X2AXIS==KAXIS) THEN ! Edge pointed in X3AXIS=IAXIS direction.
                      X3AXIS = IAXIS; II=I; JJ=J; KK=K; IF(LOHI==LOW_IND) KK=K-1
                      IERC   = M%ECVAR(II,JJ,KK,CC_IDCE,X3AXIS); IF(IERC==0) CYCLE JAXIS_IEC_LOOP
                      IF(LOHI==LOW_IND) THEN ! Indexes of other Cartesian face @ K-1
                         IIO=I; JJO=J; KKO=K-1; OFACE(1:3) = M%CC_RCEDGE(IERC)%FACE_LIST(1:3,-2) ! Y Face in low K
                      ELSE ! Indexes of other Cartesian face @ K+1
                         IIO=I; JJO=J; KKO=K+1; OFACE(1:3) = M%CC_RCEDGE(IERC)%FACE_LIST(1:3, 2) ! Y Face in high K
                      ENDIF
                      IF(KKO<1 .OR. KKO>M%KBAR) CYCLE JAXIS_IEC_LOOP
                   ENDIF
                   ! Now look for other potential face and link CF%UNKF(JCF):
                   JAXIS_OFACE_SELECT : SELECT CASE (OFACE(1))
                   CASE(CC_FTYPE_RGGAS) JAXIS_OFACE_SELECT
                      OLO_UNKZ = M%CCVAR(IIO  ,JJO  ,KKO  ,CC_UNKZ)
                      OHI_UNKZ = M%CCVAR(IIO  ,JJO+1,KKO  ,CC_UNKZ)
                      IF(LO_UNKZ==OLO_UNKZ .OR. HI_UNKZ==OHI_UNKZ .OR. ALL_FLG) THEN ! Link cut-face to regular face:
                         IF(M%FCVAR(IIO,JJO,KKO,CC_UNKF,X1AXIS)<1) THEN
                             M%NUNK_F = M%NUNK_F + 1
                             M%FCVAR(IIO,JJO,KKO,CC_UNKF,X1AXIS) = M%NUNK_F
                         ENDIF
                         CF%UNKF(JCF)     = M%FCVAR(IIO,JJO,KKO,CC_UNKF,X1AXIS)
                         CF%LINK_LEV(JCF) = -1
                         ! IF(I==35 .AND. J== 1 .AND. K==15) &
                         ! WRITE(LU_ERR,*) X3AXIS,'ETYPE_RGGAS, RGGAS J= 1=',I,J,K,IIO,JJO,KKO
                         ! IF(I==35 .AND. J==30 .AND. K==15) &
                         ! WRITE(LU_ERR,*) X3AXIS,'ETYPE_RGGAS, RGGAS J=30=',I,J,K,IIO,JJO,KKO
                         CYCLE JAXIS_JCF_LOOP
                      ENDIF
                   CASE(CC_FTYPE_RCGAS) JAXIS_OFACE_SELECT
                      OICF     = OFACE(2)
                      OLO_UNKZ = M%RC_FACE(OICF)%UNKZ(LOW_IND)
                      OHI_UNKZ = M%RC_FACE(OICF)%UNKZ(HIGH_IND)
                      IF(LO_UNKZ==OLO_UNKZ .OR. HI_UNKZ==OHI_UNKZ .OR. ALL_FLG) THEN ! Link cut-face to RC face:
                         IF(M%RC_FACE(OICF)%UNKF<1) THEN
                             M%NUNK_F = M%NUNK_F + 1
                             M%RC_FACE(OICF)%UNKF = M%NUNK_F
                         ENDIF
                         CF%UNKF(JCF)     = M%RC_FACE(OICF)%UNKF
                         CF%LINK_LEV(JCF) = -1
                         ! IF(I==35 .AND. J== 1 .AND. K==15) &
                         ! WRITE(LU_ERR,*) X3AXIS,'ETYPE_RGGAS, RCGAS J= 1=',I,J,K,IIO,JJO,KKO
                         ! IF(I==35 .AND. J==30 .AND. K==15) &
                         ! WRITE(LU_ERR,*) X3AXIS,'ETYPE_RGGAS, RCGAS J=30=',I,J,K,IIO,JJO,KKO
                         CYCLE JAXIS_JCF_LOOP
                      ENDIF
                   CASE(CC_FTYPE_CFGAS) JAXIS_OFACE_SELECT
                      OICF     = OFACE(2); OJCF     = OFACE(3)
                      OLO_UNKZ = M%CUT_FACE(OICF)%UNKZ(LOW_IND,OJCF)
                      OHI_UNKZ = M%CUT_FACE(OICF)%UNKZ(HIGH_IND,OJCF)
                      IF(LO_UNKZ==OLO_UNKZ .OR. HI_UNKZ==OHI_UNKZ .OR. ALL_FLG) THEN ! Link cut-face to other cut-face:
                          IF(M%CUT_FACE(OICF)%UNKF(OJCF)>0) THEN
                             CF%UNKF(JCF)     = M%CUT_FACE(OICF)%UNKF(OJCF)
                             CF%LINK_LEV(JCF) = M%CUT_FACE(OICF)%LINK_LEV(OJCF) - 1
                             ! IF(I==35 .AND. J== 1 .AND. K==15) &
                             ! WRITE(LU_ERR,*) X3AXIS,'ETYPE_RGGAS, CFGAS1 J= 1=',I,J,K,IIO,JJO,KKO
                             ! IF(I==35 .AND. J==30 .AND. K==15) &
                             ! WRITE(LU_ERR,*) X3AXIS,'ETYPE_RGGAS, CFGAS1 J=30=',I,J,K,IIO,JJO,KKO
                             CYCLE JAXIS_JCF_LOOP
                          ELSEIF(CF%AREA(JCF)+M%CUT_FACE(OICF)%AREA(OJCF) > CCVOL_LINK * ACRT) THEN
                             M%NUNK_F = M%NUNK_F + 1
                             CF%UNKF(JCF) = M%NUNK_F; M%CUT_FACE(OICF)%UNKF(OJCF) = M%NUNK_F
                             CF%LINK_LEV(JCF) = -1; M%CUT_FACE(OICF)%LINK_LEV(OJCF) = -1
                             ! IF(I==35 .AND. J== 1 .AND. K==15) &
                             ! WRITE(LU_ERR,*) X3AXIS,'ETYPE_RGGAS, CFGAS2 J= 1=',I,J,K,IIO,JJO,KKO
                             ! IF(I==35 .AND. J==30 .AND. K==15) &
                             ! WRITE(LU_ERR,*) X3AXIS,'ETYPE_RGGAS, CFGAS2 J=30=',I,J,K,IIO,JJO,KKO
                             CYCLE JAXIS_JCF_LOOP
                          ENDIF
                      ENDIF
                   END SELECT JAXIS_OFACE_SELECT

                CASE(CC_ETYPE_CFGAS) JAXIS_IEC_SELECT ! Gas cut-edge.
                   IECE = CF%EDGE_LIST(2,IEDGE);  JECE = CF%EDGE_LIST(3,IEDGE)
                   II=M%CUT_EDGE(IECE)%IJK(IAXIS); JJ=M%CUT_EDGE(IECE)%IJK(JAXIS); KK=M%CUT_EDGE(IECE)%IJK(KAXIS);
                   X3AXIS = M%CUT_EDGE(IECE)%IJK(KAXIS+1);
                   IF (X3AXIS==KAXIS) THEN ! X3AXIS==Edge Axis, X2AXIS = IAXIS
                      IF(II==I-1) THEN ! LOWER cut-face in the I direction.
                         IIO = I-1; JJO = J; KKO = K ! Indexes of other Cartesian face @ I-1
                         OFACE(2:3) = M%CUT_EDGE(IECE)%FACE_LIST(1:2,-1, JECE) ! Y Face in low I
                      ELSEIF(II==I) THEN ! UPPER cut-face in the I direction.
                         IIO = I+1; JJO = J; KKO = K ! Indexes of other Cartesian face @ I+1
                         OFACE(2:3) = M%CUT_EDGE(IECE)%FACE_LIST(1:2, 1, JECE) ! Y Face in high I
                      ENDIF
                      IF(IIO<1 .OR. IIO>M%IBAR) CYCLE JAXIS_IEC_LOOP
                   ELSEIF (X3AXIS==IAXIS) THEN ! X2AXIS = KAXIS
                      IF(KK==K-1) THEN ! LOWER cut-face in the K direction.
                         IIO = I; JJO = J; KKO = K-1 ! Indexes of other Cartesian face @ K-1
                         OFACE(2:3) = M%CUT_EDGE(IECE)%FACE_LIST(1:2,-2, JECE) ! Y Face in low K
                      ELSEIF(KK==K) THEN ! UPPER cut-face in the K direction.
                         IIO = I; JJO = J; KKO = K+1 ! Indexes of other Cartesian face @ K+1
                         OFACE(2:3) = M%CUT_EDGE(IECE)%FACE_LIST(1:2, 2, JECE) ! Y Face in high K
                      ENDIF
                      IF(KKO<1 .OR. KKO>M%KBAR) CYCLE JAXIS_IEC_LOOP
                   ENDIF
                   OICF     = OFACE(2); OJCF     = OFACE(3)
                   IF(OICF<1 .OR. OJCF<1) CYCLE JAXIS_IEC_LOOP
                   OLO_UNKZ = M%CUT_FACE(OICF)%UNKZ(LOW_IND,OJCF)
                   OHI_UNKZ = M%CUT_FACE(OICF)%UNKZ(HIGH_IND,OJCF)
                   IF(LO_UNKZ==OLO_UNKZ .OR. HI_UNKZ==OHI_UNKZ .OR. ALL_FLG) THEN ! Link cut-face to other cut-face:
                       IF(M%CUT_FACE(OICF)%UNKF(OJCF)>0) THEN
                          CF%UNKF(JCF)     = M%CUT_FACE(OICF)%UNKF(OJCF)
                          CF%LINK_LEV(JCF) = M%CUT_FACE(OICF)%LINK_LEV(OJCF) - 1
                          ! IF(I==35 .AND. J== 1 .AND. K==15) &
                          ! WRITE(LU_ERR,*) X3AXIS,'ETYPE_RGGAS, CFGAS1 J= 1=',I,J,K,IIO,JJO,KKO
                          ! IF(I==35 .AND. J==30 .AND. K==15) &
                          ! WRITE(LU_ERR,*) X3AXIS,'ETYPE_RGGAS, CFGAS1 J=30=',I,J,K,IIO,JJO,KKO
                          CYCLE JAXIS_JCF_LOOP
                       ELSEIF(CF%AREA(JCF)+M%CUT_FACE(OICF)%AREA(OJCF) > CCVOL_LINK * ACRT) THEN
                          M%NUNK_F = M%NUNK_F + 1
                          CF%UNKF(JCF) = M%NUNK_F; M%CUT_FACE(OICF)%UNKF(OJCF) = M%NUNK_F
                          CF%LINK_LEV(JCF) = -1; M%CUT_FACE(OICF)%LINK_LEV(OJCF) = -1
                          ! IF(I==35 .AND. J== 1 .AND. K==15) &
                          ! WRITE(LU_ERR,*) X3AXIS,'ETYPE_RGGAS, CFGAS2 J= 1=',I,J,K,IIO,JJO,KKO
                          ! IF(I==35 .AND. J==30 .AND. K==15) &
                          ! WRITE(LU_ERR,*) X3AXIS,'ETYPE_RGGAS, CFGAS2 J=30=',I,J,K,IIO,JJO,KKO
                          CYCLE JAXIS_JCF_LOOP
                       ENDIF
                   ENDIF
                END SELECT JAXIS_IEC_SELECT
             ENDDO JAXIS_IEC_LOOP
          ENDIF
       ENDDO JAXIS_JCF_LOOP

   CASE(KAXIS)
       ACRT = M%DY(J)*M%DX(I)
       KAXIS_JCF_LOOP : DO JCF=1,CF%NFACE
          IF(CF%UNKF(JCF)<1) THEN ! .AND. CF%AREA(JCF) < CCVOL_LINK*ACRT+TWO_EPSILON_EB) THEN
             LO_UNKZ = CF%UNKZ(LOW_IND, JCF)
             HI_UNKZ = CF%UNKZ(HIGH_IND,JCF)
             ! Loop edges to find next face in X2AXIS, X3AXIS plane:
             KAXIS_IEC_LOOP : DO IEC=2,CF%CEDGES(1,JCF)+1
                IEDGE = CF%CEDGES(IEC,JCF)
                KAXIS_IEC_SELECT : SELECT CASE(CF%EDGE_LIST(1,IEDGE))
                CASE(CC_ETYPE_RGGAS) KAXIS_IEC_SELECT ! Cut-faces Regular Gas Edge.
                   LOHI   = CF%EDGE_LIST(2,IEDGE)
                   X2AXIS = CF%EDGE_LIST(3,IEDGE)
                   IF (X2AXIS==IAXIS) THEN ! Edge pointed in X3AXIS=JAXIS direction.
                      X3AXIS = JAXIS; II=I; JJ=J; KK=K; IF(LOHI==LOW_IND) II=I-1
                      IERC   = M%ECVAR(II,JJ,KK,CC_IDCE,X3AXIS); IF(IERC==0) CYCLE KAXIS_IEC_LOOP ! Index in CC_RCEDGE
                      !WRITE(LU_ERR,*) 'EDGE=',IERC,II,JJ,KK,X3AXIS,', CF=',I,J,K,X1AXIS
                      IF(LOHI==LOW_IND) THEN ! Indexes of other Cartesian face @ I-1
                         IIO=I-1; JJO=J; KKO=K; OFACE(1:3) = M%CC_RCEDGE(IERC)%FACE_LIST(1:3,-2) ! Z Face in low I
                      ELSE ! Indexes of other Cartesian face @ I+1
                         IIO=I+1; JJO=J; KKO=K; OFACE(1:3) = M%CC_RCEDGE(IERC)%FACE_LIST(1:3, 2) ! Z Face in high I
                      ENDIF
                      IF(IIO<1 .OR. IIO>M%IBAR) CYCLE KAXIS_IEC_LOOP
                   ELSEIF(X2AXIS==JAXIS) THEN ! Edge pointed in X3AXIS=IAXIS direction.
                      X3AXIS = IAXIS; II=I; JJ=J; KK=K; IF(LOHI==LOW_IND) JJ=J-1
                      IERC   = M%ECVAR(II,JJ,KK,CC_IDCE,X3AXIS); IF(IERC==0) CYCLE KAXIS_IEC_LOOP
                      IF(LOHI==LOW_IND) THEN ! Indexes of other Cartesian face @ J-1
                         IIO=I; JJO=J-1; KKO=K; OFACE(1:3) = M%CC_RCEDGE(IERC)%FACE_LIST(1:3,-1) ! Z Face in low J
                      ELSE ! Indexes of other Cartesian face @ J+1
                         IIO=I; JJO=J+1; KKO=K; OFACE(1:3) = M%CC_RCEDGE(IERC)%FACE_LIST(1:3, 1) ! Z Face in high J
                      ENDIF
                      IF(JJO<1 .OR. JJO>M%JBAR) CYCLE KAXIS_IEC_LOOP
                   ENDIF
                   ! Now look for other potential face and link CF%UNKF(JCF):
                   KAXIS_OFACE_SELECT : SELECT CASE (OFACE(1))
                   CASE(CC_FTYPE_RGGAS) KAXIS_OFACE_SELECT
                      OLO_UNKZ = M%CCVAR(IIO  ,JJO  ,KKO  ,CC_UNKZ)
                      OHI_UNKZ = M%CCVAR(IIO  ,JJO  ,KKO+1,CC_UNKZ)
                      IF(LO_UNKZ==OLO_UNKZ .OR. HI_UNKZ==OHI_UNKZ .OR. ALL_FLG) THEN ! Link cut-face to regular face:
                         IF(M%FCVAR(IIO,JJO,KKO,CC_UNKF,X1AXIS)<1) THEN
                             M%NUNK_F = M%NUNK_F + 1
                             M%FCVAR(IIO,JJO,KKO,CC_UNKF,X1AXIS) = M%NUNK_F
                         ENDIF
                         CF%UNKF(JCF)     = M%FCVAR(IIO,JJO,KKO,CC_UNKF,X1AXIS)
                         CF%LINK_LEV(JCF) = -1
                         CYCLE KAXIS_JCF_LOOP
                      ENDIF
                   CASE(CC_FTYPE_RCGAS) KAXIS_OFACE_SELECT
                      OICF     = OFACE(2)
                      OLO_UNKZ = M%RC_FACE(OICF)%UNKZ(LOW_IND)
                      OHI_UNKZ = M%RC_FACE(OICF)%UNKZ(HIGH_IND)
                      IF(LO_UNKZ==OLO_UNKZ .OR. HI_UNKZ==OHI_UNKZ .OR. ALL_FLG) THEN ! Link cut-face to RC face:
                         IF(M%RC_FACE(OICF)%UNKF<1) THEN
                             M%NUNK_F = M%NUNK_F + 1
                             M%RC_FACE(OICF)%UNKF = M%NUNK_F
                         ENDIF
                         CF%UNKF(JCF)     = M%RC_FACE(OICF)%UNKF
                         CF%LINK_LEV(JCF) = -1
                         CYCLE KAXIS_JCF_LOOP
                      ENDIF
                   CASE(CC_FTYPE_CFGAS) KAXIS_OFACE_SELECT
                      OICF     = OFACE(2); OJCF     = OFACE(3)
                      OLO_UNKZ = M%CUT_FACE(OICF)%UNKZ(LOW_IND,OJCF)
                      OHI_UNKZ = M%CUT_FACE(OICF)%UNKZ(HIGH_IND,OJCF)
                      IF(LO_UNKZ==OLO_UNKZ .OR. HI_UNKZ==OHI_UNKZ .OR. ALL_FLG) THEN ! Link cut-face to other cut-face:
                          IF(M%CUT_FACE(OICF)%UNKF(OJCF)>0) THEN
                             CF%UNKF(JCF)     = M%CUT_FACE(OICF)%UNKF(OJCF)
                             CF%LINK_LEV(JCF) = M%CUT_FACE(OICF)%LINK_LEV(OJCF) - 1
                             CYCLE KAXIS_JCF_LOOP
                          ELSEIF(CF%AREA(JCF)+M%CUT_FACE(OICF)%AREA(OJCF) > CCVOL_LINK * ACRT) THEN
                             M%NUNK_F = M%NUNK_F + 1
                             CF%UNKF(JCF) = M%NUNK_F; M%CUT_FACE(OICF)%UNKF(OJCF) = M%NUNK_F
                             CF%LINK_LEV(JCF) = -1; M%CUT_FACE(OICF)%LINK_LEV(OJCF) = -1
                             CYCLE KAXIS_JCF_LOOP
                          ENDIF
                      ENDIF
                   END SELECT KAXIS_OFACE_SELECT

                CASE(CC_ETYPE_CFGAS) KAXIS_IEC_SELECT ! Gas cut-edge.
                   IECE = CF%EDGE_LIST(2,IEDGE);  JECE = CF%EDGE_LIST(3,IEDGE)
                   II=M%CUT_EDGE(IECE)%IJK(IAXIS); JJ=M%CUT_EDGE(IECE)%IJK(JAXIS); KK=M%CUT_EDGE(IECE)%IJK(KAXIS);
                   X3AXIS = M%CUT_EDGE(IECE)%IJK(KAXIS+1);
                   IF (X3AXIS==JAXIS) THEN ! X3AXIS==Edge Axis, X2AXIS = IAXIS
                      IF(II==I-1) THEN ! LOWER cut-face in the I direction.
                         IIO = I-1; JJO = J; KKO = K ! Indexes of other Cartesian face @ I-1
                         OFACE(2:3) = M%CUT_EDGE(IECE)%FACE_LIST(1:2,-2, JECE) ! Z Face in low I
                      ELSEIF(II==I) THEN ! UPPER cut-face in the I direction.
                         IIO = I+1; JJO = J; KKO = K ! Indexes of other Cartesian face @ I+1
                         OFACE(2:3) = M%CUT_EDGE(IECE)%FACE_LIST(1:2, 2, JECE) ! Z Face in high I
                      ENDIF
                      IF(IIO<1 .OR. IIO>M%IBAR) CYCLE KAXIS_IEC_LOOP
                   ELSEIF (X3AXIS==IAXIS) THEN ! X2AXIS = JAXIS
                      IF(JJ==J-1) THEN ! LOWER cut-face in the J direction.
                         IIO = I; JJO = J-1; KKO = K ! Indexes of other Cartesian face @ J-1
                         OFACE(2:3) = M%CUT_EDGE(IECE)%FACE_LIST(1:2,-1, JECE) ! Z Face in low J
                      ELSEIF(JJ==J) THEN ! UPPER cut-face in the J direction.
                         IIO = I; JJO = J+1; KKO = K ! Indexes of other Cartesian face @ J+1
                         OFACE(2:3) = M%CUT_EDGE(IECE)%FACE_LIST(1:2, 1, JECE) ! Z Face in high J
                      ENDIF
                      IF(JJO<1 .OR. JJO>M%JBAR) CYCLE KAXIS_IEC_LOOP
                   ENDIF
                   OICF     = OFACE(2); OJCF     = OFACE(3)
                   IF(OICF<1 .OR. OJCF<1) CYCLE KAXIS_IEC_LOOP
                   OLO_UNKZ = M%CUT_FACE(OICF)%UNKZ(LOW_IND,OJCF)
                   OHI_UNKZ = M%CUT_FACE(OICF)%UNKZ(HIGH_IND,OJCF)
                   IF(LO_UNKZ==OLO_UNKZ .OR. HI_UNKZ==OHI_UNKZ .OR. ALL_FLG) THEN ! Link cut-face to other cut-face:
                       IF(M%CUT_FACE(OICF)%UNKF(OJCF)>0) THEN
                          CF%UNKF(JCF)     = M%CUT_FACE(OICF)%UNKF(OJCF)
                          CF%LINK_LEV(JCF) = M%CUT_FACE(OICF)%LINK_LEV(OJCF) - 1
                          CYCLE KAXIS_JCF_LOOP
                       ELSEIF(CF%AREA(JCF)+M%CUT_FACE(OICF)%AREA(OJCF) > CCVOL_LINK * ACRT) THEN
                          M%NUNK_F = M%NUNK_F + 1
                          CF%UNKF(JCF) = M%NUNK_F; M%CUT_FACE(OICF)%UNKF(OJCF) = M%NUNK_F
                          CF%LINK_LEV(JCF) = -1; M%CUT_FACE(OICF)%LINK_LEV(OJCF) = -1
                          CYCLE KAXIS_JCF_LOOP
                       ENDIF
                   ENDIF
                END SELECT KAXIS_IEC_SELECT
             ENDDO KAXIS_IEC_LOOP
          ENDIF
       ENDDO KAXIS_JCF_LOOP
   END SELECT

ENDDO ICF_LOOP_2

ELSE

ICF_LOOP_3 : DO ICF=1,M%N_CUTFACE_MESH
   CF => M%CUT_FACE(ICF); IF(CF%STATUS/=CC_GASPHASE) CYCLE ICF_LOOP_3
   I  = CF%IJK(IAXIS); J = CF%IJK(JAXIS); K = CF%IJK(KAXIS); X1AXIS = CF%IJK(KAXIS+1)
   SELECT CASE(X1AXIS)
   CASE(IAXIS)

      ACRT = M%DY(J)*M%DZ(K)
      IAXIS_JCF_LOOP_2 : DO JCF=1,CF%NFACE
         IF(CF%UNKF(JCF)<1) THEN ! Loop edges to find next face in X2AXIS, X3AXIS plane:
            COUNT=0; IIO=0; JJO=0; KKO=0
            IAXIS_IEC_LOOP_2 : DO IEC=2,CF%CEDGES(1,JCF)+1
               IEDGE = CF%CEDGES(IEC,JCF)
               SELECT CASE(CF%EDGE_LIST(1,IEDGE))
               CASE(CC_ETYPE_RGGAS) ! Cut-faces Regular Gas Edge.
                  LOHI   = CF%EDGE_LIST(2,IEDGE)
                  X2AXIS = CF%EDGE_LIST(3,IEDGE)
                  IF (X2AXIS==JAXIS) THEN ! Edge pointed in X3AXIS=KAXIS direction.
                     IF(LOHI==LOW_IND) THEN; IIO=I; JJO=J-1; KKO=K ! Indexes of other Cartesian face @ J-1
                     ELSE;                   IIO=I; JJO=J+1; KKO=K ! Indexes of other Cartesian face @ J+1
                     ENDIF; IF(JJO<1 .OR. JJO>M%JBAR) CYCLE IAXIS_IEC_LOOP_2
                  ELSEIF(X2AXIS==KAXIS) THEN ! Edge pointed in X3AXIS=JAXIS direction.
                     IF(LOHI==LOW_IND) THEN; IIO=I; JJO=J; KKO=K-1 ! Indexes of other Cartesian face @ K-1
                     ELSE;                   IIO=I; JJO=J; KKO=K+1 ! Indexes of other Cartesian face @ K+1
                     ENDIF; IF(KKO<1 .OR. KKO>M%KBAR) CYCLE IAXIS_IEC_LOOP_2
                  ENDIF
               CASE(CC_ETYPE_CFGAS) ! Gas cut-edge.
                  IECE = CF%EDGE_LIST(2,IEDGE)
                  II=M%CUT_EDGE(IECE)%IJK(IAXIS); JJ=M%CUT_EDGE(IECE)%IJK(JAXIS); KK=M%CUT_EDGE(IECE)%IJK(KAXIS);
                  X3AXIS = M%CUT_EDGE(IECE)%IJK(KAXIS+1);
                  IF (X3AXIS==KAXIS) THEN ! X3AXIS==Edge Axis, X2AXIS = JAXIS
                     IF(JJ==J-1) THEN;   IIO = I; JJO = J-1; KKO = K ! X Face in low J
                     ELSEIF(JJ==J) THEN; IIO = I; JJO = J+1; KKO = K ! X Face in high J
                     ENDIF; IF(JJO<1 .OR. JJO>M%JBAR) CYCLE IAXIS_IEC_LOOP_2
                  ELSEIF (X3AXIS==JAXIS) THEN ! X2AXIS = KAXIS
                     IF(KK==K-1) THEN;   IIO = I; JJO = J; KKO = K-1 ! X Face in low K
                     ELSEIF(KK==K) THEN; IIO = I; JJO = J; KKO = K+1 ! X Face in high K
                     ENDIF; IF(KKO<1 .OR. KKO>M%KBAR) CYCLE IAXIS_IEC_LOOP_2
                  ENDIF
               CASE DEFAULT; CYCLE IAXIS_IEC_LOOP_2
               END SELECT
               IF(COUNT+1>SIZE_FACE) THEN
                  ALLOCATE(FACELAUX(4,SIZE_FACE+20),FACEARAUX(SIZE_FACE+20))
                  FACELAUX(1:4,1:SIZE_FACE) = FACE_LIST(1:4,1:SIZE_FACE)
                  FACEARAUX(1:SIZE_FACE)    = FACE_AREA(1:SIZE_FACE)
                  CALL MOVE_ALLOC(FROM=FACELAUX,TO=FACE_LIST)
                  CALL MOVE_ALLOC(FROM=FACEARAUX,TO=FACE_AREA)
                  SIZE_FACE = SIZE_FACE+20
               ENDIF
               IF(M%FCVAR(IIO,JJO,KKO,CC_IDCF,X1AXIS)>0) THEN ! Underlying cut-face.
                  COUNT=COUNT+1
                  FACE_LIST(1:4,COUNT) = (/ CC_FTYPE_CFGAS,IIO,JJO,KKO/)
                  FACE_AREA(COUNT)     = M%CUT_FACE(M%FCVAR(IIO,JJO,KKO,CC_IDCF,X1AXIS))%ALPHA_CF*ACRT
               ELSEIF(M%FCVAR(IIO,JJO,KKO,CC_IDRC,X1AXIS)>0) THEN ! RC face.
                  COUNT=COUNT+1
                  FACE_LIST(1:4,COUNT) = (/ CC_FTYPE_RCGAS,IIO,JJO,KKO/)
                  FACE_AREA(COUNT)     = ACRT
               ELSEIF(M%FCVAR(IIO,JJO,KKO,CC_CGSC,X1AXIS)==CC_GASPHASE) THEN ! Regular face.
                  COUNT=COUNT+1
                  FACE_LIST(1:4,COUNT) = (/ CC_FTYPE_RGGAS,IIO,JJO,KKO/)
                  FACE_AREA(COUNT)     = ACRT
               ENDIF
            ENDDO  IAXIS_IEC_LOOP_2
            IF(COUNT==0) CYCLE IAXIS_JCF_LOOP_2
            CALL SET_UNKF_CF
         ENDIF
      ENDDO IAXIS_JCF_LOOP_2

   CASE(JAXIS)

      IF (TWO_D) CYCLE ICF_LOOP_3
      ACRT = M%DX(I)*M%DZ(K)
      JAXIS_JCF_LOOP_2 : DO JCF=1,CF%NFACE
         IF(CF%UNKF(JCF)<1) THEN
            COUNT=0; IIO=0; JJO=0; KKO=0
            JAXIS_IEC_LOOP_2 : DO IEC=2,CF%CEDGES(1,JCF)+1
               IEDGE = CF%CEDGES(IEC,JCF)
               SELECT CASE(CF%EDGE_LIST(1,IEDGE))
               CASE(CC_ETYPE_RGGAS) ! Cut-faces Regular Gas Edge.
                  LOHI   = CF%EDGE_LIST(2,IEDGE)
                  X2AXIS = CF%EDGE_LIST(3,IEDGE)
                  IF (X2AXIS==IAXIS) THEN ! Edge pointed in X3AXIS=KAXIS direction.
                     IF(LOHI==LOW_IND) THEN; IIO=I-1; JJO=J; KKO=K ! Indexes of other Cartesian face @ I-1
                     ELSE;                   IIO=I+1; JJO=J; KKO=K ! Indexes of other Cartesian face @ I+1
                     ENDIF; IF(IIO<1 .OR. IIO>M%IBAR) CYCLE JAXIS_IEC_LOOP_2
                  ELSEIF(X2AXIS==KAXIS) THEN ! Edge pointed in X3AXIS=IAXIS direction.
                     IF(LOHI==LOW_IND) THEN; IIO=I; JJO=J; KKO=K-1 ! Indexes of other Cartesian face @ K-1
                     ELSE;                   IIO=I; JJO=J; KKO=K+1 ! Indexes of other Cartesian face @ K+1
                     ENDIF; IF(KKO<1 .OR. KKO>M%KBAR) CYCLE JAXIS_IEC_LOOP_2
                  ENDIF
               CASE(CC_ETYPE_CFGAS) ! Gas cut-edge.
                  IECE = CF%EDGE_LIST(2,IEDGE)
                  II=M%CUT_EDGE(IECE)%IJK(IAXIS); JJ=M%CUT_EDGE(IECE)%IJK(JAXIS); KK=M%CUT_EDGE(IECE)%IJK(KAXIS);
                  X3AXIS = M%CUT_EDGE(IECE)%IJK(KAXIS+1);
                  IF (X3AXIS==KAXIS) THEN ! X3AXIS==Edge Axis, X2AXIS = IAXIS
                     IF(II==I-1) THEN;   IIO = I-1; JJO = J; KKO = K ! Indexes of other Cartesian face @ I-1
                     ELSEIF(II==I) THEN; IIO = I+1; JJO = J; KKO = K ! Indexes of other Cartesian face @ I+1
                     ENDIF; IF(IIO<1 .OR. IIO>M%IBAR) CYCLE JAXIS_IEC_LOOP_2
                  ELSEIF (X3AXIS==IAXIS) THEN ! X2AXIS = KAXIS
                     IF(KK==K-1) THEN;   IIO = I; JJO = J; KKO = K-1 ! Indexes of other Cartesian face @ K-1
                     ELSEIF(KK==K) THEN; IIO = I; JJO = J; KKO = K+1 ! Indexes of other Cartesian face @ K+1
                     ENDIF; IF(KKO<1 .OR. KKO>M%KBAR) CYCLE JAXIS_IEC_LOOP_2
                  ENDIF
               CASE DEFAULT; CYCLE JAXIS_IEC_LOOP_2
               END SELECT
               IF(COUNT+1>SIZE_FACE) THEN
                  ALLOCATE(FACELAUX(4,SIZE_FACE+20),FACEARAUX(SIZE_FACE+20))
                  FACELAUX(1:4,1:SIZE_FACE) = FACE_LIST(1:4,1:SIZE_FACE)
                  FACEARAUX(1:SIZE_FACE)    = FACE_AREA(1:SIZE_FACE)
                  CALL MOVE_ALLOC(FROM=FACELAUX,TO=FACE_LIST)
                  CALL MOVE_ALLOC(FROM=FACEARAUX,TO=FACE_AREA)
                  SIZE_FACE = SIZE_FACE+20
               ENDIF
               IF(M%FCVAR(IIO,JJO,KKO,CC_IDCF,X1AXIS)>0) THEN ! Underlying cut-face.
                  COUNT=COUNT+1
                  FACE_LIST(1:4,COUNT) = (/ CC_FTYPE_CFGAS,IIO,JJO,KKO/)
                  FACE_AREA(COUNT)     = M%CUT_FACE(M%FCVAR(IIO,JJO,KKO,CC_IDCF,X1AXIS))%ALPHA_CF*ACRT
               ELSEIF(M%FCVAR(IIO,JJO,KKO,CC_IDRC,X1AXIS)>0) THEN ! RC face.
                  COUNT=COUNT+1
                  FACE_LIST(1:4,COUNT) = (/ CC_FTYPE_RCGAS,IIO,JJO,KKO/)
                  FACE_AREA(COUNT)     = ACRT
               ELSEIF(M%FCVAR(IIO,JJO,KKO,CC_CGSC,X1AXIS)==CC_GASPHASE) THEN ! Regular face.
                  COUNT=COUNT+1
                  FACE_LIST(1:4,COUNT) = (/ CC_FTYPE_RGGAS,IIO,JJO,KKO/)
                  FACE_AREA(COUNT)     = ACRT
               ENDIF
            ENDDO  JAXIS_IEC_LOOP_2
            IF(COUNT==0) CYCLE JAXIS_JCF_LOOP_2
            CALL SET_UNKF_CF
         ENDIF
      ENDDO JAXIS_JCF_LOOP_2

   CASE(KAXIS)

      ACRT = M%DY(J)*M%DX(I)
      KAXIS_JCF_LOOP_2 : DO JCF=1,CF%NFACE
         IF(CF%UNKF(JCF)<1) THEN
            COUNT=0; IIO=0; JJO=0; KKO=0
            KAXIS_IEC_LOOP_2 : DO IEC=2,CF%CEDGES(1,JCF)+1
               IEDGE = CF%CEDGES(IEC,JCF)
               SELECT CASE(CF%EDGE_LIST(1,IEDGE))
               CASE(CC_ETYPE_RGGAS) ! Cut-faces Regular Gas Edge.
                  LOHI   = CF%EDGE_LIST(2,IEDGE)
                  X2AXIS = CF%EDGE_LIST(3,IEDGE)
                  IF (X2AXIS==IAXIS) THEN ! Edge pointed in X3AXIS=JAXIS direction.
                     IF(LOHI==LOW_IND) THEN; IIO=I-1; JJO=J; KKO=K ! Indexes of other Cartesian face @ I-1
                     ELSE;                   IIO=I+1; JJO=J; KKO=K ! Indexes of other Cartesian face @ I+1
                     ENDIF; IF(IIO<1 .OR. IIO>M%IBAR) CYCLE KAXIS_IEC_LOOP_2
                  ELSEIF(X2AXIS==JAXIS) THEN ! Edge pointed in X3AXIS=IAXIS direction.
                     IF(LOHI==LOW_IND) THEN; IIO=I; JJO=J-1; KKO=K ! Indexes of other Cartesian face @ J-1
                     ELSE;                   IIO=I; JJO=J+1; KKO=K ! Indexes of other Cartesian face @ J+1
                     ENDIF; IF(JJO<1 .OR. JJO>M%JBAR) CYCLE KAXIS_IEC_LOOP_2
                  ENDIF
               CASE(CC_ETYPE_CFGAS) ! Gas cut-edge.
                  IECE = CF%EDGE_LIST(2,IEDGE)
                  II=M%CUT_EDGE(IECE)%IJK(IAXIS); JJ=M%CUT_EDGE(IECE)%IJK(JAXIS); KK=M%CUT_EDGE(IECE)%IJK(KAXIS);
                  X3AXIS = M%CUT_EDGE(IECE)%IJK(KAXIS+1);
                  IF (X3AXIS==JAXIS) THEN ! X3AXIS==Edge Axis, X2AXIS = IAXIS
                     IF(II==I-1) THEN;   IIO = I-1; JJO = J; KKO = K ! Indexes of other Cartesian face @ I-1
                     ELSEIF(II==I) THEN; IIO = I+1; JJO = J; KKO = K ! Indexes of other Cartesian face @ I+1
                     ENDIF; IF(IIO<1 .OR. IIO>M%IBAR) CYCLE KAXIS_IEC_LOOP_2
                  ELSEIF (X3AXIS==IAXIS) THEN ! X2AXIS = JAXIS
                     IF(JJ==J-1) THEN;   IIO = I; JJO = J-1; KKO = K ! Indexes of other Cartesian face @ J-1
                     ELSEIF(JJ==J) THEN; IIO = I; JJO = J+1; KKO = K ! Indexes of other Cartesian face @ J+1
                     ENDIF; IF(JJO<1 .OR. JJO>M%JBAR) CYCLE KAXIS_IEC_LOOP_2
                  ENDIF
               CASE DEFAULT; CYCLE KAXIS_IEC_LOOP_2
               END SELECT
               IF(COUNT+1>SIZE_FACE) THEN
                  ALLOCATE(FACELAUX(4,SIZE_FACE+20),FACEARAUX(SIZE_FACE+20))
                  FACELAUX(1:4,1:SIZE_FACE) = FACE_LIST(1:4,1:SIZE_FACE)
                  FACEARAUX(1:SIZE_FACE)    = FACE_AREA(1:SIZE_FACE)
                  CALL MOVE_ALLOC(FROM=FACELAUX,TO=FACE_LIST)
                  CALL MOVE_ALLOC(FROM=FACEARAUX,TO=FACE_AREA)
                  SIZE_FACE = SIZE_FACE+20
               ENDIF
               IF(M%FCVAR(IIO,JJO,KKO,CC_IDCF,X1AXIS)>0) THEN ! Underlying cut-face.
                  COUNT=COUNT+1
                  FACE_LIST(1:4,COUNT) = (/ CC_FTYPE_CFGAS,IIO,JJO,KKO/)
                  FACE_AREA(COUNT)     = M%CUT_FACE(M%FCVAR(IIO,JJO,KKO,CC_IDCF,X1AXIS))%ALPHA_CF*ACRT
               ELSEIF(M%FCVAR(IIO,JJO,KKO,CC_IDRC,X1AXIS)>0) THEN ! RC face.
                  COUNT=COUNT+1
                  FACE_LIST(1:4,COUNT) = (/ CC_FTYPE_RCGAS,IIO,JJO,KKO/)
                  FACE_AREA(COUNT)     = ACRT
               ELSEIF(M%FCVAR(IIO,JJO,KKO,CC_CGSC,X1AXIS)==CC_GASPHASE) THEN ! Regular face.
                  COUNT=COUNT+1
                  FACE_LIST(1:4,COUNT) = (/ CC_FTYPE_RGGAS,IIO,JJO,KKO/)
                  FACE_AREA(COUNT)     = ACRT
               ENDIF
            ENDDO  KAXIS_IEC_LOOP_2
            IF(COUNT==0) CYCLE KAXIS_JCF_LOOP_2
            CALL SET_UNKF_CF
         ENDIF
      ENDDO  KAXIS_JCF_LOOP_2

   END SELECT
ENDDO ICF_LOOP_3

ENDIF

END SUBROUTINE LINK_FACES_TO_NEIGHBORS

SUBROUTINE SET_UNKF_CF

! Now define face to link to:
ILOC = MAXLOC(FACE_AREA(1:COUNT),DIM=1)
IIO  = FACE_LIST(2,ILOC); JJO = FACE_LIST(3,ILOC); KKO = FACE_LIST(4,ILOC)
SELECT CASE (FACE_LIST(1,ILOC))
CASE(CC_FTYPE_RGGAS)
   IF(M%FCVAR(IIO,JJO,KKO,CC_UNKF,X1AXIS)<1) THEN
         M%NUNK_F = M%NUNK_F + 1
         M%FCVAR(IIO,JJO,KKO,CC_UNKF,X1AXIS) = M%NUNK_F
   ENDIF
   CF%UNKF(JCF)     = M%FCVAR(IIO,JJO,KKO,CC_UNKF,X1AXIS)
   CF%LINK_LEV(JCF) = -1
CASE(CC_FTYPE_RCGAS)
   OICF = M%FCVAR(IIO,JJO,KKO,CC_IDRC,X1AXIS)
   IF(M%RC_FACE(OICF)%UNKF<1) THEN
      M%NUNK_F = M%NUNK_F + 1
      M%RC_FACE(OICF)%UNKF = M%NUNK_F
   ENDIF
   CF%UNKF(JCF)     = M%RC_FACE(OICF)%UNKF
   CF%LINK_LEV(JCF) = -1
CASE(CC_FTYPE_CFGAS)
   OICF = M%FCVAR(IIO,JJO,KKO,CC_IDCF,X1AXIS); OJCF = 1
   IF(M%CUT_FACE(OICF)%UNKF(OJCF)>0) THEN
      CF%UNKF(JCF)     = M%CUT_FACE(OICF)%UNKF(OJCF)
      CF%LINK_LEV(JCF) = M%CUT_FACE(OICF)%LINK_LEV(OJCF) - 1
   ELSEIF(CF%AREA(JCF)+M%CUT_FACE(OICF)%AREA(OJCF) > CCVOL_LINK * ACRT) THEN
      M%NUNK_F = M%NUNK_F + 1
      CF%UNKF(JCF) = M%NUNK_F; M%CUT_FACE(OICF)%UNKF(OJCF) = M%NUNK_F
      CF%LINK_LEV(JCF) = -1; M%CUT_FACE(OICF)%LINK_LEV(OJCF) = -1
   ENDIF
END SELECT
RETURN
END SUBROUTINE SET_UNKF_CF

END SUBROUTINE GET_LINKED_FACE_INDEXES_F

END MODULE CC_SCALARS
