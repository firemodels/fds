
!  +++++++++++++++++++++++ COMPLEX_GEOMETRY ++++++++++++++++++++++++++


! Routines related to unstructured geometry and immersed boundary methods
!
! Definitions for preprocessor:
! MPI:
#define MPI_ENABLED
! Debug:
!#define DEBUG_SET_CUTCELLS /* Debug cut-cell definition algorithm. */
!#define DEBUG_IBM_INTERPOLATION /* Debug IBM interpolation and forcing scheme. */
!#define DEBUG_MATVEC_DATA /* Debug cut-cell region indexing, construction of regular, rc faces for scalars, etc. */
!#define DEBUG_CCREGION_SCALAR_TRANSPORT /* Debug time integration algorithms for scalar tranport in cut-cell region. */

! MKL Solver, defined in makefile:
#ifdef WITH_MKL
!!! #include "mkl_pardiso.f90"
#define __MKL_PARDISO_F90
MODULE MKL_PARDISO_PRIVATE
  TYPE MKL_PARDISO_HANDLE; INTEGER(KIND=8) DUMMY; END TYPE
  INTEGER, PARAMETER :: PARDISO_OOC_FILE_NAME = 1
END MODULE MKL_PARDISO_PRIVATE
MODULE MKL_PARDISO
  USE MKL_PARDISO_PRIVATE
  INTERFACE PARDISO
     SUBROUTINE PARDISO_D( PT, MAXFCT, MNUM, MTYPE, PHASE, N, A, IA, JA, PERM, NRHS, IPARM, MSGLVL, B, X, ERROR )
     USE MKL_PARDISO_PRIVATE
     TYPE(MKL_PARDISO_HANDLE), INTENT(INOUT) :: PT(*)
     INTEGER,          INTENT(IN)    :: MAXFCT
     INTEGER,          INTENT(IN)    :: MNUM
     INTEGER,          INTENT(IN)    :: MTYPE
     INTEGER,          INTENT(IN)    :: PHASE
     INTEGER,          INTENT(IN)    :: N
     INTEGER,          INTENT(IN)    :: IA(*)
     INTEGER,          INTENT(IN)    :: JA(*)
     INTEGER,          INTENT(INOUT) :: PERM(*)
     INTEGER,          INTENT(IN)    :: NRHS
     INTEGER,          INTENT(INOUT) :: IPARM(*)
     INTEGER,          INTENT(IN)    :: MSGLVL
     INTEGER,          INTENT(OUT)   :: ERROR
     REAL(KIND=8),     INTENT(IN)    :: A(*)
     REAL(KIND=8),     INTENT(INOUT) :: B(*)
     REAL(KIND=8),     INTENT(OUT)   :: X(*)
     END SUBROUTINE PARDISO_D

     SUBROUTINE PARDISO_D_2D( PT, MAXFCT, MNUM, MTYPE, PHASE, N, A, IA, JA, PERM, NRHS, IPARM, MSGLVL, B, X, ERROR )
     USE MKL_PARDISO_PRIVATE
     TYPE(MKL_PARDISO_HANDLE), INTENT(INOUT) :: PT(*)
     INTEGER,          INTENT(IN)    :: MAXFCT
     INTEGER,          INTENT(IN)    :: MNUM
     INTEGER,          INTENT(IN)    :: MTYPE
     INTEGER,          INTENT(IN)    :: PHASE
     INTEGER,          INTENT(IN)    :: N
     INTEGER,          INTENT(IN)    :: IA(*)
     INTEGER,          INTENT(IN)    :: JA(*)
     INTEGER,          INTENT(INOUT) :: PERM(*)
     INTEGER,          INTENT(IN)    :: NRHS
     INTEGER,          INTENT(INOUT) :: IPARM(*)
     INTEGER,          INTENT(IN)    :: MSGLVL
     INTEGER,          INTENT(OUT)   :: ERROR
     REAL(KIND=8),     INTENT(IN)    :: A(*)
     REAL(KIND=8),     INTENT(INOUT) :: B(N,*)
     REAL(KIND=8),     INTENT(OUT)   :: X(N,*)
     END SUBROUTINE PARDISO_D_2D
  END INTERFACE
END MODULE MKL_PARDISO

!!! #include "mkl_cluster_sparse_solver.f90"
#define __MKL_CLUSTER_SPARSE_SOLVER_F90
MODULE MKL_CLUSTER_SPARSE_SOLVER_PRIVATE
  TYPE MKL_CLUSTER_SPARSE_SOLVER_HANDLE; INTEGER(KIND=8) DUMMY; END TYPE
END MODULE MKL_CLUSTER_SPARSE_SOLVER_PRIVATE
MODULE MKL_CLUSTER_SPARSE_SOLVER
  USE MKL_CLUSTER_SPARSE_SOLVER_PRIVATE
  INTERFACE CLUSTER_SPARSE_SOLVER
  SUBROUTINE CLUSTER_SPARSE_SOLVER_D(PT,MAXFCT,MNUM,MTYPE,PHASE,N,A,IA,JA,PERM,NRHS,IPARM,MSGLVL,B,X,COMM,ERROR)
    USE MKL_CLUSTER_SPARSE_SOLVER_PRIVATE
    TYPE(MKL_CLUSTER_SPARSE_SOLVER_HANDLE), INTENT(INOUT) :: PT(*)
    INTEGER,          INTENT(IN)    :: MAXFCT
    INTEGER,          INTENT(IN)    :: MNUM
    INTEGER,          INTENT(IN)    :: MTYPE
    INTEGER,          INTENT(IN)    :: PHASE
    INTEGER,          INTENT(IN)    :: N
    INTEGER,          INTENT(IN)    :: IA(*)
    INTEGER,          INTENT(IN)    :: JA(*)
    INTEGER,          INTENT(IN)    :: PERM(*)
    INTEGER,          INTENT(IN)    :: NRHS
    INTEGER,          INTENT(INOUT) :: IPARM(*)
    INTEGER,          INTENT(IN)    :: MSGLVL
    INTEGER,          INTENT(OUT)   :: ERROR
    REAL(KIND=8),     INTENT(IN)    :: A(*)
    REAL(KIND=8),     INTENT(INOUT) :: B(*)
    REAL(KIND=8),     INTENT(OUT)   :: X(*)
    INTEGER,          INTENT(IN)    :: COMM
  END SUBROUTINE CLUSTER_SPARSE_SOLVER_D

  SUBROUTINE CLUSTER_SPARSE_SOLVER_D_2D(PT,MAXFCT,MNUM,MTYPE,PHASE,N,A,IA,JA,PERM,NRHS,IPARM,MSGLVL,B,X,COMM,ERROR)
    USE MKL_CLUSTER_SPARSE_SOLVER_PRIVATE
    TYPE(MKL_CLUSTER_SPARSE_SOLVER_HANDLE), INTENT(INOUT) :: PT(*)
    INTEGER,          INTENT(IN)    :: MAXFCT
    INTEGER,          INTENT(IN)    :: MNUM
    INTEGER,          INTENT(IN)    :: MTYPE
    INTEGER,          INTENT(IN)    :: PHASE
    INTEGER,          INTENT(IN)    :: N
    INTEGER,          INTENT(IN)    :: IA(*)
    INTEGER,          INTENT(IN)    :: JA(*)
    INTEGER,          INTENT(IN)    :: PERM(*)
    INTEGER,          INTENT(IN)    :: NRHS
    INTEGER,          INTENT(INOUT) :: IPARM(*)
    INTEGER,          INTENT(IN)    :: MSGLVL
    INTEGER,          INTENT(OUT)   :: ERROR
    REAL(KIND=8),     INTENT(IN)    :: A(*)
    REAL(KIND=8),     INTENT(INOUT) :: B(N,*)
    REAL(KIND=8),     INTENT(OUT)   :: X(N,*)
    INTEGER,          INTENT(IN)    :: COMM
  END SUBROUTINE CLUSTER_SPARSE_SOLVER_D_2D
  END INTERFACE
END MODULE MKL_CLUSTER_SPARSE_SOLVER
#endif /* WITH_MKL */

MODULE COMPLEX_GEOMETRY

USE PRECISION_PARAMETERS
USE GLOBAL_CONSTANTS
USE MESH_VARIABLES
USE MESH_POINTERS
USE COMP_FUNCTIONS, ONLY: CHECKREAD,CHECK_XB,GET_FILE_NUMBER,SHUTDOWN
USE MEMORY_FUNCTIONS, ONLY: ChkMemErr

#ifdef WITH_MKL
 USE MKL_CLUSTER_SPARSE_SOLVER
#endif /* WITH_MKL */

IMPLICIT NONE
REAL(EB), PARAMETER :: DEG2RAD=4.0_EB*ATAN(1.0_EB)/180.0_EB


!! ---------------------------------------------------------------------------------
! Start Variable declaration for CC_IBM:
! Local constants used on routines:
REAL(EB), SAVE :: GEOMEPS = 1.E-12_EB
REAL(EB), PARAMETER :: GEOFCT=10._EB

INTEGER,  SAVE :: NGUARD= 6        ! Layers of guard-cells.
INTEGER,  SAVE ::CCGUARD= 6 - 2    ! Layers of guard cut-cells.
INTEGER,  PARAMETER :: FCELL = 1   ! Right face index.

! Media definition parameters:
INTEGER,  PARAMETER :: IBM_INBOUNDCC = -3
INTEGER,  PARAMETER :: IBM_INBOUNDCF = -2
INTEGER,  PARAMETER :: IBM_GASPHASE  = -1
INTEGER,  PARAMETER :: IBM_CUTCFE    =  0
INTEGER,  PARAMETER :: IBM_SOLID     =  1
INTEGER,  PARAMETER :: IBM_INBOUNDARY=  2
INTEGER,  PARAMETER :: IBM_UNDEFINED =-11

! Intersection type definition parameters:
INTEGER,  PARAMETER :: IBM_GG =  1 ! Gas - Gas intersection.
INTEGER,  PARAMETER :: IBM_SS =  3 ! Solid - Solid intersection.
INTEGER,  PARAMETER :: IBM_GS = -1 ! Gas to Solid intersection (as coordinate xi increases).
INTEGER,  PARAMETER :: IBM_SG =  5 ! Solid to Gas intersection (as coordinate xi increases).
INTEGER,  PARAMETER :: IBM_SGG= IBM_GG ! Single point GG intersection. Might not be needed.

! Constants used to identify variables on Eulerian grid arrays:
! Vertex centered variables:
INTEGER,  PARAMETER :: IBM_VGSC   = 1 ! Type of vertex media, IBM_GASPHASE or IBM_SOLID.
INTEGER,  PARAMETER :: IBM_NVVARS = 1 ! Number of vertex variables in MESHES(N)%IBM_VERTVAR.

! Cartesian Edge centered variables:
INTEGER,  PARAMETER :: IBM_EGSC   = 1 ! Edge media type: IBM_GASPHASE, IBM_SOLID or IBM_CUTCFE.
INTEGER,  PARAMETER :: IBM_IDCE   = 2 ! MESHES(N)%CUT_EDGE data struct entry index location.
INTEGER,  PARAMETER :: IBM_ECRS   = 3 ! MESHES(N)%EDGE_CROSS data struct entry index location.
INTEGER,  PARAMETER :: IBM_NEVARS = 3 ! Number of edge variables in MESHES(N)%IBM_ECVAR.

! Cartesian Face centered variables:
INTEGER,  PARAMETER :: IBM_FGSC   = 1 ! Face media type: IBM_GASPHASE, IBM_SOLID or IBM_CUTCFE.
!INTEGER, PARAMETER :: IBM_IDCE   = 2 ! MESHES(N)%CUT_EDGE data struct entry index location,
                                      ! IBM_INBOUNDCF type.
INTEGER,  PARAMETER :: IBM_IDCF   = 3 ! MESHES(N)%CUT_FACE data struct entry index location,
                                      ! IBM_INBOUNDCF type cut-faces.
INTEGER,  PARAMETER :: IBM_FFNF   = 4 ! Flag that defines if face is to be IB forced or not.
INTEGER,  PARAMETER :: IBM_NFVARS = 4 ! Number of face variables in MESHES(N)%IBM_FCVAR.

! Cartesian Cell centered variables:
INTEGER,  PARAMETER :: IBM_CGSC   = 1 ! Face media type: IBM_GASPHASE, IBM_SOLID or IBM_CUTCFE.
!INTEGER, PARAMETER :: IBM_IDCE   = 2 ! MESHES(N)%CUT_EDGE data struct entry index location,
                                      ! cut edges in Cartesian cell.
!INTEGER, PARAMETER :: IBM_IDCF   = 3 ! MESHES(N)%CUT_FACE data struct entry index location,
                                      ! IBM_INBOUNDCC type cut-faces in Cartesian cell.
INTEGER,  PARAMETER :: IBM_IDCC   = 4 ! MESHES(N)%CUT_CELL data struct entry index location,
                                      ! cut-cells in Cartesian cell.
INTEGER,  PARAMETER :: IBM_CCNC   = 5 ! Entry for 2nd row of H Cartesian cell interpolation.
INTEGER,  PARAMETER :: IBM_UNKZ   = 6 ! Scalar indexing.
INTEGER,  PARAMETER :: IBM_UNKH   = 7 ! Pressure indexing.
INTEGER,  PARAMETER :: IBM_NCVARS = 7 ! Number of face variables in MESHES(N)%IBM_CCVAR.

! Cut-faces types in FACE_LIST of CUT_CELL:
INTEGER, PARAMETER :: IBM_FTYPE_RGGAS = 0 ! This face of a cut-cell is a regular GASPHASE face.
INTEGER, PARAMETER :: IBM_FTYPE_CFGAS = 1 ! A GASPHASE cut-face or cell.
INTEGER, PARAMETER :: IBM_FTYPE_CFINB = 2 ! An INBOUNDARY cut-face.
INTEGER, PARAMETER :: IBM_FTYPE_SVERT = 3 ! A SOLID Vertex.

! Local integers:
INTEGER, SAVE :: IBM_NEDGECROSS, IBM_NCUTEDGE, IBM_NCUTFACE, IBM_NCUTCELL
INTEGER, SAVE :: ILO_CELL,IHI_CELL,JLO_CELL,JHI_CELL,KLO_CELL,KHI_CELL
INTEGER, SAVE :: ILO_FACE,IHI_FACE,JLO_FACE,JHI_FACE,KLO_FACE,KHI_FACE
INTEGER, SAVE :: NXB, NYB, NZB
INTEGER, SAVE :: X1LO_FACE,X1LO_CELL,X1HI_FACE,X1HI_CELL, &
                 X2LO_FACE,X2LO_CELL,X2HI_FACE,X2HI_CELL, &
                 X3LO_FACE,X3LO_CELL,X3HI_FACE,X3HI_CELL

INTEGER, PARAMETER :: NODS_WSEL = 3 ! Three nodes per wet surface element (i.e. surface triangle).

INTEGER, PARAMETER :: EDGS_WSEL = 3 ! Three edges per wet surface element.

INTEGER, PARAMETER :: NODS_VLEL = 4 ! Nodes of volume element (tetrahedra).

INTEGER, PARAMETER :: LINSEARCH_LIMIT = 13  ! LINSEARCH_LIMIT-1 is the maximum size of array for linear search O(n). If
                                            ! Array larger -> binary search O(log(n)).

! Intersection Body-plane data structure:
TYPE BODINT_PLANE_TYPE
   INTEGER :: NNODS     ! Number of intersection vertices.
   INTEGER :: NSGLS     ! Number of single point intersection elements.
   INTEGER :: NSEGS     ! Number of intersection segments.
   INTEGER :: NTRIS     ! Number of in-plane intersections triangles.
   REAL(EB), ALLOCATABLE, DIMENSION(:,:) :: XYZ  ! (1:NNODS,IAXIS:KAXIS) vertex coordinates.
   INTEGER,  ALLOCATABLE, DIMENSION(:,:) :: SGLS ! (1:NSGLS,NOD1) connectivity list for single node elements.
   INTEGER,  ALLOCATABLE, DIMENSION(:,:) :: SEGS ! (1:NSEGS,NOD1:NOD2) connectivity list for segments.
   INTEGER,  ALLOCATABLE, DIMENSION(:,:) :: TRIS ! (1:NTRIS,NOD1:NOD3) connectivity list for triangle elements.
   INTEGER,  ALLOCATABLE, DIMENSION(:,:) :: INDSGL ! Wet surface triangles associated with single node elems.
   INTEGER,  ALLOCATABLE, DIMENSION(:,:) :: INDSEG ! Wet surface triangles associated with intersection segments.
   INTEGER,  ALLOCATABLE, DIMENSION(:,:) :: INDTRI ! Wet surface triangles associated with intersection triangles.
   LOGICAL,  ALLOCATABLE, DIMENSION(:)   :: X2ALIGNED ! For segments.
   LOGICAL,  ALLOCATABLE, DIMENSION(:)   :: X3ALIGNED ! For segments.
   INTEGER,  ALLOCATABLE, DIMENSION(:)   :: NBCROSS   ! Number of crossings per segment with x2,x3 grid lines.
   REAL(EB), ALLOCATABLE, DIMENSION(:,:) :: SVAR   ! Intersections with gridlines for SEGS.
   INTEGER,  ALLOCATABLE, DIMENSION(:,:) :: SEGTYPE   ! Type of SEG based on the media it separates.
   REAL(EB), ALLOCATABLE, DIMENSION(:)   :: X1NVEC    ! Sign of in-plane triangles normal vectors resp to x1 dir.
   REAL(EB), ALLOCATABLE, DIMENSION(:,:,:):: AINV     ! Inverse transformation matrix for in-plane triangles.
   INTEGER,  ALLOCATABLE, DIMENSION(:)   :: NOD_PERM  ! Permutation array for nodes in ascending order, s.t.
                                                      ! XYZ(X2AXIS,NOD_PERM(I-1)) <= XYZ(X2AXIS,NOD_PERM(I)), etc.
END TYPE BODINT_PLANE_TYPE

INTEGER, SAVE :: IBM_MAX_NNODS, IBM_MAX_NSGLS, IBM_MAX_NSEGS, IBM_MAX_NTRIS,       &
                 IBM_MAX_NBCROSS=0,IBM_MAX_NBCROSS_OLD

TYPE(BODINT_PLANE_TYPE) :: BODINT_PLANE

! Wet surface edges intersection with Cartesian cells data structure:
TYPE BODINT_CELL_TYPE
   INTEGER :: NWSEGS ! Number of wet surface edges in immersed body ibod.
   INTEGER, ALLOCATABLE, DIMENSION(:) :: NWCROSS ! Number of intersections with Cartesian grid planes.
   REAL(EB), ALLOCATABLE, DIMENSION(:,:) :: SVAR ! Intersection with grid planes defined by local coord s.
END TYPE BODINT_CELL_TYPE

INTEGER, SAVE :: IBM_MAX_NWCROSS

TYPE(BODINT_CELL_TYPE), SAVE :: BODINT_CELL

! Allocatable real arrays
! Grid position containers:
REAL(EB), SAVE, TARGET, ALLOCATABLE, DIMENSION(:) :: XFACE,YFACE,ZFACE,XCELL,YCELL,ZCELL, &
          DXFACE,DYFACE,DZFACE,DXCELL,DYCELL,DZCELL,X1FACE,X2FACE,X3FACE,  &
          X2CELL,X3CELL,DX1FACE,DX2FACE,DX3FACE,DX2CELL,DX3CELL ! X1CELL,DX1CELL not used.

REAL(EB), POINTER, DIMENSION(:) :: X1FACEP,X2FACEP,X3FACEP,  &
                   X2CELLP,X3CELLP ! X1CELLP,DX1FACEP,DX2FACEP,DX3FACEP,DX1CELLP,DX2CELLP,DX3CELLP not used.

! x2 Intersection data containers:
INTEGER, PARAMETER :: IBM_MAXCROSS_X2 = 1024
INTEGER,  SAVE :: IBM_N_CRS
REAL(EB), SAVE :: IBM_SVAR_CRS(IBM_MAXCROSS_X2)
INTEGER,  SAVE :: IBM_IS_CRS(IBM_MAXCROSS_X2)
INTEGER,  SAVE :: IBM_IS_CRS2(LOW_IND:HIGH_IND,IBM_MAXCROSS_X2)
REAL(EB), SAVE :: IBM_SEG_TAN(IAXIS:JAXIS,IBM_MAXCROSS_X2)
INTEGER,  SAVE :: IBM_SEG_CRS(IBM_MAXCROSS_X2)

! Matrix vector building variables:

LOGICAL, SAVE :: CC_MATVEC_DEFINED=.FALSE.

LOGICAL, PARAMETER :: TRAP_CORR=.TRUE.  ! Solve implicit corrector step with Trapezoidal Rule? If not implicit RK2 corr.
                                        ! Which boils down to Backward Euler.
REAL(EB), SAVE :: BRP1 = 0._EB ! If 0., Godunov for advective term; if 1., centered interp.

INTEGER, ALLOCATABLE, DIMENSION(:) :: NUNKZ_LOC, NUNKZ_TOT, UNKZ_IND, UNKZ_ILC
INTEGER :: NUNKZ_LOCAL,NUNKZ_TOTAL

INTEGER, PARAMETER :: NNZ_ROW_Z = 15 ! 7 point stencil + 8 (buffer in case of unstructured grid).

REAL(EB),ALLOCATABLE, DIMENSION(:,:) ::  D_MAT_RHO,D_MAT_RHO0
REAL(EB), ALLOCATABLE, DIMENSION(:)  ::  F_RHO, RZ_RHO, RZ_RHOS
REAL(EB), ALLOCATABLE, DIMENSION(:)  ::  TR_RHO, F_RHO0, RZ_RHO0

INTEGER, ALLOCATABLE, DIMENSION(:)    :: NNZ_D_MAT_Z
REAL(EB),ALLOCATABLE, DIMENSION(:,:)  ::  D_MAT_Z
REAL(EB),ALLOCATABLE, DIMENSION(:,:,:):: D_MAT_Z0
INTEGER, ALLOCATABLE, DIMENSION(:,:)  :: JD_MAT_Z

REAL(EB),ALLOCATABLE, DIMENSION(:)   :: M_MAT_Z
INTEGER, ALLOCATABLE, DIMENSION(:)   :: JM_MAT_Z

REAL(EB), ALLOCATABLE, DIMENSION(:)  :: F_Z, RZ_Z, RZ_ZS
REAL(EB), ALLOCATABLE, DIMENSION(:,:):: TR_Z, F_Z0, RZ_Z0

INTEGER :: TOT_NNZ_Z
INTEGER, ALLOCATABLE, DIMENSION(:)   :: IA_Z, JA_Z
REAL(EB),ALLOCATABLE, DIMENSION(:)   :: A_Z

! Internal solver memory pointer for scalars solver:
! PARDISO:
! TYPE(MKL_PARDISO_HANDLE), ALLOCATABLE :: PT_Z(:)
#ifdef WITH_MKL
 TYPE(MKL_CLUSTER_SPARSE_SOLVER_HANDLE), ALLOCATABLE :: PT_Z(:)
#else
 INTEGER, ALLOCATABLE :: PT_Z(:)
#endif /* WITH_MKL */
INTEGER, ALLOCATABLE :: IPARMZ( : ) ! SOLVER Control Parameters array.
#ifdef WITH_MKL
INTEGER :: MAXFCTZ, MNUMZ, MTYPEZ, PHASEZ, NRHSZ, ERRORZ, MSGLVLZ, PERMZ(1)
#endif

! Here H variables, case of solver from geom:
! Everything related to GLMAT_FROM_GEOM will be erased when GLMAT from pres.f90 is
! complete.
INTEGER, ALLOCATABLE, DIMENSION(:) :: NUNKH_LOC, NUNKH_TOT, UNKH_IND
INTEGER :: NUNKH_LOCAL, NUNKH_TOTAL, NM_START

INTEGER, PARAMETER :: NNZ_ROW_H = 10 ! 7 point stencil + 3
                                     ! (buffer in case of unstructured grid).

INTEGER, ALLOCATABLE, TARGET, DIMENSION(:)   :: NNZ_D_MAT_H
REAL(EB),ALLOCATABLE, TARGET, DIMENSION(:,:) :: D_MAT_H
INTEGER, ALLOCATABLE, TARGET, DIMENSION(:,:) :: JD_MAT_H

INTEGER :: TOT_NNZ_H
INTEGER, ALLOCATABLE, DIMENSION(:)   :: IA_H, JA_H
REAL(EB),ALLOCATABLE, DIMENSION(:)   :: A_H

LOGICAL :: H_MATRIX_INDEFINITE

! Soln and RHS containers:
REAL(EB), ALLOCATABLE, TARGET, DIMENSION(:) :: F_H
REAL(EB), ALLOCATABLE, TARGET, DIMENSION(:) :: X_H

! Internal solver memory pointer:
! PARDISO
! TYPE(MKL_PARDISO_HANDLE), ALLOCATABLE :: PT_H(:)
#ifdef WITH_MKL
 TYPE(MKL_CLUSTER_SPARSE_SOLVER_HANDLE), ALLOCATABLE :: PT_H(:)
#else
 INTEGER, ALLOCATABLE :: PT_H(:)
#endif /* WITH_MKL */
INTEGER, ALLOCATABLE :: IPARM( : ) ! SOLVER Control Parameters array, defined in GET_HLU_3D

! Maximum number of search planes for interpolation:
INTEGER, PARAMETER :: PLOUT_MAX = 4

! Forcing control logicals:
LOGICAL, PARAMETER :: FORCE_SOLID_FACE    = .TRUE.
LOGICAL, PARAMETER :: FORCE_GAS_FACE      = .TRUE.
LOGICAL, PARAMETER :: INTERP_TO_CARTFACE  = .FALSE. ! If True => direct interpolation to cut-face
                                                    ! Cartesian Centroid in forcing, if False => flux average.
LOGICAL, PARAMETER :: FORCE_REGC_FACE     = .TRUE.
LOGICAL, SAVE ::      FORCE_REGC_FACE_NXT = .FALSE. ! Do not Force Regular Faces next to cut-faces.

LOGICAL, SAVE :: CC_INJECT_RHO0 = .FALSE. ! .TRUE.: inject RHO0 and use Boundary W velocity for cut-cell centroid.
                                          ! .FALSE.: Interpolate RHO0 and W velocity to cut-cell centroid.
                                          ! Set to .TRUE. if &MISC CC_ZEROIBM_VELO=.TRUE.
LOGICAL, SAVE :: CC_INTERPOLATE_H=.TRUE.  ! Set to .FALSE. if &MISC CC_ZEROIBM_VELO=.TRUE.

! Communication variables:

INTEGER :: N_REQ11, N_REQ12, N_REQ13
INTEGER, SAVE, ALLOCATABLE, DIMENSION(:) :: REQ11, REQ12, REQ13


! Timings variables:
LOGICAL, SAVE :: WRITE_SET_CUTCELLS_TIMINGS = .FALSE.
INTEGER, PARAMETER :: N_SET_CUTCELLS_3D_CALLS = 10

INTEGER, PARAMETER :: SET_CUTCELLS_TIME_INDEX              =  0
INTEGER, PARAMETER :: GET_BODINT_PLANE_TIME_INDEX          =  1
INTEGER, PARAMETER :: GET_X2_INTERSECTIONS_TIME_INDEX      =  2
INTEGER, PARAMETER :: GET_X2_VERTVAR_TIME_INDEX            =  3
INTEGER, PARAMETER :: GET_CARTEDGE_CUTEDGES_TIME_INDEX     =  4
INTEGER, PARAMETER :: GET_BODX2X3_INTERSECTIONS_TIME_INDEX =  5
INTEGER, PARAMETER :: GET_CARTFACE_CUTEDGES_TIME_INDEX     =  6
INTEGER, PARAMETER :: GET_CARTCELL_CUTEDGES_TIME_INDEX     =  7
INTEGER, PARAMETER :: GET_CARTFACE_CUTFACES_TIME_INDEX     =  8
INTEGER, PARAMETER :: GET_CARTCELL_CUTFACES_TIME_INDEX     =  9
INTEGER, PARAMETER :: GET_CARTCELL_CUTCELLS_TIME_INDEX     = 10

REAL(EB), SAVE :: T_CC_USED(SET_CUTCELLS_TIME_INDEX:GET_CARTCELL_CUTCELLS_TIME_INDEX) = 0._EB

INTEGER, SAVE :: N_CUTCELLS_PROC=0, N_INB_CUTFACES_PROC=0, N_REG_CUTFACES_PROC=0

! End Variable declaration for CC_IBM.
!! ---------------------------------------------------------------------------------

!! Initial volume integral of species mass, for CHECK_MASS_CONSERVE
REAL(EB), ALLOCATABLE, DIMENSION(:) :: VOLINT_SPEC_MASS_0,FLXTINT_SPEC_MASS,VOLINT_SPEC_MASS

LOGICAL, PARAMETER :: DO_SYMM_SCALAR_DIFFLUXES   =.FALSE. ! Experimental: Use symmetric form of diffusive fluxes
                                                          ! Ja=-rho^n Da d(rho^n+1 Ya/rho^n) in Implicit CC integration.
LOGICAL, PARAMETER :: IMP_REGION_FROM_MATRIX_DIFF=.FALSE. ! IF .FALSE. use scalars diffusion from divg computation.

REAL(EB):: VAL_TESTX_LOW,VAL_TESTX_HIGH,VAL_TESTY_LOW,VAL_TESTY_HIGH,VAL_TESTZ_LOW,VAL_TESTZ_HIGH

PRIVATE
PUBLIC :: ADD_INPLACE_NNZ_H_WHLDOM,&
          CCREGION_DIVERGENCE_PART_1,CCIBM_CHECK_DIVERGENCE,CCIBM_COMPUTE_VELOCITY_ERROR, &
          CCIBM_END_STEP,CCIBM_H_INTERP,CCIBM_NO_FLUX, &
          CCIBM_RHO0W_INTERP,CCIBM_SET_DATA,CCIBM_VELOCITY_CUTFACES,CCIBM_VELOCITY_FLUX, &
          CCIBM_VELOCITY_NO_GRADH,CCREGION_DENSITY,CFACE_THERMAL_GASVARS,CHECK_SPEC_TRANSPORT_CONSERVE,FINISH_CCIBM, &
          TRILINEAR,GET_CC_MATRIXGRAPH_H,GET_CC_IROW,GET_CC_UNKH,GET_CUTCELL_FH,GET_CUTCELL_HP, &
          GETU,GET_GASCUTFACE_SCALAR_SLICE,GETGRAD,GET_BOUNDFACE_GEOM_INFO_H, &
          GET_H_CUTFACES,GET_H_MATRIX_CC,GET_CRTCFCC_INTERPOLATION_STENCILS,GET_RCFACES_H, &
          GET_EXIMFACE_SCALAR_SLICE,GET_SOLIDCUTFACE_SCALAR_SLICE,GET_SOLIDREGFACE_SCALAR_SLICE, &
          INIT_CUTCELL_DATA,INTERSECT_CONE_AABB,INTERSECT_CYLINDER_AABB,INTERSECT_OBB_AABB,INTERSECT_SPHERE_AABB, &
          LINEARFIELDS_INTERP_TEST,MASS_CONSERVE_INIT,NUMBER_UNKH_CUTCELLS,POTENTIAL_FLOW_INIT,&
          READ_GEOM,ROTATION_MATRIX, &
          SET_CCIBM_MATVEC_DATA,SET_DOMAINDIFFLX_3D,SET_DOMAINADVFLX_3D, &
          SET_EXIMADVFLX_3D,SET_EXIMDIFFLX_3D,SET_EXIMRHOHSLIM_3D,SET_EXIMRHOZZLIM_3D, &
          WRITE_GEOM,WRITE_GEOM_ALL,WRITE_GEOM_DATA, &
          FCELL,IBM_SOLID,IBM_VGSC,IBM_CGSC,IBM_FGSC,IBM_IDCF,IBM_UNKZ,IBM_GASPHASE,IBM_CUTCFE,IBM_FTYPE_CFGAS, &
          IBM_FTYPE_CFINB,IBM_FTYPE_RGGAS,IBM_IDCC, &
          IBM_NCVARS, IBM_UNKH,NUNKH_LOC, NUNKH_TOT, UNKH_IND, NUNKH_LOCAL, NUNKH_TOTAL, NM_START, &
          NNZ_ROW_H, TOT_NNZ_H, NNZ_D_MAT_H, D_MAT_H, JD_MAT_H, IA_H,       &
          JA_H, A_H, H_MATRIX_INDEFINITE, F_H, X_H, PT_H, IPARM, CCCOMPUTE_RADIATION, &
          COPY_CC_UNKH_TO_HS, COPY_CC_HS_TO_UNKH, MESH_CC_EXCHANGE, TRIANGULATE, VALID_TRIANGLE


CONTAINS

! ------------------------------- CFACE_THERMAL_GASVARS ------------------------------

SUBROUTINE CFACE_THERMAL_GASVARS(ICF,ONE_D)

USE PHYSICAL_FUNCTIONS, ONLY: GET_CONDUCTIVITY

INTEGER, INTENT(IN) :: ICF
TYPE(ONE_D_M_AND_E_XFER_TYPE), INTENT(INOUT), POINTER :: ONE_D

! Local Variables:
INTEGER :: IND1, IND2, ICC, JCC, I ,J ,K, IFACE, IFC2, IFACE2, NFCELL, ICCF, X1AXIS, LOWHIGH, ILH, IBOD, IWSEL
REAL(EB):: PREDFCT,U_CAVG(IAXIS:KAXIS),AREA_TANG(IAXIS:KAXIS),AF,VELN,NVEC(IAXIS:KAXIS),ABS_NVEC(IAXIS:KAXIS),K_G
REAL(EB), POINTER, DIMENSION(:,:,:) :: UP,VP,WP

IF (PREDICTOR) THEN
   PREDFCT=1._EB
   UP => U ! Corrector final velocities.
   VP => V
   WP => W
ELSE
   PREDFCT=0._EB
   UP => US ! Predictor final velocities.
   VP => VS
   WP => WS
ENDIF

! ONE_D%TMP_G, ONE_D%RHO_G, ONE_D%ZZ_G(:), ONE_D%RSUM_G, ONE_D%U_TANG

! Load indexes {ICF,IFACE} in CUT_FACE, for CFACE {ICFACE}:
IND1=CFACE(ICF)%CUT_FACE_IND1
IND2=CFACE(ICF)%CUT_FACE_IND2

! Assign an IOR:
IBOD =CUT_FACE(IND1)%BODTRI(1,IND2)
IWSEL=CUT_FACE(IND1)%BODTRI(2,IND2)
NVEC(IAXIS:KAXIS) = GEOMETRY(IBOD)%FACES_NORMAL(IAXIS:KAXIS,IWSEL)
ABS_NVEC(IAXIS:KAXIS) = ABS(NVEC(IAXIS:KAXIS))
X1AXIS = MAXLOC(ABS_NVEC(IAXIS:KAXIS),DIM=1)
ONE_D%IOR = INT(SIGN(1._EB,NVEC(X1AXIS)))*X1AXIS

SELECT CASE(CUT_FACE(IND1)%CELL_LIST(1,LOW_IND,IND2))
CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use value from CUT_CELL data struct:
   ICC = CUT_FACE(IND1)%CELL_LIST(2,LOW_IND,IND2)
   JCC = CUT_FACE(IND1)%CELL_LIST(3,LOW_IND,IND2)

   I = CUT_CELL(ICC)%IJK(IAXIS)
   J = CUT_CELL(ICC)%IJK(JAXIS)
   K = CUT_CELL(ICC)%IJK(KAXIS)

   ! ADD CUT_CELL properties:
   ONE_D%TMP_G = CUT_CELL(ICC)%TMP(JCC)
   ONE_D%RSUM_G= CUT_CELL(ICC)%RSUM(JCC)

   ! Mixture density and Species mass fractions:
   ONE_D%RHO_G = PREDFCT*CUT_CELL(ICC)%RHOS(JCC) + (1._EB-PREDFCT)*CUT_CELL(ICC)%RHO(JCC)
   ONE_D%ZZ_G(1:N_TRACKED_SPECIES) = PREDFCT *CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC) + &
                              (1._EB-PREDFCT)*CUT_CELL(ICC)% ZZ(1:N_TRACKED_SPECIES,JCC)

   ! Viscosity, Use MU from bearing cartesian cell:
   ONE_D%MU_G = MU(I,J,K)

   ! Gas conductivity:
   K_G = ONE_D%MU_G*CPOPR
   IF(DNS) CALL GET_CONDUCTIVITY(ONE_D%ZZ_G(1:N_TRACKED_SPECIES),K_G,ONE_D%TMP_G)
   ONE_D%K_G = K_G

   ! Finally U_TANG velocity: For now compute the Area average component on each direction:
   ! This can be optimized by moving the computaiton of U_CAVG out, before call to WALL_BC.
   U_CAVG(IAXIS:KAXIS)   = 0._EB
   AREA_TANG(IAXIS:KAXIS)= 0._EB

   NFCELL=CUT_CELL(ICC)%CCELEM(1,JCC)
   DO ICCF=1,NFCELL
      IFACE=CUT_CELL(ICC)%CCELEM(ICCF+1,JCC)
      SELECT CASE(CUT_CELL(ICC)%FACE_LIST(1,IFACE))
      CASE(IBM_FTYPE_RGGAS) ! REGULAR GASPHASE
         LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
         X1AXIS  = CUT_CELL(ICC)%FACE_LIST(3,IFACE)
         ILH     = LOWHIGH - 1
         SELECT CASE(X1AXIS)
         CASE(IAXIS)
            AF   = DY(J)*DZ(K)
            VELN = UP(I-FCELL+ILH,J,K)
         CASE(JAXIS)
            AF   = DX(I)*DZ(K)
            VELN = VP(I,J-FCELL+ILH,K)
         CASE(KAXIS)
            AF   = DX(I)*DY(J)
            VELN = WP(I,J,K-FCELL+ILH)
         END SELECT

         U_CAVG(X1AXIS)    =    U_CAVG(X1AXIS) + AF*VELN
         AREA_TANG(X1AXIS) = AREA_TANG(X1AXIS) + AF

      CASE(IBM_FTYPE_CFGAS)
         LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
         IFC2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
         IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
         X1AXIS  = CUT_FACE(IFC2)%IJK(KAXIS+1)
         AF      = CUT_FACE(IFC2)%AREA(IFACE2)
         VELN    =        PREDFCT *CUT_FACE(IFC2)%VEL( IFACE2) + &
                   (1._EB-PREDFCT)*CUT_FACE(IFC2)%VELS(IFACE2)

         U_CAVG(X1AXIS)    =    U_CAVG(X1AXIS) + AF*VELN
         AREA_TANG(X1AXIS) = AREA_TANG(X1AXIS) + AF

      CASE(IBM_FTYPE_CFINB)
         IFC2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
         IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)

         AF      = CUT_FACE(IFC2)%AREA(IFACE2)
         ! Normal velocity defined into the body. We want velocity in direction of normal out of bod.
         VELN    = -1._EB*(       PREDFCT *CUT_FACE(IFC2)%VEL( IFACE2) + &
                           (1._EB-PREDFCT)*CUT_FACE(IFC2)%VELS(IFACE2))

         ! Fetch normal out of body on surface triangle this cface lives in:
         IBOD =CUT_FACE(IFC2)%BODTRI(1,IFACE2)
         IWSEL=CUT_FACE(IFC2)%BODTRI(2,IFACE2)
         NVEC(IAXIS:KAXIS) = GEOMETRY(IBOD)%FACES_NORMAL(IAXIS:KAXIS,IWSEL)
         DO X1AXIS=IAXIS,KAXIS
            U_CAVG(X1AXIS)    =    U_CAVG(X1AXIS) + AF*VELN*NVEC(X1AXIS)
            AREA_TANG(X1AXIS) = AREA_TANG(X1AXIS) + AF*ABS(NVEC(X1AXIS))
         ENDDO

      END SELECT

   ENDDO
   DO X1AXIS=IAXIS,KAXIS
      U_CAVG(X1AXIS) = U_CAVG(X1AXIS) / AREA_TANG(X1AXIS)
   ENDDO

   ! U_TANG use the norm of CC centroid area averaged velocity:
   ONE_D%U_TANG = SQRT( U_CAVG(IAXIS)**2._EB + U_CAVG(JAXIS)**2._EB + U_CAVG(KAXIS)**2._EB )


END SELECT

RETURN
END SUBROUTINE CFACE_THERMAL_GASVARS

! --------------------------- GET_SOLIDREGFACE_SCALAR_SLICE --------------------------

SUBROUTINE GET_SOLIDREGFACE_SCALAR_SLICE(X1AXIS,I,J,K,IND,Y_INDEX,Z_INDEX,VAL_CF)

USE PHYSICAL_FUNCTIONS, ONLY: GET_MASS_FRACTION

INTEGER, INTENT(IN) :: X1AXIS,I,J,K,IND,Y_INDEX,Z_INDEX
REAL(EB),INTENT(OUT):: VAL_CF

! Local Variables:
INTEGER :: II_LO,II_HI,JJ_LO,JJ_HI,KK_LO,KK_HI,SOLID_LO,SOLID_HI
REAL(EB):: CC1(LOW_IND:HIGH_IND),CCSUM
REAL(EB) :: Y_SPECIES,ZZ_GET(1:N_TRACKED_SPECIES),VAL_CF_LO,VAL_CF_HI

VAL_CF    = 0._EB
Y_SPECIES = 1._EB

SELECT CASE(X1AXIS)
CASE(IAXIS)
   II_LO=I+FCELL-1; II_HI=I+FCELL
   JJ_LO=J;         JJ_HI=J
   KK_LO=K;         KK_HI=K
CASE(JAXIS)
   II_LO=I;         II_HI=I
   JJ_LO=J+FCELL-1; JJ_HI=J+FCELL
   KK_LO=K;         KK_HI=K
CASE(KAXIS)
   II_LO=I;         II_HI=I
   JJ_LO=J;         JJ_HI=J
   KK_LO=K+FCELL-1; KK_HI=K+FCELL
END SELECT

SOLID_LO = CCVAR(II_LO,JJ_LO,KK_LO,IBM_CGSC)
SOLID_HI = CCVAR(II_HI,JJ_HI,KK_HI,IBM_CGSC)

CC1(LOW_IND:HIGH_IND) = 0._EB
IF(SOLID_LO == IBM_SOLID) CC1( LOW_IND)= 1._EB
IF(SOLID_HI == IBM_SOLID) CC1(HIGH_IND)= 1._EB

! Interpolation coefficients:
CCSUM = SUM(CC1(LOW_IND:HIGH_IND))
IF( CCSUM > 0._EB ) CC1(LOW_IND:HIGH_IND)=CC1(LOW_IND:HIGH_IND)/CCSUM

SELECT CASE(IND)
  CASE(1)  ! DENSITY
     IF (Z_INDEX > 0) THEN
        Y_SPECIES = CC1(LOW_IND)*ZZ(II_LO,JJ_LO,KK_LO,Z_INDEX) + CC1(HIGH_IND)*ZZ(II_HI,JJ_HI,KK_HI,Z_INDEX)
     ELSEIF (Y_INDEX > 0) THEN
        ZZ_GET(1:N_TRACKED_SPECIES) = CC1( LOW_IND)*ZZ(II_LO,JJ_LO,KK_LO,1:N_TRACKED_SPECIES) + &
                                      CC1(HIGH_IND)*ZZ(II_HI,JJ_HI,KK_HI,1:N_TRACKED_SPECIES)
        CALL GET_MASS_FRACTION(ZZ_GET,Y_INDEX,Y_SPECIES)
     ENDIF
     VAL_CF =  (CC1(LOW_IND)*RHO(II_LO,JJ_LO,KK_LO) + CC1(HIGH_IND)*RHO(II_HI,JJ_HI,KK_HI))*Y_SPECIES
  CASE(5) ! TEMPERATURE
     VAL_CF =  CC1(LOW_IND)*TMP(II_LO,JJ_LO,KK_LO) + CC1(HIGH_IND)*TMP(II_HI,JJ_HI,KK_HI) - TMPM
  CASE( 9)  ! PRESSURE
     VAL_CF_LO = PBAR(KK_LO,PRESSURE_ZONE(II_LO,JJ_LO,KK_LO)) + &
                 RHO(II_LO,JJ_LO,KK_LO)*(H(II_LO,JJ_LO,KK_LO)-KRES(II_LO,JJ_LO,KK_LO)) - P_0(KK_LO)
     VAL_CF_HI = PBAR(KK_HI,PRESSURE_ZONE(II_HI,JJ_HI,KK_HI)) + &
                 RHO(II_HI,JJ_HI,KK_HI)*(H(II_HI,JJ_HI,KK_HI)-KRES(II_HI,JJ_HI,KK_HI)) - P_0(KK_HI)
     VAL_CF = CC1(LOW_IND)*VAL_CF_LO + CC1(HIGH_IND)*VAL_CF_HI
  CASE(11) ! HRRPUV
     VAL_CF = (CC1(LOW_IND)*  Q(II_LO,JJ_LO,KK_LO) + CC1(HIGH_IND)*  Q(II_HI,JJ_HI,KK_HI))*0.001_EB
  CASE(12) ! H, interpolated to cut-cells if PRES_ON_CARTESIAN
     VAL_CF =  CC1(LOW_IND)*  H(II_LO,JJ_LO,KK_LO) + CC1(HIGH_IND)*  H(II_HI,JJ_HI,KK_HI)
  CASE(14) ! DIVERGENCE
     VAL_CF =  CC1(LOW_IND)*  D(II_LO,JJ_LO,KK_LO) + CC1(HIGH_IND)*  D(II_HI,JJ_HI,KK_HI)
  CASE(17)  ! VISCOSITY
     VAL_CF =  CC1(LOW_IND)* MU(II_LO,JJ_LO,KK_LO) + CC1(HIGH_IND)* MU(II_HI,JJ_HI,KK_HI)
  CASE(90) ! MASS FRACTION, uses Y_INDEX
     IF (Z_INDEX > 0) THEN
        Y_SPECIES = CC1(LOW_IND)*ZZ(II_LO,JJ_LO,KK_LO,Z_INDEX) + CC1(HIGH_IND)*ZZ(II_HI,JJ_HI,KK_HI,Z_INDEX)
     ELSEIF (Y_INDEX > 0) THEN
        ZZ_GET(1:N_TRACKED_SPECIES) = CC1( LOW_IND)*ZZ(II_LO,JJ_LO,KK_LO,1:N_TRACKED_SPECIES) + &
                                      CC1(HIGH_IND)*ZZ(II_HI,JJ_HI,KK_HI,1:N_TRACKED_SPECIES)
        CALL GET_MASS_FRACTION(ZZ_GET,Y_INDEX,Y_SPECIES)
     ENDIF
     VAL_CF = Y_SPECIES
END SELECT

RETURN
END SUBROUTINE GET_SOLIDREGFACE_SCALAR_SLICE

! --------------------------- GET_SOLIDCUTFACE_SCALAR_SLICE --------------------------

SUBROUTINE GET_SOLIDCUTFACE_SCALAR_SLICE(X1AXIS,ICF,IND,Y_INDEX,Z_INDEX,VAL_CF)

USE PHYSICAL_FUNCTIONS, ONLY: GET_MASS_FRACTION

INTEGER, INTENT(IN) :: X1AXIS,ICF,IND,Y_INDEX,Z_INDEX
REAL(EB),INTENT(OUT):: VAL_CF

! Local Variables:
INTEGER :: II_LO,II_HI,JJ_LO,JJ_HI,KK_LO,KK_HI,IJK(IAXIS:KAXIS),IJK2(IAXIS:KAXIS,16),ICELL,II,JJ,KK
LOGICAL :: FOUND
REAL(EB):: Y_SPECIES,ZZ_GET(1:N_TRACKED_SPECIES)

! Point to mesh has been called for MESHES(NM): This routine searches for a REGULAR SOLID cell in the
! vicinity of the SOLID cut-face and assigns to the latter the scalar value of the former.

VAL_CF    = 0._EB
Y_SPECIES = 1._EB

IJK(IAXIS:KAXIS)=CUT_FACE(ICF)%IJK(IAXIS:KAXIS)

SELECT CASE(X1AXIS)
CASE(IAXIS)
   II_LO=IJK(IAXIS)+FCELL-1; II_HI=IJK(IAXIS)+FCELL
   JJ_LO=IJK(JAXIS)-1;       JJ_HI=IJK(JAXIS)+1
   KK_LO=IJK(KAXIS)-1;       KK_HI=IJK(KAXIS)+1

   IJK2(IAXIS:KAXIS, 1) = (/ II_LO, JJ_LO, IJK(KAXIS) /)
   IJK2(IAXIS:KAXIS, 2) = (/ II_LO, JJ_HI, IJK(KAXIS) /)
   IJK2(IAXIS:KAXIS, 3) = (/ II_LO, IJK(JAXIS), KK_LO /)
   IJK2(IAXIS:KAXIS, 4) = (/ II_LO, IJK(JAXIS), KK_HI /)
   IJK2(IAXIS:KAXIS, 5) = (/ II_HI, JJ_LO, IJK(KAXIS) /)
   IJK2(IAXIS:KAXIS, 6) = (/ II_HI, JJ_HI, IJK(KAXIS) /)
   IJK2(IAXIS:KAXIS, 7) = (/ II_HI, IJK(JAXIS), KK_LO /)
   IJK2(IAXIS:KAXIS, 8) = (/ II_HI, IJK(JAXIS), KK_HI /)
   IJK2(IAXIS:KAXIS, 9) = (/ II_LO, JJ_LO, KK_LO /)
   IJK2(IAXIS:KAXIS,10) = (/ II_LO, JJ_HI, KK_LO /)
   IJK2(IAXIS:KAXIS,11) = (/ II_LO, JJ_LO, KK_HI /)
   IJK2(IAXIS:KAXIS,12) = (/ II_LO, JJ_HI, KK_HI /)
   IJK2(IAXIS:KAXIS,13) = (/ II_HI, JJ_LO, KK_LO /)
   IJK2(IAXIS:KAXIS,14) = (/ II_HI, JJ_HI, KK_LO /)
   IJK2(IAXIS:KAXIS,15) = (/ II_HI, JJ_LO, KK_HI /)
   IJK2(IAXIS:KAXIS,16) = (/ II_HI, JJ_HI, KK_HI /)

CASE(JAXIS)
   II_LO=IJK(IAXIS)-1;       II_HI=IJK(IAXIS)+1
   JJ_LO=IJK(JAXIS)+FCELL-1; JJ_HI=IJK(JAXIS)+FCELL
   KK_LO=IJK(KAXIS)-1;       KK_HI=IJK(KAXIS)+1

   IJK2(IAXIS:KAXIS, 1) = (/ IJK(IAXIS), JJ_LO, KK_LO /)
   IJK2(IAXIS:KAXIS, 2) = (/ IJK(IAXIS), JJ_LO, KK_HI /)
   IJK2(IAXIS:KAXIS, 3) = (/ II_LO, JJ_LO, IJK(KAXIS) /)
   IJK2(IAXIS:KAXIS, 4) = (/ II_HI, JJ_LO, IJK(KAXIS) /)
   IJK2(IAXIS:KAXIS, 5) = (/ IJK(IAXIS), JJ_HI, KK_LO /)
   IJK2(IAXIS:KAXIS, 6) = (/ IJK(IAXIS), JJ_HI, KK_HI /)
   IJK2(IAXIS:KAXIS, 7) = (/ II_LO, JJ_HI, IJK(KAXIS) /)
   IJK2(IAXIS:KAXIS, 8) = (/ II_HI, JJ_HI, IJK(KAXIS) /)
   IJK2(IAXIS:KAXIS, 9) = (/ II_LO, JJ_LO, KK_LO /)
   IJK2(IAXIS:KAXIS,10) = (/ II_LO, JJ_LO, KK_HI /)
   IJK2(IAXIS:KAXIS,11) = (/ II_HI, JJ_LO, KK_LO /)
   IJK2(IAXIS:KAXIS,12) = (/ II_HI, JJ_LO, KK_HI /)
   IJK2(IAXIS:KAXIS,13) = (/ II_LO, JJ_HI, KK_LO /)
   IJK2(IAXIS:KAXIS,14) = (/ II_LO, JJ_HI, KK_HI /)
   IJK2(IAXIS:KAXIS,15) = (/ II_HI, JJ_HI, KK_LO /)
   IJK2(IAXIS:KAXIS,16) = (/ II_HI, JJ_HI, KK_HI /)

CASE(KAXIS)
   II_LO=IJK(IAXIS)-1;       II_HI=IJK(IAXIS)+1
   JJ_LO=IJK(JAXIS)-1;       JJ_HI=IJK(JAXIS)+1
   KK_LO=IJK(KAXIS)+FCELL-1; KK_HI=IJK(KAXIS)+FCELL

   IJK2(IAXIS:KAXIS, 1) = (/ II_LO, IJK(JAXIS), KK_LO /)
   IJK2(IAXIS:KAXIS, 2) = (/ II_HI, IJK(JAXIS), KK_LO /)
   IJK2(IAXIS:KAXIS, 3) = (/ IJK(IAXIS), JJ_LO, KK_LO /)
   IJK2(IAXIS:KAXIS, 4) = (/ IJK(IAXIS), JJ_HI, KK_LO /)
   IJK2(IAXIS:KAXIS, 5) = (/ II_LO, IJK(JAXIS), KK_HI /)
   IJK2(IAXIS:KAXIS, 6) = (/ II_HI, IJK(JAXIS), KK_HI /)
   IJK2(IAXIS:KAXIS, 7) = (/ IJK(IAXIS), JJ_LO, KK_HI /)
   IJK2(IAXIS:KAXIS, 8) = (/ IJK(IAXIS), JJ_HI, KK_HI /)
   IJK2(IAXIS:KAXIS, 9) = (/ II_LO, JJ_LO, KK_LO /)
   IJK2(IAXIS:KAXIS,10) = (/ II_HI, JJ_LO, KK_LO /)
   IJK2(IAXIS:KAXIS,11) = (/ II_LO, JJ_HI, KK_LO /)
   IJK2(IAXIS:KAXIS,12) = (/ II_HI, JJ_HI, KK_LO /)
   IJK2(IAXIS:KAXIS,13) = (/ II_LO, JJ_LO, KK_HI /)
   IJK2(IAXIS:KAXIS,14) = (/ II_HI, JJ_LO, KK_HI /)
   IJK2(IAXIS:KAXIS,15) = (/ II_LO, JJ_HI, KK_HI /)
   IJK2(IAXIS:KAXIS,16) = (/ II_HI, JJ_HI, KK_HI /)

END SELECT

FOUND=.FALSE.
DO ICELL=1,16
   ! Look only for internal cells:
   II=IJK2(IAXIS,ICELL)
   IF(II < 1 .OR. II > IBAR) CYCLE
   JJ=IJK2(JAXIS,ICELL)
   IF(JJ < 1 .OR. JJ > JBAR) CYCLE
   KK=IJK2(KAXIS,ICELL)
   IF(KK < 1 .OR. KK > KBAR) CYCLE
   IF (CCVAR(II,JJ,KK,IBM_CGSC) /= IBM_SOLID) CYCLE
   FOUND=.TRUE.
   EXIT
ENDDO

IF(.NOT.FOUND) THEN ! This is a thin object. Use first gas cut-cell value:
   DO ICELL=1,16
      ! Look only for internal cells:
      II=IJK2(IAXIS,ICELL)
      IF(II < 1 .OR. II > IBAR) CYCLE
      JJ=IJK2(JAXIS,ICELL)
      IF(JJ < 1 .OR. JJ > JBAR) CYCLE
      KK=IJK2(KAXIS,ICELL)
      IF(KK < 1 .OR. KK > KBAR) CYCLE
      IF (CCVAR(II,JJ,KK,IBM_CGSC) /= IBM_CUTCFE) CYCLE
      FOUND=.TRUE.
      EXIT
   ENDDO
ENDIF

! Use closest solid Cell values for SOLID cut-face:
IF (FOUND) THEN
   SELECT CASE(IND)
     CASE(1)  ! DENSITY
        IF (Z_INDEX > 0) THEN
           Y_SPECIES = ZZ(II,JJ,KK,Z_INDEX)
        ELSEIF (Y_INDEX > 0) THEN
           ZZ_GET(1:N_TRACKED_SPECIES) = ZZ(II,JJ,KK,1:N_TRACKED_SPECIES)
           CALL GET_MASS_FRACTION(ZZ_GET,Y_INDEX,Y_SPECIES)
        ENDIF
        VAL_CF = RHO(II,JJ,KK)*Y_SPECIES
     CASE(5) ! TEMPERATURE
        VAL_CF = TMP(II,JJ,KK) - TMPM
     CASE( 9)  ! PRESSURE
        VAL_CF = PBAR(KK,PRESSURE_ZONE(II,JJ,KK)) + RHO(II,JJ,KK)*(H(II,JJ,KK)-KRES(II,JJ,KK)) - P_0(KK)
     CASE(11) ! HRRPUV
        VAL_CF = Q(II,JJ,KK)*0.001_EB
     CASE(12) ! H, interpolated to cut-cells if PRES_ON_CARTESIAN
        VAL_CF = H(II,JJ,KK)
     CASE(14) ! DIVERGENCE
        VAL_CF = D(II,JJ,KK)
     CASE(17)  ! VISCOSITY
        VAL_CF = MU(II,JJ,KK)
     CASE(90) ! MASS FRACTION, uses Y_INDEX
        IF (Z_INDEX > 0) THEN
           Y_SPECIES = ZZ(II,JJ,KK,Z_INDEX)
        ELSEIF (Y_INDEX > 0) THEN
           ZZ_GET(1:N_TRACKED_SPECIES) = ZZ(II,JJ,KK,1:N_TRACKED_SPECIES)
           CALL GET_MASS_FRACTION(ZZ_GET,Y_INDEX,Y_SPECIES)
        ENDIF
        VAL_CF = Y_SPECIES
   END SELECT
ENDIF

RETURN
END SUBROUTINE GET_SOLIDCUTFACE_SCALAR_SLICE

! ---------------------------- GET_GASCUTFACE_SCALAR_SLICE ------------------------------

SUBROUTINE GET_GASCUTFACE_SCALAR_SLICE(X1AXIS,ICF,IFACE,IND,CC_FACE_CENTERED,CC_CELL_CENTERED,Y_INDEX,Z_INDEX,VAL_CF)

USE PHYSICAL_FUNCTIONS, ONLY: GET_MASS_FRACTION

INTEGER, INTENT(IN) :: X1AXIS,ICF,IFACE,IND,Y_INDEX,Z_INDEX
LOGICAL, INTENT(IN) :: CC_FACE_CENTERED,CC_CELL_CENTERED
REAL(EB),INTENT(OUT):: VAL_CF

! Local Variables:
REAL(EB) :: X1F, IDX, CCM1, CCP1, VAL_LOC(LOW_IND:HIGH_IND)
INTEGER  :: ISIDE, ICC, JCC, LOCAL_IND, II, JJ, KK
REAL(EB) :: Y_SPECIES(LOW_IND:HIGH_IND),ZZ_GET(1:N_TRACKED_SPECIES)

! Point to mesh has been called for MESHES(NM):

Y_SPECIES(LOW_IND:HIGH_IND) = 1._EB

! Here interpolate values from cut-cell centers:
X1F= CUT_FACE(ICF)%XYZCEN(X1AXIS,IFACE)
IDX= 1._EB/ ( CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE) - &
              CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE) )
CCM1= IDX*(CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE)-X1F)
CCP1= IDX*(X1F-CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE))
LOCAL_IND=HIGH_IND

IF( .NOT.CC_FACE_CENTERED .AND. CC_CELL_CENTERED) THEN
   CCM1=1._EB
   CCP1=0._EB
   LOCAL_IND=LOW_IND
ENDIF

VAL_LOC(LOW_IND:HIGH_IND)= 0._EB
DO ISIDE=LOW_IND,LOCAL_IND
   SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE,IFACE))
   CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use value from CUT_CELL data struct:
      ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE,IFACE)
      JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE,IFACE)
      SELECT CASE(IND)
        CASE(1)  ! DENSITY
           IF (Z_INDEX > 0) THEN
              Y_SPECIES = CUT_CELL(ICC)%ZZ(Z_INDEX,JCC)
           ELSEIF (Y_INDEX > 0) THEN
              ZZ_GET(1:N_TRACKED_SPECIES) = CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC)
              CALL GET_MASS_FRACTION(ZZ_GET,Y_INDEX,Y_SPECIES(ISIDE))
           ENDIF
           VAL_LOC(ISIDE) = CUT_CELL(ICC)%RHO(JCC)*Y_SPECIES(ISIDE)
        CASE(5) ! TEMPERATURE
           VAL_LOC(ISIDE) = CUT_CELL(ICC)%TMP(JCC) - TMPM
        CASE( 9)  ! PRESSURE
           II=CUT_CELL(ICC)%IJK(IAXIS)
           JJ=CUT_CELL(ICC)%IJK(JAXIS)
           KK=CUT_CELL(ICC)%IJK(KAXIS)
           VAL_LOC(ISIDE) = PBAR(KK,PRESSURE_ZONE(II,JJ,KK)) + RHO(II,JJ,KK)*(H(II,JJ,KK)-KRES(II,JJ,KK)) - P_0(KK)
        CASE(11) ! HRRPUV
           VAL_LOC(ISIDE) = CUT_CELL(ICC)%Q(JCC)*0.001_EB
        CASE(12) ! H, interpolated to cut-cells if PRES_ON_CARTESIAN
           VAL_LOC(ISIDE) = CUT_CELL(ICC)%H(JCC)
        CASE(14) ! DIVERGENCE
           VAL_LOC(ISIDE) = CUT_CELL(ICC)%D(JCC)/CUT_CELL(ICC)%VOLUME(JCC)
        CASE(17)  ! VISCOSITY
           VAL_LOC(ISIDE) = MU(CUT_CELL(ICC)%IJK(IAXIS),CUT_CELL(ICC)%IJK(JAXIS),CUT_CELL(ICC)%IJK(KAXIS))
        CASE(90) ! MASS FRACTION, uses Y_INDEX
           IF (Z_INDEX > 0) THEN
              Y_SPECIES = CUT_CELL(ICC)%ZZ(Z_INDEX,JCC)
           ELSEIF (Y_INDEX > 0) THEN
              ZZ_GET(1:N_TRACKED_SPECIES) = CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC)
              CALL GET_MASS_FRACTION(ZZ_GET,Y_INDEX,Y_SPECIES(ISIDE))
           ENDIF
           VAL_LOC(ISIDE) = Y_SPECIES(ISIDE)
      END SELECT
   END SELECT
ENDDO
VAL_CF = CCM1*VAL_LOC(LOW_IND) + CCP1*VAL_LOC(HIGH_IND)

RETURN
END SUBROUTINE GET_GASCUTFACE_SCALAR_SLICE

! ---------------------------- GET_EXIMFACE_SCALAR_SLICE ------------------------------

SUBROUTINE GET_EXIMFACE_SCALAR_SLICE(IEXIM,IND,Y_INDEX,Z_INDEX,VAL_CF)

USE PHYSICAL_FUNCTIONS, ONLY: GET_MASS_FRACTION

INTEGER, INTENT(IN) :: IEXIM,IND,Y_INDEX,Z_INDEX
REAL(EB),INTENT(OUT):: VAL_CF

! Local Variables:
REAL(EB), PARAMETER :: CCM1=0.5_EB, CCP1=0.5_EB
INTEGER  :: I,J,K,II,JJ,KK,X1AXIS,ISIDE,IJK(IAXIS:KAXIS,LOW_IND:HIGH_IND)=0
REAL(EB) :: Y_SPECIES(LOW_IND:HIGH_IND), ZZ_GET(1:N_TRACKED_SPECIES), VAL_LOC(LOW_IND:HIGH_IND)

! Point to mesh has been called for MESHES(NM):

Y_SPECIES(LOW_IND:HIGH_IND) = 1._EB

I      = IBM_EXIM_FACE(IEXIM)%IJK(IAXIS)
J      = IBM_EXIM_FACE(IEXIM)%IJK(JAXIS)
K      = IBM_EXIM_FACE(IEXIM)%IJK(KAXIS)
X1AXIS = IBM_EXIM_FACE(IEXIM)%IJK(KAXIS+1)

IJK(X1AXIS,HIGH_IND) = 1
VAL_LOC(LOW_IND:HIGH_IND)= 0._EB
DO ISIDE=LOW_IND,HIGH_IND
   II = I+IJK(IAXIS,ISIDE)
   JJ = J+IJK(JAXIS,ISIDE)
   KK = K+IJK(KAXIS,ISIDE)
   SELECT CASE(IND)
     CASE(1)  ! DENSITY
        IF (Z_INDEX > 0) THEN
           Y_SPECIES = ZZ(II,JJ,KK,Z_INDEX)
        ELSEIF (Y_INDEX > 0) THEN
           ZZ_GET(1:N_TRACKED_SPECIES) = ZZ(II,JJ,KK,1:N_TRACKED_SPECIES)
           CALL GET_MASS_FRACTION(ZZ_GET,Y_INDEX,Y_SPECIES(ISIDE))
        ENDIF
        VAL_LOC(ISIDE) = RHO(II,JJ,KK)*Y_SPECIES(ISIDE)
     CASE(5) ! TEMPERATURE
        VAL_LOC(ISIDE) = TMP(II,JJ,KK) - TMPM
     CASE( 9)  ! PRESSURE
        VAL_LOC(ISIDE) = PBAR(KK,PRESSURE_ZONE(II,JJ,KK)) + RHO(II,JJ,KK)*(H(II,JJ,KK)-KRES(II,JJ,KK)) - P_0(KK)
     CASE(11) ! HRRPUV
        VAL_LOC(ISIDE) = Q(II,JJ,KK)*0.001_EB
     CASE(12) ! H, interpolated to cut-cells if PRES_ON_CARTESIAN
        VAL_LOC(ISIDE) = H(II,JJ,KK)
     CASE(14) ! DIVERGENCE
        VAL_LOC(ISIDE) = D(II,JJ,KK)
     CASE(17)  ! VISCOSITY
        VAL_LOC(ISIDE) =MU(II,JJ,KK)
     CASE(90) ! MASS FRACTION, uses Y_INDEX
        IF (Z_INDEX > 0) THEN
           Y_SPECIES = ZZ(II,JJ,KK,Z_INDEX)
        ELSEIF (Y_INDEX > 0) THEN
           ZZ_GET(1:N_TRACKED_SPECIES) = ZZ(II,JJ,KK,1:N_TRACKED_SPECIES)
           CALL GET_MASS_FRACTION(ZZ_GET,Y_INDEX,Y_SPECIES(ISIDE))
        ENDIF
        VAL_LOC(ISIDE) = Y_SPECIES(ISIDE)
   END SELECT

ENDDO
VAL_CF = CCM1*VAL_LOC(LOW_IND) + CCP1*VAL_LOC(HIGH_IND)

RETURN
END SUBROUTINE GET_EXIMFACE_SCALAR_SLICE


! ------------------------------- MESH_CC_EXCHANGE ---------------------------------

SUBROUTINE MESH_CC_EXCHANGE(CODE,CALL_FROM_HINTERP)

USE MPI

INTEGER, INTENT(IN) :: CODE
LOGICAL, INTENT(IN) :: CALL_FROM_HINTERP

! Local Variables:
INTEGER :: NM,NOM,NOOM,RNODE,SNODE,IERR
INTEGER :: II1,JJ1,KK1,NCELL,ICC,ICC1,NQT2,JCC,LL,NN
INTEGER :: I,J,K,IFC,ICF,IPT,X1AXIS,IFACE
!INTEGER, ALLOCATABLE, DIMENSION(:) :: NCC_SV
TYPE (MESH_TYPE), POINTER :: M
TYPE (OMESH_TYPE), POINTER :: M2,M3
LOGICAL, SAVE :: INITIALIZE_CC_SCALARS_FORC=.TRUE.

TYPE (WALL_TYPE), POINTER :: WC
TYPE (EXTERNAL_WALL_TYPE), POINTER :: EWC
INTEGER :: IW,II,JJ,KK

! In case of initialization code from main return.
! Initialization of cut-cell communications needs to be done later in the main.f90 sequence and will be done using
! INITIALIZE_CC_SCALARS/VELOCITY logicals.
IF (CODE == 0 .OR. CODE==2 .OR. CODE==5 .OR. CODE>6) RETURN

IF (.NOT.CC_MATVEC_DEFINED) RETURN

! First Allocate and setup persistent send-receives for scalars:
INITIALIZE_CC_SCALARS_FORC_COND : IF (INITIALIZE_CC_SCALARS_FORC) THEN

   ! Allocate REQ11, for scalar transport quantities, reduced cycling conditionals:
   N_REQ11=0
   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      DO NOM=1,NMESHES
         M3=>MESHES(NM)%OMESH(NOM)
         IF (M3%NICC_S(1)==0 .AND. M3%NICC_R(1)==0) CYCLE
         N_REQ11 = N_REQ11+1
      ENDDO
   ENDDO
   ALLOCATE(REQ11(N_REQ11*4)); N_REQ11=0

   ! Allocate REQ12, for IBM forcing (face) quantities:
   N_REQ12=0
   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      DO NOM=1,NMESHES
         M3=>MESHES(NM)%OMESH(NOM)
         IF (M3%NFCC_S(1)==0 .AND. M3%NFCC_R(1)==0) CYCLE
         N_REQ12 = N_REQ12+1
      ENDDO
   ENDDO
   ALLOCATE(REQ12(N_REQ12*4)); N_REQ12=0

   ! Allocate REQ13, for end of step H and RHO_0*W interpolation (cell) quantities:
   N_REQ13=0
   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      DO NOM=1,NMESHES
         M3=>MESHES(NM)%OMESH(NOM)
         IF (M3%NFCC_S(2)==0 .AND. M3%NFCC_R(2)==0) CYCLE
         N_REQ13 = N_REQ13+1
      ENDDO
   ENDDO
   ALLOCATE(REQ13(N_REQ13*4)); N_REQ13=0


   ! 1. Receives:
   MESH_LOOP_1: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

      IF (EVACUATION_ONLY(NM)) CYCLE MESH_LOOP_1
      RNODE = PROCESS(NM)

      ! REQ11:
      OTHER_MESH_LOOP_11: DO NOM=1,NMESHES
         M3=>MESHES(NM)%OMESH(NOM)
         IF (EVACUATION_ONLY(NOM)) CYCLE OTHER_MESH_LOOP_11
         SNODE = PROCESS(NOM)
         IF (M3%NICC_R(1)>0) THEN
            ! Cell centered variables on cut-cells:
            ALLOCATE(M3%REAL_RECV_PKG11(M3%NICC_R(2)*(4+N_TOTAL_SCALARS)))
            IF (RNODE/=SNODE) THEN
               N_REQ11 = N_REQ11 + 1
               CALL MPI_RECV_INIT(M3%REAL_RECV_PKG11(1),SIZE(M3%REAL_RECV_PKG11),MPI_DOUBLE_PRECISION, &
                                  SNODE,NOM,MPI_COMM_WORLD,REQ11(N_REQ11),IERR)
            ENDIF
         ENDIF
      ENDDO OTHER_MESH_LOOP_11

      ! REQ12:
      OTHER_MESH_LOOP_12: DO NOM=1,NMESHES
         IF (EVACUATION_ONLY(NOM)) CYCLE OTHER_MESH_LOOP_12
         M3=>MESHES(NM)%OMESH(NOM)
         IF (M3%NFCC_R(1)==0) CYCLE OTHER_MESH_LOOP_12
         SNODE = PROCESS(NOM)
         ! Face centered variables Ux1, Fvx1, dHdx1:
         ALLOCATE(M3%REAL_RECV_PKG12(M3%NFCC_R(1)*3))
         IF (RNODE/=SNODE) THEN
            N_REQ12 = N_REQ12 + 1
            CALL MPI_RECV_INIT(M3%REAL_RECV_PKG12(1),SIZE(M3%REAL_RECV_PKG12),MPI_DOUBLE_PRECISION, &
                               SNODE,NOM,MPI_COMM_WORLD,REQ12(N_REQ12),IERR)
         ENDIF
      ENDDO OTHER_MESH_LOOP_12

      ! REQ13:
      OTHER_MESH_LOOP_13: DO NOM=1,NMESHES
         IF (EVACUATION_ONLY(NOM)) CYCLE OTHER_MESH_LOOP_13
         M3=>MESHES(NM)%OMESH(NOM)
         IF (M3%NFCC_R(2)==0) CYCLE OTHER_MESH_LOOP_13
         SNODE = PROCESS(NOM)
         ! Cell centered variables H, RHO_0, Wc:
         ALLOCATE(M3%REAL_RECV_PKG13(M3%NFCC_R(2)*3))
         IF (RNODE/=SNODE) THEN
            N_REQ13 = N_REQ13 + 1
            CALL MPI_RECV_INIT(M3%REAL_RECV_PKG13(1),SIZE(M3%REAL_RECV_PKG13),MPI_DOUBLE_PRECISION, &
                               SNODE,NOM,MPI_COMM_WORLD,REQ13(N_REQ13),IERR)
         ENDIF
      ENDDO OTHER_MESH_LOOP_13

   ENDDO MESH_LOOP_1

   ! 2. Sends:
   SENDING_MESH_LOOP_1: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

      IF (EVACUATION_ONLY(NM)) CYCLE SENDING_MESH_LOOP_1
      RNODE = PROCESS(NM)
      M =>MESHES(NM)

      ! REQ11:
      RECEIVING_MESH_LOOP_11: DO NOM=1,NMESHES
         IF (EVACUATION_ONLY(NOM)) CYCLE RECEIVING_MESH_LOOP_11
         M3=>MESHES(NM)%OMESH(NOM)
         SNODE = PROCESS(NOM)
         ! Initialize persistent send requests
         IF (M3%NICC_S(1)>0 .AND. RNODE/=SNODE) THEN
            ALLOCATE(M3%REAL_SEND_PKG11(M3%NICC_S(2)*(4+N_TOTAL_SCALARS)))
            N_REQ11 = N_REQ11 + 1
            CALL MPI_SEND_INIT(M3%REAL_SEND_PKG11(1),SIZE(M3%REAL_SEND_PKG11),MPI_DOUBLE_PRECISION, &
                               SNODE,NM,MPI_COMM_WORLD,REQ11(N_REQ11),IERR)
         ENDIF
      ENDDO RECEIVING_MESH_LOOP_11

      ! REQ12:
      RECEIVING_MESH_LOOP_12: DO NOM=1,NMESHES
         IF (EVACUATION_ONLY(NOM)) CYCLE RECEIVING_MESH_LOOP_12
         M3=>MESHES(NM)%OMESH(NOM)
         IF (M3%NFCC_S(1)==0)  CYCLE RECEIVING_MESH_LOOP_12
         SNODE = PROCESS(NOM)
         ! Initialize persistent send requests
         IF (M3%NFCC_S(1)>0 .AND. RNODE/=SNODE) THEN
            ALLOCATE(M3%REAL_SEND_PKG12(M3%NFCC_S(1)*3))
            N_REQ12 = N_REQ12 + 1
            CALL MPI_SEND_INIT(M3%REAL_SEND_PKG12(1),SIZE(M3%REAL_SEND_PKG12),MPI_DOUBLE_PRECISION, &
                               SNODE,NM,MPI_COMM_WORLD,REQ12(N_REQ12),IERR)
         ENDIF
      ENDDO RECEIVING_MESH_LOOP_12

      ! REQ13:
      RECEIVING_MESH_LOOP_13: DO NOM=1,NMESHES
         IF (EVACUATION_ONLY(NOM)) CYCLE RECEIVING_MESH_LOOP_13
         M3=>MESHES(NM)%OMESH(NOM)
         IF (M3%NFCC_S(2)==0)  CYCLE RECEIVING_MESH_LOOP_13
         SNODE = PROCESS(NOM)
         ! Initialize persistent send requests
         IF (M3%NFCC_S(2)>0 .AND. RNODE/=SNODE) THEN
            ALLOCATE(M3%REAL_SEND_PKG13(M3%NFCC_S(2)*3))
            N_REQ13 = N_REQ13 + 1
            CALL MPI_SEND_INIT(M3%REAL_SEND_PKG13(1),SIZE(M3%REAL_SEND_PKG13),MPI_DOUBLE_PRECISION, &
                               SNODE,NM,MPI_COMM_WORLD,REQ13(N_REQ13),IERR)
         ENDIF
      ENDDO RECEIVING_MESH_LOOP_13

   ENDDO SENDING_MESH_LOOP_1

   INITIALIZE_CC_SCALARS_FORC = .FALSE.

ENDIF INITIALIZE_CC_SCALARS_FORC_COND


! Exchange Scalars in cut-cells:
SENDING_MESH_LOOP_2: DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   IF (EVACUATION_ONLY(NM)) CYCLE SENDING_MESH_LOOP_2
   M =>MESHES(NM)
   RECEIVING_MESH_LOOP_2: DO NOM=1,NMESHES

      M3=>MESHES(NM)%OMESH(NOM)
      IF (EVACUATION_ONLY(NOM)) CYCLE RECEIVING_MESH_LOOP_2

      SNODE = PROCESS(NOM)
      RNODE = PROCESS(NM)

      ! Exchange of density and species mass fractions following the PREDICTOR update

      IF (CODE==1 .AND. M3%NICC_S(1)>0) THEN
         NQT2 = 4+N_TOTAL_SCALARS
         LL = 0
         IF (RNODE/=SNODE) THEN
            PACK_REAL_SEND_PKG11: DO ICC1=1,M3%NICC_S(1)
               ICC=M3%ICC_UNKZ_CC_S(ICC1)
               NCELL=M%CUT_CELL(ICC)%NCELL
               II1=M%CUT_CELL(ICC)%IJK(IAXIS)
               JJ1=M%CUT_CELL(ICC)%IJK(JAXIS)
               KK1=M%CUT_CELL(ICC)%IJK(KAXIS)
               DO JCC=1,NCELL
                  LL = LL + 1
                  M3%REAL_SEND_PKG11(NQT2*(LL-1)+1) = M%CUT_CELL(ICC)%RHOS(JCC)
                  M3%REAL_SEND_PKG11(NQT2*(LL-1)+2) = M%CUT_CELL(ICC)%TMP(JCC)
                  M3%REAL_SEND_PKG11(NQT2*(LL-1)+3) = M%CUT_CELL(ICC)%RSUM(JCC)
                  !M3%REAL_SEND_PKG11(NQT2*(LL-1)+2) =   M%MU(II1,JJ1,KK1) !Take the underlying Cartesian cell value for
                  !M3%REAL_SEND_PKG11(NQT2*(LL-1)+3) = M%KRES(II1,JJ1,KK1) !these for now.
                  M3%REAL_SEND_PKG11(NQT2*(LL-1)+4) =    M%CUT_CELL(ICC)%D(JCC)
                  DO NN=1,N_TOTAL_SCALARS
                     M3%REAL_SEND_PKG11(NQT2*(LL-1)+4+NN) = M%CUT_CELL(ICC)%ZZS(NN,JCC)
                  ENDDO
               ENDDO
            ENDDO PACK_REAL_SEND_PKG11
         ELSE ! Same sender as receiver:
            ! Fill REAL_RECV_PKG11 of NOM mesh directly:
            M2=>MESHES(NOM)%OMESH(NM)
            PACK_REAL_RECV_PKG11: DO ICC1=1,M3%NICC_S(1)
               ICC=M3%ICC_UNKZ_CC_S(ICC1)
               NCELL=M%CUT_CELL(ICC)%NCELL
               II1=M%CUT_CELL(ICC)%IJK(IAXIS)
               JJ1=M%CUT_CELL(ICC)%IJK(JAXIS)
               KK1=M%CUT_CELL(ICC)%IJK(KAXIS)
               DO JCC=1,NCELL
                  LL = LL + 1
                  M2%REAL_RECV_PKG11(NQT2*(LL-1)+1) = M%CUT_CELL(ICC)%RHOS(JCC)
                  M2%REAL_RECV_PKG11(NQT2*(LL-1)+2) = M%CUT_CELL(ICC)%TMP(JCC)
                  M2%REAL_RECV_PKG11(NQT2*(LL-1)+3) = M%CUT_CELL(ICC)%RSUM(JCC)
                  !M2%REAL_RECV_PKG11(NQT2*(LL-1)+2) =   M%MU(II1,JJ1,KK1) !Take the underlying Cartesian cell value for
                  !M2%REAL_RECV_PKG11(NQT2*(LL-1)+3) = M%KRES(II1,JJ1,KK1) !these for now.
                  M2%REAL_RECV_PKG11(NQT2*(LL-1)+4) =    M%CUT_CELL(ICC)%D(JCC)
                  DO NN=1,N_TOTAL_SCALARS
                     M2%REAL_RECV_PKG11(NQT2*(LL-1)+4+NN) = M%CUT_CELL(ICC)%ZZS(NN,JCC)
                  ENDDO
               ENDDO
            ENDDO PACK_REAL_RECV_PKG11
         ENDIF
      ENDIF

      ! Exchange velocity, momentum rhs and previous substep dH/Dx1 for faces, in PREDICTOR, IBM forcing:

      IF (CODE==1 .AND. M3%NFCC_S(1)>0) THEN
         NQT2 = 3
         LL = 0
         IF (RNODE/=SNODE) THEN
            PACK_REAL_SEND_PKG12 : DO IFC=1,M3%NFCC_S(1)
               I     = M3%IIO_FC_S(IFC)
               J     = M3%JJO_FC_S(IFC)
               K     = M3%KKO_FC_S(IFC)
               X1AXIS= M3%AXS_FC_S(IFC)
               LL = LL + 1
               SELECT CASE(X1AXIS)
               CASE(IAXIS)
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+1) = M%U(I,J,K)                            ! U^n in x face I,J,K
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+2) = M%FVX(I,J,K)                          ! FVX in x face I,J,K
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+3) = (M%HS(I+1,J,K)-M%HS(I,J,K))*M%RDXN(I) ! dH/dx^n-1/2 in I,J,K.
               CASE(JAXIS)
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+1) = M%V(I,J,K)                            ! V^n in y face I,J,K
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+2) = M%FVY(I,J,K)                          ! FVY in y face I,J,K
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+3) = (M%HS(I,J+1,K)-M%HS(I,J,K))*M%RDYN(J) ! dH/dy^n-1/2 in I,J,K.
               CASE(KAXIS)
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+1) = M%W(I,J,K)                            ! W^n in z face I,J,K
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+2) = M%FVZ(I,J,K)                          ! FVZ in z face I,J,K
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+3) = (M%HS(I,J,K+1)-M%HS(I,J,K))*M%RDZN(K) ! dH/dz^n-1/2 in I,J,K.
               END SELECT
            ENDDO PACK_REAL_SEND_PKG12
         ELSE
            ! Fill REAL_RECV_PKG12 of NOM mesh directly:
            M2=>MESHES(NOM)%OMESH(NM)
            PACK_REAL_RECV_PKG12: DO IFC=1,M3%NFCC_S(1)
               I     = M3%IIO_FC_S(IFC)
               J     = M3%JJO_FC_S(IFC)
               K     = M3%KKO_FC_S(IFC)
               X1AXIS= M3%AXS_FC_S(IFC)
               LL = LL + 1
               SELECT CASE(X1AXIS)
               CASE(IAXIS)
                  M2%REAL_RECV_PKG12(NQT2*(LL-1)+1) = M%U(I,J,K)                            ! U^n in x face I,J,K
                  M2%REAL_RECV_PKG12(NQT2*(LL-1)+2) = M%FVX(I,J,K)                          ! FVX in x face I,J,K
                  M2%REAL_RECV_PKG12(NQT2*(LL-1)+3) = (M%HS(I+1,J,K)-M%HS(I,J,K))*M%RDXN(I) ! dH/dx^n-1/2 in I,J,K.
               CASE(JAXIS)
                  M2%REAL_RECV_PKG12(NQT2*(LL-1)+1) = M%V(I,J,K)                            ! V^n in y face I,J,K
                  M2%REAL_RECV_PKG12(NQT2*(LL-1)+2) = M%FVY(I,J,K)                          ! FVY in y face I,J,K
                  M2%REAL_RECV_PKG12(NQT2*(LL-1)+3) = (M%HS(I,J+1,K)-M%HS(I,J,K))*M%RDYN(J) ! dH/dy^n-1/2 in I,J,K.
               CASE(KAXIS)
                  M2%REAL_RECV_PKG12(NQT2*(LL-1)+1) = M%W(I,J,K)                            ! W^n in z face I,J,K
                  M2%REAL_RECV_PKG12(NQT2*(LL-1)+2) = M%FVZ(I,J,K)                          ! FVZ in z face I,J,K
                  M2%REAL_RECV_PKG12(NQT2*(LL-1)+3) = (M%HS(I,J,K+1)-M%HS(I,J,K))*M%RDZN(K) ! dH/dz^n-1/2 in I,J,K.
               END SELECT
            ENDDO PACK_REAL_RECV_PKG12
         ENDIF
      ENDIF

      ! Exchange of density and species mass fractions following the CORRECTOR update

      IF (CODE==4 .AND. M3%NICC_S(1)>0) THEN
         NQT2 = 4+N_TOTAL_SCALARS
         LL = 0
         IF (RNODE/=SNODE) THEN
            PACK_REAL_SEND_PKG111: DO ICC1=1,M3%NICC_S(1)
               ICC=M3%ICC_UNKZ_CC_S(ICC1)
               NCELL=M%CUT_CELL(ICC)%NCELL
               II1=M%CUT_CELL(ICC)%IJK(IAXIS)
               JJ1=M%CUT_CELL(ICC)%IJK(JAXIS)
               KK1=M%CUT_CELL(ICC)%IJK(KAXIS)
               DO JCC=1,NCELL
                  LL = LL + 1
                  M3%REAL_SEND_PKG11(NQT2*(LL-1)+1) = M%CUT_CELL(ICC)%RHO(JCC)
                  M3%REAL_SEND_PKG11(NQT2*(LL-1)+2) = M%CUT_CELL(ICC)%TMP(JCC)
                  M3%REAL_SEND_PKG11(NQT2*(LL-1)+3) = M%CUT_CELL(ICC)%RSUM(JCC)
                  !M3%REAL_SEND_PKG11(NQT2*(LL-1)+2) =   M%MU(II1,JJ1,KK1) !Take the underlying Cartesian cell value for
                  !M3%REAL_SEND_PKG11(NQT2*(LL-1)+3) = M%KRES(II1,JJ1,KK1) !these for now.
                  M3%REAL_SEND_PKG11(NQT2*(LL-1)+4) =    M%CUT_CELL(ICC)%DS(JCC)
                  DO NN=1,N_TOTAL_SCALARS
                     M3%REAL_SEND_PKG11(NQT2*(LL-1)+4+NN) = M%CUT_CELL(ICC)%ZZ(NN,JCC)
                  ENDDO
               ENDDO
            ENDDO PACK_REAL_SEND_PKG111
         ELSE ! Same sender as receiver:
            ! Fill REAL_RECV_PKG11 of NOM mesh directly:
            M2=>MESHES(NOM)%OMESH(NM)
            PACK_REAL_RECV_PKG111: DO ICC1=1,M3%NICC_S(1)
               ICC=M3%ICC_UNKZ_CC_S(ICC1)
               NCELL=M%CUT_CELL(ICC)%NCELL
               II1=M%CUT_CELL(ICC)%IJK(IAXIS)
               JJ1=M%CUT_CELL(ICC)%IJK(JAXIS)
               KK1=M%CUT_CELL(ICC)%IJK(KAXIS)
               DO JCC=1,NCELL
                  LL = LL + 1
                  M2%REAL_RECV_PKG11(NQT2*(LL-1)+1) = M%CUT_CELL(ICC)%RHO(JCC)
                  M2%REAL_RECV_PKG11(NQT2*(LL-1)+2) = M%CUT_CELL(ICC)%TMP(JCC)
                  M2%REAL_RECV_PKG11(NQT2*(LL-1)+3) = M%CUT_CELL(ICC)%RSUM(JCC)
                  !M2%REAL_RECV_PKG11(NQT2*(LL-1)+2) =   M%MU(II1,JJ1,KK1) !Take the underlying Cartesian cell value for
                  !M2%REAL_RECV_PKG11(NQT2*(LL-1)+3) = M%KRES(II1,JJ1,KK1) !these for now.
                  M2%REAL_RECV_PKG11(NQT2*(LL-1)+4) =    M%CUT_CELL(ICC)%DS(JCC)
                  DO NN=1,N_TOTAL_SCALARS
                     M2%REAL_RECV_PKG11(NQT2*(LL-1)+4+NN) = M%CUT_CELL(ICC)%ZZ(NN,JCC)
                  ENDDO
               ENDDO
            ENDDO PACK_REAL_RECV_PKG111
         ENDIF
      ENDIF

      ! Exchange velocity, momentum rhs and previous substep dH/Dx1 for faces, in CORRECTOR, IBM forcing:

      IF (CODE==4 .AND. M3%NFCC_S(1)>0) THEN
         NQT2 = 3
         LL = 0
         IF (RNODE/=SNODE) THEN
            PACK_REAL_SEND_PKG112 : DO IFC=1,M3%NFCC_S(1)
               I     = M3%IIO_FC_S(IFC)
               J     = M3%JJO_FC_S(IFC)
               K     = M3%KKO_FC_S(IFC)
               X1AXIS= M3%AXS_FC_S(IFC)
               LL = LL + 1
               SELECT CASE(X1AXIS)
               CASE(IAXIS)
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+1) = M%US(I,J,K)                           ! U^* in x face I,J,K
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+2) = M%FVX(I,J,K)                          ! FVX in x face I,J,K
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+3) = (M%H(I+1,J,K)-M%H(I,J,K))*M%RDXN(I)   ! dH/dx^n in I,J,K.
               CASE(JAXIS)
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+1) = M%VS(I,J,K)                           ! V^n in y face I,J,K
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+2) = M%FVY(I,J,K)                          ! FVY in y face I,J,K
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+3) = (M%H(I,J+1,K)-M%H(I,J,K))*M%RDYN(J)   ! dH/dy^n-1/2 in I,J,K.
               CASE(KAXIS)
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+1) = M%WS(I,J,K)                           ! W^n in z face I,J,K
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+2) = M%FVZ(I,J,K)                          ! FVZ in z face I,J,K
                  M3%REAL_SEND_PKG12(NQT2*(LL-1)+3) = (M%H(I,J,K+1)-M%H(I,J,K))*M%RDZN(K)   ! dH/dz^n-1/2 in I,J,K.
               END SELECT
            ENDDO PACK_REAL_SEND_PKG112
         ELSE
            ! Fill REAL_RECV_PKG12 of NOM mesh directly:
            M2=>MESHES(NOM)%OMESH(NM)
            PACK_REAL_RECV_PKG112: DO IFC=1,M3%NFCC_S(1)
               I     = M3%IIO_FC_S(IFC)
               J     = M3%JJO_FC_S(IFC)
               K     = M3%KKO_FC_S(IFC)
               X1AXIS= M3%AXS_FC_S(IFC)
               LL = LL + 1
               SELECT CASE(X1AXIS)
               CASE(IAXIS)
                  M2%REAL_RECV_PKG12(NQT2*(LL-1)+1) = M%US(I,J,K)                           ! U^n in x face I,J,K
                  M2%REAL_RECV_PKG12(NQT2*(LL-1)+2) = M%FVX(I,J,K)                          ! FVX in x face I,J,K
                  M2%REAL_RECV_PKG12(NQT2*(LL-1)+3) = (M%H(I+1,J,K)-M%H(I,J,K))*M%RDXN(I)   ! dH/dx^n-1/2 in I,J,K.
               CASE(JAXIS)
                  M2%REAL_RECV_PKG12(NQT2*(LL-1)+1) = M%VS(I,J,K)                           ! V^n in y face I,J,K
                  M2%REAL_RECV_PKG12(NQT2*(LL-1)+2) = M%FVY(I,J,K)                          ! FVY in y face I,J,K
                  M2%REAL_RECV_PKG12(NQT2*(LL-1)+3) = (M%H(I,J+1,K)-M%H(I,J,K))*M%RDYN(J)   ! dH/dy^n-1/2 in I,J,K.
               CASE(KAXIS)
                  M2%REAL_RECV_PKG12(NQT2*(LL-1)+1) = M%WS(I,J,K)                           ! W^n in z face I,J,K
                  M2%REAL_RECV_PKG12(NQT2*(LL-1)+2) = M%FVZ(I,J,K)                          ! FVZ in z face I,J,K
                  M2%REAL_RECV_PKG12(NQT2*(LL-1)+3) = (M%H(I,J,K+1)-M%H(I,J,K))*M%RDZN(K)   ! dH/dz^n-1/2 in I,J,K.
               END SELECT
            ENDDO PACK_REAL_RECV_PKG112
         ENDIF
      ENDIF

      ! Exchange H, RHO_0 and W velocity averaged to cell center, at PREDICTOR end of step:

      IF (CODE==3 .AND. M3%NFCC_S(2)>0) THEN
         NQT2 = 3
         LL = 0
         IF (RNODE/=SNODE) THEN
            PACK_REAL_SEND_PKG13 : DO ICC=1,M3%NFCC_S(2)
               I     = M3%IIO_CC_S(ICC)
               J     = M3%JJO_CC_S(ICC)
               K     = M3%KKO_CC_S(ICC)
               LL = LL + 1
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+1) = M%H(I,J,K)                             ! H^n in cell I,J,K
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+2) = M%RHO_0(K)                             ! RHO_0 in cell I,J,K
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+3) = 0.5_EB*(M%WS(I,J,K-1)+M%WS(I,J,K))     ! Wcen^* in I,J,K.
            ENDDO PACK_REAL_SEND_PKG13
         ELSE
            ! Fill REAL_RECV_PKG13 of NOM mesh directly:
            M2=>MESHES(NOM)%OMESH(NM)
            PACK_REAL_RECV_PKG13: DO ICC=1,M3%NFCC_S(2)
               I     = M3%IIO_CC_S(ICC)
               J     = M3%JJO_CC_S(ICC)
               K     = M3%KKO_CC_S(ICC)
               LL = LL + 1
               M2%REAL_RECV_PKG13(NQT2*(LL-1)+1) = M%H(I,J,K)                             ! H^n in cell I,J,K
               M2%REAL_RECV_PKG13(NQT2*(LL-1)+2) = M%RHO_0(K)                             ! RHO_0 in cell I,J,K
               M2%REAL_RECV_PKG13(NQT2*(LL-1)+3) = 0.5_EB*(M%WS(I,J,K-1)+M%WS(I,J,K))     ! Wcen^* in I,J,K.
            ENDDO PACK_REAL_RECV_PKG13
         ENDIF
      ENDIF

      ! Exchange H, RHO_0 and W velocity averaged to cell center, at CORRECTOR end of step:

      IF (CODE==6 .AND. M3%NFCC_S(2)>0) THEN
         NQT2 = 3
         LL = 0
         IF (RNODE/=SNODE) THEN
            PACK_REAL_SEND_PKG113 : DO ICC=1,M3%NFCC_S(2)
               I     = M3%IIO_CC_S(ICC)
               J     = M3%JJO_CC_S(ICC)
               K     = M3%KKO_CC_S(ICC)
               LL = LL + 1
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+1) = M%HS(I,J,K)                            ! H^* in cell I,J,K
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+2) = M%RHO_0(K)                             ! RHO_0 in cell I,J,K
               M3%REAL_SEND_PKG13(NQT2*(LL-1)+3) = 0.5_EB*(M%W(I,J,K-1)+M%W(I,J,K))       ! Wcen  in I,J,K.
            ENDDO PACK_REAL_SEND_PKG113
         ELSE
            ! Fill REAL_RECV_PKG13 of NOM mesh directly:
            M2=>MESHES(NOM)%OMESH(NM)
            PACK_REAL_RECV_PKG113: DO ICC=1,M3%NFCC_S(2)
               I     = M3%IIO_CC_S(ICC)
               J     = M3%JJO_CC_S(ICC)
               K     = M3%KKO_CC_S(ICC)
               LL = LL + 1
               M2%REAL_RECV_PKG13(NQT2*(LL-1)+1) = M%HS(I,J,K)                            ! H^* in cell I,J,K
               M2%REAL_RECV_PKG13(NQT2*(LL-1)+2) = M%RHO_0(K)                             ! RHO_0 in cell I,J,K
               M2%REAL_RECV_PKG13(NQT2*(LL-1)+3) = 0.5_EB*(M%W(I,J,K-1)+M%W(I,J,K))       ! Wcen  in I,J,K.
            ENDDO PACK_REAL_RECV_PKG113
         ENDIF
      ENDIF

   ENDDO RECEIVING_MESH_LOOP_2
ENDDO SENDING_MESH_LOOP_2

! Exchange Scalars:
IF (N_MPI_PROCESSES>1 .AND. (CODE==1.OR.CODE==4) .AND. N_REQ11>0) THEN
   CALL MPI_STARTALL(N_REQ11,REQ11(1:N_REQ11),IERR)
   CALL CC_TIMEOUT('REQ11',N_REQ11,REQ11(1:N_REQ11))
ENDIF

! Exchange IBM forcing data:
IF (N_MPI_PROCESSES>1 .AND. (CODE==1.OR.CODE==4) .AND. N_REQ12>0) THEN
   CALL MPI_STARTALL(N_REQ12,REQ12(1:N_REQ12),IERR)
   CALL CC_TIMEOUT('REQ12',N_REQ12,REQ12(1:N_REQ12))
ENDIF

! Exchange End of step cell-centered data:
IF (N_MPI_PROCESSES>1 .AND. (CODE==3.OR.CODE==6) .AND. N_REQ13>0) THEN
   CALL MPI_STARTALL(N_REQ13,REQ13(1:N_REQ13),IERR)
   CALL CC_TIMEOUT('REQ13',N_REQ13,REQ13(1:N_REQ13))
ENDIF

! Receive the information sent above into the appropriate arrays.

RECV_MESH_LOOP: DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   IF (EVACUATION_ONLY(NOM)) CYCLE RECV_MESH_LOOP
   M =>MESHES(NOM)

   SEND_MESH_LOOP: DO NM=1,NMESHES

      M2=>MESHES(NOM)%OMESH(NM)
      IF (EVACUATION_ONLY(NM)) CYCLE SEND_MESH_LOOP

      ! Unpack densities and species mass fractions following PREDICTOR exchange

      IF (CODE==1 .AND. M2%NICC_R(1)>0) THEN

         NQT2 = 4+N_TOTAL_SCALARS
         LL = 0
         DO ICC=M%N_CUTCELL_MESH+1,M%N_CUTCELL_MESH+M%N_GCCUTCELL_MESH
            NOOM   = M%CUT_CELL(ICC)%NOMICC(1); IF (NOOM /= NM) CYCLE
            DO JCC=1,M%CUT_CELL(ICC)%NCELL
               LL = LL + 1
               M%CUT_CELL(ICC)%RHOS(JCC) = M2%REAL_RECV_PKG11(NQT2*(LL-1)+1)
               M%CUT_CELL(ICC)%TMP(JCC)  = M2%REAL_RECV_PKG11(NQT2*(LL-1)+2)
               M%CUT_CELL(ICC)%RSUM(JCC) = M2%REAL_RECV_PKG11(NQT2*(LL-1)+3)
               !M%MU(II1,JJ1,KK1) = M2%REAL_RECV_PKG11(NQT2*(LL-1)+2)   ! Take the underlying Cartesian cell value for
               !M%KRES(II1,JJ1,KK1) = M2%REAL_RECV_PKG11(NQT2*(LL-1)+3) ! these for now.
               M%CUT_CELL(ICC)%D(JCC)    = M2%REAL_RECV_PKG11(NQT2*(LL-1)+4)
               DO NN=1,N_TOTAL_SCALARS
                  M%CUT_CELL(ICC)%ZZS(NN,JCC) = M2%REAL_RECV_PKG11(NQT2*(LL-1)+4+NN)
               ENDDO
            ENDDO
         ENDDO

      ENDIF

      ! Unpack velocity, momentum rhs and previous substep dH/Dx1 for faces, in PREDICTOR, IBM forcing:

      IF (CODE==1 .AND. M2%NFCC_R(1)>0) THEN
         NQT2 = 3
         ! First loop cut-faces:
         DO ICF=1,M%N_CUTFACE_MESH
            IF (M%CUT_FACE(ICF)%STATUS /= IBM_GASPHASE) CYCLE
            ! First Cartesian center:
            DO IPT=1,MAX_INTERP_POINTS_PLANE
               NOOM   = M%CUT_FACE(ICF)%NOMIND_CARTCEN( LOW_IND,IPT); IF (NOOM /= NM) CYCLE
               LL     = M%CUT_FACE(ICF)%NOMIND_CARTCEN(HIGH_IND,IPT)
               M%CUT_FACE(ICF)%VEL_CARTCEN(   IPT+1) = M2%REAL_RECV_PKG12(NQT2*(LL-1)+1) ! Vel^n
               M%CUT_FACE(ICF)%FV_CARTCEN(    IPT+1) = M2%REAL_RECV_PKG12(NQT2*(LL-1)+2) ! Predictor FV
               M%CUT_FACE(ICF)%DHDX1_CARTCEN( IPT+1) = M2%REAL_RECV_PKG12(NQT2*(LL-1)+3) ! Predictor dH/dx1^n-1/2
            ENDDO
            ! Then cut-faces centers:
            DO IFACE=1,M%CUT_FACE(ICF)%NFACE
               DO IPT=1,MAX_INTERP_POINTS_PLANE
                  NOOM   = M%CUT_FACE(ICF)%NOMIND_CFCEN( LOW_IND,IPT,IFACE); IF (NOOM /= NM) CYCLE
                  LL     = M%CUT_FACE(ICF)%NOMIND_CFCEN(HIGH_IND,IPT,IFACE)
                  M%CUT_FACE(ICF)%VEL_CFCEN(   IPT+1,IFACE) = M2%REAL_RECV_PKG12(NQT2*(LL-1)+1) ! Vel^n
                  M%CUT_FACE(ICF)%FV_CFCEN(    IPT+1,IFACE) = M2%REAL_RECV_PKG12(NQT2*(LL-1)+2) ! Predictor FV
                  M%CUT_FACE(ICF)%DHDX1_CFCEN( IPT+1,IFACE) = M2%REAL_RECV_PKG12(NQT2*(LL-1)+3) ! Pred dH/dx1^n-1/2
               ENDDO
            ENDDO
         ENDDO
         ! Then regular forced faces:
         DO ICF=1,M%IBM_NRCFACE_VEL
            DO IPT=1,MAX_INTERP_POINTS_PLANE
               NOOM   = M%IBM_RCFACE_VEL(ICF)%NOMIND_CARTCEN( LOW_IND,IPT); IF (NOOM /= NM) CYCLE
               LL     = M%IBM_RCFACE_VEL(ICF)%NOMIND_CARTCEN(HIGH_IND,IPT)
               M%IBM_RCFACE_VEL(ICF)%VEL_CARTCEN(   IPT+1) = M2%REAL_RECV_PKG12(NQT2*(LL-1)+1) ! Vel^n
               M%IBM_RCFACE_VEL(ICF)%FV_CARTCEN(    IPT+1) = M2%REAL_RECV_PKG12(NQT2*(LL-1)+2) ! Predictor FV
               M%IBM_RCFACE_VEL(ICF)%DHDX1_CARTCEN( IPT+1) = M2%REAL_RECV_PKG12(NQT2*(LL-1)+3) ! Predictor dH/dx1^n-1/2
            ENDDO
         ENDDO
      ENDIF

      ! Unpack densities and species mass fractions following CORRECTOR exchange

      IF (CODE==4 .AND. M2%NICC_R(1)>0) THEN

         NQT2 = 4+N_TOTAL_SCALARS
         LL = 0
         DO ICC=M%N_CUTCELL_MESH+1,M%N_CUTCELL_MESH+M%N_GCCUTCELL_MESH
            NOOM   = M%CUT_CELL(ICC)%NOMICC(1); IF (NOOM /= NM) CYCLE
            DO JCC=1,M%CUT_CELL(ICC)%NCELL
               LL = LL + 1
               M%CUT_CELL(ICC)%RHO(JCC)  = M2%REAL_RECV_PKG11(NQT2*(LL-1)+1)
               M%CUT_CELL(ICC)%TMP(JCC)  = M2%REAL_RECV_PKG11(NQT2*(LL-1)+2)
               M%CUT_CELL(ICC)%RSUM(JCC) = M2%REAL_RECV_PKG11(NQT2*(LL-1)+3)
               !M%MU(II1,JJ1,KK1) = M2%REAL_RECV_PKG11(NQT2*(LL-1)+2)   ! Take the underlying Cartesian cell value for
               !M%KRES(II1,JJ1,KK1) = M2%REAL_RECV_PKG11(NQT2*(LL-1)+3) ! these for now.
               M%CUT_CELL(ICC)%DS(JCC)   = M2%REAL_RECV_PKG11(NQT2*(LL-1)+4)
               DO NN=1,N_TOTAL_SCALARS
                  M%CUT_CELL(ICC)%ZZ(NN,JCC) = M2%REAL_RECV_PKG11(NQT2*(LL-1)+4+NN)
               ENDDO
            ENDDO
         ENDDO

      ENDIF

      ! Unpack velocity, momentum rhs and previous substep dH/Dx1 for faces, in CORRECTOR, IBM forcing:

      IF (CODE==4 .AND. M2%NFCC_R(1)>0) THEN
         NQT2 = 3
         ! First loop cut-faces:
         DO ICF=1,M%N_CUTFACE_MESH
            IF (M%CUT_FACE(ICF)%STATUS /= IBM_GASPHASE) CYCLE
            ! First Cartesian center:
            DO IPT=1,MAX_INTERP_POINTS_PLANE
               NOOM   = M%CUT_FACE(ICF)%NOMIND_CARTCEN( LOW_IND,IPT); IF (NOOM /= NM) CYCLE
               LL     = M%CUT_FACE(ICF)%NOMIND_CARTCEN(HIGH_IND,IPT)
               M%CUT_FACE(ICF)%VELS_CARTCEN(  IPT+1) = M2%REAL_RECV_PKG12(NQT2*(LL-1)+1) ! Vel^*
               M%CUT_FACE(ICF)%FV_CARTCEN(    IPT+1) = M2%REAL_RECV_PKG12(NQT2*(LL-1)+2) ! Corrector FV
               M%CUT_FACE(ICF)%DHDX1_CARTCEN( IPT+1) = M2%REAL_RECV_PKG12(NQT2*(LL-1)+3) ! Corrector dH/dx1^n-1/2
            ENDDO
            ! Then cut-faces centers:
            DO IFACE=1,M%CUT_FACE(ICF)%NFACE
               DO IPT=1,MAX_INTERP_POINTS_PLANE
                  NOOM   = M%CUT_FACE(ICF)%NOMIND_CFCEN( LOW_IND,IPT,IFACE); IF (NOOM /= NM) CYCLE
                  LL     = M%CUT_FACE(ICF)%NOMIND_CFCEN(HIGH_IND,IPT,IFACE)
                  M%CUT_FACE(ICF)%VELS_CFCEN(  IPT+1,IFACE) = M2%REAL_RECV_PKG12(NQT2*(LL-1)+1) ! Vel^*
                  M%CUT_FACE(ICF)%FV_CFCEN(    IPT+1,IFACE) = M2%REAL_RECV_PKG12(NQT2*(LL-1)+2) ! Corrector FV
                  M%CUT_FACE(ICF)%DHDX1_CFCEN( IPT+1,IFACE) = M2%REAL_RECV_PKG12(NQT2*(LL-1)+3) ! Corr dH/dx1^n-1/2
               ENDDO
            ENDDO
         ENDDO
         ! Then regular forced faces:
         DO ICF=1,M%IBM_NRCFACE_VEL
            DO IPT=1,MAX_INTERP_POINTS_PLANE
               NOOM   = M%IBM_RCFACE_VEL(ICF)%NOMIND_CARTCEN( LOW_IND,IPT); IF (NOOM /= NM) CYCLE
               LL     = M%IBM_RCFACE_VEL(ICF)%NOMIND_CARTCEN(HIGH_IND,IPT)
               M%IBM_RCFACE_VEL(ICF)%VELS_CARTCEN(  IPT+1) = M2%REAL_RECV_PKG12(NQT2*(LL-1)+1) ! Vel^*
               M%IBM_RCFACE_VEL(ICF)%FV_CARTCEN(    IPT+1) = M2%REAL_RECV_PKG12(NQT2*(LL-1)+2) ! Corrector FV
               M%IBM_RCFACE_VEL(ICF)%DHDX1_CARTCEN( IPT+1) = M2%REAL_RECV_PKG12(NQT2*(LL-1)+3) ! Corrector dH/dx1^n-1/2
            ENDDO
         ENDDO
      ENDIF

     ! Unpack H, RHO_0 and W velocity averaged to cell center, at PREDICTOR or CORRECTOR end of step:

     IF ( (CODE==3 .OR. CODE==6) .AND. M2%NFCC_R(2)>0) THEN
        NQT2 = 3
        IF(CALL_FROM_HINTERP)THEN
           IF(M2%NCC_INT_R==M2%NFCC_R(2)) CYCLE
           LL = M2%NCC_INT_R
           ! Now loop INTERPOLATED WALL_CELLs:
           EXT_WALL_LOOP : DO IW=1,M%N_EXTERNAL_WALL_CELLS
              WC=>M%WALL(IW)
              EWC=>M%EXTERNAL_WALL(IW)
              IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE EXT_WALL_LOOP
              II  = WC%ONE_D%II
              JJ  = WC%ONE_D%JJ
              KK  = WC%ONE_D%KK
              NOOM = EWC%NOM
              IF (NOOM /= NM) CYCLE EXT_WALL_LOOP
              IF(.NOT.ANY(M%CCVAR(II-1:II+1,JJ-1:JJ+1,KK-1:KK+1,IBM_CGSC)==IBM_CUTCFE)) CYCLE EXT_WALL_LOOP
              LL=LL+1
              IF (CODE==3)THEN ! END of PREDICTOR
                 M%H(II,JJ,KK) = M2%REAL_RECV_PKG13(NQT2*(LL-1)+1)
              ELSE ! END of CORRECTOR
                 M%HS(II,JJ,KK)= M2%REAL_RECV_PKG13(NQT2*(LL-1)+1)
              ENDIF
           ENDDO EXT_WALL_LOOP

        ELSE
           ! First loop cut-cells:
           DO ICC=1,M%N_CUTCELL_MESH
              ! First Cartesian center:
              DO IPT=1,MAX_INTERP_POINTS_PLANE
                 NOOM   = M%CUT_CELL(ICC)%NOMIND_CARTCEN( LOW_IND,IPT); IF (NOOM /= NM) CYCLE
                 LL     = M%CUT_CELL(ICC)%NOMIND_CARTCEN(HIGH_IND,IPT)
                 M%CUT_CELL(ICC)%H_CARTCEN(     IPT+1) = M2%REAL_RECV_PKG13(NQT2*(LL-1)+1) ! H^n, or H^s
                 M%CUT_CELL(ICC)%RHO_0_CARTCEN( IPT+1) = M2%REAL_RECV_PKG13(NQT2*(LL-1)+2) ! RHO_0
                 M%CUT_CELL(ICC)%W_CARTCEN(     IPT+1) = M2%REAL_RECV_PKG13(NQT2*(LL-1)+3) ! Wcen^*, or Wcen^n+1
              ENDDO
              ! Then cut-cells:
              DO JCC=1,M%CUT_CELL(ICC)%NCELL
                 DO IPT=1,MAX_INTERP_POINTS_PLANE
                    NOOM   = M%CUT_CELL(ICC)%NOMIND_CCCEN( LOW_IND,IPT,JCC); IF (NOOM /= NM) CYCLE
                    LL     = M%CUT_CELL(ICC)%NOMIND_CCCEN(HIGH_IND,IPT,JCC)
                    M%CUT_CELL(ICC)%H_CCCEN(     IPT+1,JCC) = M2%REAL_RECV_PKG13(NQT2*(LL-1)+1) ! H^n, or H^s
                    M%CUT_CELL(ICC)%RHO_0_CCCEN( IPT+1,JCC) = M2%REAL_RECV_PKG13(NQT2*(LL-1)+2) ! RHO_0
                    M%CUT_CELL(ICC)%W_CCCEN(     IPT+1,JCC) = M2%REAL_RECV_PKG13(NQT2*(LL-1)+3) ! Wcen^*, or Wcen^n+1
                 ENDDO
              ENDDO
           ENDDO
           ! Then regular cells:
           DO ICC=1,M%IBM_NRCELL_H
              DO IPT=1,MAX_INTERP_POINTS_PLANE
                 NOOM   = M%IBM_RCELL_H(ICC)%NOMIND_CARTCEN( LOW_IND,IPT); IF (NOOM /= NM) CYCLE
                 LL     = M%IBM_RCELL_H(ICC)%NOMIND_CARTCEN(HIGH_IND,IPT)
                 M%IBM_RCELL_H(ICC)%H_CARTCEN(     IPT+1) = M2%REAL_RECV_PKG13(NQT2*(LL-1)+1) ! H^n, or H^s
                 M%IBM_RCELL_H(ICC)%RHO_0_CARTCEN( IPT+1) = M2%REAL_RECV_PKG13(NQT2*(LL-1)+2) ! RHO_0
                 M%IBM_RCELL_H(ICC)%W_CARTCEN(     IPT+1) = M2%REAL_RECV_PKG13(NQT2*(LL-1)+3) ! Wcen^*, or Wcen^n+1
              ENDDO
           ENDDO
        ENDIF
     ENDIF

   ENDDO SEND_MESH_LOOP
ENDDO RECV_MESH_LOOP


! DO NM=1,NMESHES
!    CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
!    IF(MYID/=PROCESS(NM))CYCLE
!    M => MESHES(NM)
!    WRITE(LU_ERR,*) 'Here=>',MESHES(NM)%OMESH(NM)%NFCC_R(1:2),MESHES(NM)%OMESH(NM)%NFCC_S(1:2), &
!                   SIZE(MESHES(NM)%OMESH(NM)%REAL_RECV_PKG12), &
!                   SIZE(MESHES(NM)%OMESH(NM)%REAL_RECV_PKG13)
!    DO ICC=1,M%N_CUTCELL_MESH
!       DO IPT=1,MAX_INTERP_POINTS_PLANE
!          !WRITE(LU_ERR,*) MYID,NM,ICC,IPT,M%CUT_CELL(ICC)%H_CARTCEN(     IPT+1)
!       ENDDO
!    ENDDO
! ENDDO

! WRITE(LU_ERR,*) MYID, CODE, 'Fill guard cut-cells done.'

! ! Test: Write out Values:
! IF (CODE==4) THEN
!    DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
!       CALL POINT_TO_MESH(NM)
!       DO ICC=MESHES(NM)%N_CUTCELL_MESH+1,MESHES(NM)%N_CUTCELL_MESH+MESHES(NM)%N_GCCUTCELL_MESH
!          NOM   = MESHES(NM)%CUT_CELL(ICC)%NOMICC(1)
!          IF(NOM==0) CYCLE
!          ICC1  = MESHES(NM)%CUT_CELL(ICC)%NOMICC(2)
!          DO JCC=1,MESHES(NM)%CUT_CELL(ICC)%NCELL
!             WRITE(LU_ERR,*) NM,ICC,NOM,ICC1,JCC,CUT_CELL(ICC)%RHO(JCC),MESHES(NOM)%CUT_CELL(ICC1)%RHO(JCC)
!          ENDDO
!       ENDDO
!    ENDDO
!    PAUSE
! ENDIF

RETURN

CONTAINS

SUBROUTINE CC_TIMEOUT(RNAME,NR,RR)

REAL(EB) :: START_TIME,WAIT_TIME
INTEGER :: NR
INTEGER, DIMENSION(:) :: RR
LOGICAL :: FLAG
CHARACTER(*) :: RNAME

IF (.NOT.PROFILING) THEN

   START_TIME = MPI_WTIME()
   FLAG = .FALSE.
   DO WHILE(.NOT.FLAG)
      CALL MPI_TESTALL(NR,RR(1:NR),FLAG,MPI_STATUSES_IGNORE,IERR)
      WAIT_TIME = MPI_WTIME() - START_TIME
      IF (WAIT_TIME>MPI_TIMEOUT) THEN
         WRITE(LU_ERR,'(A,A,A,I6,A,A)') 'CC_TIMEOUT Error: ',TRIM(RNAME),' timed out for MPI process ',MYID
         CALL MPI_ABORT(MPI_COMM_WORLD,0,IERR)
      ENDIF
   ENDDO
ELSE

   CALL MPI_WAITALL(NR,RR(1:NR),MPI_STATUSES_IGNORE,IERR)

ENDIF

END SUBROUTINE CC_TIMEOUT

END SUBROUTINE MESH_CC_EXCHANGE


! ----------------------------- CCCOMPUTE_RADIATION --------------------------------

SUBROUTINE CCCOMPUTE_RADIATION(T,NM,ITER)

! This is a temporary container where to add QR=-CHI_R*Q

INTEGER, INTENT(IN) :: NM,ITER
REAL(EB), INTENT(IN) :: T

! Local Variables:
INTEGER ICC, JCC
REAL(EB):: DUMMY1
INTEGER :: DUMMY2

DUMMY1=T
DUMMY2=ITER

IF(.NOT.RADIATION) THEN
   RADIATION_COMPLETED = .TRUE.
   IF (N_REACTIONS>0) THEN
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            CUT_CELL(ICC)%QR(JCC) = -CUT_CELL(ICC)%CHI_R(JCC)*CUT_CELL(ICC)%Q(JCC)
         ENDDO
      ENDDO
   ENDIF
ENDIF


RETURN
END SUBROUTINE CCCOMPUTE_RADIATION


! -------------------------------- CCIBM_SET_DATA ----------------------------------

SUBROUTINE CCIBM_SET_DATA

USE MPI
USE COMP_FUNCTIONS, ONLY: CURRENT_TIME
USE TRAN, ONLY : TRANS

! Local Variables:
INTEGER :: NM,IERR,ICALL
REAL(EB):: LX,LY,LZ,MAX_DIST,MAX_DIST_AUX
REAL(EB):: TNOW,TDEL
INTEGER :: TRN_ME(1:2)

INTEGER :: ICF
CHARACTER(80) :: FN_CCTIME
CHARACTER(200)::TCFORM

IF (N_GEOMETRY==0 .AND. .NOT.(PERIODIC_TEST==103 .OR. PERIODIC_TEST==11 .OR. PERIODIC_TEST==7)) THEN
   IF (MYID==0) THEN
      WRITE(LU_ERR,*) ' '
      WRITE(LU_ERR,*) 'CCIBM Setup Error : &MISC CC_IBM=.TRUE., but no &GEOM namelist defined on input file.'
      WRITE(LU_ERR,*) ' '
   ENDIF
   STOP_STATUS = SETUP_STOP
   RETURN
ENDIF

! Stretched grids not supported:
TRN_ME(1:2) = 0
MESH_LOOP_TRN : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   TRN_ME(1) = TRN_ME(1) + TRANS(NM)%NOCMAX
ENDDO MESH_LOOP_TRN
TRN_ME(2)=TRN_ME(1)
IF (N_MPI_PROCESSES > 1) CALL MPI_ALLREDUCE(TRN_ME(1),TRN_ME(2),1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,IERR)
IF (TRN_ME(2) > 0) THEN ! There is a TRNX, TRNY or TRNZ line defined for stretched grids. Not Unsupported.
   IF (MYID == 0) WRITE(LU_ERR,*) 'CCIBM Setup Error : Stretched grids currently unsupported.'
   STOP_STATUS = SETUP_STOP
   RETURN
ENDIF

! Defined relative GEOMEPS:
MAX_DIST=0._EB
! Loop Meshes:
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   LX=MESHES(NM)%XF-MESHES(NM)%XS
   LY=MESHES(NM)%YF-MESHES(NM)%YS
   LZ=MESHES(NM)%ZF-MESHES(NM)%ZS
   MAX_DIST=MAX(MAX_DIST,LX,LY,LZ)
ENDDO

! All Reduce Max:
IF (N_MPI_PROCESSES > 1) THEN
   MAX_DIST_AUX=MAX_DIST
   CALL MPI_ALLREDUCE(MAX_DIST_AUX, MAX_DIST, 1, MPI_DOUBLE_PRECISION, MPI_MAX, MPI_COMM_WORLD, IERR)
ENDIF

! Set relative epsilon for cut-cell definition:
MAX_DIST= MAX(1._EB,MAX_DIST)
GEOMEPS = GEOMEPS*MAX_DIST

! Set Flux limiter for cut-cell region:
IF(FLUX_LIMITER==CENTRAL_LIMITER) THEN
   BRP1 = 1._EB ! If 0., Godunov for advective term; if 1., centered interp.
ELSE ! For any other flux limiter use Godunov in CC region.
   BRP1 = 0._EB ! If 0., Godunov for advective term; if 1., centered interp.
ENDIF

IF (PERIODIC_TEST == 105) THEN ! Set cc-guard to zero, for timings.
   NGUARD = 2
   CCGUARD= NGUARD-2
ENDIF

TNOW = CURRENT_TIME()
CALL SET_CUTCELLS_3D                    ! Defines CUT_CELL data for each mesh.
TDEL = CURRENT_TIME() - TNOW

IF (PERIODIC_TEST == 105) THEN ! Cut-cell definition timings test.
    IF(MYID==0) WRITE(LU_ERR,*) ' '
    ICALL = 1
    IF(MYID==0) WRITE(LU_ERR,*) 'CALL number ',ICALL,' to SET_CUTCELLS_3D finished. Max Time=',TDEL,' sec.'
    DO ICALL=2,N_SET_CUTCELLS_3D_CALLS
       TNOW = CURRENT_TIME()
       CALL SET_CUTCELLS_3D                    ! Defines CUT_CELL data for each mesh, average timings.
       TDEL = CURRENT_TIME() - TNOW
       IF(MYID==0) WRITE(LU_ERR,*) 'CALL number ',ICALL,' to SET_CUTCELLS_3D finished. Max Time=',TDEL,' sec.'
    ENDDO
    WRITE_SET_CUTCELLS_TIMINGS = .TRUE.
    COMPUTE_CUTCELLS_ONLY =.TRUE.
ENDIF

! Write out SET_CUTCELLS_3D loop time:
IF (WRITE_SET_CUTCELLS_TIMINGS) THEN

   ! Total number of cut-cells and faces computed does not consider guard-cells:
   N_CUTCELLS_PROC     = 0
   N_INB_CUTFACES_PROC = 0
   N_REG_CUTFACES_PROC = 0
   DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      CALL POINT_TO_MESH(NM)
      ! Cut-cells:
      N_CUTCELLS_PROC = N_CUTCELLS_PROC + MESHES(NM)%N_CUTCELL_MESH
      ! Cut-faces:
      DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
         SELECT CASE(CUT_FACE(ICF)%STATUS)
         CASE(IBM_GASPHASE)
            N_REG_CUTFACES_PROC = N_REG_CUTFACES_PROC + CUT_FACE(ICF)%NFACE
         CASE(IBM_INBOUNDARY)
            N_INB_CUTFACES_PROC = N_INB_CUTFACES_PROC + CUT_FACE(ICF)%NFACE
         END SELECT
      ENDDO
   ENDDO

   ! Write xxx_cc_cpu_0001.csv
   ! This csv file contains the following fields (14):
   ! N_CUTCELLS, N_INB_CUTFACES, N_REG_CUTFACES, SET_CUTCELLS_TIME, GET_BODINT_PLANE_TIME, GET_X2_INTERSECTIONS_TIME, &
   ! GET_X2_VERTVAR_TIME, GET_CARTEDGE_CUTEDGES_TIME, GET_BODX2X3_INTERSECTIONS_TIME, GET_CARTFACE_CUTEDGES_TIME, &
   ! GET_CARTCELL_CUTEDGES_TIME, GET_CARTFACE_CUTFACES_TIME, GET_CARTCELL_CUTFACES_TIME, GET_CARTCELL_CUTCELLS_TIME
   WRITE(FN_CCTIME,'(A,A,I3.3,A)') TRIM(CHID),'_cc_cpu_',MYID,'.csv'
   OPEN(333,FILE=TRIM(FN_CCTIME),STATUS='UNKNOWN')
   WRITE(333,'(A,A,A,A)') "N_CUTCELLS, N_INB_CUTFACES, N_REG_CUTFACES, SET_CUTCELLS_TIME, GET_BODINT_PLANE_TIME, ",   &
                          "GET_X2_INTERSECTIONS_TIME, GET_X2_VERTVAR_TIME, GET_CARTEDGE_CUTEDGES_TIME, ",             &
                          "GET_BODX2X3_INTERSECTIONS_TIME, GET_CARTFACE_CUTEDGES_TIME, GET_CARTCELL_CUTEDGES_TIME, ", &
                          "GET_CARTFACE_CUTFACES_TIME, GET_CARTCELL_CUTFACES_TIME, GET_CARTCELL_CUTCELLS_TIME"
   WRITE(TCFORM,'(23A)')  "(I6,',',I6,',',I6,',',",FMT_R,",',',",FMT_R,",',',",FMT_R,",',',",FMT_R,",',',",           &
                          FMT_R,",',',",FMT_R,",',',",FMT_R,",',',",FMT_R,",',',",FMT_R,",',',",FMT_R,",',',",FMT_R,")"
   WRITE(333,TCFORM) N_CUTCELLS_PROC,N_INB_CUTFACES_PROC,N_REG_CUTFACES_PROC, &
                     T_CC_USED(SET_CUTCELLS_TIME_INDEX:GET_CARTCELL_CUTCELLS_TIME_INDEX)/ &
                     REAL(N_SET_CUTCELLS_3D_CALLS,EB)
   CLOSE(333)


   IF (MYID == 0) THEN
      WRITE(LU_ERR,*) ' '
      WRITE(LU_ERR,*) 'Spheres NVERTS,NFACES',GEOMETRY(1)%N_VERTS,GEOMETRY(1)%N_FACES
      WRITE(LU_ERR,*) 'SET_CUTCELLS_3D loop time by process ',MYID,' =',T_CC_USED(SET_CUTCELLS_TIME_INDEX), &
                      ' sec., cut-cells=',N_CUTCELLS_PROC,', cut-faces=',N_INB_CUTFACES_PROC,N_REG_CUTFACES_PROC
   ENDIF
ENDIF

IF (COMPUTE_CUTCELLS_ONLY) THEN
   STOP_STATUS = SETUP_ONLY_STOP
   RETURN
ENDIF
CALL GET_CRTCFCC_INTERPOLATION_STENCILS ! Computes interpolation stencils for face and cell centers.
CALL SET_CCIBM_MATVEC_DATA              ! Defines data for discretization matrix-vectors.
CALL SET_CFACES_ONE_D_RDN               ! Set inverse DXN for CFACES, uses cell linking information.


! Here in case of Moving meshes -> do interpolation of variables to newly defined cut-cells and faces.
!!! Something like INIT_CUT_CELL_DATA


! Set flag that specifies cut-cell data as defined:
CC_MATVEC_DEFINED=.TRUE.

RETURN

CONTAINS

! ------------------------ SET_CFACES_ONE_D_RDN ---------------------------------

SUBROUTINE SET_CFACES_ONE_D_RDN

! Local Variables:
INTEGER :: ICF, IFACE, CFACE_INDEX_LOCAL
INTEGER :: ICC, JCC, IBOD, IWSEL, I, J, K
INTEGER :: ILO, IHI, JLO, JHI, KLO, KHI, IFACE_CELL, ICF_CELL, IROW, NCELL
REAL(EB):: DXCF(IAXIS:KAXIS), NVEC(IAXIS:KAXIS), DCFXN, DCFXN2, DCFXNI, AREAI
REAL(EB), ALLOCATABLE, DIMENSION(:) :: DXN_UNKZ_LOC
REAL(EB), ALLOCATABLE, DIMENSION(:) :: VOL_UNKZ_LOC
INTEGER, ALLOCATABLE, DIMENSION(:,:):: IJK_UNKZ_LOC
! ALLOCATE local arrays
ALLOCATE(DXN_UNKZ_LOC(1:NUNKZ_LOCAL)); DXN_UNKZ_LOC(:) = 0._EB
ALLOCATE(VOL_UNKZ_LOC(1:NUNKZ_LOCAL)); VOL_UNKZ_LOC(:) = 0._EB
ALLOCATE(IJK_UNKZ_LOC(IAXIS:KAXIS+1,1:NUNKZ_LOCAL)); IJK_UNKZ_LOC(:,:) = IBM_UNDEFINED

! Main Loop:
MESH_LOOP_1 : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! Do a volume weighted average of distance to wall from linked cells, if one of them is a regular cell use 1/2 the
   ! distance of corner to corner sqrt(DX^2+DY^2+DZ^2).
   ! 1. Regular GASPHASE cells within the cc-region:
   ILO = 1; IHI = IBAR
   JLO = 1; JHI = JBAR
   KLO = 1; KHI = KBAR
   DO K=KLO,KHI
      DO J=JLO,JHI
         DO I=ILO,IHI
            IF (CCVAR(I,J,K,IBM_UNKZ) <= 0 ) CYCLE ! Drop if regular GASPHASE cell has not been assigned unknown number.
            IROW = CCVAR(I,J,K,IBM_UNKZ) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
            DXN_UNKZ_LOC(IROW) = DXN_UNKZ_LOC(IROW) + 1._EB/3._EB*(DX(I)+DY(J)+DZ(K))*(DX(I)*DY(J)*DZ(K)) ! Avg Delta.
            VOL_UNKZ_LOC(IROW) = VOL_UNKZ_LOC(IROW) + (DX(I)*DY(J)*DZ(K))
            IJK_UNKZ_LOC(IAXIS:KAXIS+1,IROW) = (/ I,J,K,NM /)
         ENDDO
      ENDDO
   ENDDO
   ! 2. Number cut-cells:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      I = CUT_CELL(ICC)%IJK(IAXIS)
      J = CUT_CELL(ICC)%IJK(JAXIS)
      K = CUT_CELL(ICC)%IJK(KAXIS)
      NCELL = CUT_CELL(ICC)%NCELL
      DO JCC=1,NCELL
         IROW = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
         ! Mean INBOUNDARY cut-face distance to this cut-cell center, projected to cut-face normal:
         AREAI = 0._EB
         DCFXNI= 0._EB
         DO ICF_CELL=1,CUT_CELL(ICC)%CCELEM(1,JCC)
            IFACE_CELL = CUT_CELL(ICC)%CCELEM(ICF_CELL+1,JCC)
            IF (CUT_CELL(ICC)%FACE_LIST(1,IFACE_CELL) /= IBM_FTYPE_CFINB) CYCLE

            ! Indexes of INBOUNDARY cutface on CUT_FACE:
            ICF   = CUT_CELL(ICC)%FACE_LIST(4,IFACE_CELL)
            IFACE = CUT_CELL(ICC)%FACE_LIST(5,IFACE_CELL)

            ! DXN:
            ! Xcc - Xcf:
            DXCF(IAXIS:KAXIS) = CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC) - CUT_FACE(ICF)%XYZCEN(IAXIS:KAXIS,IFACE)

            ! Normal to cut-face:
            IBOD =CUT_FACE(ICF)%BODTRI(1,IFACE)
            IWSEL=CUT_FACE(ICF)%BODTRI(2,IFACE)
            NVEC(IAXIS:KAXIS) = GEOMETRY(IBOD)%FACES_NORMAL(IAXIS:KAXIS,IWSEL)

            ! Dot product gives normal distance from Xcf to Xcc:
            DCFXN = ABS(DXCF(IAXIS)*NVEC(IAXIS) + DXCF(JAXIS)*NVEC(JAXIS) + DXCF(KAXIS)*NVEC(KAXIS))
            IF (DCFXN < GEOMEPS) DCFXN=SQRT(DXCF(IAXIS)**2._EB+DXCF(JAXIS)**2._EB+DXCF(KAXIS)**2._EB) ! Norm of Xcc-Xcf
            IF (DCFXN < GEOMEPS) DCFXN=0.5_EB*ABS(NVEC(IAXIS)*DX(I)+NVEC(JAXIS)*DY(J)+NVEC(KAXIS)*DZ(K)) ! Use CRT cell

            ! Area sum:
            AREAI = AREAI + CUT_FACE(ICF)%AREA(IFACE)
            ! DXN*Area sume:
            DCFXNI= DCFXNI+ DCFXN*CUT_FACE(ICF)%AREA(IFACE)
         ENDDO

         IF (AREAI < GEOMEPS) THEN ! This cut cell has the size and geometry of a regular cell.
            DXN_UNKZ_LOC(IROW) = DXN_UNKZ_LOC(IROW) + 1._EB/3._EB*(DX(I)+DY(J)+DZ(K))*(DX(I)*DY(J)*DZ(K))
            VOL_UNKZ_LOC(IROW) = VOL_UNKZ_LOC(IROW) + (DX(I)*DY(J)*DZ(K))
         ELSE
            ! INBOUNDARY cut-face area Average:
            DCFXNI= DCFXNI / AREAI
            ! Center to center distance:
            DCFXN2 = 2._EB*(DCFXNI)
            DXN_UNKZ_LOC(IROW) = DXN_UNKZ_LOC(IROW) + DCFXN2*CUT_CELL(ICC)%VOLUME(JCC)
            VOL_UNKZ_LOC(IROW) = VOL_UNKZ_LOC(IROW) + CUT_CELL(ICC)%VOLUME(JCC)
         ENDIF
         IJK_UNKZ_LOC(IAXIS:KAXIS+1,IROW) = (/ I,J,K,NM /)
      ENDDO
   ENDDO

ENDDO MESH_LOOP_1

! Compute volume average for all linked cells:
DO IROW=1,NUNKZ_LOCAL
   IF ( VOL_UNKZ_LOC(IROW) < GEOMEPS ) THEN
      I  = IJK_UNKZ_LOC(IAXIS,IROW)
      J  = IJK_UNKZ_LOC(JAXIS,IROW)
      K  = IJK_UNKZ_LOC(KAXIS,IROW)
      NM = IJK_UNKZ_LOC(KAXIS+1,IROW)
      DXN_UNKZ_LOC(IROW) = 1._EB/3._EB*( MESHES(NM)%DX(I) + MESHES(NM)%DY(J) + MESHES(NM)%DZ(K) )
      CYCLE
   ENDIF
   DXN_UNKZ_LOC(IROW) = DXN_UNKZ_LOC(IROW) / VOL_UNKZ_LOC(IROW)
ENDDO


! Finally Define ONE_D%RDN:
MESH_LOOP_2 : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      IF(CUT_FACE(ICF)%STATUS /= IBM_INBOUNDARY) CYCLE
      DO IFACE=1,CUT_FACE(ICF)%NFACE
         ! Index in CFACE for cut-face in (ICF,IFACE) of CUT_FACE.
         CFACE_INDEX_LOCAL = CUT_FACE(ICF)%CFACE_INDEX(IFACE)
         ! Compute CFACE(:)%ONE_D%RDN:
         IF (CUT_FACE(ICF)%CELL_LIST(1,LOW_IND,IFACE) /= IBM_FTYPE_CFGAS) CYCLE
         ICC = CUT_FACE(ICF)%CELL_LIST(2,LOW_IND,IFACE)
         JCC = CUT_FACE(ICF)%CELL_LIST(3,LOW_IND,IFACE)
         IROW = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
         CFACE(CFACE_INDEX_LOCAL)%ONE_D%RDN = 1._EB/DXN_UNKZ_LOC(IROW)
      ENDDO
   ENDDO

   DO ICF=1,N_CFACE_CELLS
      CFACE(ICF)%ONE_D%RDN = 1._EB/DX(1)
   ENDDO

ENDDO MESH_LOOP_2
DEALLOCATE(DXN_UNKZ_LOC, VOL_UNKZ_LOC, IJK_UNKZ_LOC)

RETURN
END SUBROUTINE SET_CFACES_ONE_D_RDN

END SUBROUTINE CCIBM_SET_DATA

! ------------------------------- CCIBM_END_STEP --------------------------------

SUBROUTINE CCIBM_END_STEP(T,DT,DIAGNOSTICS)

REAL(EB),INTENT(IN) :: T,DT
LOGICAL, INTENT(IN) :: DIAGNOSTICS

INTEGER :: CODE

CALL CCIBM_VELOCITY_CUTFACES
CALL CCIBM_H_INTERP
CALL CCIBM_RHO0W_INTERP
! Exchange interpolated H:
IF(PREDICTOR) CODE = 3
IF(CORRECTOR) CODE = 6
CALL MESH_CC_EXCHANGE(CODE,.TRUE.)
#ifdef DEBUG_CCREGION_SCALAR_TRANSPORT
IF (PREDICTOR) CALL CCIBM_CHECK_DIVERGENCE(T,DT,.TRUE.)
IF (CORRECTOR) CALL CCIBM_CHECK_DIVERGENCE(T,DT,.FALSE.)
#else
IF (CORRECTOR .AND. DIAGNOSTICS) CALL CCIBM_CHECK_DIVERGENCE(T,DT,.FALSE.)
#endif

RETURN

END SUBROUTINE CCIBM_END_STEP

! ! ------------------------------- THREED_VORTEX ---------------------------------
!
! SUBROUTINE THREED_VORTEX(NM)
!
! INTEGER, INTENT(IN) :: NM
!
! ! Local Variables:
! INTEGER :: I,J,K
! REAL(EB) :: A,B,C,WVX,WVY,WVZ
!
! CALL POINT_TO_MESH(NM)
!
! A = 1._EB
! B =-2._EB
! C = 1._EB
!
! WVX=PI
! WVY=PI
! WVZ=PI
!
! ! U velocities:
! DO K=1,KBAR
!    DO J=1,JBAR
!       DO I=0,IBAR
!          U(I,J,K)=A*COS(WVX*X(I))*SIN(WVY*YC(J))*SIN(WVZ*ZC(K))
!       ENDDO
!    ENDDO
! ENDDO
!
! ! V velocities:
! DO K=1,KBAR
!    DO J=0,JBAR
!       DO I=1,IBAR
!          V(I,J,K)=B*SIN(WVX*XC(I))*COS(WVY*Y(J))*SIN(WVZ*ZC(K))
!       ENDDO
!    ENDDO
! ENDDO
!
! ! W velocities:
! DO K=0,KBAR
!    DO J=1,JBAR
!       DO I=1,IBAR
!          W(I,J,K)=C*SIN(WVX*XC(I))*SIN(WVY*YC(J))*COS(WVZ*Z(K))
!       ENDDO
!    ENDDO
! ENDDO
!
!
! RETURN
! END SUBROUTINE THREED_VORTEX

! ----------------------------- INIT_CUTCELL_DATA -------------------------------

SUBROUTINE INIT_CUTCELL_DATA

USE PHYSICAL_FUNCTIONS, ONLY: GET_SPECIFIC_GAS_CONSTANT

! Local Variables:
INTEGER :: NM,I,J,K,N,ICC,JCC,X1AXIS,NFACE,ICF,IFACE
REAL(EB) TMP_CC,RHO_CC,AREAT,VEL_CF,RHOPV(-1:0)
REAL(EB), ALLOCATABLE, DIMENSION(:) :: ZZ_CC
TYPE(CFACE_TYPE), POINTER :: CFA=>NULL()
INTEGER :: IND1, IND2

ALLOCATE( ZZ_CC(1:N_TOTAL_SCALARS) )

! Loop Meshes:
MESH_LOOP : DO NM=1,NMESHES

   IF (PROCESS(NM)/=MYID) CYCLE

   CALL POINT_TO_MESH(NM)

   ! Default initialization:
   ! Cut-cells inherit underlying Cartesian cell values of rho,T,Z, etc.:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH+MESHES(NM)%N_GCCUTCELL_MESH


      I = CUT_CELL(ICC)%IJK(IAXIS)
      J = CUT_CELL(ICC)%IJK(JAXIS)
      K = CUT_CELL(ICC)%IJK(KAXIS)

      IF (I < 0 .OR. I > IBP1) CYCLE
      IF (J < 0 .OR. J > JBP1) CYCLE
      IF (K < 0 .OR. K > KBP1) CYCLE

      TMP_CC = TMP(I,J,K)
      RHO_CC = RHO(I,J,K)
      ZZ_CC(1:N_TOTAL_SCALARS) = ZZ(I,J,K,1:N_TOTAL_SCALARS)

      DO JCC=1,CUT_CELL(ICC)%NCELL
         CUT_CELL(ICC)%TMP(JCC) = TMP_CC
         CUT_CELL(ICC)%RHO(JCC) = RHO_CC
         CUT_CELL(ICC)%RHOS(JCC)= RHO_CC
         CUT_CELL(ICC)%ZZ(1:N_TOTAL_SCALARS,JCC) = ZZ_CC(1:N_TOTAL_SCALARS)
         DO N=1,N_TRACKED_SPECIES
            CUT_CELL(ICC)%ZZS(N,JCC) = SPECIES_MIXTURE(N)%ZZ0
         ENDDO
         CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_CC(1:N_TRACKED_SPECIES),CUT_CELL(ICC)%RSUM(JCC))
         CUT_CELL(ICC)%D(JCC)        = 0._EB
         CUT_CELL(ICC)%DS(JCC)       = 0._EB
         CUT_CELL(ICC)%D_SOURCE(JCC) = 0._EB
         CUT_CELL(ICC)%Q(JCC)        = 0._EB
         CUT_CELL(ICC)%QR(JCC)       = 0._EB
         CUT_CELL(ICC)%M_DOT_PPP(:,JCC) = 0._EB
      ENDDO
   ENDDO

   ! Gasphase Cut-faces inherit underlying Cartesian face values of Velocity (flux matched):
   CUTFACE_LOOP : DO ICF=1,MESHES(NM)%N_CUTFACE_MESH

      NFACE  = CUT_FACE(ICF)%NFACE

      IF (CUT_FACE(ICF)%STATUS == IBM_GASPHASE) THEN

         I      = CUT_FACE(ICF)%IJK(IAXIS)
         J      = CUT_FACE(ICF)%IJK(JAXIS)
         K      = CUT_FACE(ICF)%IJK(KAXIS)
         X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)


         AREAT  = SUM( CUT_FACE(ICF)%AREA(1:NFACE) )

         ! Flux matched U0 to cut-face centroids, they all get same velocity:
         SELECT CASE(X1AXIS)
         CASE(IAXIS)
            VEL_CF = (DY(J)*DZ(K))/AREAT * U(I,J,K)
         CASE(JAXIS)
            VEL_CF = (DX(I)*DZ(K))/AREAT * V(I,J,K)
         CASE(KAXIS)
            VEL_CF = (DX(I)*DY(J))/AREAT * W(I,J,K)
         END SELECT

      ELSE ! IBM_INBOUNDARY

         VEL_CF = 0._EB

      ENDIF

      CUT_FACE(ICF)%VEL(1:NFACE)  = VEL_CF
      CUT_FACE(ICF)%VELS(1:NFACE) = VEL_CF

   ENDDO CUTFACE_LOOP


   ! Populate PHOPVN in regular faces of CCIMPREGION:
   ! IAXIS faces:
   X1AXIS = IAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      I  = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)

      MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%RHOPVN(-1:0) = RHO(I+FCELL-1:I+FCELL  ,J,K)

   ENDDO

   ! JAXIS faces:
   X1AXIS = JAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      I  = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)

      MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%RHOPVN(-1:0) = RHO(I,J+FCELL-1:J+FCELL  ,K)

   ENDDO

   ! KAXIS faces:
   X1AXIS = KAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      I  = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)

      MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%RHOPVN(-1:0) = RHO(I,J,K+FCELL-1:K+FCELL  )

   ENDDO

   ! Now populate RCFACES:
   DO IFACE=1,MESHES(NM)%IBM_NRCFACE_Z

      I      = IBM_RCFACE_Z(IFACE)%IJK(IAXIS)
      J      = IBM_RCFACE_Z(IFACE)%IJK(JAXIS)
      K      = IBM_RCFACE_Z(IFACE)%IJK(KAXIS)
      X1AXIS = IBM_RCFACE_Z(IFACE)%IJK(KAXIS+1)

      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            RHOPV(-1:0) = RHO(I+FCELL-1:I+FCELL,J,K)
         CASE(JAXIS)
            RHOPV(-1:0) = RHO(I,J+FCELL-1:J+FCELL,K)
         CASE(KAXIS)
            RHOPV(-1:0) = RHO(I,J,K+FCELL-1:K+FCELL)
      ENDSELECT

      IBM_RCFACE_Z(IFACE)%RHOPVN(-1:0) = RHOPV(-1:0)
   ENDDO

   ! Finally Cut-faces:
   DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
      IF ( CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE

      I = CUT_FACE(ICF)%IJK(IAXIS)
      J = CUT_FACE(ICF)%IJK(JAXIS)
      K = CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)

      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            RHOPV(-1:0) = RHO(I+FCELL-1:I+FCELL,J,K)
         CASE(JAXIS)
            RHOPV(-1:0) = RHO(I,J+FCELL-1:J+FCELL,K)
         CASE(KAXIS)
            RHOPV(-1:0) = RHO(I,J,K+FCELL-1:K+FCELL)
      ENDSELECT

      DO IFACE=1,CUT_FACE(ICF)%NFACE
         CUT_FACE(ICF)%RHOPVN(-1:0,IFACE) = RHOPV(-1:0)
      ENDDO
   ENDDO

   ! CFACES:
   DO ICF=1,N_CFACE_CELLS
      CFA  => CFACE(ICF)
      IND1 = CFA%CUT_FACE_IND1
      IND2 = CFA%CUT_FACE_IND2
      ICC = CUT_FACE(IND1)%CELL_LIST(2,LOW_IND,IND2)
      JCC = CUT_FACE(IND1)%CELL_LIST(3,LOW_IND,IND2)

      ! Here are some hacky initializations:
      ! Set TMP_F to ambient in under laying cartesian cell.
      CFA%ONE_D%TMP_F = TMP_0(CUT_FACE(IND1)%IJK(KAXIS))
      CFA%ONE_D%RHO_F = CUT_CELL(ICC)%RHO(JCC)
      CFA%ONE_D%ZZ_F(1:N_TOTAL_SCALARS)  = CUT_CELL(ICC)%ZZ(1:N_TOTAL_SCALARS,JCC)

   ENDDO


ENDDO MESH_LOOP

DEALLOCATE( ZZ_CC )

RETURN
END SUBROUTINE INIT_CUTCELL_DATA

! ---------------------------- CCIBM_VELOCITY_NO_GRADH -----------------------------

SUBROUTINE CCIBM_VELOCITY_NO_GRADH(DT)

REAL(EB), INTENT(IN) :: DT

! Local Variables:
INTEGER :: I,J,K

IF (.NOT.PRES_ON_CARTESIAN .OR. PRES_ON_WHOLE_DOMAIN) RETURN

PREDICTOR_COND : IF (PREDICTOR) THEN

   DO K=1,KBAR
      DO J=1,JBAR
         DO I=0,IBAR
            IF (FCVAR(I,J,K,IBM_FGSC,IAXIS) /= IBM_SOLID) CYCLE
            US(I,J,K) = U(I,J,K) - DT*( FVX(I,J,K) )
         ENDDO
      ENDDO
   ENDDO

   DO K=1,KBAR
      DO J=0,JBAR
         DO I=1,IBAR
            IF (FCVAR(I,J,K,IBM_FGSC,JAXIS) /= IBM_SOLID) CYCLE
            VS(I,J,K) = V(I,J,K) - DT*( FVY(I,J,K) )
         ENDDO
      ENDDO
   ENDDO

   DO K=0,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (FCVAR(I,J,K,IBM_FGSC,KAXIS) /= IBM_SOLID) CYCLE
            WS(I,J,K) = W(I,J,K) - DT*( FVZ(I,J,K) )
         ENDDO
      ENDDO
   ENDDO

ELSE ! Corrector

   DO K=1,KBAR
      DO J=1,JBAR
         DO I=0,IBAR
            IF (FCVAR(I,J,K,IBM_FGSC,IAXIS) /= IBM_SOLID) CYCLE
            U(I,J,K) = 0.5_EB*( U(I,J,K) + US(I,J,K) - DT*FVX(I,J,K) )
         ENDDO
      ENDDO
   ENDDO

   DO K=1,KBAR
      DO J=0,JBAR
         DO I=1,IBAR
            IF (FCVAR(I,J,K,IBM_FGSC,JAXIS) /= IBM_SOLID) CYCLE
            V(I,J,K) = 0.5_EB*( V(I,J,K) + VS(I,J,K) - DT*FVY(I,J,K) )
         ENDDO
      ENDDO
   ENDDO

   DO K=0,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (FCVAR(I,J,K,IBM_FGSC,KAXIS) /= IBM_SOLID) CYCLE
            W(I,J,K) = 0.5_EB*( W(I,J,K) + WS(I,J,K) - DT*FVZ(I,J,K) )
         ENDDO
      ENDDO
   ENDDO

ENDIF PREDICTOR_COND


RETURN
END SUBROUTINE CCIBM_VELOCITY_NO_GRADH


! -------------------------------- FINISH_CCIBM ---------------------------------

SUBROUTINE FINISH_CCIBM

! Local variables:

! Stub for now.

RETURN
END SUBROUTINE FINISH_CCIBM


! -------------------------- CCREGION_DIVERGENCE_PART_1 --------------------------

SUBROUTINE CCREGION_DIVERGENCE_PART_1(T,DT,NM)

USE MATH_FUNCTIONS, ONLY: INTERPOLATE1D_UNIFORM
USE PHYSICAL_FUNCTIONS, ONLY: GET_CONDUCTIVITY,GET_SPECIFIC_HEAT,GET_SENSIBLE_ENTHALPY_Z, &
                              GET_SENSIBLE_ENTHALPY,GET_VISCOSITY,GET_MOLECULAR_WEIGHT
USE COMP_FUNCTIONS, ONLY: CURRENT_TIME
USE MANUFACTURED_SOLUTIONS, ONLY: UF_MMS,WF_MMS,VD2D_MMS_Z_SRC

REAL(EB), INTENT(IN) :: T,DT
INTEGER,  INTENT(IN) :: NM
! Recompute divergence terms in cut-cell region and surrounding cells.
! Use velocity divergence equivalence to define divergence on cut-cell underlying Cartesian cells.

! Local Variables:
INTEGER :: N,I,J,K,X1AXIS,ISIDE,IFACE,ICC,JCC,ICF,IEXIM,LHFACE
REAL(EB), POINTER, DIMENSION(:,:,:) :: DP,RHOP,RTRM,CP,R_H_G,U_DOT_DEL_RHO_Z
REAL(EB), POINTER, DIMENSION(:,:) :: PBAR_P
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: ZZP
REAL(EB) :: RDT,CCM1,CCP1,IDX,AF,TMP_G,H_S,&
            ZZ_FACE(MAX_SPECIES),TNOW,RHOPV(-1:0),TMPV(-1:0),X1F,PRFCT,PRFCTV, &
            CPV(-1:0),KPV(-1:0),KPDTDN,FCT,NEW_RHO_D_DZDN ! ZZPV2(-1:0,1:MAX_SPECIES),
REAL(EB), ALLOCATABLE, DIMENSION(:) :: ZZ_GET
REAL(EB), POINTER, DIMENSION(:,:,:) :: UU,VV,WW
TYPE(SPECIES_MIXTURE_TYPE), POINTER :: SM

REAL(EB) :: DIVVOL, MINVOL, DUMMY

LOGICAL, PARAMETER :: DO_CONDUCTION_HEAT_FLUX=.TRUE.
INTEGER :: DIFFHFLX_IND, JFLX_IND

LOGICAL, PARAMETER :: SET_DIV_TO_ZERO  = .FALSE.
LOGICAL, PARAMETER :: SET_CCDIV_TO_ZERO= .FALSE.
LOGICAL, PARAMETER :: AVERAGE_LINKDIV  = .TRUE.
LOGICAL, PARAMETER :: FIX_DIFF_FLUXES  = .TRUE.

REAL(EB), PARAMETER :: FLX_EPS=1.E-15_EB

REAL(EB), ALLOCATABLE, DIMENSION(:) :: DIVRG_VOL , VOLDVRG
INTEGER :: INDZ

! Pressure sums re-integration vars:
TYPE(WALL_TYPE), POINTER :: WC=>NULL()
TYPE(CFACE_TYPE), POINTER :: CFA=>NULL()
INTEGER :: IW,IPZ, IND1,IND2
REAL(EB) :: VC, VC1

! Shunn MMS test case vars:
REAL(EB) :: XHAT, ZHAT, Q_Z, TT

! Dummy on T:
DUMMY = T

! Check whether to skip this routine

IF (SOLID_PHASE_ONLY) RETURN

TNOW=CURRENT_TIME()

IF (DO_SYMM_SCALAR_DIFFLUXES .OR. .NOT.DO_IMPLICIT_CCREGION) THEN
   DIFFHFLX_IND = LOW_IND  ! -rho Da Grad(Za)
   JFLX_IND     = LOW_IND
ELSE
   DIFFHFLX_IND = HIGH_IND ! -( Da Grad(rho Za) - Da Grad(rho)/rho (rho Za) )
   JFLX_IND     = HIGH_IND
ENDIF

CALL POINT_TO_MESH(NM)

RDT = 1._EB/DT

SELECT CASE(PREDICTOR)
   CASE(.TRUE.)
      DP => DS
      PBAR_P => PBAR_S
      RHOP => RHOS
      PRFCT = 0._EB ! Use star cut-cell quantities.
   CASE(.FALSE.)
      DP => DDDT
      PBAR_P => PBAR
      RHOP => RHO
      PRFCT = 1._EB ! Use end of step cut-cell quantities.
END SELECT

R_PBAR = 1._EB/PBAR_P

RTRM => WORK1

! Set DP to zero in Cartesian cells of type: IBM_SOLID, IBM_CUTCFE, and IBM_GASPHASE where IBM_UNKZ > 0:
DO K=1,KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         IF ((CCVAR(I,J,K,IBM_CGSC) == IBM_GASPHASE) .AND. (CCVAR(I,J,K,IBM_UNKZ) <= 0)) CYCLE
         DP(I,J,K) = 0._EB
      ENDDO
   ENDDO
ENDDO
SELECT CASE(PREDICTOR)
   CASE(.TRUE.)
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH+MESHES(NM)%N_GCCUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            CUT_CELL(ICC)%DS(JCC)= 0._EB
            CUT_CELL(ICC)%DEL_RHO_D_DEL_Z(1:N_TOTAL_SCALARS,JCC)=0._EB
         ENDDO
      ENDDO
   CASE(.FALSE.)
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH+MESHES(NM)%N_GCCUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            CUT_CELL(ICC)%D(JCC) = 0._EB
            CUT_CELL(ICC)%DEL_RHO_D_DEL_Z(1:N_TOTAL_SCALARS,JCC)=0._EB
         ENDDO
      ENDDO
END SELECT

IF (SET_DIV_TO_ZERO) THEN
   DP = 0._EB ! Set to zero divg on all cells.
   RETURN
ENDIF
IF (SET_CCDIV_TO_ZERO) RETURN

! Point to corresponding ZZ array:
SELECT CASE(PREDICTOR)
   CASE(.TRUE.)
      ZZP => ZZS
   CASE(.FALSE.)
      ZZP => ZZ
END SELECT

ALLOCATE(ZZ_GET(N_TRACKED_SPECIES))

! Add species diffusion terms to divergence expression and compute diffusion term for species equations
SPECIES_GT_1_IF: IF (N_TOTAL_SCALARS>1) THEN

   ! 1. Diffusive Heat flux = - Grad dot (h_s rho D Grad Z_n):
   ! In FV form: use faces to add corresponding face integral terms, for face k
   ! (sum_a{h_{s,a} rho D_a Grad z_a) dot \hat{n}_k A_k, where \hat{n}_k is the versor outside of cell
   ! at face k.
   CALL CCREGION_DIFFUSIVE_MASS_FLUXES(NM)

   ! Ensure RHO_D terms sum to zero over all species.  Gather error into largest mass fraction present.
   IF (FIX_DIFF_FLUXES) CALL FIX_CCREGION_DIFF_MASS_FLUXES

   ! Zero out DEL_RHO_D_DEL_Z for impregion regular cells:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF(CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE
            DEL_RHO_D_DEL_Z(I,J,K,1:N_TOTAL_SCALARS) = 0._EB
         ENDDO
      ENDDO
   ENDDO

   ! 1. Diffusive heat flux  = - hs,a (Da Grad(rho*Ya) - Da/rho Grad(rho) (rho Ya)):
   CALL CCREGION_DIFFUSIVE_HEAT_FLUXES

ENDIF SPECIES_GT_1_IF


CONDUCTION_HEAT_IF : IF( DO_CONDUCTION_HEAT_FLUX ) THEN
   ! 2. Conduction heat flux = - k Grad(T):
   CALL CCREGION_CONDUCTION_HEAT_FLUX
ENDIF CONDUCTION_HEAT_IF


! Add \dot{q}''' and QR to DP:
! Regular cells:
DO K=1,KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         IF (CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE
         ! Add \dot{q}''' and QR to DP*Vii:
         DP(I,J,K) = DP(I,J,K) + (Q(I,J,K) + QR(I,J,K)) * DX(I)*DY(J)*DZ(K)
      ENDDO
   ENDDO
ENDDO

! HERE Cut-cells \dot{q}''' and QR:
IF (PREDICTOR) THEN
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      DO JCC=1,CUT_CELL(ICC)%NCELL
         CUT_CELL(ICC)%DS(JCC) = CUT_CELL(ICC)%DS(JCC) + &
         (CUT_CELL(ICC)%Q(JCC)+CUT_CELL(ICC)%QR(JCC)) * CUT_CELL(ICC)%VOLUME(JCC)
      ENDDO
   ENDDO
ELSE
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      DO JCC=1,CUT_CELL(ICC)%NCELL
         CUT_CELL(ICC)%D(JCC) = CUT_CELL(ICC)%D(JCC) + &
         (CUT_CELL(ICC)%Q(JCC)+CUT_CELL(ICC)%QR(JCC)) * CUT_CELL(ICC)%VOLUME(JCC)
      ENDDO
   ENDDO
ENDIF

! 3. Enthalpy advection term = - \bar{ u dot Grad (rho h_s) }:
! R_H_G = 1/(Cp * T)
! RTRM  = 1/(rho * Cp * T)
! Point to the appropriate velocity components

IF (PREDICTOR) THEN
   UU=>U
   VV=>V
   WW=>W
   PRFCTV = 1._EB
ELSE
   UU=>US
   VV=>VS
   WW=>WS
   PRFCTV = 0._EB
ENDIF

CONST_GAMMA_IF_1: IF (.NOT.CONSTANT_SPECIFIC_HEAT_RATIO) THEN
   CALL CCENTHALPY_ADVECTION ! Compute u dot grad rho h_s in FV form and add to DP in regular + cut-cells.
ENDIF CONST_GAMMA_IF_1


! Loop through regular cells in the implicit region, as well as cut-cells and compute R_H_G, and RTRM:
CP    => WORK5
R_H_G => WORK9
RTRM  => WORK1
! Regular cells:
DO K=1,KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         IF (CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE
         ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K,1:N_TRACKED_SPECIES)
         CALL GET_SPECIFIC_HEAT(ZZ_GET,CP(I,J,K),TMP(I,J,K))
         R_H_G(I,J,K) = 1._EB/(CP(I,J,K)*TMP(I,J,K))
         RTRM(I,J,K) = R_H_G(I,J,K)/RHOP(I,J,K)
         DP(I,J,K) = RTRM(I,J,K)*DP(I,J,K)
      ENDDO
   ENDDO
ENDDO

! Cut-cells:
DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
   DO JCC=1,CUT_CELL(ICC)%NCELL
      TMPV(0) = CUT_CELL(ICC)%TMP(JCC)
      ZZ_GET(1:N_TRACKED_SPECIES) =  &
             PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
      (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
      CALL GET_SPECIFIC_HEAT(ZZ_GET,CPV(0),TMPV(0))
      CUT_CELL(ICC)%R_H_G(JCC) = 1._EB/(CPV(0)*TMPV(0))
      RHOPV(0) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + &
          (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
      CUT_CELL(ICC)%RTRM(JCC)  = CUT_CELL(ICC)%R_H_G(JCC)/RHOPV(0)
      IF (PREDICTOR) THEN
         CUT_CELL(ICC)%DS(JCC) = &
         CUT_CELL(ICC)%RTRM(JCC)*CUT_CELL(ICC)%DS(JCC)
      ELSE
         CUT_CELL(ICC)%D(JCC) = &
         CUT_CELL(ICC)%RTRM(JCC)*CUT_CELL(ICC)%D(JCC)
      ENDIF
   ENDDO
ENDDO


! 4. Enthalpy flux due to mass diffusion and advection:
! sum_n [\bar{W}/W_n - h_{s,n}*R_H_G] ( Grad dot (rho D_\alpha Grad Z_n) - \bar{u dot Grad (rho Z_n)})

CONST_GAMMA_IF_2: IF (.NOT.CONSTANT_SPECIFIC_HEAT_RATIO) THEN

   DO N=1,N_TRACKED_SPECIES

      CALL CCSPECIES_ADVECTION ! Compute u dot grad rho Z_n

      SM  => SPECIES_MIXTURE(N)

      ! Regular cells:
      ICC = 0
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE
               CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP(I,J,K),H_S)
               DP(I,J,K) = DP(I,J,K) + (SM%RCON/RSUM(I,J,K) - H_S*R_H_G(I,J,K))* &
                    ( DEL_RHO_D_DEL_Z(I,J,K,N) - U_DOT_DEL_RHO_Z(I,J,K) )/RHOP(I,J,K)
               ! Values of DEL_RHO_D_DEL_Z(I,J,K,N) have been filled previously.
               ! RSUM was computed in the implicit region advance routine for scalars CCDENSITY.
               ICC = ICC + 1
            ENDDO
         ENDDO
      ENDDO

      ! Cut-cells:
      IF (PREDICTOR) THEN
         DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
            DO JCC=1,CUT_CELL(ICC)%NCELL
               TMPV(0) = CUT_CELL(ICC)%TMP(JCC)
               CALL GET_SENSIBLE_ENTHALPY_Z(N,TMPV(0),H_S)
               CUT_CELL(ICC)%DS(JCC) = CUT_CELL(ICC)%DS(JCC) + &
              (SM%RCON/CUT_CELL(ICC)%RSUM(JCC) - &
               H_S*CUT_CELL(ICC)%R_H_G(JCC))/CUT_CELL(ICC)%RHOS(JCC) * &
              (CUT_CELL(ICC)%DEL_RHO_D_DEL_Z(N,JCC)- CUT_CELL(ICC)%U_DOT_DEL_RHO_Z(N,JCC))
            ENDDO
         ENDDO
      ELSE
         DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
            DO JCC=1,CUT_CELL(ICC)%NCELL
               TMPV(0) = CUT_CELL(ICC)%TMP(JCC)
               CALL GET_SENSIBLE_ENTHALPY_Z(N,TMPV(0),H_S)
               CUT_CELL(ICC)%D(JCC) = CUT_CELL(ICC)%D(JCC) + &
              (SM%RCON/CUT_CELL(ICC)%RSUM(JCC) - &
               H_S*CUT_CELL(ICC)%R_H_G(JCC))/CUT_CELL(ICC)%RHO(JCC) * &
              (CUT_CELL(ICC)%DEL_RHO_D_DEL_Z(N,JCC)- CUT_CELL(ICC)%U_DOT_DEL_RHO_Z(N,JCC))
            ENDDO
         ENDDO
      ENDIF



   ENDDO

ENDIF CONST_GAMMA_IF_2


! Add contribution of reactions

IF (N_REACTIONS > 0 .OR. N_LP_ARRAY_INDICES>0 .OR. ANY(SPECIES_MIXTURE%DEPOSITING)) THEN

   ! Regular Cells on the implicit region:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE
            DP(I,J,K) = DP(I,J,K) + D_SOURCE(I,J,K)*DX(I)*DY(J)*DZ(K)
         ENDDO
      ENDDO
   ENDDO

   ! Cut cells:
   IF (PREDICTOR) THEN
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            CUT_CELL(ICC)%DS(JCC) = CUT_CELL(ICC)%DS(JCC) + &
                                        CUT_CELL(ICC)%D_SOURCE(JCC)*CUT_CELL(ICC)%VOLUME(JCC)
         ENDDO
      ENDDO
   ELSE
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            CUT_CELL(ICC)%D(JCC)  = CUT_CELL(ICC)%D(JCC)  + &
                                        CUT_CELL(ICC)%D_SOURCE(JCC)*CUT_CELL(ICC)%VOLUME(JCC)
         ENDDO
      ENDDO
   ENDIF

ENDIF

! Atmospheric stratification term

IF (STRATIFICATION) THEN
   ! Regular Cells on the implicit region:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE
            DP(I,J,K) = DP(I,J,K) + RTRM(I,J,K)*0.5_EB*(WW(I,J,K)+WW(I,J,K-1))*RHO_0(K)*GVEC(KAXIS)*DX(I)*DY(J)*DZ(K)
         ENDDO
      ENDDO
   ENDDO

   IF (PREDICTOR) THEN
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            ! D = D + w*rho_0*g/(rho*Cp*T)*Vii
            CUT_CELL(ICC)%DS(JCC) = CUT_CELL(ICC)%DS(JCC) +  &
            CUT_CELL(ICC)%RTRM(JCC)*CUT_CELL(ICC)%WVEL(JCC)* &
            CUT_CELL(ICC)%RHO_0(JCC)*GVEC(KAXIS)*CUT_CELL(ICC)%VOLUME(JCC)
         ENDDO
      ENDDO
   ELSE ! CORRECTOR
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            ! D = D + w*rho_0*g/(rho*Cp*T)*Vii
            CUT_CELL(ICC)%D(JCC) = CUT_CELL(ICC)%D(JCC) +  &
            CUT_CELL(ICC)%RTRM(JCC)*CUT_CELL(ICC)%WVEL(JCC)* &
            CUT_CELL(ICC)%RHO_0(JCC)*GVEC(KAXIS)*CUT_CELL(ICC)%VOLUME(JCC)
         ENDDO
      ENDDO
   ENDIF
ENDIF

! Manufactured solution

MMS_IF: IF (PERIODIC_TEST==7) THEN
   IF (PREDICTOR) TT=T+DT
   IF (CORRECTOR) TT=T
   ! Regular cells on cut-cell region:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE
            ! this term is similar to D_REACTION from fire
            XHAT = XC(I) - UF_MMS*TT
            ZHAT = ZC(K) - WF_MMS*TT
            DO N=1,N_TRACKED_SPECIES
               SM => SPECIES_MIXTURE(N)
               SELECT CASE(N)
                  CASE(1); Q_Z = -VD2D_MMS_Z_SRC(XHAT,ZHAT,TT)
                  CASE(2); Q_Z =  VD2D_MMS_Z_SRC(XHAT,ZHAT,TT)
               END SELECT
               CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP(I,J,K),H_S)
               DP(I,J,K) = DP(I,J,K) + ( SM%RCON/RSUM(I,J,K) - H_S*R_H_G(I,J,K) )*Q_Z/RHOP(I,J,K)*DX(I)*DY(J)*DZ(K)
            ENDDO
         ENDDO
      ENDDO
   ENDDO
   ! Cut-cells:
   IF (PREDICTOR) THEN
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            ! this term is similar to D_REACTION from fire
            XHAT = CUT_CELL(ICC)%XYZCEN(IAXIS,JCC) - UF_MMS*TT
            ZHAT = CUT_CELL(ICC)%XYZCEN(KAXIS,JCC) - WF_MMS*TT
            TMPV(0) = CUT_CELL(ICC)%TMP(JCC)
            DO N=1,N_TRACKED_SPECIES
               SM => SPECIES_MIXTURE(N)
               SELECT CASE(N)
                  CASE(1); Q_Z = -VD2D_MMS_Z_SRC(XHAT,ZHAT,TT)
                  CASE(2); Q_Z =  VD2D_MMS_Z_SRC(XHAT,ZHAT,TT)
               END SELECT
               CALL GET_SENSIBLE_ENTHALPY_Z(N,TMPV(0),H_S)
               CUT_CELL(ICC)%DS(JCC) = CUT_CELL(ICC)%DS(JCC) +  &
               (SM%RCON/CUT_CELL(ICC)%RSUM(JCC) - H_S*CUT_CELL(ICC)%R_H_G(JCC)) * &
               Q_Z/CUT_CELL(ICC)%RHOS(JCC)*CUT_CELL(ICC)%VOLUME(JCC)
            ENDDO
         ENDDO
      ENDDO
   ELSE ! CORRECTOR
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            ! this term is similar to D_REACTION from fire
            XHAT = CUT_CELL(ICC)%XYZCEN(IAXIS,JCC) - UF_MMS*TT
            ZHAT = CUT_CELL(ICC)%XYZCEN(KAXIS,JCC) - WF_MMS*TT
            TMPV(0) = CUT_CELL(ICC)%TMP(JCC)
            DO N=1,N_TRACKED_SPECIES
               SM => SPECIES_MIXTURE(N)
               SELECT CASE(N)
                  CASE(1); Q_Z = -VD2D_MMS_Z_SRC(XHAT,ZHAT,TT)
                  CASE(2); Q_Z =  VD2D_MMS_Z_SRC(XHAT,ZHAT,TT)
               END SELECT
               CALL GET_SENSIBLE_ENTHALPY_Z(N,TMPV(0),H_S)
               CUT_CELL(ICC)%D(JCC) = CUT_CELL(ICC)%D(JCC) +  &
               (SM%RCON/CUT_CELL(ICC)%RSUM(JCC) - H_S*CUT_CELL(ICC)%R_H_G(JCC)) * &
               Q_Z/CUT_CELL(ICC)%RHO(JCC)*CUT_CELL(ICC)%VOLUME(JCC)
            ENDDO
         ENDDO
      ENDDO
   ENDIF
ENDIF MMS_IF


! Assign divergence on Cartesian Cells:
IF (AVERAGE_LINKDIV) THEN

   ! Average divergence on linked cells:
   ALLOCATE ( DIVRG_VOL(1:NUNKZ_LOCAL) , VOLDVRG(1:NUNKZ_LOCAL) )
   DIVRG_VOL(:) = 0._EB
   VOLDVRG(:)   = 0._EB

   ! Add div*vol for all cells and cut-cells on implicit region:
   ! Regular cells:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE
            ! Unknown number:
            INDZ  = CCVAR(I,J,K,IBM_UNKZ) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
            DIVRG_VOL(INDZ) =  DIVRG_VOL(INDZ) + DP(I,J,K)
            VOLDVRG(INDZ)   =  VOLDVRG(INDZ)   + (DX(I)*DY(J)*DZ(K))
         ENDDO
      ENDDO
   ENDDO

   If (PREDICTOR) THEN
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         I      = CUT_CELL(ICC)%IJK(IAXIS)
         J      = CUT_CELL(ICC)%IJK(JAXIS)
         K      = CUT_CELL(ICC)%IJK(KAXIS)
         DO JCC=1,CUT_CELL(ICC)%NCELL
            INDZ = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
            DIVRG_VOL(INDZ) =  DIVRG_VOL(INDZ) + CUT_CELL(ICC)%DS(JCC)
            VOLDVRG(INDZ)   =  VOLDVRG(INDZ)   + CUT_CELL(ICC)%VOLUME(JCC)
         ENDDO
      ENDDO
   ELSE ! CORRECTOR
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         I      = CUT_CELL(ICC)%IJK(IAXIS)
         J      = CUT_CELL(ICC)%IJK(JAXIS)
         K      = CUT_CELL(ICC)%IJK(KAXIS)
         DO JCC=1,CUT_CELL(ICC)%NCELL
            INDZ = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
            DIVRG_VOL(INDZ) =  DIVRG_VOL(INDZ) + CUT_CELL(ICC)%D(JCC)
            VOLDVRG(INDZ)   =  VOLDVRG(INDZ)   + CUT_CELL(ICC)%VOLUME(JCC)
         ENDDO
      ENDDO
   ENDIF

   ! Here there should be a mesh exchange (add) of div*vol for cases where cut-cells are linked to cells
   ! that belong to other meshes.

   ! Compute final divergence:
   DO INDZ=UNKZ_ILC(NM)+1,UNKZ_ILC(NM)+NUNKZ_LOC(NM)
      DIVRG_VOL(INDZ)=DIVRG_VOL(INDZ)/VOLDVRG(INDZ)
   ENDDO

   ! Finally load final thermodynamic divergence to corresponding cells:
   ! Regular cells:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE
            INDZ  = CCVAR(I,J,K,IBM_UNKZ) - UNKZ_IND(NM_START)
            DP(I,J,K) = DIVRG_VOL(INDZ)
            DEL_RHO_D_DEL_Z(I,J,K,1:N_TRACKED_SPECIES) = DEL_RHO_D_DEL_Z(I,J,K,1:N_TRACKED_SPECIES)/(DX(I)*DY(J)*DZ(K))
         ENDDO
      ENDDO
   ENDDO

   If (PREDICTOR) THEN
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         I      = CUT_CELL(ICC)%IJK(IAXIS)
         J      = CUT_CELL(ICC)%IJK(JAXIS)
         K      = CUT_CELL(ICC)%IJK(KAXIS)
         DIVVOL = 0._EB
         DO JCC=1,CUT_CELL(ICC)%NCELL
            INDZ = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
            CUT_CELL(ICC)%DS(JCC) = DIVRG_VOL(INDZ)*CUT_CELL(ICC)%VOLUME(JCC)
            DIVVOL = DIVVOL + CUT_CELL(ICC)%DS(JCC)
         ENDDO
         DP(I,J,K) = DIVVOL/(DX(I)*DY(J)*DZ(K))
      ENDDO
   ELSE ! CORRECTOR
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         I      = CUT_CELL(ICC)%IJK(IAXIS)
         J      = CUT_CELL(ICC)%IJK(JAXIS)
         K      = CUT_CELL(ICC)%IJK(KAXIS)
         DIVVOL = 0._EB
         DO JCC=1,CUT_CELL(ICC)%NCELL
            INDZ = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
            CUT_CELL(ICC)%D(JCC) = DIVRG_VOL(INDZ)*CUT_CELL(ICC)%VOLUME(JCC)
            DIVVOL = DIVVOL + CUT_CELL(ICC)%D(JCC)
         ENDDO
         DP(I,J,K) = DIVVOL/(DX(I)*DY(J)*DZ(K))
      ENDDO
   ENDIF
   DEALLOCATE ( DIVRG_VOL , VOLDVRG )

ELSE

   ! Regular cells:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE
            DP(I,J,K) = DP(I,J,K)/(DX(I)*DY(J)*DZ(K))
            DEL_RHO_D_DEL_Z(I,J,K,1:N_TRACKED_SPECIES) = DEL_RHO_D_DEL_Z(I,J,K,1:N_TRACKED_SPECIES)/(DX(I)*DY(J)*DZ(K))
         ENDDO
      ENDDO
   ENDDO

   If (PREDICTOR) THEN
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         I      = CUT_CELL(ICC)%IJK(IAXIS)
         J      = CUT_CELL(ICC)%IJK(JAXIS)
         K      = CUT_CELL(ICC)%IJK(KAXIS)
         DIVVOL = 0._EB
         DO JCC=1,CUT_CELL(ICC)%NCELL
            DIVVOL = DIVVOL + CUT_CELL(ICC)%DS(JCC)
         ENDDO
         DP(I,J,K) = DIVVOL/(DX(I)*DY(J)*DZ(K))
      ENDDO
   ELSE ! CORRECTOR
      MINVOL=10000._EB
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         I      = CUT_CELL(ICC)%IJK(IAXIS)
         J      = CUT_CELL(ICC)%IJK(JAXIS)
         K      = CUT_CELL(ICC)%IJK(KAXIS)

         DIVVOL = 0._EB
         DO JCC=1,CUT_CELL(ICC)%NCELL
            DIVVOL = DIVVOL + CUT_CELL(ICC)%D(JCC)
            MINVOL=MIN(MINVOL,CUT_CELL(ICC)%VOLUME(JCC))
         ENDDO
         DP(I,J,K) = DIVVOL/(DX(I)*DY(J)*DZ(K))
      ENDDO
      WRITE(LU_ERR,*) 'MINVOL=',MINVOL
   ENDIF

ENDIF

! Calculate pressure rise in each of the pressure zones by summing divergence expression over each zone

IF_PRESSURE_ZONES: IF (N_ZONE>0) THEN

   USUM(1:N_ZONE,NM) = 0._EB
   DSUM(1:N_ZONE,NM) = 0._EB
   PSUM(1:N_ZONE,NM) = 0._EB

   IF (EVACUATION_ONLY(NM)) RTRM=1._EB

   DO K=1,KBAR
      DO J=1,JBAR
         VC1 = DY(J)*DZ(K)
         DO I=1,IBAR
            IF (INTERPOLATED_MESH(I,J,K)>0) CYCLE
            IPZ = PRESSURE_ZONE(I,J,K)
            IF (IPZ<1) CYCLE
            IF (SOLID(CELL_INDEX(I,J,K))) CYCLE
            VC = DX(I)*RC(I)*VC1
            DSUM(IPZ,NM) = DSUM(IPZ,NM) + VC*DP(I,J,K)
            PSUM(IPZ,NM) = PSUM(IPZ,NM) + VC*(R_PBAR(K,IPZ)-RTRM(I,J,K))
         ENDDO
      ENDDO
   ENDDO

   ! Calculate the volume flux to the boundary of the pressure zone (int u dot dA)

   WALL_LOOP4: DO IW=1,N_EXTERNAL_WALL_CELLS+N_INTERNAL_WALL_CELLS
      WC => WALL(IW)
      IF (INTERPOLATED_MESH(WC%ONE_D%IIG,WC%ONE_D%JJG,WC%ONE_D%KKG)>0) CYCLE
      IPZ = WC%ONE_D%PRESSURE_ZONE
      IF (IPZ<1) CYCLE WALL_LOOP4
      IF (WC%BOUNDARY_TYPE/=SOLID_BOUNDARY) CYCLE WALL_LOOP4
      IF (PREDICTOR) USUM(IPZ,NM) = USUM(IPZ,NM) + WC%ONE_D%UWS*WALL(IW)%ONE_D%AREA
      IF (CORRECTOR) USUM(IPZ,NM) = USUM(IPZ,NM) + WC%ONE_D%UW *WALL(IW)%ONE_D%AREA
   ENDDO WALL_LOOP4

ENDIF IF_PRESSURE_ZONES


DEALLOCATE(ZZ_GET)

RETURN

CONTAINS

! --------------------------- FIX_CCREGION_DIFF_MASS_FLUXES -------------------------

SUBROUTINE FIX_CCREGION_DIFF_MASS_FLUXES

! IAXIS faces:
X1AXIS = IAXIS
DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)
   IW = IBM_REGFACE_IAXIS_Z(IFACE)%IWC
   ! Cycle if boundary condition other then INTERPOLATED, OPEN or PERIODIC, already done in GET_BBREGFACE_RHO_D_DZDN.
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==OPEN_BOUNDARY         .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
   J  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
   K  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)

   ZZ_FACE(1:N_TRACKED_SPECIES) = 0.5_EB*(ZZP(I+FCELL  ,J,K,1:N_TRACKED_SPECIES) + &
                                          ZZP(I+FCELL-1,J,K,1:N_TRACKED_SPECIES))

   N=MAXLOC(ZZ_FACE(1:N_TRACKED_SPECIES),1)

   IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N,LOW_IND) = &
   -(SUM(IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(1:N_TRACKED_SPECIES,LOW_IND))- &
         IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N,LOW_IND))

   NEW_RHO_D_DZDN = &
   -(SUM(IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(1:N_TRACKED_SPECIES,HIGH_IND))- &
         IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND))

   IF (DO_IMPLICIT_CCREGION .AND. ABS(IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND)) > FLX_EPS) &
   IBM_REGFACE_IAXIS_Z(IFACE)%DIFF_FACE(N) = NEW_RHO_D_DZDN* &
   IBM_REGFACE_IAXIS_Z(IFACE)%DIFF_FACE(N)/IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND)

   IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND) = NEW_RHO_D_DZDN
ENDDO

! JAXIS faces:
X1AXIS = JAXIS
DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)
   IW = IBM_REGFACE_JAXIS_Z(IFACE)%IWC
   ! Cycle if boundary condition other then INTERPOLATED, OPEN or PERIODIC, already done in GET_BBREGFACE_RHO_D_DZDN.
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==OPEN_BOUNDARY         .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
   J  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
   K  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)

   ZZ_FACE(1:N_TRACKED_SPECIES) = 0.5_EB*(ZZP(I,J+FCELL  ,K,1:N_TRACKED_SPECIES) + &
                                          ZZP(I,J+FCELL-1,K,1:N_TRACKED_SPECIES))

   N=MAXLOC(ZZ_FACE(1:N_TRACKED_SPECIES),1)

   IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N,LOW_IND) = &
   -(SUM(IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(1:N_TRACKED_SPECIES,LOW_IND))- &
         IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N,LOW_IND))

   NEW_RHO_D_DZDN = &
   -(SUM(IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(1:N_TRACKED_SPECIES,HIGH_IND))- &
         IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND))

   IF (DO_IMPLICIT_CCREGION .AND. ABS(IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND)) > FLX_EPS) &
   IBM_REGFACE_JAXIS_Z(IFACE)%DIFF_FACE(N) = NEW_RHO_D_DZDN* &
   IBM_REGFACE_JAXIS_Z(IFACE)%DIFF_FACE(N)/IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND)

   IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND) = NEW_RHO_D_DZDN
ENDDO

! KAXIS faces:
X1AXIS = KAXIS
DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)
   IW = IBM_REGFACE_KAXIS_Z(IFACE)%IWC
   ! Cycle if boundary condition other then INTERPOLATED, OPEN or PERIODIC, already done in GET_BBREGFACE_RHO_D_DZDN.
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==OPEN_BOUNDARY         .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
   J  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
   K  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)

   ZZ_FACE(1:N_TRACKED_SPECIES) = 0.5_EB*(ZZP(I,J,K+FCELL  ,1:N_TRACKED_SPECIES) + &
                                          ZZP(I,J,K+FCELL-1,1:N_TRACKED_SPECIES))

   N=MAXLOC(ZZ_FACE(1:N_TRACKED_SPECIES),1)

   IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N,LOW_IND) = &
   -(SUM(IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(1:N_TRACKED_SPECIES,LOW_IND))- &
         IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N,LOW_IND))

   NEW_RHO_D_DZDN = &
   -(SUM(IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(1:N_TRACKED_SPECIES,HIGH_IND))- &
         IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND))

   IF (DO_IMPLICIT_CCREGION .AND. ABS(IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND)) > FLX_EPS) &
   IBM_REGFACE_KAXIS_Z(IFACE)%DIFF_FACE(N) = NEW_RHO_D_DZDN* &
   IBM_REGFACE_KAXIS_Z(IFACE)%DIFF_FACE(N)/IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND)

   IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND) = NEW_RHO_D_DZDN
ENDDO

! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
DO IFACE=1,MESHES(NM)%IBM_NRCFACE_Z
   IW = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IWC
   ! Cycle if boundary condition other then INTERPOLATED, OPEN or PERIODIC, already done in GET_BBRCFACE_RHO_D_DZDN.
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==OPEN_BOUNDARY         .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

   ZZ_FACE(1:N_TRACKED_SPECIES) = IBM_RCFACE_Z(IFACE)%ZZ_FACE(1:N_TRACKED_SPECIES)
   N=MAXLOC(ZZ_FACE(1:N_TRACKED_SPECIES),1)

   IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(N,LOW_IND) = -(SUM(IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(1:N_TRACKED_SPECIES,LOW_IND))- &
         IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(N,LOW_IND))

   NEW_RHO_D_DZDN = &
   -(SUM(IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(1:N_TRACKED_SPECIES,HIGH_IND))- &
         IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND))

   IF (DO_IMPLICIT_CCREGION .AND. ABS(IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND)) > FLX_EPS) &
   IBM_RCFACE_Z(IFACE)%DIFF_FACE(N) = NEW_RHO_D_DZDN* &
   IBM_RCFACE_Z(IFACE)%DIFF_FACE(N)/IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND)

   IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND)=NEW_RHO_D_DZDN
ENDDO


! GASPHASE cut-faces:
DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
   IF ( CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
   IW = MESHES(NM)%CUT_FACE(ICF)%IWC
   ! Cycle if boundary condition other then INTERPOLATED, OPEN or PERIODIC, already done in GET_BBCUTFACE_RHO_D_DZDN.
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==OPEN_BOUNDARY         .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

   DO IFACE=1,CUT_FACE(ICF)%NFACE
      ZZ_FACE(1:N_TRACKED_SPECIES) = CUT_FACE(ICF)%ZZ_FACE(1:N_TRACKED_SPECIES,IFACE)

      N=MAXLOC(ZZ_FACE(1:N_TRACKED_SPECIES),1)
      CUT_FACE(ICF)%RHO_D_DZDN(N,LOW_IND,IFACE) = &
      -(SUM(CUT_FACE(ICF)%RHO_D_DZDN(1:N_TRACKED_SPECIES,LOW_IND,IFACE))- &
            CUT_FACE(ICF)%RHO_D_DZDN(N,LOW_IND,IFACE))

      NEW_RHO_D_DZDN = &
      -(SUM(CUT_FACE(ICF)%RHO_D_DZDN(1:N_TRACKED_SPECIES,HIGH_IND,IFACE))- &
            CUT_FACE(ICF)%RHO_D_DZDN(N,HIGH_IND,IFACE))

      IF (DO_IMPLICIT_CCREGION .AND. ABS(CUT_FACE(ICF)%RHO_D_DZDN(N,HIGH_IND,IFACE)) > FLX_EPS) &
      CUT_FACE(ICF)%DIFF_FACE(N,IFACE) = NEW_RHO_D_DZDN* &
      CUT_FACE(ICF)%DIFF_FACE(N,IFACE)/CUT_FACE(ICF)%RHO_D_DZDN(N,HIGH_IND,IFACE)

      CUT_FACE(ICF)%RHO_D_DZDN(N,HIGH_IND,IFACE) = NEW_RHO_D_DZDN
   ENDDO ! IFACE
ENDDO ! ICF

END SUBROUTINE FIX_CCREGION_DIFF_MASS_FLUXES


! ---------------------------- CCSPECIES_ADVECTION ------------------------------

SUBROUTINE CCSPECIES_ADVECTION


! Computes FV version of flux limited \bar{u dot Grad rho Yalpha} in faces near IB
! region and adds components to thermodynamic divergence.

! Local Variables:
REAL(EB) :: RHO_Z_PV(-1:0), VELC, ALPHAP1, AM_P1, AP_P1, FN_ZZ, ZZ_GET_N
REAL(EB), PARAMETER :: SGNFCT=1._EB
INTEGER :: IOR


U_DOT_DEL_RHO_Z=>WORK7
U_DOT_DEL_RHO_Z=0._EB

! Zero out  for species N in cut-cells:
DO ICC=1,MESHES(NM)%N_CUTCELL_MESH+MESHES(NM)%N_GCCUTCELL_MESH
   DO JCC=1,CUT_CELL(ICC)%NCELL
      CUT_CELL(ICC)%U_DOT_DEL_RHO_Z(N,JCC) = 0._EB
   ENDDO
ENDDO


IF (.NOT.ENTHALPY_TRANSPORT) RETURN

! IAXIS faces:
X1AXIS = IAXIS
DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)
   IW = IBM_REGFACE_IAXIS_Z(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
   J  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
   K  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)
   RHOPV(-1:0)      = RHOP(I+FCELL-1:I+FCELL,J,K)
   RHO_Z_PV(-1:0) = 0._EB
   ! Get rho*zz on cells at both sides of IFACE:
   DO ISIDE=-1,0
      RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZP(I+FCELL+ISIDE,J,K,N)
   ENDDO
   ! Now Godunov flux limited value of rho*hs on face:
   VELC = UU(I,J,K)
   ALPHAP1 = SIGN( 1._EB, VELC )
   AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
   AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))

   FN_ZZ = (AM_P1*RHO_Z_PV(-1)+AP_P1*RHO_Z_PV(0)) ! bar{rho*zz}
   ! Add: -(bar{rho*zz} u dot n - (rho*zz) u dot n) to corresponding cell DP:
   AF = DY(J)*DZ(K)
   U_DOT_DEL_RHO_Z(I+FCELL-1,J,K) = U_DOT_DEL_RHO_Z(I+FCELL-1,J,K) + &
                                    SGNFCT*(FN_ZZ-RHO_Z_PV(-1))*VELC*AF ! +ve dot
   U_DOT_DEL_RHO_Z(I+FCELL  ,J,K) = U_DOT_DEL_RHO_Z(I+FCELL  ,J,K) - &
                                    SGNFCT*(FN_ZZ-RHO_Z_PV( 0))*VELC*AF ! -ve dot
ENDDO

! JAXIS faces:
X1AXIS = JAXIS
DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)
   IW = IBM_REGFACE_JAXIS_Z(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
   J  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
   K  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)
   RHOPV(-1:0)      = RHOP(I,J+FCELL-1:J+FCELL,K)
   RHO_Z_PV(-1:0) = 0._EB
   ! Get rho*hs on cells at both sides of IFACE:
   DO ISIDE=-1,0
      RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZP(I,J+FCELL+ISIDE,K,N)
   ENDDO
   ! Now Godunov flux limited value of rho*hs on face:
   VELC = VV(I,J,K)
   ALPHAP1 = SIGN( 1._EB, VELC )
   AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
   AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))

   FN_ZZ = (AM_P1*RHO_Z_PV(-1)+AP_P1*RHO_Z_PV(0)) ! bar{rho*zz}
   ! Add: -(bar{rho*zz} u dot n - (rho*zz) u dot n) to corresponding cell DP:
   AF = DX(I)*DZ(K)
   U_DOT_DEL_RHO_Z(I,J+FCELL-1,K) = U_DOT_DEL_RHO_Z(I,J+FCELL-1,K) + &
                                    SGNFCT*(FN_ZZ-RHO_Z_PV(-1))*VELC*AF ! +ve dot
   U_DOT_DEL_RHO_Z(I,J+FCELL  ,K) = U_DOT_DEL_RHO_Z(I,J+FCELL  ,K) - &
                                    SGNFCT*(FN_ZZ-RHO_Z_PV( 0))*VELC*AF ! -ve dot
ENDDO

! KAXIS faces:
X1AXIS = KAXIS
DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)
   IW = IBM_REGFACE_KAXIS_Z(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
   J  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
   K  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)
   RHOPV(-1:0)      = RHOP(I,J,K+FCELL-1:K+FCELL)
   RHO_Z_PV(-1:0) = 0._EB
   ! Get rho*zz on cells at both sides of IFACE:
   DO ISIDE=-1,0
      RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZP(I,J,K+FCELL+ISIDE,N)
   ENDDO
   ! Now Godunov flux limited value of rho*hs on face:
   VELC = WW(I,J,K)
   ALPHAP1 = SIGN( 1._EB, VELC )
   AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
   AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))

   FN_ZZ = (AM_P1*RHO_Z_PV(-1)+AP_P1*RHO_Z_PV(0)) ! bar{rho*zz}
   ! Add: -(bar{rho*zz} u dot n - (rho*zz) u dot n) to corresponding cell DP:
   AF = DX(I)*DY(J)
   U_DOT_DEL_RHO_Z(I,J,K+FCELL-1) = U_DOT_DEL_RHO_Z(I,J,K+FCELL-1) + &
                                    SGNFCT*(FN_ZZ-RHO_Z_PV(-1))*VELC*AF ! +ve dot
   U_DOT_DEL_RHO_Z(I,J,K+FCELL  ) = U_DOT_DEL_RHO_Z(I,J,K+FCELL  ) - &
                                    SGNFCT*(FN_ZZ-RHO_Z_PV( 0))*VELC*AF ! -ve dot
ENDDO


! Regular faces connecting gasphase - cut-cells:
DO IFACE=1,MESHES(NM)%IBM_NRCFACE_Z
   IW = IBM_RCFACE_Z(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I      = IBM_RCFACE_Z(IFACE)%IJK(IAXIS)
   J      = IBM_RCFACE_Z(IFACE)%IJK(JAXIS)
   K      = IBM_RCFACE_Z(IFACE)%IJK(KAXIS)
   X1AXIS = IBM_RCFACE_Z(IFACE)%IJK(KAXIS+1)
   RHO_Z_PV(-1:0) = 0._EB
   SELECT CASE(X1AXIS)
      CASE(IAXIS)
         AF = DY(J)*DZ(K)
         RHOPV(-1:0)      = RHOP(I+FCELL-1:I+FCELL,J,K)
         DO ISIDE=-1,0
            ZZ_GET = 0._EB
            SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
               ZZ_GET_N = ZZP(I+FCELL+ISIDE,J,K,N)
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
               JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
               RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT) *CUT_CELL(ICC)%RHOS(JCC)
               ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
            END SELECT
            RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
         ENDDO
         ! Now Godunov flux limited value of rho*zz on face:
         VELC = UU(I,J,K)
         ALPHAP1 = SIGN( 1._EB, VELC )
         AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
         AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
         FN_ZZ = (AM_P1*RHO_Z_PV(-1)+AP_P1*RHO_Z_PV(0)) ! bar{rho*zz}
         DO ISIDE=-1,0
            FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
            SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(IBM_FTYPE_RGGAS) ! Regular cell
               U_DOT_DEL_RHO_Z(I+FCELL+ISIDE,J,K) = U_DOT_DEL_RHO_Z(I+FCELL+ISIDE,J,K) + &
               FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC * AF ! +ve or -ve dot
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell
               ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
               IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
               JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
               CUT_CELL(ICC)%U_DOT_DEL_RHO_Z(N,JCC) = CUT_CELL(ICC)%U_DOT_DEL_RHO_Z(N,JCC) + &
               FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC * AF ! +ve or -ve dot
            END SELECT
         ENDDO
      CASE(JAXIS)
         AF = DX(I)*DZ(K)
         RHOPV(-1:0)      = RHOP(I,J+FCELL-1:J+FCELL,K)
         DO ISIDE=-1,0
            ZZ_GET = 0._EB
            SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
               ZZ_GET_N = ZZP(I,J+FCELL+ISIDE,K,N)
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
               JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
               RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT) *CUT_CELL(ICC)%RHOS(JCC)
               ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
            END SELECT
            RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
         ENDDO
         ! Now Godunov flux limited value of rho*zz on face:
         VELC = VV(I,J,K)
         ALPHAP1 = SIGN( 1._EB, VELC )
         AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
         AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
         FN_ZZ = (AM_P1*RHO_Z_PV(-1)+AP_P1*RHO_Z_PV(0)) ! bar{rho*zz}
         DO ISIDE=-1,0
            FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
            SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(IBM_FTYPE_RGGAS) ! Regular cell
               U_DOT_DEL_RHO_Z(I,J+FCELL+ISIDE,K) = U_DOT_DEL_RHO_Z(I,J+FCELL+ISIDE,K) + &
               FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC * AF ! +ve or -ve dot
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell
               ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
               IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
               JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
               CUT_CELL(ICC)%U_DOT_DEL_RHO_Z(N,JCC) = CUT_CELL(ICC)%U_DOT_DEL_RHO_Z(N,JCC) + &
               FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC * AF ! +ve or -ve dot
            END SELECT
         ENDDO
      CASE(KAXIS)
         AF = DX(I)*DY(J)
         RHOPV(-1:0)      = RHOP(I,J,K+FCELL-1:K+FCELL)
         DO ISIDE=-1,0
            ZZ_GET = 0._EB
            SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
               ZZ_GET_N = ZZP(I,J,K+FCELL+ISIDE,N)
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
               JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
               RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)* CUT_CELL(ICC)%RHOS(JCC)
               ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
            END SELECT
            RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
         ENDDO
         ! Now Godunov flux limited value of rho*zz on face:
         VELC = WW(I,J,K)
         ALPHAP1 = SIGN( 1._EB, VELC )
         AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
         AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
         FN_ZZ = (AM_P1*RHO_Z_PV(-1)+AP_P1*RHO_Z_PV(0)) ! bar{rho*zz}
         DO ISIDE=-1,0
            FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
            SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(IBM_FTYPE_RGGAS) ! Regular cell
               U_DOT_DEL_RHO_Z(I,J,K+FCELL+ISIDE) = U_DOT_DEL_RHO_Z(I,J,K+FCELL+ISIDE) + &
               FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC * AF ! +ve or -ve dot
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell
               ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
               IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
               JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
               CUT_CELL(ICC)%U_DOT_DEL_RHO_Z(N,JCC) = CUT_CELL(ICC)%U_DOT_DEL_RHO_Z(N,JCC) + &
               FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC * AF ! +ve or -ve dot
            END SELECT
         ENDDO
   ENDSELECT
ENDDO

! GASPHASE cut-faces:
DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
   IF ( CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
   IW = CUT_FACE(ICF)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I = CUT_FACE(ICF)%IJK(IAXIS)
   J = CUT_FACE(ICF)%IJK(JAXIS)
   K = CUT_FACE(ICF)%IJK(KAXIS)
   X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)
   DO IFACE=1,CUT_FACE(ICF)%NFACE
      AF = CUT_FACE(ICF)%AREA(IFACE)
      ! Interpolate D_Z to the face, linear interpolation:
      RHOPV(-1:0)    = -1._EB
      RHO_Z_PV(-1:0) =  0._EB
      DO ISIDE=-1,0
         SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
         CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
            ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
            JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
            RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT) *CUT_CELL(ICC)%RHOS(JCC)
            ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
         END SELECT
         RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
      ENDDO
      VELC  = PRFCTV *CUT_FACE(ICF)%VEL(IFACE) + (1._EB-PRFCTV)*CUT_FACE(ICF)%VELS(IFACE)
      ALPHAP1 = SIGN( 1._EB, VELC )
      AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
      AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
      FN_ZZ = (AM_P1*RHO_Z_PV(-1)+AP_P1*RHO_Z_PV(0)) ! bar{rho*hs}
      DO ISIDE=-1,0
         FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
         SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
         CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
            ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
            IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
            JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
            CUT_CELL(ICC)%U_DOT_DEL_RHO_Z(N,JCC) = CUT_CELL(ICC)%U_DOT_DEL_RHO_Z(N,JCC) + &
            FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC * AF ! +ve or -ve dot
         END SELECT
      ENDDO
   ENDDO ! IFACE
ENDDO ! ICF

! External Boundary GASPHASE faces:
! IAXIS faces:
X1AXIS = IAXIS
DO IFACE=1,MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)
   IW = IBM_REGFACE_IAXIS_Z(IFACE)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
   I  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
   J  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
   K  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)
   WC => WALL(IW)
   IOR = WC%ONE_D%IOR
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   RHOPV(ISIDE)    = RHOP(I+FCELL+ISIDE,J,K)
   RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZP(I+FCELL+ISIDE,J,K,N)
   FN_ZZ           = WC%ONE_D%RHO_F*WC%ONE_D%ZZ_F(N)
   SELECT CASE(WC%BOUNDARY_TYPE)
      CASE DEFAULT
         VELC = UU(I,J,K)
      CASE(SOLID_BOUNDARY)
         IF (PREDICTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UWS
         IF (CORRECTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UW
   END SELECT
   ! Add: -(bar{rho*zz} u dot n - (rho*zz) u dot n) to corresponding cell DP:
   AF = DY(J)*DZ(K)
   U_DOT_DEL_RHO_Z(I+FCELL+ISIDE,J,K) = U_DOT_DEL_RHO_Z(I+FCELL+ISIDE,J,K) - &
                                        SIGN(1._EB,REAL(IOR,EB))*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
ENDDO

! JAXIS faces:
X1AXIS = JAXIS
DO IFACE=1,MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)
   IW = IBM_REGFACE_JAXIS_Z(IFACE)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
   I  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
   J  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
   K  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)
   WC => WALL(IW)
   IOR = WC%ONE_D%IOR
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   RHOPV(ISIDE)    = RHOP(I,J+FCELL+ISIDE,K)
   RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZP(I,J+FCELL+ISIDE,K,N)
   FN_ZZ           = WC%ONE_D%RHO_F*WC%ONE_D%ZZ_F(N)
   SELECT CASE(WC%BOUNDARY_TYPE)
      CASE DEFAULT
         VELC = VV(I,J,K)
      CASE(SOLID_BOUNDARY)
         IF (PREDICTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UWS
         IF (CORRECTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UW
   END SELECT
   ! Add: -(bar{rho*zz} u dot n - (rho*zz) u dot n) to corresponding cell DP:
   AF = DX(I)*DZ(K)
   U_DOT_DEL_RHO_Z(I,J+FCELL+ISIDE,K) = U_DOT_DEL_RHO_Z(I,J+FCELL+ISIDE,K) - &
                                        SIGN(1._EB,REAL(IOR,EB))*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
ENDDO

! KAXIS faces:
X1AXIS = KAXIS
DO IFACE=1,MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)
   IW = IBM_REGFACE_KAXIS_Z(IFACE)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
   I  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
   J  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
   K  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)
   WC => WALL(IW)
   IOR = WC%ONE_D%IOR
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   RHOPV(ISIDE)    = RHOP(I,J,K+FCELL+ISIDE)
   RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZP(I,J,K+FCELL+ISIDE,N)
   FN_ZZ           = WC%ONE_D%RHO_F*WC%ONE_D%ZZ_F(N)
   SELECT CASE(WC%BOUNDARY_TYPE)
      CASE DEFAULT
         VELC = WW(I,J,K)
      CASE(SOLID_BOUNDARY)
         IF (PREDICTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UWS
         IF (CORRECTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UW
   END SELECT
   ! Add: -(bar{rho*zz} u dot n - (rho*zz) u dot n) to corresponding cell DP:
   AF = DX(I)*DY(J)
   U_DOT_DEL_RHO_Z(I,J,K+FCELL+ISIDE) = U_DOT_DEL_RHO_Z(I,J,K+FCELL+ISIDE) - &
                                        SIGN(1._EB,REAL(IOR,EB))*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
ENDDO

! Regular Faces connecting gasphase cells to cut-cells:
DO IFACE=1,MESHES(NM)%IBM_NBBRCFACE_Z
   IW = IBM_RCFACE_Z(IFACE)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
   I      = IBM_RCFACE_Z(IFACE)%IJK(IAXIS)
   J      = IBM_RCFACE_Z(IFACE)%IJK(JAXIS)
   K      = IBM_RCFACE_Z(IFACE)%IJK(KAXIS)
   X1AXIS = IBM_RCFACE_Z(IFACE)%IJK(KAXIS+1)
   WC => WALL(IW)
   IOR = WC%ONE_D%IOR
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
   ! First (rho hs)_i,j,k:
   SELECT CASE(X1AXIS)
   CASE(IAXIS)
      AF = DY(J)*DZ(K)
      VELC = UU(I,J,K)
      RHOPV(ISIDE)      = RHOP(I+FCELL+ISIDE,J,K)
      SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
      CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
         ZZ_GET_N = ZZP(I+FCELL+ISIDE,J,K,N)
      CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
         ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
         JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
         RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)* CUT_CELL(ICC)%RHOS(JCC)
         ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
      END SELECT
   CASE(JAXIS)
      AF = DX(I)*DZ(K)
      VELC = VV(I,J,K)
      RHOPV(ISIDE)      = RHOP(I,J+FCELL+ISIDE,K)
      SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
      CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
         ZZ_GET_N = ZZP(I,J+FCELL+ISIDE,K,N)
      CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
         ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
         JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
         RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)* CUT_CELL(ICC)%RHOS(JCC)
         ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
      END SELECT
   CASE(KAXIS)
      AF = DX(I)*DY(J)
      VELC = WW(I,J,K)
      RHOPV(ISIDE)      = RHOP(I,J,K+FCELL+ISIDE)
      SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
      CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
         ZZ_GET_N = ZZP(I,J,K+FCELL+ISIDE,N)
      CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
         ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
         JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
         RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)* CUT_CELL(ICC)%RHOS(JCC)
         ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
      END SELECT
   END SELECT
   RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
   FN_ZZ           = WC%ONE_D%RHO_F*WC%ONE_D%ZZ_F(N)
   SELECT CASE(WC%BOUNDARY_TYPE)
      CASE DEFAULT
         ! Already filled in previous X1AXIS select case.
      CASE(SOLID_BOUNDARY)
         IF (PREDICTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UWS
         IF (CORRECTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UW
   END SELECT
   SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
   CASE(IBM_FTYPE_RGGAS)
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
        U_DOT_DEL_RHO_Z(I+FCELL+ISIDE,J,K)=U_DOT_DEL_RHO_Z(I+FCELL+ISIDE,J,K)+FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
      CASE(JAXIS)
        U_DOT_DEL_RHO_Z(I,J+FCELL+ISIDE,K)=U_DOT_DEL_RHO_Z(I,J+FCELL+ISIDE,K)+FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
      CASE(KAXIS)
        U_DOT_DEL_RHO_Z(I,J,K+FCELL+ISIDE)=U_DOT_DEL_RHO_Z(I,J,K+FCELL+ISIDE)+FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
      END SELECT
   CASE(IBM_FTYPE_CFGAS) ! Cut-cell
      ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
      JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
      CUT_CELL(ICC)%U_DOT_DEL_RHO_Z(N,JCC)=CUT_CELL(ICC)%U_DOT_DEL_RHO_Z(N,JCC) + &
                                           FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
   END SELECT
ENDDO

! Finally Gasphase cut-faces:
DO ICF = 1,MESHES(NM)%N_BBCUTFACE_MESH
   IF ( CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
   IW = CUT_FACE(ICF)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
   WC => WALL(IW)
   IOR = WC%ONE_D%IOR
   FN_ZZ           = WC%ONE_D%RHO_F*WC%ONE_D%ZZ_F(N)
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
   DO IFACE=1,CUT_FACE(ICF)%NFACE
      AF   = CUT_FACE(ICF)%AREA(IFACE)
      VELC = PRFCT*CUT_FACE(ICF)%VEL(IFACE) + (1._EB-PRFCT)*CUT_FACE(ICF)%VELS(IFACE)
      ! First (rho hs)_i,j,k:
      IF (CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE) == IBM_FTYPE_CFGAS) THEN
         ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
         JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
         RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT) *CUT_CELL(ICC)%RHOS(JCC)
         ZZ_GET_N     = PRFCT*CUT_CELL(ICC)%ZZ(N,JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
         RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZ_GET_N
         CUT_CELL(ICC)%U_DOT_DEL_RHO_Z(N,JCC)=CUT_CELL(ICC)%U_DOT_DEL_RHO_Z(N,JCC) + &
                                              FCT*SGNFCT*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
      ENDIF
   ENDDO ! IFACE
ENDDO ! ICF

! INBOUNDARY cut-faces: The contribution to scalar advection and enthalpy advection for case of non trivial
! solid boundary conditions should be included here.


! EXIM faces:
DO IEXIM=1,MESHES(NM)%IBM_NEXIMFACE_MESH
   I      = IBM_EXIM_FACE(IEXIM)%IJK(IAXIS)
   J      = IBM_EXIM_FACE(IEXIM)%IJK(JAXIS)
   K      = IBM_EXIM_FACE(IEXIM)%IJK(KAXIS)
   X1AXIS = IBM_EXIM_FACE(IEXIM)%IJK(KAXIS+1)
   LHFACE = IBM_EXIM_FACE(IEXIM)%LHFACE
   AF     = IBM_EXIM_FACE(IEXIM)%AREA
   IW     = IBM_EXIM_FACE(IEXIM)%IWC
   IF((IW>0) .AND. WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY) CYCLE
   FN_ZZ  = IBM_EXIM_FACE(IEXIM)%FN_ZZ(N)
   RHO_Z_PV(-1:0)   = 0._EB
   IF((IW>0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                         WALL(IW)%BOUNDARY_TYPE==OPEN_BOUNDARY         .OR. &
                         WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY) ) THEN ! Boundary faces, re-compute EXIM faces
                                                                           ! RHO_D_DZDN
       WC => WALL(IW)
       IOR = WC%ONE_D%IOR
       ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
       !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
       ISIDE = -1 + (SIGN(1,IOR)+1) / 2
       SELECT CASE(WC%BOUNDARY_TYPE)
          CASE DEFAULT
             SELECT CASE(X1AXIS)
             CASE(IAXIS)
                VELC = UU(I,J,K)
             CASE(JAXIS)
                VELC = VV(I,J,K)
             CASE(KAXIS)
                VELC = WW(I,J,K)
             END SELECT
          CASE(SOLID_BOUNDARY)
             IF (PREDICTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UWS
             IF (CORRECTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UW
       END SELECT
       SELECT CASE(X1AXIS)
       CASE(IAXIS)
          RHOPV(ISIDE)    = RHOP(I+FCELL+ISIDE,J,K)
          RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZP(I+FCELL+ISIDE,J,K,N)
          AF = DY(J)*DZ(K)
          U_DOT_DEL_RHO_Z(I+FCELL+ISIDE,J,K) = U_DOT_DEL_RHO_Z(I+FCELL+ISIDE,J,K) - &
                                               SIGN(1._EB,REAL(IOR,EB))*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
       CASE(JAXIS)
          RHOPV(ISIDE)    = RHOP(I,J+FCELL+ISIDE,K)
          RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZP(I,J+FCELL+ISIDE,K,N)
          AF = DX(I)*DZ(K)
          U_DOT_DEL_RHO_Z(I,J+FCELL+ISIDE,K) = U_DOT_DEL_RHO_Z(I,J+FCELL+ISIDE,K) - &
                                               SIGN(1._EB,REAL(IOR,EB))*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
       CASE(KAXIS)
          RHOPV(ISIDE)    = RHOP(I,J,K+FCELL+ISIDE)
          RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZP(I,J,K+FCELL+ISIDE,N)
          AF = DX(I)*DY(J)
          U_DOT_DEL_RHO_Z(I,J,K+FCELL+ISIDE) = U_DOT_DEL_RHO_Z(I,J,K+FCELL+ISIDE) - &
                                               SIGN(1._EB,REAL(IOR,EB))*(FN_ZZ-RHO_Z_PV(ISIDE))*VELC*AF
       END SELECT

   ELSE ! Regular cases and internal EXIM faces:

      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         RHOPV(-1:0)  = RHOP(I+FCELL-1:I+FCELL,J,K)
         DO ISIDE=-1,0
            RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZP(I+FCELL+ISIDE,J,K,N)
         ENDDO
         VELC = UU(I,J,K)
         IF ( (IW>0) .AND. (WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) ) VELC = UVW_SAVE(IW)
         IF(LHFACE == LOW_IND) THEN ! Face on low side of cell
            U_DOT_DEL_RHO_Z(I+FCELL  ,J,K)=U_DOT_DEL_RHO_Z(I+FCELL  ,J,K)-SGNFCT*(FN_ZZ-RHO_Z_PV( 0))*VELC*AF ! -ve dot
         ELSE ! Face on high side of cell
            U_DOT_DEL_RHO_Z(I+FCELL-1,J,K)=U_DOT_DEL_RHO_Z(I+FCELL-1,J,K)+SGNFCT*(FN_ZZ-RHO_Z_PV(-1))*VELC*AF ! +ve dot
         ENDIF
      CASE(JAXIS)
         RHOPV(-1:0)  = RHOP(I,J+FCELL-1:J+FCELL,K)
         DO ISIDE=-1,0
            RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZP(I,J+FCELL+ISIDE,K,N)
         ENDDO
         VELC = VV(I,J,K)
         IF ( (IW>0) .AND. (WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) ) VELC = UVW_SAVE(IW)
         IF(LHFACE == LOW_IND) THEN ! Face on low side of cell
            U_DOT_DEL_RHO_Z(I,J+FCELL  ,K)=U_DOT_DEL_RHO_Z(I,J+FCELL  ,K)-SGNFCT*(FN_ZZ-RHO_Z_PV( 0))*VELC*AF ! -ve dot
         ELSE ! Face on high side of cell
            U_DOT_DEL_RHO_Z(I,J+FCELL-1,K)=U_DOT_DEL_RHO_Z(I,J+FCELL-1,K)+SGNFCT*(FN_ZZ-RHO_Z_PV(-1))*VELC*AF ! +ve dot
         ENDIF
      CASE(KAXIS)
         RHOPV(-1:0)  = RHOP(I,J,K+FCELL-1:K+FCELL)
         DO ISIDE=-1,0
            RHO_Z_PV(ISIDE) = RHOPV(ISIDE)*ZZP(I,J,K+FCELL+ISIDE,N)
         ENDDO
         VELC = WW(I,J,K)
         IF ( (IW>0) .AND. (WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) ) VELC = UVW_SAVE(IW)
         ! Add to divergence integral of surrounding cut-cell:
         IF(LHFACE == LOW_IND) THEN ! Face on low side of cell
            U_DOT_DEL_RHO_Z(I,J,K+FCELL  )=U_DOT_DEL_RHO_Z(I,J,K+FCELL  )-SGNFCT*(FN_ZZ-RHO_Z_PV( 0))*VELC*AF ! -ve dot
         ELSE ! Face on high side of cell
            U_DOT_DEL_RHO_Z(I,J,K+FCELL-1)=U_DOT_DEL_RHO_Z(I,J,K+FCELL-1)+SGNFCT*(FN_ZZ-RHO_Z_PV(-1))*VELC*AF ! +ve dot
         ENDIF
      END SELECT
   ENDIF
ENDDO


RETURN
END SUBROUTINE CCSPECIES_ADVECTION


! ---------------------------- CCENTHALPY_ADVECTION -----------------------------

SUBROUTINE CCENTHALPY_ADVECTION


! Computes FV version of flux limited \bar{ u dot Grad rho hs} in faces of near IB
! region and adds components to thermodynamic divergence.


! Local Variables:
REAL(EB) :: RHO_H_S_PV(-1:0), VELC, VELC2, ALPHAP1, AM_P1, AP_P1, FN_H_S, TMP_F_GAS
INTEGER  :: IOR


IF (.NOT.ENTHALPY_TRANSPORT) RETURN

! IAXIS faces:
X1AXIS = IAXIS
DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)
   IW = IBM_REGFACE_IAXIS_Z(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
   J  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
   K  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)
   RHOPV(-1:0)      = RHOP(I+FCELL-1:I+FCELL,J,K)
   TMPV(-1:0)       =  TMP(I+FCELL-1:I+FCELL,J,K)
   RHO_H_S_PV(-1:0) = 0._EB
   ! Get rho*hs on cells at both sides of IFACE:
   DO ISIDE=-1,0
      ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I+FCELL+ISIDE,J,K,1:N_TRACKED_SPECIES)
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
      RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
   ENDDO

   ! Now Godunov flux limited value of rho*hs on face:
   VELC = UU(I,J,K)
   ALPHAP1 = SIGN( 1._EB, VELC )
   AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
   AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))

   FN_H_S = (AM_P1*RHO_H_S_PV(-1)+AP_P1*RHO_H_S_PV(0)) ! bar{rho*hs}
   ! Add: -(bar{rho*hs} u dot n - (rho*hs) u dot n) to corresponding cell DP:
   AF = DY(J)*DZ(K)
   DP(I+FCELL-1,J,K) = DP(I+FCELL-1,J,K) + (-1._EB)*(FN_H_S-RHO_H_S_PV(-1))*VELC*AF ! +ve dot
   DP(I+FCELL  ,J,K) = DP(I+FCELL  ,J,K) - (-1._EB)*(FN_H_S-RHO_H_S_PV( 0))*VELC*AF ! -ve dot
ENDDO

! JAXIS faces:
X1AXIS = JAXIS
DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)
   IW = IBM_REGFACE_JAXIS_Z(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
   J  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
   K  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)
   RHOPV(-1:0)      = RHOP(I,J+FCELL-1:J+FCELL,K)
   TMPV(-1:0)       =  TMP(I,J+FCELL-1:J+FCELL,K)
   RHO_H_S_PV(-1:0) = 0._EB
   ! Get rho*hs on cells at both sides of IFACE:
   DO ISIDE=-1,0
      ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J+FCELL+ISIDE,K,1:N_TRACKED_SPECIES)
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
      RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
   ENDDO

   ! Now Godunov flux limited value of rho*hs on face:
   VELC = VV(I,J,K)
   ALPHAP1 = SIGN( 1._EB, VELC )
   AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
   AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))

   FN_H_S = (AM_P1*RHO_H_S_PV(-1)+AP_P1*RHO_H_S_PV(0)) ! bar{rho*hs}
   ! Add: -(bar{rho*hs} u dot n - (rho*hs) u dot n) to corresponding cell DP:
   AF = DX(I)*DZ(K)
   DP(I,J+FCELL-1,K) = DP(I,J+FCELL-1,K) + (-1._EB)*(FN_H_S-RHO_H_S_PV(-1))*VELC*AF ! +ve dot
   DP(I,J+FCELL  ,K) = DP(I,J+FCELL  ,K) - (-1._EB)*(FN_H_S-RHO_H_S_PV( 0))*VELC*AF ! -ve dot
ENDDO

! KAXIS faces:
X1AXIS = KAXIS
DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)
   IW = IBM_REGFACE_KAXIS_Z(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
   J  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
   K  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)
   RHOPV(-1:0)      = RHOP(I,J,K+FCELL-1:K+FCELL)
   TMPV(-1:0)       =  TMP(I,J,K+FCELL-1:K+FCELL)
   RHO_H_S_PV(-1:0) = 0._EB
   ! Get rho*hs on cells at both sides of IFACE:
   DO ISIDE=-1,0
      ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K+FCELL+ISIDE,1:N_TRACKED_SPECIES)
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
      RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
   ENDDO

   ! Now Godunov flux limited value of rho*hs on face:
   VELC = WW(I,J,K)
   ALPHAP1 = SIGN( 1._EB, VELC )
   AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
   AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))

   FN_H_S = (AM_P1*RHO_H_S_PV(-1)+AP_P1*RHO_H_S_PV(0)) ! bar{rho*hs}
   ! Add: -(bar{rho*hs} u dot n - (rho*hs) u dot n) to corresponding cell DP:
   AF = DX(I)*DY(J)
   DP(I,J,K+FCELL-1) = DP(I,J,K+FCELL-1) + (-1._EB)*(FN_H_S-RHO_H_S_PV(-1))*VELC*AF ! +ve dot
   DP(I,J,K+FCELL  ) = DP(I,J,K+FCELL  ) - (-1._EB)*(FN_H_S-RHO_H_S_PV( 0))*VELC*AF ! -ve dot
ENDDO


! Regular faces connecting gasphase - cut-cells:
DO IFACE=1,MESHES(NM)%IBM_NRCFACE_Z
   IW = IBM_RCFACE_Z(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I      = IBM_RCFACE_Z(IFACE)%IJK(IAXIS)
   J      = IBM_RCFACE_Z(IFACE)%IJK(JAXIS)
   K      = IBM_RCFACE_Z(IFACE)%IJK(KAXIS)
   X1AXIS = IBM_RCFACE_Z(IFACE)%IJK(KAXIS+1)
   RHO_H_S_PV(-1:0) = 0._EB
   SELECT CASE(X1AXIS)
      CASE(IAXIS)
         AF = DY(J)*DZ(K)
         RHOPV(-1:0)      = RHOP(I+FCELL-1:I+FCELL,J,K)
         TMPV(-1:0)       =  TMP(I+FCELL-1:I+FCELL,J,K)
         DO ISIDE=-1,0
            ZZ_GET = 0._EB
            SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
               ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I+FCELL+ISIDE,J,K,1:N_TRACKED_SPECIES)
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
               JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
               TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
               RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
               ZZ_GET(1:N_TRACKED_SPECIES) =  PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                                       (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
            END SELECT
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
            RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
         ENDDO

         ! Now Godunov flux limited value of rho*hs on face:
         VELC = UU(I,J,K)
         ALPHAP1 = SIGN( 1._EB, VELC )
         AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
         AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
         FN_H_S = (AM_P1*RHO_H_S_PV(-1)+AP_P1*RHO_H_S_PV(0)) ! bar{rho*hs}

         ! Add contribution to DP:
         DO ISIDE=-1,0
            FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
            SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(IBM_FTYPE_RGGAS) ! Regular cell
               DP(I+FCELL+ISIDE,J,K)=DP(I+FCELL+ISIDE,J,K)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF !+ve/-ve dot
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell
               ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
               IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
               JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
               IF (PREDICTOR) THEN
                  CUT_CELL(ICC)%DS(JCC)=CUT_CELL(ICC)%DS(JCC)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
               ELSE
                  CUT_CELL(ICC)%D(JCC) =CUT_CELL(ICC)%D(JCC) +FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
               ENDIF
            END SELECT
         ENDDO

      CASE(JAXIS)
         AF = DX(I)*DZ(K)
         RHOPV(-1:0)      = RHOP(I,J+FCELL-1:J+FCELL,K)
         TMPV(-1:0)       =  TMP(I,J+FCELL-1:J+FCELL,K)
         DO ISIDE=-1,0
            ZZ_GET = 0._EB
            SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
               ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J+FCELL+ISIDE,K,1:N_TRACKED_SPECIES)
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
               JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
               TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
               RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
               ZZ_GET(1:N_TRACKED_SPECIES) =  PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                                       (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
            END SELECT
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
            RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
         ENDDO

         ! Now Godunov flux limited value of rho*hs on face:
         VELC = VV(I,J,K)
         ALPHAP1 = SIGN( 1._EB, VELC )
         AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
         AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
         FN_H_S = (AM_P1*RHO_H_S_PV(-1)+AP_P1*RHO_H_S_PV(0)) ! bar{rho*hs}

         ! Add contribution to DP:
         DO ISIDE=-1,0
            FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
            SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(IBM_FTYPE_RGGAS) ! Regular cell
               DP(I,J+FCELL+ISIDE,K)=DP(I,J+FCELL+ISIDE,K)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF !+ve/-ve dot
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell
               ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
               IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
               JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
               IF (PREDICTOR) THEN
                  CUT_CELL(ICC)%DS(JCC)=CUT_CELL(ICC)%DS(JCC)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
               ELSE
                  CUT_CELL(ICC)%D(JCC) =CUT_CELL(ICC)%D(JCC) +FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
               ENDIF
            END SELECT
         ENDDO

      CASE(KAXIS)
         AF = DX(I)*DY(J)
         RHOPV(-1:0)      = RHOP(I,J,K+FCELL-1:K+FCELL)
         TMPV(-1:0)       =  TMP(I,J,K+FCELL-1:K+FCELL)
         DO ISIDE=-1,0
            ZZ_GET = 0._EB
            SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
               ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K+FCELL+ISIDE,1:N_TRACKED_SPECIES)
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
               JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
               TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
               RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
               ZZ_GET(1:N_TRACKED_SPECIES) =  PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                                       (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
            END SELECT
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
            RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
         ENDDO

         ! Now Godunov flux limited value of rho*hs on face:
         VELC = WW(I,J,K)
         ALPHAP1 = SIGN( 1._EB, VELC )
         AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
         AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
         FN_H_S = (AM_P1*RHO_H_S_PV(-1)+AP_P1*RHO_H_S_PV(0)) ! bar{rho*hs}

         ! Add contribution to DP:
         ! Low side cell:
         DO ISIDE=-1,0
            FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
            SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(IBM_FTYPE_RGGAS) ! Regular cell
               DP(I,J,K+FCELL+ISIDE)=DP(I,J,K+FCELL+ISIDE)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF !+ve/-ve dot
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell
               ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
               IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
               JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
               IF (PREDICTOR) THEN
                  CUT_CELL(ICC)%DS(JCC)=CUT_CELL(ICC)%DS(JCC)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
               ELSE
                  CUT_CELL(ICC)%D(JCC) =CUT_CELL(ICC)%D(JCC) +FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
               ENDIF
            END SELECT
         ENDDO

   ENDSELECT

ENDDO

! GASPHASE cut-faces:
DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
   IF ( CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
   IW = CUT_FACE(ICF)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I = CUT_FACE(ICF)%IJK(IAXIS)
   J = CUT_FACE(ICF)%IJK(JAXIS)
   K = CUT_FACE(ICF)%IJK(KAXIS)
   X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)
   DO IFACE=1,CUT_FACE(ICF)%NFACE
      AF = CUT_FACE(ICF)%AREA(IFACE)
      RHOPV(-1:0)      = -1._EB
      TMPV(-1:0)       = -1._EB
      RHO_H_S_PV(-1:0) =  0._EB
      DO ISIDE=-1,0
         ZZ_GET = 0._EB
         SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
         CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
            ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
            JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
            TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
            RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
            ZZ_GET(1:N_TRACKED_SPECIES) =  PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                                    (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
         END SELECT
         CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
         RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
      ENDDO

      VELC    = PRFCTV *CUT_FACE(ICF)%VEL(IFACE) + (1._EB-PRFCTV)*CUT_FACE(ICF)%VELS(IFACE)
      ALPHAP1 = SIGN( 1._EB, VELC )
      AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
      AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
      FN_H_S = (AM_P1*RHO_H_S_PV(-1)+AP_P1*RHO_H_S_PV(0)) ! bar{rho*hs}

      ! Add to divergence integral of surrounding cut-cells:
      DO ISIDE=-1,0
         FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
         SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
         CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
            ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
            IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
            JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
            IF (PREDICTOR) THEN
               CUT_CELL(ICC)%DS(JCC)=CUT_CELL(ICC)%DS(JCC)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
            ELSE
               CUT_CELL(ICC)%D(JCC) =CUT_CELL(ICC)%D(JCC) +FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
            ENDIF
         END SELECT
      ENDDO
   ENDDO ! IFACE
ENDDO ! ICF

! Now work with boundary faces:
! IAXIS faces:
X1AXIS = IAXIS
DO IFACE=1,MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)
   IW = IBM_REGFACE_IAXIS_Z(IFACE)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
   I  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
   J  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
   K  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)
   WC => WALL(IW)
   IOR = WC%ONE_D%IOR
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   RHOPV(ISIDE)      = RHOP(I+FCELL+ISIDE,J,K)
   TMPV(ISIDE)       =  TMP(I+FCELL+ISIDE,J,K)
   ! Get rho*hs on cells at both sides of IFACE:
   ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I+FCELL+ISIDE,J,K,1:N_TRACKED_SPECIES)
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
   RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
   ! Calculate the sensible enthalpy at the boundary. If the boundary is solid
   ! and the gas is flowing out, use the gas temperature for the calculation.
   IF (PREDICTOR) THEN
      VELC2 = WC%ONE_D%UWS
   ELSE
      VELC2 = WC%ONE_D%UW
   ENDIF
   IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY .AND. VELC2>0._EB) THEN
      TMP_F_GAS = WC%ONE_D%TMP_G
   ELSE
      TMP_F_GAS = WC%ONE_D%TMP_F
   ENDIF
   ZZ_GET(1:N_TRACKED_SPECIES) = WC%ONE_D%ZZ_F(1:N_TRACKED_SPECIES)
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP_F_GAS)
   SELECT CASE(WC%BOUNDARY_TYPE)
      CASE DEFAULT
         VELC = UU(I,J,K)
      CASE(SOLID_BOUNDARY)
         IF (PREDICTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UWS
         IF (CORRECTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UW
   END SELECT
   FN_H_S = WC%ONE_D%RHO_F*H_S ! bar{rho*hs}
   ! Add: -(bar{rho*hs} u dot n - (rho*hs) u dot n) to corresponding cell DP:
   AF = DY(J)*DZ(K)
   DP(I+FCELL+ISIDE,J,K) = DP(I+FCELL+ISIDE,J,K) + SIGN(1._EB,REAL(IOR,EB))*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
ENDDO

! JAXIS faces:
X1AXIS = JAXIS
DO IFACE=1,MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)
   IW = IBM_REGFACE_JAXIS_Z(IFACE)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
   I  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
   J  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
   K  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)
   WC => WALL(IW)
   IOR = WC%ONE_D%IOR
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   RHOPV(ISIDE)      = RHOP(I,J+FCELL+ISIDE,K)
   TMPV(ISIDE)       =  TMP(I,J+FCELL+ISIDE,K)
   ! Get rho*hs on cells at both sides of IFACE:
   ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J+FCELL+ISIDE,K,1:N_TRACKED_SPECIES)
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
   RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
   ! Calculate the sensible enthalpy at the boundary. If the boundary is solid
   ! and the gas is flowing out, use the gas temperature for the calculation.
   IF (PREDICTOR) THEN
      VELC2 = WC%ONE_D%UWS
   ELSE
      VELC2 = WC%ONE_D%UW
   ENDIF
   IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY .AND. VELC2>0._EB) THEN
      TMP_F_GAS = WC%ONE_D%TMP_G
   ELSE
      TMP_F_GAS = WC%ONE_D%TMP_F
   ENDIF
   ZZ_GET(1:N_TRACKED_SPECIES) = WC%ONE_D%ZZ_F(1:N_TRACKED_SPECIES)
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP_F_GAS)
   SELECT CASE(WC%BOUNDARY_TYPE)
      CASE DEFAULT
         VELC = VV(I,J,K)
      CASE(SOLID_BOUNDARY)
         IF (PREDICTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UWS
         IF (CORRECTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UW
   END SELECT
   FN_H_S = WC%ONE_D%RHO_F*H_S ! bar{rho*hs}
   ! Add: -(bar{rho*hs} u dot n - (rho*hs) u dot n) to corresponding cell DP:
   AF = DX(I)*DZ(K)
   DP(I,J+FCELL+ISIDE,K) = DP(I,J+FCELL+ISIDE,K) + SIGN(1._EB,REAL(IOR,EB))*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
ENDDO

! KAXIS faces:
X1AXIS = KAXIS
DO IFACE=1,MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)
   IW = IBM_REGFACE_KAXIS_Z(IFACE)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
   I  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
   J  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
   K  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)
   WC => WALL(IW)
   IOR = WC%ONE_D%IOR
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   RHOPV(ISIDE)      = RHOP(I,J,K+FCELL+ISIDE)
   TMPV(ISIDE)       =  TMP(I,J,K+FCELL+ISIDE)
   ! Get rho*hs on cells at both sides of IFACE:
   ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K+FCELL+ISIDE,1:N_TRACKED_SPECIES)
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
   RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
   ! Calculate the sensible enthalpy at the boundary. If the boundary is solid
   ! and the gas is flowing out, use the gas temperature for the calculation.
   IF (PREDICTOR) THEN
      VELC2 = WC%ONE_D%UWS
   ELSE
      VELC2 = WC%ONE_D%UW
   ENDIF
   IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY .AND. VELC2>0._EB) THEN
      TMP_F_GAS = WC%ONE_D%TMP_G
   ELSE
      TMP_F_GAS = WC%ONE_D%TMP_F
   ENDIF
   ZZ_GET(1:N_TRACKED_SPECIES) = WC%ONE_D%ZZ_F(1:N_TRACKED_SPECIES)
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP_F_GAS)
   SELECT CASE(WC%BOUNDARY_TYPE)
      CASE DEFAULT
         VELC = WW(I,J,K)
      CASE(SOLID_BOUNDARY)
         IF (PREDICTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UWS
         IF (CORRECTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UW
   END SELECT
   FN_H_S = WC%ONE_D%RHO_F*H_S ! bar{rho*hs}
   ! Add: -(bar{rho*hs} u dot n - (rho*hs) u dot n) to corresponding cell DP:
   AF = DX(I)*DY(J)
   DP(I,J,K+FCELL+ISIDE) = DP(I,J,K+FCELL+ISIDE) + SIGN(1._EB,REAL(IOR,EB))*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
ENDDO

! Regular Faces connecting gasphase cells to cut-cells:
DO IFACE=1,MESHES(NM)%IBM_NBBRCFACE_Z
   IW = IBM_RCFACE_Z(IFACE)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
   I      = IBM_RCFACE_Z(IFACE)%IJK(IAXIS)
   J      = IBM_RCFACE_Z(IFACE)%IJK(JAXIS)
   K      = IBM_RCFACE_Z(IFACE)%IJK(KAXIS)
   X1AXIS = IBM_RCFACE_Z(IFACE)%IJK(KAXIS+1)
   WC => WALL(IW)
   IOR = WC%ONE_D%IOR
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   FCT   = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
   ! First (rho hs)_i,j,k:
   SELECT CASE(X1AXIS)
   CASE(IAXIS)
      AF = DY(J)*DZ(K)
      VELC = UU(I,J,K)
      RHOPV(ISIDE)      = RHOP(I+FCELL+ISIDE,J,K)
      TMPV(ISIDE)       =  TMP(I+FCELL+ISIDE,J,K)
      SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
      CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
         ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I+FCELL+ISIDE,J,K,1:N_TRACKED_SPECIES)
      CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
         ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
         JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
         TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
         RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
         ZZ_GET(1:N_TRACKED_SPECIES) =  PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                                 (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
      END SELECT
   CASE(JAXIS)
      AF = DX(I)*DZ(K)
      VELC = VV(I,J,K)
      RHOPV(ISIDE)      = RHOP(I,J+FCELL+ISIDE,K)
      TMPV(ISIDE)       =  TMP(I,J+FCELL+ISIDE,K)
      SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
      CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
         ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J+FCELL+ISIDE,K,1:N_TRACKED_SPECIES)
      CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
         ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
         JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
         TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
         RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
         ZZ_GET(1:N_TRACKED_SPECIES) =  PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                                 (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
      END SELECT
   CASE(KAXIS)
      AF = DX(I)*DY(J)
      VELC = WW(I,J,K)
      RHOPV(ISIDE)      = RHOP(I,J,K+FCELL+ISIDE)
      TMPV(ISIDE)       =  TMP(I,J,K+FCELL+ISIDE)
      SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
      CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
         ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K+FCELL+ISIDE,1:N_TRACKED_SPECIES)
      CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
         ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
         JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
         TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
         RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
         ZZ_GET(1:N_TRACKED_SPECIES) =  PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                                 (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
      END SELECT
   END SELECT
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
   RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S

   ! Flux limited face value bar{rho*hs}_F
   ! Calculate the sensible enthalpy at the boundary. If the boundary is solid
   ! and the gas is flowing out, use the gas temperature for the calculation.
   IF (PREDICTOR) THEN
      VELC2 = WC%ONE_D%UWS
   ELSE
      VELC2 = WC%ONE_D%UW
   ENDIF
   IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY .AND. VELC2>0._EB) THEN
      TMP_F_GAS = WC%ONE_D%TMP_G
   ELSE
      TMP_F_GAS = WC%ONE_D%TMP_F
   ENDIF
   ZZ_GET(1:N_TRACKED_SPECIES) = WC%ONE_D%ZZ_F(1:N_TRACKED_SPECIES)
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP_F_GAS)
   SELECT CASE(WC%BOUNDARY_TYPE)
      CASE DEFAULT
         ! Already filled in previous X1AXIS select case.
      CASE(SOLID_BOUNDARY)
         IF (PREDICTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UWS
         IF (CORRECTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UW
   END SELECT
   FN_H_S = WC%ONE_D%RHO_F*H_S ! bar{rho*hs}
   ! Finally add to Div:
   SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
   CASE(IBM_FTYPE_RGGAS) ! Regular cell
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         DP(I+FCELL+ISIDE,J,K)=DP(I+FCELL+ISIDE,J,K)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF !+ve/-ve dot
      CASE(JAXIS)
         DP(I,J+FCELL+ISIDE,K)=DP(I,J+FCELL+ISIDE,K)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
      CASE(KAXIS)
         DP(I,J,K+FCELL+ISIDE)=DP(I,J,K+FCELL+ISIDE)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
      END SELECT
   CASE(IBM_FTYPE_CFGAS) ! Cut-cell
      ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
      JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
      IF (PREDICTOR) THEN
         CUT_CELL(ICC)%DS(JCC)=CUT_CELL(ICC)%DS(JCC)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
      ELSE
         CUT_CELL(ICC)%D(JCC) =CUT_CELL(ICC)%D(JCC) +FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
      ENDIF
   END SELECT
ENDDO

! Finally Gasphase cut-faces:
DO ICF = 1,MESHES(NM)%N_BBCUTFACE_MESH
   IF ( CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
   IW = CUT_FACE(ICF)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
   WC => WALL(IW)
   IOR = WC%ONE_D%IOR
   ! Flux limited face value bar{rho*hs}_F, the ONE_D variable values fo TMP, RHOP, ZZ and RSUM have been averaged to
   ! the cartesian cell location in CCREGION_DENSITY:
   IF (PREDICTOR) THEN
      VELC2 = WC%ONE_D%UWS
   ELSE
      VELC2 = WC%ONE_D%UW
   ENDIF
   IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY .AND. VELC2>0._EB) THEN
      TMP_F_GAS = WC%ONE_D%TMP_G
   ELSE
      TMP_F_GAS = WC%ONE_D%TMP_F
   ENDIF
   ZZ_GET(1:N_TRACKED_SPECIES) = WC%ONE_D%ZZ_F(1:N_TRACKED_SPECIES)
   CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP_F_GAS)
   FN_H_S = WC%ONE_D%RHO_F*H_S ! bar{rho*hs}
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
   DO IFACE=1,CUT_FACE(ICF)%NFACE
      AF   = CUT_FACE(ICF)%AREA(IFACE)
      VELC = PRFCT*CUT_FACE(ICF)%VEL(IFACE) + (1._EB-PRFCT)*CUT_FACE(ICF)%VELS(IFACE)
      ! First (rho hs)_i,j,k:
      SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
      CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
         ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
         JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
         TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
         RHOPV(ISIDE) = PRFCT *CUT_CELL(ICC)%RHO(JCC) + (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
         ZZ_GET(1:N_TRACKED_SPECIES) =  PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                                 (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
         CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
         RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
         IF (PREDICTOR) THEN
            CUT_CELL(ICC)%DS(JCC)=CUT_CELL(ICC)%DS(JCC)+FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF ! +ve or -ve dot
         ELSE
            CUT_CELL(ICC)%D(JCC) =CUT_CELL(ICC)%D(JCC) +FCT*(-1._EB)*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF ! +ve or -ve dot
         ENDIF
      END SELECT
   ENDDO ! IFACE
ENDDO ! ICF

! Enthalpy advection due to INBOUNDARY cut-faces (CFACE):
! TO DO.

! EXIM faces:
DO IEXIM=1,MESHES(NM)%IBM_NEXIMFACE_MESH
   I      = IBM_EXIM_FACE(IEXIM)%IJK(IAXIS)
   J      = IBM_EXIM_FACE(IEXIM)%IJK(JAXIS)
   K      = IBM_EXIM_FACE(IEXIM)%IJK(KAXIS)
   X1AXIS = IBM_EXIM_FACE(IEXIM)%IJK(KAXIS+1)
   LHFACE = IBM_EXIM_FACE(IEXIM)%LHFACE
   AF     = IBM_EXIM_FACE(IEXIM)%AREA
   IW     = IBM_EXIM_FACE(IEXIM)%IWC
   IF((IW>0) .AND. WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY) CYCLE

   FN_H_S = IBM_EXIM_FACE(IEXIM)%FN_H_S ! This value of face bar{rho*hs} has been filled in SET_EXIMRHOHSLIM_3D.
   RHO_H_S_PV(-1:0)   = 0._EB

   IF((IW>0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                         WALL(IW)%BOUNDARY_TYPE==OPEN_BOUNDARY         .OR. &
                         WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY) ) THEN ! Boundary faces, re-compute EXIM faces
                                                                           ! RHO_D_DZDN
       WC => WALL(IW)
       IOR = WC%ONE_D%IOR
       ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
       !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
       ISIDE = -1 + (SIGN(1,IOR)+1) / 2
       SELECT CASE(WC%BOUNDARY_TYPE)
          CASE DEFAULT
             SELECT CASE(X1AXIS)
             CASE(IAXIS)
                VELC = UU(I,J,K)
             CASE(JAXIS)
                VELC = VV(I,J,K)
             CASE(KAXIS)
                VELC = WW(I,J,K)
             END SELECT
          CASE(SOLID_BOUNDARY)
             IF (PREDICTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UWS
             IF (CORRECTOR) VELC = -SIGN(1._EB,REAL(IOR,EB))*WC%ONE_D%UW
       END SELECT
       SELECT CASE(X1AXIS)
       CASE(IAXIS)
          RHOPV(ISIDE)      = RHOP(I+FCELL+ISIDE,J,K)
          TMPV(ISIDE)       =  TMP(I+FCELL+ISIDE,J,K)
          ! Get rho*hs on cells at both sides of IFACE:
          ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I+FCELL+ISIDE,J,K,1:N_TRACKED_SPECIES)
          CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
          RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
          ! Add: -(bar{rho*hs} u dot n - (rho*hs) u dot n) to corresponding cell DP:
          AF = DY(J)*DZ(K)
          DP(I+FCELL+ISIDE,J,K) = DP(I+FCELL+ISIDE,J,K) + SIGN(1._EB,REAL(IOR,EB))*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
       CASE(JAXIS)
          RHOPV(ISIDE)      = RHOP(I,J+FCELL+ISIDE,K)
          TMPV(ISIDE)       =  TMP(I,J+FCELL+ISIDE,K)
          ! Get rho*hs on cells at both sides of IFACE:
          ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J+FCELL+ISIDE,K,1:N_TRACKED_SPECIES)
          CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
          RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
          ! Add: -(bar{rho*hs} u dot n - (rho*hs) u dot n) to corresponding cell DP:
          AF = DX(I)*DZ(K)
          DP(I,J+FCELL+ISIDE,K) = DP(I,J+FCELL+ISIDE,K) + SIGN(1._EB,REAL(IOR,EB))*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
       CASE(KAXIS)
          RHOPV(ISIDE)      = RHOP(I,J,K+FCELL+ISIDE)
          TMPV(ISIDE)       =  TMP(I,J,K+FCELL+ISIDE)
          ! Get rho*hs on cells at both sides of IFACE:
          ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K+FCELL+ISIDE,1:N_TRACKED_SPECIES)
          CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
          RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
          ! Add: -(bar{rho*hs} u dot n - (rho*hs) u dot n) to corresponding cell DP:
          AF = DX(I)*DY(J)
          DP(I,J,K+FCELL+ISIDE) = DP(I,J,K+FCELL+ISIDE) + SIGN(1._EB,REAL(IOR,EB))*(FN_H_S-RHO_H_S_PV(ISIDE))*VELC*AF
       END SELECT

   ELSE ! Regular cases and internal EXIM faces:

      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         RHOPV(-1:0)  = RHOP(I+FCELL-1:I+FCELL,J,K)
         TMPV(-1:0)   =  TMP(I+FCELL-1:I+FCELL,J,K)
         DO ISIDE=-1,0
            ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I+FCELL+ISIDE,J,K,1:N_TRACKED_SPECIES)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
            RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
         ENDDO
         VELC = UU(I,J,K)
         IF (IW > 0) THEN
            IF(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) VELC = UVW_SAVE(IW)
         ENDIF
         ! Add to divergence integral of surrounding cut-cell:
         IF(LHFACE == LOW_IND) THEN ! Face on low side of cell
            DP(I+FCELL  ,J,K) = DP(I+FCELL  ,J,K) - (-1._EB)*(FN_H_S-RHO_H_S_PV( 0))*VELC * AF ! -ve dot
         ELSE ! Face on high side of cell
            DP(I+FCELL-1,J,K) = DP(I+FCELL-1,J,K) + (-1._EB)*(FN_H_S-RHO_H_S_PV(-1))*VELC * AF ! +ve dot
         ENDIF
      CASE(JAXIS)
         RHOPV(-1:0)  = RHOP(I,J+FCELL-1:J+FCELL,K)
         TMPV(-1:0)   =  TMP(I,J+FCELL-1:J+FCELL,K)
         DO ISIDE=-1,0
            ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J+FCELL+ISIDE,K,1:N_TRACKED_SPECIES)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
            RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
         ENDDO
         VELC = VV(I,J,K)
         IF (IW > 0) THEN
            IF(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) VELC = UVW_SAVE(IW)
         ENDIF
         ! Add to divergence integral of surrounding cut-cell:
         IF(LHFACE == LOW_IND) THEN ! Face on low side of cell
            DP(I,J+FCELL  ,K) = DP(I,J+FCELL  ,K) - (-1._EB)*(FN_H_S-RHO_H_S_PV( 0))*VELC * AF ! -ve dot
         ELSE ! Face on high side of cell
            DP(I,J+FCELL-1,K) = DP(I,J+FCELL-1,K) + (-1._EB)*(FN_H_S-RHO_H_S_PV(-1))*VELC * AF ! +ve dot
         ENDIF
      CASE(KAXIS)
         RHOPV(-1:0)  = RHOP(I,J,K+FCELL-1:K+FCELL)
         TMPV(-1:0)   =  TMP(I,J,K+FCELL-1:K+FCELL)
         DO ISIDE=-1,0
            ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K+FCELL+ISIDE,1:N_TRACKED_SPECIES)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMPV(ISIDE))
            RHO_H_S_PV(ISIDE) = RHOPV(ISIDE)*H_S
         ENDDO
         VELC = WW(I,J,K)
         IF (IW > 0) THEN
            IF(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) VELC = UVW_SAVE(IW)
         ENDIF
         ! Add to divergence integral of surrounding cut-cell:
         IF(LHFACE == LOW_IND) THEN ! Face on low side of cell
            DP(I,J,K+FCELL  ) = DP(I,J,K+FCELL  ) - (-1._EB)*(FN_H_S-RHO_H_S_PV( 0))*VELC * AF ! -ve dot
         ELSE ! Face on high side of cell
            DP(I,J,K+FCELL-1) = DP(I,J,K+FCELL-1) + (-1._EB)*(FN_H_S-RHO_H_S_PV(-1))*VELC * AF ! +ve dot
         ENDIF
      END SELECT
   ENDIF
ENDDO

RETURN
END SUBROUTINE CCENTHALPY_ADVECTION

! ----------------------- CCREGION_DIFFUSIVE_HEAT_FLUXES ------------------------

SUBROUTINE CCREGION_DIFFUSIVE_HEAT_FLUXES

! NOTE: this routine assumes POINT_TO_MESH(NM) has been previously called.

! Local Variables:
INTEGER :: IIG, JJG, KKG , IOR, N_ZZ_MAX
REAL(EB) :: UWP, RHO_D_DZDN
REAL(EB) :: RHO_D_DZDN_GET(1:N_TRACKED_SPECIES)

SPECIES_LOOP1: DO N=1,N_TOTAL_SCALARS

   ! IAXIS faces:
   X1AXIS = IAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)
      IW = IBM_REGFACE_IAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
      J  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
      K  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)
      ! H_RHO_D_DZDN
      TMP_G = 0.5_EB*(TMP(I+FCELL  ,J,K)+TMP(I+FCELL-1,J,K))
      CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
      IBM_REGFACE_IAXIS_Z(IFACE)%H_RHO_D_DZDN(N) = &
      H_S*IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N,DIFFHFLX_IND)

      ! Add H_RHO_D_DZDN dot n to corresponding cell DP:
      AF = DY(J)*DZ(K)
      DP(I+FCELL-1,J,K) = DP(I+FCELL-1,J,K) + &
                          IBM_REGFACE_IAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! +ve dot
      DP(I+FCELL  ,J,K) = DP(I+FCELL  ,J,K) - &
                          IBM_REGFACE_IAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! -ve dot

      ! Add to int(DEL_RHO_D_DEL_Z)dv in FV form:
      DEL_RHO_D_DEL_Z(I+FCELL-1,J,K,N) = DEL_RHO_D_DEL_Z(I+FCELL-1,J,K,N) + &
                          IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N,JFLX_IND) * AF ! +ve dot
      DEL_RHO_D_DEL_Z(I+FCELL  ,J,K,N) = DEL_RHO_D_DEL_Z(I+FCELL  ,J,K,N) - &
                          IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N,JFLX_IND) * AF ! -ve dot

   ENDDO

   ! JAXIS faces:
   X1AXIS = JAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)
      IW = IBM_REGFACE_JAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
      J  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
      K  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)

      ! H_RHO_D_DZDN
      TMP_G = 0.5_EB*(TMP(I,J+FCELL  ,K)+TMP(I,J+FCELL-1,K))
      CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
      IBM_REGFACE_JAXIS_Z(IFACE)%H_RHO_D_DZDN(N) = &
      H_S*IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N,DIFFHFLX_IND)

      ! Add H_RHO_D_DZDN dot n to corresponding cell DP:
      AF = DX(I)*DZ(K)
      DP(I,J+FCELL-1,K) = DP(I,J+FCELL-1,K) + &
                          IBM_REGFACE_JAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! +ve dot
      DP(I,J+FCELL  ,K) = DP(I,J+FCELL  ,K) - &
                          IBM_REGFACE_JAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! -ve dot

      ! Add to int(DEL_RHO_D_DEL_Z)dv in FV form:
      DEL_RHO_D_DEL_Z(I,J+FCELL-1,K,N) = DEL_RHO_D_DEL_Z(I,J+FCELL-1,K,N) + &
                          IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N,JFLX_IND) * AF ! +ve dot
      DEL_RHO_D_DEL_Z(I,J+FCELL  ,K,N) = DEL_RHO_D_DEL_Z(I,J+FCELL  ,K,N) - &
                          IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N,JFLX_IND) * AF ! -ve dot

   ENDDO

   ! KAXIS faces:
   X1AXIS = KAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)
      IW = IBM_REGFACE_KAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
      I  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
      J  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
      K  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)

      ! H_RHO_D_DZDN
      TMP_G = 0.5_EB*(TMP(I,J,K+FCELL  )+TMP(I,J,K+FCELL-1))
      CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
      IBM_REGFACE_KAXIS_Z(IFACE)%H_RHO_D_DZDN(N) = &
      H_S*IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N,DIFFHFLX_IND)

      ! Add H_RHO_D_DZDN dot n to corresponding cell DP:
      AF = DX(I)*DY(J)
      DP(I,J,K+FCELL-1) = DP(I,J,K+FCELL-1) + &
                          IBM_REGFACE_KAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! +ve dot
      DP(I,J,K+FCELL  ) = DP(I,J,K+FCELL  ) - &
                          IBM_REGFACE_KAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! -ve dot

      ! Add to int(DEL_RHO_D_DEL_Z)dv in FV form:
      DEL_RHO_D_DEL_Z(I,J,K+FCELL-1,N) = DEL_RHO_D_DEL_Z(I,J,K+FCELL-1,N) + &
                          IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N,JFLX_IND) * AF ! +ve dot
      DEL_RHO_D_DEL_Z(I,J,K+FCELL  ,N) = DEL_RHO_D_DEL_Z(I,J,K+FCELL  ,N) - &
                          IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N,JFLX_IND) * AF ! -ve dot

   ENDDO

ENDDO SPECIES_LOOP1

! Regular faces connecting gasphase- cut-cells:
DO IFACE=1,MESHES(NM)%IBM_NRCFACE_Z
   IW = IBM_RCFACE_Z(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I      = IBM_RCFACE_Z(IFACE)%IJK(IAXIS)
   J      = IBM_RCFACE_Z(IFACE)%IJK(JAXIS)
   K      = IBM_RCFACE_Z(IFACE)%IJK(KAXIS)
   X1AXIS = IBM_RCFACE_Z(IFACE)%IJK(KAXIS+1)
   TMP_G  = IBM_RCFACE_Z(IFACE)%TMP_FACE
   SELECT CASE(X1AXIS)
   CASE(IAXIS)
      AF = DY(J)*DZ(K)
      ! H_RHO_D_DZDN
      DO N=1,N_TOTAL_SCALARS
         CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
         IBM_RCFACE_Z(IFACE)%H_RHO_D_DZDN(N) = H_S*IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(N,DIFFHFLX_IND)
      ENDDO
      ! Add contribution to DP:
      ! Low side cell:
      DO ISIDE=-1,0
         FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
         SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
         CASE(IBM_FTYPE_RGGAS) ! Regular cell
         DP(I+FCELL+ISIDE,J,K)=DP(I+FCELL+ISIDE,J,K)+FCT*SUM(IBM_RCFACE_Z(IFACE)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF
         ! +ve or -ve dot
         DO N=1,N_TOTAL_SCALARS
            DEL_RHO_D_DEL_Z(I+FCELL+ISIDE,J,K,N) = DEL_RHO_D_DEL_Z(I+FCELL+ISIDE,J,K,N) + &
                                                   FCT*IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(N,JFLX_IND) * AF
         ENDDO
         CASE(IBM_FTYPE_CFGAS) ! Cut-cell
         ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
         IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE
         JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
         IF (PREDICTOR) THEN
            CUT_CELL(ICC)%DS(JCC) = &
            CUT_CELL(ICC)%DS(JCC) + FCT*SUM(IBM_RCFACE_Z(IFACE)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF ! +ve or -ve dot
         ELSE
            CUT_CELL(ICC)%D(JCC) = &
            CUT_CELL(ICC)%D(JCC) + FCT*SUM(IBM_RCFACE_Z(IFACE)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF ! +ve or -ve dot
         ENDIF
         CUT_CELL(ICC)%DEL_RHO_D_DEL_Z(1:N_TOTAL_SCALARS,JCC) = &
         CUT_CELL(ICC)%DEL_RHO_D_DEL_Z(1:N_TOTAL_SCALARS,JCC) + &
         FCT*IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(1:N_TOTAL_SCALARS,JFLX_IND) * AF
         END SELECT
      ENDDO
   CASE(JAXIS)
      AF = DX(I)*DZ(K)
      ! H_RHO_D_DZDN
      DO N=1,N_TOTAL_SCALARS
         CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
         IBM_RCFACE_Z(IFACE)%H_RHO_D_DZDN(N) = H_S*IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(N,DIFFHFLX_IND)
      ENDDO
      ! Add contribution to DP:
      ! Low side cell:
      DO ISIDE=-1,0
         FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
         SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
         CASE(IBM_FTYPE_RGGAS) ! Regular cell
         DP(I,J+FCELL+ISIDE,K)=DP(I,J+FCELL+ISIDE,K)+FCT*SUM(IBM_RCFACE_Z(IFACE)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF
         ! +ve or -ve dot
         DO N=1,N_TOTAL_SCALARS
            DEL_RHO_D_DEL_Z(I,J+FCELL+ISIDE,K,N) = DEL_RHO_D_DEL_Z(I,J+FCELL+ISIDE,K,N) + &
                                                   FCT*IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(N,JFLX_IND) * AF
         ENDDO
         CASE(IBM_FTYPE_CFGAS) ! Cut-cell
         ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
         IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE
         JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
         IF (PREDICTOR) THEN
            CUT_CELL(ICC)%DS(JCC) = &
            CUT_CELL(ICC)%DS(JCC) + FCT*SUM(IBM_RCFACE_Z(IFACE)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF ! +ve or -ve dot
         ELSE
            CUT_CELL(ICC)%D(JCC) = &
            CUT_CELL(ICC)%D(JCC) + FCT*SUM(IBM_RCFACE_Z(IFACE)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF ! +ve or -ve dot
         ENDIF
         CUT_CELL(ICC)%DEL_RHO_D_DEL_Z(1:N_TOTAL_SCALARS,JCC) = &
         CUT_CELL(ICC)%DEL_RHO_D_DEL_Z(1:N_TOTAL_SCALARS,JCC) + &
         FCT*IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(1:N_TOTAL_SCALARS,JFLX_IND) * AF
         END SELECT
      ENDDO
   CASE(KAXIS)
      AF = DX(I)*DY(J)
      ! H_RHO_D_DZDN
      DO N=1,N_TOTAL_SCALARS
         CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
         IBM_RCFACE_Z(IFACE)%H_RHO_D_DZDN(N) = H_S*IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(N,DIFFHFLX_IND)
      ENDDO
      ! Add contribution to DP:
      ! Low side cell:
      DO ISIDE=-1,0
         FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
         SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
         CASE(IBM_FTYPE_RGGAS) ! Regular cell
         DP(I,J,K+FCELL+ISIDE)=DP(I,J,K+FCELL+ISIDE)+FCT*SUM(IBM_RCFACE_Z(IFACE)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF
         ! +ve or -ve dot
         DO N=1,N_TOTAL_SCALARS
            DEL_RHO_D_DEL_Z(I,J,K+FCELL+ISIDE,N) = DEL_RHO_D_DEL_Z(I,J,K+FCELL+ISIDE,N) + &
                                                   FCT*IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(N,JFLX_IND) * AF
         ENDDO
         CASE(IBM_FTYPE_CFGAS) ! Cut-cell
         ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
         IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE
         JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
         IF (PREDICTOR) THEN
            CUT_CELL(ICC)%DS(JCC) = &
            CUT_CELL(ICC)%DS(JCC) + FCT*SUM(IBM_RCFACE_Z(IFACE)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF ! +ve or -ve dot
         ELSE
            CUT_CELL(ICC)%D(JCC) = &
            CUT_CELL(ICC)%D(JCC) + FCT*SUM(IBM_RCFACE_Z(IFACE)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF ! +ve or -ve dot
         ENDIF
         CUT_CELL(ICC)%DEL_RHO_D_DEL_Z(1:N_TOTAL_SCALARS,JCC) = &
         CUT_CELL(ICC)%DEL_RHO_D_DEL_Z(1:N_TOTAL_SCALARS,JCC) + &
         FCT*IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(1:N_TOTAL_SCALARS,JFLX_IND)* AF
         END SELECT
      ENDDO
   END SELECT
ENDDO

! GASPHASE cut-faces:
DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
   IF ( CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
   IW = CUT_FACE(ICF)%IWC
   ! Note: for cut-faces open boundaries are dealt with below in external BC loops:
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I = CUT_FACE(ICF)%IJK(IAXIS)
   J = CUT_FACE(ICF)%IJK(JAXIS)
   K = CUT_FACE(ICF)%IJK(KAXIS)
   X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)
   DO IFACE=1,CUT_FACE(ICF)%NFACE
      AF = CUT_FACE(ICF)%AREA(IFACE)
      ! H_RHO_D_DZDN
      TMP_G = CUT_FACE(ICF)%TMP_FACE(IFACE)
      DO N=1,N_TOTAL_SCALARS
         CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
         CUT_FACE(ICF)%H_RHO_D_DZDN(N,IFACE) = H_S*CUT_FACE(ICF)%RHO_D_DZDN(N,DIFFHFLX_IND,IFACE)
      ENDDO
      ! Add to divergence integral of surrounding cut-cells:
      DO ISIDE=-1,0
         FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
         SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
         CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
         ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
         IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE
         JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
         IF (PREDICTOR) THEN
            CUT_CELL(ICC)%DS(JCC) = &
            CUT_CELL(ICC)%DS(JCC) + FCT*SUM(CUT_FACE(ICF)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS,IFACE)) * AF ! +ve or -ve dot
         ELSE
            CUT_CELL(ICC)%D(JCC) = &
            CUT_CELL(ICC)%D(JCC) + FCT*SUM(CUT_FACE(ICF)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS,IFACE)) * AF ! +ve or -ve dot
         ENDIF
         CUT_CELL(ICC)%DEL_RHO_D_DEL_Z(1:N_TOTAL_SCALARS,JCC) = &
         CUT_CELL(ICC)%DEL_RHO_D_DEL_Z(1:N_TOTAL_SCALARS,JCC) + &
         FCT*CUT_FACE(ICF)%RHO_D_DZDN(1:N_TOTAL_SCALARS,JFLX_IND,IFACE)* AF
         END SELECT
      ENDDO
   ENDDO ! IFACE
ENDDO ! ICF


! Now define diffussive heat flux components in domain boundaries:
SPECIES_LOOP2: DO N=1,N_TOTAL_SCALARS

   ! IAXIS faces:
   X1AXIS = IAXIS
   DO IFACE=1,MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)
      IW = IBM_REGFACE_IAXIS_Z(IFACE)%IWC
      IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
      I  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
      J  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
      K  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)
      WC => WALL(IW)
      ! H_RHO_D_DZDN
      IF (PREDICTOR) THEN
         UWP = WC%ONE_D%UWS
      ELSE
         UWP = WC%ONE_D%UW
      ENDIF
      IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY .AND. UWP>0._EB) THEN
         TMP_G = WC%ONE_D%TMP_G
      ELSE
         TMP_G = WC%ONE_D%TMP_F
      ENDIF
      CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
      IBM_REGFACE_IAXIS_Z(IFACE)%H_RHO_D_DZDN(N) = H_S*IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N,DIFFHFLX_IND)

      ! Add H_RHO_D_DZDN dot n to corresponding cell DP:
      AF = DY(J)*DZ(K)
      SELECT CASE(WC%ONE_D%IOR)
      CASE(-IAXIS) ! Low side cell.
      DP(I+FCELL-1,J,K) = DP(I+FCELL-1,J,K) + IBM_REGFACE_IAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! +ve dot
      ! Add to int(DEL_RHO_D_DEL_Z)dv in FV form:
      DEL_RHO_D_DEL_Z(I+FCELL-1,J,K,N) = DEL_RHO_D_DEL_Z(I+FCELL-1,J,K,N) + &
                                         IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N,JFLX_IND) * AF ! +ve dot
      CASE( IAXIS) ! High side cell.
      DP(I+FCELL  ,J,K) = DP(I+FCELL  ,J,K) - IBM_REGFACE_IAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! -ve dot
      DEL_RHO_D_DEL_Z(I+FCELL  ,J,K,N) = DEL_RHO_D_DEL_Z(I+FCELL  ,J,K,N) - &
                                         IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N,JFLX_IND) * AF ! -ve dot
      END SELECT
   ENDDO

   ! JAXIS faces:
   X1AXIS = JAXIS
   DO IFACE=1,MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)
      IW = IBM_REGFACE_JAXIS_Z(IFACE)%IWC
      IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
      I  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
      J  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
      K  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)
      WC => WALL(IW)
      ! H_RHO_D_DZDN
      IF (PREDICTOR) THEN
         UWP = WC%ONE_D%UWS
      ELSE
         UWP = WC%ONE_D%UW
      ENDIF
      IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY .AND. UWP>0._EB) THEN
         TMP_G = WC%ONE_D%TMP_G
      ELSE
         TMP_G = WC%ONE_D%TMP_F
      ENDIF
      CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
      IBM_REGFACE_JAXIS_Z(IFACE)%H_RHO_D_DZDN(N) = H_S*IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N,DIFFHFLX_IND)

      ! Add H_RHO_D_DZDN dot n to corresponding cell DP:
      AF = DX(I)*DZ(K)
      SELECT CASE(WC%ONE_D%IOR)
      CASE(-JAXIS) ! Low side cell.
      DP(I,J+FCELL-1,K) = DP(I,J+FCELL-1,K) + IBM_REGFACE_JAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! +ve dot
                          ! Add to int(DEL_RHO_D_DEL_Z)dv in FV form:
      DEL_RHO_D_DEL_Z(I,J+FCELL-1,K,N) = DEL_RHO_D_DEL_Z(I,J+FCELL-1,K,N) + &
                                         IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N,JFLX_IND) * AF ! +ve dot
      CASE( JAXIS) ! High side cell.
      DP(I,J+FCELL  ,K) = DP(I,J+FCELL  ,K) - IBM_REGFACE_JAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! -ve dot
      DEL_RHO_D_DEL_Z(I,J+FCELL  ,K,N) = DEL_RHO_D_DEL_Z(I,J+FCELL  ,K,N) - &
                                         IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N,JFLX_IND) * AF ! -ve dot
      END SELECT
   ENDDO

   ! KAXIS faces:
   X1AXIS = KAXIS
   DO IFACE=1,MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)
      IW = IBM_REGFACE_KAXIS_Z(IFACE)%IWC
      IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
      I  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
      J  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
      K  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)
      WC => WALL(IW)
      ! H_RHO_D_DZDN
      IF (PREDICTOR) THEN
         UWP = WC%ONE_D%UWS
      ELSE
         UWP = WC%ONE_D%UW
      ENDIF
      IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY .AND. UWP>0._EB) THEN
         TMP_G = WC%ONE_D%TMP_G
      ELSE
         TMP_G = WC%ONE_D%TMP_F
      ENDIF
      CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
      IBM_REGFACE_KAXIS_Z(IFACE)%H_RHO_D_DZDN(N) = H_S*IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N,DIFFHFLX_IND)

      ! Add H_RHO_D_DZDN dot n to corresponding cell DP:
      AF = DX(I)*DY(J)
      SELECT CASE(WC%ONE_D%IOR)
      CASE(-KAXIS) ! Low side cell.
      DP(I,J,K+FCELL-1) = DP(I,J,K+FCELL-1) + IBM_REGFACE_KAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! +ve dot
      ! Add to int(DEL_RHO_D_DEL_Z)dv in FV form:
      DEL_RHO_D_DEL_Z(I,J,K+FCELL-1,N) = DEL_RHO_D_DEL_Z(I,J,K+FCELL-1,N) + &
                                         IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N,JFLX_IND) * AF ! +ve dot
      CASE( KAXIS) ! High side cell.
      DP(I,J,K+FCELL  ) = DP(I,J,K+FCELL  ) - IBM_REGFACE_KAXIS_Z(IFACE)%H_RHO_D_DZDN(N) * AF ! -ve dot
      DEL_RHO_D_DEL_Z(I,J,K+FCELL  ,N) = DEL_RHO_D_DEL_Z(I,J,K+FCELL  ,N) - &
                                         IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N,JFLX_IND) * AF ! -ve dot
      END SELECT
   ENDDO

ENDDO SPECIES_LOOP2

! Regular faces connecting gasphase- cut-cells:
DO IFACE=1,MESHES(NM)%IBM_NBBRCFACE_Z
   IW = IBM_RCFACE_Z(IFACE)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
   I      = IBM_RCFACE_Z(IFACE)%IJK(IAXIS)
   J      = IBM_RCFACE_Z(IFACE)%IJK(JAXIS)
   K      = IBM_RCFACE_Z(IFACE)%IJK(KAXIS)
   X1AXIS = IBM_RCFACE_Z(IFACE)%IJK(KAXIS+1)
   TMP_G  = IBM_RCFACE_Z(IFACE)%TMP_FACE

   WC => WALL(IW)
   IIG = WC%ONE_D%IIG
   JJG = WC%ONE_D%JJG
   KKG = WC%ONE_D%KKG
   IOR = WC%ONE_D%IOR
   ! H_RHO_D_DZDN
   DO N=1,N_TOTAL_SCALARS
      CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
      IBM_RCFACE_Z(IFACE)%H_RHO_D_DZDN(N) = H_S*IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(N,DIFFHFLX_IND)
   ENDDO
   SELECT CASE(X1AXIS)
   CASE(IAXIS)
      AF = DY(J)*DZ(K)
   CASE(JAXIS)
      AF = DX(I)*DZ(K)
   CASE(KAXIS)
      AF = DX(I)*DY(J)
   END SELECT
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
   SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
   CASE(IBM_FTYPE_RGGAS) ! Regular cell
   DP(IIG,JJG,KKG)=DP(IIG,JJG,KKG)+FCT*SUM(IBM_RCFACE_Z(IFACE)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF ! +ve or -ve dot
   DO N=1,N_TOTAL_SCALARS
      DEL_RHO_D_DEL_Z(IIG,JJG,KKG,N)=DEL_RHO_D_DEL_Z(IIG,JJG,KKG,N)+FCT*IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(N,JFLX_IND)*AF
   ENDDO
   CASE(IBM_FTYPE_CFGAS) ! Cut-cell
   ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
   JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
   IF (PREDICTOR) THEN
      CUT_CELL(ICC)%DS(JCC) = &
      CUT_CELL(ICC)%DS(JCC) + FCT*SUM(IBM_RCFACE_Z(IFACE)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF ! +ve or -ve dot
   ELSE
      CUT_CELL(ICC)%D(JCC) = &
      CUT_CELL(ICC)%D(JCC) + FCT*SUM(IBM_RCFACE_Z(IFACE)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF ! +ve or -ve dot
   ENDIF
   CUT_CELL(ICC)%DEL_RHO_D_DEL_Z(1:N_TOTAL_SCALARS,JCC) = &
   CUT_CELL(ICC)%DEL_RHO_D_DEL_Z(1:N_TOTAL_SCALARS,JCC) + &
   FCT*IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(1:N_TOTAL_SCALARS,JFLX_IND) * AF
   END SELECT
ENDDO

! GASPHASE cut-faces:
DO ICF = 1,MESHES(NM)%N_BBCUTFACE_MESH
   IF ( CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
   IW = CUT_FACE(ICF)%IWC
   ! Note: for cut-faces open boundaries are dealt with below in external BC loops:
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
   I = CUT_FACE(ICF)%IJK(IAXIS)
   J = CUT_FACE(ICF)%IJK(JAXIS)
   K = CUT_FACE(ICF)%IJK(KAXIS)
   X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)
   WC => WALL(IW)
   IOR = WC%ONE_D%IOR
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   DO IFACE=1,CUT_FACE(ICF)%NFACE
      AF = CUT_FACE(ICF)%AREA(IFACE)
      ! H_RHO_D_DZDN
      TMP_G = CUT_FACE(ICF)%TMP_FACE(IFACE)
      DO N=1,N_TOTAL_SCALARS
         CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
         CUT_FACE(ICF)%H_RHO_D_DZDN(N,IFACE) = H_S*CUT_FACE(ICF)%RHO_D_DZDN(N,DIFFHFLX_IND,IFACE)
      ENDDO
      ! Add to divergence integral of surrounding cut-cells:
      FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
      SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
      CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
      ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
      JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
      IF (PREDICTOR) THEN
         CUT_CELL(ICC)%DS(JCC) = &
         CUT_CELL(ICC)%DS(JCC) + FCT*SUM(CUT_FACE(ICF)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS,IFACE)) * AF ! +ve or -ve dot
      ELSE
         CUT_CELL(ICC)%D(JCC) = &
         CUT_CELL(ICC)%D(JCC) + FCT*SUM(CUT_FACE(ICF)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS,IFACE)) * AF ! +ve or -ve dot
      ENDIF
      CUT_CELL(ICC)%DEL_RHO_D_DEL_Z(1:N_TOTAL_SCALARS,JCC) = &
      CUT_CELL(ICC)%DEL_RHO_D_DEL_Z(1:N_TOTAL_SCALARS,JCC) + &
      FCT*CUT_FACE(ICF)%RHO_D_DZDN(1:N_TOTAL_SCALARS,JFLX_IND,IFACE)* AF
      END SELECT
   ENDDO ! IFACE
ENDDO ! ICF

! Diffusive heat fluxes due to INBOUNDARY cut-faces (CFACE):
! TO DO.

! Diffusive terms at EXIM faces:
DO IEXIM=1,MESHES(NM)%IBM_NEXIMFACE_MESH
   I      = IBM_EXIM_FACE(IEXIM)%IJK(IAXIS)
   J      = IBM_EXIM_FACE(IEXIM)%IJK(JAXIS)
   K      = IBM_EXIM_FACE(IEXIM)%IJK(KAXIS)
   X1AXIS = IBM_EXIM_FACE(IEXIM)%IJK(KAXIS+1)
   LHFACE = IBM_EXIM_FACE(IEXIM)%LHFACE
   AF     = IBM_EXIM_FACE(IEXIM)%AREA
   IW     = IBM_EXIM_FACE(IEXIM)%IWC

   IF((IW>0) .AND. WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY) CYCLE
   IF((IW>0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                         WALL(IW)%BOUNDARY_TYPE==OPEN_BOUNDARY         .OR. &
                         WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY) ) THEN ! Boundary faces, re-compute EXIM faces
                                                                           ! RHO_D_DZDN
      WC => WALL(IW)
      IIG = WC%ONE_D%IIG
      JJG = WC%ONE_D%JJG
      KKG = WC%ONE_D%KKG
      IOR = WC%ONE_D%IOR
      N_ZZ_MAX = MAXLOC(WC%ONE_D%ZZ_F(1:N_TRACKED_SPECIES),1)
      DO N=1,N_TOTAL_SCALARS
         RHO_D_DZDN = 2._EB*WC%ONE_D%RHO_D_F(N)*(ZZP(IIG,JJG,KKG,N)-WC%ONE_D%ZZ_F(N))*WC%ONE_D%RDN
         IF (N==N_ZZ_MAX) THEN
            RHO_D_DZDN_GET = 2._EB*WC%ONE_D%RHO_D_F(:)*(ZZP(IIG,JJG,KKG,:)-WC%ONE_D%ZZ_F(:))*WC%ONE_D%RDN
            RHO_D_DZDN = -(SUM(RHO_D_DZDN_GET(:))-RHO_D_DZDN)
         ENDIF
         IF (IOR < 0) RHO_D_DZDN = -RHO_D_DZDN ! Switch the sign of the spatial derivative in high side boundaries.
         IBM_EXIM_FACE(IEXIM)%FLX(LOW_IND,N) = RHO_D_DZDN
      ENDDO
      TMP_G = WC%ONE_D%TMP_F
   ELSE ! Internal faces:
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         TMP_G = 0.5_EB*(TMP(I+FCELL  ,J,K)+TMP(I+FCELL-1,J,K))
      CASE(JAXIS)
         TMP_G = 0.5_EB*(TMP(I,J+FCELL  ,K)+TMP(I,J+FCELL-1,K))
      CASE(KAXIS)
         TMP_G = 0.5_EB*(TMP(I,J,K+FCELL  )+TMP(I,J,K+FCELL-1))
      END SELECT
   ENDIF

   ! H_RHO_D_DZDN
   DO N=1,N_TOTAL_SCALARS
      CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP_G,H_S)
      IBM_EXIM_FACE(IEXIM)%H_RHO_D_DZDN(N) = H_S*IBM_EXIM_FACE(IEXIM)%FLX(LOW_IND,N)
   ENDDO

   SELECT CASE(X1AXIS)
   CASE(IAXIS)
      ! Add H_RHO_D_DZDN dot n to corresponding cell DP:
      IF(LHFACE == LOW_IND) THEN ! Face on low side of cell
         DP(I+FCELL  ,J,K) = DP(I+FCELL  ,J,K)-SUM(IBM_EXIM_FACE(IEXIM)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF ! -ve dot
         DO N=1,N_TOTAL_SCALARS
            DEL_RHO_D_DEL_Z(I+FCELL  ,J,K,N)=DEL_RHO_D_DEL_Z(I+FCELL  ,J,K,N)-IBM_EXIM_FACE(IEXIM)%FLX(LOW_IND,N)*AF
         ENDDO
      ELSE ! Face on high side of cell
         DP(I+FCELL-1,J,K) = DP(I+FCELL-1,J,K)+SUM(IBM_EXIM_FACE(IEXIM)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF ! +ve dot
         DO N=1,N_TOTAL_SCALARS
            DEL_RHO_D_DEL_Z(I+FCELL-1,J,K,N)=DEL_RHO_D_DEL_Z(I+FCELL-1,J,K,N)+IBM_EXIM_FACE(IEXIM)%FLX(LOW_IND,N)*AF
         ENDDO
      ENDIF
   CASE(JAXIS)
      ! Add H_RHO_D_DZDN dot n to corresponding cell DP:
      IF(LHFACE == LOW_IND) THEN ! Face on low side of cell
         DP(I,J+FCELL  ,K) = DP(I,J+FCELL  ,K)-SUM(IBM_EXIM_FACE(IEXIM)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF ! -ve dot
         DO N=1,N_TOTAL_SCALARS
            DEL_RHO_D_DEL_Z(I,J+FCELL  ,K,N)=DEL_RHO_D_DEL_Z(I,J+FCELL  ,K,N)-IBM_EXIM_FACE(IEXIM)%FLX(LOW_IND,N)*AF
         ENDDO
      ELSE ! Face on high side of cell
         DP(I,J+FCELL-1,K) = DP(I,J+FCELL-1,K)+SUM(IBM_EXIM_FACE(IEXIM)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF ! +ve dot
         DO N=1,N_TOTAL_SCALARS
            DEL_RHO_D_DEL_Z(I,J+FCELL-1,K,N)=DEL_RHO_D_DEL_Z(I,J+FCELL-1,K,N)+IBM_EXIM_FACE(IEXIM)%FLX(LOW_IND,N)*AF
         ENDDO
      ENDIF
   CASE(KAXIS)
      ! Add H_RHO_D_DZDN dot n to corresponding cell DP:
      IF(LHFACE == LOW_IND) THEN ! Face on low side of cell
         DP(I,J,K+FCELL  ) = DP(I,J,K+FCELL  )-SUM(IBM_EXIM_FACE(IEXIM)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF ! -ve dot
         DO N=1,N_TOTAL_SCALARS
            DEL_RHO_D_DEL_Z(I,J,K+FCELL  ,N)=DEL_RHO_D_DEL_Z(I,J,K+FCELL  ,N)-IBM_EXIM_FACE(IEXIM)%FLX(LOW_IND,N)*AF
         ENDDO
      ELSE ! Face on high side of cell
         DP(I,J,K+FCELL-1) = DP(I,J,K+FCELL-1)+SUM(IBM_EXIM_FACE(IEXIM)%H_RHO_D_DZDN(1:N_TOTAL_SCALARS))*AF ! +ve dot
         DO N=1,N_TOTAL_SCALARS
            DEL_RHO_D_DEL_Z(I,J,K+FCELL-1,N)=DEL_RHO_D_DEL_Z(I,J,K+FCELL-1,N)+IBM_EXIM_FACE(IEXIM)%FLX(LOW_IND,N)*AF
         ENDDO
      ENDIF
   END SELECT
ENDDO ! IEXIM

RETURN
END SUBROUTINE CCREGION_DIFFUSIVE_HEAT_FLUXES

! ----------------------- CCREGION_CONDUCTION_HEAT_FLUX --------------------------

SUBROUTINE CCREGION_CONDUCTION_HEAT_FLUX

INTEGER :: IIG, JJG, KKG, IOR

! IAXIS faces:
X1AXIS = IAXIS
DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

   IW = IBM_REGFACE_IAXIS_Z(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

   I  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
   J  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
   K  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)

   ! K*DTDN:
   TMPV(-1:0)  = TMP(I+FCELL-1:I+FCELL,J,K)
   KPV(-1:0)   =  MU(I+FCELL-1:I+FCELL,J,K)*CPOPR
   ! KP on low-high side cells:
   IF (DNS) THEN
      DO ISIDE=-1,0
         ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I+FCELL+ISIDE,J,K,1:N_TRACKED_SPECIES)
         CALL GET_CONDUCTIVITY(ZZ_GET,KPV(ISIDE),TMPV(ISIDE))
      ENDDO
   ENDIF

   KPDTDN = 0.5_EB*(KPV(-1)+KPV(0)) * (TMPV(0)-TMPV(-1)) / DX(I)

   ! Add K*DTDN dot n to corresponding cell DP:
   AF = DY(J)*DZ(K)
   DP(I+FCELL-1,J,K) = DP(I+FCELL-1,J,K) + KPDTDN * AF ! +ve dot
   DP(I+FCELL  ,J,K) = DP(I+FCELL  ,J,K) - KPDTDN * AF ! -ve dot
ENDDO

! JAXIS faces:
X1AXIS = JAXIS
DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

   IW = IBM_REGFACE_JAXIS_Z(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

   I  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
   J  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
   K  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)

   ! K*DTDN:
   TMPV(-1:0)  = TMP(I,J+FCELL-1:J+FCELL,K)
   KPV(-1:0)   =  MU(I,J+FCELL-1:J+FCELL,K)*CPOPR
   ! KP on low-high side cells:
   IF (DNS) THEN
      DO ISIDE=-1,0
         ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J+FCELL+ISIDE,K,1:N_TRACKED_SPECIES)
         CALL GET_CONDUCTIVITY(ZZ_GET,KPV(ISIDE),TMPV(ISIDE))
      ENDDO
   ENDIF

   KPDTDN = 0.5_EB*(KPV(-1)+KPV(0)) * (TMPV(0)-TMPV(-1)) / DY(J)

   ! Add K*DTDN dot n to corresponding cell DP:
   AF = DX(I)*DZ(K)
   DP(I,J+FCELL-1,K) = DP(I,J+FCELL-1,K) + KPDTDN * AF ! +ve dot
   DP(I,J+FCELL  ,K) = DP(I,J+FCELL  ,K) - KPDTDN * AF ! -ve dot
ENDDO

! KAXIS faces:
X1AXIS = KAXIS
DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

   IW = IBM_REGFACE_KAXIS_Z(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

   I  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
   J  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
   K  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)

   ! K*DTDN:
   TMPV(-1:0)  = TMP(I,J,K+FCELL-1:K+FCELL)
   KPV(-1:0)   =  MU(I,J,K+FCELL-1:K+FCELL)*CPOPR
   ! KP on low-high side cells:
   IF (DNS) THEN
      DO ISIDE=-1,0
         ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K+FCELL+ISIDE,1:N_TRACKED_SPECIES)
         CALL GET_CONDUCTIVITY(ZZ_GET,KPV(ISIDE),TMPV(ISIDE))
      ENDDO
   ENDIF

   KPDTDN = 0.5_EB*(KPV(-1)+KPV(0)) * (TMPV(0)-TMPV(-1)) / DZ(K)

   ! Add K*DTDN dot n to corresponding cell DP:
   AF = DX(I)*DY(J)
   DP(I,J,K+FCELL-1) = DP(I,J,K+FCELL-1) + KPDTDN * AF ! +ve dot
   DP(I,J,K+FCELL  ) = DP(I,J,K+FCELL  ) - KPDTDN * AF ! -ve dot
ENDDO


! Regular faces connecting gasphase - cut-cells:
DO IFACE=1,MESHES(NM)%IBM_NRCFACE_Z

   IW = IBM_RCFACE_Z(IFACE)%IWC
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

   I      = IBM_RCFACE_Z(IFACE)%IJK(IAXIS)
   J      = IBM_RCFACE_Z(IFACE)%IJK(JAXIS)
   K      = IBM_RCFACE_Z(IFACE)%IJK(KAXIS)
   X1AXIS = IBM_RCFACE_Z(IFACE)%IJK(KAXIS+1)

   SELECT CASE(X1AXIS)
      CASE(IAXIS)
         AF = DY(J)*DZ(K)
         X1F= MESHES(NM)%X(I)
         IDX = 1._EB / ( IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                         IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND) )
         ! Linear interpolation coefficients:
         CCM1 = IDX*(IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
         CCP1 = IDX*(X1F -IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND))

         TMPV(-1:0)  = TMP(I+FCELL-1:I+FCELL,J,K)
         KPV(-1:0)   =  MU(I+FCELL-1:I+FCELL,J,K)*CPOPR
         DO ISIDE=-1,0
            ZZ_GET = 0._EB
            SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
               ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I+FCELL+ISIDE,J,K,1:N_TRACKED_SPECIES)
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
               JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
               TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
               ZZ_GET(1:N_TRACKED_SPECIES) =  &
                      PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
               (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
            END SELECT
            IF (DNS) CALL GET_CONDUCTIVITY(ZZ_GET,KPV(ISIDE),TMPV(ISIDE))
         ENDDO

         KPDTDN = (CCM1*KPV(-1)+CCP1*KPV(0)) * (TMPV(0)-TMPV(-1)) * IDX

         ! Add contribution to DP:
         ! Low side cell:
         DO ISIDE=-1,0
            FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
            SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(IBM_FTYPE_RGGAS) ! Regular cell
               DP(I+FCELL+ISIDE,J,K) = DP(I+FCELL+ISIDE,J,K) + FCT*KPDTDN * AF ! +ve or -ve dot
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell
               ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
               IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
               JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
               IF (PREDICTOR) THEN
                  CUT_CELL(ICC)%DS(JCC) = &
                  CUT_CELL(ICC)%DS(JCC) + FCT*KPDTDN * AF ! +ve or -ve dot
               ELSE
                  CUT_CELL(ICC)%D(JCC) = &
                  CUT_CELL(ICC)%D(JCC) + FCT*KPDTDN * AF ! +ve or -ve dot
               ENDIF
            END SELECT
         ENDDO

      CASE(JAXIS)
         AF = DX(I)*DZ(K)
         X1F= MESHES(NM)%Y(J)
         IDX = 1._EB / ( IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                         IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND) )
         ! Linear interpolation coefficients:
         CCM1 = IDX*(IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
         CCP1 = IDX*(X1F -IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND))

         TMPV(-1:0)  = TMP(I,J+FCELL-1:J+FCELL,K)
         KPV(-1:0)   =  MU(I,J+FCELL-1:J+FCELL,K)*CPOPR
         DO ISIDE=-1,0
            ZZ_GET = 0._EB
            SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
               ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J+FCELL+ISIDE,K,1:N_TRACKED_SPECIES)
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
               JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
               TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
               ZZ_GET(1:N_TRACKED_SPECIES) =  &
                      PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
               (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
            END SELECT
            IF (DNS) CALL GET_CONDUCTIVITY(ZZ_GET,KPV(ISIDE),TMPV(ISIDE))
         ENDDO

         KPDTDN = (CCM1*KPV(-1)+CCP1*KPV(0)) * (TMPV(0)-TMPV(-1)) * IDX

         ! Add contribution to DP:
         ! Low side cell:
         DO ISIDE=-1,0
            FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
            SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(IBM_FTYPE_RGGAS) ! Regular cell
               DP(I,J+FCELL+ISIDE,K) = DP(I,J+FCELL+ISIDE,K) + FCT*KPDTDN * AF ! +ve or -ve dot
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell
               ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
               IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
               JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
               IF (PREDICTOR) THEN
                  CUT_CELL(ICC)%DS(JCC) = &
                  CUT_CELL(ICC)%DS(JCC) + FCT*KPDTDN * AF ! +ve or -ve dot
               ELSE
                  CUT_CELL(ICC)%D(JCC) = &
                  CUT_CELL(ICC)%D(JCC) + FCT*KPDTDN * AF ! +ve or -ve dot
               ENDIF
            END SELECT
         ENDDO

      CASE(KAXIS)
         AF = DX(I)*DY(J)
         X1F= MESHES(NM)%Z(K)
         IDX = 1._EB / ( IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                         IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND) )
         ! Linear interpolation coefficients:
         CCM1 = IDX*(IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
         CCP1 = IDX*(X1F -IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND))

         TMPV(-1:0)  = TMP(I,J,K+FCELL-1:K+FCELL)
         KPV(-1:0)   =  MU(I,J,K+FCELL-1:K+FCELL)*CPOPR
         DO ISIDE=-1,0
            ZZ_GET = 0._EB
            SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
               ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K+FCELL+ISIDE,1:N_TRACKED_SPECIES)
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
               JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
               TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
               ZZ_GET(1:N_TRACKED_SPECIES) =  &
                      PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
               (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
            END SELECT
            IF (DNS) CALL GET_CONDUCTIVITY(ZZ_GET,KPV(ISIDE),TMPV(ISIDE))
         ENDDO

         KPDTDN = (CCM1*KPV(-1)+CCP1*KPV(0)) * (TMPV(0)-TMPV(-1)) * IDX

         ! Add contribution to DP:
         ! Low side cell:
         DO ISIDE=-1,0
            FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
            SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
            CASE(IBM_FTYPE_RGGAS) ! Regular cell
               DP(I,J,K+FCELL+ISIDE) = DP(I,J,K+FCELL+ISIDE) + FCT*KPDTDN * AF ! +ve or -ve dot
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell
               ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
               IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
               JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
               IF (PREDICTOR) THEN
                  CUT_CELL(ICC)%DS(JCC) = &
                  CUT_CELL(ICC)%DS(JCC) + FCT*KPDTDN * AF ! +ve or -ve dot
               ELSE
                  CUT_CELL(ICC)%D(JCC) = &
                  CUT_CELL(ICC)%D(JCC) + FCT*KPDTDN * AF ! +ve or -ve dot
               ENDIF
            END SELECT
         ENDDO

   ENDSELECT

ENDDO

! GASPHASE cut-faces:
DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
   IF ( CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
   IW = CUT_FACE(ICF)%IWC
   ! Note: for cut-faces open boundaries are dealt with below in external BC loops:
   IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                           WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE
   I = CUT_FACE(ICF)%IJK(IAXIS)
   J = CUT_FACE(ICF)%IJK(JAXIS)
   K = CUT_FACE(ICF)%IJK(KAXIS)
   X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)
   SELECT CASE(X1AXIS)
   CASE(IAXIS)
      KPV(-1:0)   =  MU(I+FCELL-1:I+FCELL,J,K)*CPOPR
   CASE(JAXIS)
      KPV(-1:0)   =  MU(I,J+FCELL-1:J+FCELL,K)*CPOPR
   CASE(KAXIS)
      KPV(-1:0)   =  MU(I,J,K+FCELL-1:K+FCELL)*CPOPR
   END SELECT
   DO IFACE=1,CUT_FACE(ICF)%NFACE
      AF = CUT_FACE(ICF)%AREA(IFACE)
      X1F= CUT_FACE(ICF)%XYZCEN(X1AXIS,IFACE)
      IDX= 1._EB/ ( CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE) - &
                    CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE) )
      CCM1= IDX*(CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE)-X1F)
      CCP1= IDX*(X1F-CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE))
      ! Interpolate D_Z to the face, linear interpolation:
      TMPV(-1:0)  = -1._EB
      DO ISIDE=-1,0
         ZZ_GET = 0._EB
         SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
         CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
            ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
            JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
            TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
            ZZ_GET(1:N_TRACKED_SPECIES) =  &
                   PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
            (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
         END SELECT
         IF(DNS) CALL GET_CONDUCTIVITY(ZZ_GET,KPV(ISIDE),TMPV(ISIDE))
      ENDDO
      KPDTDN = (CCM1*KPV(-1)+CCP1*KPV(0)) * (TMPV(0)-TMPV(-1)) * IDX
      ! Add to divergence integral of surrounding cut-cells:
      DO ISIDE=-1,0
         FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
         SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
         CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
            ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
            IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
            JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
            IF (PREDICTOR) THEN
               CUT_CELL(ICC)%DS(JCC) = &
               CUT_CELL(ICC)%DS(JCC) + FCT*KPDTDN * AF ! +ve or -ve dot
            ELSE
               CUT_CELL(ICC)%D(JCC) = &
               CUT_CELL(ICC)%D(JCC) + FCT*KPDTDN * AF ! +ve or -ve dot
            ENDIF
         END SELECT
      ENDDO
   ENDDO ! IFACE
ENDDO ! ICF

! Now do Boundary conditions for Conductive Heat Flux:
! IAXIS faces:
X1AXIS = IAXIS
DO IFACE=1,MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)
   IW = IBM_REGFACE_IAXIS_Z(IFACE)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE ! Already done on previous loops.
   WC => WALL(IW)
   IIG = WC%ONE_D%IIG
   JJG = WC%ONE_D%JJG
   KKG = WC%ONE_D%KKG
   AF  = DY(JJG)*DZ(KKG)
   ! Q_LEAK accounts for enthalpy moving through leakage paths
   DP(IIG,JJG,KKG) = DP(IIG,JJG,KKG) - ( WC%ONE_D%QCONF ) * AF  + WC%Q_LEAK * (DX(IIG)*DY(JJG)*DZ(KKG))
ENDDO

! JAXIS faces:
X1AXIS = JAXIS
DO IFACE=1,MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)
   IW = IBM_REGFACE_JAXIS_Z(IFACE)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE ! Already done on previous loops.
   WC => WALL(IW)
   IIG = WC%ONE_D%IIG
   JJG = WC%ONE_D%JJG
   KKG = WC%ONE_D%KKG
   AF  = DX(IIG)*DZ(KKG)
   ! Q_LEAK accounts for enthalpy moving through leakage paths
   DP(IIG,JJG,KKG) = DP(IIG,JJG,KKG) - ( WC%ONE_D%QCONF ) * AF  + WC%Q_LEAK * (DX(IIG)*DY(JJG)*DZ(KKG))
ENDDO

! KAXIS faces:
X1AXIS = KAXIS
DO IFACE=1,MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)
   IW = IBM_REGFACE_KAXIS_Z(IFACE)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE ! Already done on previous loops.
   WC => WALL(IW)
   IIG = WC%ONE_D%IIG
   JJG = WC%ONE_D%JJG
   KKG = WC%ONE_D%KKG
   AF  = DX(IIG)*DY(JJG)
   ! Q_LEAK accounts for enthalpy moving through leakage paths
   DP(IIG,JJG,KKG) = DP(IIG,JJG,KKG) - ( WC%ONE_D%QCONF ) * AF  + WC%Q_LEAK * (DX(IIG)*DY(JJG)*DZ(KKG))
ENDDO

! Regular faces connecting gasphase - cut-cells:
DO IFACE=1,MESHES(NM)%IBM_NBBRCFACE_Z
   IW = IBM_RCFACE_Z(IFACE)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
   X1AXIS = IBM_RCFACE_Z(IFACE)%IJK(KAXIS+1)
   WC => WALL(IW)
   IIG = WC%ONE_D%IIG
   JJG = WC%ONE_D%JJG
   KKG = WC%ONE_D%KKG
   IOR = WC%ONE_D%IOR
   SELECT CASE(X1AXIS)
       CASE(IAXIS)
          AF=DY(JJG)*DZ(KKG)
       CASE(JAXIS)
          AF=DX(IIG)*DZ(KKG)
       CASE(KAXIS)
          AF=DX(IIG)*DY(JJG)
   END SELECT
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
   CASE(IBM_FTYPE_RGGAS) ! Regular cell.
      ! Q_LEAK accounts for enthalpy moving through leakage paths
      DP(IIG,JJG,KKG) = DP(IIG,JJG,KKG) - ( WC%ONE_D%QCONF ) * AF  + WC%Q_LEAK * (DX(IIG)*DY(JJG)*DZ(KKG))
   CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
      ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
      IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
      JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
      IF (PREDICTOR) THEN
         CUT_CELL(ICC)%DS(JCC) = &
         CUT_CELL(ICC)%DS(JCC) - ( WC%ONE_D%QCONF ) * AF + WC%Q_LEAK * CUT_CELL(ICC)%VOLUME(JCC) ! Qconf +ve sign is
                                                                                                 ! outwards of cut-cell.
      ELSE
         CUT_CELL(ICC)%D(JCC) = &
         CUT_CELL(ICC)%D(JCC) - ( WC%ONE_D%QCONF ) * AF  + WC%Q_LEAK * CUT_CELL(ICC)%VOLUME(JCC)
      ENDIF
   END SELECT
ENDDO

! GASPHASE cut-faces:
DO ICF = 1,MESHES(NM)%N_BBCUTFACE_MESH
   IF ( CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
   IW = MESHES(NM)%CUT_FACE(ICF)%IWC
   IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
       WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
       WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE

   I = CUT_FACE(ICF)%IJK(IAXIS)
   J = CUT_FACE(ICF)%IJK(JAXIS)
   K = CUT_FACE(ICF)%IJK(KAXIS)
   X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)
   WC => WALL(IW)
   IOR = WC%ONE_D%IOR
   ! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
   !                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
   ISIDE = -1 + (SIGN(1,IOR)+1) / 2
   ! External boundary cut-cells of type OPEN_BOUNDARY:
   GASBOUND_IF : IF (WALL(IW)%BOUNDARY_TYPE==OPEN_BOUNDARY) THEN
      FCT = -REAL(2*ISIDE+1,EB) ! Factor to set +ve or -ve sign of dot with normal outside.
      DO IFACE=1,CUT_FACE(ICF)%NFACE
         SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
         CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
            AF = CUT_FACE(ICF)%AREA(IFACE)
            X1F= CUT_FACE(ICF)%XYZCEN(X1AXIS,IFACE)
            IF (WC%ONE_D%IOR > 0) THEN
               IDX= 0.5_EB/(CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE)-X1F) ! Assumes DX twice the distance from WALL_CELL
                                                                      ! to internal cut-cell centroid.
            ELSE
               IDX= 0.5_EB/(X1F-CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE))
            ENDIF
            SELECT CASE(X1AXIS)
            CASE(IAXIS)
               KPV(-1:0)   =   MU(I+FCELL-1:I+FCELL  ,J,K)*CPOPR
               TMPV(-1:0)  =  TMP(I+FCELL-1:I+FCELL  ,J,K)
            CASE(JAXIS)
               KPV(-1:0)   =   MU(I,J+FCELL-1:J+FCELL  ,K)*CPOPR
               TMPV(-1:0)  =  TMP(I,J+FCELL-1:J+FCELL  ,K)
            CASE(KAXIS)
               KPV(-1:0)   =   MU(I,J,K+FCELL-1:K+FCELL  )*CPOPR
               TMPV(-1:0)  =  TMP(I,J,K+FCELL-1:K+FCELL  )
            END SELECT
            ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
            IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
            JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
            TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
            IF (DNS) THEN
               ZZ_GET(1:N_TRACKED_SPECIES) =  PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                                       (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
               CALL GET_CONDUCTIVITY(ZZ_GET,KPV(ISIDE),TMPV(ISIDE))
            ENDIF
            KPDTDN = 0.5_EB*(KPV(-1)+KPV(0)) * (TMPV(0)-TMPV(-1)) * IDX
            IF (PREDICTOR) THEN
               CUT_CELL(ICC)%DS(JCC) = CUT_CELL(ICC)%DS(JCC) + FCT*KPDTDN * AF ! +ve or -ve dot
            ELSE
               CUT_CELL(ICC)%D(JCC)  = CUT_CELL(ICC)%D(JCC)  + FCT*KPDTDN * AF ! +ve or -ve dot
            ENDIF
         END SELECT
      ENDDO

   ELSE
      ! Other boundary conditions:
      DO IFACE=1,CUT_FACE(ICF)%NFACE
         AF = CUT_FACE(ICF)%AREA(IFACE)
         SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
         CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
            ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
            IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE ! Cut-cell is guard-cell cc.
            JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
            IF (PREDICTOR) THEN
               CUT_CELL(ICC)%DS(JCC) = &
               CUT_CELL(ICC)%DS(JCC) - ( WC%ONE_D%QCONF ) * AF + WC%Q_LEAK * CUT_CELL(ICC)%VOLUME(JCC) ! Qconf +ve sign
                                                                                              ! is outwards of cut-cell.
            ELSE
               CUT_CELL(ICC)%D(JCC) = &
               CUT_CELL(ICC)%D(JCC) - ( WC%ONE_D%QCONF ) * AF  + WC%Q_LEAK * CUT_CELL(ICC)%VOLUME(JCC)
            ENDIF
         END SELECT
      ENDDO
   ENDIF GASBOUND_IF
ENDDO

! INBOUNDARY cut-faces, loop on CFACE to add BC defined at SOLID phase:
IF (PREDICTOR) THEN
  DO ICF=1,N_CFACE_CELLS
     CFA  => CFACE(ICF)
     IND1 = CFA%CUT_FACE_IND1;                         IND2 = CFA%CUT_FACE_IND2
     ICC  = CUT_FACE(IND1)%CELL_LIST(2,LOW_IND,IND2);  JCC  = CUT_FACE(IND1)%CELL_LIST(3,LOW_IND,IND2)
     CUT_CELL(ICC)%DS(JCC)=CUT_CELL(ICC)%DS(JCC)-( CFA%ONE_D%QCONF ) * CUT_FACE(IND1)%AREA(IND2) ! QCONF(+) into solid.
  ENDDO
ELSE
  DO ICF=1,N_CFACE_CELLS
     CFA  => CFACE(ICF)
     IND1 = CFA%CUT_FACE_IND1;                         IND2 = CFA%CUT_FACE_IND2
     ICC  = CUT_FACE(IND1)%CELL_LIST(2,LOW_IND,IND2);  JCC  = CUT_FACE(IND1)%CELL_LIST(3,LOW_IND,IND2)
     CUT_CELL(ICC)%D(JCC) = CUT_CELL(ICC)%D(JCC)-( CFA%ONE_D%QCONF ) * CUT_FACE(IND1)%AREA(IND2) ! QCONF(+) into solid.
  ENDDO
ENDIF

! EXIM faces:
DO IEXIM=1,MESHES(NM)%IBM_NEXIMFACE_MESH
  I      = IBM_EXIM_FACE(IEXIM)%IJK(IAXIS)
  J      = IBM_EXIM_FACE(IEXIM)%IJK(JAXIS)
  K      = IBM_EXIM_FACE(IEXIM)%IJK(KAXIS)
  X1AXIS = IBM_EXIM_FACE(IEXIM)%IJK(KAXIS+1)
  LHFACE = IBM_EXIM_FACE(IEXIM)%LHFACE
  AF     = IBM_EXIM_FACE(IEXIM)%AREA
  IW     = IBM_EXIM_FACE(IEXIM)%IWC

  IF((IW>0) .AND. WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY) CYCLE
  IF((IW>0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                        WALL(IW)%BOUNDARY_TYPE==OPEN_BOUNDARY         .OR. &
                        WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY) ) THEN ! Boundary faces, re-compute EXIM faces
                                                                          ! RHO_D_DZDN
     WC => WALL(IW)
     IIG = WC%ONE_D%IIG
     JJG = WC%ONE_D%JJG
     KKG = WC%ONE_D%KKG
     ! Q_LEAK accounts for enthalpy moving through leakage paths
     DP(IIG,JJG,KKG) = DP(IIG,JJG,KKG) - ( WC%ONE_D%QCONF ) * AF  + WC%Q_LEAK * (DX(IIG)*DY(JJG)*DZ(KKG))
  ELSE

     SELECT CASE(X1AXIS)
     CASE(IAXIS)
        ! K*DTDN:
        TMPV(-1:0)  = TMP(I+FCELL-1:I+FCELL,J,K)
        KPV(-1:0)   =  MU(I+FCELL-1:I+FCELL,J,K)*CPOPR
        ! KP on low-high side cells:
        IF (DNS) THEN
           DO ISIDE=-1,0
              ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I+FCELL+ISIDE,J,K,1:N_TRACKED_SPECIES)
              CALL GET_CONDUCTIVITY(ZZ_GET,KPV(ISIDE),TMPV(ISIDE))
           ENDDO
        ENDIF
        KPDTDN = 0.5_EB*(KPV(-1)+KPV(0)) * (TMPV(0)-TMPV(-1)) / DX(I)
        ! Add H_RHO_D_DZDN dot n to corresponding cell DP:
        IF(LHFACE == LOW_IND) THEN ! Face on low side of cell
           DP(I+FCELL  ,J,K) = DP(I+FCELL  ,J,K) - KPDTDN * AF ! -ve dot
        ELSE ! Face on high side of cell
           DP(I+FCELL-1,J,K) = DP(I+FCELL-1,J,K) + KPDTDN * AF ! +ve dot
        ENDIF
     CASE(JAXIS)
        ! K*DTDN:
        TMPV(-1:0)  = TMP(I,J+FCELL-1:J+FCELL,K)
        KPV(-1:0)   =  MU(I,J+FCELL-1:J+FCELL,K)*CPOPR
        ! KP on low-high side cells:
        IF (DNS) THEN
           DO ISIDE=-1,0
              ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J+FCELL+ISIDE,K,1:N_TRACKED_SPECIES)
              CALL GET_CONDUCTIVITY(ZZ_GET,KPV(ISIDE),TMPV(ISIDE))
           ENDDO
        ENDIF
        KPDTDN = 0.5_EB*(KPV(-1)+KPV(0)) * (TMPV(0)-TMPV(-1)) / DY(J)
        ! Add H_RHO_D_DZDN dot n to corresponding cell DP:
        IF(LHFACE == LOW_IND) THEN ! Face on low side of cell
           DP(I,J+FCELL  ,K) = DP(I,J+FCELL  ,K) - KPDTDN * AF ! -ve dot
        ELSE ! Face on high side of cell
           DP(I,J+FCELL-1,K) = DP(I,J+FCELL-1,K) + KPDTDN * AF ! +ve dot
        ENDIF
     CASE(KAXIS)
        ! K*DTDN:
        TMPV(-1:0)  = TMP(I,J,K+FCELL-1:K+FCELL)
        KPV(-1:0)   =  MU(I,J,K+FCELL-1:K+FCELL)*CPOPR
        ! KP on low-high side cells:
        IF (DNS) THEN
           DO ISIDE=-1,0
              ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(I,J,K+FCELL+ISIDE,1:N_TRACKED_SPECIES)
              CALL GET_CONDUCTIVITY(ZZ_GET,KPV(ISIDE),TMPV(ISIDE))
           ENDDO
        ENDIF
        KPDTDN = 0.5_EB*(KPV(-1)+KPV(0)) * (TMPV(0)-TMPV(-1)) / DZ(K)
        ! Add H_RHO_D_DZDN dot n to corresponding cell DP:
        IF(LHFACE == LOW_IND) THEN ! Face on low side of cell
           DP(I,J,K+FCELL  ) = DP(I,J,K+FCELL  ) - KPDTDN * AF ! -ve dot
        ELSE ! Face on high side of cell
           DP(I,J,K+FCELL-1) = DP(I,J,K+FCELL-1) + KPDTDN * AF ! +ve dot
        ENDIF
     END SELECT

  ENDIF

ENDDO

RETURN
END SUBROUTINE CCREGION_CONDUCTION_HEAT_FLUX


END SUBROUTINE CCREGION_DIVERGENCE_PART_1

! ----------------------- CCREGION_DIFFUSIVE_MASS_FLUXES -------------------------

SUBROUTINE CCREGION_DIFFUSIVE_MASS_FLUXES(NM)
USE MATH_FUNCTIONS, ONLY: INTERPOLATE1D_UNIFORM
USE MANUFACTURED_SOLUTIONS, ONLY: DIFF_MMS
INTEGER, INTENT(IN) :: NM

! NOTE: this routine assumes POINT_TO_MESH(NM) has been previously called.

! Local Variables:
INTEGER :: N,I,J,K,X1AXIS,ISIDE,IFACE,ICC,JCC,ICF
REAL(EB), POINTER, DIMENSION(:,:,:) :: RHOP=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: ZZP=>NULL()
REAL(EB) :: D_Z_N(0:5000),CCM1,CCP1,IDX,DIFF_FACE,VELD,D_Z_TEMP(-1:0),MUV(-1:0), &
            RHOPV(-1:0),RHOPVN(-1:0),TMPV(-1:0),ZZPV(-1:0),X1F,PRFCT
REAL(EB), ALLOCATABLE, DIMENSION(:) :: ZZ_GET
INTEGER :: N_LOOKUP
INTEGER :: IW
REAL(EB) :: RHO_D_DZDN, ZZ_FACE, TMP_FACE

SELECT CASE(PREDICTOR)
   CASE(.TRUE.)
      ZZP => ZZS
      RHOP => RHOS
      PRFCT = 0._EB ! Use star cut-cell quantities.
   CASE(.FALSE.)
      ZZP => ZZ
      RHOP => RHO
      PRFCT = 1._EB ! Use end of step cut-cell quantities.
END SELECT

ALLOCATE(ZZ_GET(N_TRACKED_SPECIES))

! 1. Diffusive Heat flux = - Grad dot (h_s rho D Grad Z_n):
! In FV form: use faces to add corresponding face integral terms, for face k
! (sum_a{h_{s,a} rho D_a Grad z_a) dot \hat{n}_k A_k, where \hat{n}_k is the versor outside of cell
! at face k.
DIFFUSIVE_FLUX_LOOP: DO N=1,N_TOTAL_SCALARS

   ! Diffusivity lookup table for species N:
   N_LOOKUP = N
   D_Z_N(:) = D_Z(:,N_LOOKUP)

   ! First Regular faces connecting regular cells on scalar implicit region:
   ! Linear interpolation coefficients:
   CCM1 = 0.5_EB;  CCP1 = 0.5_EB ! Uniform Grid

   ! IAXIS faces:
   X1AXIS = IAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      IW = IBM_REGFACE_IAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
      J  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
      K  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)

      ! Face dx:
      IDX= 1._EB/DXN(I)

      ! Diffusive Part:
      IF (DNS) THEN
         IF(PERIODIC_TEST==7) THEN
            ! Interpolate D_Z to the face:
            DO ISIDE=-1,0
               D_Z_TEMP(ISIDE) = DIFF_MMS / RHOP(I+FCELL+ISIDE,J,K)
            ENDDO
         ELSE
            ! Interpolate D_Z to the face:
            DO ISIDE=-1,0
               CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMP(I+FCELL+ISIDE,J,K),D_Z_TEMP(ISIDE))
            ENDDO
         ENDIF
      ELSE ! LES
         DO ISIDE=-1,0
            D_Z_TEMP(ISIDE)= MU(I+FCELL+ISIDE,J,K)*RSC/RHOP(I+FCELL+ISIDE,J,K)
         ENDDO
      ENDIF

      ! One Term defined flux:
      DIFF_FACE = CCM1*RHOP(I+FCELL-1,J,K)*D_Z_TEMP(-1) + CCP1*RHOP(I+FCELL  ,J,K)*D_Z_TEMP(0)
      IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N,LOW_IND) = &
      DIFF_FACE*IDX*(ZZP(I+FCELL  ,J,K,N) - ZZP(I+FCELL-1,J,K,N) ) ! rho D_a Grad(Y_a)

      IF(DO_IMPLICIT_CCREGION) THEN
         IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D(N)=DIFF_FACE
         IBM_REGFACE_IAXIS_Z(IFACE)%RHOPVN(-1:0) = RHOP(I+FCELL-1:I+FCELL  ,J,K)
         RHOPVN(-1:0)=IBM_REGFACE_IAXIS_Z(IFACE)%RHOPVN(-1:0)
         IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N,LOW_IND) = &
         DIFF_FACE*IDX*(RHOP(I+FCELL  ,J,K)*ZZP(I+FCELL  ,J,K,N)/RHOPVN( 0) - &
                        RHOP(I+FCELL-1,J,K)*ZZP(I+FCELL-1,J,K,N)/RHOPVN(-1) ) ! rho D_a Grad(Y_a)
      ENDIF

      ! Two term defined flux:
      IF (.NOT.DO_IMPLICIT_CCREGION .OR. .NOT.IMP_REGION_FROM_MATRIX_DIFF) THEN
         IBM_REGFACE_IAXIS_Z(IFACE)%DIFF_FACE(N)=CCM1*D_Z_TEMP(-1) + CCP1*D_Z_TEMP(0)
         IBM_REGFACE_IAXIS_Z(IFACE)%VELD(N)= IBM_REGFACE_IAXIS_Z(IFACE)%DIFF_FACE(N)* &
                                                       2._EB*IDX*(RHOP(I+FCELL  ,J,K)-RHOP(I+FCELL-1,J,K))/ &
                                                                 (RHOP(I+FCELL  ,J,K)+RHOP(I+FCELL-1,J,K))
      ENDIF
      DIFF_FACE = IBM_REGFACE_IAXIS_Z(IFACE)%DIFF_FACE(N)
      VELD = IBM_REGFACE_IAXIS_Z(IFACE)%VELD(N)

      ! Here VelD and the Diff coefficient are evaluated with the end of step soln.
      ! Note: this is different than the flux evaluation done on scalar transport on the
      ! step, in the sense that DIFF_FACE and VELD are evaluated with end of step rho and ZZ.
      ! Now add to Adiff corresponding coeff:
      IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND) = &
             - VELD*0.5_EB*(RHOP(I+FCELL  ,J,K)*ZZP(I+FCELL  ,J,K,N)   + &
                            RHOP(I+FCELL-1,J,K)*ZZP(I+FCELL-1,J,K,N) ) + & !-D_a/rho*Grad rho * (rho Y_a)
               DIFF_FACE*IDX*(RHOP(I+FCELL  ,J,K)*ZZP(I+FCELL  ,J,K,N) - &
                              RHOP(I+FCELL-1,J,K)*ZZP(I+FCELL-1,J,K,N) )   ! D_a Grad(rho Y_a)

   ENDDO

   ! JAXIS faces:
   X1AXIS = JAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      IW = IBM_REGFACE_JAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
      J  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
      K  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)

      ! Face dx:
      IDX= 1._EB/DYN(J)

      ! Diffusive Part:
      IF (DNS) THEN
         IF(PERIODIC_TEST==7) THEN
            ! Interpolate D_Z to the face:
            DO ISIDE=-1,0
               D_Z_TEMP(ISIDE) = DIFF_MMS / RHOP(I,J+FCELL+ISIDE,K)
            ENDDO
         ELSE
            ! Interpolate D_Z to the face:
            DO ISIDE=-1,0
               CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMP(I,J+FCELL+ISIDE,K),D_Z_TEMP(ISIDE))
            ENDDO
         ENDIF
      ELSE ! LES
         DO ISIDE=-1,0
            D_Z_TEMP(ISIDE)= MU(I,J+FCELL+ISIDE,K)*RSC/RHOP(I,J+FCELL+ISIDE,K)
         ENDDO
      ENDIF

      ! One Term defined flux:
      DIFF_FACE = CCM1*RHOP(I,J+FCELL-1,K)*D_Z_TEMP(-1) + CCP1*RHOP(I,J+FCELL  ,K)*D_Z_TEMP(0)
      IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N,LOW_IND) = &
      DIFF_FACE*IDX*(ZZP(I,J+FCELL  ,K,N) - ZZP(I,J+FCELL-1,K,N))   ! rho D_a Grad(Y_a)

      IF(DO_IMPLICIT_CCREGION) THEN
         IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D(N)=DIFF_FACE
         IBM_REGFACE_JAXIS_Z(IFACE)%RHOPVN(-1:0) = RHOP(I,J+FCELL-1:J+FCELL  ,K)
         RHOPVN(-1:0)=IBM_REGFACE_JAXIS_Z(IFACE)%RHOPVN(-1:0)
         IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N,LOW_IND) = &
         DIFF_FACE*IDX*(RHOP(I,J+FCELL  ,K)*ZZP(I,J+FCELL  ,K,N)/RHOPVN( 0) - &
                        RHOP(I,J+FCELL-1,K)*ZZP(I,J+FCELL-1,K,N)/RHOPVN(-1) ) ! rho D_a Grad(Y_a)
      ENDIF

      ! Two Terms defined flux:
      IF (.NOT.DO_IMPLICIT_CCREGION .OR. .NOT.IMP_REGION_FROM_MATRIX_DIFF) THEN
         IBM_REGFACE_JAXIS_Z(IFACE)%DIFF_FACE(N)=CCM1*D_Z_TEMP(-1) + CCP1*D_Z_TEMP(0)
         IBM_REGFACE_JAXIS_Z(IFACE)%VELD(N)= IBM_REGFACE_JAXIS_Z(IFACE)%DIFF_FACE(N)* &
                                                       2._EB*IDX*(RHOP(I,J+FCELL  ,K)-RHOP(I,J+FCELL-1,K))/ &
                                                                 (RHOP(I,J+FCELL  ,K)+RHOP(I,J+FCELL-1,K))
      ENDIF
      DIFF_FACE = IBM_REGFACE_JAXIS_Z(IFACE)%DIFF_FACE(N)
      VELD = IBM_REGFACE_JAXIS_Z(IFACE)%VELD(N)

      ! Here VelD and the Diff coefficient are evaluated with the end of step soln.
      ! Note: this is different than the flux evaluation done on scalar transport on the
      ! step, in the sense that DIFF_FACE and VELD are evaluated with end of step rho and ZZ.
      ! Now add to Adiff corresponding coeff:
      IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND) = &
             - VELD*0.5_EB*(RHOP(I,J+FCELL  ,K)*ZZP(I,J+FCELL  ,K,N)   + &
                            RHOP(I,J+FCELL-1,K)*ZZP(I,J+FCELL-1,K,N) ) + & !-D_a/rho*Grad rho * (rho Y_a)
               DIFF_FACE*IDX*(RHOP(I,J+FCELL  ,K)*ZZP(I,J+FCELL  ,K,N) - &
                              RHOP(I,J+FCELL-1,K)*ZZP(I,J+FCELL-1,K,N) )   ! D_a Grad(rho Y_a)

   ENDDO

   ! KAXIS faces:
   X1AXIS = KAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      IW = IBM_REGFACE_KAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
      J  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
      K  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)

      ! Face dx:
      IDX= 1._EB/DZN(K)

      ! Diffusive Part:
      IF (DNS) THEN
         IF(PERIODIC_TEST==7) THEN
            ! Interpolate D_Z to the face:
            DO ISIDE=-1,0
               D_Z_TEMP(ISIDE) = DIFF_MMS / RHOP(I,J,K+FCELL+ISIDE)
            ENDDO
         ELSE
            ! Interpolate D_Z to the face:
            DO ISIDE=-1,0
               CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMP(I,J,K+FCELL+ISIDE),D_Z_TEMP(ISIDE))
            ENDDO
         ENDIF
      ELSE ! LES
         DO ISIDE=-1,0
            D_Z_TEMP(ISIDE)= MU(I,J,K+FCELL+ISIDE)*RSC/RHOP(I,J,K+FCELL+ISIDE)
         ENDDO
      ENDIF

      ! One Term defined flux:
      DIFF_FACE = CCM1*RHOP(I,J,K+FCELL-1)*D_Z_TEMP(-1) + CCP1*RHOP(I,J,K+FCELL  )*D_Z_TEMP(0)
      IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N,LOW_IND) = &
      DIFF_FACE*IDX*(ZZP(I,J,K+FCELL  ,N) - ZZP(I,J,K+FCELL-1,N) )   ! + rho D_a Grad(Y_a)

      IF(DO_IMPLICIT_CCREGION) THEN
         IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D(N)=DIFF_FACE
         IBM_REGFACE_KAXIS_Z(IFACE)%RHOPVN(-1:0) = RHOP(I,J,K+FCELL-1:K+FCELL  )
         RHOPVN(-1:0)=IBM_REGFACE_KAXIS_Z(IFACE)%RHOPVN(-1:0)
         IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N,LOW_IND) = &
         DIFF_FACE*IDX*(RHOP(I,J,K+FCELL  )*ZZP(I,J,K+FCELL  ,N)/RHOPVN( 0) - &
                        RHOP(I,J,K+FCELL-1)*ZZP(I,J,K+FCELL-1,N)/RHOPVN(-1) ) ! rho D_a Grad(Y_a)
         !IF(K==2) WRITE(0,*) PREDICTOR,I,J,K,RHOP(I,J,K),RHOPVN(-1),RHOP(I,J,K)/RHOPVN(-1)
      ENDIF

      ! Two Terms defined flux:
      IF (.NOT.DO_IMPLICIT_CCREGION .OR. .NOT.IMP_REGION_FROM_MATRIX_DIFF) THEN
         IBM_REGFACE_KAXIS_Z(IFACE)%DIFF_FACE(N)=CCM1*D_Z_TEMP(-1) + CCP1*D_Z_TEMP(0)
         IBM_REGFACE_KAXIS_Z(IFACE)%VELD(N)= IBM_REGFACE_KAXIS_Z(IFACE)%DIFF_FACE(N)* &
                                                       2._EB*IDX*(RHOP(I,J,K+FCELL  )-RHOP(I,J,K+FCELL-1))/ &
                                                                 (RHOP(I,J,K+FCELL  )+RHOP(I,J,K+FCELL-1))
      ENDIF
      DIFF_FACE = IBM_REGFACE_KAXIS_Z(IFACE)%DIFF_FACE(N)
      VELD = IBM_REGFACE_KAXIS_Z(IFACE)%VELD(N)

      ! Here VelD and the Diff coefficient are evaluated with the end of step soln.
      ! Note: this is different than the flux evaluation done on scalar transport on the
      ! step, in the sense that DIFF_FACE and VELD are evaluated with end of step rho and ZZ.
      ! Now add to Adiff corresponding coeff:
      IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND) = &
             - VELD*0.5_EB*(RHOP(I,J,K+FCELL  )*ZZP(I,J,K+FCELL  ,N)   + &
                            RHOP(I,J,K+FCELL-1)*ZZP(I,J,K+FCELL-1,N) ) + & !-D_a/rho*Grad rho * (rho Y_a)
               DIFF_FACE*IDX*(RHOP(I,J,K+FCELL  )*ZZP(I,J,K+FCELL  ,N) - &
                              RHOP(I,J,K+FCELL-1)*ZZP(I,J,K+FCELL-1,N) )   ! + D_a Grad(rho Y_a)

   ENDDO


   ! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
   DO IFACE=1,MESHES(NM)%IBM_NRCFACE_Z

      IW = IBM_RCFACE_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I      = IBM_RCFACE_Z(IFACE)%IJK(IAXIS)
      J      = IBM_RCFACE_Z(IFACE)%IJK(JAXIS)
      K      = IBM_RCFACE_Z(IFACE)%IJK(KAXIS)
      X1AXIS = IBM_RCFACE_Z(IFACE)%IJK(KAXIS+1)

      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            X1F= MESHES(NM)%X(I)
            IDX = 1._EB / ( IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                            IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND) )
            ! Linear interpolation coefficients:
            CCM1 = IDX*(IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
            CCP1 = IDX*(X1F -IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND))

            TMPV(-1:0)  = TMP(I+FCELL-1:I+FCELL,J,K)
            RHOPV(-1:0) = RHOP(I+FCELL-1:I+FCELL,J,K)
            ZZPV(-1:0)  = ZZP(I+FCELL-1:I+FCELL,J,K,N)
            DO ISIDE=-1,0
               SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
               CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
                  ! TMPV(ISIDE) = TMPV(ISIDE)
               CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
                  JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
                  TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
                  RHOPV(ISIDE)=        PRFCT *CUT_CELL(ICC)%RHO(JCC) + &
                                (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
                  ZZPV(ISIDE) =        PRFCT *CUT_CELL(ICC)%ZZ(N,JCC) + &
                                (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
               CASE DEFAULT
                  print*, 'MESHES(NM)%IBM_NRCFACE_Z face not connected to REG or CC cell',NM,IFACE
                  TMPV(ISIDE) = -1._EB
               END SELECT
               D_Z_TEMP(ISIDE)= MU(I+FCELL+ISIDE,J,K)*RSC/RHOPV(ISIDE) ! Here we use the cut-cells
                                                                       ! underlying Cartesian turb MU.
            ENDDO
            ! Diffusion Velocity D/rho drho/dx
            VELD = IDX*(     RHOPV(0)-     RHOPV(-1))/ &
                       (CCP1*RHOPV(0)+CCM1*RHOPV(-1)) ! DIFF_FACE further down.

         CASE(JAXIS)
            X1F= MESHES(NM)%Y(J)
            IDX = 1._EB / ( IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                            IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND) )
            ! Linear interpolation coefficients:
            CCM1 = IDX*(IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
            CCP1 = IDX*(X1F -IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND))

            TMPV(-1:0)  = TMP(I,J+FCELL-1:J+FCELL,K)
            RHOPV(-1:0) = RHOP(I,J+FCELL-1:J+FCELL,K)
            ZZPV(-1:0)  = ZZP(I,J+FCELL-1:J+FCELL,K,N)
            DO ISIDE=-1,0
               SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
               CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
                  ! TMPV(ISIDE) = TMPV(ISIDE)
                  ! RHOPV(ISIDE)= RHOPV(ISIDE)
               CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
                  JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
                  TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
                  RHOPV(ISIDE)=        PRFCT *CUT_CELL(ICC)%RHO(JCC) + &
                                (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
                  ZZPV(ISIDE) =        PRFCT *CUT_CELL(ICC)%ZZ(N,JCC) + &
                                (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
               CASE DEFAULT
                  print*, 'MESHES(NM)%IBM_NRCFACE_Z face not connected to REG or CC cell',NM,IFACE
                  TMPV(ISIDE) = -1._EB
               END SELECT
               D_Z_TEMP(ISIDE)= MU(I,J+FCELL+ISIDE,K)*RSC/RHOPV(ISIDE) ! Here we use the cut-cells
                                                                       ! underlying Cartesian turb MU.
            ENDDO
            ! Diffusion Velocity D/rho drho/dy
            VELD = IDX*(     RHOPV(0)-     RHOPV(-1))/ &
                       (CCP1*RHOPV(0)+CCM1*RHOPV(-1)) ! DIFF_FACE further down.

         CASE(KAXIS)
            X1F= MESHES(NM)%Z(K)
            IDX = 1._EB / ( IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                            IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND) )
            ! Linear interpolation coefficients:
            CCM1 = IDX*(IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
            CCP1 = IDX*(X1F -IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND))

            TMPV(-1:0)  = TMP(I,J,K+FCELL-1:K+FCELL)
            RHOPV(-1:0) = RHOP(I,J,K+FCELL-1:K+FCELL)
            ZZPV(-1:0)  = ZZP(I,J,K+FCELL-1:K+FCELL,N)
            DO ISIDE=-1,0
               SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
               CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
                  ! TMPV(ISIDE) = TMPV(ISIDE)
                  ! RHOPV(ISIDE)= RHOPV(ISIDE)
               CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
                  JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
                  TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
                  RHOPV(ISIDE)=        PRFCT *CUT_CELL(ICC)%RHO(JCC) + &
                                (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
                  ZZPV(ISIDE) =        PRFCT *CUT_CELL(ICC)%ZZ(N,JCC) + &
                                (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
               CASE DEFAULT
                  print*, 'MESHES(NM)%IBM_NRCFACE_Z face not connected to REG or CC cell',NM,IFACE
                  TMPV(ISIDE) = -1._EB
               END SELECT
               D_Z_TEMP(ISIDE)= MU(I,J,K+FCELL+ISIDE)*RSC/RHOPV(ISIDE) ! Here we use the cut-cells
                                                                       ! underlying Cartesian turb MU.
            ENDDO
            ! Diffusion Velocity D/rho drho/dz
            VELD = IDX*(     RHOPV(0)-     RHOPV(-1))/ &
                       (CCP1*RHOPV(0)+CCM1*RHOPV(-1)) ! DIFF_FACE further down.

      ENDSELECT

      ! Interpolate D_Z to the face, linear interpolation:
      IF (DNS) THEN
         IF(PERIODIC_TEST==7) THEN
            ! Interpolate D_Z to the face:
            DO ISIDE=-1,0
               D_Z_TEMP(ISIDE) = DIFF_MMS / RHOPV(ISIDE)
            ENDDO
         ELSE
            DO ISIDE=-1,0
               CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMPV(ISIDE),D_Z_TEMP(ISIDE))
            ENDDO
         ENDIF
      ENDIF

      ! One Term defined flux:
      DIFF_FACE = CCM1*RHOPV(-1)*D_Z_TEMP(-1) + CCP1*RHOPV(0)*D_Z_TEMP(0)
      IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(N,LOW_IND) = DIFF_FACE*IDX*(ZZPV(0) - ZZPV(-1) ) ! + rho D_a Grad(Y_a)

      IF(DO_IMPLICIT_CCREGION) THEN
         IBM_RCFACE_Z(IFACE)%RHO_D(N)=DIFF_FACE
         IBM_RCFACE_Z(IFACE)%RHOPVN(-1:0) = RHOPV(-1:0)
         RHOPVN(-1:0)=IBM_RCFACE_Z(IFACE)%RHOPVN(-1:0)
         IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(N,LOW_IND) = &
         DIFF_FACE*IDX*(RHOPV( 0)*ZZPV( 0)/RHOPVN( 0) - RHOPV(-1)*ZZPV(-1)/RHOPVN(-1) ) ! rho D_a Grad(Y_a)
      ENDIF

      ! Two Terms defined flux:
      IF (.NOT.DO_IMPLICIT_CCREGION .OR. .NOT.IMP_REGION_FROM_MATRIX_DIFF) THEN
         IBM_RCFACE_Z(IFACE)%DIFF_FACE(N)=CCM1*D_Z_TEMP(-1) + CCP1*D_Z_TEMP(0)
         IBM_RCFACE_Z(IFACE)%VELD(N)=IBM_RCFACE_Z(IFACE)%DIFF_FACE(N)*VELD
      ENDIF
      DIFF_FACE = IBM_RCFACE_Z(IFACE)%DIFF_FACE(N)
      VELD = IBM_RCFACE_Z(IFACE)%VELD(N)

      IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(N,HIGH_IND) = &
        - VELD*(CCP1*RHOPV(0)*ZZPV(0)   + CCM1*RHOPV(-1)*ZZPV(-1) ) + & !-D_a/rho*Grad rho * (rho Y_a)
             DIFF_FACE*IDX*(RHOPV(0)*ZZPV(0) - RHOPV(-1)*ZZPV(-1) )     ! + D_a Grad(rho Y_a)

      IBM_RCFACE_Z(IFACE)%ZZ_FACE(N) = CCM1*ZZPV(-1) + CCP1*ZZPV(0) ! Linear interpolation of ZZ to the face.
      IBM_RCFACE_Z(IFACE)%TMP_FACE = CCM1*TMPV(-1) + CCP1*TMPV(0)   ! Linear interpolation of Temp to the face.

   ENDDO


   ! GASPHASE cut-faces:
   DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH

      IF ( CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
      IW = CUT_FACE(ICF)%IWC
      ! Note: for cut-faces open boundaries are dealt with below in external BC loops:
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I = CUT_FACE(ICF)%IJK(IAXIS)
      J = CUT_FACE(ICF)%IJK(JAXIS)
      K = CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)

      DO IFACE=1,CUT_FACE(ICF)%NFACE

         !AF = CUT_FACE(ICF)%AREA(IFACE)
         X1F= CUT_FACE(ICF)%XYZCEN(X1AXIS,IFACE)
         IDX= 1._EB/ ( CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE) - &
                       CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE) )
         CCM1= IDX*(CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE)-X1F)
         CCP1= IDX*(X1F-CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE))

         SELECT CASE (X1AXIS)
         CASE(IAXIS)
            MUV(-1:0) = MU(I+FCELL-1:I+FCELL  ,J,K)
         CASE(JAXIS)
            MUV(-1:0) = MU(I,J+FCELL-1:J+FCELL  ,K)
         CASE(KAXIS)
            MUV(-1:0) = MU(I,J,K+FCELL-1:K+FCELL  )
         END SELECT

         ! Interpolate D_Z to the face, linear interpolation:
         TMPV(-1:0)  = -1._EB; RHOPV(-1:0) = -1._EB; ZZPV(-1:0)  = -1._EB
         DO ISIDE=-1,0
            SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
               JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
               TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
               RHOPV(ISIDE)=        PRFCT *CUT_CELL(ICC)%RHO(JCC) + &
                             (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
               ZZPV(ISIDE) =        PRFCT *CUT_CELL(ICC)%ZZ(N,JCC) + &
                             (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
            CASE DEFAULT
               print*, 'CUT_FACE face not connected to CC cell',NM,IFACE
               TMPV(ISIDE) = -1._EB
            END SELECT
            IF (DNS) THEN
               IF(PERIODIC_TEST==7) THEN
                  D_Z_TEMP(ISIDE) = DIFF_MMS / RHOPV(ISIDE)
               ELSE
                  CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMPV(ISIDE),D_Z_TEMP(ISIDE))
               ENDIF
            ELSE
               D_Z_TEMP(ISIDE) = MUV(ISIDE)*RSC/RHOPV(ISIDE)
            ENDIF
         ENDDO

         ! One Term defined flux:
         DIFF_FACE = CCM1*RHOPV(-1)*D_Z_TEMP(-1) + CCP1*RHOPV(0)*D_Z_TEMP(0)
         CUT_FACE(ICF)%RHO_D_DZDN(N,LOW_IND,IFACE) = DIFF_FACE*IDX*(ZZPV(0) - ZZPV(-1) ) ! rho D_a Grad(Y_a)

         IF(DO_IMPLICIT_CCREGION) THEN
            CUT_FACE(ICF)%RHO_D(N,IFACE)=DIFF_FACE
            CUT_FACE(ICF)%RHOPVN(-1:0,IFACE)=RHOPV(-1:0)
            RHOPVN(-1:0)=CUT_FACE(ICF)%RHOPVN(-1:0,IFACE)
            CUT_FACE(ICF)%RHO_D_DZDN(N,LOW_IND,IFACE) = &
            DIFF_FACE*IDX*(RHOPV( 0)*ZZPV( 0)/RHOPVN( 0) - RHOPV(-1)*ZZPV(-1)/RHOPVN(-1) ) ! rho D_a Grad(Y_a)
         ENDIF

         ! Two Terms defined flux:
         IF (.NOT.DO_IMPLICIT_CCREGION .OR. .NOT.IMP_REGION_FROM_MATRIX_DIFF) THEN
            CUT_FACE(ICF)%DIFF_FACE(N,IFACE)=CCM1*D_Z_TEMP(-1) + CCP1*D_Z_TEMP(0)
            CUT_FACE(ICF)%VELD(N,IFACE)=CUT_FACE(ICF)%DIFF_FACE(N,IFACE)*IDX*(    RHOPV(0)-     RHOPV(-1))/&
                                                                                     (CCP1*RHOPV(0)+CCM1*RHOPV(-1))
         ENDIF
         DIFF_FACE = CUT_FACE(ICF)%DIFF_FACE(N,IFACE)
         VELD = CUT_FACE(ICF)%VELD(N,IFACE)

         CUT_FACE(ICF)%RHO_D_DZDN(N,HIGH_IND,IFACE) = &
         - VELD*(CCP1*RHOPV(0)*ZZPV(0)   + CCM1*RHOPV(-1)*ZZPV(-1) ) + & !-D_a/rho*Grad rho * (rho Y_a)
              DIFF_FACE*IDX*(RHOPV(0)*ZZPV(0) - RHOPV(-1)*ZZPV(-1) )     ! + D_a Grad(rho Y_a)

         CUT_FACE(ICF)%ZZ_FACE(N,IFACE) = CCM1*ZZPV(-1) + CCP1*ZZPV(0) ! Linear interpolation of ZZ to the face.
         CUT_FACE(ICF)%TMP_FACE(IFACE)  = CCM1*TMPV(-1) + CCP1*TMPV(0) ! Linear interpolation of TMP to the face.

      ENDDO ! IFACE

   ENDDO ! ICF

   ! Now Boundary Conditions:
   ! Regular Faces:
   ! For Regular Faces connecting regular cells we use the WALL_CELL array to fill RHO_D_DZDN, in the same way as
   ! done in WALL_LOOP_2 of DIVERGENCE_PART_1 (divg.f90):
   ! IAXIS faces:
   X1AXIS = IAXIS
   DO IFACE=1,MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)
      IW = IBM_REGFACE_IAXIS_Z(IFACE)%IWC
      IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE ! Already done on previous loops.
      CALL GET_BBREGFACE_RHO_D_DZDN
      ! NOTE: Boundary condition diffusive mass fluxes are already made realizable:
      IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D_DZDN(N,LOW_IND:HIGH_IND) = RHO_D_DZDN ! Use single value of RHO_D_DZDN
   ENDDO

   ! JAXIS faces:
   X1AXIS = JAXIS
   DO IFACE=1,MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)
      IW = IBM_REGFACE_JAXIS_Z(IFACE)%IWC
      IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
      CALL GET_BBREGFACE_RHO_D_DZDN
      ! NOTE: Boundary condition diffusive mass fluxes are already made realizable:
      IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D_DZDN(N,LOW_IND:HIGH_IND) = RHO_D_DZDN ! Use single value of RHO_D_DZDN
   ENDDO

   ! KAXIS faces:
   X1AXIS = KAXIS
   DO IFACE=1,MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)
      IW = IBM_REGFACE_KAXIS_Z(IFACE)%IWC
      IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
      CALL GET_BBREGFACE_RHO_D_DZDN
      ! NOTE: Boundary condition diffusive mass fluxes are already made realizable:
      IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D_DZDN(N,LOW_IND:HIGH_IND) = RHO_D_DZDN ! Use single value of RHO_D_DZDN
   ENDDO

   ! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
   DO IFACE=1,MESHES(NM)%IBM_NBBRCFACE_Z
      IW = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IWC
      IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
      I      = IBM_RCFACE_Z(IFACE)%IJK(IAXIS)
      J      = IBM_RCFACE_Z(IFACE)%IJK(JAXIS)
      K      = IBM_RCFACE_Z(IFACE)%IJK(KAXIS)
      X1AXIS = IBM_RCFACE_Z(IFACE)%IJK(KAXIS+1)
      CALL GET_BBRCFACE_RHO_D_DZDN
      IBM_RCFACE_Z(IFACE)%RHO_D_DZDN(N,LOW_IND:HIGH_IND) = RHO_D_DZDN
      IBM_RCFACE_Z(IFACE)%DIFF_FACE(N) = DIFF_FACE
      IBM_RCFACE_Z(IFACE)%ZZ_FACE(N)   = ZZ_FACE
      IBM_RCFACE_Z(IFACE)%TMP_FACE     = TMP_FACE
   ENDDO

   ! GASPHASE cut-faces:
   ! In case of Cut Faces and OPEN boundaries redefine the location of the guard cells with atmospheric conditions:
   DO ICF = 1,MESHES(NM)%N_BBCUTFACE_MESH
      IF ( CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
      IW = MESHES(NM)%CUT_FACE(ICF)%IWC
      IF( WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE

      I = CUT_FACE(ICF)%IJK(IAXIS)
      J = CUT_FACE(ICF)%IJK(JAXIS)
      K = CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)

      ! External boundary cut-cells of type OPEN_BOUNDARY:
      GASBOUND_IF : IF(WALL(IW)%BOUNDARY_TYPE==OPEN_BOUNDARY) THEN
         ! Run over local cut-faces:
         DO IFACE=1,CUT_FACE(ICF)%NFACE
            X1F= CUT_FACE(ICF)%XYZCEN(X1AXIS,IFACE)
            IF (WALL(IW)%ONE_D%IOR > 0) THEN
               IDX= 0.5_EB/(CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE)-X1F) ! Assumes DX twice the distance from WALL_CELL to
                                                                      ! internal cut-cell centroid.
            ELSE
               IDX= 0.5_EB/(X1F-CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE))
            ENDIF
            CCM1= 0.5_EB; CCP1= 0.5_EB
            SELECT CASE (X1AXIS)
            CASE(IAXIS)
               MUV(-1:0)   =   MU(I+FCELL-1:I+FCELL  ,J,K)
               TMPV(-1:0)  =  TMP(I+FCELL-1:I+FCELL  ,J,K)
               RHOPV(-1:0) = RHOP(I+FCELL-1:I+FCELL  ,J,K)
               ZZPV(-1:0)  =  ZZP(I+FCELL-1:I+FCELL  ,J,K,N)
            CASE(JAXIS)
               MUV(-1:0)   =   MU(I,J+FCELL-1:J+FCELL  ,K)
               TMPV(-1:0)  =  TMP(I,J+FCELL-1:J+FCELL  ,K)
               RHOPV(-1:0) = RHOP(I,J+FCELL-1:J+FCELL  ,K)
               ZZPV(-1:0)  =  ZZP(I,J+FCELL-1:J+FCELL  ,K,N)
            CASE(KAXIS)
               MUV(-1:0)   =   MU(I,J,K+FCELL-1:K+FCELL  )
               TMPV(-1:0)  =  TMP(I,J,K+FCELL-1:K+FCELL  )
               RHOPV(-1:0) = RHOP(I,J,K+FCELL-1:K+FCELL  )
               ZZPV(-1:0)  =  ZZP(I,J,K+FCELL-1:K+FCELL  ,N)
            END SELECT
            ! Interpolate D_Z to the face, linear interpolation:
            DO ISIDE=-1,0
               SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
               CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
                  JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
                  TMPV(ISIDE) = CUT_CELL(ICC)%TMP(JCC)
                  RHOPV(ISIDE)=        PRFCT *CUT_CELL(ICC)%RHO(JCC) + &
                                (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)
                  ZZPV(ISIDE) =        PRFCT *CUT_CELL(ICC)%ZZ(N,JCC) + &
                                (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
               END SELECT
               IF (DNS) THEN
                  CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMPV(ISIDE),D_Z_TEMP(ISIDE))
               ELSE
                  D_Z_TEMP(ISIDE) = MUV(ISIDE)*RSC/RHOPV(ISIDE)
               ENDIF
            ENDDO

            ! One Term defined flux:
            DIFF_FACE = CCM1*RHOPV(-1)*D_Z_TEMP(-1) + CCP1*RHOPV(0)*D_Z_TEMP(0)
            CUT_FACE(ICF)%RHO_D_DZDN(N,LOW_IND,IFACE) = DIFF_FACE*IDX*(ZZPV(0) - ZZPV(-1) ) ! rho D_a Grad(Y_a)

            IF(DO_IMPLICIT_CCREGION) THEN
               CUT_FACE(ICF)%RHO_D(N,IFACE)=DIFF_FACE
               CUT_FACE(ICF)%RHOPVN(-1:0,IFACE)=RHOPV(-1:0)
               RHOPVN(-1:0)=CUT_FACE(ICF)%RHOPVN(-1:0,IFACE)
               CUT_FACE(ICF)%RHO_D_DZDN(N,LOW_IND,IFACE) = &
               DIFF_FACE*IDX*(RHOPV( 0)*ZZPV( 0)/RHOPVN( 0) - RHOPV(-1)*ZZPV(-1)/RHOPVN(-1) ) ! rho D_a Grad(Y_a)
            ENDIF

            ! Two Terms defined flux:
            IF (.NOT.DO_IMPLICIT_CCREGION .OR. .NOT.IMP_REGION_FROM_MATRIX_DIFF) THEN
               CUT_FACE(ICF)%DIFF_FACE(N,IFACE)=CCM1*D_Z_TEMP(-1) + CCP1*D_Z_TEMP(0)
               CUT_FACE(ICF)%VELD(N,IFACE)=CUT_FACE(ICF)%DIFF_FACE(N,IFACE)*IDX*(    RHOPV(0)-     RHOPV(-1))/&
                                                                               (CCP1*RHOPV(0)+CCM1*RHOPV(-1))
            ENDIF
            DIFF_FACE = CUT_FACE(ICF)%DIFF_FACE(N,IFACE)
            VELD = CUT_FACE(ICF)%VELD(N,IFACE)

            CUT_FACE(ICF)%RHO_D_DZDN(N,HIGH_IND,IFACE) = &
            - VELD*(CCP1*RHOPV(0)*ZZPV(0)   + CCM1*RHOPV(-1)*ZZPV(-1) ) + & !-D_a/rho*Grad rho * (rho Y_a)
                 DIFF_FACE*IDX*(RHOPV(0)*ZZPV(0) - RHOPV(-1)*ZZPV(-1) )     ! + D_a Grad(rho Y_a)

            CUT_FACE(ICF)%ZZ_FACE(N,IFACE) = CCM1*ZZPV(-1) + CCP1*ZZPV(0) ! Linear interpolation of ZZ to the face.
            CUT_FACE(ICF)%TMP_FACE(IFACE)  = CCM1*TMPV(-1) + CCP1*TMPV(0) ! Linear interpolation of TMP to the face.

         ENDDO ! IFACE

      ELSE

         ! Other boundary conditions:
         DO IFACE=1,CUT_FACE(ICF)%NFACE
            CALL GET_BBCUTFACE_RHO_D_DZDN
            CUT_FACE(ICF)%DIFF_FACE(N,IFACE) = DIFF_FACE
            CUT_FACE(ICF)%RHO_D_DZDN(N,LOW_IND:HIGH_IND,IFACE) = RHO_D_DZDN
            CUT_FACE(ICF)%ZZ_FACE(N,IFACE) = ZZ_FACE
            CUT_FACE(ICF)%TMP_FACE(IFACE)  = TMP_FACE
         ENDDO

      ENDIF GASBOUND_IF

   ENDDO ! ICF

   ! Finally INBOUNDARY cut-faces, compute RHO_D_DZDN using CFACES:
   ! TO DO.

   ! Finally EXIM faces -> we use RHO_D_DZDX,Y,Z previously defined on divg.f90:
   ! No need to do anything on this initial DIFFUSIVE_FLUX_LOOP, as consistency already enforced
   ! on divg.f90.

ENDDO DIFFUSIVE_FLUX_LOOP

DEALLOCATE(ZZ_GET)

RETURN

CONTAINS

SUBROUTINE GET_BBREGFACE_RHO_D_DZDN

TYPE(WALL_TYPE), POINTER :: WC=>NULL()
INTEGER :: IIG, JJG, KKG, IOR, N_ZZ_MAX
REAL(EB) :: RHO_D_DZDN_GET(1:N_TRACKED_SPECIES)
WC => WALL(IW)
IIG = WC%ONE_D%IIG
JJG = WC%ONE_D%JJG
KKG = WC%ONE_D%KKG
IOR = WC%ONE_D%IOR
N_ZZ_MAX = MAXLOC(WC%ONE_D%ZZ_F(1:N_TRACKED_SPECIES),1)
RHO_D_DZDN = 2._EB*WC%ONE_D%RHO_D_F(N)*(ZZP(IIG,JJG,KKG,N)-WC%ONE_D%ZZ_F(N))*WC%ONE_D%RDN
IF (N==N_ZZ_MAX) THEN
   RHO_D_DZDN_GET = 2._EB*WC%ONE_D%RHO_D_F(:)*(ZZP(IIG,JJG,KKG,:)-WC%ONE_D%ZZ_F(:))*WC%ONE_D%RDN
   RHO_D_DZDN = -(SUM(RHO_D_DZDN_GET(:))-RHO_D_DZDN)
ENDIF

IF (IOR < 0) RHO_D_DZDN = -RHO_D_DZDN ! This is to switch the sign of the spatial derivative in high side boundaries.

END SUBROUTINE GET_BBREGFACE_RHO_D_DZDN

SUBROUTINE GET_BBRCFACE_RHO_D_DZDN

TYPE(WALL_TYPE), POINTER :: WC=>NULL()
INTEGER :: IIG, JJG, KKG, IOR, N_ZZ_MAX
REAL(EB) :: ZZ_G, ZZ_GV(1:N_TRACKED_SPECIES),RHO_D_DZDN_GET(1:N_TRACKED_SPECIES)

WC => WALL(IW)
IIG = WC%ONE_D%IIG
JJG = WC%ONE_D%JJG
KKG = WC%ONE_D%KKG
IOR = WC%ONE_D%IOR
! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
!                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
ISIDE = -1 + (SIGN(1,IOR)+1) / 2
SELECT CASE(IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
CASE(IBM_FTYPE_RGGAS) ! Regular cell.
   ZZ_G = ZZP(IIG,JJG,KKG,N)
   ZZ_GV(1:N_TRACKED_SPECIES)= ZZP(IIG,JJG,KKG,1:N_TRACKED_SPECIES)
CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
   ICC = IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
   JCC = IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
   ZZ_G =               PRFCT *CUT_CELL(ICC)%ZZ(N,JCC) + &
                 (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
   ZZ_GV(1:N_TRACKED_SPECIES)= PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                        (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
CASE DEFAULT
   print*, 'GET_BBRCFACE_RHO_D_DZDN : MESHES(NM)%IBM_NRCFACE_Z face not connected to REG or CC cell',NM,IFACE
   ZZ_G = -1._EB; ZZ_GV(:)=0._EB
END SELECT

SELECT CASE(X1AXIS)
    CASE(IAXIS)
       X1F= MESHES(NM)%X(I)
    CASE(JAXIS)
       X1F= MESHES(NM)%Y(J)
    CASE(KAXIS)
       X1F= MESHES(NM)%Z(K)
END SELECT

IF (IOR > 0) THEN !Cell or cutcell on high side of RC face:
   IDX = 1._EB / (IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
ELSE
   IDX = 1._EB / (X1F-IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS, LOW_IND))
ENDIF

N_ZZ_MAX = MAXLOC(WC%ONE_D%ZZ_F(1:N_TRACKED_SPECIES),1)
RHO_D_DZDN = WC%ONE_D%RHO_D_F(N)*(ZZ_G-WC%ONE_D%ZZ_F(N))*IDX
IF (N==N_ZZ_MAX) THEN
   RHO_D_DZDN_GET = WC%ONE_D%RHO_D_F(:)*(ZZ_GV(:)-WC%ONE_D%ZZ_F(:))*IDX
   RHO_D_DZDN = -(SUM(RHO_D_DZDN_GET(:))-RHO_D_DZDN)
ENDIF

IF (IOR < 0) RHO_D_DZDN = -RHO_D_DZDN ! This is to switch the sign of the spatial derivative in high side boundaries.
DIFF_FACE = WC%ONE_D%RHO_D_F(N)/WC%ONE_D%RHO_F
ZZ_FACE   = WC%ONE_D%ZZ_F(N)
TMP_FACE  = WC%ONE_D%TMP_F

END SUBROUTINE GET_BBRCFACE_RHO_D_DZDN


SUBROUTINE GET_BBCUTFACE_RHO_D_DZDN

TYPE(WALL_TYPE), POINTER :: WC=>NULL()
INTEGER :: IOR, N_ZZ_MAX
REAL(EB) :: ZZ_G, ZZ_GV(1:N_TRACKED_SPECIES),RHO_D_DZDN_GET(1:N_TRACKED_SPECIES)

WC => WALL(IW)
IOR = WC%ONE_D%IOR

X1F= CUT_FACE(ICF)%XYZCEN(X1AXIS,IFACE)
IF (IOR > 0) THEN
   IDX= 1._EB/(CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE)-X1F)
ELSE
   IDX= 1._EB/(X1F-CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE))
ENDIF
! This expression is such that when sign of IOR is -1 -> use Low Side cell  -> ISIDE=-1,
!                              when sign of IOR is  1 -> use High Side cell -> ISIDE= 0 .
ISIDE = -1 + (SIGN(1,IOR)+1) / 2
SELECT CASE(CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
   ICC = CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
   JCC = CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
   ZZ_G =               PRFCT *CUT_CELL(ICC)%ZZ(N,JCC) + &
                 (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(N,JCC)
   ZZ_GV(1:N_TRACKED_SPECIES)= PRFCT *CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC) + &
                        (1._EB-PRFCT)*CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
CASE DEFAULT
   print*, 'GET_BBCUTFACE_RHO_D_DZDN : CUT_FACE(ICF),IFACE not connected to REG or CC cell',NM,ICF,IFACE
   ZZ_G = -1._EB; ZZ_GV(:)=0._EB
END SELECT

N_ZZ_MAX = MAXLOC(WC%ONE_D%ZZ_F(1:N_TRACKED_SPECIES),1)
RHO_D_DZDN = WC%ONE_D%RHO_D_F(N)*(ZZ_G-WC%ONE_D%ZZ_F(N))*IDX
IF (N==N_ZZ_MAX) THEN
   RHO_D_DZDN_GET = WC%ONE_D%RHO_D_F(:)*(ZZ_GV(:)-WC%ONE_D%ZZ_F(:))*IDX
   RHO_D_DZDN = -(SUM(RHO_D_DZDN_GET(:))-RHO_D_DZDN)
ENDIF

IF (IOR < 0) RHO_D_DZDN = -RHO_D_DZDN ! This is to switch the sign of the spatial derivative in high side boundaries.
DIFF_FACE = WC%ONE_D%RHO_D_F(N)/WC%ONE_D%RHO_F
ZZ_FACE   = WC%ONE_D%ZZ_F(N)
TMP_FACE  = WC%ONE_D%TMP_F

END SUBROUTINE GET_BBCUTFACE_RHO_D_DZDN

END SUBROUTINE CCREGION_DIFFUSIVE_MASS_FLUXES


! ------------------------------ CCREGION_DENSITY -------------------------------

SUBROUTINE CCREGION_DENSITY(T,DT)

USE PHYSICAL_FUNCTIONS, ONLY : GET_SPECIFIC_GAS_CONSTANT
USE MPI

REAL(EB), INTENT(IN) :: T,DT

! Local Variables:
INTEGER :: N
INTEGER :: I,J,K,NM,ICC,JCC,NCELL
REAL(EB) :: ZZ_GET(1:N_TRACKED_SPECIES)
REAL(EB) :: VCCELL
REAL(EB) :: DUMMYT
! CHARACTER(len=20) :: filename
! LOGICAL, SAVE :: FIRST_CALL = .TRUE.
!

! Dummy on T:
DUMMYT = T

IF (SOLID_PHASE_ONLY) RETURN

SELECT CASE (PERIODIC_TEST)
   CASE DEFAULT
      IF (PROJECTION .AND. ICYC<=1) RETURN
   CASE (5,8)
      RETURN
   CASE (7,11)
      ! CONTINUE
END SELECT

! Advance scalars and density, sanitize results if needed:
IF (DO_IMPLICIT_CCREGION) THEN
   CALL CCREGION_DENSITY_IMPLICIT(T,DT)
ELSE
   CALL CCREGION_DENSITY_EXPLICIT(T,DT)
ENDIF

! Predict background pressure at next time step



! Compute molecular weight term RSUM=R0*SUM(Y_i/W_i). Here WBAR=1/SUM(Y_i/W_i).
! Compute temperature in regular and cut-cells, from equation of state:
IF (PREDICTOR) THEN

   MESHES_LOOP1 : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

      CALL POINT_TO_MESH(NM)

      ! First Regular Cells:
      ! Compute molecular weight term RSUM=R0*SUM(Y_i/W_i).
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE ! Cycle Reg cells not implicit, cut-cells
                                                     ! underlying Cartesian cells and
                                                     ! solid cells.
               ZZ_GET(1:N_TRACKED_SPECIES) = ZZS(I,J,K,1:N_TRACKED_SPECIES)
               CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,RSUM(I,J,K))
            ENDDO
         ENDDO
      ENDDO

      ! Extract predicted temperature at next time step from Equation of State
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE ! Cycle Reg cells not implicit, cut-cells
                                                     ! underlying Cartesian cells and
                                                     ! solid cells.
               TMP(I,J,K) = PBAR_S(K,PRESSURE_ZONE(I,J,K))/(RSUM(I,J,K)*RHOS(I,J,K))
            ENDDO
         ENDDO
      ENDDO

      ! Store RHO*ZZ values at step n:
      IF (.NOT.ALLOCATED(MESHES(NM)%RHO_ZZN)) &
      ALLOCATE(MESHES(NM)%RHO_ZZN(0:IBP1,0:JBP1,0:KBP1,N_TOTAL_SCALARS))

      DO N=1,N_TOTAL_SCALARS
         MESHES(NM)%RHO_ZZN(:,:,:,N) = MESHES(NM)%RHO(:,:,:)*MESHES(NM)%ZZ(:,:,:,N)
      ENDDO

      ! Second cut-cells, these variables being filled are only used for exporting to slices and applying Boundary
      ! conditions on external walls other than NULL or INTERPOLATED in WALL_BC (wall.f90):
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         NCELL = CUT_CELL(ICC)%NCELL
         I     = CUT_CELL(ICC)%IJK(IAXIS)
         J     = CUT_CELL(ICC)%IJK(JAXIS)
         K     = CUT_CELL(ICC)%IJK(KAXIS)
         VCCELL = 0._EB
         TMP(I,J,K)=0._EB
         RHOS(I,J,K)=0._EB
         ZZS(I,J,K,1:N_TRACKED_SPECIES)=0._EB
         RSUM(I,J,K)=0._EB
         DO JCC=1,NCELL
            ! Compute molecular weight term RSUM=R0*SUM(Y_i/W_i).
            ZZ_GET(1:N_TRACKED_SPECIES) = CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC)
            CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,CUT_CELL(ICC)%RSUM(JCC))
            ! Extract predicted temperature at next time step from Equation of State
            ! Use for pressure the height of the underlying cartesian cell centroid:
            CUT_CELL(ICC)%TMP(JCC) = &
            PBAR_S(K,PRESSURE_ZONE(I,J,K))/(CUT_CELL(ICC)%RSUM(JCC)*CUT_CELL(ICC)%RHOS(JCC))

            TMP(I,J,K) = TMP(I,J,K) + CUT_CELL(ICC)%TMP(JCC)*CUT_CELL(ICC)%VOLUME(JCC)
            RHOS(I,J,K)= RHOS(I,J,K)+ CUT_CELL(ICC)%RHOS(JCC)*CUT_CELL(ICC)%VOLUME(JCC)
            ZZS(I,J,K,1:N_TRACKED_SPECIES) = ZZS(I,J,K,1:N_TRACKED_SPECIES) + &
                                             ZZ_GET(1:N_TRACKED_SPECIES)*CUT_CELL(ICC)%VOLUME(JCC)
            RSUM(I,J,K)= RSUM(I,J,K)+ CUT_CELL(ICC)%RSUM(JCC)*CUT_CELL(ICC)%VOLUME(JCC)

            VCCELL = VCCELL + CUT_CELL(ICC)%VOLUME(JCC)

         ENDDO

         ! Volume average cell variables to underlying cell:
         TMP(I,J,K) = TMP(I,J,K)/VCCELL
         RHOS(I,J,K)= RHOS(I,J,K)/VCCELL
         ZZS(I,J,K,1:N_TRACKED_SPECIES)=ZZS(I,J,K,1:N_TRACKED_SPECIES)/VCCELL
         RSUM(I,J,K)=RSUM(I,J,K)/VCCELL

      ENDDO

      ! Finally set to ambient temperature the temp of SOLID cells:
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (CCVAR(I,J,K,IBM_CGSC) /= IBM_SOLID) CYCLE
               TMP(I,J,K) = TMPA
            ENDDO
         ENDDO
      ENDDO

   ENDDO MESHES_LOOP1

ELSE ! CORRECTOR

   MESHES_LOOP2 : DO NM=1,NMESHES

      IF (PROCESS(NM)/=MYID) CYCLE

      CALL POINT_TO_MESH(NM)

      ! Compute molecular weight term RSUM=R0*SUM(Y_i/W_i)
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE ! Cycle Reg cells not implicit, cut-cells
                                                     ! underlying Cartesian cells and
                                                     ! solid cells.
               ZZ_GET(1:N_TRACKED_SPECIES) = ZZ(I,J,K,1:N_TRACKED_SPECIES)
               CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,RSUM(I,J,K))
            ENDDO
         ENDDO
      ENDDO

      ! Extract predicted temperature at next time step from Equation of State
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE ! Cycle Reg cells not implicit, cut-cells
                                                     ! underlying Cartesian cells and
                                                     ! solid cells.
               TMP(I,J,K) = PBAR(K,PRESSURE_ZONE(I,J,K))/(RSUM(I,J,K)*RHO(I,J,K))

            ENDDO
         ENDDO
      ENDDO

      ! Second cut-cells, these variables being filled are only used for exporting to slices and applying Boundary
      ! conditions on external walls other than NULL or INTERPOLATED in WALL_BC (wall.f90):
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         NCELL = CUT_CELL(ICC)%NCELL
         I     = CUT_CELL(ICC)%IJK(IAXIS)
         J     = CUT_CELL(ICC)%IJK(JAXIS)
         K     = CUT_CELL(ICC)%IJK(KAXIS)
         VCCELL = 0._EB
         TMP(I,J,K)=0._EB
         RHO(I,J,K)=0._EB
         ZZ(I,J,K,1:N_TRACKED_SPECIES)=0._EB
         RSUM(I,J,K)=0._EB
         DO JCC=1,NCELL
            ! Compute molecular weight term RSUM=R0*SUM(Y_i/W_i).
            ZZ_GET(1:N_TRACKED_SPECIES) = CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC)
            CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,CUT_CELL(ICC)%RSUM(JCC))
            ! Extract predicted temperature at next time step from Equation of State
            ! Use for pressure the height of the underlying cartesian cell centroid:
            CUT_CELL(ICC)%TMP(JCC) = &
            PBAR(K,PRESSURE_ZONE(I,J,K))/(CUT_CELL(ICC)%RSUM(JCC)*CUT_CELL(ICC)%RHO(JCC))


            TMP(I,J,K) = TMP(I,J,K) + CUT_CELL(ICC)%TMP(JCC)*CUT_CELL(ICC)%VOLUME(JCC)
            RHO(I,J,K) = RHO(I,J,K) + CUT_CELL(ICC)%RHO(JCC)*CUT_CELL(ICC)%VOLUME(JCC)
            ZZ(I,J,K,1:N_TRACKED_SPECIES) = ZZ(I,J,K,1:N_TRACKED_SPECIES) + &
                                            ZZ_GET(1:N_TRACKED_SPECIES)*CUT_CELL(ICC)%VOLUME(JCC)
            RSUM(I,J,K)= RSUM(I,J,K)+ CUT_CELL(ICC)%RSUM(JCC)*CUT_CELL(ICC)%VOLUME(JCC)

            VCCELL = VCCELL + CUT_CELL(ICC)%VOLUME(JCC)

         ENDDO

         ! Volume average cell variables to underlying cell:
         TMP(I,J,K) = TMP(I,J,K)/VCCELL
         RHO(I,J,K) = RHO(I,J,K)/VCCELL
         ZZ(I,J,K,1:N_TRACKED_SPECIES)=ZZ(I,J,K,1:N_TRACKED_SPECIES)/VCCELL
         RSUM(I,J,K)=RSUM(I,J,K)/VCCELL

      ENDDO

      ! Finally set to ambient temperature the temp of SOLID cells:
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (CCVAR(I,J,K,IBM_CGSC) /= IBM_SOLID) CYCLE
               TMP(I,J,K) = TMPA
            ENDDO
         ENDDO
      ENDDO

   ENDDO MESHES_LOOP2

ENDIF ! PREDICTOR


RETURN
END SUBROUTINE CCREGION_DENSITY

! ----------------------------- CCREGION_DENSITY_EXPLICIT ------------------------

SUBROUTINE CCREGION_DENSITY_EXPLICIT(T,DT)

REAL(EB), INTENT(IN) :: T,DT

! Local variables:
INTEGER :: N
INTEGER :: IROW_LOC
REAL(EB):: DUMMYT

! Just to avoid compilation warnings: T might be used to define a time dependent source.
DUMMYT = T

! Loop through species:
! This loop performs an either implicit or explicit time advancement of the transport equations for each
! chemical species on the cut-cell implicit region, plus explicit reaction (as done on FDS).
! Scalar bounds are checked on the implicit region regular and cut-cells:
SPECIES_LOOP: DO N=1,N_TOTAL_SCALARS

   IF( (PREDICTOR.AND.FIRST_PASS) .OR. CORRECTOR) THEN
      ! RHS vector (Adv+diff)*zz+F_BC, derived from boundary conditions on immersed and domain Boundaries:
      F_Z(:) = 0._EB
      CALL GET_EXPLICIT_ADVDIFFVECTOR_SCALAR_3D(N)

      ! Add Advective fluxes due to PRES_ON_WHOLE_DOMAIN for F_Z:
      CALL GET_ADVDIFFVECTOR_SCALAR_3D(N)

      ! Here add the reaction source term M_DOT_PPP, treated explicitly:
      IF (N_LP_ARRAY_INDICES>0 .OR. N_REACTIONS>0 .OR. ANY(SPECIES_MIXTURE%DEPOSITING)) THEN
         CALL GET_M_DOT_PPP_SCALAR_3D(N)
      ENDIF

      IF (PERIODIC_TEST==7) CALL GET_SHUNN3_QZ(T,N)

      ! Flux vector F_EXIM in the EXIM boundary for species N:
      CALL GET_EXIMVECTOR_SCALAR_3D(N)

      ! Get rho*zz vector at step n:
      CALL GET_RHOZZVECTOR_SCALAR_3D(N)
   ENDIF

   IF (PREDICTOR) THEN
      IF (FIRST_PASS) THEN
         F_Z0(:,N) = F_Z(:)
         RZ_Z0(:,N) = RZ_Z(:)
      ELSE
         F_Z(:) = F_Z0(:,N)
         RZ_Z(:)= RZ_Z0(:,N)
      ENDIF
   ENDIF

   IF (PREDICTOR) THEN

      ! Here F_Z: (Adv+Diff)*(rho z)^n + F^n
      ! Advance with Explicit Euler: RZ_Z = RZ_Z - DT*M_MAT_Z^-1*F_Z: where initially
      ! RZ_Z = (rho z)^n, filled in GET_RHOZZVECTOR_SCALAR_3D
      DO IROW_LOC=1,NUNKZ_LOCAL
         RZ_Z(IROW_LOC) = RZ_Z(IROW_LOC) - DT * F_Z(IROW_LOC) / M_MAT_Z(IROW_LOC)
      ENDDO

   ELSE ! CORRECTOR

      ! Here F_Z: (Adv+Diff)*(rho z)^* + F^*
      ! Advance with Corrector SSPRK2: RZ_Z = RZ_Z - DT/2*M_MAT_Z^-1*F_Z: where initially
      ! RZ_Z = 1/2*((rho z)^n + (rho z)^*)
      DO IROW_LOC=1,NUNKZ_LOCAL
         RZ_Z(IROW_LOC) = RZ_Z(IROW_LOC) - 0.5_EB * DT * F_Z(IROW_LOC) / M_MAT_Z(IROW_LOC)
      ENDDO

   ENDIF

   ! Copy back to RHOZZP and CUT_CELL:
   CALL PUT_RHOZZVECTOR_SCALAR_3D(N)

ENDDO SPECIES_LOOP

! Recompute RHOP, and check for positivity, define mass fraction ZZ and clip if necessary:
CALL GET_RHOZZ_CCIMPREG_3D

RETURN
END SUBROUTINE CCREGION_DENSITY_EXPLICIT

! --------------------------------- GET_SHUNN3_QZ --------------------------------

SUBROUTINE GET_SHUNN3_QZ(T,N)

USE MANUFACTURED_SOLUTIONS, ONLY: UF_MMS,WF_MMS,VD2D_MMS_Z_SRC

REAL(EB),INTENT(IN) :: T
INTEGER, INTENT(IN) :: N

! Local Variables:
INTEGER I,J,K,NM,IROW,ICC,JCC
REAL(EB) :: FCT,XHAT,ZHAT,Q_Z

FCT=REAL(2*(1-N)+1,EB)

! Mesh Loop:
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! First add Q_Z on regular cells to source F_Z:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF(CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE
            IROW = CCVAR(I,J,K,IBM_UNKZ) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
            ! divergence from EOS
            XHAT = XC(I) - UF_MMS*T
            ZHAT = ZC(K) - WF_MMS*T
            Q_Z = VD2D_MMS_Z_SRC(XHAT,ZHAT,T)
            F_Z(IROW) = F_Z(IROW) + FCT*Q_Z*DX(I)*DY(J)*DZ(K)
         ENDDO
      ENDDO
   ENDDO

   ! Then add Cut-cell contributions to F_Z:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      DO JCC=1,CUT_CELL(ICC)%NCELL
         IROW = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
         ! divergence from EOS
         XHAT = CUT_CELL(ICC)%XYZCEN(IAXIS,JCC) - UF_MMS*T
         ZHAT = CUT_CELL(ICC)%XYZCEN(KAXIS,JCC) - WF_MMS*T
         Q_Z = VD2D_MMS_Z_SRC(XHAT,ZHAT,T)
         F_Z(IROW) = F_Z(IROW) + FCT*Q_Z*CUT_CELL(ICC)%VOLUME(JCC)
      ENDDO
   ENDDO

ENDDO MESH_LOOP

RETURN
END SUBROUTINE GET_SHUNN3_QZ

! ---------------------------- GET_M_DOT_PPP_SCALAR_3D ---------------------------

SUBROUTINE GET_M_DOT_PPP_SCALAR_3D(N)

INTEGER, INTENT(IN) :: N

! Local Variables:
INTEGER :: NM,I,J,K,IROW,ICC,JCC,NCELL

! Mesh Loop:
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! First add M_DOT_PPP on regular cells to source F_Z:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE ! Cycle Reg cells not implicit, cut-cells
                                                  ! underlying Cartesian cells and
                                                  ! solid cells.
            IROW = CCVAR(I,J,K,IBM_UNKZ) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
            F_Z(IROW) = F_Z(IROW) - M_DOT_PPP(I,J,K,N)*DX(I)*DY(J)*DZ(K)
         ENDDO
      ENDDO
   ENDDO

   ! Then add Cut-cell contributions to F_Z:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      NCELL=CUT_CELL(ICC)%NCELL
      DO JCC=1,NCELL
         IROW = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
         F_Z(IROW) = F_Z(IROW) - CUT_CELL(ICC)%M_DOT_PPP(N,JCC)*CUT_CELL(ICC)%VOLUME(JCC)
      ENDDO
   ENDDO

   ! Finally if Corrector zero out M_DOT_PPP and D_SOURCE:
   IF (CORRECTOR) THEN
      M_DOT_PPP(:,:,:,N) = 0._EB
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         NCELL=CUT_CELL(ICC)%NCELL
         CUT_CELL(ICC)%M_DOT_PPP(N,1:NCELL) = 0._EB
      ENDDO
      IF (N == N_TOTAL_SCALARS) THEN
         D_SOURCE(:,:,:)  = 0._EB
         DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
            NCELL=CUT_CELL(ICC)%NCELL
            CUT_CELL(ICC)%D_SOURCE(1:NCELL) = 0._EB
         ENDDO
      ENDIF
   ENDIF

ENDDO MESH_LOOP

RETURN
END SUBROUTINE GET_M_DOT_PPP_SCALAR_3D

! ---------------------- GET_EXPLICIT_ADVDIFFVECTOR_SCALAR_3D --------------------

SUBROUTINE GET_EXPLICIT_ADVDIFFVECTOR_SCALAR_3D(N)

INTEGER, INTENT(IN) :: N

! Local Variables:
INTEGER :: NM,I,J,K
REAL(EB):: PRFCT
INTEGER :: X1AXIS,IFACE,IND(LOW_IND:HIGH_IND),IND_LOC(LOW_IND:HIGH_IND),ICF
INTEGER :: LOCROW_1,LOCROW_2,ILOC,IROW,ICC,JCC,ISIDE,IW
REAL(EB):: AF,KFACE(2,2),F_LOC(2),CIJP,CIJM,VELC,ALPHAP1,AM_P1,AP_P1
REAL(EB), POINTER, DIMENSION(:,:,:)  :: RHOP=>NULL(),UP=>NULL(),VP=>NULL(),WP=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:,:)::  ZZP=>NULL()

! Mesh Loop:
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN
      ZZP  => ZZ
      RHOP => RHO
      UP   => U
      VP   => V
      WP   => W
      PRFCT= 1._EB
   ELSE
      ZZP  => ZZS
      RHOP => RHOS
      UP   => US
      VP   => VS
      WP   => WS
      PRFCT= 0._EB
   ENDIF

   ! X direction bounds:
   ILO_FACE = 0                    ! Low mesh boundary face index.
   IHI_FACE = IBAR                 ! High mesh boundary face index.

   ! Y direction bounds:
   JLO_FACE = 0                    ! Low mesh boundary face index.
   JHI_FACE = JBAR                 ! High mesh boundary face index.

   ! Z direction bounds:
   KLO_FACE = 0                    ! Low mesh boundary face index.
   KHI_FACE = KBAR                 ! High mesh boundary face index.

   ! First add advective fluxes to internal and INTERPOLATED_BOUNDARY regular and cut-cells in the CC region:
   ! IAXIS faces:
   X1AXIS = IAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      IW = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I+FCELL-1,J,K,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I+FCELL  ,J,K,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Face area and Velocity u:
      AF = DY(J)*DZ(K)
      VELC = UP(I,J,K)

      ! Matrix coefficients:
      ALPHAP1 = SIGN( 1._EB, VELC)
      AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
      AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
      CIJM = AM_P1*VELC*AF
      CIJP = AP_P1*VELC*AF

      ! Now add to A corresponding advection coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = CIJM; KFACE(2,1) =-CIJM; KFACE(1,2) = CIJP; KFACE(2,2) =-CIJP

      F_LOC(1) = RHOP(I+FCELL-1,J,K)*ZZP(I+FCELL-1,J,K,N)
      F_LOC(2) = RHOP(I+FCELL  ,J,K)*ZZP(I+FCELL  ,J,K,N)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( I == ILO_FACE )  LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
      IF ( I == IHI_FACE )  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
      DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
         IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
         F_Z(IROW) = F_Z(IROW) + KFACE(ILOC,1)*F_LOC(1) + KFACE(ILOC,2)*F_LOC(2)
      ENDDO

   ENDDO

   ! JAXIS faces:
   X1AXIS = JAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      IW = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I,J+FCELL-1,K,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I,J+FCELL  ,K,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Face area and Velocity v:
      AF = DX(I)*DZ(K)
      VELC = VP(I,J,K)

      ! Matrix coefficients:
      ALPHAP1 = SIGN( 1._EB, VELC)
      AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
      AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
      CIJM = AM_P1*VELC*AF
      CIJP = AP_P1*VELC*AF

      ! Now add to A corresponding advection and diffusion coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = CIJM; KFACE(2,1) =-CIJM; KFACE(1,2) = CIJP; KFACE(2,2) =-CIJP

      F_LOC(1) = RHOP(I,J+FCELL-1,K)*ZZP(I,J+FCELL-1,K,N)
      F_LOC(2) = RHOP(I,J+FCELL  ,K)*ZZP(I,J+FCELL  ,K,N)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( J == JLO_FACE )  LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
      IF ( J == JHI_FACE )  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
      DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
         IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
         F_Z(IROW) = F_Z(IROW) + KFACE(ILOC,1)*F_LOC(1) + KFACE(ILOC,2)*F_LOC(2)
      ENDDO

   ENDDO

   ! KAXIS faces:
   X1AXIS = KAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      IW = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I,J,K+FCELL-1,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I,J,K+FCELL  ,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Face area and Velocity w:
      AF = DX(I)*DY(J)
      VELC = WP(I,J,K)

      ! Matrix coefficients:
      ALPHAP1 = SIGN( 1._EB, VELC)
      AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
      AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
      CIJM = AM_P1*VELC*AF
      CIJP = AP_P1*VELC*AF

      ! Now add to A corresponding advection and diffusion coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = CIJM; KFACE(2,1) =-CIJM; KFACE(1,2) = CIJP; KFACE(2,2) =-CIJP

      F_LOC(1) = RHOP(I,J,K+FCELL-1)*ZZP(I,J,K+FCELL-1,N)
      F_LOC(2) = RHOP(I,J,K+FCELL  )*ZZP(I,J,K+FCELL  ,N)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( K == KLO_FACE )  LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
      IF ( K == KHI_FACE )  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
      DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
         IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
         F_Z(IROW) = F_Z(IROW) + KFACE(ILOC,1)*F_LOC(1) + KFACE(ILOC,2)*F_LOC(2)
      ENDDO

   ENDDO

   ! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
   DO IFACE=1,MESHES(NM)%IBM_NRCFACE_Z

      IW = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I      = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(IAXIS)
      J      = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(JAXIS)
      K      = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(KAXIS+1)

      ! Unknowns on related cells:
      IND(LOW_IND)  = MESHES(NM)%IBM_RCFACE_Z(IFACE)%UNK(LOW_IND)
      IND(HIGH_IND) = MESHES(NM)%IBM_RCFACE_Z(IFACE)%UNK(HIGH_IND)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            AF = DY(J)*DZ(K)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
            ! Advective Part: Velocity u
            VELC = UP(I,J,K)
            F_LOC(1) = RHOP(I+FCELL-1,J,K)*ZZP(I+FCELL-1,J,K,N)
            F_LOC(2) = RHOP(I+FCELL  ,J,K)*ZZP(I+FCELL  ,J,K,N)
         CASE(JAXIS)
            AF = DX(I)*DZ(K)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
            ! Advective Part: Velocity v
            VELC = VP(I,J,K)
            F_LOC(1) = RHOP(I,J+FCELL-1,K)*ZZP(I,J+FCELL-1,K,N)
            F_LOC(2) = RHOP(I,J+FCELL  ,K)*ZZP(I,J+FCELL  ,K,N)
         CASE(KAXIS)
            AF = DX(I)*DY(J)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
            ! Advective Part: Velocity w
            VELC = WP(I,J,K)
            F_LOC(1) = RHOP(I,J,K+FCELL-1)*ZZP(I,J,K+FCELL-1,N)
            F_LOC(2) = RHOP(I,J,K+FCELL  )*ZZP(I,J,K+FCELL  ,N)
      ENDSELECT

      ! Matrix coefficients for advection:
      ALPHAP1 = SIGN( 1._EB, VELC)
      AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
      AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
      CIJM = AM_P1*VELC*AF
      CIJP = AP_P1*VELC*AF

      ! Now add to A corresponding advection and diffusion coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = CIJM; KFACE(2,1) =-CIJM; KFACE(1,2) = CIJP; KFACE(2,2) =-CIJP

      DO ISIDE=1,2
         IF ( MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE) == IBM_FTYPE_CFGAS ) THEN
            ICC = MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE)
            JCC = MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE)
            F_LOC(ISIDE) =       PRFCT *CUT_CELL(ICC)% RHO(JCC)*CUT_CELL(ICC)% ZZ(N,JCC) + &
                          (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)*CUT_CELL(ICC)%ZZS(N,JCC)
         ENDIF
      ENDDO

      DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
         IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
         F_Z(IROW) = F_Z(IROW) + KFACE(ILOC,1)*F_LOC(1) + KFACE(ILOC,2)*F_LOC(2)
      ENDDO

   ENDDO

   ! Now Gasphase CUT_FACES:
   DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH

      IF ( MESHES(NM)%CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE

      IW = MESHES(NM)%CUT_FACE(ICF)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I = MESHES(NM)%CUT_FACE(ICF)%IJK(IAXIS)
      J = MESHES(NM)%CUT_FACE(ICF)%IJK(JAXIS)
      K = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS+1)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         CASE(JAXIS)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         CASE(KAXIS)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
      ENDSELECT

      DO IFACE=1,MESHES(NM)%CUT_FACE(ICF)%NFACE

         ! Unknowns on related cells:
         IND(LOW_IND)  = MESHES(NM)%CUT_FACE(ICF)%UNKZ(LOW_IND,IFACE)
         IND(HIGH_IND) = MESHES(NM)%CUT_FACE(ICF)%UNKZ(HIGH_IND,IFACE)

         IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
         IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

         AF = MESHES(NM)%CUT_FACE(ICF)%AREA(IFACE)

         ! Matrix coefficients for advection:
         VELC =        PRFCT *MESHES(NM)%CUT_FACE(ICF)%VEL(IFACE) + &
                (1._EB-PRFCT)*MESHES(NM)%CUT_FACE(ICF)%VELS(IFACE)

         ALPHAP1 = SIGN( 1._EB, VELC)
         AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
         AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
         CIJM = AM_P1*VELC*AF
         CIJP = AP_P1*VELC*AF

         ! Now add to A corresponding advection and diffusion coeffs:
         !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
         KFACE(1,1) = CIJM; KFACE(2,1) =-CIJM; KFACE(1,2) = CIJP; KFACE(2,2) =-CIJP

         F_LOC(:) = 0._EB
         DO ISIDE=1,2
            SELECT CASE(MESHES(NM)%CUT_FACE(ICF)%CELL_LIST(1,ISIDE,IFACE))
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = MESHES(NM)%CUT_FACE(ICF)%CELL_LIST(2,ISIDE,IFACE)
               JCC = MESHES(NM)%CUT_FACE(ICF)%CELL_LIST(3,ISIDE,IFACE)
               F_LOC(ISIDE) =       PRFCT *CUT_CELL(ICC)% RHO(JCC)*CUT_CELL(ICC)% ZZ(N,JCC) + &
                             (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)*CUT_CELL(ICC)%ZZS(N,JCC)
            CASE DEFAULT
               WRITE(0,*) 'GET_EXPLICIT_ADVDIFFVECTOR_SCALAR_3D: ', &
               'MESHES(NM)%CUT_FACE face not connected to CC cell',NM,IFACE
            END SELECT
        ENDDO

        DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
           IROW=IND_LOC(ILOC)     ! Process Local Unknown number.
           F_Z(IROW) = F_Z(IROW) + KFACE(ILOC,1)*F_LOC(1) + KFACE(ILOC,2)*F_LOC(2)
        ENDDO

      ENDDO

   ENDDO

   ! Case of PRES_ON_WHOLE_DOMAIN, we have non-zero velocities on INBOUNDARY cut-faces:
   ! Done on CALL GET_ADVDIFFVECTOR_SCALAR_3D(N)

   ! Then add (Del rho D Del Z)*dv computed on CCDIVERGENCE_PART_1:
   ! Loop over regular cells on CC region:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE ! Cycle Reg cells not implicit, cut-cells
                                                  ! underlying Cartesian cells and
                                                  ! solid cells.
            IROW  = CCVAR(I,J,K,IBM_UNKZ) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
            F_Z(IROW) = F_Z(IROW) - DEL_RHO_D_DEL_Z(I,J,K,N)*(DX(I)*DY(J)*DZ(K))
         ENDDO
      ENDDO
   ENDDO

   ! Now cut-cells:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      DO JCC=1,CUT_CELL(ICC)%NCELL
         IROW = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
         F_Z(IROW) = F_Z(IROW) - CUT_CELL(ICC)%DEL_RHO_D_DEL_Z(N,JCC)
      ENDDO
   ENDDO

ENDDO MESH_LOOP

RETURN
END SUBROUTINE GET_EXPLICIT_ADVDIFFVECTOR_SCALAR_3D


! ----------------------------- CCREGION_DENSITY_IMPLICIT ------------------------

SUBROUTINE CCREGION_DENSITY_IMPLICIT(T,DT)

USE MPI

REAL(EB), INTENT(IN) :: T,DT

! Local variables:
INTEGER :: N
INTEGER :: IROW_LOC,JCOL,INNZ
REAL(EB):: DUMMYT
REAL(EB), ALLOCATABLE, DIMENSION(:) :: RZ_Z2,RZ_Z2AUX
INTEGER :: IERR

! CHARACTER(30) :: FILE_NAME
! INTEGER :: NM,I,J,K,ICC,JCC

! Just to avoid compilation warnings: T might be used to define a time dependent source.
DUMMYT = T

MATRIX_DIFF_IF : IF (IMP_REGION_FROM_MATRIX_DIFF) THEN

   ! First advance density equation:
   IF( (PREDICTOR.AND.FIRST_PASS) .OR. CORRECTOR) THEN
      ! Compute advection matrix:
      CALL GET_ADVMATRIX_DENSITY_3D

      ! RHS vector F_BC, derived from boundary conditions on immersed and domain Boundaries:
      F_RHO(:) = 0._EB
      CALL GET_ADVVECTOR_DENSITY_3D

      ! Advective Flux vector F_EXIM in the EXIM boundary for density:
      CALL GET_EXIMVECTOR_DENSITY_3D

      ! Get rho vector at step n:
      CALL GET_RHOVECTOR_3D

   ENDIF

   IF (PREDICTOR) THEN
      IF (FIRST_PASS) THEN
         D_MAT_RHO0(:,:) = D_MAT_RHO(:,:)
         F_RHO0(:) = F_RHO(:)
         RZ_RHO0(:) = RZ_RHO(:)
      ELSE
         D_MAT_RHO(:,:) = D_MAT_RHO0(:,:)
         F_RHO(:) = F_RHO0(:)
         RZ_RHO(:)= RZ_RHO0(:)
      ENDIF
   ENDIF

   ! Compute implicit discretization matrix, and store in D_MAT_RHO:
   ! D_MAT_RHO(i,j)= M_MAT_RHO(i,j) + DT*D_MAT_RHO(i,j); here we recycle M_MAT_Z as it is the same as M_MAT_RHO.
   IF (PREDICTOR) THEN
      D_MAT_RHO(:,:) = DT*D_MAT_RHO(:,:)
   ELSE
      D_MAT_RHO(:,:) = 0.5_EB*DT*D_MAT_RHO(:,:)
   ENDIF

   ! Solve implicit system of equations for density:
   ! D_MAT_RHO RHO^(n+1) = M_MAT_RHO*RHO^n - DT*(F_EXIM+F_BC)   PREDICTOR
   ! D_MAT_RHO RHO^(n+1) = M_MAT_RHO*RHO - 0.5_EB*(F_EXIM+F_BC) CORRECTOR
   IF (PREDICTOR) THEN
      IF (TRAP_CORR) THEN
         TR_RHO(:) = 0._EB
         DO IROW_LOC=1,NUNKZ_LOCAL
            ! [M_MAT_RHO(:,:)-1/2*DT*D_MAT_RHO(:,:)] * RHO - 1/2*DT*F_RHO: PART of Trapezoidal corrector rhs.
            DO JCOL=1,NNZ_D_MAT_Z(IROW_LOC)
               TR_RHO(IROW_LOC) = TR_RHO(IROW_LOC) - 0.5_EB*D_MAT_RHO(JCOL,IROW_LOC)*RZ_RHO(JD_MAT_Z(JCOL,IROW_LOC))
            ENDDO
            TR_RHO(IROW_LOC) = TR_RHO(IROW_LOC) + M_MAT_Z(IROW_LOC)*RZ_RHO(IROW_LOC) - 0.5_EB*DT*F_RHO(IROW_LOC)
         ENDDO
      ENDIF
      DO IROW_LOC=1,NUNKZ_LOCAL
         F_RHO(IROW_LOC) = M_MAT_Z(IROW_LOC)*RZ_RHO(IROW_LOC) - DT*F_RHO(IROW_LOC)
      ENDDO
   ELSE
      IF (TRAP_CORR) THEN
          DO IROW_LOC=1,NUNKZ_LOCAL
             F_RHO(IROW_LOC) = TR_RHO(IROW_LOC) - 0.5_EB*DT*F_RHO(IROW_LOC)
          ENDDO
      ELSE
         DO IROW_LOC=1,NUNKZ_LOCAL
            F_RHO(IROW_LOC) = M_MAT_Z(IROW_LOC)*RZ_RHO(IROW_LOC) - 0.5_EB*DT*F_RHO(IROW_LOC)
         ENDDO
      ENDIF
   ENDIF

   DO IROW_LOC=1,NUNKZ_LOCAL
      JCOL=JM_MAT_Z(IROW_LOC)
      D_MAT_RHO(JCOL,IROW_LOC) = D_MAT_RHO(JCOL,IROW_LOC) + M_MAT_Z(IROW_LOC)
   ENDDO

   ! Load into 3 vector CSR Format for Implicit rho matrix:
   INNZ = 0
   DO IROW_LOC=1,NUNKZ_LOCAL
      IA_Z(IROW_LOC) = INNZ + 1
      DO JCOL=1,NNZ_D_MAT_Z(IROW_LOC)
         IF ( D_MAT_RHO(JCOL,IROW_LOC) == 0._EB ) CYCLE ! Drop zero values.
         INNZ = INNZ + 1
         A_Z(INNZ)  =  D_MAT_RHO(JCOL,IROW_LOC)
         JA_Z(INNZ) =   JD_MAT_Z(JCOL,IROW_LOC)
      ENDDO
   ENDDO
   IA_Z(NUNKZ_LOCAL+1) = INNZ + 1

   ! PARDISO:
   ! CALL SYMBLU_ZZ
   ! Numerical Factorization and Solve.
   ! PHASEZ = 23
   ! CALL PARDISO(PT_Z, MAXFCTZ, MNUMZ, MTYPEZ, PHASEZ, NUNKZ_TOTAL, &
   !      A_Z, IA_Z, JA_Z, PERMZ, NRHSZ, IPARMZ, MSGLVLZ, F_RHO, RZ_RHO, ERRORZ)

   ! Release internal memory for scalar:
   ! PHASEZ = -1
   ! CALL PARDISO(PT_Z, MAXFCTZ, MNUMZ, MTYPEZ, PHASEZ, NUNKZ_TOTAL, &
   !      A_Z, IA_Z, JA_Z, PERMZ, NRHSZ, IPARMZ, MSGLVLZ, F_RHO, RZ_RHO, ERRORZ)
#ifdef WITH_MKL
   CALL SYMBLU_ZZ
   ! Numerical Factorization and Solve.
   PHASEZ = 23
   CALL CLUSTER_SPARSE_SOLVER (PT_Z, MAXFCTZ, MNUMZ, MTYPEZ, PHASEZ, NUNKZ_TOTAL, &
       A_Z, IA_Z, JA_Z, PERMZ, NRHSZ, IPARMZ, MSGLVLZ, F_RHO, RZ_RHO, MPI_COMM_WORLD, ERRORZ)

   ! Release internal memory for scalar:
   PHASEZ = -1
   CALL CLUSTER_SPARSE_SOLVER (PT_Z, MAXFCTZ, MNUMZ, MTYPEZ, PHASEZ, NUNKZ_TOTAL, &
       A_Z, IA_Z, JA_Z, PERMZ, NRHSZ, IPARMZ, MSGLVLZ, F_RHO, RZ_RHO, MPI_COMM_WORLD, ERRORZ)
#endif /* WITH_MKL */

   ! Copy back to RHOP and CUT_CELL:
   CALL PUT_RHOVECTOR_3D

ENDIF MATRIX_DIFF_IF

! Loop through species:
! This loop performs an either implicit or explicit time advancement of the transport equations for each
! chemical species on the cut-cell implicit region, plus explicit reaction (as done on FDS).
! Scalar bounds are checked on the implicit region regular and cut-cells:
SPECIES_LOOP: DO N=1,N_TOTAL_SCALARS

   IF( (PREDICTOR.AND.FIRST_PASS) .OR. CORRECTOR) THEN

   ! Compute advection + diffusion matrix:
   IF ( DNS .OR. (N==1) ) THEN
      IF (DO_SYMM_SCALAR_DIFFLUXES) THEN
         CALL GET_ADVDIFFMATRIX_SCALAR_SYMM_3D(N)
      ELSE
         CALL GET_ADVDIFFMATRIX_SCALAR_3D(N)
      ENDIF
   ENDIF

   ! RHS vector F_BC, derived from boundary conditions on immersed and domain Boundaries:
   F_Z(:) = 0._EB
   CALL GET_ADVDIFFVECTOR_SCALAR_3D(N)

   ! Here add the reaction source term M_DOT_PPP, treated explicitly:
   IF (N_LP_ARRAY_INDICES>0 .OR. N_REACTIONS>0 .OR. ANY(SPECIES_MIXTURE%DEPOSITING)) THEN
      CALL GET_M_DOT_PPP_SCALAR_3D(N)
   ENDIF

   IF (PERIODIC_TEST==7) CALL GET_SHUNN3_QZ(T,N)

   ! Flux vector F_EXIM in the EXIM boundary for species N:
   CALL GET_EXIMVECTOR_SCALAR_3D(N)

   ! Get rho*zz vector at step n:
   CALL GET_RHOZZVECTOR_SCALAR_3D(N)

   ENDIF

   IF (PREDICTOR) THEN
      IF (FIRST_PASS) THEN
         D_MAT_Z0(:,:,N) = D_MAT_Z(:,:)
         F_Z0(:,N) = F_Z(:)
         RZ_Z0(:,N) = RZ_Z(:)
      ELSE
         D_MAT_Z(:,:) = D_MAT_Z0(:,:,N)
         F_Z(:) = F_Z0(:,N)
         RZ_Z(:)= RZ_Z0(:,N)
      ENDIF
   ENDIF

   ! Compute implicit discretization matrix, and store in D_MAT_Z:
   ! D_MAT_Z(i,j)= M_MAT_Z(i,j) + DT*D_MAT_Z(i,j):
   IF (PREDICTOR) THEN
      D_MAT_Z(:,:) = DT*D_MAT_Z(:,:)
   ELSE
      D_MAT_Z(:,:) = 0.5_EB*DT*D_MAT_Z(:,:)
   ENDIF

   ! Solve implicit system of equations for species N:
   ! D_MAT_Z RZZ^(n+1) = M_MAT_Z*RZZ^n - DT*(F_EXIM+F_BC)   PREDICTOR
   ! D_MAT_Z RZZ^(n+1) = M_MAT_Z*RZZ - 0.5_EB*(F_EXIM+F_BC) CORRECTOR
   IF (PREDICTOR) THEN
      IF (TRAP_CORR) THEN
         TR_Z(:,N) = 0._EB
         ALLOCATE(RZ_Z2(NUNKZ_TOTAL),RZ_Z2AUX(NUNKZ_TOTAL)); RZ_Z2=0._EB; RZ_Z2AUX=0._EB
         DO IROW_LOC=1,NUNKZ_LOCAL
            RZ_Z2AUX(IROW_LOC+UNKZ_IND(NM_START))=RZ_Z(IROW_LOC)
         ENDDO
         CALL MPI_ALLREDUCE(RZ_Z2AUX, RZ_Z2, NUNKZ_TOTAL, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD, IERR)
         DO IROW_LOC=1,NUNKZ_LOCAL
            ! [M_MAT_Z(:,:)-1/2*DT*D_MAT_Z(:,:)] * RZ_Z - 1/2*DT*F_Z: PART of Trapezoidal corrector rhs.
            DO JCOL=1,NNZ_D_MAT_Z(IROW_LOC)
               TR_Z(IROW_LOC,N) = TR_Z(IROW_LOC,N) - 0.5_EB*D_MAT_Z(JCOL,IROW_LOC)*RZ_Z2(JD_MAT_Z(JCOL,IROW_LOC))
            ENDDO
            TR_Z(IROW_LOC,N) = TR_Z(IROW_LOC,N) + M_MAT_Z(IROW_LOC)*RZ_Z(IROW_LOC) - 0.5_EB*DT*F_Z(IROW_LOC)
         ENDDO
         DEALLOCATE(RZ_Z2,RZ_Z2AUX)
      ENDIF
      DO IROW_LOC=1,NUNKZ_LOCAL
         F_Z(IROW_LOC) = M_MAT_Z(IROW_LOC)*RZ_Z(IROW_LOC) - DT*F_Z(IROW_LOC)
      ENDDO
   ELSE
      IF (TRAP_CORR) THEN
          DO IROW_LOC=1,NUNKZ_LOCAL
             F_Z(IROW_LOC) = TR_Z(IROW_LOC,N) - 0.5_EB*DT*F_Z(IROW_LOC)
          ENDDO
      ELSE
         DO IROW_LOC=1,NUNKZ_LOCAL
            F_Z(IROW_LOC) = M_MAT_Z(IROW_LOC)*RZ_Z(IROW_LOC) - 0.5_EB*DT*F_Z(IROW_LOC)
         ENDDO
      ENDIF
   ENDIF

   IF ( DNS .OR. (N==1) ) THEN
      ! Sum M_MAT + DT*D_MAT
      DO IROW_LOC=1,NUNKZ_LOCAL
         JCOL=JM_MAT_Z(IROW_LOC)
         D_MAT_Z(JCOL,IROW_LOC) = D_MAT_Z(JCOL,IROW_LOC) + M_MAT_Z(IROW_LOC)
      ENDDO
      ! Load into 3 vector CSR Format for Implicit Z matrix:
      INNZ = 0
      DO IROW_LOC=1,NUNKZ_LOCAL
         IA_Z(IROW_LOC) = INNZ + 1
         DO JCOL=1,NNZ_D_MAT_Z(IROW_LOC)
            !IF ( ABS(D_MAT_Z(JCOL,IROW_LOC)) < GEOMEPS**2._EB ) CYCLE ! Drop zero values.
            INNZ = INNZ + 1
            A_Z(INNZ)  =  D_MAT_Z(JCOL,IROW_LOC)
            JA_Z(INNZ) = JD_MAT_Z(JCOL,IROW_LOC)
         ENDDO
      ENDDO
      IA_Z(NUNKZ_LOCAL+1) = INNZ + 1
      ! Recover original D_MAT_Z, this is only used when in LES mode.
      DO IROW_LOC=1,NUNKZ_LOCAL
         JCOL=JM_MAT_Z(IROW_LOC)
         D_MAT_Z(JCOL,IROW_LOC) = D_MAT_Z(JCOL,IROW_LOC) - M_MAT_Z(IROW_LOC)
      ENDDO
   ENDIF

   IF (.NOT.DNS) THEN
      IF (PREDICTOR) THEN
         D_MAT_Z(:,:) = 1._EB/DT*D_MAT_Z(:,:)
      ELSE
         D_MAT_Z(:,:) = 2._EB/DT*D_MAT_Z(:,:)
      ENDIF
   ENDIF

   ! PARDISO:
   ! IF ( DNS .OR. (N==1) ) THEN
   !    CALL SYMBLU_ZZ
   !    ! Numerical Factorization:
   !    PHASEZ = 22
   !    CALL PARDISO(PT_Z, MAXFCTZ, MNUMZ, MTYPEZ, PHASEZ, NUNKZ_TOTAL, &
   !         A_Z, IA_Z, JA_Z, PERMZ, NRHSZ, IPARMZ, MSGLVLZ, F_Z, RZ_Z, ERRORZ)
   ! ENDIF

   ! Solve Phase
   ! PHASEZ = 33
   ! CALL PARDISO(PT_Z, MAXFCTZ, MNUMZ, MTYPEZ, PHASEZ, NUNKZ_TOTAL, &
   !      A_Z, IA_Z, JA_Z, PERMZ, NRHSZ, IPARMZ, MSGLVLZ, F_Z, RZ_Z, ERRORZ)

   ! Release internal memory for scalar:
   ! IF ( DNS .OR. (N==N_TOTAL_SCALARS) ) THEN
   !    PHASEZ = -1
   !    CALL PARDISO(PT_Z, MAXFCTZ, MNUMZ, MTYPEZ, PHASEZ, NUNKZ_TOTAL, &
   !         A_Z, IA_Z, JA_Z, PERMZ, NRHSZ, IPARMZ, MSGLVLZ, F_Z, RZ_Z, ERRORZ)
   ! ENDIF

#ifdef WITH_MKL

! WRITE(FILE_NAME,'(A,I2.2,A,I2.2,A,I2.2,A)') "Matrix_",MYID,'_',N_MPI_PROCESSES,'_',NMESHES,".dat"
! OPEN(unit=33, file=TRIM(FILE_NAME), status='unknown')
! WRITE(FILE_NAME,'(A,I2.2,A,I2.2,A,I2.2,A)') "VAR_",MYID,'_',N_MPI_PROCESSES,'_',NMESHES,".dat"
! OPEN(unit=34, file=TRIM(FILE_NAME), status='unknown')
! DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
!    CALL POINT_TO_MESH(NM)
!    DO K=1,KBAR
!       DO J=1,JBAR
!          DO I=1,IBAR
!             IF (CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE
!             WRITE(33,'(5I8,3F24.18,I8)') NM,IBM_GASPHASE,I,J,K,XC(I),YC(J),ZC(K),CCVAR(I,J,K,IBM_UNKZ)
!             WRITE(34,'(F24.18)') RZ_Z(CCVAR(I,J,K,IBM_UNKZ)-UNKZ_IND(NM_START)) !RZ_Z(CCVAR(I,J,K,IBM_UNKZ))
!          ENDDO
!       ENDDO
!    ENDDO
!    ! Cut cells:
!    DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
!       DO JCC=1,CUT_CELL(ICC)%NCELL
!          IF (CUT_CELL(ICC)%UNKZ(JCC) <= 0) CYCLE
!          WRITE(33,'(5I8,3F24.18,I8)') NM,IBM_CUTCFE,ICC,JCC,0,CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC),&
!          CUT_CELL(ICC)%UNKZ(JCC)
!          WRITE(34,'(F24.18)') RZ_Z(CUT_CELL(ICC)%UNKZ(JCC)-UNKZ_IND(NM_START)) !RZ_Z(CUT_CELL(ICC)%UNKZ(JCC))
!          IF(CUT_CELL(ICC)%UNKZ(JCC) == 2827) WRITE(LU_ERR,*) 'UNKZ == 2827, ',ICC,JCC,CUT_CELL(ICC)%VOLUME(JCC)
!       ENDDO
!    ENDDO
! ENDDO
! CLOSE(33)
! CLOSE(34)
!
! ! Write out A matrix:
! WRITE(FILE_NAME,'(A,I2.2,A,I2.2,A,I2.2,A)') "A_Z_",MYID,'_',N_MPI_PROCESSES,'_',NMESHES,".dat"
! OPEN(unit=33, file=TRIM(FILE_NAME), status='unknown')
! DO I=1,INNZ
!    WRITE(33,'(F24.18)') A_Z(I)
! ENDDO
! CLOSE(33)
! WRITE(FILE_NAME,'(A,I2.2,A,I2.2,A,I2.2,A)') "JA_Z_",MYID,'_',N_MPI_PROCESSES,'_',NMESHES,".dat"
! OPEN(unit=33, file=TRIM(FILE_NAME), status='unknown')
! DO I=1,INNZ
!    WRITE(33,'(I8)') JA_Z(I)
! ENDDO
! CLOSE(33)
! WRITE(FILE_NAME,'(A,I2.2,A,I2.2,A,I2.2,A)') "IA_Z_",MYID,'_',N_MPI_PROCESSES,'_',NMESHES,".dat"
! OPEN(unit=33, file=TRIM(FILE_NAME), status='unknown')
! DO I=1,NUNKZ_LOCAL+1
!    WRITE(33,'(I8)') IA_Z(I)
! ENDDO
! CLOSE(33)
!
!
! CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
! !STOP

   IF ( DNS .OR. (N==1) ) THEN
      CALL SYMBLU_ZZ
      ! Numerical Factorization.
      PHASEZ = 22
      CALL CLUSTER_SPARSE_SOLVER (PT_Z, MAXFCTZ, MNUMZ, MTYPEZ, PHASEZ, NUNKZ_TOTAL, &
          A_Z, IA_Z, JA_Z, PERMZ, NRHSZ, IPARMZ, MSGLVLZ, F_Z, RZ_Z, MPI_COMM_WORLD, ERRORZ)
   ENDIF

   ! Solve Phase
   PHASEZ = 33
   CALL CLUSTER_SPARSE_SOLVER (PT_Z, MAXFCTZ, MNUMZ, MTYPEZ, PHASEZ, NUNKZ_TOTAL, &
       A_Z, IA_Z, JA_Z, PERMZ, NRHSZ, IPARMZ, MSGLVLZ, F_Z, RZ_Z, MPI_COMM_WORLD, ERRORZ)

   ! Release internal memory for scalar:
   IF ( DNS .OR. (N==N_TOTAL_SCALARS) ) THEN
      PHASEZ = -1
      CALL CLUSTER_SPARSE_SOLVER (PT_Z, MAXFCTZ, MNUMZ, MTYPEZ, PHASEZ, NUNKZ_TOTAL, &
          A_Z, IA_Z, JA_Z, PERMZ, NRHSZ, IPARMZ, MSGLVLZ, F_Z, RZ_Z, MPI_COMM_WORLD, ERRORZ)
   ENDIF

   ! WRITE(FILE_NAME,'(A,I2.2,A,I2.2,A,I2.2,A)') "Matrix_",MYID,'_',N_MPI_PROCESSES,'_',NMESHES,".dat"
   ! OPEN(unit=33, file=TRIM(FILE_NAME), status='unknown')
   ! WRITE(FILE_NAME,'(A,I2.2,A,I2.2,A,I2.2,A)') "VAR_",MYID,'_',N_MPI_PROCESSES,'_',NMESHES,".dat"
   ! OPEN(unit=34, file=TRIM(FILE_NAME), status='unknown')
   ! DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   !    CALL POINT_TO_MESH(NM)
   !    DO K=1,KBAR
   !       DO J=1,JBAR
   !          DO I=1,IBAR
   !             IF (CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE
   !             WRITE(33,'(5I8,3F24.18,I8)') NM,IBM_GASPHASE,I,J,K,XC(I),YC(J),ZC(K),CCVAR(I,J,K,IBM_UNKZ)
   !             WRITE(34,'(F24.18)') RZ_Z(CCVAR(I,J,K,IBM_UNKZ)-UNKZ_IND(NM_START)) !RZ_Z(CCVAR(I,J,K,IBM_UNKZ))
   !          ENDDO
   !       ENDDO
   !    ENDDO
   !    ! Cut cells:
   !    DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
   !       DO JCC=1,CUT_CELL(ICC)%NCELL
   !          IF (CUT_CELL(ICC)%UNKZ(JCC) <= 0) CYCLE
   !          WRITE(33,'(5I8,3F24.18,I8)') NM,IBM_CUTCFE,ICC,JCC,0,CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC),&
   !          CUT_CELL(ICC)%UNKZ(JCC)
   !          WRITE(34,'(F24.18)') RZ_Z(CUT_CELL(ICC)%UNKZ(JCC)-UNKZ_IND(NM_START)) !RZ_Z(CUT_CELL(ICC)%UNKZ(JCC))
   !          IF(CUT_CELL(ICC)%UNKZ(JCC) == 2827) WRITE(LU_ERR,*) 'UNKZ == 2827, ',ICC,JCC,CUT_CELL(ICC)%VOLUME(JCC)
   !       ENDDO
   !    ENDDO
   ! ENDDO
   ! CLOSE(33)
   ! CLOSE(34)
   !
   ! ! Write out A matrix:
   ! WRITE(FILE_NAME,'(A,I2.2,A,I2.2,A,I2.2,A)') "A_Z_",MYID,'_',N_MPI_PROCESSES,'_',NMESHES,".dat"
   ! OPEN(unit=33, file=TRIM(FILE_NAME), status='unknown')
   ! DO I=1,INNZ
   !    WRITE(33,'(F24.18)') A_Z(I)
   ! ENDDO
   ! CLOSE(33)
   ! WRITE(FILE_NAME,'(A,I2.2,A,I2.2,A,I2.2,A)') "JA_Z_",MYID,'_',N_MPI_PROCESSES,'_',NMESHES,".dat"
   ! OPEN(unit=33, file=TRIM(FILE_NAME), status='unknown')
   ! DO I=1,INNZ
   !    WRITE(33,'(I8)') JA_Z(I)
   ! ENDDO
   ! CLOSE(33)
   ! WRITE(FILE_NAME,'(A,I2.2,A,I2.2,A,I2.2,A)') "IA_Z_",MYID,'_',N_MPI_PROCESSES,'_',NMESHES,".dat"
   ! OPEN(unit=33, file=TRIM(FILE_NAME), status='unknown')
   ! DO I=1,NUNKZ_LOCAL+1
   !    WRITE(33,'(I8)') IA_Z(I)
   ! ENDDO
   ! CLOSE(33)
   !
   !
   ! CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
   ! !STOP
#endif /* WITH_MKL */

   ! Copy back to RHOZZP and CUT_CELL:
   CALL PUT_RHOZZVECTOR_SCALAR_3D(N)

ENDDO SPECIES_LOOP

! Recompute rho*ZZalpha for the most abundant alpha in each cell:
IF (IMP_REGION_FROM_MATRIX_DIFF) THEN
   CALL GET_ZZ_CCIMPREG_3D
ELSE
   CALL GET_RHOZZ_CCIMPREG_3D
ENDIF

RETURN
END SUBROUTINE CCREGION_DENSITY_IMPLICIT

! --------------------------------- GET_ZZ_CCIMPREG_3D ---------------------------

SUBROUTINE GET_ZZ_CCIMPREG_3D

USE MATH_FUNCTIONS, ONLY: INTERPOLATE1D_UNIFORM
! Local Variables:
INTEGER :: NM,N,I,J,K,ICC,JCC,NCELL
REAL(EB), POINTER, DIMENSION(:,:,:)   :: RHOP=>NULL(),UP=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: ZZP=>NULL()
REAL(EB) :: VOLTOT
LOGICAL, PARAMETER :: DO_LAST_SPEC=.FALSE.

! Loop meshes:
MESH_LOOP : DO NM=1,NMESHES

   IF (PROCESS(NM)/=MYID) CYCLE

   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN
      RHOP => RHOS
      ZZP  => ZZS
      UP   => U

      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         NCELL=CUT_CELL(ICC)%NCELL
         DO JCC=1,NCELL
            ! Rho was obtained by integration of continuity -> in CUT_CELL(ICC)%RHOS(JCC)

            ! Check mass density for positivity
            IF ( (CUT_CELL(ICC)%RHOS(JCC)<RHOMIN) .OR. &
                 (CUT_CELL(ICC)%RHOS(JCC)>RHOMAX) ) THEN
               WRITE(LU_ERR,*) 'GET_ZZ_CCIMPREG_3D CC Pred:',ICC,JCC,CUT_CELL(ICC)%VOLUME(JCC)
               WRITE(LU_ERR,*) 'RHOP,MIN,MAX=',CUT_CELL(ICC)%RHOS(JCC),RHOMIN,RHOMAX
            ENDIF

            ! Find max rhos*ZZS:
            IF (DO_LAST_SPEC) THEN
               N=N_TOTAL_SCALARS
            ELSE
               N=MAXLOC(CUT_CELL(ICC)%ZZS(1:N_TOTAL_SCALARS,JCC),1)
            ENDIF

            ! Modify max rhos*ZZS s.t. sum(rhos*ZZS) = rhos:
            CUT_CELL(ICC)%ZZS(N,JCC) = CUT_CELL(ICC)%RHOS(JCC) - &
            (SUM(CUT_CELL(ICC)%ZZS(1:N_TOTAL_SCALARS,JCC))-CUT_CELL(ICC)%ZZS(N,JCC))

            ! Extract z from rho*z
            CUT_CELL(ICC)%ZZS(1:N_TOTAL_SCALARS,JCC) = &
            CUT_CELL(ICC)%ZZS(1:N_TOTAL_SCALARS,JCC)/  &
            CUT_CELL(ICC)%RHOS(JCC)

            ! Check bounds on z:
            DO N=1,N_TOTAL_SCALARS
               IF ( (CUT_CELL(ICC)%ZZS(N,JCC)<(0._EB-GEOMEPS)) .OR. &
                    (CUT_CELL(ICC)%ZZS(N,JCC)>(1._EB+GEOMEPS)) ) THEN
                  WRITE(LU_ERR,*) 'GET_ZZ_CCIMPREG_3D CC Pred:',ICC,JCC,N
                  WRITE(LU_ERR,*) 'ZZP=',CUT_CELL(ICC)%ZZS(N,JCC)
               ENDIF
            ENDDO

            ! Clip passive scalars:
            IF (N_PASSIVE_SCALARS==0) CYCLE
            CUT_CELL(ICC)%ZZS(ZETA_INDEX,JCC) = &
            MAX(0._EB,MIN(1._EB,CUT_CELL(ICC)%ZZS(ZETA_INDEX,JCC)))
         ENDDO

         ! Dump volume average scalar mass fraction and density to Cartesian container:
         I = CUT_CELL(ICC)%IJK(IAXIS)
         J = CUT_CELL(ICC)%IJK(JAXIS)
         K = CUT_CELL(ICC)%IJK(KAXIS)

         VOLTOT = SUM( CUT_CELL(ICC)%VOLUME(1:NCELL) )

         RHOP(I,J,K) = SUM( CUT_CELL(ICC)%RHOS(1:NCELL)* &
                            CUT_CELL(ICC)%VOLUME(1:NCELL) )/VOLTOT

         DO N=1,N_TOTAL_SCALARS
            ZZP(I,J,K,N) = SUM( CUT_CELL(ICC)%ZZS(N,1:NCELL)* &
                                CUT_CELL(ICC)%VOLUME(1:NCELL) )/VOLTOT
         ENDDO

      ENDDO

   ELSE
      RHOP => RHO
      ZZP  => ZZ
      UP   => US

      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         NCELL=CUT_CELL(ICC)%NCELL
         DO JCC=1,NCELL

            ! Rho was obtained by integration of continuity -> in CUT_CELL(ICC)%RHO(JCC)

            ! Check mass density for positivity
            IF ( (CUT_CELL(ICC)%RHO(JCC)<RHOMIN) .OR. &
                 (CUT_CELL(ICC)%RHO(JCC)>RHOMAX) ) THEN
               WRITE(LU_ERR,*) 'GET_ZZ_CCIMPREG_3D CC Corr:',ICC,JCC,CUT_CELL(ICC)%VOLUME(JCC)
               WRITE(LU_ERR,*) 'RHOP,MIN,MAX=',CUT_CELL(ICC)%RHO(JCC),RHOMIN,RHOMAX
            ENDIF

            ! Find max rho*ZZ:
            IF (DO_LAST_SPEC) THEN
               N=N_TOTAL_SCALARS
            ELSE
               N=MAXLOC(CUT_CELL(ICC)%ZZ(1:N_TOTAL_SCALARS,JCC),1)
            ENDIF

            ! Modify max rho*ZZ s.t. sum(rho*ZZ) = rho:
            CUT_CELL(ICC)%ZZ(N,JCC) = CUT_CELL(ICC)%RHO(JCC) - &
            (SUM(CUT_CELL(ICC)%ZZ(1:N_TOTAL_SCALARS,JCC))-CUT_CELL(ICC)%ZZ(N,JCC))

            ! Extract z from rho*z
            CUT_CELL(ICC)%ZZ(1:N_TOTAL_SCALARS,JCC) = &
            CUT_CELL(ICC)%ZZ(1:N_TOTAL_SCALARS,JCC)/  &
            CUT_CELL(ICC)%RHO(JCC)

            ! Check bounds on z:
            DO N=1,N_TOTAL_SCALARS
               IF ( (CUT_CELL(ICC)%ZZ(N,JCC)<(0._EB-GEOMEPS)) .OR. &
                    (CUT_CELL(ICC)%ZZ(N,JCC)>(1._EB+GEOMEPS)) ) THEN
                  WRITE(LU_ERR,*) 'GET_ZZ_CCIMPREG_3D CC Corr:',ICC,JCC,N
                  WRITE(LU_ERR,*) 'ZZP=',CUT_CELL(ICC)%ZZ(N,JCC)
               ENDIF
            ENDDO

            ! Clip passive scalars:
            IF (N_PASSIVE_SCALARS==0) CYCLE
            CUT_CELL(ICC)%ZZ(ZETA_INDEX,JCC) = &
            MAX(0._EB,MIN(1._EB,CUT_CELL(ICC)%ZZ(ZETA_INDEX,JCC)))
         ENDDO

         ! Dump volume average scalar mass fraction and density to Cartesian container:
         I = CUT_CELL(ICC)%IJK(IAXIS)
         J = CUT_CELL(ICC)%IJK(JAXIS)
         K = CUT_CELL(ICC)%IJK(KAXIS)

         VOLTOT = SUM( CUT_CELL(ICC)%VOLUME(1:NCELL) )

         RHOP(I,J,K) = SUM( CUT_CELL(ICC)%RHO(1:NCELL)* &
                            CUT_CELL(ICC)%VOLUME(1:NCELL) )/VOLTOT

         DO N=1,N_TOTAL_SCALARS
            ZZP(I,J,K,N) = SUM( CUT_CELL(ICC)%ZZ(N,1:NCELL)* &
                                CUT_CELL(ICC)%VOLUME(1:NCELL) )/VOLTOT
         ENDDO

      ENDDO

   ENDIF

   ! Regular Cartesian cells:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (MESHES(NM)%CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE ! Cycle Reg cells not implicit, cut-cells
                                                             ! underlying Cartesian cells and
                                                             ! solid cells.

            ! Rho was obtained by integration of continuity -> in RHOP(I,J,K)

            IF (K==2 .AND. I==IBAR/2 .AND. J==JBAR/2) THEN
               WRITE(0,*) 'RHOC,RHO_SUM',PREDICTOR,I,J,RHOP(I,J,K),SUM(ZZP(I,J,K,1:N_TRACKED_SPECIES))
            ENDIF

            ! Check mass density for positivity
            IF ((RHOP(I,J,K)<RHOMIN) .OR. (RHOP(I,J,K)>RHOMAX) ) THEN
               WRITE(LU_ERR,*) 'GET_ZZ_CCIMPREG_3D Cart:',I,J,K
               WRITE(LU_ERR,*) 'RHOP,MIN,MAX=',RHOP(I,J,K),RHOMIN,RHOMAX
            ENDIF

            ! Find max rho*ZZ:
            IF (DO_LAST_SPEC) THEN
               N=N_TOTAL_SCALARS
            ELSE
               N=MAXLOC(ZZP(I,J,K,1:N_TOTAL_SCALARS),1)
            ENDIF

            ! Modify max rho*ZZ s.t. sum(rho*ZZ) = rho:
            ZZP(I,J,K,N) = RHOP(I,J,K) - (SUM(ZZP(I,J,K,1:N_TOTAL_SCALARS))-ZZP(I,J,K,N))

            ! Extract z from rho*z
            ZZP(I,J,K,1:N_TOTAL_SCALARS) = ZZP(I,J,K,1:N_TOTAL_SCALARS)/RHOP(I,J,K)

            ! Check bounds on z:
            DO N=1,N_TOTAL_SCALARS
               IF (ZZP(I,J,K,N)<(0._EB-GEOMEPS) .OR. ZZP(I,J,K,N)>(1._EB+GEOMEPS)) THEN
                  WRITE(LU_ERR,*) 'GET_ZZ_CCIMPREG_3D Cart:',I,J,K,N
                  WRITE(LU_ERR,*) 'ZZP=',ZZP(I,J,K,N)
               ENDIF
            ENDDO

            ! Clip passive scalars:
            IF (N_PASSIVE_SCALARS==0) CYCLE
            ZZP(I,J,K,ZETA_INDEX) = MAX(0._EB,MIN(1._EB,ZZP(I,J,K,ZETA_INDEX)))

         ENDDO
      ENDDO
   ENDDO

ENDDO MESH_LOOP

RETURN
END SUBROUTINE GET_ZZ_CCIMPREG_3D

! ---------------------------------- PUT_RHOVECTOR_3D ----------------------------

SUBROUTINE PUT_RHOVECTOR_3D

! Local Variables:
INTEGER :: NM,I,J,K,IROW_LOC,ICC,JCC
REAL(EB), POINTER, DIMENSION(:,:,:) :: RHOP=>NULL()

! Loop meshes:
MESH_LOOP : DO NM=1,NMESHES

   IF (PROCESS(NM)/=MYID) CYCLE

   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN
      RHOP  => RHOS ! Copy rho obtained at the end of substep.
      ! Loop Cut-cells for PREDICTOR:
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            IROW_LOC = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
            CUT_CELL(ICC)%RHOS(JCC) = RZ_RHO(IROW_LOC)
         ENDDO
      ENDDO

   ELSE
      RHOP  => RHO  ! Copy rho obtained at the end of substep.
      ! Loop Cut-cells for CORRECTOR:
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            IROW_LOC = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
            CUT_CELL(ICC)%RHO(JCC) = RZ_RHO(IROW_LOC)
         ENDDO
      ENDDO

   ENDIF

   ! Loop on Cartesian Cells:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR

            IF (MESHES(NM)%CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE ! Cycle Reg cells not implicit, cut-cells
                                                             ! underlying Cartesian cells and
                                                             ! solid cells.

            ! Cut-cells are surrounded by a layer of GASPHASE cells which is
            ! also integrated implicitly.
            IROW_LOC = MESHES(NM)%CCVAR(I,J,K,IBM_UNKZ) - UNKZ_IND(NM_START)

            RHOP(I,J,K)   = RZ_RHO(IROW_LOC)
         ENDDO
      ENDDO
   ENDDO

ENDDO MESH_LOOP

RETURN
END SUBROUTINE PUT_RHOVECTOR_3D

! ---------------------------------- PUT_RHOVECTOR_3D ----------------------------

SUBROUTINE GET_RHOVECTOR_3D

! Local Variables:
INTEGER :: NM,I,J,K,IROW_LOC,ICC,JCC

! Initialize rho:
RZ_RHO(:) = 0._EB
RZ_RHOS(:)= 0._EB

! Loop meshes:
MESH_LOOP : DO NM=1,NMESHES

   IF (PROCESS(NM)/=MYID) CYCLE

   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN

      ! Loop on Cartesian Cells:
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (MESHES(NM)%CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE ! Cycle Reg cells not implicit, cut-cells
                                                                ! underlying Cartesian cells and
                                                                ! solid cells.

               ! Cut-cells are surrounded by a layer of GASPHASE cells which is
               ! also integrated implicitly.
               IROW_LOC = MESHES(NM)%CCVAR(I,J,K,IBM_UNKZ) - UNKZ_IND(NM_START)
               RZ_RHO(IROW_LOC) = RHO(I,J,K) ! Known rho^n
            ENDDO
         ENDDO
      ENDDO

      ! Now loop Cut-cells:
      CUTCELL_LOOP : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            IROW_LOC = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
            RZ_RHO(IROW_LOC) = CUT_CELL(ICC)%RHO(JCC) ! Known rho^n
         ENDDO
      ENDDO CUTCELL_LOOP

   ELSE

      ! Loop on Cartesian Cells:
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (MESHES(NM)%CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE ! Cycle Reg cells not implicit, cut-cells
                                                                ! underlying Cartesian cells and
                                                                ! solid cells.

               ! Cut-cells are surrounded by a layer of GASPHASE cells which is
               ! also integrated implicitly.
               IROW_LOC = MESHES(NM)%CCVAR(I,J,K,IBM_UNKZ) - UNKZ_IND(NM_START)

               ! RZ_RHO(IROW_LOC) = 0.5_EB*(RHO(I,J,K)+RHOS(I,J,K)) ! Known rho
               ! We use the stored RHO_ZZN as RHO has already been changed in DENSITY for the end of step with an
               ! unwanted value.
               RZ_RHO(IROW_LOC) = 0.5_EB*(SUM(MESHES(NM)%RHO_ZZN(I,J,K,1:N_TOTAL_SCALARS))+RHOS(I,J,K))

               !RZ_RHO(IROW_LOC) = SUM(MESHES(NM)%RHO_ZZN(I,J,K,1:N_TOTAL_SCALARS))
               RZ_RHOS(IROW_LOC)= RHOS(I,J,K)

            ENDDO
         ENDDO
      ENDDO

      ! Now loop Cut-cells:
      CUTCELL_LOOP2 : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            IROW_LOC = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
            RZ_RHO(IROW_LOC) = 0.5_EB*(CUT_CELL(ICC)%RHO(JCC) + CUT_CELL(ICC)%RHOS(JCC))
            RZ_RHOS(IROW_LOC)= CUT_CELL(ICC)%RHOS(JCC)
         ENDDO
      ENDDO CUTCELL_LOOP2

   ENDIF

ENDDO MESH_LOOP

RETURN
END SUBROUTINE GET_RHOVECTOR_3D

! ----------------------------- GET_EXIMVECTOR_DENSITY_3D ------------------------

SUBROUTINE GET_EXIMVECTOR_DENSITY_3D

! Local Variables:
INTEGER :: NM,IEXIM,I,J,K,X1AXIS,LHFACE,IROW_LOC
REAL(EB):: FCT,AF,FLX

! Advective fluxes for species N have been copied to IBM_EXIM_FACE%FLX(HIGH_IND,N) containers
! in routine DENSITY
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   DO IEXIM=1,MESHES(NM)%IBM_NEXIMFACE_MESH

      I      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(IAXIS)
      J      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(JAXIS)
      K      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(KAXIS+1)

      LHFACE = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%LHFACE
      FCT = REAL(2*LHFACE-3,EB) ! fct = 1, if lhface is HIGH for the cell, -1 if LOW.

      IROW_LOC = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%UNKZ - UNKZ_IND(NM_START)

      AF =   MESHES(NM)%IBM_EXIM_FACE(IEXIM)%AREA
      FLX=   SUM(MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FLX(HIGH_IND,1:N_TOTAL_SCALARS)) ! sum_i(rho*ZZi*u)

      F_RHO(IROW_LOC) = F_RHO(IROW_LOC) + FCT*FLX*AF

   ENDDO

ENDDO MESH_LOOP


RETURN
END SUBROUTINE GET_EXIMVECTOR_DENSITY_3D

! ----------------------------- GET_ADVVECTOR_DENSITY_3D -------------------------

SUBROUTINE GET_ADVVECTOR_DENSITY_3D

! Local Variables:

! This routine computes RHS due to boundary conditions prescribed in immersed solids
! and domain boundaries.

!!!! Stub routine for now. !!!!

! Source due to nonzero velocities in SOLID-CUT CELL interface faces:
! This is only nonzero when the Poisson solve is done s.t. PRES_ON_WHOLE_DOMAIN = .TRUE.
IF (PRES_ON_WHOLE_DOMAIN) CALL GET_ADV_TRANSPIRATIONVECTOR_DENSITY_3D ! add to F_RHO

RETURN
END SUBROUTINE GET_ADVVECTOR_DENSITY_3D

! -------------------- GET_ADV_TRANSPIRATIONVECTOR_DENSITY_3D --------------------

SUBROUTINE GET_ADV_TRANSPIRATIONVECTOR_DENSITY_3D

! Local Variables:
INTEGER :: NM,I,J,K,ICC,JCC,ICF,ICF2,IFC,JCOL,IFACE,INDADD,INDF,NFACE,IROW_LOC
REAL(EB):: FSCU,AREATOT,AREAI

! Loop meshes:
MESH_LOOP : DO NM=1,NMESHES
   IF (PROCESS(NM)/=MYID) CYCLE
   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN

      ! First Cycle over cut-cell underlying Cartesian cells:
      ICC_LOOP : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH

         I      = CUT_CELL(ICC)%IJK(IAXIS)
         J      = CUT_CELL(ICC)%IJK(JAXIS)
         K      = CUT_CELL(ICC)%IJK(KAXIS)

         FSCU = 0._EB

         ! Loop on cells neighbors and test if they are of type IBM_SOLID, if so
         ! Add to velocity flux:
         ! X faces
         DO INDADD=-1,1,2
            INDF = I - FCELL + (INDADD+1)/2
            IF( FCVAR(INDF,J,K,IBM_FGSC,IAXIS) /= IBM_SOLID) CYCLE
            FSCU = FSCU + REAL(INDADD,EB)*U(INDF,J,K)*DY(J)*DZ(K)
         ENDDO
         ! Y faces
         DO INDADD=-1,1,2
            INDF = J - FCELL + (INDADD+1)/2
            IF( FCVAR(I,INDF,K,IBM_FGSC,JAXIS) /= IBM_SOLID ) CYCLE
            FSCU = FSCU + REAL(INDADD,EB)*V(I,INDF,K)*DX(I)*DZ(K)
         ENDDO
         ! Z faces
         DO INDADD=-1,1,2
            INDF = K - FCELL + (INDADD+1)/2
            IF( FCVAR(I,J,INDF,IBM_FGSC,KAXIS) /= IBM_SOLID ) CYCLE
            FSCU = FSCU + REAL(INDADD,EB)*W(I,J,INDF)*DX(I)*DY(J)
         ENDDO

         ! Now Define total area of INBOUNDARY cut-faces:
         ICF=CCVAR(I,J,K,IBM_IDCF);
         IF (ICF <= 0) CYCLE
         NFACE = CUT_FACE(ICF)%NFACE
         AREATOT = SUM ( CUT_FACE(ICF)%AREA(1:NFACE) )
         DO JCC =1,CUT_CELL(ICC)%NCELL
            IROW_LOC = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
            IFC_LOOP : DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)

               IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)

               IF (CUT_CELL(ICC)%FACE_LIST(1,IFACE) == IBM_FTYPE_CFINB) THEN
                  ICF2   = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
                  IFACE  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
                  IF ( ICF2 /= ICF ) &
                  WRITE(LU_ERR,*) "GET_ADV_TRANSPIRATIONVECTOR_DENSITY_3D ", &
                                  "INBOUND CF obtained from CUT_CELL doesn't match."
                  AREAI = CUT_FACE(ICF)%AREA(IFACE)
                  IF (DO_IMPLICIT_CCREGION) THEN
                     JCOL=JM_MAT_Z(IROW_LOC)
                     D_MAT_RHO(JCOL,IROW_LOC) = D_MAT_RHO(JCOL,IROW_LOC) + AREAI/AREATOT*FSCU
                  ELSE
                     F_RHO(IROW_LOC) = F_RHO(IROW_LOC) + AREAI/AREATOT*FSCU * CUT_CELL(ICC)%RHO(JCC)
                  ENDIF
               ENDIF

            ENDDO IFC_LOOP
         ENDDO
      ENDDO ICC_LOOP

   ELSE

      ! First Cycle over cut-cell underlying Cartesian cells:
      ICC_LOOP2 : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH

         I      = CUT_CELL(ICC)%IJK(IAXIS)
         J      = CUT_CELL(ICC)%IJK(JAXIS)
         K      = CUT_CELL(ICC)%IJK(KAXIS)

         FSCU = 0._EB

         ! Loop on cells neighbors and test if they are of type IBM_SOLID, if so
         ! Add to velocity flux:
         ! X faces
         DO INDADD=-1,1,2
            INDF = I - FCELL + (INDADD+1)/2
            IF( FCVAR(INDF,J,K,IBM_FGSC,IAXIS) /= IBM_SOLID) CYCLE
            FSCU = FSCU + REAL(INDADD,EB)*US(INDF,J,K)*DY(J)*DZ(K)
         ENDDO
         ! Y faces
         DO INDADD=-1,1,2
            INDF = J - FCELL + (INDADD+1)/2
            IF( FCVAR(I,INDF,K,IBM_FGSC,JAXIS) /= IBM_SOLID ) CYCLE
            FSCU = FSCU + REAL(INDADD,EB)*VS(I,INDF,K)*DX(I)*DZ(K)
         ENDDO
         ! Z faces
         DO INDADD=-1,1,2
            INDF = K - FCELL + (INDADD+1)/2
            IF( FCVAR(I,J,INDF,IBM_FGSC,KAXIS) /= IBM_SOLID ) CYCLE
            FSCU = FSCU + REAL(INDADD,EB)*WS(I,J,INDF)*DX(I)*DY(J)
         ENDDO


         ! Now Define total area of INBOUNDARY cut-faces:
         ICF=CCVAR(I,J,K,IBM_IDCF);
         IF (ICF <= 0) CYCLE
         NFACE = CUT_FACE(ICF)%NFACE
         AREATOT = SUM ( CUT_FACE(ICF)%AREA(1:NFACE) )
         DO JCC =1,CUT_CELL(ICC)%NCELL
            IROW_LOC = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
            IFC_LOOP2 : DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)

               IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)

               IF (CUT_CELL(ICC)%FACE_LIST(1,IFACE) == IBM_FTYPE_CFINB) THEN
                  ICF2   = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
                  IFACE  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
                  AREAI = CUT_FACE(ICF)%AREA(IFACE)
                  IF (DO_IMPLICIT_CCREGION) THEN
                     JCOL=JM_MAT_Z(IROW_LOC)
                     D_MAT_RHO(JCOL,IROW_LOC) = D_MAT_RHO(JCOL,IROW_LOC) + AREAI/AREATOT*FSCU
                  ELSE
                     F_RHO(IROW_LOC) = F_RHO(IROW_LOC) + AREAI/AREATOT*FSCU * CUT_CELL(ICC)%RHOS(JCC)
                  ENDIF
               ENDIF

            ENDDO IFC_LOOP2
         ENDDO
      ENDDO ICC_LOOP2

   ENDIF ! PREDICTOR

ENDDO MESH_LOOP

RETURN
END SUBROUTINE GET_ADV_TRANSPIRATIONVECTOR_DENSITY_3D


! ----------------------------- GET_ADVMATRIX_DENSITY_3D -------------------------

SUBROUTINE GET_ADVMATRIX_DENSITY_3D

! Local Variables:
INTEGER :: NM,I,J,K
REAL(EB):: PRFCT
INTEGER :: X1AXIS,IFACE,IND(LOW_IND:HIGH_IND),IND_LOC(LOW_IND:HIGH_IND),ICF
INTEGER :: LOCROW_1,LOCROW_2,ILOC,JLOC,IROW,JCOL
REAL(EB):: AF,KFACE(2,2),CIJP,CIJM,VELC,ALPHAP1,AM_P1,AP_P1
LOGICAL, PARAMETER :: ALL_GODUNOV = .FALSE. ! If false uses centered interpolation for diffusion velocity.
REAL(EB), POINTER, DIMENSION(:,:,:) :: RHOP=>NULL(),UP=>NULL(),VP=>NULL(),WP=>NULL()

! Set D_MAT_RHO to zero, will add implicit parts of advection:
D_MAT_RHO = 0._EB

! 1. Regular gasphase faces, connecting regular cells:
! Mesh Loop:
MESH_LOOP : DO NM=1,NMESHES

   IF (PROCESS(NM)/=MYID) CYCLE

   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN
      RHOP => RHO
      UP   => U
      VP   => V
      WP   => W
      PRFCT= 1._EB
   ELSE
      RHOP => RHOS
      UP   => US
      VP   => VS
      WP   => WS
      PRFCT= 0._EB
   ENDIF

   ! X direction bounds:
   ILO_FACE = 0                    ! Low mesh boundary face index.
   IHI_FACE = IBAR                 ! High mesh boundary face index.

   ! Y direction bounds:
   JLO_FACE = 0                    ! Low mesh boundary face index.
   JHI_FACE = JBAR                 ! High mesh boundary face index.

   ! Z direction bounds:
   KLO_FACE = 0                    ! Low mesh boundary face index.
   KHI_FACE = KBAR                 ! High mesh boundary face index.

   ! IAXIS faces:
   X1AXIS = IAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      I  = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I+FCELL-1,J,K,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I+FCELL  ,J,K,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Face area and Velocity u:
      AF = DY(J)*DZ(K)
      VELC = UP(I,J,K)

      ! Matrix coefficients:
      ALPHAP1 = SIGN( 1._EB, VELC)
      AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
      AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
      CIJM = AM_P1*VELC*AF
      CIJP = AP_P1*VELC*AF

      ! Now add to A corresponding advection coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = CIJM; KFACE(2,1) =-CIJM; KFACE(1,2) = CIJP; KFACE(2,2) =-CIJP

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( I == ILO_FACE )  LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
      IF ( I == IHI_FACE )  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.

      DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
         DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
             IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
             JCOL=MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%JD(ILOC,JLOC) ! Local position of coef in D_MAT_RHO
             ! Add coefficient:
             D_MAT_RHO(JCOL,IROW) = D_MAT_RHO(JCOL,IROW) + KFACE(ILOC,JLOC)
         ENDDO
      ENDDO

   ENDDO

   ! JAXIS faces:
   X1AXIS = JAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      I  = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I,J+FCELL-1,K,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I,J+FCELL  ,K,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Face area and Velocity v:
      AF = DX(I)*DZ(K)
      VELC = VP(I,J,K)

      ! Matrix coefficients:
      ALPHAP1 = SIGN( 1._EB, VELC)
      AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
      AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
      CIJM = AM_P1*VELC*AF
      CIJP = AP_P1*VELC*AF

      ! Now add to A corresponding advection and diffusion coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = CIJM; KFACE(2,1) =-CIJM; KFACE(1,2) = CIJP; KFACE(2,2) =-CIJP

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( J == JLO_FACE )  LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
      IF ( J == JHI_FACE )  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.

      DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
         DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
             IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
             JCOL=MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%JD(ILOC,JLOC) ! Local position of coef in D_MAT_RHO
             ! Add coefficient:
             D_MAT_RHO(JCOL,IROW) = D_MAT_RHO(JCOL,IROW) + KFACE(ILOC,JLOC)
         ENDDO
      ENDDO

   ENDDO

   ! KAXIS faces:
   X1AXIS = KAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      I  = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I,J,K+FCELL-1,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I,J,K+FCELL  ,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Face area and Velocity w:
      AF = DX(I)*DY(J)
      VELC = WP(I,J,K)

      ! Matrix coefficients:
      ALPHAP1 = SIGN( 1._EB, VELC)
      AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
      AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
      CIJM = AM_P1*VELC*AF
      CIJP = AP_P1*VELC*AF

      ! Now add to A corresponding advection and diffusion coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = CIJM; KFACE(2,1) =-CIJM; KFACE(1,2) = CIJP; KFACE(2,2) =-CIJP

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( K == KLO_FACE )  LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
      IF ( K == KHI_FACE )  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.

      DO ILOC=LOCROW_1,LOCROW_2   ! Local row number in Kface
         DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
             IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
             JCOL=MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%JD(ILOC,JLOC) ! Local position of coef in D_MAT_RHO
             ! Add coefficient:
             D_MAT_RHO(JCOL,IROW) = D_MAT_RHO(JCOL,IROW) + KFACE(ILOC,JLOC)
         ENDDO
      ENDDO

   ENDDO

   ! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
   DO IFACE=1,MESHES(NM)%IBM_NRCFACE_Z

      I      = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(IAXIS)
      J      = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(JAXIS)
      K      = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(KAXIS+1)

      ! Unknowns on related cells:
      IND(LOW_IND)  = MESHES(NM)%IBM_RCFACE_Z(IFACE)%UNK(LOW_IND)
      IND(HIGH_IND) = MESHES(NM)%IBM_RCFACE_Z(IFACE)%UNK(HIGH_IND)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            AF = DY(J)*DZ(K)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
            ! Advective Part: Velocity u
            VELC = UP(I,J,K)
         CASE(JAXIS)
            AF = DX(I)*DZ(K)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
            ! Advective Part: Velocity v+D/rho drho/dy
            VELC = VP(I,J,K)
         CASE(KAXIS)
            AF = DX(I)*DY(J)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
            ! Advective Part: Velocity w+D/rho drho/dz
            VELC = WP(I,J,K)
      ENDSELECT

      ! Matrix coefficients for advection:
      ALPHAP1 = SIGN( 1._EB, VELC)
      AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
      AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
      CIJM = AM_P1*VELC*AF
      CIJP = AP_P1*VELC*AF

      ! Now add to A corresponding advection and diffusion coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = CIJM; KFACE(2,1) =-CIJM; KFACE(1,2) = CIJP; KFACE(2,2) =-CIJP

      DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
         DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
             IROW=IND_LOC(ILOC)                                ! Process Local Unknown number.
             JCOL=MESHES(NM)%IBM_RCFACE_Z(IFACE)%JD(ILOC,JLOC) ! Local position of coef in D_MAT_RHO
             ! Add coefficient:
             D_MAT_RHO(JCOL,IROW) = D_MAT_RHO(JCOL,IROW) + KFACE(ILOC,JLOC)
         ENDDO
      ENDDO

   ENDDO

   ! Now Gasphase CUT_FACES:
   DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH

      IF ( MESHES(NM)%CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE

      I = MESHES(NM)%CUT_FACE(ICF)%IJK(IAXIS)
      J = MESHES(NM)%CUT_FACE(ICF)%IJK(JAXIS)
      K = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS+1)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         CASE(JAXIS)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         CASE(KAXIS)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
      ENDSELECT

      DO IFACE=1,MESHES(NM)%CUT_FACE(ICF)%NFACE

         ! Unknowns on related cells:
         IND(LOW_IND)  = MESHES(NM)%CUT_FACE(ICF)%UNKZ(LOW_IND,IFACE)
         IND(HIGH_IND) = MESHES(NM)%CUT_FACE(ICF)%UNKZ(HIGH_IND,IFACE)

         IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
         IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

         AF = MESHES(NM)%CUT_FACE(ICF)%AREA(IFACE)

         ! Matrix coefficients for advection:
         VELC =        PRFCT *MESHES(NM)%CUT_FACE(ICF)%VEL(IFACE) + &
                (1._EB-PRFCT)*MESHES(NM)%CUT_FACE(ICF)%VELS(IFACE)

         ALPHAP1 = SIGN( 1._EB, VELC)
         AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
         AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
         CIJM = AM_P1*VELC*AF
         CIJP = AP_P1*VELC*AF

         ! Now add to A corresponding advection and diffusion coeffs:
         !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
         KFACE(1,1) = CIJM; KFACE(2,1) =-CIJM; KFACE(1,2) = CIJP; KFACE(2,2) =-CIJP

         DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
            DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
                IROW=IND_LOC(ILOC)                                     ! Process Local Unknown number.
                JCOL=MESHES(NM)%CUT_FACE(ICF)%JDZ(ILOC,JLOC,IFACE) ! Local position of coef in D_MAT_RHO
                ! Add coefficient:
                D_MAT_RHO(JCOL,IROW) = D_MAT_RHO(JCOL,IROW) + KFACE(ILOC,JLOC)
            ENDDO
         ENDDO

      ENDDO

   ENDDO

ENDDO MESH_LOOP

RETURN
END SUBROUTINE GET_ADVMATRIX_DENSITY_3D

! ------------------------------ GET_RHOZZ_CCIMPREG_3D ---------------------------

SUBROUTINE GET_RHOZZ_CCIMPREG_3D

USE MATH_FUNCTIONS, ONLY: INTERPOLATE1D_UNIFORM
! Local Variables:
INTEGER :: NM,N,I,J,K,ICC,JCC,NCELL,NMX
REAL(EB), POINTER, DIMENSION(:,:,:)   :: RHOP=>NULL(),UP=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: ZZP=>NULL()
REAL(EB) :: VOLTOT

! Loop meshes:
MESH_LOOP : DO NM=1,NMESHES

   IF (PROCESS(NM)/=MYID) CYCLE

   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN
      RHOP => RHOS
      ZZP  => ZZS
      UP   => U

      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         NCELL=CUT_CELL(ICC)%NCELL
         DO JCC=1,NCELL
            ! Get rho = sum(rho*z_alpha)
            CUT_CELL(ICC)%RHOS(JCC) = SUM(CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC))

#ifdef DEBUG_CCREGION_SCALAR_TRANSPORT
            ! Check mass density for positivity
            IF ( (CUT_CELL(ICC)%RHOS(JCC)<RHOMIN) .OR. (CUT_CELL(ICC)%RHOS(JCC)>RHOMAX) ) THEN
               WRITE(LU_ERR,*) 'GET_RHOZZ_CCIMPREG_3D CC Pred:',ICC,JCC,CUT_CELL(ICC)%VOLUME(JCC)
               WRITE(LU_ERR,*) 'CELL Location=',X(CUT_CELL(ICC)%IJK(IAXIS)),Y(CUT_CELL(ICC)%IJK(JAXIS)),&
                                                Z(CUT_CELL(ICC)%IJK(KAXIS))
               WRITE(LU_ERR,*) 'RHOP,MIN,MAX=',CUT_CELL(ICC)%RHOS(JCC),RHOMIN,RHOMAX
            ENDIF
#endif

            ! Extract z from rho*z
            CUT_CELL(ICC)%ZZS(1:N_TOTAL_SCALARS,JCC) = CUT_CELL(ICC)%ZZS(1:N_TOTAL_SCALARS,JCC)/CUT_CELL(ICC)%RHOS(JCC)

#ifdef DEBUG_CCREGION_SCALAR_TRANSPORT
            ! Check bounds on z:
            DO N=1,N_TOTAL_SCALARS
               IF ( (CUT_CELL(ICC)%ZZS(N,JCC)<(0._EB-GEOMEPS)) .OR. (CUT_CELL(ICC)%ZZS(N,JCC)>(1._EB+GEOMEPS)) ) THEN
                  WRITE(LU_ERR,*) 'GET_RHOZZ_CCIMPREG_3D CC Pred:',ICC,JCC,N
                  WRITE(LU_ERR,*) 'ZZP=',CUT_CELL(ICC)%ZZS(N,JCC)
               ENDIF
            ENDDO
#else
            ! Some z_alpha might be slightly below zero (bounds overrun), assign -ve mass to most abundant species:
            ! Note rho = sum(rho*z_alpha), sum(z_alpha)=1 remain unchanged.
            NMX=MAXLOC(CUT_CELL(ICC)%ZZS(1:N_TRACKED_SPECIES,JCC),DIM=1)
            DO N=1,N_TRACKED_SPECIES
               IF(N==NMX) CYCLE
               IF ( CUT_CELL(ICC)%ZZS(N,JCC) < (0._EB-TWO_EPSILON_EB)) THEN
                  CUT_CELL(ICC)%ZZS(NMX,JCC) = CUT_CELL(ICC)%ZZS(NMX,JCC) + CUT_CELL(ICC)%ZZS(N,JCC)
                  CUT_CELL(ICC)%ZZS(N,JCC)   = 0._EB
               ENDIF
            ENDDO
#endif

            ! Clip passive scalars:
            IF (N_PASSIVE_SCALARS==0) CYCLE
            CUT_CELL(ICC)%ZZS(ZETA_INDEX,JCC) = MAX(0._EB,MIN(1._EB,CUT_CELL(ICC)%ZZS(ZETA_INDEX,JCC)))
         ENDDO

         ! Dump volume average scalar mass fraction and density to Cartesian container:
         I = CUT_CELL(ICC)%IJK(IAXIS)
         J = CUT_CELL(ICC)%IJK(JAXIS)
         K = CUT_CELL(ICC)%IJK(KAXIS)
         VOLTOT = SUM( CUT_CELL(ICC)%VOLUME(1:NCELL) )
         RHOP(I,J,K) = SUM( CUT_CELL(ICC)%RHOS(1:NCELL)*CUT_CELL(ICC)%VOLUME(1:NCELL) )/VOLTOT
         DO N=1,N_TOTAL_SCALARS
            ZZP(I,J,K,N) = SUM( CUT_CELL(ICC)%ZZS(N,1:NCELL)*CUT_CELL(ICC)%VOLUME(1:NCELL) )/VOLTOT
         ENDDO

      ENDDO

   ELSE
      RHOP => RHO
      ZZP  => ZZ
      UP   => US

      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         NCELL=CUT_CELL(ICC)%NCELL
         DO JCC=1,NCELL
            ! Get rho = sum(rho*z_alpha)
            CUT_CELL(ICC)%RHO(JCC) = SUM(CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC))

#ifdef DEBUG_CCREGION_SCALAR_TRANSPORT
            ! Check mass density for positivity
            IF ( (CUT_CELL(ICC)%RHO(JCC)<RHOMIN) .OR. (CUT_CELL(ICC)%RHO(JCC)>RHOMAX) ) THEN
               WRITE(LU_ERR,*) 'GET_RHOZZ_CCIMPREG_3D CC Corr:',ICC,JCC,CUT_CELL(ICC)%VOLUME(JCC)
               WRITE(LU_ERR,*) 'RHOP,MIN,MAX=',CUT_CELL(ICC)%RHO(JCC),RHOMIN,RHOMAX
            ENDIF
#endif

            ! Extract z from rho*z
            CUT_CELL(ICC)%ZZ(1:N_TOTAL_SCALARS,JCC) = CUT_CELL(ICC)%ZZ(1:N_TOTAL_SCALARS,JCC)/CUT_CELL(ICC)%RHO(JCC)

#ifdef DEBUG_CCREGION_SCALAR_TRANSPORT
            ! Check bounds on z:
            DO N=1,N_TOTAL_SCALARS
               IF ( (CUT_CELL(ICC)%ZZ(N,JCC)<(0._EB-GEOMEPS)) .OR. (CUT_CELL(ICC)%ZZ(N,JCC)>(1._EB+GEOMEPS)) ) THEN
                  WRITE(LU_ERR,*) 'GET_RHOZZ_CCIMPREG_3D CC Corr:',ICC,JCC,N
                  WRITE(LU_ERR,*) 'ZZP=',CUT_CELL(ICC)%ZZ(N,JCC)
               ENDIF
            ENDDO
#else
            ! Some z_alpha might be slightly below zero (bounds overrun), assign -ve mass to most abundant species:
            ! Note rho = sum(rho*z_alpha), sum(z_alpha)=1 remain unchanged.
            NMX=MAXLOC(CUT_CELL(ICC)%ZZ(1:N_TRACKED_SPECIES,JCC),DIM=1)
            DO N=1,N_TRACKED_SPECIES
               IF(N==NMX) CYCLE
               IF ( CUT_CELL(ICC)%ZZ(N,JCC) < (0._EB-TWO_EPSILON_EB)) THEN
                  CUT_CELL(ICC)%ZZ(NMX,JCC) = CUT_CELL(ICC)%ZZ(NMX,JCC) + CUT_CELL(ICC)%ZZ(N,JCC)
                  CUT_CELL(ICC)%ZZ(N,JCC)   = 0._EB
               ENDIF
            ENDDO
#endif
            ! Clip passive scalars:
            IF (N_PASSIVE_SCALARS==0) CYCLE
            CUT_CELL(ICC)%ZZ(ZETA_INDEX,JCC) = MAX(0._EB,MIN(1._EB,CUT_CELL(ICC)%ZZ(ZETA_INDEX,JCC)))
         ENDDO

         ! Dump volume average scalar mass fraction and density to Cartesian container:
         I = CUT_CELL(ICC)%IJK(IAXIS)
         J = CUT_CELL(ICC)%IJK(JAXIS)
         K = CUT_CELL(ICC)%IJK(KAXIS)
         VOLTOT = SUM( CUT_CELL(ICC)%VOLUME(1:NCELL) )
         RHOP(I,J,K) = SUM( CUT_CELL(ICC)%RHO(1:NCELL)*CUT_CELL(ICC)%VOLUME(1:NCELL) )/VOLTOT
         DO N=1,N_TOTAL_SCALARS
            ZZP(I,J,K,N) = SUM( CUT_CELL(ICC)%ZZ(N,1:NCELL)*CUT_CELL(ICC)%VOLUME(1:NCELL) )/VOLTOT
         ENDDO

      ENDDO

   ENDIF

   ! Regular Cartesian cells:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (MESHES(NM)%CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE ! Cycle Reg cells not in cc-region, cut-cells
                                                             ! underlying Cartesian cells and
                                                             ! solid cells.

            ! Get rho = sum(rho*z_alpha)
            RHOP(I,J,K) = SUM(ZZP(I,J,K,1:N_TRACKED_SPECIES))

            ! Check mass density for positivity
#ifdef DEBUG_CCREGION_SCALAR_TRANSPORT
            IF ((RHOP(I,J,K)<RHOMIN) .OR. (RHOP(I,J,K)>RHOMAX) ) THEN
               WRITE(LU_ERR,*) 'GET_RHOZZ_CCIMPREG_3D Cart:',I,J,K
               WRITE(LU_ERR,*) 'RHOP,MIN,MAX=',RHOP(I,J,K),RHOMIN,RHOMAX
            ENDIF
#endif

            ! Extract z from rho*z
            ZZP(I,J,K,1:N_TOTAL_SCALARS) = ZZP(I,J,K,1:N_TOTAL_SCALARS)/RHOP(I,J,K)

#ifdef DEBUG_CCREGION_SCALAR_TRANSPORT
            ! Check bounds on z:
            DO N=1,N_TOTAL_SCALARS
               IF (ZZP(I,J,K,N)<(0._EB-GEOMEPS) .OR. ZZP(I,J,K,N)>(1._EB+GEOMEPS)) THEN
                  WRITE(LU_ERR,*) 'GET_RHOZZ_CCIMPREG_3D Cart:',I,J,K,N
                  WRITE(LU_ERR,*) 'ZZP=',ZZP(I,J,K,N)
               ENDIF
            ENDDO
#else
            ! Some z_alpha might be slightly below zero (bounds overrun), assign -ve mass to most abundant species:
            ! Note rho = sum(rho*z_alpha), sum(z_alpha)=1 remain unchanged.
            NMX=MAXLOC(ZZP(I,J,K,1:N_TRACKED_SPECIES),DIM=1)
            DO N=1,N_TRACKED_SPECIES
               IF(N==NMX) CYCLE
               IF ( ZZP(I,J,K,N) < (0._EB-TWO_EPSILON_EB)) THEN
                  ZZP(I,J,K,NMX) = ZZP(I,J,K,NMX) + ZZP(I,J,K,N)
                  ZZP(I,J,K,N)   = 0._EB
               ENDIF
            ENDDO
#endif
            ! Clip passive scalars:
            IF (N_PASSIVE_SCALARS==0) CYCLE
            ZZP(I,J,K,ZETA_INDEX) = MAX(0._EB,MIN(1._EB,ZZP(I,J,K,ZETA_INDEX)))

         ENDDO
      ENDDO
   ENDDO

ENDDO MESH_LOOP

RETURN
END SUBROUTINE GET_RHOZZ_CCIMPREG_3D

! -------------------------------- SYMBLU_ZZ -----------------------------
#ifdef WITH_MKL

SUBROUTINE SYMBLU_ZZ

USE MPI

! Local Variables:
INTEGER :: I
! Now we invoke the MKL_CLUSTER_SPARSE_SOLVER for LU decomposition:
NRHSZ   = 1
MAXFCTZ = 1
MNUMZ   = 1

! Define CLUSTER_SPARSE_SOLVER control parameter vector iparmz:
IPARMZ(1) = 1   ! no solver default
! PARDISO:
! IPARMZ(2) = 2   ! fill-in reordering from METIS
! CLUSTER_SPARSE_SOLVER:
IPARMZ(2) = 3   ! Parallel fill-in reordering from METIS
IPARMZ(4) = 0   ! no iterative-direct algorithm
IPARMZ(5) = 0   ! no user fill-in reducing permutation
IPARMZ(6) = 0   ! =0 solution on the first n components of x
IPARMZ(8) = 2   ! numbers of iterative refinement steps
IPARMZ(10) = 13 ! perturb the pivot elements with 1E-13
IPARMZ(11) = 1  ! use nonsymmetric permutation and scaling MPS  !!!!! was 1
IPARMZ(13) = 1  ! maximum weighted matching algorithm is enabled
                !(default for non-symmetric).
IPARMZ(14) = 0  ! Output: number of perturbed pivots
IPARMZ(18) = 0  !-1 ! Output: number of nonzeros in the factor LU
IPARMZ(19) = 0  !-1 ! Output: Mflops for LU factorization
IPARMZ(20) = 0  ! Output: Numbers of CG Iterations

IPARMZ(40) = 2  ! Matrix, solution and rhs provided in distributed assembled matrix input format.

! Here each process defines de beginning and end rows in global numeration, for the equations
! it has assembled:
IPARMZ(41) = UNKZ_IND(NM_START) + 1
IPARMZ(42) = UNKZ_IND(NM_START) + NUNKZ_LOCAL

ERRORZ  =  0 ! initialize error flag
MSGLVLZ =  0 ! print statistical information

! Matrix type real non-symmetric:
MTYPEZ=11

! PARDISO:
! Initialize solver pointer for H matrix solves:
! DO I=1,64
!    PT_Z(I)%DUMMY = 0
! ENDDO
! Reorder and Symbolic factorization:
! PHASEZ = 11
! CALL PARDISO(PT_Z, MAXFCTZ, MNUMZ, MTYPEZ, PHASEZ, NUNKZ_TOTAL, &
!              A_Z, IA_Z, JA_Z, PERMZ, NRHSZ, IPARMZ, MSGLVLZ, F_Z, RZ_Z, ERRORZ)

! CLUSTER_SPARSE_SOLVER:
! Initialize solver pointer for H matrix solves:
DO I=1,64
   PT_Z(I)%DUMMY = 0
ENDDO
! Reorder and Symbolic factorization:
PHASEZ = 11
CALL CLUSTER_SPARSE_SOLVER (PT_Z, MAXFCTZ, MNUMZ, MTYPEZ, PHASEZ, NUNKZ_TOTAL, &
    A_Z, IA_Z, JA_Z, PERMZ, NRHSZ, IPARMZ, MSGLVLZ, F_Z, RZ_Z, MPI_COMM_WORLD, ERRORZ)
! No WITH_MKL:
! WRITE(LU_ERR,*) 'Can not solve implicitly scalar transport on cut-cell region.'
! WRITE(LU_ERR,*) 'MKL library compile flag was not defined.'
! Some error - stop flag.
RETURN

! WRITE(*,*) 'Reordering ZZ completed ... '
! IF (ERROR /= 0) THEN
!    WRITE(*,*) 'SYMBLU_ZZ Sym Factor: The following ERROR was detected: ', error
! END IF
! WRITE(*,*) 'Number of nonzeros in factors ZZ= ',IPARMZ(18)
! WRITE(*,*) 'Number of factorization MFLOPS ZZ= ',IPARMZ(19)

RETURN
END SUBROUTINE SYMBLU_ZZ

#endif /* WITH_MKL */

! --------------------------- PUT_RHOZZVECTOR_SCALAR_3D --------------------------

SUBROUTINE PUT_RHOZZVECTOR_SCALAR_3D(N)

INTEGER, INTENT(IN) :: N

! Local Variables:
INTEGER :: NM,I,J,K,IROW_LOC,ICC,JCC
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: ZZP=>NULL()

! Loop meshes:
MESH_LOOP : DO NM=1,NMESHES

   IF (PROCESS(NM)/=MYID) CYCLE

   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN
      ZZP  => ZZS ! Copy rho*z obtained for species N in the end of substep container for z.
      ! Loop Cut-cells for PREDICTOR:
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            IROW_LOC = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
            CUT_CELL(ICC)%ZZS(N,JCC) = RZ_Z(IROW_LOC)
         ENDDO
      ENDDO

   ELSE
      ZZP  => ZZ  ! Copy rho*z obtained for species N in the end of substep container for z.
      ! Loop Cut-cells for CORRECTOR:
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            IROW_LOC = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
            CUT_CELL(ICC)%ZZ(N,JCC) = RZ_Z(IROW_LOC)
         ENDDO
      ENDDO

   ENDIF

   ! Loop on Cartesian Cells:
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=1,IBAR

            IF (MESHES(NM)%CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE ! Cycle Reg cells not implicit, cut-cells
                                                             ! underlying Cartesian cells and
                                                             ! solid cells.

            ! Cut-cells are surrounded by a layer of GASPHASE cells which is
            ! also integrated implicitly.
            IROW_LOC = MESHES(NM)%CCVAR(I,J,K,IBM_UNKZ) - UNKZ_IND(NM_START)

            ZZP(I,J,K,N)   = RZ_Z(IROW_LOC)
         ENDDO
      ENDDO
   ENDDO

ENDDO MESH_LOOP


RETURN
END SUBROUTINE PUT_RHOZZVECTOR_SCALAR_3D


! --------------------------- GET_RHOZZVECTOR_SCALAR_3D --------------------------

SUBROUTINE GET_RHOZZVECTOR_SCALAR_3D(N)

INTEGER, INTENT(IN) :: N

! Local Variables:
INTEGER :: NM,I,J,K,IROW_LOC,ICC,JCC

! Initialize rho*z:
RZ_Z(:) = 0._EB
RZ_ZS(:) = 0._EB

! Loop meshes:
MESH_LOOP : DO NM=1,NMESHES

   IF (PROCESS(NM)/=MYID) CYCLE

   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN

      ! Loop on Cartesian Cells:
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (MESHES(NM)%CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE ! Cycle Reg cells not implicit, cut-cells
                                                                ! underlying Cartesian cells and
                                                                ! solid cells.

               ! Cut-cells are surrounded by a layer of GASPHASE cells which is
               ! also integrated implicitly.
               IROW_LOC = MESHES(NM)%CCVAR(I,J,K,IBM_UNKZ) - UNKZ_IND(NM_START)
               RZ_Z(IROW_LOC) = RHO(I,J,K)*ZZ(I,J,K,N) ! Known rho*zz^n
            ENDDO
         ENDDO
      ENDDO

      ! Now loop Cut-cells:
      CUTCELL_LOOP : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            IROW_LOC = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
            RZ_Z(IROW_LOC) = CUT_CELL(ICC)%RHO(JCC) * CUT_CELL(ICC)%ZZ(N,JCC) ! Known rho*zz^n
         ENDDO
      ENDDO CUTCELL_LOOP

   ELSE

      ! Loop on Cartesian Cells:
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (MESHES(NM)%CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE ! Cycle Reg cells not implicit, cut-cells
                                                                ! underlying Cartesian cells and
                                                                ! solid cells.

               ! Cut-cells are surrounded by a layer of GASPHASE cells which is
               ! also integrated implicitly.
               IROW_LOC = MESHES(NM)%CCVAR(I,J,K,IBM_UNKZ) - UNKZ_IND(NM_START)
               !RZ_Z(IROW_LOC) = 0.5_EB*(RHO(I,J,K)*ZZ(I,J,K,N)+RHOS(I,J,K)*ZZS(I,J,K,N)) ! Known rho*zz

               RZ_Z(IROW_LOC) = 0.5_EB*(MESHES(NM)%RHO_ZZN(I,J,K,N)+RHOS(I,J,K)*ZZS(I,J,K,N))
               RZ_ZS(IROW_LOC)= RHOS(I,J,K)*ZZS(I,J,K,N)

            ENDDO
         ENDDO
      ENDDO

      ! Now loop Cut-cells:
      CUTCELL_LOOP2 : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            IROW_LOC = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
            RZ_Z(IROW_LOC) = 0.5_EB*(CUT_CELL(ICC)%RHO(JCC) *CUT_CELL(ICC)%ZZ(N,JCC) + &
                                     CUT_CELL(ICC)%RHOS(JCC)*CUT_CELL(ICC)%ZZS(N,JCC))
            RZ_ZS(IROW_LOC)=CUT_CELL(ICC)%RHOS(JCC)*CUT_CELL(ICC)%ZZS(N,JCC)
         ENDDO
      ENDDO CUTCELL_LOOP2

   ENDIF

ENDDO MESH_LOOP


RETURN
END SUBROUTINE GET_RHOZZVECTOR_SCALAR_3D

! ------------------------------- SET_EXIMADVFLX_3D ------------------------------

SUBROUTINE SET_EXIMADVFLX_3D(NM,UU,VV,WW)

INTEGER, INTENT(IN) :: NM
REAL(EB), POINTER, DIMENSION(:,:,:) :: UU,VV,WW

! Local Variables:
INTEGER :: N,I,J,K,X1AXIS,IEXIM

! Loop on scalars:
SPECIES_LOOP : DO N=1,N_TOTAL_SCALARS

   DO IEXIM=1,MESHES(NM)%IBM_NEXIMFACE_MESH

      I      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(IAXIS)
      J      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(JAXIS)
      K      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(KAXIS+1)

      ! Load Advective flux in EXIM boundary face container:
      MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FLX(HIGH_IND,N) = 0._EB
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FLX(HIGH_IND,N) = FX(I,J,K,N)*UU(I,J,K)*R(I)
      CASE(JAXIS)
         MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FLX(HIGH_IND,N) = FY(I,J,K,N)*VV(I,J,K)
      CASE(KAXIS)
         MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FLX(HIGH_IND,N) = FZ(I,J,K,N)*WW(I,J,K)
      END SELECT

   ENDDO
ENDDO SPECIES_LOOP

RETURN
END SUBROUTINE SET_EXIMADVFLX_3D

! ----------------------------- SET_EXIMRHOZZLIM_3D -----------------------------

SUBROUTINE SET_EXIMRHOZZLIM_3D(NM,N)

! Get flux limited \bar{rho Za} computed on divg.f90 in EXIM boundary faces.

INTEGER, INTENT(IN) :: NM, N

! Local Variables:
INTEGER :: I,J,K,X1AXIS,IEXIM
REAL(EB), POINTER, DIMENSION(:,:,:) :: FX_ZZ=>NULL(),FY_ZZ=>NULL(),FZ_ZZ=>NULL()
INTEGER :: IW
TYPE(WALL_TYPE), POINTER :: WC=>NULL()

FX_ZZ=>WORK2
FY_ZZ=>WORK3
FZ_ZZ=>WORK4

DO IEXIM=1,MESHES(NM)%IBM_NEXIMFACE_MESH

   I      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(IAXIS)
   J      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(JAXIS)
   K      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(KAXIS)
   X1AXIS = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(KAXIS+1)

   ! Load Diffusive flux in EXIM boundary face container:
   MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FN_ZZ(N) = 0._EB
   IF (MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IWC > 0) THEN
      IW = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IWC
      WC=>WALL(IW)
      IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY) CYCLE
      MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FN_ZZ(N)=WC%ONE_D%RHO_F*WC%ONE_D%ZZ_F(N)
   ELSE
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FN_ZZ(N) = FX_ZZ(I,J,K)
      CASE(JAXIS)
         MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FN_ZZ(N) = FY_ZZ(I,J,K)
      CASE(KAXIS)
         MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FN_ZZ(N) = FZ_ZZ(I,J,K)
      END SELECT
   ENDIF

ENDDO


RETURN
END SUBROUTINE SET_EXIMRHOZZLIM_3D

! ----------------------------- SET_EXIMRHOHSLIM_3D -----------------------------

SUBROUTINE SET_EXIMRHOHSLIM_3D(NM)

! Get flux limited \bar{rho hs} computed on divg.f90 in EXIM boundary faces.

USE PHYSICAL_FUNCTIONS, ONLY: GET_SENSIBLE_ENTHALPY

INTEGER, INTENT(IN) :: NM

! Local Variables:
INTEGER :: I,J,K,X1AXIS,IEXIM
REAL(EB), POINTER, DIMENSION(:,:,:) :: FX_H_S=>NULL(),FY_H_S=>NULL(),FZ_H_S=>NULL()
REAL(EB) :: H_S,ZZ_GET(1:N_TRACKED_SPECIES),TMP_F_GAS,VELC2
INTEGER :: IW
TYPE(WALL_TYPE), POINTER :: WC=>NULL()

FX_H_S=>WORK2
FY_H_S=>WORK3
FZ_H_S=>WORK4

DO IEXIM=1,MESHES(NM)%IBM_NEXIMFACE_MESH

   I      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(IAXIS)
   J      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(JAXIS)
   K      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(KAXIS)
   X1AXIS = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(KAXIS+1)

   ! Load Diffusive flux in EXIM boundary face container:
   MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FN_H_S = 0._EB
   IF (MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IWC > 0) THEN
      IW = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IWC
      WC=>WALL(IW)
      IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY) CYCLE
      IF (PREDICTOR) THEN
         VELC2 = WC%ONE_D%UWS
      ELSE
         VELC2 = WC%ONE_D%UW
      ENDIF
      IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY .AND. VELC2>0._EB) THEN
         TMP_F_GAS = WC%ONE_D%TMP_G
      ELSE
         TMP_F_GAS = WC%ONE_D%TMP_F
      ENDIF
      ZZ_GET(1:N_TRACKED_SPECIES) = WC%ONE_D%ZZ_F(1:N_TRACKED_SPECIES)
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET,H_S,TMP_F_GAS)
      MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FN_H_S = WC%ONE_D%RHO_F*H_S ! bar{rho*hs}
   ELSE
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FN_H_S = FX_H_S(I,J,K)
      CASE(JAXIS)
         MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FN_H_S = FY_H_S(I,J,K)
      CASE(KAXIS)
         MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FN_H_S = FZ_H_S(I,J,K)
      END SELECT
   ENDIF

ENDDO

RETURN
END SUBROUTINE SET_EXIMRHOHSLIM_3D

! ------------------------------ SET_EXIMDIFFLX_3D ------------------------------

SUBROUTINE SET_EXIMDIFFLX_3D(NM,RHO_D_DZDX,RHO_D_DZDY,RHO_D_DZDZ)

INTEGER, INTENT(IN) :: NM
REAL(EB), INTENT(IN), POINTER, DIMENSION(:,:,:,:) :: RHO_D_DZDX,RHO_D_DZDY,RHO_D_DZDZ

! Local Variables:
INTEGER :: N,I,J,K,X1AXIS,IEXIM

! First, set all diffusive fluxes to zero on IBM_SOLID faces:
! IAXIS:
X1AXIS = IAXIS
DO K=1,MESHES(NM)%KBAR
   DO J=1,MESHES(NM)%JBAR
      DO I=0,MESHES(NM)%IBAR
         IF (MESHES(NM)%FCVAR(I,J,K,IBM_FGSC,X1AXIS) /= IBM_SOLID ) CYCLE
         RHO_D_DZDX(I,J,K,1:N_TOTAL_SCALARS) = 0._EB
      ENDDO
   ENDDO
ENDDO
! JAXIS:
X1AXIS = JAXIS
DO K=1,MESHES(NM)%KBAR
   DO J=0,MESHES(NM)%JBAR
      DO I=1,MESHES(NM)%IBAR
         IF (MESHES(NM)%FCVAR(I,J,K,IBM_FGSC,X1AXIS) /= IBM_SOLID ) CYCLE
         RHO_D_DZDY(I,J,K,1:N_TOTAL_SCALARS) = 0._EB
      ENDDO
   ENDDO
ENDDO
! KAXIS:
X1AXIS = KAXIS
DO K=0,MESHES(NM)%KBAR
   DO J=1,MESHES(NM)%JBAR
      DO I=1,MESHES(NM)%IBAR
         IF (MESHES(NM)%FCVAR(I,J,K,IBM_FGSC,X1AXIS) /= IBM_SOLID ) CYCLE
         RHO_D_DZDZ(I,J,K,1:N_TOTAL_SCALARS) = 0._EB
      ENDDO
   ENDDO
ENDDO

! Loop on scalars:
SPECIES_LOOP : DO N=1,N_TOTAL_SCALARS

   DO IEXIM=1,MESHES(NM)%IBM_NEXIMFACE_MESH

      I      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(IAXIS)
      J      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(JAXIS)
      K      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(KAXIS+1)

      ! Load Diffusive flux in EXIM boundary face container:
      MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FLX(LOW_IND,N) = 0._EB
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FLX(LOW_IND,N) = RHO_D_DZDX(I,J,K,N)
      CASE(JAXIS)
         MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FLX(LOW_IND,N) = RHO_D_DZDY(I,J,K,N)
      CASE(KAXIS)
         MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FLX(LOW_IND,N) = RHO_D_DZDZ(I,J,K,N)
      END SELECT

   ENDDO
ENDDO SPECIES_LOOP

RETURN
END SUBROUTINE SET_EXIMDIFFLX_3D

! -------------------------- GET_EXIMVECTOR_SCALAR_3D ---------------------------

SUBROUTINE GET_EXIMVECTOR_SCALAR_3D(N)

INTEGER, INTENT(IN) :: N

! Local Variables:
INTEGER :: NM,IEXIM,I,J,K,X1AXIS,LHFACE,IROW_LOC
REAL(EB):: FCT,AF,FLX

! Diffusive Fluxes for species N have been copied to IBM_EXIM_FACE%FLX(LOW_IND,N) containers
! in routine DIVERGENCE_PART_1 of the previous time step.
! Advective fluxes for species N have been copied to IBM_EXIM_FACE%FLX(HIGH_IND,N) containers
! in routine DENSITY
MESH_LOOP : DO NM=1,NMESHES

   IF (PROCESS(NM)/=MYID) CYCLE

   IF (DO_IMPLICIT_CCREGION) THEN

      DO IEXIM=1,MESHES(NM)%IBM_NEXIMFACE_MESH
         I      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(IAXIS)
         J      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(JAXIS)
         K      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(KAXIS)
         X1AXIS = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(KAXIS+1)
         LHFACE = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%LHFACE
         FCT = REAL(2*LHFACE-3,EB) ! fct = 1, if lhface is HIGH for the cell, -1 if LOW.
         IROW_LOC = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%UNKZ - UNKZ_IND(NM_START)
         AF =   MESHES(NM)%IBM_EXIM_FACE(IEXIM)%AREA
         FLX= - MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FLX(LOW_IND,N) + & ! Diffusive with (-) sign.
                MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FLX(HIGH_IND,N)
         F_Z(IROW_LOC) = F_Z(IROW_LOC) + FCT*FLX*AF
      ENDDO

   ELSE

    DO IEXIM=1,MESHES(NM)%IBM_NEXIMFACE_MESH
       I      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(IAXIS)
       J      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(JAXIS)
       K      = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(KAXIS)
       X1AXIS = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(KAXIS+1)
       LHFACE = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%LHFACE
       FCT = REAL(2*LHFACE-3,EB) ! fct = 1, if lhface is HIGH for the cell, -1 if LOW.
       IROW_LOC = MESHES(NM)%IBM_EXIM_FACE(IEXIM)%UNKZ - UNKZ_IND(NM_START)
       AF =   MESHES(NM)%IBM_EXIM_FACE(IEXIM)%AREA
       FLX= MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FLX(HIGH_IND,N) ! Diffusive fluxes have been counted on DEL_RHO_D_DELZ.
       F_Z(IROW_LOC) = F_Z(IROW_LOC) + FCT*FLX*AF
    ENDDO

   ENDIF

ENDDO MESH_LOOP

RETURN
END SUBROUTINE GET_EXIMVECTOR_SCALAR_3D

! -------------------- GET_ADV_TRANSPIRATIONVECTOR_SCALAR_3D --------------------

SUBROUTINE GET_ADV_TRANSPIRATIONVECTOR_SCALAR_3D(N)

INTEGER, INTENT(IN) :: N

! Local Variables:
INTEGER :: NM,I,J,K,ICC,JCC,ICF,ICF2,IFC,IFACE,NFACE,IROW_LOC
REAL(EB):: AREAI

! Loop meshes:
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN

      ! First Cycle over cut-cell underlying Cartesian cells:
      ICC_LOOP : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH

         I      = CUT_CELL(ICC)%IJK(IAXIS)
         J      = CUT_CELL(ICC)%IJK(JAXIS)
         K      = CUT_CELL(ICC)%IJK(KAXIS)

         ! Now Define total area of INBOUNDARY cut-faces:
         ICF=CCVAR(I,J,K,IBM_IDCF);
         IF (ICF <= 0) CYCLE
         NFACE = CUT_FACE(ICF)%NFACE
         DO JCC =1,CUT_CELL(ICC)%NCELL
            IROW_LOC = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
            IFC_LOOP : DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)

               IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)

               IF (CUT_CELL(ICC)%FACE_LIST(1,IFACE) == IBM_FTYPE_CFINB) THEN
                  ICF2   = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
                  IFACE  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
                  IF ( ICF2 /= ICF ) WRITE(LU_ERR,*) "INBOUND CF obtained from CUT_CELL doesn't match."

                  AREAI = CUT_FACE(ICF)%AREA(IFACE)

                  ! IF (DO_IMPLICIT_CCREGION) THEN
                  ! JCOL=JM_MAT_Z(IROW_LOC)
                  ! D_MAT_Z(JCOL,IROW_LOC) = D_MAT_Z(JCOL,IROW_LOC) + AREAI*CUT_FACE(ICF)%VEL(IFACE) !/AREATOT*FSCU
                  ! ELSE
                  F_Z(IROW_LOC) = F_Z(IROW_LOC) + AREAI*CUT_FACE(ICF)%VEL(IFACE) * & !/AREATOT*FSCU * &
                                  CUT_CELL(ICC)%RHO(JCC)*CUT_CELL(ICC)%ZZ(N,JCC)
                  ! ENDIF


               ENDIF

            ENDDO IFC_LOOP
         ENDDO
      ENDDO ICC_LOOP

   ELSE ! Corrector

      ! First Cycle over cut-cell underlying Cartesian cells:
      ICC_LOOP2 : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH

         I      = CUT_CELL(ICC)%IJK(IAXIS)
         J      = CUT_CELL(ICC)%IJK(JAXIS)
         K      = CUT_CELL(ICC)%IJK(KAXIS)

         ! Now Define total area of INBOUNDARY cut-faces:
         ICF=CCVAR(I,J,K,IBM_IDCF);
         IF (ICF <= 0) CYCLE
         NFACE = CUT_FACE(ICF)%NFACE
         DO JCC =1,CUT_CELL(ICC)%NCELL
            IROW_LOC = CUT_CELL(ICC)%UNKZ(JCC) - UNKZ_IND(NM_START)
            IFC_LOOP2 : DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)

               IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)

               IF (CUT_CELL(ICC)%FACE_LIST(1,IFACE) == IBM_FTYPE_CFINB) THEN
                  ICF2   = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
                  IFACE  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
                  IF ( ICF2 /= ICF ) WRITE(LU_ERR,*) "INBOUND CF obtained from CUT_CELL doesn't match."

                  AREAI = CUT_FACE(ICF)%AREA(IFACE)

                  ! IF (DO_IMPLICIT_CCREGION) THEN
                  ! JCOL=JM_MAT_Z(IROW_LOC)
                  ! D_MAT_Z(JCOL,IROW_LOC) = D_MAT_Z(JCOL,IROW_LOC) + AREAI*CUT_FACE(ICF)%VELS(IFACE) !/AREATOT*FSCU
                  ! ELSE
                  F_Z(IROW_LOC) = F_Z(IROW_LOC) + AREAI*CUT_FACE(ICF)%VELS(IFACE) * & !/AREATOT*FSCU * &
                                  CUT_CELL(ICC)%RHOS(JCC)*CUT_CELL(ICC)%ZZS(N,JCC)
                  ! ENDIF

               ENDIF

            ENDDO IFC_LOOP2
         ENDDO
      ENDDO ICC_LOOP2

   ENDIF ! PREDICTOR

ENDDO MESH_LOOP

RETURN
END SUBROUTINE GET_ADV_TRANSPIRATIONVECTOR_SCALAR_3D

! ------------------------- GET_ADVDIFFVECTOR_SCALAR_3D -------------------------

SUBROUTINE GET_ADVDIFFVECTOR_SCALAR_3D(N)

INTEGER, INTENT(IN) :: N

! Local Variables:
INTEGER :: NM,I,J,K
REAL(EB):: PRFCT
INTEGER :: X1AXIS,IFACE,IND(LOW_IND:HIGH_IND),IND_LOC(LOW_IND:HIGH_IND),ICF
INTEGER :: LOCROW_1,LOCROW_2,ILOC,IROW,ICC,JCC,ISIDE,IW
REAL(EB):: AF,KFACE(2,2),F_LOC(2),CIJP,CIJM,VELC,ALPHAP1,AM_P1,AP_P1
REAL(EB), POINTER, DIMENSION(:,:,:)  :: RHOP=>NULL(),UP=>NULL(),VP=>NULL(),WP=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:,:)::  ZZP=>NULL()
TYPE(WALL_TYPE), POINTER :: WC=>NULL()

! This routine computes RHS due to boundary conditions prescribed in immersed solids
! and domain boundaries.

! First Domain Boundaries:
! Mesh Loop, Advective Fluxes:
MESH_LOOP_DBND : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN
      ZZP  => ZZ
      RHOP => RHO
      UP   => U
      VP   => V
      WP   => W
      PRFCT= 1._EB
   ELSE
      ZZP  => ZZS
      RHOP => RHOS
      UP   => US
      VP   => VS
      WP   => WS
      PRFCT= 0._EB
   ENDIF

   ! X direction bounds:
   ILO_FACE = 0                    ! Low mesh boundary face index.
   IHI_FACE = IBAR                 ! High mesh boundary face index.

   ! Y direction bounds:
   JLO_FACE = 0                    ! Low mesh boundary face index.
   JHI_FACE = JBAR                 ! High mesh boundary face index.

   ! Z direction bounds:
   KLO_FACE = 0                    ! Low mesh boundary face index.
   KHI_FACE = KBAR                 ! High mesh boundary face index.

   ! First add advective fluxes to domain boundary regular and cut-cells:
   ! Boundary IAXIS faces:
   X1AXIS = IAXIS
   DO IFACE=1,MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)

      IW=MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IWC
      WC=>WALL(IW)
      IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE

      I  = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I+FCELL-1,J,K,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I+FCELL  ,J,K,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Face area and Velocity u:
      AF = DY(J)*DZ(K)
      VELC = UP(I,J,K)

      ! Matrix coefficients, Next to domain boundary always Godunov:
      ALPHAP1 = SIGN( 1._EB, VELC)
      AM_P1 = 0.5_EB*(1._EB+ALPHAP1)
      AP_P1 = 0.5_EB*(1._EB-ALPHAP1)
      CIJM = AM_P1*VELC*AF
      CIJP = AP_P1*VELC*AF

      ! Now add to A corresponding advection coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = CIJM; KFACE(2,1) =-CIJM; KFACE(1,2) = CIJP; KFACE(2,2) =-CIJP

      ! Row ind(1),ind(2), and F_LOC:
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( I == ILO_FACE ) THEN
         LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
         F_LOC(1) = WC%ONE_D%RHO_F*WC%ONE_D%ZZ_F(N) ! For low side use Wall values defined in wall.f90.
         F_LOC(2) = RHOP(I+FCELL  ,J,K)*ZZP(I+FCELL  ,J,K,N)
      ENDIF
      IF ( I == IHI_FACE ) THEN
         LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         F_LOC(1) = RHOP(I+FCELL-1,J,K)*ZZP(I+FCELL-1,J,K,N)
         F_LOC(2) = WC%ONE_D%RHO_F*WC%ONE_D%ZZ_F(N) ! For high side use Wall values defined in wall.f90.
      ENDIF
      DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
         IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
         F_Z(IROW) = F_Z(IROW) + KFACE(ILOC,1)*F_LOC(1) + KFACE(ILOC,2)*F_LOC(2)
      ENDDO

   ENDDO

   ! Boundary JAXIS faces:
   X1AXIS = JAXIS
   DO IFACE=1,MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)

      IW=MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IWC
      WC=>WALL(IW)
      IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE

      I  = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I,J+FCELL-1,K,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I,J+FCELL  ,K,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Face area and Velocity v:
      AF = DX(I)*DZ(K)
      VELC = VP(I,J,K)

      ! Matrix coefficients, Next to domain boundary always Godunov:
      ALPHAP1 = SIGN( 1._EB, VELC)
      AM_P1 = 0.5_EB*(1._EB+ALPHAP1)
      AP_P1 = 0.5_EB*(1._EB-ALPHAP1)
      CIJM = AM_P1*VELC*AF
      CIJP = AP_P1*VELC*AF

      ! Now add to A corresponding advection and diffusion coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = CIJM; KFACE(2,1) =-CIJM; KFACE(1,2) = CIJP; KFACE(2,2) =-CIJP

      ! Row ind(1),ind(2), and F_LOC:
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( J == JLO_FACE ) THEN
         LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
         F_LOC(1) = WC%ONE_D%RHO_F*WC%ONE_D%ZZ_F(N) ! For low side use Wall values defined in wall.f90.
         F_LOC(2) = RHOP(I,J+FCELL  ,K)*ZZP(I,J+FCELL  ,K,N)
      ENDIF
      IF ( J == JHI_FACE ) THEN
         LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         F_LOC(1) = RHOP(I,J+FCELL-1,K)*ZZP(I,J+FCELL-1,K,N)
         F_LOC(2) = WC%ONE_D%RHO_F*WC%ONE_D%ZZ_F(N) ! For high side use Wall values defined in wall.f90.
      ENDIF
      DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
         IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
         F_Z(IROW) = F_Z(IROW) + KFACE(ILOC,1)*F_LOC(1) + KFACE(ILOC,2)*F_LOC(2)
      ENDDO

   ENDDO

   ! Boundary KAXIS faces:
   X1AXIS = KAXIS
   DO IFACE=1,MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)

      IW=MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IWC
      WC=>WALL(IW)
      IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE

      I  = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I,J,K+FCELL-1,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I,J,K+FCELL  ,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Face area and Velocity w:
      AF = DX(I)*DY(J)
      VELC = WP(I,J,K)

      ! Matrix coefficients, Next to domain boundary always Godunov:
      ALPHAP1 = SIGN( 1._EB, VELC)
      AM_P1 = 0.5_EB*(1._EB+ALPHAP1)
      AP_P1 = 0.5_EB*(1._EB-ALPHAP1)
      CIJM = AM_P1*VELC*AF
      CIJP = AP_P1*VELC*AF

      ! Now add to A corresponding advection and diffusion coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = CIJM; KFACE(2,1) =-CIJM; KFACE(1,2) = CIJP; KFACE(2,2) =-CIJP

      ! Row ind(1),ind(2), and F_LOC:
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( K == KLO_FACE ) THEN
         LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
         F_LOC(1) = WC%ONE_D%RHO_F*WC%ONE_D%ZZ_F(N) ! For low side use Wall values defined in wall.f90.
         F_LOC(2) = RHOP(I,J,K+FCELL  )*ZZP(I,J,K+FCELL  ,N)
      ENDIF
      IF ( K == KHI_FACE ) THEN
         LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         F_LOC(1) = RHOP(I,J,K+FCELL-1)*ZZP(I,J,K+FCELL-1,N)
         F_LOC(2) = WC%ONE_D%RHO_F*WC%ONE_D%ZZ_F(N) ! For high side use Wall values defined in wall.f90.
      ENDIF
      DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
         IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
         F_Z(IROW) = F_Z(IROW) + KFACE(ILOC,1)*F_LOC(1) + KFACE(ILOC,2)*F_LOC(2)
      ENDDO

   ENDDO

   ! Boundary Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
   DO IFACE=1,MESHES(NM)%IBM_NBBRCFACE_Z

      IW=MESHES(NM)%IBM_RCFACE_Z(IFACE)%IWC
      WC=>WALL(IW)
      IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE

      I      = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(IAXIS)
      J      = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(JAXIS)
      K      = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(KAXIS+1)

      ! Unknowns on related cells:
      IND(LOW_IND)  = MESHES(NM)%IBM_RCFACE_Z(IFACE)%UNK(LOW_IND)
      IND(HIGH_IND) = MESHES(NM)%IBM_RCFACE_Z(IFACE)%UNK(HIGH_IND)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            AF = DY(J)*DZ(K)
            ! Advective Part: Velocity u
            VELC = UP(I,J,K)
            IF ( I == ILO_FACE ) THEN
               LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
               F_LOC(1) = WC%ONE_D%RHO_F*WC%ONE_D%ZZ_F(N) ! For low side use Wall values defined in wall.f90.
               F_LOC(2) = RHOP(I+FCELL  ,J,K)*ZZP(I+FCELL  ,J,K,N)
            ENDIF
            IF ( I == IHI_FACE ) THEN
               LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
               F_LOC(1) = RHOP(I+FCELL-1,J,K)*ZZP(I+FCELL-1,J,K,N)
               F_LOC(2) = WC%ONE_D%RHO_F*WC%ONE_D%ZZ_F(N) ! For high side use Wall values defined in wall.f90.
            ENDIF
         CASE(JAXIS)
            AF = DX(I)*DZ(K)
            ! Advective Part: Velocity v
            VELC = VP(I,J,K)
            IF ( J == JLO_FACE ) THEN
               LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
               F_LOC(1) = WC%ONE_D%RHO_F*WC%ONE_D%ZZ_F(N) ! For low side use Wall values defined in wall.f90.
               F_LOC(2) = RHOP(I,J+FCELL  ,K)*ZZP(I,J+FCELL  ,K,N)
            ENDIF
            IF ( J == JHI_FACE ) THEN
               LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
               F_LOC(1) = RHOP(I,J+FCELL-1,K)*ZZP(I,J+FCELL-1,K,N)
               F_LOC(2) = WC%ONE_D%RHO_F*WC%ONE_D%ZZ_F(N) ! For high side use Wall values defined in wall.f90.
            ENDIF
         CASE(KAXIS)
            AF = DX(I)*DY(J)
            ! Advective Part: Velocity w
            VELC = WP(I,J,K)
            IF ( K == KLO_FACE ) THEN
               LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
               F_LOC(1) = WC%ONE_D%RHO_F*WC%ONE_D%ZZ_F(N) ! For low side use Wall values defined in wall.f90.
               F_LOC(2) = RHOP(I,J,K+FCELL  )*ZZP(I,J,K+FCELL  ,N)
            ENDIF
            IF ( K == KHI_FACE ) THEN
               LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
               F_LOC(1) = RHOP(I,J,K+FCELL-1)*ZZP(I,J,K+FCELL-1,N)
               F_LOC(2) = WC%ONE_D%RHO_F*WC%ONE_D%ZZ_F(N) ! For high side use Wall values defined in wall.f90.
            ENDIF
      ENDSELECT

      ! Matrix coefficients, Next to domain boundary always Godunov:
      ALPHAP1 = SIGN( 1._EB, VELC)
      AM_P1 = 0.5_EB*(1._EB+ALPHAP1)
      AP_P1 = 0.5_EB*(1._EB-ALPHAP1)
      CIJM = AM_P1*VELC*AF
      CIJP = AP_P1*VELC*AF

      ! Now add to A corresponding advection and diffusion coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = CIJM; KFACE(2,1) =-CIJM; KFACE(1,2) = CIJP; KFACE(2,2) =-CIJP

      DO ISIDE=1,2
         IF ( MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE) == IBM_FTYPE_CFGAS ) THEN
            ! Discard if cut-cell on guard-cell region (External domain boundary):
            ICC = MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE); IF (ICC > MESHES(NM)%N_CUTCELL_MESH) CYCLE
            JCC = MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE)
            F_LOC(ISIDE) =       PRFCT *CUT_CELL(ICC)% RHO(JCC)*CUT_CELL(ICC)% ZZ(N,JCC) + &
                          (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)*CUT_CELL(ICC)%ZZS(N,JCC)
         ENDIF
      ENDDO

      DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
         IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
         F_Z(IROW) = F_Z(IROW) + KFACE(ILOC,1)*F_LOC(1) + KFACE(ILOC,2)*F_LOC(2)
      ENDDO

   ENDDO

   ! Now Boundary Gasphase CUT_FACES:
   DO ICF = 1,MESHES(NM)%N_BBCUTFACE_MESH
      IF ( MESHES(NM)%CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
      IW=MESHES(NM)%CUT_FACE(ICF)%IWC
      WC=>WALL(IW)
      IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY         .OR. &
          WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
          WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) CYCLE
      I = MESHES(NM)%CUT_FACE(ICF)%IJK(IAXIS)
      J = MESHES(NM)%CUT_FACE(ICF)%IJK(JAXIS)
      K = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS+1)
      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         CASE(JAXIS)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         CASE(KAXIS)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
      ENDSELECT

      DO IFACE=1,MESHES(NM)%CUT_FACE(ICF)%NFACE

         ! Unknowns on related cells:
         IND(LOW_IND)  = MESHES(NM)%CUT_FACE(ICF)%UNKZ(LOW_IND,IFACE)
         IND(HIGH_IND) = MESHES(NM)%CUT_FACE(ICF)%UNKZ(HIGH_IND,IFACE)

         IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
         IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

         AF = MESHES(NM)%CUT_FACE(ICF)%AREA(IFACE)

         ! Matrix coefficients for advection:
         VELC =        PRFCT *MESHES(NM)%CUT_FACE(ICF)%VEL(IFACE) + &
                (1._EB-PRFCT)*MESHES(NM)%CUT_FACE(ICF)%VELS(IFACE)

         ALPHAP1 = SIGN( 1._EB, VELC)
         AM_P1 = 0.5_EB*(1._EB+ALPHAP1)
         AP_P1 = 0.5_EB*(1._EB-ALPHAP1)
         CIJM = AM_P1*VELC*AF
         CIJP = AP_P1*VELC*AF

         ! Now add to A corresponding advection and diffusion coeffs:
         !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
         KFACE(1,1) = CIJM; KFACE(2,1) =-CIJM; KFACE(1,2) = CIJP; KFACE(2,2) =-CIJP

         F_LOC(:) = WC%ONE_D%RHO_F*WC%ONE_D%ZZ_F(N) !Initialize both sides to face BC value.
         DO ISIDE=1,2
            SELECT CASE(MESHES(NM)%CUT_FACE(ICF)%CELL_LIST(1,ISIDE,IFACE))
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ! If cut-cell on guard-cell region, skip, will use BC value.
               ICC = MESHES(NM)%CUT_FACE(ICF)%CELL_LIST(2,ISIDE,IFACE); IF(ICC>MESHES(NM)%N_CUTCELL_MESH) CYCLE
               JCC = MESHES(NM)%CUT_FACE(ICF)%CELL_LIST(3,ISIDE,IFACE)
               F_LOC(ISIDE) =       PRFCT *CUT_CELL(ICC)% RHO(JCC)*CUT_CELL(ICC)% ZZ(N,JCC) + &
                             (1._EB-PRFCT)*CUT_CELL(ICC)%RHOS(JCC)*CUT_CELL(ICC)%ZZS(N,JCC)
            CASE DEFAULT
               WRITE(0,*) 'GET_ADVDIFFVECTOR_SCALAR_3D: MESHES(NM)%CUT_FACE face not connected to CC cell',NM,IFACE
            END SELECT
        ENDDO

        DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
           IROW=IND_LOC(ILOC)     ! Process Local Unknown number.
           F_Z(IROW) = F_Z(IROW) + KFACE(ILOC,1)*F_LOC(1) + KFACE(ILOC,2)*F_LOC(2)
        ENDDO

      ENDDO

   ENDDO

   ! Advective mass fluxes through INBOUNDARY cut-faces (CFACE):
   ! TO DO.

   ! Then add diffusive fluxes through domain boundaries:
   ! Defined in CCREGION_DIVERGENCE_PART_1.

ENDDO MESH_LOOP_DBND



! Source due to nonzero velocities in SOLID-CUT CELL interface faces:
! This is only nonzero when the Poisson solve is done s.t. PRES_ON_WHOLE_DOMAIN = .TRUE. (Solver 'FFT','GLMAT IBM')
IF (PRES_ON_WHOLE_DOMAIN) CALL GET_ADV_TRANSPIRATIONVECTOR_SCALAR_3D(N) ! add to F_Z

RETURN
END SUBROUTINE GET_ADVDIFFVECTOR_SCALAR_3D


! -------------------------- CCIBM_VELOCITY_CUTFACES ----------------------------

SUBROUTINE CCIBM_VELOCITY_CUTFACES


! Local Variables:
INTEGER  :: NM,ICC,ICF,I,J,K,X1AXIS,NFACE,INDADD,INDF,JCC,IFC,IFACE,IFACE2,CFACE_IND
REAL(EB) :: AREATOT, VEL_CART, FLX_FCT, FSCU
REAL(EB), POINTER, DIMENSION(:,:,:) :: UP,VP,WP

IF (.NOT. PRES_ON_CARTESIAN) RETURN

! Mesh Loop:
MESH_LOOP : DO NM=1,NMESHES

   IF (PROCESS(NM)/=MYID) CYCLE

   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN
      UP => US ! Predictor final velocities.
      VP => VS
      WP => WS
   ELSE
      UP => U ! Corrector final velocities.
      VP => V
      WP => W
   ENDIF

   ! Cut-face Loop:
   ! For now we do area averaging to transfer flux matched velocities to cut-faces:
   ! First GASPHASE cut-faces:
   CUTFACE_LOOP : DO ICF=1,MESHES(NM)%N_CUTFACE_MESH

      IF ( CUT_FACE(ICF)%STATUS /= IBM_GASPHASE) CYCLE

      I      = CUT_FACE(ICF)%IJK(IAXIS)
      J      = CUT_FACE(ICF)%IJK(JAXIS)
      K      = CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)

      NFACE  = CUT_FACE(ICF)%NFACE

      AREATOT= SUM( CUT_FACE(ICF)%AREA(1:NFACE) )

      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         VEL_CART = UP(I,J,K)
         FLX_FCT  = DY(J)*DZ(K)/AREATOT  ! This is Area Cartesian / Sum of cut-face areas.

      CASE(JAXIS)
         VEL_CART = VP(I,J,K)
         FLX_FCT  = DX(I)*DZ(K)/AREATOT  ! This is Area Cartesian / Sum of cut-face areas.

      CASE(KAXIS)
         VEL_CART = WP(I,J,K)
         FLX_FCT  = DY(J)*DX(I)/AREATOT  ! This is Area Cartesian / Sum of cut-face areas.

      END SELECT

      IF (PREDICTOR) THEN
         ! For now assign to all cut-faces same velocity:
         CUT_FACE(ICF)%VELS(1:NFACE) = FLX_FCT*VEL_CART
      ELSE
         CUT_FACE(ICF)%VEL(1:NFACE) = FLX_FCT*VEL_CART
      ENDIF

   ENDDO CUTFACE_LOOP

   ! In case of PERIODIC_TEST = 103, there are no immersed bodies.
   IF(PERIODIC_TEST == 103 .OR. PERIODIC_TEST == 11 .OR. PERIODIC_TEST==7) CYCLE

   ! Then INBOUNDARY cut-faces:
   ! This is only required in the case the pressure solve is done on the whole domain, i.e. FFT solver.
   ! Procedure, for each cut-cell marked Cartesian cell find cell faces tagged as solid, and compute
   ! velocity flux on these. Also compute total area of cut-faces of type INBOUNDARY.
   ! Define average velocity (either in or out) and assign to each INBOUNDARY cut-face.
   PRES_ON_WHOLE_DOMAIN_IF : IF ( PRES_ON_WHOLE_DOMAIN ) THEN

       ! First Cycle over cut-cell underlying Cartesian cells:
       ICC_LOOP : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH

          I      = CUT_CELL(ICC)%IJK(IAXIS)
          J      = CUT_CELL(ICC)%IJK(JAXIS)
          K      = CUT_CELL(ICC)%IJK(KAXIS)

          FSCU = 0._EB

          ! Loop on cells neighbors and test if they are of type IBM_SOLID, if so
          ! Add to velocity flux:
          ! X faces
          DO INDADD=-1,1,2
             INDF = I - FCELL + (INDADD+1)/2
             IF( FCVAR(INDF,J,K,IBM_FGSC,IAXIS) /= IBM_SOLID) CYCLE
             FSCU = FSCU + REAL(INDADD,EB)*UP(INDF,J,K)*DY(J)*DZ(K)
          ENDDO
          ! Y faces
          DO INDADD=-1,1,2
             INDF = J - FCELL + (INDADD+1)/2
             IF( FCVAR(I,INDF,K,IBM_FGSC,JAXIS) /= IBM_SOLID ) CYCLE
             FSCU = FSCU + REAL(INDADD,EB)*VP(I,INDF,K)*DX(I)*DZ(K)
          ENDDO
          ! Z faces
          DO INDADD=-1,1,2
             INDF = K - FCELL + (INDADD+1)/2
             IF( FCVAR(I,J,INDF,IBM_FGSC,KAXIS) /= IBM_SOLID ) CYCLE
             FSCU = FSCU + REAL(INDADD,EB)*WP(I,J,INDF)*DX(I)*DY(J)
          ENDDO

          ! Now Define total area of INBOUNDARY cut-faces:
          ICF=CCVAR(I,J,K,IBM_IDCF);

          ICF_COND : IF (ICF > 0) THEN
             NFACE = CUT_FACE(ICF)%NFACE
             AREATOT = SUM ( CUT_FACE(ICF)%AREA(1:NFACE) )
             IF (PREDICTOR) THEN
                DO JCC =1,CUT_CELL(ICC)%NCELL
                   IFC_LOOP : DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
                      IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
                      IF (CUT_CELL(ICC)%FACE_LIST(1,IFACE) == IBM_FTYPE_CFINB) THEN
                         IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
                         CUT_FACE(ICF)%VELS(IFACE2) = 1._EB/AREATOT*FSCU ! +ve into the solid
                      ENDIF
                   ENDDO IFC_LOOP
                ENDDO
             ELSE ! PREDICTOR
                DO JCC =1,CUT_CELL(ICC)%NCELL
                   IFC_LOOP2 : DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
                      IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
                      IF (CUT_CELL(ICC)%FACE_LIST(1,IFACE) == IBM_FTYPE_CFINB) THEN
                         IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
                         CUT_FACE(ICF)%VEL( IFACE2) = 1._EB/AREATOT*FSCU ! +ve into the solid
                         CFACE_IND=CUT_FACE(ICF)%CFACE_INDEX( IFACE2)
                         CFACE(CFACE_IND)%VEL_ERR_NEW=CUT_FACE(ICF)%VEL( IFACE2) - 0._EB ! Assumes zero veloc of solid.
                      ENDIF
                   ENDDO IFC_LOOP2
                ENDDO
             ENDIF
          ENDIF ICF_COND

       ENDDO ICC_LOOP

   ENDIF PRES_ON_WHOLE_DOMAIN_IF

ENDDO MESH_LOOP


RETURN
END SUBROUTINE CCIBM_VELOCITY_CUTFACES


! ----------------------------- CCIBM_RHO0W_INTERP ------------------------------

SUBROUTINE CCIBM_RHO0W_INTERP

! Local Variables:
REAL(EB), POINTER, DIMENSION(:,:,:) :: WP
INTEGER :: NM, ICC, NCELL, ICELL
INTEGER :: I, II, J ,K, PTS(IAXIS:KAXIS,NOD1:NOD4), INBFC_CCCEN(1:3)
REAL(EB):: XYZ(MAX_DIM),XYZ_PP(MAX_DIM),INTCOEF(1:5),VAL(1:5),VAL_CC, VALW(1:5), VAL_CCW
INTEGER :: IPT

! This routines interpolates RHO_0 and W velocity component to cut-cell centers,
! It is used when stratification is .TRUE.

IF (.NOT. STRATIFICATION) RETURN
IF (PERIODIC_TEST == 103 .OR. PERIODIC_TEST == 11 .OR. PERIODIC_TEST==7) RETURN

IF (CC_ZEROIBM_VELO) CC_INJECT_RHO0=.TRUE.

MESH_LOOP : DO NM=1,NMESHES

   IF (PROCESS(NM)/=MYID) CYCLE

   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN
      WP => WS ! End of step velocities.
   ELSE
      WP => W
   ENDIF

   CC_INJECT_RHO0_COND : IF (CC_INJECT_RHO0) THEN

      ICC_LOOP_1 : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         NCELL  = CUT_CELL(ICC)%NCELL
         I      = CUT_CELL(ICC)%IJK(IAXIS)
         J      = CUT_CELL(ICC)%IJK(JAXIS)
         K      = CUT_CELL(ICC)%IJK(KAXIS)
         DO ICELL=1,NCELL
            ! Cell variables:
            XYZ(IAXIS:KAXIS) = CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,ICELL)
            INBFC_CCCEN(1:3) = CUT_CELL(ICC)%INBFC_CCCEN(1:3,ICELL)
            XYZ_PP(IAXIS:KAXIS)        = CUT_CELL(ICC)%XYZ_BP_CCCEN(IAXIS:KAXIS,ICELL)
            PTS(IAXIS:KAXIS,NOD1:NOD4) = CUT_CELL(ICC)%IJK_CCCEN(IAXIS:KAXIS,NOD1:NOD4,ICELL)
            INTCOEF(1:5)               = CUT_CELL(ICC)%INTCOEF_CCCEN(1:5,ICELL)

            ! Now values:
            ! First RHO_0
            VAL_CC = RHO_0(K)

            ! Second W vel interpolated to cell centers on stencil.
            CALL GET_BOUND_VEL(KAXIS,INBFC_CCCEN,XYZ_PP,VAL_CCW)

            CUT_CELL(ICC)%RHO_0(ICELL) = VAL_CC
            CUT_CELL(ICC)%WVEL(ICELL)  = VAL_CCW
         ENDDO
      ENDDO ICC_LOOP_1

   ELSE

      ICC_LOOP_2 : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         NCELL  = CUT_CELL(ICC)%NCELL
         I      = CUT_CELL(ICC)%IJK(IAXIS)
         J      = CUT_CELL(ICC)%IJK(JAXIS)
         K      = CUT_CELL(ICC)%IJK(KAXIS)
         DO ICELL=1,NCELL
            ! Cell variables:
            XYZ(IAXIS:KAXIS) = CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,ICELL)
            INBFC_CCCEN(1:3) = CUT_CELL(ICC)%INBFC_CCCEN(1:3,ICELL)
            XYZ_PP(IAXIS:KAXIS)        = CUT_CELL(ICC)%XYZ_BP_CCCEN(IAXIS:KAXIS,ICELL)
            PTS(IAXIS:KAXIS,NOD1:NOD4) = CUT_CELL(ICC)%IJK_CCCEN(IAXIS:KAXIS,NOD1:NOD4,ICELL)
            INTCOEF(1:5)               = CUT_CELL(ICC)%INTCOEF_CCCEN(1:5,ICELL)

            ! Now values:
            ! First RHO_0
            VAL(1) = RHO_0(K)

            ! Second W vel interpolated to cell centers on stencil.
            CALL GET_BOUND_VEL(KAXIS,INBFC_CCCEN,XYZ_PP,VALW(1))

            DO IPT=1,MAX_INTERP_POINTS_PLANE
               VAL(IPT+1) = CUT_CELL(ICC)%RHO_0_CCCEN( IPT+1,ICELL)
               VALW(IPT+1)= CUT_CELL(ICC)%W_CCCEN( IPT+1,ICELL)
            ENDDO

            VAL_CC    = 0._EB
            VAL_CCW   = 0._EB
            DO II=1,5
               VAL_CC = VAL_CC + INTCOEF(II)* VAL(II)
               VAL_CCW= VAL_CCW+ INTCOEF(II)*VALW(II)
            ENDDO

            CUT_CELL(ICC)%RHO_0(ICELL) = VAL_CC
            CUT_CELL(ICC)%WVEL(ICELL)  = VAL_CCW
         ENDDO
      ENDDO ICC_LOOP_2

   ENDIF CC_INJECT_RHO0_COND

   NULLIFY(WP)

ENDDO MESH_LOOP

RETURN
END SUBROUTINE CCIBM_RHO0W_INTERP

! ------------------------------- CCIBM_H_INTERP --------------------------------

SUBROUTINE CCIBM_H_INTERP

! Local Variables:
REAL(EB), POINTER, DIMENSION(:,:,:) :: UP,VP,WP,HP
INTEGER :: NM, ICC, NCELL, ICELL
INTEGER :: I, II, J ,K, PTS(IAXIS:KAXIS,NOD1:NOD4), IRCELL
REAL(EB):: XYZ(MAX_DIM),XYZ_PP(MAX_DIM),INTCOEF(1:5),VAL(1:5),VAL_CC
REAL(EB):: U_IBM, V_IBM, W_IBM

INTEGER :: IPT

! This routine interpolates H to cut cells/Cartesian cells at the end of step.
! Makes use of dH/dXn boundary condition on immersed solid surfaces.

IF (CC_ZEROIBM_VELO) CC_INTERPOLATE_H=.FALSE.

! Interpolate H in cut-cells:
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN
      HP => H
      UP => US ! End of step velocities.
      VP => VS
      WP => WS
   ELSE
      HP => HS
      UP => U ! End of step velocities.
      VP => V
      WP => W
   ENDIF

   ! Interpolate to Regular cell centers of cells with all faces being forced:
   IF (FORCE_REGC_FACE_NXT) THEN
   NRCELL_LOOP : DO IRCELL=1,MESHES(NM)%IBM_NRCELL_H

      I = MESHES(NM)%IBM_RCELL_H(IRCELL)%IJK(IAXIS)
      J = MESHES(NM)%IBM_RCELL_H(IRCELL)%IJK(JAXIS)
      K = MESHES(NM)%IBM_RCELL_H(IRCELL)%IJK(KAXIS)

      VAL_CC    = 0._EB
      IF (CC_INTERPOLATE_H) THEN
         PTS(IAXIS:KAXIS,NOD1:NOD4) = MESHES(NM)%IBM_RCELL_H(IRCELL)%IJK_CARTCEN(IAXIS:KAXIS,NOD1:NOD4)
         INTCOEF(1:5)               = MESHES(NM)%IBM_RCELL_H(IRCELL)%INTCOEF_CARTCEN(1:5)

         IF ( ABS(1._EB-INTCOEF(1)) < GEOMEPS) CYCLE ! Can't interpolate for dH/dXn = 0., H not known at Bpund pt.

         ! Now values:
         VAL(1) = 0._EB
         DO IPT=1,MAX_INTERP_POINTS_PLANE
            VAL(IPT+1) = MESHES(NM)%IBM_RCELL_H(IRCELL)%H_CARTCEN( IPT+1)
         ENDDO

         ! This method assumes HB = HCC = Hint in Fluid Plane, i.e. dH/dXn = 0.

         DO II=1,5
            VAL_CC = VAL_CC + INTCOEF(II)*VAL(II)
         ENDDO
         ! val = CB * HB + (sum(CE*Ci*HEi)), but val = HB = sum(Ci*HEi) as dH/dXn = 0.
         ! CE = 1 - CB, then val = 1._EB/(1._EB-INTCOEF(1))*VAL_CC
         VAL_CC = VAL_CC / (1._EB-INTCOEF(1))
      ENDIF

      HP(I,J,K) = VAL_CC

   ENDDO NRCELL_LOOP
   ENDIF


   ! Interpolate to cut-cells. Cut-cell loop:
   ICC_LOOP : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH

      NCELL  = CUT_CELL(ICC)%NCELL

      I      = CUT_CELL(ICC)%IJK(IAXIS)
      J      = CUT_CELL(ICC)%IJK(JAXIS)
      K      = CUT_CELL(ICC)%IJK(KAXIS)

      IF(PERIODIC_TEST == 103 .OR. PERIODIC_TEST == 11 .OR. PERIODIC_TEST==7) THEN
         IF (PREDICTOR) THEN
            CUT_CELL(ICC)%H(1:NCELL) = HP(I,J,K)
         ELSE
            CUT_CELL(ICC)%HS(1:NCELL) = HP(I,J,K)
         ENDIF
         CYCLE
      ENDIF

      VAL_CC    = 0._EB
      IF (CC_INTERPOLATE_H) THEN
         ! First Cartesian centroid:
         PTS(IAXIS:KAXIS,NOD1:NOD4) = CUT_CELL(ICC)%IJK_CARTCEN(IAXIS:KAXIS,NOD1:NOD4)
         INTCOEF(1:5)               = CUT_CELL(ICC)%INTCOEF_CARTCEN(1:5)

         IF ( ABS(1._EB-INTCOEF(1)) < GEOMEPS) CYCLE ! Can't interpolate for dH/dXn = 0., H not known at Bound pt.

         ! Now values:
         VAL(1) = 0._EB
         DO IPT=1,MAX_INTERP_POINTS_PLANE
            VAL(IPT+1) = CUT_CELL(ICC)%H_CARTCEN( IPT+1)
         ENDDO

         ! This method assumes HB = HCC = Hint in Fluid Plane, i.e. dH/dXn = 0.
         DO II=1,5
            VAL_CC = VAL_CC + INTCOEF(II)*VAL(II)
         ENDDO
         ! val = CB * HB + (sum(CE*Ci*HEi)), but val = HB = sum(Ci*HEi) as dH/dXn = 0.
         ! CE = 1 - CB, then val = 1._EB/(1._EB-INTCOEF(1))*VAL_CC
         VAL_CC = VAL_CC / (1._EB-INTCOEF(1))
      ENDIF

      HP(I,J,K) = VAL_CC

      ! Now if the Pressure equation has been solved on Cartesian cells, interpolate values of
      ! H to corresponding cut-cell centroids:
      IF (PRES_ON_CARTESIAN) THEN

         IF (CC_INTERPOLATE_H) THEN
            DO ICELL=1,NCELL
               ! Centroid location:
               XYZ(IAXIS:KAXIS) = CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,ICELL)

               PTS(IAXIS:KAXIS,NOD1:NOD4) = CUT_CELL(ICC)%IJK_CCCEN(IAXIS:KAXIS,NOD1:NOD4,ICELL)
               XYZ_PP(IAXIS:KAXIS)        = CUT_CELL(ICC)%XYZ_BP_CCCEN(IAXIS:KAXIS,ICELL)
               INTCOEF(1:5)               = CUT_CELL(ICC)%INTCOEF_CCCEN(1:5,ICELL)

               ! Now values:
               VAL(1) = 0._EB
               DO IPT=1,MAX_INTERP_POINTS_PLANE
                  VAL(IPT+1) = CUT_CELL(ICC)%H_CCCEN( IPT+1,ICELL)
               ENDDO

               VAL_CC    = 0._EB
               DO II=1,5
                  VAL_CC = VAL_CC + INTCOEF(II)*VAL(II)
               ENDDO

               IF ( ABS(1._EB-INTCOEF(1)) < GEOMEPS) CYCLE ! Can't interpolate for dH/dXn = 0., H not known at Bound pt.
                                                           ! No regular gasphase cells found for interpolation.
               VAL_CC = VAL_CC / (1._EB-INTCOEF(1)) ! dH/dxn = 0.

               IF (PREDICTOR) THEN
                  CUT_CELL(ICC)%H(ICELL) = VAL_CC
               ELSE
                  CUT_CELL(ICC)%HS(ICELL) = VAL_CC
               ENDIF

            ENDDO
         ELSE
            VAL_CC    = 0._EB
            IF (PREDICTOR) THEN
               CUT_CELL(ICC)%H(1:NCELL) = VAL_CC
            ELSE
               CUT_CELL(ICC)%HS(1:NCELL) = VAL_CC
            ENDIF
        ENDIF
      ENDIF

   ENDDO ICC_LOOP

   ! Finally set HP to zero inside immersed solids:
   !IF (.NOT.PRES_ON_WHOLE_DOMAIN) THEN
   DO K=0,KBP1
     DO J=0,JBP1
        DO I=0,IBP1
           IF (MESHES(NM)%CCVAR(I,J,K,IBM_CGSC) /= IBM_SOLID) CYCLE
           HP(I,J,K) = 0._EB
        ENDDO
     ENDDO
   ENDDO
   !ENDIF

   ! In case of .NOT. PRES_ON_WHOLE_DOMAIN set velocities on solid faces to zero:
   IF (.NOT.PRES_ON_WHOLE_DOMAIN) THEN
   ! Force U velocities in IBM_SOLID faces to zero
   U_IBM = 0._EB ! Body doesn't move.
   DO K=1,KBAR
      DO J=1,JBAR
         DO I=0,IBAR
            IF (MESHES(NM)%FCVAR(I,J,K,IBM_FGSC,IAXIS) /= IBM_SOLID ) CYCLE
            UP(I,J,K) = U_IBM
         ENDDO
      ENDDO
   ENDDO

   ! Force V velocities in IBM_SOLID faces to zero
   V_IBM = 0._EB ! Body doesn't move.
   DO K=1,KBAR
      DO J=0,JBAR
         DO I=1,IBAR
            IF (MESHES(NM)%FCVAR(I,J,K,IBM_FGSC,JAXIS) /= IBM_SOLID ) CYCLE
            VP(I,J,K) = V_IBM
         ENDDO
      ENDDO
   ENDDO

   ! Force W velocities in IBM_SOLID faces to zero
   W_IBM = 0._EB ! Body doesn't move.
   DO K=0,KBAR
      DO J=1,JBAR
         DO I=1,IBAR
            IF (MESHES(NM)%FCVAR(I,J,K,IBM_FGSC,KAXIS) /= IBM_SOLID ) CYCLE
            WP(I,J,K) = W_IBM
         ENDDO
      ENDDO
   ENDDO
   ENDIF

   NULLIFY(UP,VP,WP,HP)

ENDDO MESH_LOOP

RETURN
END SUBROUTINE CCIBM_H_INTERP


! ---------------------------- CCIBM_VELOCITY_FLUX ------------------------------

SUBROUTINE CCIBM_VELOCITY_FLUX(DT,NM)

INTEGER, INTENT(IN) :: NM
REAL(EB), INTENT(IN) :: DT


! Local Variables:
REAL(EB), POINTER, DIMENSION(:,:,:) :: UU,VV,WW,DP,RHOP,HP
REAL(EB):: U_IBM,V_IBM,W_IBM,DUUDT,DVVDT,DWWDT,VAL(1:5),DUMEB,XYZ_PP(IAXIS:KAXIS)
INTEGER :: I,J,K,ICF,IFACE,X1AXIS,NFACE,IPT,INBFC_CFCEN(1:3),INBFC_CARTCEN(1:3), IW
REAL(EB):: U_INT,V_INT,W_INT

! This is the CCIBM forcing routine for momentum eqns.

IF ( FREEZE_VELOCITY ) RETURN
IF (PERIODIC_TEST == 103 .OR. PERIODIC_TEST == 11 .OR. PERIODIC_TEST==7) RETURN

IF (PREDICTOR) THEN
   UU => U
   VV => V
   WW => W
   DP => D
   RHOP => RHOS
   HP => HS ! Previous substep H
ELSE
   UU => US
   VV => VS
   WW => WS
   DP => DS
   RHOP => RHO
   HP => H ! Previous substep H
ENDIF


IF (FORCE_GAS_FACE) THEN
   ! For mesh NM loop through CUT_FACE field and interpolate value of Un+1 approx
   ! to centroids:
   ! If PRES_ON_CARTESIAN=.FALSE. compute momentum flux forcing on cut-faces,
   ! if PRES_ON_CARTESIAN= .TRUE. average cut-face velocities to Cartesian face centroid
   ! and compute momentum flux forcing on face centroid using Cartesian discretization.
   CUTFACE_LOOP : DO ICF=1,MESHES(NM)%N_CUTFACE_MESH

      IF ( CUT_FACE(ICF)%STATUS /= IBM_GASPHASE) CYCLE
      IW = CUT_FACE(ICF)%IWC
      IF ( (IW > 0) .AND. (WALL(IW)%BOUNDARY_TYPE==SOLID_BOUNDARY   .OR. &
                           WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY    .OR. &
                           WALL(IW)%BOUNDARY_TYPE==MIRROR_BOUNDARY) ) CYCLE ! Here force Open boundaries.

      I      = CUT_FACE(ICF)%IJK(IAXIS)
      J      = CUT_FACE(ICF)%IJK(JAXIS)
      K      = CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)

      NFACE  = CUT_FACE(ICF)%NFACE

      ! Interpolate Un+1 approx to cut-face centroids:
      SELECT CASE(X1AXIS)
      CASE(IAXIS)

         IF (INTERP_TO_CARTFACE) THEN

            VAL(1:5) = 0._EB

            U_IBM = 0._EB
            IF (.NOT.CC_ZEROIBM_VELO) THEN
               ! Get UBn+1:
               INBFC_CARTCEN(1:3) = CUT_FACE(ICF)%INBFC_CARTCEN(1:3)
               XYZ_PP(IAXIS:KAXIS)= CUT_FACE(ICF)%XYZ_BP_CARTCEN(IAXIS:KAXIS)
               CALL GET_BOUND_VEL(X1AXIS,INBFC_CARTCEN,XYZ_PP,VAL(1))

               ! Loop stencil points and define Un+1 approx
               DO IPT=NOD1,NOD4
                  DUMEB = DT*(CUT_FACE(ICF)%FV_CARTCEN(IPT+1)+CUT_FACE(ICF)%DHDX1_CARTCEN(IPT+1))
                  ! Case PREDICTOR => Un+1_aprx = Un - DT*(FVXn + DH/DXn):
                  IF (PREDICTOR) VAL(IPT+1) = CUT_FACE(ICF)%VEL_CARTCEN(IPT+1) - DUMEB
                  ! Case CORRECTOR => Un+1_aprx = 1/2*(Un + Us) - DT/2*(FVXs + DH/DXs):
                  IF (CORRECTOR) VAL(IPT+1) = 0.5_EB*(CUT_FACE(ICF)%VEL_CARTCEN( IPT+1)+ &
                                                      CUT_FACE(ICF)%VELS_CARTCEN(IPT+1)) - 0.5_EB*DUMEB
               ENDDO

               ! Interpolate to Un+1 approx on the cut-face centroid:
               DO IPT=1,5
                  U_IBM = U_IBM + CUT_FACE(ICF)%INTCOEF_CARTCEN(IPT)*VAL(IPT)
               ENDDO
            ENDIF
            CUT_FACE(ICF)%VELINT_CRF = U_IBM

            ! Compute Forcing:
            IF (PREDICTOR) DUUDT = (U_IBM-U(I,J,K))/DT
            IF (CORRECTOR) DUUDT = (2._EB*U_IBM-(U(I,J,K)+US(I,J,K)))/DT
            FVX(I,J,K) = -RDXN(I)*(HP(I+1,J,K)-HP(I,J,K)) - DUUDT

         ELSE ! Flux matched value of Cartesian face velocity:

            DO IFACE=1,NFACE
               VAL(1:5) = 0._EB

               U_INT = 0._EB
               IF (.NOT.CC_ZEROIBM_VELO) THEN
                  ! Get UBn+1:
                  INBFC_CFCEN(1:3)   = CUT_FACE(ICF)%INBFC_CFCEN(1:3,IFACE)
                  XYZ_PP(IAXIS:KAXIS)= CUT_FACE(ICF)%XYZ_BP_CFCEN(IAXIS:KAXIS,IFACE)
                  CALL GET_BOUND_VEL(X1AXIS,INBFC_CFCEN,XYZ_PP,VAL(1))

                  ! Loop stencil points and define Un+1 approx
                  DO IPT=NOD1,NOD4
                     DUMEB = DT*(CUT_FACE(ICF)%FV_CFCEN(IPT+1,IFACE)+CUT_FACE(ICF)%DHDX1_CFCEN(IPT+1,IFACE))
                     ! Case PREDICTOR => Un+1_aprx = Un - DT*(FVXn + DH/DXn):
                     IF (PREDICTOR) VAL(IPT+1) = CUT_FACE(ICF)%VEL_CFCEN(IPT+1,IFACE) - DUMEB
                     ! Case CORRECTOR => Un+1_aprx = 1/2*(Un + Us) - DT/2*(FVXs + DH/DXs):
                     IF (CORRECTOR) VAL(IPT+1) = 0.5_EB*(CUT_FACE(ICF)%VEL_CFCEN( IPT+1,IFACE)+ &
                                                         CUT_FACE(ICF)%VELS_CFCEN(IPT+1,IFACE)) - 0.5_EB*DUMEB
                  ENDDO

                  ! Interpolate to Un+1 approx on the cut-face centroid:
                  DO IPT=1,5
                     U_INT = U_INT + CUT_FACE(ICF)%INTCOEF_CFCEN(IPT,IFACE)*VAL(IPT)
                  ENDDO
               ENDIF
               CUT_FACE(ICF)%VELINT(IFACE) = U_INT
#ifdef DEBUG_IBM_INTERPOLATION
               IF (ISNAN(CUT_FACE(ICF)%VELINT(IFACE))) THEN
                  WRITE(LU_ERR,*) 'VELINT CUTFACE IAXIS=',CUT_FACE(ICF)%IJK(IAXIS:KAXIS),ICF,IFACE,U_INT
                  DO IPT=1,5
                     WRITE(LU_ERR,*) IPT,CUT_FACE(ICF)%INTCOEF_CFCEN(IPT,IFACE),VAL(IPT)
                  ENDDO
                  PAUSE
               ENDIF
#endif
            ENDDO

            ! Now Momentum flux computation:
            IF (PRES_ON_CARTESIAN) THEN ! CCIBM on Cartesian cells.

               ! Flux average velocities to Cartesian face center:
               ! This assumes zero velocity of solid part of Cartesian Face - !!
               U_IBM = 0._EB
               DO IFACE=1,NFACE
                  U_IBM = U_IBM + CUT_FACE(ICF)%AREA(IFACE)* &
                                  CUT_FACE(ICF)%VELINT(IFACE)
               ENDDO
               U_IBM = U_IBM/(DY(J)*DZ(K))
               CUT_FACE(ICF)%VELINT_CRF = U_IBM

               ! Compute Forcing:
               IF (PREDICTOR) DUUDT = (U_IBM-U(I,J,K))/DT
               IF (CORRECTOR) DUUDT = (2._EB*U_IBM-(U(I,J,K)+US(I,J,K)))/DT
               FVX(I,J,K) = -RDXN(I)*(HP(I+1,J,K)-HP(I,J,K)) - DUUDT

            ELSE ! Unstructured scheme
               ! Compute Forcing on cut-face centroids:


            ENDIF
         ENDIF

      CASE(JAXIS)

         IF (INTERP_TO_CARTFACE) THEN

            VAL(1:5) = 0._EB

            V_IBM = 0._EB
            IF (.NOT.CC_ZEROIBM_VELO) THEN
               ! Get UBn+1:
               INBFC_CARTCEN(1:3) = CUT_FACE(ICF)%INBFC_CARTCEN(1:3)
               XYZ_PP(IAXIS:KAXIS)= CUT_FACE(ICF)%XYZ_BP_CARTCEN(IAXIS:KAXIS)
               CALL GET_BOUND_VEL(X1AXIS,INBFC_CARTCEN,XYZ_PP,VAL(1))

               ! Loop stencil points and define Un+1 approx
               DO IPT=NOD1,NOD4
                  DUMEB = DT*(CUT_FACE(ICF)%FV_CARTCEN(IPT+1)+CUT_FACE(ICF)%DHDX1_CARTCEN(IPT+1))
                  ! Case PREDICTOR => Un+1_aprx = Un - DT*(FVXn + DH/DXn):
                  IF (PREDICTOR) VAL(IPT+1) = CUT_FACE(ICF)%VEL_CARTCEN(IPT+1) - DUMEB
                  ! Case CORRECTOR => Un+1_aprx = 1/2*(Un + Us) - DT/2*(FVXs + DH/DXs):
                  IF (CORRECTOR) VAL(IPT+1) = 0.5_EB*(CUT_FACE(ICF)%VEL_CARTCEN( IPT+1)+ &
                                                      CUT_FACE(ICF)%VELS_CARTCEN(IPT+1)) - 0.5_EB*DUMEB
               ENDDO

               DO IPT=1,5
                  V_IBM = V_IBM + CUT_FACE(ICF)%INTCOEF_CARTCEN(IPT)*VAL(IPT)
               ENDDO
            ENDIF
            CUT_FACE(ICF)%VELINT_CRF = V_IBM

            ! Compute Forcing:
            IF (PREDICTOR) DVVDT = (V_IBM-V(I,J,K))/DT
            IF (CORRECTOR) DVVDT = (2._EB*V_IBM-(V(I,J,K)+VS(I,J,K)))/DT
            FVY(I,J,K) = -RDYN(J)*(HP(I,J+1,K)-HP(I,J,K)) - DVVDT

         ELSE ! Flux matched value of Cartesian face velocity:

            DO IFACE=1,NFACE
               VAL(1:5) = 0._EB

               V_INT = 0._EB
               IF (.NOT.CC_ZEROIBM_VELO) THEN
                  ! Get VBn+1:
                  INBFC_CFCEN(1:3)   = CUT_FACE(ICF)%INBFC_CFCEN(1:3,IFACE)
                  XYZ_PP(IAXIS:KAXIS)= CUT_FACE(ICF)%XYZ_BP_CFCEN(IAXIS:KAXIS,IFACE)
                  CALL GET_BOUND_VEL(X1AXIS,INBFC_CFCEN,XYZ_PP,VAL(1))

                  ! Loop stencil points and define Un+1 approx
                  DO IPT=NOD1,NOD4
                     DUMEB = DT*(CUT_FACE(ICF)%FV_CFCEN(IPT+1,IFACE)+CUT_FACE(ICF)%DHDX1_CFCEN(IPT+1,IFACE))
                     ! Case PREDICTOR => Un+1_aprx = Un - DT*(FVXn + DH/DXn):
                     IF (PREDICTOR) VAL(IPT+1) = CUT_FACE(ICF)%VEL_CFCEN(IPT+1,IFACE) - DUMEB
                     ! Case CORRECTOR => Un+1_aprx = 1/2*(Un + Us) - DT/2*(FVXs + DH/DXs):
                     IF (CORRECTOR) VAL(IPT+1) = 0.5_EB*(CUT_FACE(ICF)%VEL_CFCEN( IPT+1,IFACE)+ &
                                                         CUT_FACE(ICF)%VELS_CFCEN(IPT+1,IFACE)) - 0.5_EB*DUMEB
                  ENDDO

                  ! Interpolate to Vn+1 approx on the cut-face centroid:
                  DO IPT=1,5
                     V_INT = V_INT + CUT_FACE(ICF)%INTCOEF_CFCEN(IPT,IFACE)*VAL(IPT)
                  ENDDO
               ENDIF
               CUT_FACE(ICF)%VELINT(IFACE) = V_INT
#ifdef DEBUG_IBM_INTERPOLATION
               IF (ISNAN(CUT_FACE(ICF)%VELINT(IFACE))) THEN
                  WRITE(LU_ERR,*) 'VELINT CUTFACE JAXIS=',CUT_FACE(ICF)%IJK(IAXIS:KAXIS),ICF,IFACE,V_INT
                  DO IPT=1,5
                     WRITE(LU_ERR,*) IPT,CUT_FACE(ICF)%INTCOEF_CFCEN(IPT,IFACE),VAL(IPT)
                  ENDDO
                  PAUSE
               ENDIF
#endif
            ENDDO

            ! Now Momentum flux computation:
            IF (PRES_ON_CARTESIAN) THEN ! CCIBM on Cartesian cells.

               ! Flux average velocities to Cartesian face center:
               ! This assumes zero velocity of solid part of Cartesian Face - !!
               V_IBM = 0._EB
               DO IFACE=1,NFACE
                  V_IBM = V_IBM + CUT_FACE(ICF)%AREA(IFACE)*&
                                  CUT_FACE(ICF)%VELINT(IFACE)
               ENDDO
               V_IBM = V_IBM/(DX(I)*DZ(K))
               CUT_FACE(ICF)%VELINT_CRF = V_IBM

               ! Compute Forcing:
               IF (PREDICTOR) DVVDT = (V_IBM-V(I,J,K))/DT
               IF (CORRECTOR) DVVDT = (2._EB*V_IBM-(V(I,J,K)+VS(I,J,K)))/DT
               FVY(I,J,K) = -RDYN(J)*(HP(I,J+1,K)-HP(I,J,K)) - DVVDT

            ELSE ! Unstructured scheme
               ! Compute Forcing on cut-face centroids:


            ENDIF
         ENDIF

      CASE(KAXIS)

         IF (INTERP_TO_CARTFACE) THEN

            VAL(1:5) = 0._EB

            W_IBM = 0._EB
            IF (.NOT.CC_ZEROIBM_VELO) THEN
               ! Get UBn+1:
               INBFC_CARTCEN(1:3) = CUT_FACE(ICF)%INBFC_CARTCEN(1:3)
               XYZ_PP(IAXIS:KAXIS)= CUT_FACE(ICF)%XYZ_BP_CARTCEN(IAXIS:KAXIS)
               CALL GET_BOUND_VEL(X1AXIS,INBFC_CARTCEN,XYZ_PP,VAL(1))

               ! Loop stencil points and define Un+1 approx
               DO IPT=NOD1,NOD4
                  DUMEB = DT*(CUT_FACE(ICF)%FV_CARTCEN(IPT+1)+CUT_FACE(ICF)%DHDX1_CARTCEN(IPT+1))
                  ! Case PREDICTOR => Un+1_aprx = Un - DT*(FVXn + DH/DXn):
                  IF (PREDICTOR) VAL(IPT+1) = CUT_FACE(ICF)%VEL_CARTCEN(IPT+1) - DUMEB
                  ! Case CORRECTOR => Un+1_aprx = 1/2*(Un + Us) - DT/2*(FVXs + DH/DXs):
                  IF (CORRECTOR) VAL(IPT+1) = 0.5_EB*(CUT_FACE(ICF)%VEL_CARTCEN( IPT+1)+ &
                                                      CUT_FACE(ICF)%VELS_CARTCEN(IPT+1)) - 0.5_EB*DUMEB
               ENDDO

               ! Interpolate to Wn+1 approx on the cut-face centroid:
               DO IPT=1,5
                  W_IBM = W_IBM + CUT_FACE(ICF)%INTCOEF_CARTCEN(IPT)*VAL(IPT)
               ENDDO
            ENDIF
            CUT_FACE(ICF)%VELINT_CRF = W_IBM

            ! Compute Forcing:
            IF (PREDICTOR) DWWDT = (W_IBM-W(I,J,K))/DT
            IF (CORRECTOR) DWWDT = (2._EB*W_IBM-(W(I,J,K)+WS(I,J,K)))/DT
            FVZ(I,J,K) = -RDZN(K)*(HP(I,J,K+1)-HP(I,J,K)) - DWWDT

         ELSE ! Flux matched value of Cartesian face velocity:

            DO IFACE=1,NFACE
               VAL(1:5) = 0._EB

               W_INT = 0._EB
               IF (.NOT.CC_ZEROIBM_VELO) THEN
                  ! Get WBn+1:
                  INBFC_CFCEN(1:3)   = CUT_FACE(ICF)%INBFC_CFCEN(1:3,IFACE)
                  XYZ_PP(IAXIS:KAXIS)= CUT_FACE(ICF)%XYZ_BP_CFCEN(IAXIS:KAXIS,IFACE)
                  CALL GET_BOUND_VEL(X1AXIS,INBFC_CFCEN,XYZ_PP,VAL(1))

                  ! Loop stencil points and define Un+1 approx
                  DO IPT=NOD1,NOD4
                     DUMEB = DT*(CUT_FACE(ICF)%FV_CFCEN(IPT+1,IFACE)+CUT_FACE(ICF)%DHDX1_CFCEN(IPT+1,IFACE))
                     ! Case PREDICTOR => Un+1_aprx = Un - DT*(FVXn + DH/DXn):
                     IF (PREDICTOR) VAL(IPT+1) = CUT_FACE(ICF)%VEL_CFCEN(IPT+1,IFACE) - DUMEB
                     ! Case CORRECTOR => Un+1_aprx = 1/2*(Un + Us) - DT/2*(FVXs + DH/DXs):
                     IF (CORRECTOR) VAL(IPT+1) = 0.5_EB*(CUT_FACE(ICF)%VEL_CFCEN( IPT+1,IFACE)+ &
                                                         CUT_FACE(ICF)%VELS_CFCEN(IPT+1,IFACE)) - 0.5_EB*DUMEB
                  ENDDO

                  ! Interpolate to Wn+1 approx on the cut-face centroid:
                  DO IPT=1,5
                     W_INT = W_INT + CUT_FACE(ICF)%INTCOEF_CFCEN(IPT,IFACE)*VAL(IPT)
                  ENDDO
               ENDIF
               CUT_FACE(ICF)%VELINT(IFACE) = W_INT
#ifdef DEBUG_IBM_INTERPOLATION
               IF (ISNAN(CUT_FACE(ICF)%VELINT(IFACE))) THEN
                  WRITE(LU_ERR,*) 'VELINT CUTFACE KAXIS=',CUT_FACE(ICF)%IJK(IAXIS:KAXIS),ICF,IFACE,W_INT
                  DO IPT=1,5
                     WRITE(LU_ERR,*) IPT,CUT_FACE(ICF)%INTCOEF_CFCEN(IPT,IFACE),VAL(IPT)
                  ENDDO
                  PAUSE
               ENDIF
#endif
            ENDDO

            ! Now Momentum flux computation:
            IF (PRES_ON_CARTESIAN) THEN ! CCIBM on Cartesian cells.

               ! Flux average velocities to Cartesian face center:
               ! This assumes zero velocity of solid part of Cartesian Face - !!
               W_IBM = 0._EB
               DO IFACE=1,NFACE
                  W_IBM = W_IBM + CUT_FACE(ICF)%AREA(IFACE)*&
                                  CUT_FACE(ICF)%VELINT(IFACE)
               ENDDO
               W_IBM = W_IBM/(DX(I)*DY(J))
               CUT_FACE(ICF)%VELINT_CRF = W_IBM

               ! Compute Forcing:
               IF (PREDICTOR) DWWDT = (W_IBM-W(I,J,K))/DT
               IF (CORRECTOR) DWWDT = (2._EB*W_IBM-(W(I,J,K)+WS(I,J,K)))/DT
               FVZ(I,J,K) = -RDZN(K)*(HP(I,J,K+1)-HP(I,J,K)) - DWWDT

            ELSE ! Unstructured scheme
               ! Compute Forcing on cut-face centroids:


            ENDIF
         ENDIF

      END SELECT

   ENDDO CUTFACE_LOOP

   ! For mesh NM loop through REGC_FACE_VEL field, interpolate Un+1 approx to Cartesian centroids,
   ! and compute momentum flux forcing on face.
   IF (FORCE_REGC_FACE) THEN
   REGCFACE_LOOP : DO ICF=1,MESHES(NM)%IBM_NRCFACE_VEL

      IF ((ICF > MESHES(NM)%IBM_NRCFACE_VEL_CC) .AND. (.NOT.FORCE_REGC_FACE_NXT)) CYCLE

      IW = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IWC
      IF ( (IW > 0) .AND. (WALL(IW)%BOUNDARY_TYPE==SOLID_BOUNDARY   .OR. &
                           WALL(IW)%BOUNDARY_TYPE==NULL_BOUNDARY    .OR. &
                           WALL(IW)%BOUNDARY_TYPE==MIRROR_BOUNDARY  .OR. &
                           WALL(IW)%BOUNDARY_TYPE==OPEN_BOUNDARY) ) CYCLE

      I      = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK(IAXIS)
      J      = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK(JAXIS)
      K      = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK(KAXIS+1)

      VAL(1:5) = 0._EB

      ! Interpolate Un+1 approx to cut-face centroids:
      SELECT CASE(X1AXIS)
      CASE(IAXIS)

         U_INT = 0._EB
         IF (.NOT.CC_ZEROIBM_VELO) THEN
            ! Get UBn+1:
            INBFC_CARTCEN(1:3) = MESHES(NM)%IBM_RCFACE_VEL(ICF)%INBFC_CARTCEN(1:3)
            XYZ_PP(IAXIS:KAXIS)= MESHES(NM)%IBM_RCFACE_VEL(ICF)%XYZ_BP_CARTCEN(IAXIS:KAXIS)
            CALL GET_BOUND_VEL(X1AXIS,INBFC_CARTCEN,XYZ_PP,VAL(1))

            ! Loop stencil points and define Un+1 approx
            DO IPT=NOD1,NOD4
               DUMEB = DT*(MESHES(NM)%IBM_RCFACE_VEL(ICF)%FV_CARTCEN(IPT+1)+ &
                           MESHES(NM)%IBM_RCFACE_VEL(ICF)%DHDX1_CARTCEN(IPT+1))
               ! Case PREDICTOR => Un+1_aprx = Un - DT*(FVXn + DH/DXn):
               IF (PREDICTOR) VAL(IPT+1) = MESHES(NM)%IBM_RCFACE_VEL(ICF)%VEL_CARTCEN(IPT+1) - DUMEB
               ! Case CORRECTOR => Un+1_aprx = 1/2*(Un + Us) - DT/2*(FVXs + DH/DXs):
               IF (CORRECTOR) VAL(IPT+1) = 0.5_EB*(MESHES(NM)%IBM_RCFACE_VEL(ICF)%VEL_CARTCEN( IPT+1)+ &
                                                   MESHES(NM)%IBM_RCFACE_VEL(ICF)%VELS_CARTCEN(IPT+1)) - 0.5_EB*DUMEB
            ENDDO

            ! Interpolate to Un+1 approx on the cut-face centroid:
            DO IPT=1,5
               U_INT = U_INT + MESHES(NM)%IBM_RCFACE_VEL(ICF)%INTCOEF_CARTCEN(IPT)*VAL(IPT)
            ENDDO
         ENDIF
         MESHES(NM)%IBM_RCFACE_VEL(ICF)%VELINT = U_INT
#ifdef DEBUG_IBM_INTERPOLATION
         IF (ISNAN(MESHES(NM)%IBM_RCFACE_VEL(ICF)%VELINT)) THEN
            WRITE(LU_ERR,*) 'VELINT RCFACE_VEL IAXIS=',MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK(IAXIS:KAXIS),ICF,U_INT
            DO IPT=1,5
               WRITE(LU_ERR,*) IPT,MESHES(NM)%IBM_RCFACE_VEL(ICF)%INTCOEF_CARTCEN(IPT),VAL(IPT)
            ENDDO
            PAUSE
         ENDIF
#endif
         ! Compute Forcing:
         U_IBM = U_INT
         IF (PREDICTOR) DUUDT = (U_IBM-U(I,J,K))/DT
         IF (CORRECTOR) DUUDT = (2._EB*U_IBM-(U(I,J,K)+US(I,J,K)))/DT
         FVX(I,J,K) = -RDXN(I)*(HP(I+1,J,K)-HP(I,J,K)) - DUUDT

      CASE(JAXIS)

         V_INT = 0._EB
         IF (.NOT.CC_ZEROIBM_VELO) THEN
            ! Get VBn+1:
            INBFC_CARTCEN(1:3) = MESHES(NM)%IBM_RCFACE_VEL(ICF)%INBFC_CARTCEN(1:3)
            XYZ_PP(IAXIS:KAXIS)= MESHES(NM)%IBM_RCFACE_VEL(ICF)%XYZ_BP_CARTCEN(IAXIS:KAXIS)
            CALL GET_BOUND_VEL(X1AXIS,INBFC_CARTCEN,XYZ_PP,VAL(1))

            ! Loop stencil points and define Un+1 approx
            DO IPT=NOD1,NOD4
               DUMEB = DT*(MESHES(NM)%IBM_RCFACE_VEL(ICF)%FV_CARTCEN(IPT+1)+ &
                           MESHES(NM)%IBM_RCFACE_VEL(ICF)%DHDX1_CARTCEN(IPT+1))
               ! Case PREDICTOR => Un+1_aprx = Un - DT*(FVXn + DH/DXn):
               IF (PREDICTOR) VAL(IPT+1) = MESHES(NM)%IBM_RCFACE_VEL(ICF)%VEL_CARTCEN(IPT+1) - DUMEB
               ! Case CORRECTOR => Un+1_aprx = 1/2*(Un + Us) - DT/2*(FVXs + DH/DXs):
               IF (CORRECTOR) VAL(IPT+1) = 0.5_EB*(MESHES(NM)%IBM_RCFACE_VEL(ICF)%VEL_CARTCEN( IPT+1)+ &
                                                   MESHES(NM)%IBM_RCFACE_VEL(ICF)%VELS_CARTCEN(IPT+1)) - 0.5_EB*DUMEB
            ENDDO

            ! Interpolate to Vn+1 approx on the cut-face centroid:
            DO IPT=1,5
               V_INT = V_INT + MESHES(NM)%IBM_RCFACE_VEL(ICF)%INTCOEF_CARTCEN(IPT)*VAL(IPT)
            ENDDO
         ENDIF
         MESHES(NM)%IBM_RCFACE_VEL(ICF)%VELINT = V_INT
#ifdef DEBUG_IBM_INTERPOLATION
         IF (ISNAN(MESHES(NM)%IBM_RCFACE_VEL(ICF)%VELINT)) THEN
            WRITE(LU_ERR,*) 'VELINT RCFACE_VEL JAXIS=',MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK(IAXIS:KAXIS),ICF,V_INT
            DO IPT=1,5
               WRITE(LU_ERR,*) IPT,MESHES(NM)%IBM_RCFACE_VEL(ICF)%INTCOEF_CARTCEN(IPT),VAL(IPT)
            ENDDO
            PAUSE
         ENDIF
#endif
         ! Compute Forcing:
         V_IBM = V_INT
         IF (PREDICTOR) DVVDT = (V_IBM-V(I,J,K))/DT
         IF (CORRECTOR) DVVDT = (2._EB*V_IBM-(V(I,J,K)+VS(I,J,K)))/DT
         FVY(I,J,K) = -RDYN(J)*(HP(I,J+1,K)-HP(I,J,K)) - DVVDT

      CASE(KAXIS)

         W_INT = 0._EB
         IF (.NOT.CC_ZEROIBM_VELO) THEN
            ! Get WBn+1:
            INBFC_CARTCEN(1:3) = MESHES(NM)%IBM_RCFACE_VEL(ICF)%INBFC_CARTCEN(1:3)
            XYZ_PP(IAXIS:KAXIS)= MESHES(NM)%IBM_RCFACE_VEL(ICF)%XYZ_BP_CARTCEN(IAXIS:KAXIS)
            CALL GET_BOUND_VEL(X1AXIS,INBFC_CARTCEN,XYZ_PP,VAL(1))

            ! Loop stencil points and define Un+1 approx
            DO IPT=NOD1,NOD4
               DUMEB = DT*(MESHES(NM)%IBM_RCFACE_VEL(ICF)%FV_CARTCEN(IPT+1)+ &
                           MESHES(NM)%IBM_RCFACE_VEL(ICF)%DHDX1_CARTCEN(IPT+1))
               ! Case PREDICTOR => Un+1_aprx = Un - DT*(FVXn + DH/DXn):
               IF (PREDICTOR) VAL(IPT+1) = MESHES(NM)%IBM_RCFACE_VEL(ICF)%VEL_CARTCEN(IPT+1) - DUMEB
               ! Case CORRECTOR => Un+1_aprx = 1/2*(Un + Us) - DT/2*(FVXs + DH/DXs):
               IF (CORRECTOR) VAL(IPT+1) = 0.5_EB*(MESHES(NM)%IBM_RCFACE_VEL(ICF)%VEL_CARTCEN( IPT+1)+ &
                                                   MESHES(NM)%IBM_RCFACE_VEL(ICF)%VELS_CARTCEN(IPT+1)) - 0.5_EB*DUMEB
            ENDDO

            ! Interpolate to Wn+1 approx on the cut-face centroid:
            DO IPT=1,5
               W_INT = W_INT + MESHES(NM)%IBM_RCFACE_VEL(ICF)%INTCOEF_CARTCEN(IPT)*VAL(IPT)
            ENDDO
         ENDIF
         MESHES(NM)%IBM_RCFACE_VEL(ICF)%VELINT = W_INT
#ifdef DEBUG_IBM_INTERPOLATION
         IF (ISNAN(MESHES(NM)%IBM_RCFACE_VEL(ICF)%VELINT)) THEN
            WRITE(LU_ERR,*) 'VELINT RCFACE_VEL KAXIS=',PREDICTOR,MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK(IAXIS:KAXIS),ICF,W_INT
            DO IPT=1,5
               WRITE(LU_ERR,*) IPT,MESHES(NM)%IBM_RCFACE_VEL(ICF)%INTCOEF_CARTCEN(IPT),VAL(IPT),&
               MESHES(NM)%IBM_RCFACE_VEL(ICF)%DHDX1_CARTCEN(IPT),MESHES(NM)%IBM_RCFACE_VEL(ICF)%FV_CARTCEN(IPT)
            ENDDO
            PAUSE
         ENDIF
#endif
         ! Compute Forcing:
         W_IBM = W_INT
         IF (PREDICTOR) DWWDT = (W_IBM-W(I,J,K))/DT
         IF (CORRECTOR) DWWDT = (2._EB*W_IBM-(W(I,J,K)+WS(I,J,K)))/DT
         FVZ(I,J,K) = -RDZN(K)*(HP(I,J,K+1)-HP(I,J,K)) - DWWDT

      END SELECT ! X1AXIS
   ENDDO REGCFACE_LOOP
  ENDIF ! FORCE_REGC_FACE

ENDIF ! FORCE_GAS_FACE


! For Mesh NM, force solid faces:
IF (FORCE_SOLID_FACE) CALL CCIBM_NO_FLUX(DT,NM,.FALSE.)

RETURN
END SUBROUTINE CCIBM_VELOCITY_FLUX

! ------------------------------- CCIBM_NO_FLUX ---------------------------------

SUBROUTINE CCIBM_NO_FLUX(DT,NM,PRESSURE_ITERATION)

! Force to zero velocities on faces of type IBM_SOLID.

INTEGER, INTENT(IN) :: NM
REAL(EB), INTENT(IN) :: DT
LOGICAL,  INTENT(IN) :: PRESSURE_ITERATION

! Local Variables:
REAL(EB), POINTER, DIMENSION(:,:,:) :: HP
REAL(EB):: U_IBM,V_IBM,W_IBM,DUUDT,DVVDT,DWWDT
INTEGER :: I,J,K

! This is the CCIBM forcing routine for momentum eqns.

IF ( FREEZE_VELOCITY ) RETURN
IF (PERIODIC_TEST == 103 .OR. PERIODIC_TEST == 11 .OR. PERIODIC_TEST==7) RETURN

IF(PRESSURE_ITERATION) CALL POINT_TO_MESH(NM)

IF (PRESSURE_ITERATION) THEN
   IF (PREDICTOR) HP => H  ! Current substep H
   IF (CORRECTOR) HP => HS ! Current Substep H
ELSE
   IF (PREDICTOR) HP => HS ! Previous substep H
   IF (CORRECTOR) HP => H  ! Previous substep H
ENDIF

! Force U velocities in IBM_SOLID faces to zero
U_IBM = 0._EB ! Body doesn't move.
DO K=1,KBAR
   DO J=1,JBAR
      DO I=0,IBAR

         IF (MESHES(NM)%FCVAR(I,J,K,IBM_FGSC,IAXIS) == IBM_SOLID ) THEN
            IF (PREDICTOR) DUUDT = (U_IBM-U(I,J,K))/DT
            IF (CORRECTOR) DUUDT = (2._EB*U_IBM-(U(I,J,K)+US(I,J,K)))/DT
            FVX(I,J,K) = -RDXN(I)*(HP(I+1,J,K)-HP(I,J,K)) - DUUDT
            IF (.NOT. PRES_ON_WHOLE_DOMAIN) FVX(I,J,K) = - DUUDT ! This is because dH/Dx = 0 in unstructured cases
                                                                 ! and solid Cartesian faces.
         ENDIF

      ENDDO
   ENDDO
ENDDO

! Force V velocities in IBM_SOLID faces to zero
V_IBM = 0._EB ! Body doesn't move.
DO K=1,KBAR
   DO J=0,JBAR
      DO I=1,IBAR

         IF (MESHES(NM)%FCVAR(I,J,K,IBM_FGSC,JAXIS) == IBM_SOLID ) THEN
            IF (PREDICTOR) DVVDT = (V_IBM-V(I,J,K))/DT
            IF (CORRECTOR) DVVDT = (2._EB*V_IBM-(V(I,J,K)+VS(I,J,K)))/DT
            FVY(I,J,K) = -RDYN(J)*(HP(I,J+1,K)-HP(I,J,K)) - DVVDT
            IF (.NOT. PRES_ON_WHOLE_DOMAIN) FVY(I,J,K) = - DVVDT ! This is because dH/Dx = 0 in unstructured cases
                                                                 ! and solid Cartesian faces.
         ENDIF

      ENDDO
   ENDDO
ENDDO

! Force W velocities in IBM_SOLID faces to zero
W_IBM = 0._EB ! Body doesn't move.
DO K=0,KBAR
   DO J=1,JBAR
      DO I=1,IBAR

         IF (MESHES(NM)%FCVAR(I,J,K,IBM_FGSC,KAXIS) == IBM_SOLID ) THEN
            IF (PREDICTOR) DWWDT = (W_IBM-W(I,J,K))/DT
            IF (CORRECTOR) DWWDT = (2._EB*W_IBM-(W(I,J,K)+WS(I,J,K)))/DT
            FVZ(I,J,K) = -RDZN(K)*(HP(I,J,K+1)-HP(I,J,K)) - DWWDT
            IF (.NOT. PRES_ON_WHOLE_DOMAIN) FVZ(I,J,K) = - DWWDT ! This is because dH/Dx = 0 in unstructured cases
                                                                 ! and solid Cartesian faces.
         ENDIF

      ENDDO
   ENDDO
ENDDO

RETURN

END SUBROUTINE CCIBM_NO_FLUX

! ------------------------- CCIBM_COMPUTE_VELOCITY_ERROR -------------------------

SUBROUTINE CCIBM_COMPUTE_VELOCITY_ERROR(DT,NM)

! Compute velocity error on faces of type IBM_SOLID.

INTEGER, INTENT(IN) :: NM
REAL(EB), INTENT(IN) :: DT

! Local Variables:
INTEGER :: I,J,K
REAL(EB):: UN_NEW, UN_NEW_OTHER, VELOCITY_ERROR

IF (.NOT. PRES_ON_WHOLE_DOMAIN) RETURN ! No error in IBM_SOLID faces, solver used in Cartesian unstructured.

CALL POINT_TO_MESH(NM)

UN_NEW_OTHER = 0._EB ! Body doesn't move.

! Compute U velocity errors in IBM_SOLID faces:
DO K=1,KBAR
   DO J=1,JBAR
      DO I=0,IBAR
         IF (MESHES(NM)%FCVAR(I,J,K,IBM_FGSC,IAXIS) /= IBM_SOLID ) CYCLE
         IF (PREDICTOR) UN_NEW = U(I,J,K)   - DT*(FVX(I,J,K) + RDXN(I)  *(H(I+1,J,K)-H(I,J,K)))
         IF (CORRECTOR) UN_NEW = 0.5_EB*(U(I,J,K)+US(I,J,K)  - DT*(FVX(I,J,K) + RDXN(I)  *(HS(I+1,J,K)-HS(I,J,K))))
         VELOCITY_ERROR = UN_NEW - UN_NEW_OTHER
         IF (ABS(VELOCITY_ERROR)>VELOCITY_ERROR_MAX(NM)) THEN
            VELOCITY_ERROR_MAX_LOC(1,NM) = I
            VELOCITY_ERROR_MAX_LOC(2,NM) = J
            VELOCITY_ERROR_MAX_LOC(3,NM) = K
            VELOCITY_ERROR_MAX(NM)       = ABS(VELOCITY_ERROR)
         ENDIF
      ENDDO
   ENDDO
ENDDO

! Compute V velocity errors in IBM_SOLID faces:
DO K=1,KBAR
   DO J=0,JBAR
      DO I=1,IBAR
         IF (MESHES(NM)%FCVAR(I,J,K,IBM_FGSC,JAXIS) /= IBM_SOLID ) CYCLE
         IF (PREDICTOR) UN_NEW = V(I,J,K)   - DT*(FVY(I,J,K) + RDYN(J)  *(H(I,J+1,K)-H(I,J,K)))
         IF (CORRECTOR) UN_NEW = 0.5_EB*(V(I,J,K)+VS(I,J,K)  - DT*(FVY(I,J,K) + RDYN(J)  *(HS(I,J+1,K)-HS(I,J,K))))
         VELOCITY_ERROR = UN_NEW - UN_NEW_OTHER
         IF (ABS(VELOCITY_ERROR)>VELOCITY_ERROR_MAX(NM)) THEN
            VELOCITY_ERROR_MAX_LOC(1,NM) = I
            VELOCITY_ERROR_MAX_LOC(2,NM) = J
            VELOCITY_ERROR_MAX_LOC(3,NM) = K
            VELOCITY_ERROR_MAX(NM)       = ABS(VELOCITY_ERROR)
         ENDIF
      ENDDO
   ENDDO
ENDDO

! Compute W velocity errors in IBM_SOLID faces:
DO K=0,KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         IF (MESHES(NM)%FCVAR(I,J,K,IBM_FGSC,KAXIS) /= IBM_SOLID ) CYCLE
         IF (PREDICTOR) UN_NEW = W(I,J,K)   - DT*(FVZ(I,J,K) + RDZN(K)  *(H(I,J,K+1)-H(I,J,K)))
         IF (CORRECTOR) UN_NEW = 0.5_EB*(W(I,J,K)+WS(I,J,K)  - DT*(FVZ(I,J,K) + RDZN(K)  *(HS(I,J,K+1)-HS(I,J,K))))
         VELOCITY_ERROR = UN_NEW - UN_NEW_OTHER
         IF (ABS(VELOCITY_ERROR)>VELOCITY_ERROR_MAX(NM)) THEN
            VELOCITY_ERROR_MAX_LOC(1,NM) = I
            VELOCITY_ERROR_MAX_LOC(2,NM) = J
            VELOCITY_ERROR_MAX_LOC(3,NM) = K
            VELOCITY_ERROR_MAX(NM)       = ABS(VELOCITY_ERROR)
         ENDIF
      ENDDO
   ENDDO
ENDDO

RETURN
END SUBROUTINE CCIBM_COMPUTE_VELOCITY_ERROR

! ------------------------------- GET_BOUND_VEL ---------------------------------

SUBROUTINE GET_BOUND_VEL(X1AXIS,INBFC_CFCEN,XYZ_PP,VELX1)

INTEGER, INTENT(IN) :: X1AXIS,INBFC_CFCEN(1:3)
REAL(EB),INTENT(IN) :: XYZ_PP(IAXIS:KAXIS)
REAL(EB),INTENT(OUT):: VELX1

! Local Variables
REAL(EB) :: VEL_PP(MAX_DIM)
INTEGER  :: DUMMY(3)
! This routine computes boundary velocity of a boundary point on INBFC_CFCEN(1:3) INBOUNDARY cut-face
! with coordinates XYZ_PP. Will make use of velocity field defined on GEOMETRY.
! For now Set to zero:
DUMMY(1:3) = INBFC_CFCEN(1:3)
VEL_PP(IAXIS:KAXIS) = XYZ_PP(IAXIS:KAXIS) ! S.T. XYZ_PP is used and debug compilation does not throw warning.
VEL_PP(IAXIS:KAXIS) = 0._EB

VELX1 = VEL_PP(X1AXIS)

RETURN
END SUBROUTINE GET_BOUND_VEL


! -------------------------- CCIBM_CHECK_DIVERGENCE -----------------------------

SUBROUTINE CCIBM_CHECK_DIVERGENCE(T,DT,PREDVEL)

USE MPI

! This routine is to be used at the end of predictor or corrector:
REAL(EB),INTENT(IN) :: T,DT
LOGICAL, INTENT(IN) :: PREDVEL

! Local Variables:
INTEGER :: NM, I, J, K, ICC, NCELL, JCC, IFC, IFACE, LOWHIGH, ILH, X1AXIS, IFC2, IFACE2,IERR
INTEGER :: NMV(1)
REAL(EB):: PRFCT, DIV, RES, AF, VELN, DIVVOL, VOL, FCT, DPCC, DIV2

REAL(EB), POINTER, DIMENSION(:,:,:)  :: UP=>NULL(), VP=>NULL(), WP=>NULL(), DP=>NULL()
REAL(EB), ALLOCATABLE, DIMENSION(:)  :: RESMAXV, RESMAXV_AUX, RESVOLMX, RESVOLMX_AUX
REAL(EB), ALLOCATABLE, DIMENSION(:,:):: DIVMNX, DIVVOLMNX, VOLMNX, DIVMNX_AUX, DIVVOLMNX_AUX, VOLMNX_AUX
INTEGER,  ALLOCATABLE, DIMENSION(:,:):: IJKRM, IJKRM_AUX, RESICJCMX, RESICJCMX_AUX
INTEGER,  ALLOCATABLE, DIMENSION(:,:,:):: IJKMNX    , DIVVOLIJKMNX    , DIVVOLICJCMNX     ,DIVICJCMNX    ,&
                                          IJKMNX_AUX, DIVVOLIJKMNX_AUX, DIVVOLICJCMNX_AUX ,DIVICJCMNX_AUX
LOGICAL, PARAMETER :: DO_CARTESIAN = .FALSE.

! Allocate div Containers
ALLOCATE( RESMAXV(NMESHES), DIVMNX(LOW_IND:HIGH_IND,NMESHES), DIVVOLMNX(LOW_IND:HIGH_IND,NMESHES) )
ALLOCATE( IJKRM(MAX_DIM,NMESHES), IJKMNX(MAX_DIM,LOW_IND:HIGH_IND,NMESHES), &
          DIVVOLIJKMNX(MAX_DIM,LOW_IND:HIGH_IND,NMESHES),  DIVVOLICJCMNX(2,LOW_IND:HIGH_IND,1:NMESHES), &
          DIVICJCMNX(2,LOW_IND:HIGH_IND,1:NMESHES) ,  VOLMNX(LOW_IND:HIGH_IND,1:NMESHES) )
ALLOCATE( RESICJCMX(1:2,1:NMESHES), RESVOLMX(1:NMESHES) )

! Initialize div containers
RESMAXV(1:NMESHES) = 0._EB
DIVMNX(LOW_IND:HIGH_IND,1:NMESHES)    = 0._EB
DIVVOLMNX(LOW_IND:HIGH_IND,1:NMESHES) = 0._EB
IJKRM(IAXIS:KAXIS,1:NMESHES)                         = 0
IJKMNX(IAXIS:KAXIS,LOW_IND:HIGH_IND,1:NMESHES)       = 0
DIVVOLIJKMNX(IAXIS:KAXIS,LOW_IND:HIGH_IND,1:NMESHES) = 0
DIVVOLICJCMNX(1:2,LOW_IND:HIGH_IND,1:NMESHES)        = 0
DIVICJCMNX(1:2,LOW_IND:HIGH_IND,1:NMESHES)           = 0
RESICJCMX(1:2,1:NMESHES)                             = 0
VOLMNX(LOW_IND:HIGH_IND,1:NMESHES)                   = 0._EB
RESVOLMX(1:NMESHES)                                  = 0._EB

! Meshes Loop:
MESHES_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   DIVMNX(HIGH_IND,NM)     = -10000._EB
   DIVMNX(LOW_IND ,NM)     =  10000._EB
   DIVVOLMNX(HIGH_IND,NM)  = -10000._EB
   DIVVOLMNX(LOW_IND ,NM)  =  10000._EB

   CALL POINT_TO_MESH(NM)

   IF (EVACUATION_ONLY(NM)) CYCLE

   IF (PREDVEL) THEN ! Take divergence from predicted velocities
      UP => US
      VP => VS
      WP => WS
      DP => DS ! Thermodynamic divergence
      PRFCT= 1._EB
   ELSE ! Take divergence from final velocities
      UP => U
      VP => V
      WP => W
      DP => D !DDT
      PRFCT= 0._EB
   ENDIF

   IF (DO_CARTESIAN) THEN

      ! First Regular GASPHASE cells:
      DO K=1,KBAR
         DO J=1,JBAR
            LOOP1C: DO I=1,IBAR

               IF (.NOT.PRES_ON_WHOLE_DOMAIN .AND. (CCVAR(I,J,K,IBM_CGSC)==IBM_SOLID)) CYCLE

               ! 3D Cartesian divergence:
               DIV = (UP(I,J,K)-UP(I-1,J,K))*RDX(I) + &
                     (VP(I,J,K)-VP(I,J-1,K))*RDY(J) + &
                     (WP(I,J,K)-WP(I,J,K-1))*RDZ(K)

               RES = ABS(DIV-DP(I,J,K))
               IF (RES >= RESMAXV(NM)) THEN
                  RESMAXV(NM) = RES
                  IJKRM(IAXIS:KAXIS,NM)= (/ I,J,K /)
               ENDIF
               IF (DIV >= DIVMNX(HIGH_IND,NM)) THEN
                  DIVMNX(HIGH_IND,NM) = DIV
                  IJKMNX(IAXIS:KAXIS,HIGH_IND,NM) = (/ I,J,K /)
               ENDIF
               IF (DIV < DIVMNX(LOW_IND ,NM)) THEN
                  DIVMNX(LOW_IND ,NM) = DIV
                  IJKMNX(IAXIS:KAXIS,LOW_IND ,NM) = (/ I,J,K /)
               ENDIF

               DIVVOL = DIV*DX(I)*DY(J)*DZ(K)
               IF (DIVVOL >= DIVVOLMNX(HIGH_IND,NM)) THEN
                  DIVVOLMNX(HIGH_IND,NM) = DIVVOL
                  DIVVOLIJKMNX(IAXIS:KAXIS,HIGH_IND,NM) = (/ I,J,K /)
               ENDIF
               IF (DIVVOL < DIVVOLMNX(LOW_IND ,NM)) THEN
                  DIVVOLMNX(LOW_IND ,NM) = DIVVOL
                  DIVVOLIJKMNX(IAXIS:KAXIS,LOW_IND ,NM) = (/ I,J,K /)
               ENDIF

            ENDDO LOOP1C
         ENDDO
      ENDDO

   ELSE

      ! First Regular GASPHASE cells:
      DO K=1,KBAR
         DO J=1,JBAR
            LOOP1: DO I=1,IBAR

               IF( CCVAR(I,J,K,IBM_CGSC) /= IBM_GASPHASE ) CYCLE
               IF( SOLID(CELL_INDEX(I,J,K)) ) CYCLE

               ! 3D Cartesian divergence:
               DIV = (UP(I,J,K)-UP(I-1,J,K))*RDX(I) + &
                     (VP(I,J,K)-VP(I,J-1,K))*RDY(J) + &
                     (WP(I,J,K)-WP(I,J,K-1))*RDZ(K)

               RES = ABS(DIV-DP(I,J,K))
               IF (RES >= RESMAXV(NM)) THEN
                  RESMAXV(NM) = RES
                  IJKRM(IAXIS:KAXIS,NM)= (/ I,J,K /)
                  RESVOLMX(NM) = DX(I)*DY(J)*DZ(K)
               ENDIF
               IF (DIV >= DIVMNX(HIGH_IND,NM)) THEN
                  DIVMNX(HIGH_IND,NM) = DIV
                  IJKMNX(IAXIS:KAXIS,HIGH_IND,NM) = (/ I,J,K /)
                  VOLMNX(HIGH_IND,NM) = DX(I)*DY(J)*DZ(K)
               ENDIF
               IF (DIV < DIVMNX(LOW_IND ,NM)) THEN
                  DIVMNX(LOW_IND ,NM) = DIV
                  IJKMNX(IAXIS:KAXIS,LOW_IND ,NM) = (/ I,J,K /)
                  VOLMNX(LOW_IND,NM) = DX(I)*DY(J)*DZ(K)
               ENDIF

               DIVVOL = DIV*DX(I)*DY(J)*DZ(K)
               IF (DIVVOL >= DIVVOLMNX(HIGH_IND,NM)) THEN
                  DIVVOLMNX(HIGH_IND,NM) = DIVVOL
                  DIVVOLIJKMNX(IAXIS:KAXIS,HIGH_IND,NM) = (/ I,J,K /)
               ENDIF
               IF (DIVVOL < DIVVOLMNX(LOW_IND ,NM)) THEN
                  DIVVOLMNX(LOW_IND ,NM) = DIVVOL
                  DIVVOLIJKMNX(IAXIS:KAXIS,LOW_IND ,NM) = (/ I,J,K /)
               ENDIF

            ENDDO LOOP1
         ENDDO
      ENDDO

      ! Then cut-cells:
      ICC_LOOP : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH

         NCELL  = CUT_CELL(ICC)%NCELL
         I      = CUT_CELL(ICC)%IJK(IAXIS)
         J      = CUT_CELL(ICC)%IJK(JAXIS)
         K      = CUT_CELL(ICC)%IJK(KAXIS)

         DIVVOL = 0._EB
         DPCC   = 0._EB
         VOL    = 0._EB
         JCC_LOOP : DO JCC=1,NCELL

            VOL  = VOL + CUT_CELL(ICC)%VOLUME(JCC)

            IFC_LOOP3 : DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)

               IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)

               AF     = 0._EB
               VELN   = 0._EB
               SELECT CASE(CUT_CELL(ICC)%FACE_LIST(1,IFACE))
               CASE(IBM_FTYPE_RGGAS) ! REGULAR GASPHASE
                  LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
                  X1AXIS  = CUT_CELL(ICC)%FACE_LIST(3,IFACE)
                  ILH     =        LOWHIGH - 1
                  FCT     = REAL(2*LOWHIGH - 3, EB)
                  SELECT CASE(X1AXIS)
                  CASE(IAXIS)
                     AF   = DY(J)*DZ(K)
                     VELN = FCT*UP(I-FCELL+ILH,J,K)
                  CASE(JAXIS)
                     AF   = DX(I)*DZ(K)
                     VELN = FCT*VP(I,J-FCELL+ILH,K)
                  CASE(KAXIS)
                     AF   = DX(I)*DY(J)
                     VELN = FCT*WP(I,J,K-FCELL+ILH)
                  END SELECT

               CASE(IBM_FTYPE_CFGAS)
                  LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
                  FCT     = REAL(2*LOWHIGH - 3, EB)

                  IFC2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
                  IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)

                  AF      = CUT_FACE(IFC2)%AREA(IFACE2)
                  VELN    = FCT*((1._EB-PRFCT)*CUT_FACE(IFC2)%VEL( IFACE2) + &
                                        PRFCT *CUT_FACE(IFC2)%VELS(IFACE2))

               CASE(IBM_FTYPE_CFINB)
                  FCT     = 1._EB ! Normal velocity defined into the body.

                  IFC2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
                  IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)

                  AF      = CUT_FACE(IFC2)%AREA(IFACE2)
                  VELN    = FCT*((1._EB-PRFCT)*CUT_FACE(IFC2)%VEL( IFACE2) + &
                                        PRFCT *CUT_FACE(IFC2)%VELS(IFACE2))

               END SELECT

               DIVVOL = DIVVOL + AF*VELN

            ENDDO IFC_LOOP3

            ! Thermodynamic divergence * vol:
            DPCC= DPCC + (1._EB-PRFCT)*CUT_CELL(ICC)%D(JCC) + PRFCT*CUT_CELL(ICC)%DS(JCC)

         ENDDO JCC_LOOP

         DIV = DIVVOL / (DX(I)*DY(J)*DZ(K))
         RES = ABS(DIVVOL-DPCC)/(DX(I)*DY(J)*DZ(K))
         DIV2 = (UP(I,J,K)-UP(I-1,J,K))*RDX(I) + &
                (VP(I,J,K)-VP(I,J-1,K))*RDY(J) + &
                (WP(I,J,K)-WP(I,J,K-1))*RDZ(K)

         IF (RES >= RESMAXV(NM)) THEN
            RESMAXV(NM) = RES
            IJKRM(IAXIS:KAXIS,NM)= (/ I,J,K /)
            RESICJCMX(1:2,NM) = (/ ICC, NCELL /)
            RESVOLMX(NM) = VOL !CUT_CELL(ICC)%VOLUME(JCC)
         ENDIF
         IF (DIV >= DIVMNX(HIGH_IND,NM)) THEN
            DIVMNX(HIGH_IND,NM) = DIV
            IJKMNX(IAXIS:KAXIS,HIGH_IND,NM) = (/ I,J,K /)
            DIVICJCMNX(1:2,HIGH_IND,NM) = (/ ICC, NCELL /)
            VOLMNX(HIGH_IND,NM) = VOL !CUT_CELL(ICC)%VOLUME(JCC)
         ENDIF
         IF (DIV < DIVMNX(LOW_IND ,NM)) THEN
            DIVMNX(LOW_IND ,NM) = DIV
            IJKMNX(IAXIS:KAXIS,LOW_IND ,NM) = (/ I,J,K /)
            DIVICJCMNX(1:2,LOW_IND,NM) = (/ ICC, NCELL /)
            VOLMNX(LOW_IND,NM) = VOL !CUT_CELL(ICC)%VOLUME(JCC)
         ENDIF

         IF (DIVVOL >= DIVVOLMNX(HIGH_IND,NM)) THEN
            DIVVOLMNX(HIGH_IND,NM) = DIVVOL
            DIVVOLIJKMNX(IAXIS:KAXIS,HIGH_IND,NM) = (/ I,J,K /)
            DIVVOLICJCMNX(1:2,HIGH_IND,NM) = (/ ICC, NCELL/)
         ENDIF
         IF (DIVVOL < DIVVOLMNX(LOW_IND ,NM)) THEN
            DIVVOLMNX(LOW_IND ,NM) = DIVVOL
            DIVVOLIJKMNX(IAXIS:KAXIS,LOW_IND ,NM) = (/ I,J,K /)
            DIVVOLICJCMNX(1:2,LOW_IND,NM) = (/ ICC, NCELL /)
         ENDIF

      ENDDO ICC_LOOP

   ENDIF

   ! Assign max residual and divergence to corresponding location in MESHES(NM):
   RESMAX = RESMAXV(NM)
   IRM = IJKRM(IAXIS,NM)
   JRM = IJKRM(JAXIS,NM)
   KRM = IJKRM(KAXIS,NM)

   DIVMN = DIVMNX(LOW_IND ,NM)
   IMN = IJKMNX(IAXIS,LOW_IND ,NM)
   JMN = IJKMNX(JAXIS,LOW_IND ,NM)
   KMN = IJKMNX(KAXIS,LOW_IND ,NM)

   DIVMX = DIVMNX(HIGH_IND ,NM)
   IMX = IJKMNX(IAXIS,HIGH_IND ,NM)
   JMX = IJKMNX(JAXIS,HIGH_IND ,NM)
   KMX = IJKMNX(KAXIS,HIGH_IND ,NM)

ENDDO MESHES_LOOP

! Here All_Reduce SUM all mesh values:
IF (N_MPI_PROCESSES>1) THEN
   ! Allocate aux div Containers
   ALLOCATE( RESMAXV_AUX(NMESHES), DIVMNX_AUX(LOW_IND:HIGH_IND,NMESHES), DIVVOLMNX_AUX(LOW_IND:HIGH_IND,NMESHES) )
   ALLOCATE( IJKRM_AUX(MAX_DIM,NMESHES), IJKMNX_AUX(MAX_DIM,LOW_IND:HIGH_IND,NMESHES), &
             DIVVOLIJKMNX_AUX(MAX_DIM,LOW_IND:HIGH_IND,NMESHES),  DIVVOLICJCMNX_AUX(2,LOW_IND:HIGH_IND,1:NMESHES), &
             DIVICJCMNX_AUX(2,LOW_IND:HIGH_IND,1:NMESHES) ,  VOLMNX_AUX(LOW_IND:HIGH_IND,1:NMESHES) )
   ALLOCATE( RESICJCMX_AUX(1:2,1:NMESHES), RESVOLMX_AUX(1:NMESHES) )
   RESMAXV_AUX(:)           = RESMAXV(:)
   DIVMNX_AUX(:,:)          = DIVMNX(:,:)
   DIVVOLMNX_AUX(:,:)       = DIVVOLMNX(:,:)
   IJKRM_AUX(:,:)           = IJKRM(:,:)
   IJKMNX_AUX(:,:,:)        = IJKMNX(:,:,:)
   DIVVOLIJKMNX_AUX(:,:,:)  = DIVVOLIJKMNX(:,:,:)
   DIVVOLICJCMNX_AUX(:,:,:) = DIVVOLICJCMNX(:,:,:)
   DIVICJCMNX_AUX(:,:,:)    = DIVICJCMNX(:,:,:)
   VOLMNX_AUX(:,:)          = VOLMNX(:,:)
   RESICJCMX_AUX(:,:)       = RESICJCMX(:,:)
   RESVOLMX_AUX(:)          = RESVOLMX(:)

   ! Reals:
   CALL MPI_ALLREDUCE(RESMAXV_AUX(1) , RESMAXV(1) ,   NMESHES, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD, IERR)
   CALL MPI_ALLREDUCE(DIVMNX_AUX(1,1), DIVMNX(1,1), 2*NMESHES, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD, IERR)
   CALL MPI_ALLREDUCE(DIVVOLMNX_AUX(1,1), DIVVOLMNX(1,1), 2*NMESHES, MPI_DOUBLE_PRECISION, MPI_SUM, &
                      MPI_COMM_WORLD, IERR)
   CALL MPI_ALLREDUCE(VOLMNX_AUX(1,1), VOLMNX(1,1), 2*NMESHES, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD, IERR)
   CALL MPI_ALLREDUCE(RESVOLMX_AUX(1), RESVOLMX(1),   NMESHES, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD, IERR)

   ! Integers:
   CALL MPI_ALLREDUCE(IJKRM_AUX(1,1), IJKRM(1,1), MAX_DIM*NMESHES, MPI_INTEGER, MPI_SUM, MPI_COMM_WORLD, IERR)
   CALL MPI_ALLREDUCE(IJKMNX_AUX(1,1,1), IJKMNX(1,1,1), MAX_DIM*2*NMESHES, MPI_INTEGER, MPI_SUM, MPI_COMM_WORLD, IERR)
   CALL MPI_ALLREDUCE(DIVVOLIJKMNX_AUX(1,1,1), DIVVOLIJKMNX(1,1,1), MAX_DIM*2*NMESHES, MPI_INTEGER, MPI_SUM, &
                      MPI_COMM_WORLD, IERR)
   CALL MPI_ALLREDUCE(DIVVOLICJCMNX_AUX(1,1,1), DIVVOLICJCMNX(1,1,1), 2*2*NMESHES, MPI_INTEGER, MPI_SUM, &
                      MPI_COMM_WORLD, IERR)
   CALL MPI_ALLREDUCE(DIVICJCMNX_AUX(1,1,1), DIVICJCMNX(1,1,1), 2*2*NMESHES, MPI_INTEGER, MPI_SUM, MPI_COMM_WORLD, IERR)
   CALL MPI_ALLREDUCE(RESICJCMX_AUX(1,1), RESICJCMX(1,1), 2*NMESHES, MPI_INTEGER, MPI_SUM, MPI_COMM_WORLD, IERR)

   DEALLOCATE(RESMAXV_AUX, DIVMNX_AUX, DIVVOLMNX_AUX, IJKRM_AUX, IJKMNX_AUX, DIVVOLIJKMNX_AUX, DIVVOLICJCMNX_AUX, &
              DIVICJCMNX_AUX, VOLMNX_AUX, RESICJCMX_AUX, RESVOLMX_AUX)
ENDIF


IF (MYID==0) THEN
   WRITE(LU_ERR,*) ' '
   WRITE(LU_ERR,*) "N Step    =",ICYC," T, DT=",T,DT
   NMV(1)=MINLOC(DIVMNX(LOW_IND ,1:NMESHES),DIM=1)
   WRITE(LU_ERR,*) "Div Min   =",NMV(1),DIVMNX(LOW_IND ,NMV(1)),IJKMNX(IAXIS:KAXIS,LOW_IND ,NMV(1)),&
   DIVICJCMNX(1:2,LOW_IND,NMV(1)),VOLMNX(LOW_IND,NMV(1))
   NMV(1)=MAXLOC(DIVMNX(HIGH_IND ,1:NMESHES),DIM=1)
   WRITE(LU_ERR,*) "Div Max   =",NMV(1),DIVMNX(HIGH_IND,NMV(1)),IJKMNX(IAXIS:KAXIS,HIGH_IND,NMV(1)),&
   DIVICJCMNX(1:2,HIGH_IND,NMV(1)),VOLMNX(HIGH_IND,NMV(1))

   NMV(1)=MAXLOC(RESMAXV(1:NMESHES),DIM=1)
   WRITE(LU_ERR,*) "Res Max   =",NMV(1),RESMAXV(NMV(1)),IJKRM(IAXIS:KAXIS,NMV(1)),RESICJCMX(1:2,NMV(1)),RESVOLMX(NMV(1))

   NMV(1)=MINLOC(DIVVOLMNX(LOW_IND ,1:NMESHES),DIM=1)
   WRITE(LU_ERR,*) "DivVol Min=",NMV(1),DIVVOLMNX(LOW_IND ,NMV(1)),DIVVOLIJKMNX(IAXIS:KAXIS,LOW_IND ,NMV(1)),&
   DIVVOLICJCMNX(1:2,LOW_IND,NMV(1))
   NMV(1)=MAXLOC(DIVVOLMNX(HIGH_IND ,1:NMESHES),DIM=1)
   WRITE(LU_ERR,*) "DivVol Max=",NMV(1),DIVVOLMNX(HIGH_IND,NMV(1)),DIVVOLIJKMNX(IAXIS:KAXIS,HIGH_IND,NMV(1)),&
   DIVVOLICJCMNX(1:2,HIGH_IND,NMV(1))
ENDIF

! DeAllocate div Containers
DEALLOCATE( RESMAXV, DIVMNX, DIVVOLMNX )
DEALLOCATE( IJKRM, IJKMNX, DIVVOLIJKMNX, DIVVOLICJCMNX, RESVOLMX, RESICJCMX )

RETURN
END SUBROUTINE  CCIBM_CHECK_DIVERGENCE


! ----------------------------- MASS_CONSERVE_INIT ------------------------------

SUBROUTINE MASS_CONSERVE_INIT

USE MPI

! Local Variables:
INTEGER :: NM,IW,I,J,K,ICC,JCC
TYPE (WALL_TYPE), POINTER :: WC
TYPE (EXTERNAL_WALL_TYPE), POINTER :: EWC

INTEGER :: IERR

! Allocate and set FLXTINT_SPEC_MASS to zero
ALLOCATE( VOLINT_SPEC_MASS(1:N_TOTAL_SCALARS), FLXTINT_SPEC_MASS(1:N_TOTAL_SCALARS), &
          VOLINT_SPEC_MASS_0(1:N_TOTAL_SCALARS) )
FLXTINT_SPEC_MASS(1:N_TOTAL_SCALARS) = 0._EB
VOLINT_SPEC_MASS_0(1:N_TOTAL_SCALARS)= 0._EB

! Allocate and compute initial mass integrals for species:
MESH_LOOP : DO NM=1,NMESHES

   IF (PROCESS(NM)/=MYID) CYCLE
   CALL POINT_TO_MESH(NM)

   ! Allocate flux containers in EXTERNAL_WALL
   DO IW=1,N_EXTERNAL_WALL_CELLS
      WC => WALL(IW)
      IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY .OR. &
          WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) CYCLE

      EWC=>EXTERNAL_WALL(IW)

      ! Advective Fluxes:
      ALLOCATE(EWC%FVN(1:N_TOTAL_SCALARS),EWC%FVNS(1:N_TOTAL_SCALARS))
      EWC%FVN(1:N_TOTAL_SCALARS) = 0._EB
      EWC%FVNS(1:N_TOTAL_SCALARS)= 0._EB

      ! Diffusive Fluxes:
      ALLOCATE(EWC%RHO_D_DZDN(1:N_TOTAL_SCALARS),EWC%RHO_D_DZDNS(1:N_TOTAL_SCALARS))
      EWC%RHO_D_DZDN(1:N_TOTAL_SCALARS) = 0._EB
      EWC%RHO_D_DZDNS(1:N_TOTAL_SCALARS)= 0._EB

   ENDDO

   ! Compute initial mass integrals:
   ! First compute rhoZZ Volume integrals:
   CC_IBM_IF : IF (CC_IBM) THEN

      ! Now Compute, discard if solid:
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (CCVAR(I,J,K,IBM_CGSC) /= IBM_GASPHASE) CYCLE
               VOLINT_SPEC_MASS_0(1:N_TOTAL_SCALARS) = VOLINT_SPEC_MASS_0(1:N_TOTAL_SCALARS) + &
                                    DX(I)*DY(J)*DZ(K)*RHO(I,J,K)*ZZ(I,J,K,1:N_TOTAL_SCALARS)
            ENDDO
         ENDDO
      ENDDO

      ! Now do cut-cells:
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            VOLINT_SPEC_MASS_0(1:N_TOTAL_SCALARS) = VOLINT_SPEC_MASS_0(1:N_TOTAL_SCALARS) + &
            CUT_CELL(ICC)%VOLUME(JCC)*CUT_CELL(ICC)%RHO(JCC)* &
            CUT_CELL(ICC)%ZZ(1:N_TOTAL_SCALARS,JCC)
         ENDDO
      ENDDO

   ELSE ! Regular integral in the GASPHASE

      ! Now Compute, discard if solid:
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (SOLID(CELL_INDEX(I,J,K))) CYCLE
               VOLINT_SPEC_MASS_0(1:N_TOTAL_SCALARS) = VOLINT_SPEC_MASS_0(1:N_TOTAL_SCALARS) + &
                                    DX(I)*DY(J)*DZ(K)*RHO(I,J,K)*ZZ(I,J,K,1:N_TOTAL_SCALARS)
            ENDDO
         ENDDO
      ENDDO

   ENDIF CC_IBM_IF

ENDDO MESH_LOOP

VOLINT_SPEC_MASS(1:N_TOTAL_SCALARS)=VOLINT_SPEC_MASS_0(1:N_TOTAL_SCALARS)
IF(N_MPI_PROCESSES>1) THEN
   CALL MPI_ALLREDUCE(VOLINT_SPEC_MASS(1), VOLINT_SPEC_MASS_0(1), N_TOTAL_SCALARS, MPI_DOUBLE_PRECISION, &
                      MPI_SUM, MPI_COMM_WORLD, IERR)
ENDIF

RETURN
END SUBROUTINE MASS_CONSERVE_INIT

! ----------------------- CHECK_SPEC_TRANSPORT_CONSERVE -------------------------

SUBROUTINE CHECK_SPEC_TRANSPORT_CONSERVE(T,DT,DIAGNOSTICS)

USE MPI

REAL(EB), INTENT(IN) :: T,DT
LOGICAL,  INTENT(IN) :: DIAGNOSTICS

! Local Variables:
INTEGER :: NM, N, IW, I, J ,K, II, JJ, KK, IOR, ICC, JCC
TYPE (WALL_TYPE), POINTER :: WC
TYPE (EXTERNAL_WALL_TYPE), POINTER :: EWC
REAL(EB) :: DMWS(1:N_TOTAL_SCALARS),DMW(1:N_TOTAL_SCALARS)

REAL(EB) :: FLXDT_SPEC_MASS(1:N_TOTAL_SCALARS)
REAL(EB) :: VOLINT_SPEC_MASS_AUX(1:N_TOTAL_SCALARS),FLXDT_SPEC_MASS_AUX(1:N_TOTAL_SCALARS)

INTEGER :: IERR

LOGICAL, SAVE :: FIRST_CALL=.TRUE.

SELECT CASE (PERIODIC_TEST)
   CASE DEFAULT
      IF (PROJECTION .AND. ICYC<=1) RETURN
   CASE (5,8)
      RETURN
   CASE (7,11)
      ! CONTINUE
END SELECT

! First compute rhoZZ Volume integrals:
VOLINT_SPEC_MASS(1:N_TOTAL_SCALARS) = 0._EB
CC_IBM_IF : IF (CC_IBM) THEN

   MESH_LOOP1 : DO NM=1,NMESHES

      IF (PROCESS(NM)/=MYID) CYCLE
      CALL POINT_TO_MESH(NM)

      ! Now Compute, discard if solid:
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (CCVAR(I,J,K,IBM_CGSC) /= IBM_GASPHASE) CYCLE
               VOLINT_SPEC_MASS(1:N_TOTAL_SCALARS) = VOLINT_SPEC_MASS(1:N_TOTAL_SCALARS) + &
                                DX(I)*DY(J)*DZ(K)*RHO(I,J,K)*ZZ(I,J,K,1:N_TOTAL_SCALARS)
            ENDDO
         ENDDO
      ENDDO

      ! Now do cut-cells:
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO JCC=1,CUT_CELL(ICC)%NCELL
            VOLINT_SPEC_MASS(1:N_TOTAL_SCALARS) = VOLINT_SPEC_MASS(1:N_TOTAL_SCALARS) + &
            CUT_CELL(ICC)%VOLUME(JCC)*CUT_CELL(ICC)%RHO(JCC)* &
            CUT_CELL(ICC)%ZZ(1:N_TOTAL_SCALARS,JCC)
         ENDDO
      ENDDO

   ENDDO MESH_LOOP1

ELSE ! Regular integral in the GASPHASE

   MESH_LOOP2 : DO NM=1,NMESHES

      IF (PROCESS(NM)/=MYID) CYCLE
      CALL POINT_TO_MESH(NM)

      ! Now Compute, discard if solid:
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
               IF (SOLID(CELL_INDEX(I,J,K))) CYCLE
               VOLINT_SPEC_MASS(1:N_TOTAL_SCALARS) = VOLINT_SPEC_MASS(1:N_TOTAL_SCALARS) + &
                                DX(I)*DY(J)*DZ(K)*RHO(I,J,K)*ZZ(I,J,K,1:N_TOTAL_SCALARS)
            ENDDO
         ENDDO
      ENDDO

   ENDDO MESH_LOOP2

ENDIF CC_IBM_IF
! Here MPI_ALLREDUCE SUM VOLINT_SPEC_MASS(1:N_TOTAL_SCALARS) across processes:
VOLINT_SPEC_MASS_AUX(1:N_TOTAL_SCALARS) = VOLINT_SPEC_MASS(1:N_TOTAL_SCALARS)
IF (N_MPI_PROCESSES>1) THEN
   CALL MPI_ALLREDUCE(VOLINT_SPEC_MASS_AUX(1), VOLINT_SPEC_MASS(1), N_TOTAL_SCALARS, MPI_DOUBLE_PRECISION, &
                      MPI_SUM, MPI_COMM_WORLD, IERR)
ENDIF

! Then add DrhoZZ from Domain boundaries to time accumulated values:
FLXDT_SPEC_MASS(1:N_TOTAL_SCALARS) = 0._EB
MESH_LOOP3 : DO NM=1,NMESHES

   IF (PROCESS(NM)/=MYID) CYCLE
   CALL POINT_TO_MESH(NM)

   EWC_LOOP : DO IW=1,N_EXTERNAL_WALL_CELLS
      WC => WALL(IW)
      IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY .OR. &
          WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) CYCLE
      EWC=>EXTERNAL_WALL(IW)

      ! WRITE(LU_ERR,*) size(EXTERNAL_WALL(IW)%FVN,DIM=1)

      II  = WC%ONE_D%II
      JJ  = WC%ONE_D%JJ
      KK  = WC%ONE_D%KK
      IOR = WC%ONE_D%IOR

      ! Do SSPRK2 integral of fluxes across EXTERNAL wall cell, DELTAMASS=0 for time level n:
      !                         DT*(ADV+DIFF)^n
      DMWS(1:N_TOTAL_SCALARS) = DT*(EWC%FVN(1:N_TOTAL_SCALARS)-EWC%RHO_D_DZDN(1:N_TOTAL_SCALARS))
      DMW(1:N_TOTAL_SCALARS)  = 0.5_EB*( DMWS(1:N_TOTAL_SCALARS) + &
                                DT*(EWC%FVNS(1:N_TOTAL_SCALARS)-EWC%RHO_D_DZDNS(1:N_TOTAL_SCALARS)))

      ! ADD TO FLXDT_SPEC_MASS(1:N_TOTAL_SCALARS):
      SELECT CASE(IOR)
      CASE(1) ! Low FACE: Add delta mass due to FLX.
         FLXDT_SPEC_MASS(1:N_TOTAL_SCALARS) = FLXDT_SPEC_MASS(1:N_TOTAL_SCALARS) + &
                                              DMW(1:N_TOTAL_SCALARS)*DY(JJ)*DZ(KK)
      CASE(-1) ! High FACE: Subtract mass due to FLX.
         FLXDT_SPEC_MASS(1:N_TOTAL_SCALARS) = FLXDT_SPEC_MASS(1:N_TOTAL_SCALARS) - &
                                              DMW(1:N_TOTAL_SCALARS)*DY(JJ)*DZ(KK)
      CASE(2) ! Low FACE: Add delta mass due to FLX.
         FLXDT_SPEC_MASS(1:N_TOTAL_SCALARS) = FLXDT_SPEC_MASS(1:N_TOTAL_SCALARS) + &
                                              DMW(1:N_TOTAL_SCALARS)*DX(II)*DZ(KK)
      CASE(-2) ! High FACE: Subtract mass due to FLX.
         FLXDT_SPEC_MASS(1:N_TOTAL_SCALARS) = FLXDT_SPEC_MASS(1:N_TOTAL_SCALARS) - &
                                              DMW(1:N_TOTAL_SCALARS)*DX(II)*DZ(KK)
      CASE(3) ! Low FACE: Add delta mass due to FLX.
         FLXDT_SPEC_MASS(1:N_TOTAL_SCALARS) = FLXDT_SPEC_MASS(1:N_TOTAL_SCALARS) + &
                                              DMW(1:N_TOTAL_SCALARS)*DX(II)*DY(JJ)
      CASE(-3) ! High FACE: Subtract mass due to FLX.
         FLXDT_SPEC_MASS(1:N_TOTAL_SCALARS) = FLXDT_SPEC_MASS(1:N_TOTAL_SCALARS) - &
                                              DMW(1:N_TOTAL_SCALARS)*DX(II)*DY(JJ)
      END SELECT

   ENDDO EWC_LOOP

ENDDO MESH_LOOP3

! Here MPI_ALLREDUCE SUM FLXDT_SPEC_MASS(1:N_TOTAL_SCALARS) across processes:
FLXDT_SPEC_MASS_AUX(1:N_TOTAL_SCALARS) = FLXDT_SPEC_MASS(1:N_TOTAL_SCALARS)
IF (N_MPI_PROCESSES>1) THEN
   CALL MPI_ALLREDUCE(FLXDT_SPEC_MASS_AUX(1), FLXDT_SPEC_MASS(1), N_TOTAL_SCALARS, MPI_DOUBLE_PRECISION, &
                      MPI_SUM, MPI_COMM_WORLD, IERR)
ENDIF

FLXTINT_SPEC_MASS(1:N_TOTAL_SCALARS) = FLXTINT_SPEC_MASS(1:N_TOTAL_SCALARS) + &
                                       FLXDT_SPEC_MASS(1:N_TOTAL_SCALARS)
! Check difference:
If (DIAGNOSTICS .AND. MYID==0) THEN
    WRITE(LU_ERR,'(A)') 'Scalar,   Total Mass Vol Integral,   Total Mass Flx Time Integral,   Difference'
    DO N=1,N_TOTAL_SCALARS
       WRITE(LU_ERR,'(I4,3E25.3)') N,VOLINT_SPEC_MASS(N), VOLINT_SPEC_MASS_0(N)+FLXTINT_SPEC_MASS(N), &
                         VOLINT_SPEC_MASS(N)-(VOLINT_SPEC_MASS_0(N)+FLXTINT_SPEC_MASS(N))
    ENDDO
ENDIF

! Write To file:
IF(MYID==0) THEN
   IF (FIRST_CALL) THEN
      OPEN(unit=33, file="./Scalars_Integral.res", status='unknown')
      CLOSE(33)
      FIRST_CALL = .FALSE.
   ENDIF

   OPEN(unit=33, file="./Scalars_Integral.res", status='old', position='append')
   DO N=1,N_TOTAL_SCALARS
      write(33,*) T,N,VOLINT_SPEC_MASS(N), VOLINT_SPEC_MASS_0(N)+FLXTINT_SPEC_MASS(N), &
                      VOLINT_SPEC_MASS(N)-(VOLINT_SPEC_MASS_0(N)+FLXTINT_SPEC_MASS(N))
   ENDDO
   CLOSE(33)
ENDIF

RETURN
END SUBROUTINE CHECK_SPEC_TRANSPORT_CONSERVE


! ---------------------------- SET_DOMAINADVLX_3D -------------------------------

SUBROUTINE SET_DOMAINADVFLX_3D(UU,VV,WW,PREDCORR)

REAL(EB), POINTER, DIMENSION(:,:,:) :: UU,VV,WW
LOGICAL, INTENT(IN) :: PREDCORR

! Local Variables:
INTEGER :: IW, II, JJ, KK, IOR
TYPE (WALL_TYPE), POINTER :: WC
TYPE (EXTERNAL_WALL_TYPE), POINTER :: EWC


! Now store advective fluxes:
EWALL_LOOP : DO IW=1,N_EXTERNAL_WALL_CELLS

   WC => WALL(IW)
   IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY .OR. &
       WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) CYCLE
   EWC=>EXTERNAL_WALL(IW)

   II  = WC%ONE_D%II
   JJ  = WC%ONE_D%JJ
   KK  = WC%ONE_D%KK
   IOR = WC%ONE_D%IOR

   IF (PREDCORR) THEN
      ! Diffusive fluxes related to ZZ
      SELECT CASE(IOR)
      CASE(1)
         EWC%FVN(1:N_TOTAL_SCALARS) = FX(II,JJ,KK,1:N_TOTAL_SCALARS)*UU(II,JJ,KK)
      CASE(-1)
         EWC%FVN(1:N_TOTAL_SCALARS) = FX(II-1,JJ,KK,1:N_TOTAL_SCALARS)*UU(II-1,JJ,KK)
      CASE(2)
         EWC%FVN(1:N_TOTAL_SCALARS) = FY(II,JJ,KK,1:N_TOTAL_SCALARS)*VV(II,JJ,KK)
      CASE(-2)
         EWC%FVN(1:N_TOTAL_SCALARS) = FY(II,JJ-1,KK,1:N_TOTAL_SCALARS)*VV(II,JJ-1,KK)
      CASE(3)
         EWC%FVN(1:N_TOTAL_SCALARS) = FZ(II,JJ,KK,1:N_TOTAL_SCALARS)*WW(II,JJ,KK)
      CASE(-3)
         EWC%FVN(1:N_TOTAL_SCALARS) = FZ(II,JJ,KK-1,1:N_TOTAL_SCALARS)*WW(II,JJ,KK-1)
      END SELECT
   ELSE
      ! Diffusive fluxes computed from ZZS
      SELECT CASE(IOR)
      CASE(1)
         EWC%FVNS(1:N_TOTAL_SCALARS) = FX(II,JJ,KK,1:N_TOTAL_SCALARS)*UU(II,JJ,KK)
      CASE(-1)
         EWC%FVNS(1:N_TOTAL_SCALARS) = FX(II-1,JJ,KK,1:N_TOTAL_SCALARS)*UU(II-1,JJ,KK)
      CASE(2)
         EWC%FVNS(1:N_TOTAL_SCALARS) = FY(II,JJ,KK,1:N_TOTAL_SCALARS)*VV(II,JJ,KK)
      CASE(-2)
         EWC%FVNS(1:N_TOTAL_SCALARS) = FY(II,JJ-1,KK,1:N_TOTAL_SCALARS)*VV(II,JJ-1,KK)
      CASE(3)
         EWC%FVNS(1:N_TOTAL_SCALARS) = FZ(II,JJ,KK,1:N_TOTAL_SCALARS)*WW(II,JJ,KK)
      CASE(-3)
         EWC%FVNS(1:N_TOTAL_SCALARS) = FZ(II,JJ,KK-1,1:N_TOTAL_SCALARS)*WW(II,JJ,KK-1)
      END SELECT
   ENDIF

ENDDO EWALL_LOOP



RETURN
END SUBROUTINE SET_DOMAINADVFLX_3D

! ---------------------------- SET_DOMAINDIFFLX_3D ------------------------------

SUBROUTINE SET_DOMAINDIFFLX_3D(ZZP,RHO_D_DZDX,RHO_D_DZDY,RHO_D_DZDZ,PREDCORR)

REAL(EB), INTENT(IN),POINTER, DIMENSION(:,:,:,:) :: ZZP
REAL(EB), INTENT(IN), POINTER, DIMENSION(:,:,:,:) :: RHO_D_DZDX,RHO_D_DZDY,RHO_D_DZDZ
LOGICAL, INTENT(IN) :: PREDCORR

! Local Variables:
INTEGER :: N, IW
TYPE (WALL_TYPE), POINTER :: WC
TYPE (EXTERNAL_WALL_TYPE), POINTER :: EWC
REAL(EB) :: RHO_D_DZDN_GET(1:N_TRACKED_SPECIES),RHO_D_DZDN(1:N_TOTAL_SCALARS)
INTEGER :: II,JJ,KK,IIG,JJG,KKG,IOR,N_ZZ_MAX

! This routine assumes this call has been made before calling it:
! CALL POINT_TO_MESH(NM)

! Now loop species and external wall-cells:
SPECIES_GT_1_IF: IF (N_TOTAL_SCALARS>1) THEN

   ! Get rho*D_n grad Z_n at domain boundaries:

   EWALL_LOOP : DO IW=1,N_EXTERNAL_WALL_CELLS

      WC => WALL(IW)

      IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY .OR. &
          WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) CYCLE EWALL_LOOP

      EWC=>EXTERNAL_WALL(IW)

      II  = WC%ONE_D%II
      JJ  = WC%ONE_D%JJ
      KK  = WC%ONE_D%KK

      IIG = WC%ONE_D%IIG
      JJG = WC%ONE_D%JJG
      KKG = WC%ONE_D%KKG

      IOR = WC%ONE_D%IOR

      IF (WC%BOUNDARY_TYPE==OPEN_BOUNDARY) THEN

         IF (PREDCORR) THEN
            ! Diffusive fluxes related to ZZ
            SELECT CASE(IOR)
            CASE(1)
               EWC%RHO_D_DZDN(1:N_TOTAL_SCALARS) = RHO_D_DZDX(II,JJ,KK,1:N_TOTAL_SCALARS)
            CASE(-1)
               EWC%RHO_D_DZDN(1:N_TOTAL_SCALARS) = RHO_D_DZDX(II-1,JJ,KK,1:N_TOTAL_SCALARS)
            CASE(2)
               EWC%RHO_D_DZDN(1:N_TOTAL_SCALARS) = RHO_D_DZDY(II,JJ,KK,1:N_TOTAL_SCALARS)
            CASE(-2)
               EWC%RHO_D_DZDN(1:N_TOTAL_SCALARS) = RHO_D_DZDY(II,JJ-1,KK,1:N_TOTAL_SCALARS)
            CASE(3)
               EWC%RHO_D_DZDN(1:N_TOTAL_SCALARS) = RHO_D_DZDZ(II,JJ,KK,1:N_TOTAL_SCALARS)
            CASE(-3)
               EWC%RHO_D_DZDN(1:N_TOTAL_SCALARS) = RHO_D_DZDZ(II,JJ,KK-1,1:N_TOTAL_SCALARS)
            END SELECT
         ELSE
            ! Diffusive fluxes computed from ZZS
            SELECT CASE(ABS(IOR))
            CASE(1)
               EWC%RHO_D_DZDNS(1:N_TOTAL_SCALARS) = RHO_D_DZDX(II,JJ,KK,1:N_TOTAL_SCALARS)
            CASE(-1)
               EWC%RHO_D_DZDNS(1:N_TOTAL_SCALARS) = RHO_D_DZDX(II-1,JJ,KK,1:N_TOTAL_SCALARS)
            CASE(2)
               EWC%RHO_D_DZDNS(1:N_TOTAL_SCALARS) = RHO_D_DZDY(II,JJ,KK,1:N_TOTAL_SCALARS)
            CASE(-2)
               EWC%RHO_D_DZDNS(1:N_TOTAL_SCALARS) = RHO_D_DZDY(II,JJ-1,KK,1:N_TOTAL_SCALARS)
            CASE(3)
               EWC%RHO_D_DZDNS(1:N_TOTAL_SCALARS) = RHO_D_DZDZ(II,JJ,KK,1:N_TOTAL_SCALARS)
            CASE(-3)
               EWC%RHO_D_DZDNS(1:N_TOTAL_SCALARS) = RHO_D_DZDZ(II,JJ,KK-1,1:N_TOTAL_SCALARS)
            END SELECT
         ENDIF

      ELSE ! WC%BOUNDARY_TYPE/=OPEN_BOUNDARY
         ! Recompute diffusive fluxes:
         N_ZZ_MAX = MAXLOC(WC%ONE_D%ZZ_F(1:N_TRACKED_SPECIES),1)
         SPECIES_LOOP: DO N=1,N_TOTAL_SCALARS
            ! This will only work if N_TOTAL_SCALARS=N_TRACKED_SPECIES, i.e.
            ! WC%ONE_D%ZZ_F(1:N_TRACKED_SPECIES), but loop  N=1,N_TOTAL_SCALARS
            RHO_D_DZDN(N) = 2._EB*WC%ONE_D%RHO_D_F(N)*(ZZP(IIG,JJG,KKG,N)-WC%ONE_D%ZZ_F(N))*WC%ONE_D%RDN
            IF (N==N_ZZ_MAX) THEN
               RHO_D_DZDN_GET(1:N_TRACKED_SPECIES) = &
                 2._EB*WC%ONE_D%RHO_D_F(1:N_TRACKED_SPECIES)*  &
               (ZZP(IIG,JJG,KKG,1:N_TRACKED_SPECIES)-WC%ONE_D%ZZ_F(1:N_TRACKED_SPECIES))*WC%ONE_D%RDN
               RHO_D_DZDN(N) = -(SUM(RHO_D_DZDN_GET(1:N_TRACKED_SPECIES))-RHO_D_DZDN(N))
            ENDIF

         ENDDO SPECIES_LOOP

         IF (PREDCORR) THEN
            EWC%RHO_D_DZDN(1:N_TOTAL_SCALARS) = RHO_D_DZDN(1:N_TOTAL_SCALARS)
         ELSE
            EWC%RHO_D_DZDNS(1:N_TOTAL_SCALARS) = RHO_D_DZDN(1:N_TOTAL_SCALARS)
         ENDIF

      ENDIF ! WC%BOUNDARY_TYPE

   ENDDO EWALL_LOOP

ENDIF SPECIES_GT_1_IF


RETURN
END SUBROUTINE SET_DOMAINDIFFLX_3D

! ---------------------------- POTENTIAL_FLOW_INIT ------------------------------

SUBROUTINE POTENTIAL_FLOW_INIT

USE COMP_FUNCTIONS, ONLY: CURRENT_TIME
USE MPI

! Local Variables:
INTEGER :: MAXFCT, MNUM, MTYPE, PHASE, NRHS, ERROR, MSGLVL
#ifdef WITH_MKL
INTEGER :: PERM(1)
#endif
INTEGER :: NM, IW, IIG, JJG, KKG, IOR, IROW, I, J, K, X1AXIS, ICF, IFACE, NFACE
TYPE (WALL_TYPE), POINTER :: WC
REAL(EB):: IDX, AF, VAL, TNOW, DHDXN, HVAL, HM1, HP1
!REAL(EB), POINTER, DIMENSION(:,:,:) :: HP
INTEGER :: IND(LOW_IND:HIGH_IND), IND_LOC(LOW_IND:HIGH_IND)

! Set FREEZE_VELOCITY to .TRUE., no velocity evolution along the time integration.
FREEZE_VELOCITY=.TRUE.

! Here we define A set of boundary conditions on the Domain boundaries such that we
! Define rhs F_H, here we use Source defined for potential flow solution:
F_H(1:NUNKH_LOCAL) = 0._EB
X_H(1:NUNKH_LOCAL) = 0._EB

! Meshes Loop:
MESHES_LOOP : DO NM=1,NMESHES

   IF (PROCESS(NM)/=MYID) CYCLE

   CALL POINT_TO_MESH(NM)

   ! Then BCs:
   WALL_CELL_LOOP: DO IW=1,N_EXTERNAL_WALL_CELLS

      WC => WALL(IW)

      ! NEUMANN boundaries:
      IF_NEUMANN: IF (WC%PRESSURE_BC_INDEX==NEUMANN) THEN

         ! Gasphase cell indexes:
         IIG   = WC%ONE_D%IIG
         JJG   = WC%ONE_D%JJG
         KKG   = WC%ONE_D%KKG
         IOR   = WC%ONE_D%IOR

         DHDXN = -WC%UW0

         ! Define cell size, normal to WC:
         SELECT CASE (IOR)
         CASE(-1) ! -IAXIS oriented, high face of IIG cell.
            AF  =  DY(JJG)*DZ(KKG)
            VAL = -DHDXN*AF
         CASE( 1) ! +IAXIS oriented, low face of IIG cell.
            AF  =  DY(JJG)*DZ(KKG)
            VAL =  DHDXN*AF
         CASE(-2) ! -JAXIS oriented, high face of JJG cell.
            AF  =  DX(IIG)*DZ(KKG)
            VAL = -DHDXN*AF
         CASE( 2) ! +JAXIS oriented, low face of JJG cell.
            AF  =  DX(IIG)*DZ(KKG)
            VAL =  DHDXN*AF
         CASE(-3) ! -KAXIS oriented, high face of KKG cell.
            AF  =  DX(IIG)*DY(JJG)
            VAL = -DHDXN*AF
            WRITE(LU_ERR,*) "POTENTIAL_FLOW_INIT: high KAXIS H BC set to NEUMANN, should be DIRICHLET."
         CASE( 3) ! +KAXIS oriented, low face of KKG cell.
            AF  =  DX(IIG)*DY(JJG)
            VAL =  DHDXN*AF
         END SELECT

         ! Row number:
         IROW = CCVAR(IIG,JJG,KKG,IBM_UNKH) - UNKH_IND(NM_START) ! Local numeration.

         ! Add to F_H:
         F_H(IROW) = F_H(IROW) + VAL

      ENDIF IF_NEUMANN

      ! DIRICHLET boundaries, Modify diagonal coefficient on D_MAT_H:
      IF_DIRICHLET: IF (WC%PRESSURE_BC_INDEX==DIRICHLET) THEN

         ! Gasphase cell indexes:
         IIG   = WC%ONE_D%IIG
         JJG   = WC%ONE_D%JJG
         KKG   = WC%ONE_D%KKG
         IOR   = WC%ONE_D%IOR

         ! Define cell size, normal to WC:
         HVAL= 0._EB ! Same sign for all cases.
         SELECT CASE (IOR)
         CASE(-1) ! -IAXIS oriented, high face of IIG cell.
            IDX = 1._EB / DXN(IIG)
            AF  =  DY(JJG)*DZ(KKG)
            VAL = -2._EB*IDX*AF*HVAL
            WRITE(LU_ERR,*) "POTENTIAL_FLOW_INIT: high IAXIS H BC set to DIRICHLET, should be NEUMANN."
         CASE( 1) ! +IAXIS oriented, low face of IIG cell.
            IDX = 1._EB / DXN(IIG-1)
            AF  =  DY(JJG)*DZ(KKG)
            VAL = -2._EB*IDX*AF*HVAL
            WRITE(LU_ERR,*) "POTENTIAL_FLOW_INIT: low IAXIS H BC set to DIRICHLET, should be NEUMANN."
         CASE(-2) ! -JAXIS oriented, high face of JJG cell.
            IDX = 1._EB / DYN(JJG)
            AF  =  DX(IIG)*DZ(KKG)
            VAL = -2._EB*IDX*AF*HVAL
            WRITE(LU_ERR,*) "POTENTIAL_FLOW_INIT: high JAXIS H BC set to DIRICHLET, should be NEUMANN."
         CASE( 2) ! +JAXIS oriented, low face of JJG cell.
            IDX = 1._EB / DYN(JJG-1)
            AF  =  DX(IIG)*DZ(KKG)
            VAL = -2._EB*IDX*AF*HVAL
            WRITE(LU_ERR,*) "POTENTIAL_FLOW_INIT: low JAXIS H BC set to DIRICHLET, should be NEUMANN."
         CASE(-3) ! -KAXIS oriented, high face of KKG cell.
            IDX = 1._EB / DZN(KKG)
            AF  =  DX(IIG)*DY(JJG)
            VAL = -2._EB*IDX*AF*HVAL
         CASE( 3) ! +KAXIS oriented, low face of KKG cell.
            IDX = 1._EB / DZN(KKG-1)
            AF  =  DX(IIG)*DY(JJG)
            VAL = -2._EB*IDX*AF*HVAL
            WRITE(LU_ERR,*) "POTENTIAL_FLOW_INIT: low KAXIS H BC set to DIRICHLET, should be NEUMANN."
         END SELECT

         ! Row number:
         IROW = CCVAR(IIG,JJG,KKG,IBM_UNKH) - UNKH_IND(NM_START) ! Local numeration.

         ! Add to F_H:
         F_H(IROW) = F_H(IROW) + VAL

      ENDIF IF_DIRICHLET

   ENDDO WALL_CELL_LOOP

ENDDO MESHES_LOOP

! Solve:
NRHS   =  1
MAXFCT =  1
MNUM   =  1
ERROR  =  0 ! initialize error flag
MSGLVL =  0 ! print statistical information
IF ( H_MATRIX_INDEFINITE ) THEN
   MTYPE  = -2 ! symmetric indefinite
ELSE ! positive definite
   MTYPE  =  2
ENDIF

!.. Solve system:
IPARM(8) = 0 ! max numbers of iterative refinement steps
PHASE = 33   ! Solve system back-forth substitution.
TNOW=CURRENT_TIME()
! PARDISO:
! CALL PARDISO(PT_H, MAXFCT, MNUM, MTYPE, PHASE, NUNKH_TOTAL, &
!      A_H, IA_H, JA_H, PERM, NRHS, IPARM, MSGLVL, F_H, X_H, ERROR)
! WRITE(LU_ERR,*) "POTENTIAL_FLOW PARDISO time=",CURRENT_TIME()-TNOW,ERROR

#ifdef WITH_MKL
CALL CLUSTER_SPARSE_SOLVER(PT_H, MAXFCT, MNUM, MTYPE, PHASE, NUNKH_TOTAL, &
             A_H, IA_H, JA_H, PERM, NRHS, IPARM, MSGLVL, F_H, X_H, MPI_COMM_WORLD, ERROR)
IF (MYID==0) WRITE(LU_ERR,*) "POTENTIAL_FLOW CLUSTER_SPARSE_SOLVER time=",CURRENT_TIME()-TNOW,ERROR

#else
IF (MYID==0) THEN
   WRITE(LU_ERR,*) 'Can not solve Potential flow problem on domain.'
   WRITE(LU_ERR,*) 'MKL Library compile flag was not defined.'
ENDIF
! Some error - stop flag.
RETURN
#endif /* WITH_MKL */

! Use result to define potential flow velocities:
! Meshes Loop:
MESHES_LOOP2 : DO NM=1,NMESHES

   IF (PROCESS(NM)/=MYID) CYCLE

   CALL POINT_TO_MESH(NM)

   ! Now define velocities V = -G(H):
   ! First Regular gasphase velocities:
   ! IAXIS faces:
   X1AXIS = IAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_H(X1AXIS)

      I  = MESHES(NM)%IBM_REGFACE_IAXIS_H(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_IAXIS_H(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_IAXIS_H(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = MESHES(NM)%CCVAR(I+FCELL-1,J,K,IBM_UNKH)
      IND(HIGH_IND) = MESHES(NM)%CCVAR(I+FCELL  ,J,K,IBM_UNKH)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKH_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKH_IND(NM_START)

      ! Face dx:
      IDX= 1._EB/DXN(I)

      HM1 = X_H(IND_LOC(LOW_IND))
      HP1 = X_H(IND_LOC(HIGH_IND))
      U(I,J,K) = -IDX*(HP1-HM1)
      US(I,J,K)= U(I,J,K)
   ENDDO

   ! JAXIS faces:
   X1AXIS = JAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_H(X1AXIS)

      I  = MESHES(NM)%IBM_REGFACE_JAXIS_H(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_JAXIS_H(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_JAXIS_H(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = MESHES(NM)%CCVAR(I,J+FCELL-1,K,IBM_UNKH)
      IND(HIGH_IND) = MESHES(NM)%CCVAR(I,J+FCELL  ,K,IBM_UNKH)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKH_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKH_IND(NM_START)

      ! Face dx:
      IDX= 1._EB/DYN(J)

      HM1 = X_H(IND_LOC(LOW_IND))
      HP1 = X_H(IND_LOC(HIGH_IND))
      V(I,J,K) = -IDX*(HP1-HM1)
      VS(I,J,K)= V(I,J,K)
   ENDDO

   ! KAXIS faces:
   X1AXIS = KAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_H(X1AXIS)

      I  = MESHES(NM)%IBM_REGFACE_KAXIS_H(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_KAXIS_H(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_KAXIS_H(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = MESHES(NM)%CCVAR(I,J,K+FCELL-1,IBM_UNKH)
      IND(HIGH_IND) = MESHES(NM)%CCVAR(I,J,K+FCELL  ,IBM_UNKH)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKH_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKH_IND(NM_START)

      ! Face dx:
      IDX= 1._EB/DZN(K)

      HM1 = X_H(IND_LOC(LOW_IND))
      HP1 = X_H(IND_LOC(HIGH_IND))
      W(I,J,K) = -IDX*(HP1-HM1)
      WS(I,J,K)= W(I,J,K)

   ENDDO

   ! Domain boundary collocated velocities:
   ! Low Z:
   K = 0
   DO J=1,JBAR
      DO I=1,IBAR
         W(I,J,K) = 1._EB
      ENDDO
   ENDDO
   ! High Z:
   K = KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         ! Unknowns on related cells:
         IND(LOW_IND)  = MESHES(NM)%CCVAR(I,J,K+FCELL-1,IBM_UNKH)
         IND_LOC(LOW_IND) = IND(LOW_IND) - UNKH_IND(NM_START) ! All row indexes must refer to ind_loc.
         ! Face dx:
         IDX= 1._EB/DZN(K)

         HM1 = X_H(IND_LOC(LOW_IND))
         W(I,J,K) = 2._EB*IDX*HM1
      ENDDO
   ENDDO


   ! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
   DO IFACE=1,MESHES(NM)%IBM_NRCFACE_H

      I      = MESHES(NM)%IBM_RCFACE_H(IFACE)%IJK(IAXIS)
      J      = MESHES(NM)%IBM_RCFACE_H(IFACE)%IJK(JAXIS)
      K      = MESHES(NM)%IBM_RCFACE_H(IFACE)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%IBM_RCFACE_H(IFACE)%IJK(KAXIS+1)

      ! Unknowns on related cells:
      IND(LOW_IND)  = MESHES(NM)%IBM_RCFACE_H(IFACE)%UNK(LOW_IND)
      IND(HIGH_IND) = MESHES(NM)%IBM_RCFACE_H(IFACE)%UNK(HIGH_IND)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKH_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKH_IND(NM_START)

      IDX = 1._EB / ( MESHES(NM)%IBM_RCFACE_H(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                      MESHES(NM)%IBM_RCFACE_H(IFACE)%XCEN(X1AXIS,LOW_IND) )

      HM1 = X_H(IND_LOC(LOW_IND))
      HP1 = X_H(IND_LOC(HIGH_IND))

      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            U(I,J,K) = -IDX*(HP1-HM1)
            US(I,J,K)= U(I,J,K)
         CASE(JAXIS)
            V(I,J,K) = -IDX*(HP1-HM1)
            VS(I,J,K)= V(I,J,K)
         CASE(KAXIS)
            W(I,J,K) = -IDX*(HP1-HM1)
            WS(I,J,K)= W(I,J,K)
      END SELECT

   ENDDO

   ! Finally Gasphase cut-faces:
   IF (.NOT. PRES_ON_CARTESIAN) THEN

   DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH

      CUT_FACE(ICF)%VEL(:) = 0._EB ! INBOUNDARY cut-faces velocities set to 0.
      CUT_FACE(ICF)%VELS(:)= 0._EB

      IF ( CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE

      I = CUT_FACE(ICF)%IJK(IAXIS)
      J = CUT_FACE(ICF)%IJK(JAXIS)
      K = CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)

      DO IFACE=1,CUT_FACE(ICF)%NFACE

         !% Unknowns on related cells:
         IND(LOW_IND)  = CUT_FACE(ICF)%UNKH(LOW_IND,IFACE)
         IND(HIGH_IND) = CUT_FACE(ICF)%UNKH(HIGH_IND,IFACE)

         IND_LOC(LOW_IND) = IND(LOW_IND) - UNKH_IND(NM_START) ! All row indexes must refer to ind_loc.
         IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKH_IND(NM_START)

         IDX= 1._EB/ ( CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE) - &
                       CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE) )

         HM1 = X_H(IND_LOC(LOW_IND))
         HP1 = X_H(IND_LOC(HIGH_IND))

         CUT_FACE(ICF)%VEL(IFACE)  = -IDX*(HP1-HM1)
         CUT_FACE(ICF)%VELS(IFACE) =  CUT_FACE(ICF)%VEL(IFACE)

      ENDDO

   ENDDO

  ELSE ! PRES_ON_CARTESIAN

   DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH

      CUT_FACE(ICF)%VEL(:) = 0._EB ! INBOUNDARY cut-faces velocities set to 0.
      CUT_FACE(ICF)%VELS(:)= 0._EB

      IF ( CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE

      I = CUT_FACE(ICF)%IJK(IAXIS)
      J = CUT_FACE(ICF)%IJK(JAXIS)
      K = CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)

      IFACE=1
      !% Unknowns on related cells:
      IND(LOW_IND)  = CUT_FACE(ICF)%UNKH(LOW_IND,IFACE)
      IND(HIGH_IND) = CUT_FACE(ICF)%UNKH(HIGH_IND,IFACE)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKH_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKH_IND(NM_START)

      HM1 = X_H(IND_LOC(LOW_IND))
      HP1 = X_H(IND_LOC(HIGH_IND))

      NFACE = CUT_FACE(ICF)%NFACE
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            IDX = 1._EB/DXN(I)
            U(I,J,K) = -IDX*(HP1-HM1)
            US(I,J,K)= U(I,J,K)

            AF=DY(J)*DZ(K)/ SUM(CUT_FACE(ICF)%AREA(1:NFACE))
            CUT_FACE(ICF)%VEL(1:NFACE)  = AF*U(I,J,K)
            CUT_FACE(ICF)%VELS(1:NFACE) = AF*U(I,J,K)

         CASE(JAXIS)
            IDX= 1._EB/DYN(J)
            V(I,J,K) = -IDX*(HP1-HM1)
            VS(I,J,K)= V(I,J,K)

            AF=DX(I)*DZ(K)/ SUM(CUT_FACE(ICF)%AREA(1:NFACE))
            CUT_FACE(ICF)%VEL(1:NFACE)  = AF*V(I,J,K)
            CUT_FACE(ICF)%VELS(1:NFACE) = AF*V(I,J,K)

         CASE(KAXIS)
            IDX= 1._EB/DZN(K)
            W(I,J,K) = -IDX*(HP1-HM1)
            WS(I,J,K)= W(I,J,K)

            AF=DX(I)*DY(J)/ SUM(CUT_FACE(ICF)%AREA(1:NFACE))
            CUT_FACE(ICF)%VEL(1:NFACE)  = AF*W(I,J,K)
            CUT_FACE(ICF)%VELS(1:NFACE) = AF*W(I,J,K)

      END SELECT

   ENDDO

   ENDIF

ENDDO MESHES_LOOP2

RETURN
END SUBROUTINE POTENTIAL_FLOW_INIT

! -------------------------- LINEARFIELDS_INTERP_TEST ---------------------------

SUBROUTINE LINEARFIELDS_INTERP_TEST

USE MPI

! Local Variables:
INTEGER :: NM, I, II, J ,K, X1AXIS, IFACE, ICF, PTS(IAXIS:KAXIS,NOD1:NOD4), PTS_PLANE
REAL(EB):: XYZ(MAX_DIM),XYZ_PP(MAX_DIM),INTCOEF(1:5),VAL(1:5),VAL_CC,VAL_CC_ANN
LOGICAL :: DO_CUT_FACE, DO_RCFACE_VEL, DO_CUT_CELL, DO_RCCELL
REAL(EB):: L1_DIFF_CUT_FACE, L1_DIFF_REGC, L1_DIFF_CUTCELL, L1_DIFF_RCCELL
INTEGER :: NP_CUTFACE, NP_REGC, NP_CUTCELL, NP_RCCELL
INTEGER :: ICC, NCELL, ICELL, IPT, IPROC, IERR

DO_CUT_FACE   =  .TRUE.
DO_RCFACE_VEL =  .TRUE.
DO_CUT_CELL   =  .TRUE.
DO_RCCELL     =  .TRUE.

L1_DIFF_CUT_FACE = 0._EB
L1_DIFF_REGC     = 0._EB
L1_DIFF_CUTCELL  = 0._EB
L1_DIFF_RCCELL   = 0._EB

NP_CUTFACE       = 0
NP_REGC          = 0
NP_CUTCELL       = 0
NP_RCCELL        = 0

! Initialize:
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   ! Initialize face, center variables with linear fielp phi(x,y,z) = 2*x + 3*y +4*z
   CALL LINEARFIELDS_INIT(NM)
ENDDO

CALL MESH_CC_EXCHANGE(1,.FALSE.)
CALL MESH_CC_EXCHANGE(3,.FALSE.)
CALL MESH_CC_EXCHANGE(4,.FALSE.)
CALL MESH_CC_EXCHANGE(6,.FALSE.)

! Main Mesh Loop:
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM) ! already done in LINEARFIELDS_INIT(NM).

   ! Test that interpolation to faces and cell centroids gives the same phi values:
   ! Cut-faces and underlying Cartesian face centroid:
   IF (DO_CUT_FACE) THEN
      ICF_LOOP : DO ICF=1,MESHES(NM)%N_CUTFACE_MESH

         IF ( CUT_FACE(ICF)%STATUS /= IBM_GASPHASE) CYCLE

         I      = CUT_FACE(ICF)%IJK(IAXIS)
         J      = CUT_FACE(ICF)%IJK(JAXIS)
         K      = CUT_FACE(ICF)%IJK(KAXIS)
         X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)

         DO IFACE=0,CUT_FACE(ICF)%NFACE

            ! First, underlying cartesian face centroid:
            SELECT CASE(X1AXIS)
              CASE(IAXIS)
                  XYZ(IAXIS:KAXIS) = (/ X(I), YC(J), ZC(K) /)
              CASE(JAXIS)
                  XYZ(IAXIS:KAXIS) = (/ XC(I), Y(J), ZC(K) /)
              CASE(KAXIS)
                  XYZ(IAXIS:KAXIS) = (/ XC(I), YC(J), Z(K) /)
            END SELECT

            PTS(IAXIS:KAXIS,NOD1:NOD4) = CUT_FACE(ICF)%IJK_CARTCEN(IAXIS:KAXIS,NOD1:NOD4)
            XYZ_PP(IAXIS:KAXIS)        = CUT_FACE(ICF)%XYZ_BP_CARTCEN(IAXIS:KAXIS)
            INTCOEF(1:5)               = CUT_FACE(ICF)%INTCOEF_CARTCEN (1:5)
            IF (IFACE > 0) THEN ! do cut-face centroid:
              XYZ(IAXIS:KAXIS)           = CUT_FACE(ICF)%XYZCEN(IAXIS:KAXIS,IFACE)
              PTS(IAXIS:KAXIS,NOD1:NOD4) = CUT_FACE(ICF)%IJK_CFCEN(IAXIS:KAXIS,NOD1:NOD4,IFACE)
              XYZ_PP(IAXIS:KAXIS)        = CUT_FACE(ICF)%XYZ_BP_CFCEN(IAXIS:KAXIS,IFACE)
              INTCOEF(1:5)               = CUT_FACE(ICF)%INTCOEF_CFCEN(1:5,IFACE)
            ENDIF

            ! Now values:
            VAL(1) = 2._EB*XYZ_PP(IAXIS) + 3._EB*XYZ_PP(JAXIS) + 4._EB*XYZ_PP(KAXIS)
            IF (IFACE==0) THEN
               DO IPT=1,MAX_INTERP_POINTS_PLANE
                  VAL(IPT+1)=CUT_FACE(ICF)%VEL_CARTCEN(IPT+1)
               ENDDO
            ELSE
               DO IPT=1,MAX_INTERP_POINTS_PLANE
                  VAL(IPT+1)=CUT_FACE(ICF)%VEL_CFCEN(IPT+1,IFACE)
               ENDDO
            ENDIF

            VAL_CC    = 0._EB
            PTS_PLANE = 0
            DO II=1,5
               VAL_CC = VAL_CC + INTCOEF(II)*VAL(II)
               IF ( (II > 1) .AND. ABS(INTCOEF(II)) < GEOMEPS ) PTS_PLANE = PTS_PLANE + 1
            ENDDO
            VAL_CC_ANN = 2._EB*XYZ(IAXIS) + 3._EB*XYZ(JAXIS) + 4._EB*XYZ(KAXIS)

            L1_DIFF_CUT_FACE = L1_DIFF_CUT_FACE + ABS(VAL_CC-VAL_CC_ANN)
            NP_CUTFACE       = NP_CUTFACE + 1
         ENDDO
      ENDDO ICF_LOOP

   ENDIF

   ! Now IBM_RCFACE_VEL:
   IF (DO_RCFACE_VEL) THEN
      RCFACE_LOOP : DO ICF=1,MESHES(NM)%IBM_NRCFACE_VEL

         I      = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK(IAXIS)
         J      = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK(JAXIS)
         K      = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK(KAXIS)
         X1AXIS = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK(KAXIS+1)

         ! Centroid location in 3D:
         SELECT CASE(X1AXIS)
           CASE(IAXIS)
               XYZ(IAXIS:KAXIS) = (/ X(I), YC(J), ZC(K) /)
           CASE(JAXIS)
               XYZ(IAXIS:KAXIS) = (/ XC(I), Y(J), ZC(K) /)
           CASE(KAXIS)
               XYZ(IAXIS:KAXIS) = (/ XC(I), YC(J), Z(K) /)
         END SELECT

         PTS(IAXIS:KAXIS,NOD1:NOD4) = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK_CARTCEN(IAXIS:KAXIS,NOD1:NOD4)
         XYZ_PP(IAXIS:KAXIS)        = MESHES(NM)%IBM_RCFACE_VEL(ICF)%XYZ_BP_CARTCEN(IAXIS:KAXIS)
         INTCOEF(1:5)               = MESHES(NM)%IBM_RCFACE_VEL(ICF)%INTCOEF_CARTCEN(1:5)

         ! Now values:
         VAL(1) = 2._EB*XYZ_PP(IAXIS) + 3._EB*XYZ_PP(JAXIS) + 4._EB*XYZ_PP(KAXIS)
         DO IPT=1,MAX_INTERP_POINTS_PLANE
            VAL(IPT+1)=MESHES(NM)%IBM_RCFACE_VEL(ICF)%VEL_CARTCEN(IPT+1)
         ENDDO

         VAL_CC    = 0._EB
         PTS_PLANE = 0
         DO II=1,5
            VAL_CC = VAL_CC + INTCOEF(II)*VAL(II)
            IF ( (II > 1) .AND. ABS(INTCOEF(II)) < GEOMEPS ) PTS_PLANE = PTS_PLANE + 1
         ENDDO
         VAL_CC_ANN = 2._EB*XYZ(IAXIS) + 3._EB*XYZ(JAXIS) + 4._EB*XYZ(KAXIS)

         L1_DIFF_REGC = L1_DIFF_REGC + ABS(VAL_CC-VAL_CC_ANN)
         NP_REGC      = NP_REGC + 1

      ENDDO RCFACE_LOOP

   ENDIF

   ! Finally CUT_CELL centroids:
   IF (DO_CUT_CELL) THEN
      ICC_LOOP : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH

         NCELL  = CUT_CELL(ICC)%NCELL

         I      = CUT_CELL(ICC)%IJK(IAXIS)
         J      = CUT_CELL(ICC)%IJK(JAXIS)
         K      = CUT_CELL(ICC)%IJK(KAXIS)

         ! First Cartesian centroid:
         XYZ(IAXIS:KAXIS) = (/ XC(I), YC(J), ZC(K) /)

         PTS(IAXIS:KAXIS,NOD1:NOD4) = CUT_CELL(ICC)%IJK_CARTCEN(IAXIS:KAXIS,NOD1:NOD4)
         XYZ_PP(IAXIS:KAXIS)        = CUT_CELL(ICC)%XYZ_BP_CARTCEN(IAXIS:KAXIS)
         INTCOEF(1:5)               = CUT_CELL(ICC)%INTCOEF_CARTCEN(1:5)

         ! Now values:
         VAL(1) = 2._EB*XYZ_PP(IAXIS) + 3._EB*XYZ_PP(JAXIS) + 4._EB*XYZ_PP(KAXIS)
         DO IPT=1,MAX_INTERP_POINTS_PLANE
            VAL(IPT+1)=CUT_CELL(ICC)%H_CARTCEN(IPT+1)
         ENDDO

         VAL_CC    = 0._EB
         PTS_PLANE = 0
         DO II=1,5
            VAL_CC = VAL_CC + INTCOEF(II)*VAL(II)
            IF ( (II > 1) .AND. ABS(INTCOEF(II)) < GEOMEPS ) PTS_PLANE = PTS_PLANE + 1
         ENDDO
         VAL_CC_ANN = 2._EB*XYZ(IAXIS) + 3._EB*XYZ(JAXIS) + 4._EB*XYZ(KAXIS)

         L1_DIFF_CUTCELL = L1_DIFF_CUTCELL + ABS(VAL_CC-VAL_CC_ANN)
         NP_CUTCELL      = NP_CUTCELL + 1

         ! Now cut-cell volumes:
         DO ICELL=1,NCELL

            ! Centroid location:
            XYZ(IAXIS:KAXIS) = CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,ICELL)

            PTS(IAXIS:KAXIS,NOD1:NOD4) = CUT_CELL(ICC)%IJK_CCCEN(IAXIS:KAXIS,NOD1:NOD4,ICELL)
            XYZ_PP(IAXIS:KAXIS)        = CUT_CELL(ICC)%XYZ_BP_CCCEN(IAXIS:KAXIS,ICELL)
            INTCOEF(1:5)               = CUT_CELL(ICC)%INTCOEF_CCCEN(1:5,ICELL)

            ! Now values:
            VAL(1) = 2._EB*XYZ_PP(IAXIS) + 3._EB*XYZ_PP(JAXIS) + 4._EB*XYZ_PP(KAXIS)
            DO IPT=1,MAX_INTERP_POINTS_PLANE
               VAL(IPT+1)=CUT_CELL(ICC)%H_CCCEN(IPT+1,ICELL)
            ENDDO

            VAL_CC    = 0._EB
            PTS_PLANE = 0
            DO II=1,5
               VAL_CC = VAL_CC + INTCOEF(II)*VAL(II)
               IF ( (II > 1) .AND. ABS(INTCOEF(II)) < GEOMEPS ) PTS_PLANE = PTS_PLANE + 1
            ENDDO
            VAL_CC_ANN = 2._EB*XYZ(IAXIS) + 3._EB*XYZ(JAXIS) + 4._EB*XYZ(KAXIS)

            L1_DIFF_CUTCELL = L1_DIFF_CUTCELL + ABS(VAL_CC-VAL_CC_ANN)
            NP_CUTCELL      = NP_CUTCELL + 1

         ENDDO

      ENDDO ICC_LOOP
   ENDIF


   IF (DO_RCCELL) THEN
      RC_LOOP : DO ICC=1,MESHES(NM)%IBM_NRCELL_H

         I      = MESHES(NM)%IBM_RCELL_H(ICC)%IJK(IAXIS)
         J      = MESHES(NM)%IBM_RCELL_H(ICC)%IJK(JAXIS)
         K      = MESHES(NM)%IBM_RCELL_H(ICC)%IJK(KAXIS)

         ! First Cartesian centroid:
         XYZ(IAXIS:KAXIS) = (/ XC(I), YC(J), ZC(K) /)

         PTS(IAXIS:KAXIS,NOD1:NOD4) = MESHES(NM)%IBM_RCELL_H(ICC)%IJK_CARTCEN(IAXIS:KAXIS,NOD1:NOD4)
         XYZ_PP(IAXIS:KAXIS)        = MESHES(NM)%IBM_RCELL_H(ICC)%XYZ_BP_CARTCEN(IAXIS:KAXIS)
         INTCOEF(1:5)               = MESHES(NM)%IBM_RCELL_H(ICC)%INTCOEF_CARTCEN(1:5)

         ! Now values:
         VAL(1) = 2._EB*XYZ_PP(IAXIS) + 3._EB*XYZ_PP(JAXIS) + 4._EB*XYZ_PP(KAXIS)
         DO IPT=1,MAX_INTERP_POINTS_PLANE
            VAL(IPT+1)=MESHES(NM)%IBM_RCELL_H(ICC)%H_CARTCEN(IPT+1)
         ENDDO

         VAL_CC    = 0._EB
         PTS_PLANE = 0
         DO II=1,5
            VAL_CC = VAL_CC + INTCOEF(II)*VAL(II)
            IF ( (II > 1) .AND. ABS(INTCOEF(II)) < GEOMEPS ) PTS_PLANE = PTS_PLANE + 1
         ENDDO
         VAL_CC_ANN = 2._EB*XYZ(IAXIS) + 3._EB*XYZ(JAXIS) + 4._EB*XYZ(KAXIS)

         L1_DIFF_RCCELL = L1_DIFF_RCCELL + ABS(VAL_CC-VAL_CC_ANN)
         NP_RCCELL      = NP_RCCELL + 1

      ENDDO RC_LOOP
   ENDIF

ENDDO MESH_LOOP

! Write output:
CHECK_LOOP : DO IPROC=0,N_MPI_PROCESSES-1
   CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
   IF(MYID/=IPROC) CYCLE
   WRITE(LU_OUTPUT,*) ' '
   WRITE(LU_OUTPUT,*) IPROC,'CUT_FACE interp pts=',NP_CUTFACE,', L1_DIFF_INTRP=',L1_DIFF_CUT_FACE
   WRITE(LU_OUTPUT,*) IPROC,'REGC_VEL interp pts=',NP_REGC,', L1_DIFF_INTRP=',L1_DIFF_REGC
   WRITE(LU_OUTPUT,*) IPROC,'CUT_CELL interp pts=',NP_CUTCELL,', L1_DIFF_INTRP=',L1_DIFF_CUTCELL
   WRITE(LU_OUTPUT,*) IPROC,'RC_CELL  interp pts=',NP_RCCELL,', L1_DIFF_INTRP=',L1_DIFF_RCCELL
ENDDO CHECK_LOOP
IF(MYID==0) WRITE(LU_OUTPUT,*) ' '

! Stop flag for CALL STOP_CHECK(1).
STOP_STATUS = SETUP_ONLY_STOP

RETURN
END SUBROUTINE LINEARFIELDS_INTERP_TEST

! ------------------------------ LINEARFIELDS_INIT -----------------------------

SUBROUTINE LINEARFIELDS_INIT(NM)

INTEGER, INTENT(IN) :: NM

! Local Variables:
INTEGER :: I,J,K

IF (EVACUATION_ONLY(NM)) RETURN
CALL POINT_TO_MESH(NM)

! Face centered fields, stored in fields U, V ,W:
DO K=1,KBAR
   DO J=1,JBAR
      DO I=0,IBAR
         U(I,J,K) = 2._EB*X(I) + 3._EB*YC(J) + 4._EB*ZC(K)
      ENDDO
   ENDDO
ENDDO
DO K=1,KBAR
   DO J=0,JBAR
      DO I=1,IBAR
         V(I,J,K) = 2._EB*XC(I) + 3._EB*Y(J) + 4._EB*ZC(K)
      ENDDO
   ENDDO
ENDDO
DO K=0,KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         W(I,J,K) = 2._EB*XC(I) + 3._EB*YC(J) + 4._EB*Z(K)
      ENDDO
   ENDDO
ENDDO

! Cell centered field, stored in H:
DO K=1,KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         H(I,J,K)  = 2._EB*XC(I) + 3._EB*YC(J) + 4._EB*ZC(K)
         HS(I,J,K) = H(I,J,K)
      ENDDO
   ENDDO
ENDDO

RETURN

END SUBROUTINE LINEARFIELDS_INIT


! --------------- GET_CRTCFCC_INTERPOLATION_STENCILS ---------------------------

SUBROUTINE GET_CRTCFCC_INTERPOLATION_STENCILS

USE GEOMETRY_FUNCTIONS, ONLY : SEARCH_OTHER_MESHES

! Local variables:
INTEGER :: NM
INTEGER :: IRC,IIFC,X1AXIS,X2AXIS,X3AXIS
INTEGER, ALLOCATABLE, DIMENSION(:,:,:,:,:) :: IJKFACE
INTEGER, ALLOCATABLE, DIMENSION(:,:,:,:)   :: IJKCELL
INTEGER :: I,J,K,NCELL,ICC,JCC,IJK(MAX_DIM),IFC,ICF,ICF1,ICF2,IFACE,LOWHIGH
INTEGER :: XIAXIS,XJAXIS,XKAXIS,INDXI1(MAX_DIM),INCELL,JNCELL,KNCELL,INFACE,JNFACE,KNFACE
INTEGER :: ISTR, IEND, JSTR, JEND, KSTR, KEND
LOGICAL :: INLIST, FOUND_POINT, INSEG, FOUNDPT
REAL(EB):: XYZ(MAX_DIM),XYZ_PP(MAX_DIM),XYZ_IP(MAX_DIM),DV(MAX_DIM),NVEC(MAX_DIM)
INTEGER :: PTS2(IAXIS:KAXIS,1:MAX_INTERP_POINTS_PLANE)
REAL(EB):: P0(MAX_DIM),P1(MAX_DIM),CI,CII,CIII,CIV,CV,DIST,DISTANCE,DIR_FCT,NORM_DV,LASTDOTNVEC,DOTNVEC
INTEGER :: IND_CC(IAXIS:KAXIS+1),FOUND_INBFC(1:3), BODTRI(1:2)
INTEGER :: CCFC,NFC_CC,ICFC,INBFC,INBFC_LOC,IFCPT,IFCPT_LOC,IBOD,IWSEL,ICELL,NCFACE
INTEGER, PARAMETER :: ADDVEC(1:2,1:4) = RESHAPE( (/1,0,-1,0,0,1,0,-1/), (/2,4/) )
INTEGER :: IX1,IX2,IX3,ADDX,ADDX2,ADDX3,INDI,INDJ,INDK,ICFACE
LOGICAL :: FOUNDCF,DO_GASNXT_CUTFACE,DO_GASNXT_CARTCELL
INTEGER :: IGAS,NCCELL,IADD,JADD,KADD,IRCELL,ICC2,TESTVAR

INTEGER :: IW,II,JJ,KK,IIF,JJF,KKF,IOR,LOWHIGH_TEST,IGC
TYPE (WALL_TYPE), POINTER :: WC
TYPE (EXTERNAL_WALL_TYPE), POINTER :: EWC

! OMESH related arrays:
INTEGER, ALLOCATABLE, DIMENSION(:,:,:,:,:) :: IJKFACE2
INTEGER :: IIO,JJO,KKO,NOM,IPT
LOGICAL :: FLGX,FLGY,FLGZ,INNM

INTEGER, ALLOCATABLE, DIMENSION(:) :: IIO_FC_R_AUX,JJO_FC_R_AUX,KKO_FC_R_AUX,AXS_FC_R_AUX
INTEGER, ALLOCATABLE, DIMENSION(:) :: IIO_CC_R_AUX,JJO_CC_R_AUX,KKO_CC_R_AUX
INTEGER :: SIZE_REC

INTEGER, PARAMETER :: DELTA_FC = 200

INTEGER, PARAMETER :: OZPOS=0, ICPOS=1, JCPOS=2, IFPOS=3, IWPOS=4

DO_GASNXT_CUTFACE = .FALSE.
DO_GASNXT_CARTCELL= .FALSE.

IF (PERIODIC_TEST == 103 .OR. PERIODIC_TEST==11 .OR. PERIODIC_TEST==7) FORCE_REGC_FACE_NXT=.FALSE.

IF (FORCE_REGC_FACE_NXT) THEN
   DO_GASNXT_CUTFACE = .TRUE.
   DO_GASNXT_CARTCELL= .TRUE.
ENDIF

! First fill IJK of cut-cells for CUT_FACE and IBM_RCFACE_VEL, in field CELL_LIST:
! Meshes Loop:
MESHES_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! Mesh sizes:
   NXB=IBAR
   NYB=JBAR
   NZB=KBAR

   ! X direction bounds:
   ILO_FACE = 0                    ! Low mesh boundary face index.
   IHI_FACE = IBAR                 ! High mesh boundary face index.
   ILO_CELL = ILO_FACE + FCELL     ! First internal cell index. See notes.
   IHI_CELL = IHI_FACE + FCELL - 1 ! Last internal cell index.
   ISTR     = ILO_FACE - NGUARD    ! Allocation start x arrays.
   IEND     = IHI_FACE + NGUARD    ! Allocation end x arrays.

   ! Y direction bounds:
   JLO_FACE = 0                    ! Low mesh boundary face index.
   JHI_FACE = JBAR                 ! High mesh boundary face index.
   JLO_CELL = JLO_FACE + FCELL     ! First internal cell index. See notes.
   JHI_CELL = JHI_FACE + FCELL - 1 ! Last internal cell index.
   JSTR     = JLO_FACE - NGUARD    ! Allocation start y arrays.
   JEND     = JHI_FACE + NGUARD    ! Allocation end y arrays.

   ! Z direction bounds:
   KLO_FACE = 0                    ! Low mesh boundary face index.
   KHI_FACE = KBAR                 ! High mesh boundary face index.
   KLO_CELL = KLO_FACE + FCELL     ! First internal cell index. See notes.
   KHI_CELL = KHI_FACE + FCELL - 1 ! Last internal cell index.
   KSTR     = KLO_FACE - NGUARD    ! Allocation start z arrays.
   KEND     = KHI_FACE + NGUARD    ! Allocation end z arrays.

   ! Initialize IBM_FFNF to IBM_FGSC, this is to discard from the onset faces that can not be used in interpolation
   ! stencils (i.e. not fluid points). Faces allowed for interpolation stencils must be type IBM_GASPHASE:
   FCVAR(:,:,:,IBM_FFNF,IAXIS:KAXIS) = FCVAR(:,:,:,IBM_FGSC,IAXIS:KAXIS)

   ! First count for allocation:
   ALLOCATE( IJKFACE(ISTR:IEND,JSTR:JEND,KSTR:KEND,IAXIS:KAXIS,OZPOS:IWPOS) )
   IJKFACE(:,:,:,:,:) = 0

   ! Regular Faces that are boundary of cut-cells:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH+MESHES(NM)%N_GCCUTCELL_MESH
      NCELL = CUT_CELL(ICC)%NCELL
      IJK(IAXIS:KAXIS) = CUT_CELL(ICC)%IJK(IAXIS:KAXIS)
      DO JCC=1,NCELL
         ! Loop faces and test:
         DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
            IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
            ! If face type in face_list is not IBM_FTYPE_RGGAS, drop:
            IF(CUT_CELL(ICC)%FACE_LIST(1,IFACE) /= IBM_FTYPE_RGGAS) CYCLE
            ! Which face?
            LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
            X1AXIS  = CUT_CELL(ICC)%FACE_LIST(3,IFACE)
            SELECT CASE(X1AXIS)
            CASE(IAXIS)
               X2AXIS = JAXIS; X3AXIS = KAXIS
               ! location in I,J,K od x2,x2,x3 axes:
               XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS
               X1LO_FACE = ILO_FACE; X2LO_CELL = JLO_CELL; X3LO_CELL = KLO_CELL
               X1HI_FACE = IHI_FACE; X2HI_CELL = JHI_CELL; X3HI_CELL = KHI_CELL
            CASE(JAXIS)
               X2AXIS = KAXIS; X3AXIS = IAXIS
               ! location in I,J,K od x2,x2,x3 axes:
               XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS
               X1LO_FACE = JLO_FACE; X2LO_CELL = KLO_CELL; X3LO_CELL = ILO_CELL
               X1HI_FACE = JHI_FACE; X2HI_CELL = KHI_CELL; X3HI_CELL = IHI_CELL
            CASE(KAXIS)
               X2AXIS = IAXIS; X3AXIS = JAXIS
               ! location in I,J,K od x2,x2,x3 axes:
               XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS
               X1LO_FACE = KLO_FACE; X2LO_CELL = ILO_CELL; X3LO_CELL = JLO_CELL
               X1HI_FACE = KHI_FACE; X2HI_CELL = IHI_CELL; X3HI_CELL = JHI_CELL
            END SELECT

            ! Face indexes:
            INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-FCELL+(LOWHIGH-1), IJK(X2AXIS), IJK(X3AXIS) /)
            INFACE = INDXI1(XIAXIS)
            JNFACE = INDXI1(XJAXIS)
            KNFACE = INDXI1(XKAXIS)

            ! This takes into account faces in the guard-cell region:
            FCVAR(INFACE,JNFACE,KNFACE,IBM_FFNF,X1AXIS) = IBM_CUTCFE ! Can't be used for interp.

            ! For this mesh, don't do interpolation on faces that are not internal or boundary faces.
            IF(INDXI1(IAXIS) < X1LO_FACE .OR. INDXI1(IAXIS) > X1HI_FACE) CYCLE
            IF(INDXI1(JAXIS) < X2LO_CELL .OR. INDXI1(JAXIS) > X2HI_CELL) CYCLE
            IF(INDXI1(KAXIS) < X3LO_CELL .OR. INDXI1(KAXIS) > X3HI_CELL) CYCLE

            IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,OZPOS) = 1
            IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,ICPOS) = ICC
            IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,JCPOS) = JCC
            IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,IFPOS) = IFACE

         ENDDO
      ENDDO
   ENDDO

   ! This is the number of RC faces that will require interpolation for this mesh, defined from cut-cell data on the
   ! interior of the mesh or first layer of guard-cells.
   IRC = SUM(IJKFACE(:,:,:,:,OZPOS))
   MESHES(NM)%IBM_NRCFACE_VEL_CC = IRC

   ! Add Faces that are GASPHASE and have a cut face on their plane cross:
   IF (DO_GASNXT_CUTFACE) THEN
   DO X1AXIS=IAXIS,KAXIS
      SELECT CASE(X1AXIS)
      CASE(IAXIS)

         X2AXIS = JAXIS; X3AXIS = KAXIS
         X1LO_FACE = ILO_FACE; X2LO_CELL = JLO_CELL; X3LO_CELL = KLO_CELL
         X1HI_FACE = IHI_FACE; X2HI_CELL = JHI_CELL; X3HI_CELL = KHI_CELL
         XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS

      CASE(JAXIS)

         X2AXIS = KAXIS; X3AXIS = IAXIS
         X1LO_FACE = JLO_FACE; X2LO_CELL = KLO_CELL; X3LO_CELL = ILO_CELL
         X1HI_FACE = JHI_FACE; X2HI_CELL = KHI_CELL; X3HI_CELL = IHI_CELL
         XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS

      CASE(KAXIS)

         X2AXIS = IAXIS; X3AXIS = JAXIS
         X1LO_FACE = KLO_FACE; X2LO_CELL = ILO_CELL; X3LO_CELL = JLO_CELL
         X1HI_FACE = KHI_FACE; X2HI_CELL = IHI_CELL; X3HI_CELL = JHI_CELL
         XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS

      END SELECT

      ! Now search in ix2 +- 1, ix3 +- 1, considering guard-cell faces:
      DO IX1=X1LO_FACE-CCGUARD,X1HI_FACE+CCGUARD
         DO IX2=X2LO_CELL-CCGUARD,X2HI_CELL+CCGUARD
            DO IX3=X3LO_CELL-CCGUARD,X3HI_CELL+CCGUARD

               ! Faces indexes:
               INDXI1(IAXIS:KAXIS) = (/ IX1, IX2, IX3 /)
               INDI = INDXI1(XIAXIS)
               INDJ = INDXI1(XJAXIS)
               INDK = INDXI1(XKAXIS)

               IF ( FCVAR(INDI,INDJ,INDK,IBM_FGSC,X1AXIS) /= IBM_GASPHASE ) CYCLE ! Only regular faces.
               IF ( FCVAR(INDI,INDJ,INDK,IBM_FFNF,X1AXIS) == IBM_CUTCFE )   CYCLE ! Face has been already counted.

               ! Look at surrounding faces in x2,x3 direction, same plane along X1AXIS as INDI,INDJ,INDK face:
               DO ADDX=1,4
                  ADDX2 = ADDVEC(1,ADDX)
                  ADDX3 = ADDVEC(2,ADDX)

                  ! FIRST CARTESIAN FACE:
                  INDXI1(IAXIS:KAXIS) = (/ IX1, IX2+ADDX2, IX3+ADDX3 /)
                  INFACE = INDXI1(XIAXIS)
                  JNFACE = INDXI1(XJAXIS)
                  KNFACE = INDXI1(XKAXIS)
                  IF( FCVAR(INFACE,JNFACE,KNFACE,IBM_FGSC,X1AXIS) == IBM_CUTCFE ) THEN

                     ! This takes into account faces in the guard-cell region:
                     FCVAR(INDI,INDJ,INDK,IBM_FFNF,X1AXIS) = IBM_CUTCFE ! Can't be used for interp.

                     ! For this mesh, don't do interpolation on faces that are not internal or boundary faces.
                     IF(IX1 < X1LO_FACE .OR. IX1 > X1HI_FACE) EXIT
                     IF(IX2 < X2LO_CELL .OR. IX2 > X2HI_CELL) EXIT
                     IF(IX3 < X3LO_CELL .OR. IX3 > X3HI_CELL) EXIT

                     IJKFACE(INDI,INDJ,INDK,X1AXIS,OZPOS) = 1
                     IJKFACE(INDI,INDJ,INDK,X1AXIS,ICPOS) = IBM_UNDEFINED
                     IJKFACE(INDI,INDJ,INDK,X1AXIS,JCPOS) = IBM_UNDEFINED
                     IJKFACE(INDI,INDJ,INDK,X1AXIS,IFPOS) = IBM_UNDEFINED
                     EXIT
                  ENDIF
               ENDDO
            ENDDO
         ENDDO
      ENDDO
   ENDDO
   ENDIF ! DO_GASNXT_CUTFACE

   IRC = SUM(IJKFACE(:,:,:,:,OZPOS))
   IF ( (IRC == 0) .AND. (MESHES(NM)%N_CUTCELL_MESH == 0) ) THEN
      DEALLOCATE(IJKFACE)
      CYCLE MESHES_LOOP
   ENDIF
   ! Allocate data structure IBM_RCFACE_VEL
   ALLOCATE( MESHES(NM)%IBM_RCFACE_VEL(IRC) )

   ! Now assign to IWPOS the location of external wall cells for RCFACE_VEL:
   GUARD_CUT_CELL_LOOP_1 :  DO IW=1,N_EXTERNAL_WALL_CELLS
      WC=>WALL(IW)
      II  = WC%ONE_D%II
      JJ  = WC%ONE_D%JJ
      KK  = WC%ONE_D%KK
      IOR = WC%ONE_D%IOR
      ! Which face:
      X1AXIS=ABS(IOR)
      SELECT CASE(IOR)
      CASE( IAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=HIGH_IND ! Face on high side of Guard-Cell
      CASE(-IAXIS)
         IIF=II-1; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=LOW_IND
      CASE( JAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=HIGH_IND
      CASE(-JAXIS)
         IIF=II  ; JJF=JJ-1; KKF=KK
         LOWHIGH_TEST=LOW_IND
      CASE( KAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=HIGH_IND
      CASE(-KAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK-1
         LOWHIGH_TEST=LOW_IND
      END SELECT

      IF(IJKFACE(IIF,JJF,KKF,X1AXIS,OZPOS) < 1) CYCLE GUARD_CUT_CELL_LOOP_1 ! Not an RCFACE_VEL.

      IJKFACE(IIF,JJF,KKF,X1AXIS,IWPOS) = IW
   ENDDO GUARD_CUT_CELL_LOOP_1

   ! Now loop cut-cells:
   IRC = 0;
   CUT_CELL_LOOP : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH+MESHES(NM)%N_GCCUTCELL_MESH
      NCELL = CUT_CELL(ICC)%NCELL
      IJK(IAXIS:KAXIS) = CUT_CELL(ICC)%IJK(IAXIS:KAXIS)
      DO JCC=1,NCELL
         ! Loop faces and test:
         DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
            IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
            ! Which face ?
            LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
            SELECT CASE(CUT_CELL(ICC)%FACE_LIST(1,IFACE))

            ! If face type in face_list is 0 i.e. regular GASPASE
            ! connecting one or more cut-cells:
            CASE(IBM_FTYPE_RGGAS)
               X1AXIS  = CUT_CELL(ICC)%FACE_LIST(3,IFACE)

               SELECT CASE(X1AXIS)
               CASE(IAXIS)
                  X2AXIS = JAXIS;  X3AXIS = KAXIS
                  ! location in I,J,K od x2,x2,x3 axes:
                  XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS
               CASE(JAXIS)
                  X2AXIS = KAXIS;  X3AXIS = IAXIS
                  ! location in I,J,K od x2,x2,x3 axes:
                  XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS
               CASE(KAXIS)
                  X2AXIS = IAXIS;  X3AXIS = JAXIS
                  ! location in I,J,K od x2,x2,x3 axes:
                  XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS
               END SELECT

               ! Face indexes:
               INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-FCELL+(LOWHIGH-1), IJK(X2AXIS), IJK(X3AXIS) /)
               INFACE = INDXI1(XIAXIS)
               JNFACE = INDXI1(XJAXIS)
               KNFACE = INDXI1(XKAXIS)

               IF(IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,OZPOS) < 1) CYCLE ! Cycle this face as it does not belong to
                                                                        ! RCFACE_VEL list.

               ! Location of next Cartesian cell:
               INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)+2*LOWHIGH-3, IJK(X2AXIS), IJK(X3AXIS) /)
               INCELL = INDXI1(XIAXIS)
               JNCELL = INDXI1(XJAXIS)
               KNCELL = INDXI1(XKAXIS)

               IF (LOWHIGH == LOW_IND) THEN

                  IF (CCVAR(INCELL,JNCELL,KNCELL,IBM_CGSC) == IBM_GASPHASE ) THEN ! next cell is reg-cell:

                  ! Add face to REGC_FACE_VEL data structure:
                  IRC = IRC + 1
                  MESHES(NM)%IBM_RCFACE_VEL(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS /)
                  MESHES(NM)%IBM_RCFACE_VEL(IRC)%NCFACE = 1
                  ! Cell at i-1, i.e. regular GASPHASE:
                  MESHES(NM)%IBM_RCFACE_VEL(IRC)%CELL_LIST(IAXIS:KAXIS+1,LOW_IND,1) = &
                                          (/ IBM_FTYPE_RGGAS,  INCELL,     JNCELL,     KNCELL /)
                                          !  REGGAScell           I           J          K
                  ! Cell at i+1, i.e. cut-cell:
                  MESHES(NM)%IBM_RCFACE_VEL(IRC)%CELL_LIST(IAXIS:KAXIS+1,HIGH_IND,1) = &
                                          (/ IBM_FTYPE_CFGAS,     ICC,        JCC,        IFC /)
                                          !  Cut-cell   CUT_CELL(icc),CCELEM(jcc,:) is cut vol.

                  ! Modify FACE_LIST for the given cut-cell:
                  CUT_CELL(ICC)%FACE_LIST(4,IFACE) = IRC

                  ! Add WALL_CELL number to IBM_RCFACE_VEL(IRC) (if zero, not a wall-cell):
                  MESHES(NM)%IBM_RCFACE_VEL(IRC)%IWC = IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,IWPOS)
                  IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,OZPOS) = 2

                  ELSEIF(CCVAR(INCELL,JNCELL,KNCELL,IBM_CGSC) == IBM_CUTCFE) THEN ! next cell is cut-cell:

                  ! Test that Cut-cell to Cut-cell reg face hasn't been added before:
                  INLIST = .FALSE.
                  DO IIFC=1,IRC
                     IF (MESHES(NM)%IBM_RCFACE_VEL(IIFC)%IJK(IAXIS)   /= INFACE) CYCLE
                     IF (MESHES(NM)%IBM_RCFACE_VEL(IIFC)%IJK(JAXIS)   /= JNFACE) CYCLE
                     IF (MESHES(NM)%IBM_RCFACE_VEL(IIFC)%IJK(KAXIS)   /= KNFACE) CYCLE
                     IF (MESHES(NM)%IBM_RCFACE_VEL(IIFC)%IJK(KAXIS+1) /= X1AXIS) CYCLE
                     INLIST = .TRUE.
                     EXIT
                  ENDDO
                  IF (INLIST) THEN
                      ! This cut-cell is on the high side of face iifc:
                      ! Cell at i+1, i.e. cut-cell:
                      MESHES(NM)%IBM_RCFACE_VEL(IIFC)%CELL_LIST(IAXIS:KAXIS+1,HIGH_IND,1) = &
                                   (/ IBM_FTYPE_CFGAS,     ICC,     JCC,     IFC /)
                                   !  Cut-cell   CUT_CELL(icc),CCELEM(jcc,:) is cut vol.
                      ! Modify FACE_LIST for the given cut-cell:
                      CUT_CELL(ICC)%FACE_LIST(4,IFACE) = IIFC
                      CYCLE
                  ENDIF

                  ! Add face to REGC_FACE_VEL data structure:
                  IRC = IRC + 1
                  MESHES(NM)%IBM_RCFACE_VEL(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS /)
                  MESHES(NM)%IBM_RCFACE_VEL(IRC)%NCFACE = 1
                  ! Cell at i+1, i.e. cut-cell:
                  MESHES(NM)%IBM_RCFACE_VEL(IRC)%CELL_LIST(IAXIS:KAXIS+1,HIGH_IND,1) = &
                                          (/ IBM_FTYPE_CFGAS,     ICC,        JCC,        IFC /)
                                          !  Cut-cell   CUT_CELL(icc),CCELEM(jcc,:) is cut vol.

                  ! Modify FACE_LIST for the given cut-cell:
                  CUT_CELL(ICC)%FACE_LIST(4,IFACE) = IRC

                  ! Add WALL_CELL number to IBM_RCFACE_VEL(IRC) (if zero, not a wall-cell):
                  MESHES(NM)%IBM_RCFACE_VEL(IRC)%IWC = IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,IWPOS)
                  IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,OZPOS) = 2

                  ENDIF

               ELSE ! LOWHIGH == HIGH

                  IF (CCVAR(INCELL,JNCELL,KNCELL,IBM_CGSC) == IBM_GASPHASE ) THEN ! next cell is reg-cell:

                  ! Add face to REGC_FACE_VEL data structure:
                  IRC = IRC + 1
                  MESHES(NM)%IBM_RCFACE_VEL(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS /)
                  MESHES(NM)%IBM_RCFACE_VEL(IRC)%NCFACE = 1
                  ! Cell at i-1, i.e. cut-cell:
                  MESHES(NM)%IBM_RCFACE_VEL(IRC)%CELL_LIST(IAXIS:KAXIS+1,LOW_IND,1) = &
                                          (/ IBM_FTYPE_CFGAS,     ICC,        JCC,        IFC /)
                                          !  Cut-cell   CUT_CELL(icc),CCELEM(jcc,:) is cut vol.
                  ! Cell at i+1, i.e. regular GASPHASE:
                  MESHES(NM)%IBM_RCFACE_VEL(IRC)%CELL_LIST(IAXIS:KAXIS+1,HIGH_IND,1) = &
                                          (/ IBM_FTYPE_RGGAS,  INCELL,     JNCELL,     KNCELL /)
                                          !  REGGAScell           I           J          K

                  ! Modify FACE_LIST for the given cut-cell:
                  CUT_CELL(ICC)%FACE_LIST(4,IFACE) = IRC

                  ! Add WALL_CELL number to IBM_RCFACE_VEL(IRC) (if zero, not a wall-cell):
                  MESHES(NM)%IBM_RCFACE_VEL(IRC)%IWC = IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,IWPOS)
                  IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,OZPOS) = 2

                  ELSEIF(CCVAR(INCELL,JNCELL,KNCELL,IBM_CGSC) == IBM_CUTCFE) THEN ! next cell is cut-cell:

                  ! Test that Cut-cell to Cut-cell reg face hasn't been added before:
                  INLIST = .FALSE.
                  DO IIFC=1,IRC
                     IF (MESHES(NM)%IBM_RCFACE_VEL(IIFC)%IJK(IAXIS)   /= INFACE) CYCLE
                     IF (MESHES(NM)%IBM_RCFACE_VEL(IIFC)%IJK(JAXIS)   /= JNFACE) CYCLE
                     IF (MESHES(NM)%IBM_RCFACE_VEL(IIFC)%IJK(KAXIS)   /= KNFACE) CYCLE
                     IF (MESHES(NM)%IBM_RCFACE_VEL(IIFC)%IJK(KAXIS+1) /= X1AXIS) CYCLE
                     INLIST = .TRUE.
                     EXIT
                  ENDDO
                  IF (INLIST) THEN
                      ! This cut-cell is on the high side of face iifc:
                      ! Cell at i-1, i.e. cut-cell:
                      MESHES(NM)%IBM_RCFACE_VEL(IIFC)%CELL_LIST(IAXIS:KAXIS+1,LOW_IND,1) = &
                                   (/ IBM_FTYPE_CFGAS,     ICC,     JCC,     IFC /)
                                   !  Cut-cell   CUT_CELL(icc),CCELEM(jcc,:) is cut vol.
                      ! Modify FACE_LIST for the given cut-cell:
                      CUT_CELL(ICC)%FACE_LIST(4,IFACE) = IIFC
                      CYCLE
                  ENDIF

                  ! Add face to REGC_FACE_VEL data structure:
                  IRC = IRC + 1
                  MESHES(NM)%IBM_RCFACE_VEL(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS /)
                  MESHES(NM)%IBM_RCFACE_VEL(IRC)%NCFACE = 1
                  ! Cell at i-1, i.e. cut-cell:
                  MESHES(NM)%IBM_RCFACE_VEL(IRC)%CELL_LIST(IAXIS:KAXIS+1,LOW_IND,1) = &
                                          (/ IBM_FTYPE_CFGAS,     ICC,        JCC,        IFC /)
                                          !  Cut-cell   CUT_CELL(icc),CCELEM(jcc,:) is cut vol.

                  ! Modify FACE_LIST for the given cut-cell:
                  CUT_CELL(ICC)%FACE_LIST(4,IFACE) = IRC

                  ! Add WALL_CELL number to IBM_RCFACE_VEL(IRC) (if zero, not a wall-cell):
                  MESHES(NM)%IBM_RCFACE_VEL(IRC)%IWC = IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,IWPOS)
                  IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,OZPOS) = 2

                  ENDIF

               ENDIF ! LOWHIGH

            CASE(IBM_FTYPE_CFGAS) ! GASPHASE cut-face:

               ICF1    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
               ICF2    = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
               IF (LOWHIGH == LOW_IND) THEN ! Cut-face on low side of cut-cell:
                  CUT_FACE(ICF1)%CELL_LIST(IAXIS:KAXIS+1,HIGH_IND,ICF2) = &
                                      (/ IBM_FTYPE_CFGAS,     ICC,     JCC,     IFC  /)
                                      !  Cut-cell   CUT_CELL(icc),CCELEM(jcc,:) is cut vol.
               ELSE ! HIGH
                  CUT_FACE(ICF1)%CELL_LIST(IAXIS:KAXIS+1,LOW_IND,ICF2) = &
                                      (/ IBM_FTYPE_CFGAS,     ICC,     JCC,     IFC  /)
                                      !  Cut-cell   CUT_CELL(icc),CCELEM(jcc,:) is cut vol.
               ENDIF

            CASE(IBM_FTYPE_CFINB) ! INBOUNDARY cut-face:

                ICF1    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
                ICF2    = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
                ! We add the cut-cell related info in LOW_IND
                CUT_FACE(ICF1)%CELL_LIST(IAXIS:KAXIS+1,LOW_IND,ICF2) = &
                                    (/ IBM_FTYPE_CFGAS,     ICC,     JCC,     IFC  /)
                                    !  Cut-cell   CUT_CELL(icc),CCELEM(jcc,:) is cut vol.

            END SELECT
         ENDDO
      ENDDO
   ENDDO CUT_CELL_LOOP

   ! Add Faces that are GASPHASE and have a cut face on their plane cross:
   IF (DO_GASNXT_CUTFACE) THEN
   DO X1AXIS=IAXIS,KAXIS
      SELECT CASE(X1AXIS)
      CASE(IAXIS)

         X2AXIS = JAXIS; X3AXIS = KAXIS
         X1LO_FACE = ILO_FACE; X2LO_CELL = JLO_CELL; X3LO_CELL = KLO_CELL
         X1HI_FACE = IHI_FACE; X2HI_CELL = JHI_CELL; X3HI_CELL = KHI_CELL
         XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS

      CASE(JAXIS)

         X2AXIS = KAXIS; X3AXIS = IAXIS
         X1LO_FACE = JLO_FACE; X2LO_CELL = KLO_CELL; X3LO_CELL = ILO_CELL
         X1HI_FACE = JHI_FACE; X2HI_CELL = KHI_CELL; X3HI_CELL = IHI_CELL
         XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS

      CASE(KAXIS)

         X2AXIS = IAXIS; X3AXIS = JAXIS
         X1LO_FACE = KLO_FACE; X2LO_CELL = ILO_CELL; X3LO_CELL = JLO_CELL
         X1HI_FACE = KHI_FACE; X2HI_CELL = IHI_CELL; X3HI_CELL = JHI_CELL
         XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS

      END SELECT

      ! Now search in ix2 +- 1, ix3 +- 1:
      DO IX1=X1LO_FACE-CCGUARD,X1HI_FACE+CCGUARD
         DO IX2=X2LO_CELL-CCGUARD,X2HI_CELL+CCGUARD
            DO IX3=X3LO_CELL-CCGUARD,X3HI_CELL+CCGUARD

               ! Faces indexes:
               INDXI1(IAXIS:KAXIS) = (/ IX1, IX2, IX3 /)
               INDI = INDXI1(XIAXIS)
               INDJ = INDXI1(XJAXIS)
               INDK = INDXI1(XKAXIS)

               IF ( MESHES(NM)%FCVAR(INDI,INDJ,INDK,IBM_FGSC,X1AXIS) /= IBM_GASPHASE ) CYCLE
               IF ( IJKFACE(INDI,INDJ,INDK,X1AXIS,OZPOS) /= 1 ) CYCLE !Either not in list (=0), or already counted (=2).

               FOUNDCF = .FALSE.

               ADDX_LOOP : DO ADDX=1,4
                  ADDX2 = ADDVEC(1,ADDX)
                  ADDX3 = ADDVEC(2,ADDX)

                  ! FIRST CARTESIAN FACE:
                  INDXI1(IAXIS:KAXIS) = (/ IX1, IX2+ADDX2, IX3+ADDX3 /)
                  INFACE = INDXI1(XIAXIS)
                  JNFACE = INDXI1(XJAXIS)
                  KNFACE = INDXI1(XKAXIS)
                  IF( MESHES(NM)%FCVAR(INFACE,JNFACE,KNFACE,IBM_FGSC,X1AXIS) == IBM_CUTCFE ) THEN

                     ICF1 =  MESHES(NM)%FCVAR(INFACE,JNFACE,KNFACE,IBM_IDCF,X1AXIS)

                     ! This same assignment might be done more than once, but we keep it here to
                     ! fill IBM_FFNF in guard-cell region.
                     MESHES(NM)%FCVAR(INDI,INDJ,INDK,IBM_FFNF,X1AXIS) = IBM_CUTCFE

                     ! Discard if face on guard-cell region, we don't want to use it in IBM_RC_FACE_VEL:
                     IF (IX1 < X1LO_FACE .OR. IX1 > X1HI_FACE ) EXIT ADDX_LOOP
                     IF (IX2 < X2LO_CELL .OR. IX2 > X2HI_CELL ) EXIT ADDX_LOOP
                     IF (IX3 < X3LO_CELL .OR. IX3 > X3HI_CELL ) EXIT ADDX_LOOP

                     IF (.NOT.FOUNDCF) THEN

                        IRC = IRC + 1
                        MESHES(NM)%IBM_RCFACE_VEL(IRC)%IJK(IAXIS:KAXIS+1) = (/INDI,INDJ,INDK,X1AXIS/)

                        ! Add cut-cells to REGC_FACE_VEL().cell_list:
                        NCFACE = 0
                        DO ICF2=1,MESHES(NM)%CUT_FACE(ICF1)%NFACE
                           NCFACE = NCFACE + 1
                           MESHES(NM)%IBM_RCFACE_VEL(IRC)%CELL_LIST(IAXIS:KAXIS+1,LOW_IND:HIGH_IND,NCFACE) = &
                           MESHES(NM)%CUT_FACE(ICF1)%CELL_LIST(IAXIS:KAXIS+1,LOW_IND:HIGH_IND,ICF2)
                        ENDDO
                        MESHES(NM)%IBM_RCFACE_VEL(IRC)%NCFACE = NCFACE
                        FOUNDCF = .TRUE.

                     ELSE

                        ! Add cut-cells to REGC_FACE_VEL().cell_list:
                        NCFACE = MESHES(NM)%IBM_RCFACE_VEL(IRC)%NCFACE
                        DO ICF2=1,MESHES(NM)%CUT_FACE(ICF1)%NFACE
                           NCFACE = NCFACE + 1
                           MESHES(NM)%IBM_RCFACE_VEL(IRC)%CELL_LIST(IAXIS:KAXIS+1,LOW_IND:HIGH_IND,NCFACE) = &
                           MESHES(NM)%CUT_FACE(ICF1)%CELL_LIST(IAXIS:KAXIS+1,LOW_IND:HIGH_IND,ICF2)
                        ENDDO
                        MESHES(NM)%IBM_RCFACE_VEL(IRC)%NCFACE = NCFACE

                     ENDIF
                  ENDIF
               ENDDO ADDX_LOOP
            ENDDO
         ENDDO
      ENDDO
   ENDDO
   ENDIF ! DO_GASNXT_CUTFACE
   MESHES(NM)%IBM_NRCFACE_VEL = IRC

   DEALLOCATE(IJKFACE)

   ! Now Cartesian GASPHASE Cells that get interpolated H:
   MESHES(NM)%IBM_NRCELL_H = 0
   IF (DO_GASNXT_CARTCELL) THEN
   IRC = 0
   ! Initialize IBM_CCNC to IBM_CGSC:
   MESHES(NM)%CCVAR(:,:,:,IBM_CCNC) = MESHES(NM)%CCVAR(:,:,:,IBM_CGSC)
   DO K=KLO_CELL,KHI_CELL
      DO J=JLO_CELL,JHI_CELL
         DO I=ILO_CELL,IHI_CELL

            IF (MESHES(NM)%CCVAR(I,J,K,IBM_CGSC) /= IBM_GASPHASE) CYCLE

            ! Count face velocities being forced:
            IGAS = 0
            IF (MESHES(NM)%FCVAR(I-FCELL  ,J,K,IBM_FFNF,IAXIS) == IBM_CUTCFE) IGAS = IGAS + 1
            IF (MESHES(NM)%FCVAR(I-FCELL+1,J,K,IBM_FFNF,IAXIS) == IBM_CUTCFE) IGAS = IGAS + 1
            IF (MESHES(NM)%FCVAR(I,J-FCELL  ,K,IBM_FFNF,JAXIS) == IBM_CUTCFE) IGAS = IGAS + 1
            IF (MESHES(NM)%FCVAR(I,J-FCELL+1,K,IBM_FFNF,JAXIS) == IBM_CUTCFE) IGAS = IGAS + 1
            IF (MESHES(NM)%FCVAR(I,J,K-FCELL  ,IBM_FFNF,KAXIS) == IBM_CUTCFE) IGAS = IGAS + 1
            IF (MESHES(NM)%FCVAR(I,J,K-FCELL+1,IBM_FFNF,KAXIS) == IBM_CUTCFE) IGAS = IGAS + 1

            ! H is interpolated on cells with 4, 5 or 6 faces being forced.
            IF (IGAS > 4) IRC = IRC + 1

         ENDDO
      ENDDO
   ENDDO
   ! Allocate data structure:
   ALLOCATE( MESHES(NM)%IBM_RCELL_H(IRC))
   ! NOW populate ijk, cell_list, nccell
   IRC = 0
   DO K=KLO_CELL-CCGUARD,KHI_CELL+CCGUARD
      DO J=JLO_CELL-CCGUARD,JHI_CELL+CCGUARD
         DO I=ILO_CELL-CCGUARD,IHI_CELL+CCGUARD

            IF (MESHES(NM)%CCVAR(I,J,K,IBM_CGSC) /= IBM_GASPHASE) CYCLE

            ! Count face velocities being forced:
            IGAS = 0
            IF (MESHES(NM)%FCVAR(I-FCELL  ,J,K,IBM_FFNF,IAXIS) == IBM_CUTCFE) IGAS = IGAS + 1
            IF (MESHES(NM)%FCVAR(I-FCELL+1,J,K,IBM_FFNF,IAXIS) == IBM_CUTCFE) IGAS = IGAS + 1
            IF (MESHES(NM)%FCVAR(I,J-FCELL  ,K,IBM_FFNF,JAXIS) == IBM_CUTCFE) IGAS = IGAS + 1
            IF (MESHES(NM)%FCVAR(I,J-FCELL+1,K,IBM_FFNF,JAXIS) == IBM_CUTCFE) IGAS = IGAS + 1
            IF (MESHES(NM)%FCVAR(I,J,K-FCELL  ,IBM_FFNF,KAXIS) == IBM_CUTCFE) IGAS = IGAS + 1
            IF (MESHES(NM)%FCVAR(I,J,K-FCELL+1,IBM_FFNF,KAXIS) == IBM_CUTCFE) IGAS = IGAS + 1

            ! H is interpolated on cells with 4, 5 or 6 faces being forced.
            IF (IGAS < 5) CYCLE

            ! Set Cartesian cell interpolation status CCNC to CUTCFE, so it will not
            ! be used in the H interpolation stencil of another cell.
            MESHES(NM)%CCVAR(I,J,K,IBM_CCNC) = IBM_CUTCFE

            ! Discard if cell belongs to guard-cell region:
            IF ( I < ILO_CELL .OR. I > IHI_CELL ) CYCLE
            IF ( J < JLO_CELL .OR. J > JHI_CELL ) CYCLE
            IF ( K < KLO_CELL .OR. K > KHI_CELL ) CYCLE

            ! Add cell to list:
            IRC = IRC + 1

            MESHES(NM)%IBM_RCELL_H(IRC)%IJK(IAXIS:KAXIS) = (/ I, J, K /)

            NCCELL = 0
            ! Look for surrounding cut-cells:
            DO KADD=-1,1
               DO JADD=-1,1
                  DO IADD=-1,1
                     IF(MESHES(NM)%CCVAR(I+IADD,J+JADD,K+KADD,IBM_CGSC) /= IBM_CUTCFE) CYCLE
                     NCCELL = NCCELL + 1
                     ICC = MESHES(NM)%CCVAR(I+IADD,J+JADD,K+KADD,IBM_IDCC)
                     MESHES(NM)%IBM_RCELL_H(IRC)%CELL_LIST(NCCELL) = ICC
                  ENDDO
               ENDDO
            ENDDO
            MESHES(NM)%IBM_RCELL_H(IRC)%NCCELL = NCCELL

         ENDDO
      ENDDO
   ENDDO
   ! Final number of RCCELLS getting H interpolated:
   MESHES(NM)%IBM_NRCELL_H = IRC
   ENDIF ! DO_GASNXT_CARTCELL

ENDDO MESHES_LOOP

! Here Guardcell exchange of MESHES(NM)%FCVAR(INFACE,JNFACE,KNFACE,IBM_FFNF,X1AXIS),
!                            MESHES(NM)%CCVAR(I,J,K,IBM_CCNC):
! No need to do this, as IBM_FFNF, IBM_CCNC have been populated in the guard-cell region.
!!! ---

! Case of periodic test 103, return. No IBM interpolation needed as there are no immersed Bodies:
IF(PERIODIC_TEST==103 .OR. PERIODIC_TEST==11 .OR. PERIODIC_TEST==7) RETURN

! Then, second mesh loop:
IF( ASSOCIATED(X1FACEP)) NULLIFY(X1FACEP)
IF( ASSOCIATED(X2FACEP)) NULLIFY(X2FACEP)
IF( ASSOCIATED(X3FACEP)) NULLIFY(X3FACEP)
IF( ASSOCIATED(X2CELLP)) NULLIFY(X2CELLP)
IF( ASSOCIATED(X3CELLP)) NULLIFY(X3CELLP)
MESHES_LOOP2 : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! Mesh sizes:
   NXB=IBAR
   NYB=JBAR
   NZB=KBAR

   ! X direction bounds:
   ILO_FACE = 0                    ! Low mesh boundary face index.
   IHI_FACE = IBAR                 ! High mesh boundary face index.
   ILO_CELL = ILO_FACE + FCELL     ! First internal cell index. See notes.
   IHI_CELL = IHI_FACE + FCELL - 1 ! Last internal cell index.
   ISTR     = ILO_FACE - NGUARD    ! Allocation start x arrays.
   IEND     = IHI_FACE + NGUARD    ! Allocation end x arrays.

   ! Y direction bounds:
   JLO_FACE = 0                    ! Low mesh boundary face index.
   JHI_FACE = JBAR                 ! High mesh boundary face index.
   JLO_CELL = JLO_FACE + FCELL     ! First internal cell index. See notes.
   JHI_CELL = JHI_FACE + FCELL - 1 ! Last internal cell index.
   JSTR     = JLO_FACE - NGUARD    ! Allocation start y arrays.
   JEND     = JHI_FACE + NGUARD    ! Allocation end y arrays.

   ! Z direction bounds:
   KLO_FACE = 0                    ! Low mesh boundary face index.
   KHI_FACE = KBAR                 ! High mesh boundary face index.
   KLO_CELL = KLO_FACE + FCELL     ! First internal cell index. See notes.
   KHI_CELL = KHI_FACE + FCELL - 1 ! Last internal cell index.
   KSTR     = KLO_FACE - NGUARD    ! Allocation start z arrays.
   KEND     = KHI_FACE + NGUARD    ! Allocation end z arrays.

   ! Define grid arrays for this mesh:
   ! Populate position and cell size arrays: Uniform grid implementation.
   ! X direction:
   ALLOCATE(DXCELL(ISTR:IEND)); DXCELL(ILO_CELL-1:IHI_CELL+1) = DX(ILO_CELL-1:IHI_CELL+1)
   DO IGC=2,NGUARD
      DXCELL(ILO_CELL-IGC)=DXCELL(ILO_CELL-IGC+1)
      DXCELL(IHI_CELL+IGC)=DXCELL(IHI_CELL+IGC-1)
   ENDDO
   ALLOCATE(DXFACE(ISTR:IEND)); DXFACE(ILO_FACE:IHI_FACE)= DXN(ILO_FACE:IHI_FACE)
   DO IGC=1,NGUARD
      DXFACE(ILO_FACE-IGC)=DXFACE(ILO_FACE-IGC+1)
      DXFACE(IHI_FACE+IGC)=DXFACE(ILO_FACE+IGC-1)
   ENDDO
   ALLOCATE(XCELL(ISTR:IEND));  XCELL = 1._EB/GEOMEPS ! Initialize huge.
   XCELL(ILO_CELL-1:IHI_CELL+1) = XC(ILO_CELL-1:IHI_CELL+1)
   DO IGC=2,NGUARD
      XCELL(ILO_CELL-IGC)=XCELL(ILO_CELL-IGC+1)-DXFACE(ILO_FACE-IGC+1)
      XCELL(IHI_CELL+IGC)=XCELL(IHI_CELL+IGC-1)+DXFACE(IHI_FACE+IGC-1)
   ENDDO
   ALLOCATE(XFACE(ISTR:IEND));  XFACE = 1._EB/GEOMEPS ! Initialize huge.
   XFACE(ILO_FACE:IHI_FACE) = X(ILO_FACE:IHI_FACE)
   DO IGC=1,NGUARD
      XFACE(ILO_FACE-IGC)=XFACE(ILO_FACE-IGC+1)-DXCELL(ILO_CELL-IGC)
      XFACE(IHI_FACE+IGC)=XFACE(IHI_FACE+IGC-1)+DXCELL(IHI_CELL+IGC)
   ENDDO

   ! Y direction:
   ALLOCATE(DYCELL(JSTR:JEND)); DYCELL(JLO_CELL-1:JHI_CELL+1)= DY(JLO_CELL-1:JHI_CELL+1)
   DO IGC=2,NGUARD
      DYCELL(JLO_CELL-IGC)=DYCELL(JLO_CELL-IGC+1)
      DYCELL(JHI_CELL+IGC)=DYCELL(JHI_CELL+IGC-1)
   ENDDO
   ALLOCATE(DYFACE(JSTR:JEND)); DYFACE(JLO_FACE:JHI_FACE)= DYN(JLO_FACE:JHI_FACE)
   DO IGC=1,NGUARD
      DYFACE(JLO_FACE-IGC)=DYFACE(JLO_FACE-IGC+1)
      DYFACE(JHI_FACE+IGC)=DYFACE(JHI_FACE+IGC-1)
   ENDDO
   ALLOCATE(YCELL(JSTR:JEND));  YCELL = 1._EB/GEOMEPS ! Initialize huge.
   YCELL(JLO_CELL-1:JHI_CELL+1) = YC(JLO_CELL-1:JHI_CELL+1)
   DO IGC=2,NGUARD
      YCELL(JLO_CELL-IGC)=YCELL(JLO_CELL-IGC+1)-DYFACE(JLO_FACE-IGC+1)
      YCELL(JHI_CELL+IGC)=YCELL(JHI_CELL+IGC-1)+DYFACE(JHI_FACE+IGC-1)
   ENDDO
   ALLOCATE(YFACE(JSTR:JEND));  YFACE = 1._EB/GEOMEPS ! Initialize huge.
   YFACE(JLO_FACE:JHI_FACE) = Y(JLO_FACE:JHI_FACE)
   DO IGC=1,NGUARD
      YFACE(JLO_FACE-IGC)=YFACE(JLO_FACE-IGC+1)-DYCELL(JLO_CELL-IGC)
      YFACE(JHI_FACE+IGC)=YFACE(JHI_FACE+IGC-1)+DYCELL(JHI_CELL+IGC)
   ENDDO

   ! Z direction:
   ALLOCATE(DZCELL(KSTR:KEND)); DZCELL(KLO_CELL-1:KHI_CELL+1)= DZ(KLO_CELL-1:KHI_CELL+1)
   DO IGC=2,NGUARD
      DZCELL(KLO_CELL-IGC)=DZCELL(KLO_CELL-IGC+1)
      DZCELL(KHI_CELL+IGC)=DZCELL(KHI_CELL+IGC-1)
   ENDDO
   ALLOCATE(DZFACE(KSTR:KEND)); DZFACE(KLO_FACE:KHI_FACE)= DZN(KLO_FACE:KHI_FACE)
   DO IGC=1,NGUARD
      DZFACE(KLO_FACE-IGC)=DZFACE(KLO_FACE-IGC+1)
      DZFACE(KHI_FACE+IGC)=DZFACE(KHI_FACE+IGC-1)
   ENDDO
   ALLOCATE(ZCELL(KSTR:KEND));  ZCELL = 1._EB/GEOMEPS ! Initialize huge.
   ZCELL(KLO_CELL-1:KHI_CELL+1) = ZC(KLO_CELL-1:KHI_CELL+1)
   DO IGC=2,NGUARD
      ZCELL(KLO_CELL-IGC)=ZCELL(KLO_CELL-IGC+1)-DZFACE(KLO_FACE-IGC+1)
      ZCELL(KHI_CELL+IGC)=ZCELL(KHI_CELL+IGC-1)+DZFACE(KHI_FACE+IGC-1)
   ENDDO
   ALLOCATE(ZFACE(KSTR:KEND));  ZFACE = 1._EB/GEOMEPS ! Initialize huge.
   ZFACE(KLO_FACE:KHI_FACE) = Z(KLO_FACE:KHI_FACE)
   DO IGC=1,NGUARD
      ZFACE(KLO_FACE-IGC)=ZFACE(KLO_FACE-IGC+1)-DZCELL(KLO_CELL-IGC)
      ZFACE(KHI_FACE+IGC)=ZFACE(KHI_FACE+IGC-1)+DZCELL(KHI_CELL+IGC)
   ENDDO

   ! 1.:
   ! Loop by CUT_FACE, define interpolation stencils in Cartesian and cut-face
   ! centroids using the corresponding cells INBOUNDARY cut-faces and external
   ! face centered fluid points:
   CUT_FACE_LOOP : DO ICF=1,MESHES(NM)%N_CUTFACE_MESH

      IF (CUT_FACE(ICF)%STATUS /= IBM_GASPHASE) CYCLE

      I = CUT_FACE(ICF)%IJK(IAXIS)
      J = CUT_FACE(ICF)%IJK(JAXIS)
      K = CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)

      IJK(IAXIS:KAXIS) = (/ I, J, K /)

      ! First, underlying cartesian face centroid:
      ! Centroid location in 3D:
      SELECT CASE (X1AXIS)
      CASE(IAXIS)
          XYZ(IAXIS:KAXIS) = (/ XFACE(I), YCELL(J), ZCELL(K) /)

          ! x2, x3 axes:
          X2AXIS = JAXIS; X3AXIS = KAXIS

          X1LO_FACE = ILO_FACE-CCGUARD; X1LO_CELL = ILO_CELL-CCGUARD
          X1HI_FACE = IHI_FACE+CCGUARD; X1HI_CELL = IHI_CELL+CCGUARD
          X2LO_FACE = JLO_FACE-CCGUARD; X2LO_CELL = JLO_CELL-CCGUARD
          X2HI_FACE = JHI_FACE+CCGUARD; X2HI_CELL = JHI_CELL+CCGUARD
          X3LO_FACE = KLO_FACE-CCGUARD; X3LO_CELL = KLO_CELL-CCGUARD
          X3HI_FACE = KHI_FACE+CCGUARD; X3HI_CELL = KHI_CELL+CCGUARD

          ! location in I,J,K od x2,x2,x3 axes:
          XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS

          ! Face coordinates in x1,x2,x3 axes:
          X1FACEP => XFACE;
          X2FACEP => YFACE; X2CELLP => YCELL
          X3FACEP => ZFACE; X3CELLP => ZCELL

      CASE(JAXIS)
          XYZ(IAXIS:KAXIS) = (/ XCELL(I), YFACE(J), ZCELL(K) /)

          ! x2, x3 axes:
          X2AXIS = KAXIS;  X3AXIS = IAXIS

          X1LO_FACE = JLO_FACE-CCGUARD; X1LO_CELL = JLO_CELL-CCGUARD
          X1HI_FACE = JHI_FACE+CCGUARD; X1HI_CELL = JHI_CELL+CCGUARD
          X2LO_FACE = KLO_FACE-CCGUARD; X2LO_CELL = KLO_CELL-CCGUARD
          X2HI_FACE = KHI_FACE+CCGUARD; X2HI_CELL = KHI_CELL+CCGUARD
          X3LO_FACE = ILO_FACE-CCGUARD; X3LO_CELL = ILO_CELL-CCGUARD
          X3HI_FACE = IHI_FACE+CCGUARD; X3HI_CELL = IHI_CELL+CCGUARD

          ! location in I,J,K od x2,x2,x3 axes:
          XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS

          ! Face coordinates in x1,x2,x3 axes:
          X1FACEP => YFACE;
          X2FACEP => ZFACE; X2CELLP => ZCELL
          X3FACEP => XFACE; X3CELLP => XCELL

      CASE(KAXIS)
          XYZ(IAXIS:KAXIS) = (/ XCELL(I), YCELL(J), ZFACE(K) /)

          ! x2, x3 axes:
          X2AXIS = IAXIS;  X3AXIS = JAXIS

          X1LO_FACE = KLO_FACE-CCGUARD; X1LO_CELL = KLO_CELL-CCGUARD
          X1HI_FACE = KHI_FACE+CCGUARD; X1HI_CELL = KHI_CELL+CCGUARD
          X2LO_FACE = ILO_FACE-CCGUARD; X2LO_CELL = ILO_CELL-CCGUARD
          X2HI_FACE = IHI_FACE+CCGUARD; X2HI_CELL = IHI_CELL+CCGUARD
          X3LO_FACE = JLO_FACE-CCGUARD; X3LO_CELL = JLO_CELL-CCGUARD
          X3HI_FACE = JHI_FACE+CCGUARD; X3HI_CELL = JHI_CELL+CCGUARD

          ! location in I,J,K od x2,x2,x3 axes:
          XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS

          ! Face coordinates in x1,x2,x3 axes:
          X1FACEP => ZFACE;
          X2FACEP => XFACE; X2CELLP => XCELL
          X3FACEP => YFACE; X3CELLP => YCELL

      END SELECT

      DO IFACE=0,CUT_FACE(ICF)%NFACE

         ! do cut-face centroid for IFACE > 0:
         IF (IFACE > 0) XYZ(IAXIS:KAXIS) = CUT_FACE(ICF)%XYZCEN(IAXIS:KAXIS,IFACE)

         ! Initialize closest inboundary point data:
         DISTANCE            = 1._EB / GEOMEPS
         LASTDOTNVEC         =-1._EB / GEOMEPS
         FOUND_POINT         = .FALSE.
         XYZ_PP(IAXIS:KAXIS) = 0._EB
         FOUND_INBFC(1:3)    = 0

         ! Now LOW side list of INBOUNDARY cut faces, search for closest point to xyz:
         DO LOWHIGH=LOW_IND,HIGH_IND

            DO ICF2=1,CUT_FACE(ICF)%NFACE

               IND_CC(IAXIS:KAXIS+1) = CUT_FACE(ICF)%CELL_LIST(IAXIS:KAXIS+1,LOWHIGH,ICF2)

               IF (IND_CC(1) == IBM_FTYPE_RGGAS) CYCLE ! Cell regular gasphase

               ICC = IND_CC(2)
               JCC = IND_CC(3)

               ! Find closest point and Inboundary cut-face:
               NFC_CC = MESHES(NM)%CUT_CELL(ICC)%CCELEM(1,JCC)
               DO CCFC=1,NFC_CC

                  ICFC = MESHES(NM)%CUT_CELL(ICC)%CCELEM(CCFC+1,JCC)
                  IF ( MESHES(NM)%CUT_CELL(ICC)%FACE_LIST(1,ICFC) /= IBM_FTYPE_CFINB) CYCLE

                  ! Inboundary face number in CUT_FACE:
                  INBFC     = MESHES(NM)%CUT_CELL(ICC)%FACE_LIST(4,ICFC)
                  INBFC_LOC = MESHES(NM)%CUT_CELL(ICC)%FACE_LIST(5,ICFC)

                  CALL GET_CLSPT_INBCF(NM,XYZ,INBFC,INBFC_LOC,XYZ_IP,DIST,FOUNDPT,INSEG)
                  IF (FOUNDPT .AND. ((DIST-DISTANCE) < GEOMEPS)) THEN
                      IF (INSEG) THEN
                          BODTRI(1:2)  = CUT_FACE(INBFC)%BODTRI(1:2,INBFC_LOC)
                          ! normal vector to boundary surface triangle:
                          IBOD    = BODTRI(1)
                          IWSEL   = BODTRI(2)
                          NVEC(IAXIS:KAXIS) = GEOMETRY(IBOD)%FACES_NORMAL(IAXIS:KAXIS,IWSEL)
                          DV(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS) - XYZ_IP(IAXIS:KAXIS)
                          NORM_DV = SQRT( DV(IAXIS)**2._EB + DV(JAXIS)**2._EB + DV(KAXIS)**2._EB )
                          IF(NORM_DV > GEOMEPS) THEN ! Point in segment not same as pt to interp to.
                             DV(IAXIS:KAXIS) = (1._EB / NORM_DV) * DV(IAXIS:KAXIS)
                             DOTNVEC = NVEC(IAXIS)*DV(IAXIS) + NVEC(JAXIS)*DV(JAXIS) + NVEC(KAXIS)*DV(KAXIS)
                             IF (DOTNVEC <= LASTDOTNVEC) CYCLE
                             LASTDOTNVEC = DOTNVEC
                          ENDIF
                      ENDIF
                      DISTANCE = DIST
                      XYZ_PP(IAXIS:KAXIS)   = XYZ_IP(IAXIS:KAXIS)
                      FOUND_INBFC(1:3) = (/ IBM_FTYPE_CFINB, INBFC, INBFC_LOC /) ! Inbound cut-face in CUT_FACE.
                      FOUND_POINT = .TRUE.
                  ENDIF

               ENDDO

               ! If point not found, all cut-faces boundary of the icc, jcc volume
               ! are GASPHASE. There must be a SOLID point in the boundary of the
               ! underlying Cartesian cell. this is the closest point:
               IF (.NOT.FOUND_POINT) THEN
                   ! Search for for CUT_CELL(icc) vertex points or other solid points:
                   CALL GET_CLOSEPT_CCVT(NM,XYZ,ICC,XYZ_IP,DIST,FOUNDPT,IFCPT,IFCPT_LOC)
                   IF (FOUNDPT .AND. ((DIST-DISTANCE) < GEOMEPS)) THEN
                      DISTANCE = DIST
                      XYZ_PP(IAXIS:KAXIS)   = XYZ_IP(IAXIS:KAXIS)
                      FOUND_INBFC(1:3) = (/ IBM_FTYPE_SVERT, IFCPT, IFCPT_LOC /) ! SOLID vertex in CUT_FACE.
                      FOUND_POINT = .TRUE.
                   ENDIF
               ENDIF

            ENDDO ! ICF2

         ENDDO ! LOWHIGH

         IF (.NOT.FOUND_POINT) PRINT*, 'CF: Havent found closest point. ICF, IFACE=',ICF,IFACE

         ! Here test if point in boundary and interpolation point coincide:
         IF (DISTANCE <= GEOMEPS) THEN

            ! Dummy values for external interpolation nodes:
            PTS2(IAXIS,1:MAX_INTERP_POINTS_PLANE) = I ! IJK triangle nodes
            PTS2(JAXIS,1:MAX_INTERP_POINTS_PLANE) = J
            PTS2(KAXIS,1:MAX_INTERP_POINTS_PLANE) = K

            ! Interpolation coeff s.t. interpolated value = boundary value:
            CI  = 1.0_EB
            CII = 0.0_EB
            CIII= 0.0_EB
            CIV = 0.0_EB
            CV  = 0.0_EB

         ELSE

            ! After this loop we have the closest boundary point to xyz and the
            ! cut-face it belongs. We need to use the normal out of the face (or the
            ! vertex to xyz direction to find fluid points on the stencil:
            ! The fluid points are points that lay on the plane outside in the
            ! largest Cartesian component direction of the normal.
            DIR_FCT = 1._EB
            IF (FOUND_INBFC(1) == IBM_FTYPE_CFINB) THEN ! closest point in INBOUNDARY cut-face.
                BODTRI(1:2) = CUT_FACE(FOUND_INBFC(2))%BODTRI(1:2,FOUND_INBFC(3))
                ! normal vector to boundary surface triangle:
                IBOD    = BODTRI(1)
                IWSEL   = BODTRI(2)
                NVEC(IAXIS:KAXIS) = GEOMETRY(IBOD)%FACES_NORMAL(IAXIS:KAXIS,IWSEL)
                DV(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS) - XYZ_PP(IAXIS:KAXIS)
                DOTNVEC = NVEC(IAXIS)*DV(IAXIS) + NVEC(JAXIS)*DV(JAXIS) + NVEC(KAXIS)*DV(KAXIS)

                IF (DOTNVEC < 0._EB) DIR_FCT = -1._EB ! if normal to triangle has opposite dir change
                                                      ! search direction.
            ENDIF

            ! Versor to GASPHASE:
            IF (DIR_FCT > 0._EB) THEN ! Versor from boundary point to centroid
                P0(IAXIS:KAXIS) = XYZ_PP(IAXIS:KAXIS)
                P1(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS)
            ELSE ! Viceversa
                P0(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS)
                P1(IAXIS:KAXIS) = XYZ_PP(IAXIS:KAXIS)
            ENDIF
            !print*, 'DIR_FCT=',DIR_FCT
            !print*, 'XYZ=',XYZ(IAXIS:KAXIS)
            !print*, 'XYZ_PP=',XYZ_PP(IAXIS:KAXIS)
            DV(IAXIS:KAXIS)   = DIR_FCT * ( XYZ(IAXIS:KAXIS) - XYZ_PP(IAXIS:KAXIS) )
            NORM_DV           = SQRT( DV(IAXIS)**2._EB + DV(JAXIS)**2._EB + DV(KAXIS)**2._EB )
            DV(IAXIS:KAXIS) = (1._EB / NORM_DV) * DV(IAXIS:KAXIS) ! NOUT

            ! Call routine that defines stencils:
            CALL GET_INTSTENCILS_FACE3D(NM,X1AXIS,X2AXIS,X3AXIS,XIAXIS,XJAXIS,XKAXIS,               &
                                        P0,P1,DV,X1FACEP,X2FACEP,X3FACEP,X2CELLP,X3CELLP,&
                                        DIR_FCT,CI,CII,CIII,CIV,CV,PTS2)

         ENDIF

         ! Add coefficients to CUT_FACE fields:
         IF (IFACE == 0) THEN
           CUT_FACE(ICF)%IJK_CARTCEN(IAXIS:KAXIS,1:MAX_INTERP_POINTS_PLANE) = &
                                               PTS2(IAXIS:KAXIS,1:MAX_INTERP_POINTS_PLANE) ! IJK triangle nodes
           CUT_FACE(ICF)%XYZ_BP_CARTCEN(IAXIS:KAXIS) = XYZ_PP(IAXIS:KAXIS)  ! xyz of boundary pt
           CUT_FACE(ICF)%INBFC_CARTCEN(1:3)   = FOUND_INBFC(1:3)  ! which INB cut-face boundary pt belongs to.
           CUT_FACE(ICF)%INTCOEF_CARTCEN(1:5) = (/ CI, CII, CIII, CIV, CV /)
         ELSE
           CUT_FACE(ICF)%IJK_CFCEN(IAXIS:KAXIS,1:MAX_INTERP_POINTS_PLANE,IFACE) = &
                                             PTS2(IAXIS:KAXIS,1:MAX_INTERP_POINTS_PLANE) ! IJK triangle nodes
           CUT_FACE(ICF)%XYZ_BP_CFCEN(IAXIS:KAXIS,IFACE) = XYZ_PP(IAXIS:KAXIS)!xyz of boundary pt
           CUT_FACE(ICF)%INBFC_CFCEN(1:3,IFACE) = FOUND_INBFC(1:3) ! which INB cut-face boundary pt belongs to.
           CUT_FACE(ICF)%INTCOEF_CFCEN(1:5,IFACE) = (/ CI, CII, CIII, CIV, CV /)
         ENDIF

      ENDDO ! IFACE loop
      NULLIFY(X1FACEP,X2FACEP,X3FACEP,X2CELLP,X3CELLP)

   ENDDO CUT_FACE_LOOP

   ! 2.:
   ! Loop by REGC_FACE_VEL, define interpolation stencils in Cartesian and cut
   ! face centroids using the corresponding cells INBOUNDARY cut-faces
   RCVEL_FACE_LOOP : DO ICF=1,MESHES(NM)%IBM_NRCFACE_VEL

      I      = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK(IAXIS)
      J      = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK(JAXIS)
      K      = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK(KAXIS+1)

      IJK(IAXIS:KAXIS) = (/ I, J, K /)

      ! First, underlying cartesian face centroid:
      ! Centroid location in 3D:
      SELECT CASE (X1AXIS)
      CASE(IAXIS)
          XYZ(IAXIS:KAXIS) = (/ XFACE(I), YCELL(J), ZCELL(K) /)

          ! x2, x3 axes:
          X2AXIS = JAXIS; X3AXIS = KAXIS

          X1LO_FACE = ILO_FACE-CCGUARD; X1LO_CELL = ILO_CELL-CCGUARD
          X1HI_FACE = IHI_FACE+CCGUARD; X1HI_CELL = IHI_CELL+CCGUARD
          X2LO_FACE = JLO_FACE-CCGUARD; X2LO_CELL = JLO_CELL-CCGUARD
          X2HI_FACE = JHI_FACE+CCGUARD; X2HI_CELL = JHI_CELL+CCGUARD
          X3LO_FACE = KLO_FACE-CCGUARD; X3LO_CELL = KLO_CELL-CCGUARD
          X3HI_FACE = KHI_FACE+CCGUARD; X3HI_CELL = KHI_CELL+CCGUARD

          ! location in I,J,K od x2,x2,x3 axes:
          XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS

          ! Face coordinates in x1,x2,x3 axes:
          X1FACEP => XFACE;
          X2FACEP => YFACE; X2CELLP => YCELL
          X3FACEP => ZFACE; X3CELLP => ZCELL

      CASE(JAXIS)
          XYZ(IAXIS:KAXIS) = (/ XCELL(I), YFACE(J), ZCELL(K) /)

          ! x2, x3 axes:
          X2AXIS = KAXIS;  X3AXIS = IAXIS

          X1LO_FACE = JLO_FACE-CCGUARD; X1LO_CELL = JLO_CELL-CCGUARD
          X1HI_FACE = JHI_FACE+CCGUARD; X1HI_CELL = JHI_CELL+CCGUARD
          X2LO_FACE = KLO_FACE-CCGUARD; X2LO_CELL = KLO_CELL-CCGUARD
          X2HI_FACE = KHI_FACE+CCGUARD; X2HI_CELL = KHI_CELL+CCGUARD
          X3LO_FACE = ILO_FACE-CCGUARD; X3LO_CELL = ILO_CELL-CCGUARD
          X3HI_FACE = IHI_FACE+CCGUARD; X3HI_CELL = IHI_CELL+CCGUARD

          ! location in I,J,K od x2,x2,x3 axes:
          XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS

          ! Face coordinates in x1,x2,x3 axes:
          X1FACEP => YFACE;
          X2FACEP => ZFACE; X2CELLP => ZCELL
          X3FACEP => XFACE; X3CELLP => XCELL

      CASE(KAXIS)
          XYZ(IAXIS:KAXIS) = (/ XCELL(I), YCELL(J), ZFACE(K) /)

          ! x2, x3 axes:
          X2AXIS = IAXIS;  X3AXIS = JAXIS

          X1LO_FACE = KLO_FACE-CCGUARD; X1LO_CELL = KLO_CELL-CCGUARD
          X1HI_FACE = KHI_FACE+CCGUARD; X1HI_CELL = KHI_CELL+CCGUARD
          X2LO_FACE = ILO_FACE-CCGUARD; X2LO_CELL = ILO_CELL-CCGUARD
          X2HI_FACE = IHI_FACE+CCGUARD; X2HI_CELL = IHI_CELL+CCGUARD
          X3LO_FACE = JLO_FACE-CCGUARD; X3LO_CELL = JLO_CELL-CCGUARD
          X3HI_FACE = JHI_FACE+CCGUARD; X3HI_CELL = JHI_CELL+CCGUARD

          ! location in I,J,K od x2,x2,x3 axes:
          XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS

          ! Face coordinates in x1,x2,x3 axes:
          X1FACEP => ZFACE;
          X2FACEP => XFACE; X2CELLP => XCELL
          X3FACEP => YFACE; X3CELLP => YCELL

      END SELECT

      ! Initialize closest inboundary point data:
      DISTANCE            = 1._EB / GEOMEPS
      LASTDOTNVEC         =-1._EB / GEOMEPS
      FOUND_POINT         = .FALSE.
      XYZ_PP(IAXIS:KAXIS) = 0._EB
      FOUND_INBFC(1:3)    = 0

      ! Now LOW:HIGH side list of RCVEL faces, search for closest point to xyz:
      DO ICFACE=1,MESHES(NM)%IBM_RCFACE_VEL(ICF)%NCFACE
      DO LOWHIGH=LOW_IND,HIGH_IND

         IND_CC(IAXIS:KAXIS+1) = MESHES(NM)%IBM_RCFACE_VEL(ICF)%CELL_LIST(IAXIS:KAXIS+1,LOWHIGH,ICFACE)
         IF (IND_CC(1) == IBM_FTYPE_RGGAS) CYCLE ! Cell regular gasphase
         ICC = IND_CC(2)
         JCC = IND_CC(3)

         ! Find closest point and Inboundary cut-face:
         NFC_CC = MESHES(NM)%CUT_CELL(ICC)%CCELEM(1,JCC)
         DO CCFC=1,NFC_CC

            ICFC = MESHES(NM)%CUT_CELL(ICC)%CCELEM(CCFC+1,JCC)
            IF ( MESHES(NM)%CUT_CELL(ICC)%FACE_LIST(1,ICFC) /= IBM_FTYPE_CFINB) CYCLE

            ! Inboundary face number in CUT_FACE:
            INBFC     = MESHES(NM)%CUT_CELL(ICC)%FACE_LIST(4,ICFC)
            INBFC_LOC = MESHES(NM)%CUT_CELL(ICC)%FACE_LIST(5,ICFC)

            CALL GET_CLSPT_INBCF(NM,XYZ,INBFC,INBFC_LOC,XYZ_IP,DIST,FOUNDPT,INSEG)
            IF (FOUNDPT .AND. ((DIST-DISTANCE) < GEOMEPS)) THEN
                IF (INSEG) THEN
                    BODTRI(1:2)  = CUT_FACE(INBFC)%BODTRI(1:2,INBFC_LOC)
                    ! normal vector to boundary surface triangle:
                    IBOD    = BODTRI(1)
                    IWSEL   = BODTRI(2)
                    NVEC(IAXIS:KAXIS) = GEOMETRY(IBOD)%FACES_NORMAL(IAXIS:KAXIS,IWSEL)
                    DV(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS) - XYZ_IP(IAXIS:KAXIS)
                    NORM_DV = SQRT( DV(IAXIS)**2._EB + DV(JAXIS)**2._EB + DV(KAXIS)**2._EB )
                    IF(NORM_DV > GEOMEPS) THEN ! Point in segment not same as pt to interp to.
                       DV(IAXIS:KAXIS) = (1._EB / NORM_DV) * DV(IAXIS:KAXIS)
                       DOTNVEC = NVEC(IAXIS)*DV(IAXIS) + NVEC(JAXIS)*DV(JAXIS) + NVEC(KAXIS)*DV(KAXIS)
                       IF (DOTNVEC <= LASTDOTNVEC) CYCLE
                       LASTDOTNVEC = DOTNVEC
                    ENDIF
                ENDIF
                DISTANCE = DIST
                XYZ_PP(IAXIS:KAXIS)   = XYZ_IP(IAXIS:KAXIS)
                FOUND_INBFC(1:3) = (/ IBM_FTYPE_CFINB, INBFC, INBFC_LOC /) ! Inbound cut-face in CUT_FACE.
                FOUND_POINT = .TRUE.
            ENDIF

         ENDDO

         ! If point not found, all cut-faces boundary of the icc, jcc volume
         ! are GASPHASE. There must be a SOLID point in the boundary of the
         ! underlying Cartesian cell. this is the closest point:
         IF (.NOT.FOUND_POINT) THEN
             ! Search for for CUT_CELL(icc) vertex points or other solid points:
             CALL GET_CLOSEPT_CCVT(NM,XYZ,ICC,XYZ_IP,DIST,FOUNDPT,IFCPT,IFCPT_LOC)
             IF (FOUNDPT .AND. ((DIST-DISTANCE) < GEOMEPS)) THEN
                DISTANCE = DIST
                XYZ_PP(IAXIS:KAXIS)   = XYZ_IP(IAXIS:KAXIS)
                FOUND_INBFC(1:3) = (/ IBM_FTYPE_SVERT, IFCPT, IFCPT_LOC /) ! SOLID vertex in CUT_FACE.
                FOUND_POINT = .TRUE.
             ENDIF
         ENDIF

      ENDDO ! LOWHIGH
      ENDDO ! ICFACE

      IF (.NOT.FOUND_POINT) PRINT*, 'CF: Havent found closest point. ICF RCFACE_VEL=',ICF

      ! Here test if point in boundary and interpolation point coincide:
      IF (DISTANCE <= GEOMEPS) THEN

         ! Dummy values for external interpolation nodes:
         PTS2(IAXIS,1:MAX_INTERP_POINTS_PLANE) = I ! IJK triangle nodes
         PTS2(JAXIS,1:MAX_INTERP_POINTS_PLANE) = J
         PTS2(KAXIS,1:MAX_INTERP_POINTS_PLANE) = K

         ! Interpolation coeff s.t. interpolated value = boundary value:
         CI  = 1.0_EB
         CII = 0.0_EB
         CIII= 0.0_EB
         CIV = 0.0_EB
         CV  = 0.0_EB

      ELSE

         ! After this loop we have the closest boundary point to xyz and the
         ! cut-face it belongs. We need to use the normal out of the face (or the
         ! vertex to xyz direction to find fluid points on the stencil:
         ! The fluid points are points that lay on the plane outside in the
         ! largest Cartesian component direction of the normal.
         DIR_FCT = 1._EB
         P0(IAXIS:KAXIS) = XYZ_PP(IAXIS:KAXIS)
         P1(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS)
         DV(IAXIS:KAXIS) = DIR_FCT * ( XYZ(IAXIS:KAXIS) - XYZ_PP(IAXIS:KAXIS) )
         NORM_DV         = SQRT( DV(IAXIS)**2._EB + DV(JAXIS)**2._EB + DV(KAXIS)**2._EB )
         DV(IAXIS:KAXIS) = (1._EB / NORM_DV) * DV(IAXIS:KAXIS) ! NOUT

         ! Call routine that defines stencils:
         CALL GET_INTSTENCILS_FACE3D(NM,X1AXIS,X2AXIS,X3AXIS,XIAXIS,XJAXIS,XKAXIS,    &
                                     P0,P1,DV,X1FACEP,X2FACEP,X3FACEP,X2CELLP,X3CELLP,&
                                     DIR_FCT,CI,CII,CIII,CIV,CV,PTS2)

      ENDIF

      ! Add coefficients to REGC_FACE_VEL fields:
      MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK_CARTCEN(IAXIS:KAXIS,1:MAX_INTERP_POINTS_PLANE) =  &
                                            PTS2(IAXIS:KAXIS,1:MAX_INTERP_POINTS_PLANE) ! IJK ot triangle nodes
      MESHES(NM)%IBM_RCFACE_VEL(ICF)%XYZ_BP_CARTCEN(IAXIS:KAXIS) = XYZ_PP(IAXIS:KAXIS)  ! xyz of boundary pt
      MESHES(NM)%IBM_RCFACE_VEL(ICF)%INBFC_CARTCEN(1:3)   = FOUND_INBFC(1:3)            ! which INB cut-face boundary pt belongs to.
      MESHES(NM)%IBM_RCFACE_VEL(ICF)%INTCOEF_CARTCEN(1:5)= (/ CI, CII, CIII, CIV, CV /)

      NULLIFY(X1FACEP,X2FACEP,X3FACEP,X2CELLP,X3CELLP)

   ENDDO RCVEL_FACE_LOOP

   ! 3.:
   ! Loop by CUT_CELL, define interpolation stencils in Cartesian and cut
   ! cell centroids using the corresponding cells INBOUNDARY cut-faces:
   ! to be used for interpolation of H, etc.
   TESTVAR = IBM_CGSC
   CUT_CELL_LOOP2 : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH

      NCELL = MESHES(NM)%CUT_CELL(ICC)%NCELL
      IJK(IAXIS:KAXIS) = MESHES(NM)%CUT_CELL(ICC)%IJK(IAXIS:KAXIS)
      I = IJK(IAXIS); J = IJK(JAXIS); K = IJK(KAXIS)

      ! First Cartesian centroid:
      XYZ(IAXIS:KAXIS) = (/ XCELL(I), YCELL(J), ZCELL(K) /)

      ! Initialize closest inboundary point data:
      DISTANCE            = 1._EB / GEOMEPS
      LASTDOTNVEC         =-1._EB / GEOMEPS
      FOUND_POINT         = .FALSE.
      XYZ_PP(IAXIS:KAXIS) = 0._EB
      FOUND_INBFC(1:3)    = 0

      JCC_LOOP : DO JCC=1,NCELL

         ! Find closest point and Inboundary cut-face:
         NFC_CC = MESHES(NM)%CUT_CELL(ICC)%CCELEM(1,JCC)
         DO CCFC=1,NFC_CC

            ICFC = MESHES(NM)%CUT_CELL(ICC)%CCELEM(CCFC+1,JCC)
            IF ( MESHES(NM)%CUT_CELL(ICC)%FACE_LIST(1,ICFC) /= IBM_FTYPE_CFINB) CYCLE

            ! Inboundary face number in CUT_FACE:
            INBFC     = MESHES(NM)%CUT_CELL(ICC)%FACE_LIST(4,ICFC)
            INBFC_LOC = MESHES(NM)%CUT_CELL(ICC)%FACE_LIST(5,ICFC)

            CALL GET_CLSPT_INBCF(NM,XYZ,INBFC,INBFC_LOC,XYZ_IP,DIST,FOUNDPT,INSEG)
            IF (FOUNDPT .AND. ((DIST-DISTANCE) < GEOMEPS)) THEN
                IF (INSEG) THEN
                    BODTRI(1:2)  = CUT_FACE(INBFC)%BODTRI(1:2,INBFC_LOC)
                    ! normal vector to boundary surface triangle:
                    IBOD    = BODTRI(1)
                    IWSEL   = BODTRI(2)
                    NVEC(IAXIS:KAXIS) = GEOMETRY(IBOD)%FACES_NORMAL(IAXIS:KAXIS,IWSEL)
                    DV(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS) - XYZ_IP(IAXIS:KAXIS)
                    NORM_DV = SQRT( DV(IAXIS)**2._EB + DV(JAXIS)**2._EB + DV(KAXIS)**2._EB )
                    IF(NORM_DV > GEOMEPS) THEN ! Point in segment not same as pt to interp to.
                       DV(IAXIS:KAXIS) = (1._EB / NORM_DV) * DV(IAXIS:KAXIS)
                       DOTNVEC = NVEC(IAXIS)*DV(IAXIS) + NVEC(JAXIS)*DV(JAXIS) + NVEC(KAXIS)*DV(KAXIS)
                       IF (DOTNVEC <= LASTDOTNVEC) CYCLE
                       LASTDOTNVEC = DOTNVEC
                    ENDIF
                ENDIF
                DISTANCE = DIST
                XYZ_PP(IAXIS:KAXIS)   = XYZ_IP(IAXIS:KAXIS)
                FOUND_INBFC(1:3) = (/ IBM_FTYPE_CFINB, INBFC, INBFC_LOC /) ! Inbound cut-face in CUT_FACE.
                FOUND_POINT = .TRUE.
            ENDIF

         ENDDO

         ! If point not found, all cut-faces boundary of the icc, jcc volume
         ! are GASPHASE. There must be a SOLID point in the boundary of the
         ! underlying Cartesian cell. this is the closest point:
         IF (.NOT.FOUND_POINT) THEN
             ! Search for for CUT_CELL(icc) vertex points or other solid points:
             CALL GET_CLOSEPT_CCVT(NM,XYZ,ICC,XYZ_IP,DIST,FOUNDPT,IFCPT,IFCPT_LOC)
             IF (FOUNDPT .AND. ((DIST-DISTANCE) < GEOMEPS)) THEN
                DISTANCE = DIST
                XYZ_PP(IAXIS:KAXIS)   = XYZ_IP(IAXIS:KAXIS)
                FOUND_INBFC(1:3) = (/ IBM_FTYPE_SVERT, IFCPT, IFCPT_LOC /) ! SOLID vertex in CUT_FACE.
                FOUND_POINT = .TRUE.
             ENDIF
         ENDIF

      ENDDO JCC_LOOP

      IF (.NOT.FOUND_POINT) PRINT*, 'CF: Havent found closest point CART CELL. ICC=',ICC

      ! Here test if point in boundary and interpolation point coincide:
      IF (DISTANCE <= GEOMEPS) THEN

         ! Dummy values for external interpolation nodes:
         PTS2(IAXIS,1:MAX_INTERP_POINTS_PLANE) = I ! IJK triangle nodes
         PTS2(JAXIS,1:MAX_INTERP_POINTS_PLANE) = J
         PTS2(KAXIS,1:MAX_INTERP_POINTS_PLANE) = K

         ! Interpolation coeff s.t. interpolated value = boundary value:
         CI  = 1.0_EB
         CII = 0.0_EB
         CIII= 0.0_EB
         CIV = 0.0_EB
         CV  = 0.0_EB

      ELSE

         ! After this loop we have the closest boundary point to xyz and the
         ! cut-face it belongs. We need to use the normal out of the face (or the
         ! vertex to xyz direction to find fluid points on the stencil:
         ! The fluid points are points that lay on the plane outside in the
         ! largest Cartesian component direction of the normal.
         DIR_FCT = 1._EB
         IF (FOUND_INBFC(1) == IBM_FTYPE_CFINB) THEN ! closest point in INBOUNDARY cut-face.
             BODTRI(1:2) = CUT_FACE(FOUND_INBFC(2))%BODTRI(1:2,FOUND_INBFC(3))
             ! normal vector to boundary surface triangle:
             IBOD    = BODTRI(1)
             IWSEL   = BODTRI(2)
             NVEC(IAXIS:KAXIS) = GEOMETRY(IBOD)%FACES_NORMAL(IAXIS:KAXIS,IWSEL)
             DV(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS) - XYZ_PP(IAXIS:KAXIS)
             DOTNVEC = NVEC(IAXIS)*DV(IAXIS) + NVEC(JAXIS)*DV(JAXIS) + NVEC(KAXIS)*DV(KAXIS)

             IF (DOTNVEC < 0._EB) DIR_FCT = -1._EB ! if normal to triangle has opposite dir change
                                                   ! search direction.
         ENDIF

         ! Versor to GASPHASE:
         IF (DIR_FCT > 0._EB) THEN ! Versor from boundary point to centroid
             P0(IAXIS:KAXIS) = XYZ_PP(IAXIS:KAXIS)
             P1(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS)
         ELSE ! Viceversa
             P0(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS)
             P1(IAXIS:KAXIS) = XYZ_PP(IAXIS:KAXIS)
         ENDIF
         DV(IAXIS:KAXIS)   = DIR_FCT * ( XYZ(IAXIS:KAXIS) - XYZ_PP(IAXIS:KAXIS) )
         NORM_DV           = SQRT( DV(IAXIS)**2._EB + DV(JAXIS)**2._EB + DV(KAXIS)**2._EB )
         DV(IAXIS:KAXIS) = (1._EB / NORM_DV) * DV(IAXIS:KAXIS) ! NOUT

         ! Call routine that defines stencils:
         CALL GET_INTSTENCILS_VOL3D(NM,P0,P1,DV,DIR_FCT,TESTVAR,CI,CII,CIII,CIV,CV,PTS2)

      ENDIF

      ! Interpolation coefficients for Cartesian cell center:
      MESHES(NM)%CUT_CELL(ICC)%IJK_CARTCEN(IAXIS:KAXIS,1:MAX_INTERP_POINTS_PLANE) = &
                           PTS2(IAXIS:KAXIS,1:MAX_INTERP_POINTS_PLANE) ! IJK ot triangle nodes
      MESHES(NM)%CUT_CELL(ICC)%XYZ_BP_CARTCEN(IAXIS:KAXIS) = XYZ_PP(IAXIS:KAXIS) ! xyz of boundary pt
      MESHES(NM)%CUT_CELL(ICC)%INBFC_CARTCEN(1:3)   = FOUND_INBFC(1:3) ! INB cut-face pt belongs to.
      MESHES(NM)%CUT_CELL(ICC)%INTCOEF_CARTCEN(1:5)= (/ CI, CII, CIII, CIV, CV /)

      ! Now cut-cell volumes:
      ICELL_LOOP : DO ICELL=1,NCELL

         ! Centroid location:
         XYZ(IAXIS:KAXIS) = MESHES(NM)%CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,ICELL)

         ! Initialize closest inboundary point data:
         DISTANCE            = 1._EB / GEOMEPS
         LASTDOTNVEC         =-1._EB / GEOMEPS
         FOUND_POINT         = .FALSE.
         XYZ_PP(IAXIS:KAXIS) = 0._EB
         FOUND_INBFC(1:3)    = 0
         JCC = ICELL

         ! Find closest point and Inboundary cut-face:
         NFC_CC = MESHES(NM)%CUT_CELL(ICC)%CCELEM(1,JCC)
         DO CCFC=1,NFC_CC

            ICFC = MESHES(NM)%CUT_CELL(ICC)%CCELEM(CCFC+1,JCC)
            IF ( MESHES(NM)%CUT_CELL(ICC)%FACE_LIST(1,ICFC) /= IBM_FTYPE_CFINB) CYCLE

            ! Inboundary face number in CUT_FACE:
            INBFC     = MESHES(NM)%CUT_CELL(ICC)%FACE_LIST(4,ICFC)
            INBFC_LOC = MESHES(NM)%CUT_CELL(ICC)%FACE_LIST(5,ICFC)

            CALL GET_CLSPT_INBCF(NM,XYZ,INBFC,INBFC_LOC,XYZ_IP,DIST,FOUNDPT,INSEG)
            IF (FOUNDPT .AND. ((DIST-DISTANCE) < GEOMEPS)) THEN
                IF (INSEG) THEN
                    BODTRI(1:2)  = CUT_FACE(INBFC)%BODTRI(1:2,INBFC_LOC)
                    ! normal vector to boundary surface triangle:
                    IBOD    = BODTRI(1)
                    IWSEL   = BODTRI(2)
                    NVEC(IAXIS:KAXIS) = GEOMETRY(IBOD)%FACES_NORMAL(IAXIS:KAXIS,IWSEL)
                    DV(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS) - XYZ_IP(IAXIS:KAXIS)
                    NORM_DV = SQRT( DV(IAXIS)**2._EB + DV(JAXIS)**2._EB + DV(KAXIS)**2._EB )
                    IF(NORM_DV > GEOMEPS) THEN ! Point in segment not same as pt to interp to.
                       DV(IAXIS:KAXIS) = (1._EB / NORM_DV) * DV(IAXIS:KAXIS)
                       DOTNVEC = NVEC(IAXIS)*DV(IAXIS) + NVEC(JAXIS)*DV(JAXIS) + NVEC(KAXIS)*DV(KAXIS)
                       IF (DOTNVEC <= LASTDOTNVEC) CYCLE
                       LASTDOTNVEC = DOTNVEC
                    ENDIF
                ENDIF
                DISTANCE = DIST
                XYZ_PP(IAXIS:KAXIS)   = XYZ_IP(IAXIS:KAXIS)
                FOUND_INBFC(1:3) = (/ IBM_FTYPE_CFINB, INBFC, INBFC_LOC /) ! Inbound cut-face in CUT_FACE.
                FOUND_POINT = .TRUE.
            ENDIF

         ENDDO

         ! If point not found, all cut-faces boundary of the icc, jcc volume
         ! are GASPHASE. There must be a SOLID point in the boundary of the
         ! underlying Cartesian cell. this is the closest point:
         IF (.NOT.FOUND_POINT) THEN
             ! Search for for CUT_CELL(icc) vertex points or other solid points:
             CALL GET_CLOSEPT_CCVT(NM,XYZ,ICC,XYZ_IP,DIST,FOUNDPT,IFCPT,IFCPT_LOC)
             IF (FOUNDPT .AND. ((DIST-DISTANCE) < GEOMEPS)) THEN
                DISTANCE = DIST
                XYZ_PP(IAXIS:KAXIS)   = XYZ_IP(IAXIS:KAXIS)
                FOUND_INBFC(1:3) = (/ IBM_FTYPE_SVERT, IFCPT, IFCPT_LOC /) ! SOLID vertex in CUT_FACE.
                FOUND_POINT = .TRUE.
             ENDIF
         ENDIF

         IF (.NOT.FOUND_POINT) PRINT*, 'CF: Havent found closest point CUT CELL. ICC,JCC=',ICC,JCC

         ! Here test if point in boundary and interpolation point coincide:
         IF (DISTANCE <= GEOMEPS) THEN

            ! Dummy values for external interpolation nodes:
            PTS2(IAXIS,1:MAX_INTERP_POINTS_PLANE) = I ! IJK triangle nodes
            PTS2(JAXIS,1:MAX_INTERP_POINTS_PLANE) = J
            PTS2(KAXIS,1:MAX_INTERP_POINTS_PLANE) = K

            ! Interpolation coeff s.t. interpolated value = boundary value:
            CI  = 1.0_EB
            CII = 0.0_EB
            CIII= 0.0_EB
            CIV = 0.0_EB
            CV  = 0.0_EB

         ELSE
            ! After this loop we have the closest boundary point to xyz and the
            ! cut-face it belongs. We need to use the normal out of the face (or the
            ! vertex to xyz direction to find fluid points on the stencil:
            ! The fluid points are points that lay on the plane outside in the
            ! largest Cartesian component direction of the normal.
            DIR_FCT = 1._EB
            IF (FOUND_INBFC(1) == IBM_FTYPE_CFINB) THEN ! closest point in INBOUNDARY cut-face.
                BODTRI(1:2) = CUT_FACE(FOUND_INBFC(2))%BODTRI(1:2,FOUND_INBFC(3))
                ! normal vector to boundary surface triangle:
                IBOD    = BODTRI(1)
                IWSEL   = BODTRI(2)
                NVEC(IAXIS:KAXIS) = GEOMETRY(IBOD)%FACES_NORMAL(IAXIS:KAXIS,IWSEL)
                DV(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS) - XYZ_PP(IAXIS:KAXIS)
                DOTNVEC = NVEC(IAXIS)*DV(IAXIS) + NVEC(JAXIS)*DV(JAXIS) + NVEC(KAXIS)*DV(KAXIS)

                IF (DOTNVEC < 0._EB) DIR_FCT = -1._EB ! if normal to triangle has opposite dir change
                                                      ! search direction.
            ENDIF

            ! Versor to GASPHASE:
            IF (DIR_FCT > 0._EB) THEN ! Versor from boundary point to centroid
                P0(IAXIS:KAXIS) = XYZ_PP(IAXIS:KAXIS)
                P1(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS)
            ELSE ! Viceversa
                P0(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS)
                P1(IAXIS:KAXIS) = XYZ_PP(IAXIS:KAXIS)
            ENDIF
            DV(IAXIS:KAXIS)   = DIR_FCT * ( XYZ(IAXIS:KAXIS) - XYZ_PP(IAXIS:KAXIS) )
            NORM_DV           = SQRT( DV(IAXIS)**2._EB + DV(JAXIS)**2._EB + DV(KAXIS)**2._EB )
            DV(IAXIS:KAXIS) = (1._EB / NORM_DV) * DV(IAXIS:KAXIS) ! NOUT

            ! Call routine that defines stencils:
            CALL GET_INTSTENCILS_VOL3D(NM,P0,P1,DV,DIR_FCT,TESTVAR,CI,CII,CIII,CIV,CV,PTS2)

         ENDIF

         ! Interpolation coefficients for Cartesian cell center:
         MESHES(NM)%CUT_CELL(ICC)%IJK_CCCEN(IAXIS:KAXIS,1:MAX_INTERP_POINTS_PLANE,ICELL) = &
                                           PTS2(IAXIS:KAXIS,1:MAX_INTERP_POINTS_PLANE) ! IJK ot triangle nodes
         MESHES(NM)%CUT_CELL(ICC)%XYZ_BP_CCCEN(IAXIS:KAXIS,ICELL) = XYZ_PP(IAXIS:KAXIS) ! xyz of boundary pt
         MESHES(NM)%CUT_CELL(ICC)%INBFC_CCCEN(1:3,ICELL) = FOUND_INBFC(1:3) ! INB cut-face pt belongs to.
         MESHES(NM)%CUT_CELL(ICC)%INTCOEF_CCCEN(1:5,ICELL) = (/ CI, CII, CIII, CIV, CV /)

      ENDDO ICELL_LOOP


   ENDDO CUT_CELL_LOOP2


   ! 4.:
   ! Finally work on RCELL_H, in the same manner as for CUT_CELL
   ! Cartesian cell centroids:
   TESTVAR = IBM_CCNC
   NRCELL_LOOP : DO IRCELL=1,MESHES(NM)%IBM_NRCELL_H

      I = MESHES(NM)%IBM_RCELL_H(IRCELL)%IJK(IAXIS)
      J = MESHES(NM)%IBM_RCELL_H(IRCELL)%IJK(JAXIS)
      K = MESHES(NM)%IBM_RCELL_H(IRCELL)%IJK(KAXIS)

      ! Cartesian centroid:
      XYZ(IAXIS:KAXIS) = (/ XCELL(I), YCELL(J), ZCELL(K) /)

      ! Initialize closest inboundary point data:
      DISTANCE            = 1._EB / GEOMEPS
      LASTDOTNVEC         =-1._EB / GEOMEPS
      FOUND_POINT         = .FALSE.
      XYZ_PP(IAXIS:KAXIS) = 0._EB
      FOUND_INBFC(1:3)    = 0

      ! Now loop on related cut-cells
      ICC2_LOOP : DO ICC2=1,MESHES(NM)%IBM_RCELL_H(IRCELL)%NCCELL

         ICC   = MESHES(NM)%IBM_RCELL_H(IRCELL)%CELL_LIST(ICC2)
         NCELL = MESHES(NM)%CUT_CELL(ICC)%NCELL

         JCC_LOOP2 : DO JCC=1,NCELL

            ! Find closest point and Inboundary cut-face:
            NFC_CC = MESHES(NM)%CUT_CELL(ICC)%CCELEM(1,JCC)
            DO CCFC=1,NFC_CC

               ICFC = MESHES(NM)%CUT_CELL(ICC)%CCELEM(CCFC+1,JCC)
               IF ( MESHES(NM)%CUT_CELL(ICC)%FACE_LIST(1,ICFC) /= IBM_FTYPE_CFINB) CYCLE

               ! Inboundary face number in CUT_FACE:
               INBFC     = MESHES(NM)%CUT_CELL(ICC)%FACE_LIST(4,ICFC)
               INBFC_LOC = MESHES(NM)%CUT_CELL(ICC)%FACE_LIST(5,ICFC)

               CALL GET_CLSPT_INBCF(NM,XYZ,INBFC,INBFC_LOC,XYZ_IP,DIST,FOUNDPT,INSEG)
               IF (FOUNDPT .AND. ((DIST-DISTANCE) < GEOMEPS)) THEN
                   IF (INSEG) THEN
                       BODTRI(1:2)  = CUT_FACE(INBFC)%BODTRI(1:2,INBFC_LOC)
                       ! normal vector to boundary surface triangle:
                       IBOD    = BODTRI(1)
                       IWSEL   = BODTRI(2)
                       NVEC(IAXIS:KAXIS) = GEOMETRY(IBOD)%FACES_NORMAL(IAXIS:KAXIS,IWSEL)
                       DV(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS) - XYZ_IP(IAXIS:KAXIS)
                       NORM_DV = SQRT( DV(IAXIS)**2._EB + DV(JAXIS)**2._EB + DV(KAXIS)**2._EB )
                       IF(NORM_DV > GEOMEPS) THEN ! Point in segment not same as pt to interp to.
                          DV(IAXIS:KAXIS) = (1._EB / NORM_DV) * DV(IAXIS:KAXIS)
                          DOTNVEC = NVEC(IAXIS)*DV(IAXIS) + NVEC(JAXIS)*DV(JAXIS) + NVEC(KAXIS)*DV(KAXIS)
                          IF (DOTNVEC <= LASTDOTNVEC) CYCLE
                          LASTDOTNVEC = DOTNVEC
                       ENDIF
                   ENDIF
                   DISTANCE = DIST
                   XYZ_PP(IAXIS:KAXIS)   = XYZ_IP(IAXIS:KAXIS)
                   FOUND_INBFC(1:3) = (/ IBM_FTYPE_CFINB, INBFC, INBFC_LOC /) ! Inbound cut-face in CUT_FACE.
                   FOUND_POINT = .TRUE.
               ENDIF

            ENDDO

            ! If point not found, all cut-faces boundary of the icc, jcc volume
            ! are GASPHASE. There must be a SOLID point in the boundary of the
            ! underlying Cartesian cell. this is the closest point:
            IF (.NOT.FOUND_POINT) THEN
                ! Search for for CUT_CELL(icc) vertex points or other solid points:
                CALL GET_CLOSEPT_CCVT(NM,XYZ,ICC,XYZ_IP,DIST,FOUNDPT,IFCPT,IFCPT_LOC)
                IF (FOUNDPT .AND. ((DIST-DISTANCE) < GEOMEPS)) THEN
                   DISTANCE = DIST
                   XYZ_PP(IAXIS:KAXIS)   = XYZ_IP(IAXIS:KAXIS)
                   FOUND_INBFC(1:3) = (/ IBM_FTYPE_SVERT, IFCPT, IFCPT_LOC /) ! SOLID vertex in CUT_FACE.
                   FOUND_POINT = .TRUE.
                ENDIF
            ENDIF

         ENDDO JCC_LOOP2

      ENDDO ICC2_LOOP

      IF (.NOT.FOUND_POINT) PRINT*, 'CC Cart on IBM_RCELL_H: Havent found closest point.',IRCELL

      ! Here test if point in boundary and interpolation point coincide:
      IF (DISTANCE <= GEOMEPS) THEN

         ! Dummy values for external interpolation nodes:
         PTS2(IAXIS,1:MAX_INTERP_POINTS_PLANE) = I ! IJK triangle nodes
         PTS2(JAXIS,1:MAX_INTERP_POINTS_PLANE) = J
         PTS2(KAXIS,1:MAX_INTERP_POINTS_PLANE) = K

         ! Interpolation coeff s.t. interpolated value = boundary value:
         CI  = 1.0_EB
         CII = 0.0_EB
         CIII= 0.0_EB
         CIV = 0.0_EB
         CV  = 0.0_EB

      ELSE

         ! After this loop we have the closest boundary point to xyz and the
         ! cut-face it belongs. We need to use the normal out of the face (or the
         ! vertex to xyz direction to find fluid points on the stencil:
         ! The fluid points are points that lay on the plane outside in the
         ! largest Cartesian component direction of the normal.
         DIR_FCT = 1._EB

         ! Versor to GASPHASE:
         P0(IAXIS:KAXIS) = XYZ_PP(IAXIS:KAXIS)
         P1(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS)
         DV(IAXIS:KAXIS) = DIR_FCT * ( XYZ(IAXIS:KAXIS) - XYZ_PP(IAXIS:KAXIS) )
         NORM_DV         = SQRT( DV(IAXIS)**2._EB + DV(JAXIS)**2._EB + DV(KAXIS)**2._EB )
         DV(IAXIS:KAXIS) = (1._EB / NORM_DV) * DV(IAXIS:KAXIS) ! NOUT

         ! Call routine that defines stencils:
         CALL GET_INTSTENCILS_VOL3D(NM,P0,P1,DV,DIR_FCT,TESTVAR,CI,CII,CIII,CIV,CV,PTS2)

      ENDIF

      ! Interpolation coefficients for Cartesian cell center:
      MESHES(NM)%IBM_RCELL_H(IRCELL)%IJK_CARTCEN(IAXIS:KAXIS,1:MAX_INTERP_POINTS_PLANE) = &
                           PTS2(IAXIS:KAXIS,1:MAX_INTERP_POINTS_PLANE) ! IJK ot triangle nodes
      MESHES(NM)%IBM_RCELL_H(IRCELL)%XYZ_BP_CARTCEN(IAXIS:KAXIS) = XYZ_PP(IAXIS:KAXIS) ! xyz of boundary pt
      MESHES(NM)%IBM_RCELL_H(IRCELL)%INBFC_CARTCEN(1:3)   = FOUND_INBFC(1:3) ! INB cut-face pt belongs to.
      MESHES(NM)%IBM_RCELL_H(IRCELL)%INTCOEF_CARTCEN(1:5)= (/ CI, CII, CIII, CIV, CV /)

   ENDDO NRCELL_LOOP


   ! Up to this point we have the cut-face, cut-cell (these both underlaying Cartesian and unstructured), regular
   ! forced faces and regular interpolated cells.
   ! 1. CUT_FACE -> IJK_CARTCEN,CFCEN; XYZ_BP_CARTCEN,CFCEN; INBCF_CARTCEN,CFCEN; INTCOEF_CARTCEN,CFCEN
   ! 2. IBM_RCFACE_VEL -> IJK_CARTCEN; XYZ_BP_CARTCEN; INBCF_CARTCEN; INTCOEF_CARTCEN
   ! 3. CUT_CELL -> IJK_CARTCEN,CCCEN; XYZ_BP_CARTCEN,CCCEN; INBCF_CARTCEN,CCCEN; INTCOEF_CARTCEN,CCCEN
   ! 4. IBM_RCELL_H -> IJK_CARTCEN; XYZ_BP_CARTCEN; INBCF_CARTCEN; INTCOEF_CARTCEN

   DO NOM=1,NMESHES
      ! Also considers the case NOM==NM as a regular case.
      ! Face Variables:
      ALLOCATE(MESHES(NM)%OMESH(NOM)%IIO_FC_R(DELTA_FC))
      ALLOCATE(MESHES(NM)%OMESH(NOM)%JJO_FC_R(DELTA_FC))
      ALLOCATE(MESHES(NM)%OMESH(NOM)%KKO_FC_R(DELTA_FC))
      ALLOCATE(MESHES(NM)%OMESH(NOM)%AXS_FC_R(DELTA_FC))
      ! Cell Variables:
      ALLOCATE(MESHES(NM)%OMESH(NOM)%IIO_CC_R(DELTA_FC))
      ALLOCATE(MESHES(NM)%OMESH(NOM)%JJO_CC_R(DELTA_FC))
      ALLOCATE(MESHES(NM)%OMESH(NOM)%KKO_CC_R(DELTA_FC))
   ENDDO

   ! Figure out which Regular face locations for this mesh are required for interpolation:
   ALLOCATE(IJKFACE2(LOW_IND:HIGH_IND,ISTR:IEND,JSTR:JEND,KSTR:KEND,IAXIS:KAXIS)); IJKFACE2 = IBM_UNDEFINED

   ! Figure out which other meshes this mesh will receive face centered variables from:
   ! Cut-faces stencils:
   DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      IF (CUT_FACE(ICF)%STATUS /= IBM_GASPHASE) CYCLE
      X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)

      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         ! First undelaying Cartesian:
         DO IPT=1,MAX_INTERP_POINTS_PLANE
            I = CUT_FACE(ICF)%IJK_CARTCEN(IAXIS,IPT)
            J = CUT_FACE(ICF)%IJK_CARTCEN(JAXIS,IPT)
            K = CUT_FACE(ICF)%IJK_CARTCEN(KAXIS,IPT)
            ! If face not counted yet:
            IF (IJKFACE2(LOW_IND,I,J,K,X1AXIS) < 1 ) THEN
               FLGX = (I >= ILO_FACE) .AND. (I <= IHI_FACE)
               FLGY = (J >= JLO_CELL) .AND. (J <= JHI_CELL)
               FLGZ = (K >= KLO_CELL) .AND. (K <= KHI_CELL)
               INNM = FLGX .AND. FLGY .AND. FLGZ
               IF (INNM) THEN
                  NOM=NM; IIO=I; JJO=J; KKO=K
               ELSE
                  CALL SEARCH_OTHER_MESHES_FACE(X1AXIS,XFACE(I),YCELL(J),ZCELL(K),NOM,IIO,JJO,KKO)
               ENDIF
               IF (NOM > 0) THEN ! Add to IIO_FC_R,JJO_FC_R,KKO_FC_R,AXIS_FC_R list,
                                 ! and add 1 to NFC_R for OMESH(NOM).
                  ! Use Automatic reallocation:
                  OMESH(NOM)%NFCC_R(1)= OMESH(NOM)%NFCC_R(1) + 1
                  SIZE_REC=SIZE(OMESH(NOM)%IIO_FC_R,DIM=1)
                  IF(OMESH(NOM)%NFCC_R(1) > SIZE_REC) THEN
                      ALLOCATE(IIO_FC_R_AUX(SIZE_REC),JJO_FC_R_AUX(SIZE_REC),KKO_FC_R_AUX(SIZE_REC));
                      ALLOCATE(AXS_FC_R_AUX(SIZE_REC))
                      IIO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%IIO_FC_R(1:SIZE_REC)
                      JJO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%JJO_FC_R(1:SIZE_REC)
                      KKO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%KKO_FC_R(1:SIZE_REC)
                      AXS_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%AXS_FC_R(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%IIO_FC_R); ALLOCATE(OMESH(NOM)%IIO_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%IIO_FC_R(1:SIZE_REC)=IIO_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%JJO_FC_R); ALLOCATE(OMESH(NOM)%JJO_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%JJO_FC_R(1:SIZE_REC)=JJO_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%KKO_FC_R); ALLOCATE(OMESH(NOM)%KKO_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%KKO_FC_R(1:SIZE_REC)=KKO_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%AXS_FC_R); ALLOCATE(OMESH(NOM)%AXS_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%AXS_FC_R(1:SIZE_REC)=AXS_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(IIO_FC_R_AUX,JJO_FC_R_AUX,KKO_FC_R_AUX,AXS_FC_R_AUX)
                  ENDIF
                  OMESH(NOM)%IIO_FC_R(OMESH(NOM)%NFCC_R(1)) = IIO
                  OMESH(NOM)%JJO_FC_R(OMESH(NOM)%NFCC_R(1)) = JJO
                  OMESH(NOM)%KKO_FC_R(OMESH(NOM)%NFCC_R(1)) = KKO
                  OMESH(NOM)%AXS_FC_R(OMESH(NOM)%NFCC_R(1)) = X1AXIS
                  IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS) = (/ NOM, OMESH(NOM)%NFCC_R(1) /)
               ENDIF
            ENDIF
            CUT_FACE(ICF)%NOMIND_CARTCEN(LOW_IND:HIGH_IND,IPT) = IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS)
         ENDDO
         ! Then gasphase cut-faces:
         DO IFACE=1,CUT_FACE(ICF)%NFACE
            DO IPT=1,MAX_INTERP_POINTS_PLANE
               I = CUT_FACE(ICF)%IJK_CFCEN(IAXIS,IPT,IFACE)
               J = CUT_FACE(ICF)%IJK_CFCEN(JAXIS,IPT,IFACE)
               K = CUT_FACE(ICF)%IJK_CFCEN(KAXIS,IPT,IFACE)
               ! If face not counted yet:
               IF (IJKFACE2(LOW_IND,I,J,K,X1AXIS) < 1 ) THEN
                  FLGX = (I >= ILO_FACE) .AND. (I <= IHI_FACE)
                  FLGY = (J >= JLO_CELL) .AND. (J <= JHI_CELL)
                  FLGZ = (K >= KLO_CELL) .AND. (K <= KHI_CELL)
                  INNM = FLGX .AND. FLGY .AND. FLGZ
                  IF (INNM) THEN
                     NOM=NM; IIO=I; JJO=J; KKO=K
                  ELSE
                     CALL SEARCH_OTHER_MESHES_FACE(X1AXIS,XFACE(I),YCELL(J),ZCELL(K),NOM,IIO,JJO,KKO)
                  ENDIF
                  IF (NOM > 0) THEN ! Add to IIO_FC_R,JJO_FC_R,KKO_FC_R,AXIS_FC_R list,
                                    ! and add 1 to NFC_R for OMESH(NOM).
                     ! Use Automatic reallocation:
                     OMESH(NOM)%NFCC_R(1)= OMESH(NOM)%NFCC_R(1) + 1
                     SIZE_REC=SIZE(OMESH(NOM)%IIO_FC_R,DIM=1)
                     IF(OMESH(NOM)%NFCC_R(1) > SIZE_REC) THEN
                         ALLOCATE(IIO_FC_R_AUX(SIZE_REC),JJO_FC_R_AUX(SIZE_REC),KKO_FC_R_AUX(SIZE_REC));
                         ALLOCATE(AXS_FC_R_AUX(SIZE_REC))
                         IIO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%IIO_FC_R(1:SIZE_REC)
                         JJO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%JJO_FC_R(1:SIZE_REC)
                         KKO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%KKO_FC_R(1:SIZE_REC)
                         AXS_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%AXS_FC_R(1:SIZE_REC)
                         DEALLOCATE(OMESH(NOM)%IIO_FC_R); ALLOCATE(OMESH(NOM)%IIO_FC_R(SIZE_REC+DELTA_FC))
                         OMESH(NOM)%IIO_FC_R(1:SIZE_REC)=IIO_FC_R_AUX(1:SIZE_REC)
                         DEALLOCATE(OMESH(NOM)%JJO_FC_R); ALLOCATE(OMESH(NOM)%JJO_FC_R(SIZE_REC+DELTA_FC))
                         OMESH(NOM)%JJO_FC_R(1:SIZE_REC)=JJO_FC_R_AUX(1:SIZE_REC)
                         DEALLOCATE(OMESH(NOM)%KKO_FC_R); ALLOCATE(OMESH(NOM)%KKO_FC_R(SIZE_REC+DELTA_FC))
                         OMESH(NOM)%KKO_FC_R(1:SIZE_REC)=KKO_FC_R_AUX(1:SIZE_REC)
                         DEALLOCATE(OMESH(NOM)%AXS_FC_R); ALLOCATE(OMESH(NOM)%AXS_FC_R(SIZE_REC+DELTA_FC))
                         OMESH(NOM)%AXS_FC_R(1:SIZE_REC)=AXS_FC_R_AUX(1:SIZE_REC)
                         DEALLOCATE(IIO_FC_R_AUX,JJO_FC_R_AUX,KKO_FC_R_AUX,AXS_FC_R_AUX)
                     ENDIF
                     OMESH(NOM)%IIO_FC_R(OMESH(NOM)%NFCC_R(1)) = IIO
                     OMESH(NOM)%JJO_FC_R(OMESH(NOM)%NFCC_R(1)) = JJO
                     OMESH(NOM)%KKO_FC_R(OMESH(NOM)%NFCC_R(1)) = KKO
                     OMESH(NOM)%AXS_FC_R(OMESH(NOM)%NFCC_R(1)) = X1AXIS
                     IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS) = (/ NOM, OMESH(NOM)%NFCC_R(1) /)
                  ENDIF
               ENDIF
               CUT_FACE(ICF)%NOMIND_CFCEN(LOW_IND:HIGH_IND,IPT,IFACE) = IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS)
            ENDDO
         ENDDO

      CASE(JAXIS)
         ! First undelaying Cartesian:
         DO IPT=1,MAX_INTERP_POINTS_PLANE
            I = CUT_FACE(ICF)%IJK_CARTCEN(IAXIS,IPT)
            J = CUT_FACE(ICF)%IJK_CARTCEN(JAXIS,IPT)
            K = CUT_FACE(ICF)%IJK_CARTCEN(KAXIS,IPT)
            ! If face not counted yet:
            IF (IJKFACE2(LOW_IND,I,J,K,X1AXIS) < 1 ) THEN
               FLGX = (I >= ILO_CELL) .AND. (I <= IHI_CELL)
               FLGY = (J >= JLO_FACE) .AND. (J <= JHI_FACE)
               FLGZ = (K >= KLO_CELL) .AND. (K <= KHI_CELL)
               INNM = FLGX .AND. FLGY .AND. FLGZ
               IF (INNM) THEN
                  NOM=NM; IIO=I; JJO=J; KKO=K
               ELSE
                  CALL SEARCH_OTHER_MESHES_FACE(X1AXIS,XCELL(I),YFACE(J),ZCELL(K),NOM,IIO,JJO,KKO)
               ENDIF
               IF (NOM > 0) THEN ! Add to IIO_FC_R,JJO_FC_R,KKO_FC_R,AXIS_FC_R list,
                                 ! and add 1 to NFC_R for OMESH(NOM).
                  ! Use Automatic reallocation:
                  OMESH(NOM)%NFCC_R(1)= OMESH(NOM)%NFCC_R(1) + 1
                  SIZE_REC=SIZE(OMESH(NOM)%IIO_FC_R,DIM=1)
                  IF(OMESH(NOM)%NFCC_R(1) > SIZE_REC) THEN
                      ALLOCATE(IIO_FC_R_AUX(SIZE_REC),JJO_FC_R_AUX(SIZE_REC),KKO_FC_R_AUX(SIZE_REC));
                      ALLOCATE(AXS_FC_R_AUX(SIZE_REC))
                      IIO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%IIO_FC_R(1:SIZE_REC)
                      JJO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%JJO_FC_R(1:SIZE_REC)
                      KKO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%KKO_FC_R(1:SIZE_REC)
                      AXS_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%AXS_FC_R(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%IIO_FC_R); ALLOCATE(OMESH(NOM)%IIO_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%IIO_FC_R(1:SIZE_REC)=IIO_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%JJO_FC_R); ALLOCATE(OMESH(NOM)%JJO_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%JJO_FC_R(1:SIZE_REC)=JJO_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%KKO_FC_R); ALLOCATE(OMESH(NOM)%KKO_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%KKO_FC_R(1:SIZE_REC)=KKO_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%AXS_FC_R); ALLOCATE(OMESH(NOM)%AXS_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%AXS_FC_R(1:SIZE_REC)=AXS_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(IIO_FC_R_AUX,JJO_FC_R_AUX,KKO_FC_R_AUX,AXS_FC_R_AUX)
                  ENDIF
                  OMESH(NOM)%IIO_FC_R(OMESH(NOM)%NFCC_R(1)) = IIO
                  OMESH(NOM)%JJO_FC_R(OMESH(NOM)%NFCC_R(1)) = JJO
                  OMESH(NOM)%KKO_FC_R(OMESH(NOM)%NFCC_R(1)) = KKO
                  OMESH(NOM)%AXS_FC_R(OMESH(NOM)%NFCC_R(1)) = X1AXIS
                  IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS) = (/ NOM, OMESH(NOM)%NFCC_R(1) /)
               ENDIF
            ENDIF
            CUT_FACE(ICF)%NOMIND_CARTCEN(LOW_IND:HIGH_IND,IPT) = IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS)
         ENDDO
         ! Then gasphase cut-faces:
         DO IFACE=1,CUT_FACE(ICF)%NFACE
            DO IPT=1,MAX_INTERP_POINTS_PLANE
               I = CUT_FACE(ICF)%IJK_CFCEN(IAXIS,IPT,IFACE)
               J = CUT_FACE(ICF)%IJK_CFCEN(JAXIS,IPT,IFACE)
               K = CUT_FACE(ICF)%IJK_CFCEN(KAXIS,IPT,IFACE)
               ! If face not counted yet:
               IF (IJKFACE2(LOW_IND,I,J,K,X1AXIS) < 1 ) THEN
                  FLGX = (I >= ILO_CELL) .AND. (I <= IHI_CELL)
                  FLGY = (J >= JLO_FACE) .AND. (J <= JHI_FACE)
                  FLGZ = (K >= KLO_CELL) .AND. (K <= KHI_CELL)
                  INNM = FLGX .AND. FLGY .AND. FLGZ
                  IF (INNM) THEN
                     NOM=NM; IIO=I; JJO=J; KKO=K
                  ELSE
                     CALL SEARCH_OTHER_MESHES_FACE(X1AXIS,XCELL(I),YFACE(J),ZCELL(K),NOM,IIO,JJO,KKO)
                  ENDIF
                  IF (NOM > 0) THEN ! Add to IIO_FC_R,JJO_FC_R,KKO_FC_R,AXIS_FC_R list,
                                    ! and add 1 to NFC_R for OMESH(NOM).
                     ! Use Automatic reallocation:
                     OMESH(NOM)%NFCC_R(1)= OMESH(NOM)%NFCC_R(1) + 1
                     SIZE_REC=SIZE(OMESH(NOM)%IIO_FC_R,DIM=1)
                     IF(OMESH(NOM)%NFCC_R(1) > SIZE_REC) THEN
                         ALLOCATE(IIO_FC_R_AUX(SIZE_REC),JJO_FC_R_AUX(SIZE_REC),KKO_FC_R_AUX(SIZE_REC));
                         ALLOCATE(AXS_FC_R_AUX(SIZE_REC))
                         IIO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%IIO_FC_R(1:SIZE_REC)
                         JJO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%JJO_FC_R(1:SIZE_REC)
                         KKO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%KKO_FC_R(1:SIZE_REC)
                         AXS_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%AXS_FC_R(1:SIZE_REC)
                         DEALLOCATE(OMESH(NOM)%IIO_FC_R); ALLOCATE(OMESH(NOM)%IIO_FC_R(SIZE_REC+DELTA_FC))
                         OMESH(NOM)%IIO_FC_R(1:SIZE_REC)=IIO_FC_R_AUX(1:SIZE_REC)
                         DEALLOCATE(OMESH(NOM)%JJO_FC_R); ALLOCATE(OMESH(NOM)%JJO_FC_R(SIZE_REC+DELTA_FC))
                         OMESH(NOM)%JJO_FC_R(1:SIZE_REC)=JJO_FC_R_AUX(1:SIZE_REC)
                         DEALLOCATE(OMESH(NOM)%KKO_FC_R); ALLOCATE(OMESH(NOM)%KKO_FC_R(SIZE_REC+DELTA_FC))
                         OMESH(NOM)%KKO_FC_R(1:SIZE_REC)=KKO_FC_R_AUX(1:SIZE_REC)
                         DEALLOCATE(OMESH(NOM)%AXS_FC_R); ALLOCATE(OMESH(NOM)%AXS_FC_R(SIZE_REC+DELTA_FC))
                         OMESH(NOM)%AXS_FC_R(1:SIZE_REC)=AXS_FC_R_AUX(1:SIZE_REC)
                         DEALLOCATE(IIO_FC_R_AUX,JJO_FC_R_AUX,KKO_FC_R_AUX,AXS_FC_R_AUX)
                     ENDIF
                     OMESH(NOM)%IIO_FC_R(OMESH(NOM)%NFCC_R(1)) = IIO
                     OMESH(NOM)%JJO_FC_R(OMESH(NOM)%NFCC_R(1)) = JJO
                     OMESH(NOM)%KKO_FC_R(OMESH(NOM)%NFCC_R(1)) = KKO
                     OMESH(NOM)%AXS_FC_R(OMESH(NOM)%NFCC_R(1)) = X1AXIS
                     IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS) = (/ NOM, OMESH(NOM)%NFCC_R(1) /)
                  ENDIF
               ENDIF
               CUT_FACE(ICF)%NOMIND_CFCEN(LOW_IND:HIGH_IND,IPT,IFACE) = IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS)
            ENDDO
         ENDDO

      CASE(KAXIS)
         ! First undelaying Cartesian:
         DO IPT=1,MAX_INTERP_POINTS_PLANE
            I = CUT_FACE(ICF)%IJK_CARTCEN(IAXIS,IPT)
            J = CUT_FACE(ICF)%IJK_CARTCEN(JAXIS,IPT)
            K = CUT_FACE(ICF)%IJK_CARTCEN(KAXIS,IPT)
            ! If face not counted yet:
            IF (IJKFACE2(LOW_IND,I,J,K,X1AXIS) < 1 ) THEN
               FLGX = (I >= ILO_CELL) .AND. (I <= IHI_CELL)
               FLGY = (J >= JLO_CELL) .AND. (J <= JHI_CELL)
               FLGZ = (K >= KLO_FACE) .AND. (K <= KHI_FACE)
               INNM = FLGX .AND. FLGY .AND. FLGZ
               IF (INNM) THEN
                  NOM=NM; IIO=I; JJO=J; KKO=K
               ELSE
                  CALL SEARCH_OTHER_MESHES_FACE(X1AXIS,XCELL(I),YCELL(J),ZFACE(K),NOM,IIO,JJO,KKO)
               ENDIF
               IF (NOM > 0) THEN ! Add to IIO_FC_R,JJO_FC_R,KKO_FC_R,AXIS_FC_R list,
                                 ! and add 1 to NFC_R for OMESH(NOM).
                  ! Use Automatic reallocation:
                  OMESH(NOM)%NFCC_R(1)= OMESH(NOM)%NFCC_R(1) + 1
                  SIZE_REC=SIZE(OMESH(NOM)%IIO_FC_R,DIM=1)
                  IF(OMESH(NOM)%NFCC_R(1) > SIZE_REC) THEN
                      ALLOCATE(IIO_FC_R_AUX(SIZE_REC),JJO_FC_R_AUX(SIZE_REC),KKO_FC_R_AUX(SIZE_REC));
                      ALLOCATE(AXS_FC_R_AUX(SIZE_REC))
                      IIO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%IIO_FC_R(1:SIZE_REC)
                      JJO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%JJO_FC_R(1:SIZE_REC)
                      KKO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%KKO_FC_R(1:SIZE_REC)
                      AXS_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%AXS_FC_R(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%IIO_FC_R); ALLOCATE(OMESH(NOM)%IIO_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%IIO_FC_R(1:SIZE_REC)=IIO_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%JJO_FC_R); ALLOCATE(OMESH(NOM)%JJO_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%JJO_FC_R(1:SIZE_REC)=JJO_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%KKO_FC_R); ALLOCATE(OMESH(NOM)%KKO_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%KKO_FC_R(1:SIZE_REC)=KKO_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%AXS_FC_R); ALLOCATE(OMESH(NOM)%AXS_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%AXS_FC_R(1:SIZE_REC)=AXS_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(IIO_FC_R_AUX,JJO_FC_R_AUX,KKO_FC_R_AUX,AXS_FC_R_AUX)
                  ENDIF
                  OMESH(NOM)%IIO_FC_R(OMESH(NOM)%NFCC_R(1)) = IIO
                  OMESH(NOM)%JJO_FC_R(OMESH(NOM)%NFCC_R(1)) = JJO
                  OMESH(NOM)%KKO_FC_R(OMESH(NOM)%NFCC_R(1)) = KKO
                  OMESH(NOM)%AXS_FC_R(OMESH(NOM)%NFCC_R(1)) = X1AXIS
                  IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS) = (/ NOM, OMESH(NOM)%NFCC_R(1) /)
               ENDIF
            ENDIF
            CUT_FACE(ICF)%NOMIND_CARTCEN(LOW_IND:HIGH_IND,IPT) = IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS)
         ENDDO
         ! Then gasphase cut-faces:
         DO IFACE=1,CUT_FACE(ICF)%NFACE
            DO IPT=1,MAX_INTERP_POINTS_PLANE
               I = CUT_FACE(ICF)%IJK_CFCEN(IAXIS,IPT,IFACE)
               J = CUT_FACE(ICF)%IJK_CFCEN(JAXIS,IPT,IFACE)
               K = CUT_FACE(ICF)%IJK_CFCEN(KAXIS,IPT,IFACE)
               ! If face not counted yet:
               IF (IJKFACE2(LOW_IND,I,J,K,X1AXIS) < 1 ) THEN
                  FLGX = (I >= ILO_CELL) .AND. (I <= IHI_CELL)
                  FLGY = (J >= JLO_CELL) .AND. (J <= JHI_CELL)
                  FLGZ = (K >= KLO_FACE) .AND. (K <= KHI_FACE)
                  INNM = FLGX .AND. FLGY .AND. FLGZ
                  IF (INNM) THEN
                     NOM=NM; IIO=I; JJO=J; KKO=K
                  ELSE
                     CALL SEARCH_OTHER_MESHES_FACE(X1AXIS,XCELL(I),YCELL(J),ZFACE(K),NOM,IIO,JJO,KKO)
                  ENDIF
                  IF (NOM > 0) THEN ! Add to IIO_FC_R,JJO_FC_R,KKO_FC_R,AXIS_FC_R list,
                                    ! and add 1 to NFC_R for OMESH(NOM).
                     ! Use Automatic reallocation:
                     OMESH(NOM)%NFCC_R(1)= OMESH(NOM)%NFCC_R(1) + 1
                     SIZE_REC=SIZE(OMESH(NOM)%IIO_FC_R,DIM=1)
                     IF(OMESH(NOM)%NFCC_R(1) > SIZE_REC) THEN
                         ALLOCATE(IIO_FC_R_AUX(SIZE_REC),JJO_FC_R_AUX(SIZE_REC),KKO_FC_R_AUX(SIZE_REC));
                         ALLOCATE(AXS_FC_R_AUX(SIZE_REC))
                         IIO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%IIO_FC_R(1:SIZE_REC)
                         JJO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%JJO_FC_R(1:SIZE_REC)
                         KKO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%KKO_FC_R(1:SIZE_REC)
                         AXS_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%AXS_FC_R(1:SIZE_REC)
                         DEALLOCATE(OMESH(NOM)%IIO_FC_R); ALLOCATE(OMESH(NOM)%IIO_FC_R(SIZE_REC+DELTA_FC))
                         OMESH(NOM)%IIO_FC_R(1:SIZE_REC)=IIO_FC_R_AUX(1:SIZE_REC)
                         DEALLOCATE(OMESH(NOM)%JJO_FC_R); ALLOCATE(OMESH(NOM)%JJO_FC_R(SIZE_REC+DELTA_FC))
                         OMESH(NOM)%JJO_FC_R(1:SIZE_REC)=JJO_FC_R_AUX(1:SIZE_REC)
                         DEALLOCATE(OMESH(NOM)%KKO_FC_R); ALLOCATE(OMESH(NOM)%KKO_FC_R(SIZE_REC+DELTA_FC))
                         OMESH(NOM)%KKO_FC_R(1:SIZE_REC)=KKO_FC_R_AUX(1:SIZE_REC)
                         DEALLOCATE(OMESH(NOM)%AXS_FC_R); ALLOCATE(OMESH(NOM)%AXS_FC_R(SIZE_REC+DELTA_FC))
                         OMESH(NOM)%AXS_FC_R(1:SIZE_REC)=AXS_FC_R_AUX(1:SIZE_REC)
                         DEALLOCATE(IIO_FC_R_AUX,JJO_FC_R_AUX,KKO_FC_R_AUX,AXS_FC_R_AUX)
                     ENDIF
                     OMESH(NOM)%IIO_FC_R(OMESH(NOM)%NFCC_R(1)) = IIO
                     OMESH(NOM)%JJO_FC_R(OMESH(NOM)%NFCC_R(1)) = JJO
                     OMESH(NOM)%KKO_FC_R(OMESH(NOM)%NFCC_R(1)) = KKO
                     OMESH(NOM)%AXS_FC_R(OMESH(NOM)%NFCC_R(1)) = X1AXIS
                     IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS) = (/ NOM, OMESH(NOM)%NFCC_R(1) /)
                  ENDIF
               ENDIF
               CUT_FACE(ICF)%NOMIND_CFCEN(LOW_IND:HIGH_IND,IPT,IFACE) = IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS)
            ENDDO
         ENDDO

      END SELECT

   ENDDO

   ! RC faces stencils:
   DO ICF=1,MESHES(NM)%IBM_NRCFACE_VEL
      X1AXIS = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK(KAXIS+1)
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         DO IPT=1,MAX_INTERP_POINTS_PLANE
            I      = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK_CARTCEN(IAXIS,IPT)
            J      = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK_CARTCEN(JAXIS,IPT)
            K      = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK_CARTCEN(KAXIS,IPT)
            ! If face not counted yet:
            IF (IJKFACE2(LOW_IND,I,J,K,X1AXIS) < 1 ) THEN
               FLGX = (I >= ILO_FACE) .AND. (I <= IHI_FACE)
               FLGY = (J >= JLO_CELL) .AND. (J <= JHI_CELL)
               FLGZ = (K >= KLO_CELL) .AND. (K <= KHI_CELL)
               INNM = FLGX .AND. FLGY .AND. FLGZ
               IF (INNM) THEN
                  NOM=NM; IIO=I; JJO=J; KKO=K
               ELSE
                  CALL SEARCH_OTHER_MESHES_FACE(X1AXIS,XFACE(I),YCELL(J),ZCELL(K),NOM,IIO,JJO,KKO)
               ENDIF
               IF (NOM > 0) THEN ! Add to IIO_FC_R,JJO_FC_R,KKO_FC_R,AXIS_FC_R list,
                                 ! and add 1 to NFC_R for OMESH(NOM).
                  ! Use Automatic reallocation:
                  OMESH(NOM)%NFCC_R(1)= OMESH(NOM)%NFCC_R(1) + 1
                  SIZE_REC=SIZE(OMESH(NOM)%IIO_FC_R,DIM=1)
                  IF(OMESH(NOM)%NFCC_R(1) > SIZE_REC) THEN
                      ALLOCATE(IIO_FC_R_AUX(SIZE_REC),JJO_FC_R_AUX(SIZE_REC),KKO_FC_R_AUX(SIZE_REC));
                      ALLOCATE(AXS_FC_R_AUX(SIZE_REC))
                      IIO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%IIO_FC_R(1:SIZE_REC)
                      JJO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%JJO_FC_R(1:SIZE_REC)
                      KKO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%KKO_FC_R(1:SIZE_REC)
                      AXS_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%AXS_FC_R(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%IIO_FC_R); ALLOCATE(OMESH(NOM)%IIO_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%IIO_FC_R(1:SIZE_REC)=IIO_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%JJO_FC_R); ALLOCATE(OMESH(NOM)%JJO_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%JJO_FC_R(1:SIZE_REC)=JJO_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%KKO_FC_R); ALLOCATE(OMESH(NOM)%KKO_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%KKO_FC_R(1:SIZE_REC)=KKO_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%AXS_FC_R); ALLOCATE(OMESH(NOM)%AXS_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%AXS_FC_R(1:SIZE_REC)=AXS_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(IIO_FC_R_AUX,JJO_FC_R_AUX,KKO_FC_R_AUX,AXS_FC_R_AUX)
                  ENDIF
                  OMESH(NOM)%IIO_FC_R(OMESH(NOM)%NFCC_R(1)) = IIO
                  OMESH(NOM)%JJO_FC_R(OMESH(NOM)%NFCC_R(1)) = JJO
                  OMESH(NOM)%KKO_FC_R(OMESH(NOM)%NFCC_R(1)) = KKO
                  OMESH(NOM)%AXS_FC_R(OMESH(NOM)%NFCC_R(1)) = X1AXIS
                  IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS) = (/ NOM, OMESH(NOM)%NFCC_R(1) /)
               ENDIF
            ENDIF
            MESHES(NM)%IBM_RCFACE_VEL(ICF)%NOMIND_CARTCEN(LOW_IND:HIGH_IND,IPT) = &
            IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS)
         ENDDO

      CASE(JAXIS)
         DO IPT=1,MAX_INTERP_POINTS_PLANE
            I      = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK_CARTCEN(IAXIS,IPT)
            J      = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK_CARTCEN(JAXIS,IPT)
            K      = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK_CARTCEN(KAXIS,IPT)
            ! If face not counted yet:
            IF (IJKFACE2(LOW_IND,I,J,K,X1AXIS) < 1 ) THEN
               FLGX = (I >= ILO_CELL) .AND. (I <= IHI_CELL)
               FLGY = (J >= JLO_FACE) .AND. (J <= JHI_FACE)
               FLGZ = (K >= KLO_CELL) .AND. (K <= KHI_CELL)
               INNM = FLGX .AND. FLGY .AND. FLGZ
               IF (INNM) THEN
                  NOM=NM; IIO=I; JJO=J; KKO=K
               ELSE
                  CALL SEARCH_OTHER_MESHES_FACE(X1AXIS,XCELL(I),YFACE(J),ZCELL(K),NOM,IIO,JJO,KKO)
               ENDIF
               IF (NOM > 0) THEN ! Add to IIO_FC_R,JJO_FC_R,KKO_FC_R,AXIS_FC_R list,
                                 ! and add 1 to NFC_R for OMESH(NOM).
                  ! Use Automatic reallocation:
                  OMESH(NOM)%NFCC_R(1)= OMESH(NOM)%NFCC_R(1) + 1
                  SIZE_REC=SIZE(OMESH(NOM)%IIO_FC_R,DIM=1)
                  IF(OMESH(NOM)%NFCC_R(1) > SIZE_REC) THEN
                      ALLOCATE(IIO_FC_R_AUX(SIZE_REC),JJO_FC_R_AUX(SIZE_REC),KKO_FC_R_AUX(SIZE_REC));
                      ALLOCATE(AXS_FC_R_AUX(SIZE_REC))
                      IIO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%IIO_FC_R(1:SIZE_REC)
                      JJO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%JJO_FC_R(1:SIZE_REC)
                      KKO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%KKO_FC_R(1:SIZE_REC)
                      AXS_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%AXS_FC_R(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%IIO_FC_R); ALLOCATE(OMESH(NOM)%IIO_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%IIO_FC_R(1:SIZE_REC)=IIO_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%JJO_FC_R); ALLOCATE(OMESH(NOM)%JJO_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%JJO_FC_R(1:SIZE_REC)=JJO_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%KKO_FC_R); ALLOCATE(OMESH(NOM)%KKO_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%KKO_FC_R(1:SIZE_REC)=KKO_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%AXS_FC_R); ALLOCATE(OMESH(NOM)%AXS_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%AXS_FC_R(1:SIZE_REC)=AXS_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(IIO_FC_R_AUX,JJO_FC_R_AUX,KKO_FC_R_AUX,AXS_FC_R_AUX)
                  ENDIF
                  OMESH(NOM)%IIO_FC_R(OMESH(NOM)%NFCC_R(1)) = IIO
                  OMESH(NOM)%JJO_FC_R(OMESH(NOM)%NFCC_R(1)) = JJO
                  OMESH(NOM)%KKO_FC_R(OMESH(NOM)%NFCC_R(1)) = KKO
                  OMESH(NOM)%AXS_FC_R(OMESH(NOM)%NFCC_R(1)) = X1AXIS
                  IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS) = (/ NOM, OMESH(NOM)%NFCC_R(1) /)
               ENDIF
            ENDIF
            MESHES(NM)%IBM_RCFACE_VEL(ICF)%NOMIND_CARTCEN(LOW_IND:HIGH_IND,IPT) = &
            IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS)
         ENDDO

      CASE(KAXIS)
         DO IPT=1,MAX_INTERP_POINTS_PLANE
            I      = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK_CARTCEN(IAXIS,IPT)
            J      = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK_CARTCEN(JAXIS,IPT)
            K      = MESHES(NM)%IBM_RCFACE_VEL(ICF)%IJK_CARTCEN(KAXIS,IPT)
            ! If face not counted yet:
            IF (IJKFACE2(LOW_IND,I,J,K,X1AXIS) < 1 ) THEN
               FLGX = (I >= ILO_CELL) .AND. (I <= IHI_CELL)
               FLGY = (J >= JLO_CELL) .AND. (J <= JHI_CELL)
               FLGZ = (K >= KLO_FACE) .AND. (K <= KHI_FACE)
               INNM = FLGX .AND. FLGY .AND. FLGZ
               IF (INNM) THEN
                  NOM=NM; IIO=I; JJO=J; KKO=K
               ELSE
                  CALL SEARCH_OTHER_MESHES_FACE(X1AXIS,XCELL(I),YCELL(J),ZFACE(K),NOM,IIO,JJO,KKO)
               ENDIF
               IF (NOM > 0) THEN ! Add to IIO_FC_R,JJO_FC_R,KKO_FC_R,AXIS_FC_R list,
                                 ! and add 1 to NFC_R for OMESH(NOM).
                  ! Use Automatic reallocation:
                  OMESH(NOM)%NFCC_R(1)= OMESH(NOM)%NFCC_R(1) + 1
                  SIZE_REC=SIZE(OMESH(NOM)%IIO_FC_R,DIM=1)
                  IF(OMESH(NOM)%NFCC_R(1) > SIZE_REC) THEN
                      ALLOCATE(IIO_FC_R_AUX(SIZE_REC),JJO_FC_R_AUX(SIZE_REC),KKO_FC_R_AUX(SIZE_REC));
                      ALLOCATE(AXS_FC_R_AUX(SIZE_REC))
                      IIO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%IIO_FC_R(1:SIZE_REC)
                      JJO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%JJO_FC_R(1:SIZE_REC)
                      KKO_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%KKO_FC_R(1:SIZE_REC)
                      AXS_FC_R_AUX(1:SIZE_REC)=OMESH(NOM)%AXS_FC_R(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%IIO_FC_R); ALLOCATE(OMESH(NOM)%IIO_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%IIO_FC_R(1:SIZE_REC)=IIO_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%JJO_FC_R); ALLOCATE(OMESH(NOM)%JJO_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%JJO_FC_R(1:SIZE_REC)=JJO_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%KKO_FC_R); ALLOCATE(OMESH(NOM)%KKO_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%KKO_FC_R(1:SIZE_REC)=KKO_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%AXS_FC_R); ALLOCATE(OMESH(NOM)%AXS_FC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%AXS_FC_R(1:SIZE_REC)=AXS_FC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(IIO_FC_R_AUX,JJO_FC_R_AUX,KKO_FC_R_AUX,AXS_FC_R_AUX)
                  ENDIF
                  OMESH(NOM)%IIO_FC_R(OMESH(NOM)%NFCC_R(1)) = IIO
                  OMESH(NOM)%JJO_FC_R(OMESH(NOM)%NFCC_R(1)) = JJO
                  OMESH(NOM)%KKO_FC_R(OMESH(NOM)%NFCC_R(1)) = KKO
                  OMESH(NOM)%AXS_FC_R(OMESH(NOM)%NFCC_R(1)) = X1AXIS
                  IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS) = (/ NOM, OMESH(NOM)%NFCC_R(1) /)
               ENDIF
            ENDIF
            MESHES(NM)%IBM_RCFACE_VEL(ICF)%NOMIND_CARTCEN(LOW_IND:HIGH_IND,IPT) = &
            IJKFACE2(LOW_IND:HIGH_IND,I,J,K,X1AXIS)
         ENDDO

      END SELECT

   ENDDO
   DEALLOCATE(IJKFACE2)


   ! Now Cell Variables:
   ALLOCATE(IJKCELL(LOW_IND:HIGH_IND,ISTR:IEND,JSTR:JEND,KSTR:KEND)); IJKCELL = IBM_UNDEFINED

   ! First Cut-cells:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      ! Underlaying Cartesian:
      DO IPT=1,MAX_INTERP_POINTS_PLANE
         I = CUT_CELL(ICC)%IJK_CARTCEN(IAXIS,IPT)
         J = CUT_CELL(ICC)%IJK_CARTCEN(JAXIS,IPT)
         K = CUT_CELL(ICC)%IJK_CARTCEN(KAXIS,IPT)
         ! If cell not counted yet:
         IF (IJKCELL(LOW_IND,I,J,K) < 1 ) THEN
            FLGX = (I >= ILO_CELL) .AND. (I <= IHI_CELL)
            FLGY = (J >= JLO_CELL) .AND. (J <= JHI_CELL)
            FLGZ = (K >= KLO_CELL) .AND. (K <= KHI_CELL)
            INNM = FLGX .AND. FLGY .AND. FLGZ
            IF (INNM) THEN
               NOM=NM; IIO=I; JJO=J; KKO=K
            ELSE
               CALL SEARCH_OTHER_MESHES(XCELL(I),YCELL(J),ZCELL(K),NOM,IIO,JJO,KKO)
            ENDIF
            IF (NOM > 0) THEN ! Add to IIO_FC_R,JJO_FC_R,KKO_FC_R,AXIS_FC_R list,
                              ! and add 1 to NFC_R for OMESH(NOM).
               ! Use Automatic reallocation:
               OMESH(NOM)%NFCC_R(2)= OMESH(NOM)%NFCC_R(2) + 1
               SIZE_REC=SIZE(OMESH(NOM)%IIO_CC_R,DIM=1)
               IF(OMESH(NOM)%NFCC_R(2) > SIZE_REC) THEN
                   ALLOCATE(IIO_CC_R_AUX(SIZE_REC),JJO_CC_R_AUX(SIZE_REC),KKO_CC_R_AUX(SIZE_REC));
                   IIO_CC_R_AUX(1:SIZE_REC)=OMESH(NOM)%IIO_CC_R(1:SIZE_REC)
                   JJO_CC_R_AUX(1:SIZE_REC)=OMESH(NOM)%JJO_CC_R(1:SIZE_REC)
                   KKO_CC_R_AUX(1:SIZE_REC)=OMESH(NOM)%KKO_CC_R(1:SIZE_REC)
                   DEALLOCATE(OMESH(NOM)%IIO_CC_R); ALLOCATE(OMESH(NOM)%IIO_CC_R(SIZE_REC+DELTA_FC))
                   OMESH(NOM)%IIO_CC_R(1:SIZE_REC)=IIO_CC_R_AUX(1:SIZE_REC)
                   DEALLOCATE(OMESH(NOM)%JJO_CC_R); ALLOCATE(OMESH(NOM)%JJO_CC_R(SIZE_REC+DELTA_FC))
                   OMESH(NOM)%JJO_CC_R(1:SIZE_REC)=JJO_CC_R_AUX(1:SIZE_REC)
                   DEALLOCATE(OMESH(NOM)%KKO_CC_R); ALLOCATE(OMESH(NOM)%KKO_CC_R(SIZE_REC+DELTA_FC))
                   OMESH(NOM)%KKO_CC_R(1:SIZE_REC)=KKO_CC_R_AUX(1:SIZE_REC)
                   DEALLOCATE(IIO_CC_R_AUX,JJO_CC_R_AUX,KKO_CC_R_AUX)
               ENDIF
               OMESH(NOM)%IIO_CC_R(OMESH(NOM)%NFCC_R(2)) = IIO
               OMESH(NOM)%JJO_CC_R(OMESH(NOM)%NFCC_R(2)) = JJO
               OMESH(NOM)%KKO_CC_R(OMESH(NOM)%NFCC_R(2)) = KKO
               IJKCELL(LOW_IND:HIGH_IND,I,J,K) = (/ NOM, OMESH(NOM)%NFCC_R(2) /)
            ENDIF
         ENDIF
         CUT_CELL(ICC)%NOMIND_CARTCEN(LOW_IND:HIGH_IND,IPT) = IJKCELL(LOW_IND:HIGH_IND,I,J,K)
      ENDDO
      ! Now cut-cells:
      DO JCC=1,CUT_CELL(ICC)%NCELL
         DO IPT=1,MAX_INTERP_POINTS_PLANE
            I = CUT_CELL(ICC)%IJK_CCCEN(IAXIS,IPT,JCC)
            J = CUT_CELL(ICC)%IJK_CCCEN(JAXIS,IPT,JCC)
            K = CUT_CELL(ICC)%IJK_CCCEN(KAXIS,IPT,JCC)
            ! If cell not counted yet:
            IF (IJKCELL(LOW_IND,I,J,K) < 1 ) THEN
               FLGX = (I >= ILO_CELL) .AND. (I <= IHI_CELL)
               FLGY = (J >= JLO_CELL) .AND. (J <= JHI_CELL)
               FLGZ = (K >= KLO_CELL) .AND. (K <= KHI_CELL)
               INNM = FLGX .AND. FLGY .AND. FLGZ
               IF (INNM) THEN
                  NOM=NM; IIO=I; JJO=J; KKO=K
               ELSE
                  CALL SEARCH_OTHER_MESHES(XCELL(I),YCELL(J),ZCELL(K),NOM,IIO,JJO,KKO)
               ENDIF
               IF (NOM > 0) THEN ! Add to IIO_FC_R,JJO_FC_R,KKO_FC_R,AXIS_FC_R list,
                                 ! and add 1 to NFC_R for OMESH(NOM).
                  ! Use Automatic reallocation:
                  OMESH(NOM)%NFCC_R(2)= OMESH(NOM)%NFCC_R(2) + 1
                  SIZE_REC=SIZE(OMESH(NOM)%IIO_CC_R,DIM=1)
                  IF(OMESH(NOM)%NFCC_R(2) > SIZE_REC) THEN
                      ALLOCATE(IIO_CC_R_AUX(SIZE_REC),JJO_CC_R_AUX(SIZE_REC),KKO_CC_R_AUX(SIZE_REC));
                      IIO_CC_R_AUX(1:SIZE_REC)=OMESH(NOM)%IIO_CC_R(1:SIZE_REC)
                      JJO_CC_R_AUX(1:SIZE_REC)=OMESH(NOM)%JJO_CC_R(1:SIZE_REC)
                      KKO_CC_R_AUX(1:SIZE_REC)=OMESH(NOM)%KKO_CC_R(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%IIO_CC_R); ALLOCATE(OMESH(NOM)%IIO_CC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%IIO_CC_R(1:SIZE_REC)=IIO_CC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%JJO_CC_R); ALLOCATE(OMESH(NOM)%JJO_CC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%JJO_CC_R(1:SIZE_REC)=JJO_CC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(OMESH(NOM)%KKO_CC_R); ALLOCATE(OMESH(NOM)%KKO_CC_R(SIZE_REC+DELTA_FC))
                      OMESH(NOM)%KKO_CC_R(1:SIZE_REC)=KKO_CC_R_AUX(1:SIZE_REC)
                      DEALLOCATE(IIO_CC_R_AUX,JJO_CC_R_AUX,KKO_CC_R_AUX)
                  ENDIF
                  OMESH(NOM)%IIO_CC_R(OMESH(NOM)%NFCC_R(2)) = IIO
                  OMESH(NOM)%JJO_CC_R(OMESH(NOM)%NFCC_R(2)) = JJO
                  OMESH(NOM)%KKO_CC_R(OMESH(NOM)%NFCC_R(2)) = KKO
                  IJKCELL(LOW_IND:HIGH_IND,I,J,K) = (/ NOM, OMESH(NOM)%NFCC_R(2) /)
               ENDIF
            ENDIF
            CUT_CELL(ICC)%NOMIND_CCCEN(LOW_IND:HIGH_IND,IPT,JCC) = IJKCELL(LOW_IND:HIGH_IND,I,J,K)
         ENDDO
      ENDDO
   ENDDO

   ! Finally RCELLs:
   DO IRCELL=1,MESHES(NM)%IBM_NRCELL_H
      DO IPT=1,MAX_INTERP_POINTS_PLANE
         I = MESHES(NM)%IBM_RCELL_H(IRCELL)%IJK_CARTCEN(IAXIS,IPT)
         J = MESHES(NM)%IBM_RCELL_H(IRCELL)%IJK_CARTCEN(JAXIS,IPT)
         K = MESHES(NM)%IBM_RCELL_H(IRCELL)%IJK_CARTCEN(KAXIS,IPT)
         ! If cell not counted yet:
         IF (IJKCELL(LOW_IND,I,J,K) < 1 ) THEN
            FLGX = (I >= ILO_CELL) .AND. (I <= IHI_CELL)
            FLGY = (J >= JLO_CELL) .AND. (J <= JHI_CELL)
            FLGZ = (K >= KLO_CELL) .AND. (K <= KHI_CELL)
            INNM = FLGX .AND. FLGY .AND. FLGZ
            IF (INNM) THEN
               NOM=NM; IIO=I; JJO=J; KKO=K
            ELSE
               CALL SEARCH_OTHER_MESHES(XCELL(I),YCELL(J),ZCELL(K),NOM,IIO,JJO,KKO)
            ENDIF
            IF (NOM > 0) THEN ! Add to IIO_FC_R,JJO_FC_R,KKO_FC_R,AXIS_FC_R list,
                              ! and add 1 to NFC_R for OMESH(NOM).
               ! Use Automatic reallocation:
               OMESH(NOM)%NFCC_R(2)= OMESH(NOM)%NFCC_R(2) + 1
               SIZE_REC=SIZE(OMESH(NOM)%IIO_CC_R,DIM=1)
               IF(OMESH(NOM)%NFCC_R(2) > SIZE_REC) THEN
                   ALLOCATE(IIO_CC_R_AUX(SIZE_REC),JJO_CC_R_AUX(SIZE_REC),KKO_CC_R_AUX(SIZE_REC));
                   IIO_CC_R_AUX(1:SIZE_REC)=OMESH(NOM)%IIO_CC_R(1:SIZE_REC)
                   JJO_CC_R_AUX(1:SIZE_REC)=OMESH(NOM)%JJO_CC_R(1:SIZE_REC)
                   KKO_CC_R_AUX(1:SIZE_REC)=OMESH(NOM)%KKO_CC_R(1:SIZE_REC)
                   DEALLOCATE(OMESH(NOM)%IIO_CC_R); ALLOCATE(OMESH(NOM)%IIO_CC_R(SIZE_REC+DELTA_FC))
                   OMESH(NOM)%IIO_CC_R(1:SIZE_REC)=IIO_CC_R_AUX(1:SIZE_REC)
                   DEALLOCATE(OMESH(NOM)%JJO_CC_R); ALLOCATE(OMESH(NOM)%JJO_CC_R(SIZE_REC+DELTA_FC))
                   OMESH(NOM)%JJO_CC_R(1:SIZE_REC)=JJO_CC_R_AUX(1:SIZE_REC)
                   DEALLOCATE(OMESH(NOM)%KKO_CC_R); ALLOCATE(OMESH(NOM)%KKO_CC_R(SIZE_REC+DELTA_FC))
                   OMESH(NOM)%KKO_CC_R(1:SIZE_REC)=KKO_CC_R_AUX(1:SIZE_REC)
                   DEALLOCATE(IIO_CC_R_AUX,JJO_CC_R_AUX,KKO_CC_R_AUX)
               ENDIF
               OMESH(NOM)%IIO_CC_R(OMESH(NOM)%NFCC_R(2)) = IIO
               OMESH(NOM)%JJO_CC_R(OMESH(NOM)%NFCC_R(2)) = JJO
               OMESH(NOM)%KKO_CC_R(OMESH(NOM)%NFCC_R(2)) = KKO
               IJKCELL(LOW_IND:HIGH_IND,I,J,K) = (/ NOM, OMESH(NOM)%NFCC_R(2) /)
            ENDIF
         ENDIF
         MESHES(NM)%IBM_RCELL_H(IRCELL)%NOMIND_CARTCEN(LOW_IND:HIGH_IND,IPT) = IJKCELL(LOW_IND:HIGH_IND,I,J,K)
      ENDDO
   ENDDO


   ! Add ghost-cells which are of type IBM_CUTCFE or next to one cell type IBM_CUTCFE:
   ! First record size of interpolation cells to be reveiced from OMESHES:
   DO NOM=1,NMESHES
      OMESH(NOM)%NCC_INT_R=OMESH(NOM)%NFCC_R(2)
   ENDDO
   ! Now loop INTERPOLATED WALL_CELLs:
   EXT_WALL_LOOP : DO IW=1,N_EXTERNAL_WALL_CELLS

      WC=>WALL(IW)
      EWC=>EXTERNAL_WALL(IW)
      IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE EXT_WALL_LOOP

      II  = WC%ONE_D%II
      JJ  = WC%ONE_D%JJ
      KK  = WC%ONE_D%KK
      NOM = EWC%NOM
      IF (NOM <= 0) CYCLE EXT_WALL_LOOP

      IF(ANY(CCVAR(II-1:II+1,JJ-1:JJ+1,KK-1:KK+1,IBM_CGSC)==IBM_CUTCFE)) THEN
         DO KKO=EWC%KKO_MIN,EWC%KKO_MAX
            DO JJO=EWC%JJO_MIN,EWC%JJO_MAX
               DO IIO=EWC%IIO_MIN,EWC%IIO_MAX
                OMESH(NOM)%NFCC_R(2)= OMESH(NOM)%NFCC_R(2) + 1
                SIZE_REC=SIZE(OMESH(NOM)%IIO_CC_R,DIM=1)
                IF(OMESH(NOM)%NFCC_R(2) > SIZE_REC) THEN
                    ALLOCATE(IIO_CC_R_AUX(SIZE_REC),JJO_CC_R_AUX(SIZE_REC),KKO_CC_R_AUX(SIZE_REC));
                    IIO_CC_R_AUX(1:SIZE_REC)=OMESH(NOM)%IIO_CC_R(1:SIZE_REC)
                    JJO_CC_R_AUX(1:SIZE_REC)=OMESH(NOM)%JJO_CC_R(1:SIZE_REC)
                    KKO_CC_R_AUX(1:SIZE_REC)=OMESH(NOM)%KKO_CC_R(1:SIZE_REC)
                    DEALLOCATE(OMESH(NOM)%IIO_CC_R); ALLOCATE(OMESH(NOM)%IIO_CC_R(SIZE_REC+DELTA_FC))
                    OMESH(NOM)%IIO_CC_R(1:SIZE_REC)=IIO_CC_R_AUX(1:SIZE_REC)
                    DEALLOCATE(OMESH(NOM)%JJO_CC_R); ALLOCATE(OMESH(NOM)%JJO_CC_R(SIZE_REC+DELTA_FC))
                    OMESH(NOM)%JJO_CC_R(1:SIZE_REC)=JJO_CC_R_AUX(1:SIZE_REC)
                    DEALLOCATE(OMESH(NOM)%KKO_CC_R); ALLOCATE(OMESH(NOM)%KKO_CC_R(SIZE_REC+DELTA_FC))
                    OMESH(NOM)%KKO_CC_R(1:SIZE_REC)=KKO_CC_R_AUX(1:SIZE_REC)
                    DEALLOCATE(IIO_CC_R_AUX,JJO_CC_R_AUX,KKO_CC_R_AUX)
                ENDIF
                OMESH(NOM)%IIO_CC_R(OMESH(NOM)%NFCC_R(2)) = IIO
                OMESH(NOM)%JJO_CC_R(OMESH(NOM)%NFCC_R(2)) = JJO
                OMESH(NOM)%KKO_CC_R(OMESH(NOM)%NFCC_R(2)) = KKO
               ENDDO
            ENDDO
         ENDDO
       ENDIF
   ENDDO EXT_WALL_LOOP
   DEALLOCATE(IJKCELL)

   ! WRITE(LU_ERR,*) ' MYID,   NM,   NOM,   OMESH(NOM)%NFC_R,  OMESH(NOM)%NCC_R'
   ! DO NOM=1,NMESHES
   !    WRITE(LU_ERR,*) MYID,NM,NOM,OMESH(NOM)%NFC_R,OMESH(NOM)%NCC_R
   ! ENDDO
   ! WRITE(LU_ERR,*) ' '

   ! Quality control:
   ! print*, 'MESHES(NM)%IBM_NRCELL_H=',MESHES(NM)%IBM_NRCELL_H
   ! IRC=176 ! Last entry for mesh 24x24x24 on sphre_air_demo_1.fds
   ! print*,' '
   ! print*,'RCELL=',IRC
   ! print*,'IJK=',MESHES(NM)%IBM_RCELL_H(IRC)%IJK(IAXIS:KAXIS)
   ! print*,'NCCELL=',MESHES(NM)%IBM_RCELL_H(IRC)%NCCELL
   ! print*,'CELL_LIST=',MESHES(NM)%IBM_RCELL_H(IRC)%CELL_LIST(1:MESHES(NM)%IBM_RCELL_H(IRC)%NCCELL)
   ! print*,'INBFC_CARTCEN(1:3)=',MESHES(NM)%IBM_RCELL_H(IRC)%INBFC_CARTCEN(1:3)
   ! print*,'INTCOEF_CARTCEN(1:5)=',MESHES(NM)%IBM_RCELL_H(IRC)%INTCOEF_CARTCEN(1:5)


   ! Deallocate arrays:
   ! Face centered positions and cell sizes:
   IF (ALLOCATED(XFACE)) DEALLOCATE(XFACE)
   IF (ALLOCATED(YFACE)) DEALLOCATE(YFACE)
   IF (ALLOCATED(ZFACE)) DEALLOCATE(ZFACE)
   IF (ALLOCATED(DXFACE)) DEALLOCATE(DXFACE)
   IF (ALLOCATED(DYFACE)) DEALLOCATE(DYFACE)
   IF (ALLOCATED(DZFACE)) DEALLOCATE(DZFACE)

   ! Cell centered positions and cell sizes:
   IF (ALLOCATED(XCELL)) DEALLOCATE(XCELL)
   IF (ALLOCATED(YCELL)) DEALLOCATE(YCELL)
   IF (ALLOCATED(ZCELL)) DEALLOCATE(ZCELL)
   IF (ALLOCATED(DXCELL)) DEALLOCATE(DXCELL)
   IF (ALLOCATED(DYCELL)) DEALLOCATE(DYCELL)
   IF (ALLOCATED(DZCELL)) DEALLOCATE(DZCELL)

ENDDO MESHES_LOOP2


! Finally Exchange info on messages to send among MPI processes:
! Populates OMESH(NOM)% : NFCC_S, IIO_FCC_S, JJO_FCC_S, KKO_FCC_S, AXS_FCC_S
CALL FILL_IJKO_INTERP_STENCILS


RETURN
END SUBROUTINE GET_CRTCFCC_INTERPOLATION_STENCILS


! -------------------------------- FILL_IJKO_INTERP_STENCILS ----------------------------

SUBROUTINE FILL_IJKO_INTERP_STENCILS

USE MPI

! Local Variables:
INTEGER :: NM,NOM,IERR
TYPE (OMESH_TYPE), POINTER :: M2,M3
INTEGER, ALLOCATABLE, DIMENSION(:) :: REQ0
INTEGER :: N_REQ0

CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)

IF (N_MPI_PROCESSES>1) ALLOCATE(REQ0(2*NMESHES**2))

N_REQ0 = 0

! Exchange number of cut-cells information to be exchanged between MESH and OMESHES:
DO NM=1,NMESHES
   IF (EVACUATION_ONLY(NM)) CYCLE
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      IF (EVACUATION_ONLY(NOM)) CYCLE
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MYID) THEN ! .AND. MESHES(NOM)%CONNECTED_MESH(NM)
         M2 => MESHES(NOM)%OMESH(NM)
         N_REQ0 = N_REQ0 + 1
         CALL MPI_IRECV(M2%NFCC_S(1),2,MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ENDIF
   ENDDO
ENDDO

! DEFINITION NCCC_S:   MESHES(NOM)%OMESH(NM)%NFCC_S   = MESHES(NM)%OMESH(NOM)%NFCC_R

DO NM=1,NMESHES
   CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)  ! This call orders the sending mesh by mesh.
   IF (PROCESS(NM)/=MYID) CYCLE
   IF (EVACUATION_ONLY(NM)) CYCLE
   DO NOM=1,NMESHES
      IF (EVACUATION_ONLY(NOM)) CYCLE
      !IF (.NOT.MESHES(NM)%CONNECTED_MESH(NOM)) CYCLE
      M3 => MESHES(NM)%OMESH(NOM)
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NOM)/=MYID) THEN ! .AND. MESHES(NM)%CONNECTED_MESH(NOM)
         N_REQ0 = N_REQ0 + 1
         CALL MPI_ISEND(M3%NFCC_R(1),2,MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ELSE
         M2 => MESHES(NOM)%OMESH(NM)
         M2%NFCC_S(1:2) = M3%NFCC_R(1:2)
      ENDIF
   ENDDO
ENDDO

IF ( (N_REQ0>0) .AND. (N_MPI_PROCESSES>1) ) CALL MPI_WAITALL(N_REQ0,REQ0(1:N_REQ0),MPI_STATUSES_IGNORE,IERR)

! At this point values of M2%NFCC_S should have been received.

! Definition: MESHES(NOM)%OMESH(NM)%IIO_FC_S(:) = MESHES(NM)%OMESH(NOM)%IIO_FC_R(:)
!             MESHES(NOM)%OMESH(NM)%JJO_FC_S(:) = MESHES(NM)%OMESH(NOM)%JJO_FC_R(:)
!             MESHES(NOM)%OMESH(NM)%KKO_FC_S(:) = MESHES(NM)%OMESH(NOM)%KKO_FC_R(:)
!             MESHES(NOM)%OMESH(NM)%AXS_FC_S(:) = MESHES(NM)%OMESH(NOM)%AXS_FC_R(:)

! Exchange list of face and cutcells data:
DO NM=1,NMESHES
   IF (EVACUATION_ONLY(NM)) CYCLE
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      IF (EVACUATION_ONLY(NOM)) CYCLE
      M2 => MESHES(NOM)%OMESH(NM)
      IF (M2%NFCC_S(1)>0) THEN
         ALLOCATE(M2%IIO_FC_S(M2%NFCC_S(1)))
         ALLOCATE(M2%JJO_FC_S(M2%NFCC_S(1)))
         ALLOCATE(M2%KKO_FC_S(M2%NFCC_S(1)))
         ALLOCATE(M2%AXS_FC_S(M2%NFCC_S(1)))
      ENDIF
      IF (M2%NFCC_S(2)>0) THEN
         ALLOCATE(M2%IIO_CC_S(M2%NFCC_S(2)))
         ALLOCATE(M2%JJO_CC_S(M2%NFCC_S(2)))
         ALLOCATE(M2%KKO_CC_S(M2%NFCC_S(2)))
      ENDIF
   ENDDO
ENDDO

! Faces:
N_REQ0 = 0
DO NM=1,NMESHES
   IF (EVACUATION_ONLY(NM)) CYCLE
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      IF (EVACUATION_ONLY(NOM)) CYCLE
      M2 => MESHES(NOM)%OMESH(NM)
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MYID .AND. M2%NFCC_S(1)>0) THEN
         CALL MPI_IRECV(M2%IIO_FC_S(1),M2%NFCC_S(1),MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0+1),IERR)
         CALL MPI_IRECV(M2%JJO_FC_S(1),M2%NFCC_S(1),MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0+2),IERR)
         CALL MPI_IRECV(M2%KKO_FC_S(1),M2%NFCC_S(1),MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0+3),IERR)
         CALL MPI_IRECV(M2%AXS_FC_S(1),M2%NFCC_S(1),MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0+4),IERR)
         N_REQ0 = N_REQ0 + 4
      ENDIF
   ENDDO
ENDDO
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   IF (EVACUATION_ONLY(NM)) CYCLE
   DO NOM=1,NMESHES
      IF (EVACUATION_ONLY(NOM)) CYCLE
      M3 => MESHES(NM)%OMESH(NOM)
      IF (M3%NFCC_R(1)<1) CYCLE
      IF (PROCESS(NOM)/=MYID) THEN
         CALL MPI_ISEND(M3%IIO_FC_R(1),M3%NFCC_R(1),MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0+1),IERR)
         CALL MPI_ISEND(M3%JJO_FC_R(1),M3%NFCC_R(1),MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0+2),IERR)
         CALL MPI_ISEND(M3%KKO_FC_R(1),M3%NFCC_R(1),MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0+3),IERR)
         CALL MPI_ISEND(M3%AXS_FC_R(1),M3%NFCC_R(1),MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0+4),IERR)
         N_REQ0 = N_REQ0 + 4
      ELSE
         M2 => MESHES(NOM)%OMESH(NM)
         M2%IIO_FC_S(1:M2%NFCC_S(1)) = M3%IIO_FC_R(1:M3%NFCC_R(1))
         M2%JJO_FC_S(1:M2%NFCC_S(1)) = M3%JJO_FC_R(1:M3%NFCC_R(1))
         M2%KKO_FC_S(1:M2%NFCC_S(1)) = M3%KKO_FC_R(1:M3%NFCC_R(1))
         M2%AXS_FC_S(1:M2%NFCC_S(1)) = M3%AXS_FC_R(1:M3%NFCC_R(1))
      ENDIF
   ENDDO
ENDDO

IF ( (N_REQ0>0) .AND. (N_MPI_PROCESSES>1) ) CALL MPI_WAITALL(N_REQ0,REQ0(1:N_REQ0),MPI_STATUSES_IGNORE,IERR)

! Cells:
N_REQ0 = 0
DO NM=1,NMESHES
   IF (EVACUATION_ONLY(NM)) CYCLE
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      IF (EVACUATION_ONLY(NOM)) CYCLE
      M2 => MESHES(NOM)%OMESH(NM)
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MYID .AND. M2%NFCC_S(2)>0) THEN
         CALL MPI_IRECV(M2%IIO_CC_S(1),M2%NFCC_S(2),MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0+1),IERR)
         CALL MPI_IRECV(M2%JJO_CC_S(1),M2%NFCC_S(2),MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0+2),IERR)
         CALL MPI_IRECV(M2%KKO_CC_S(1),M2%NFCC_S(2),MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0+3),IERR)
         N_REQ0 = N_REQ0 + 3
      ENDIF
   ENDDO
ENDDO
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   IF (EVACUATION_ONLY(NM)) CYCLE
   DO NOM=1,NMESHES
      IF (EVACUATION_ONLY(NOM)) CYCLE
      M3 => MESHES(NM)%OMESH(NOM)
      IF (M3%NFCC_R(2)<1) CYCLE
      IF (PROCESS(NOM)/=MYID) THEN
         CALL MPI_ISEND(M3%IIO_CC_R(1),M3%NFCC_R(2),MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0+1),IERR)
         CALL MPI_ISEND(M3%JJO_CC_R(1),M3%NFCC_R(2),MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0+2),IERR)
         CALL MPI_ISEND(M3%KKO_CC_R(1),M3%NFCC_R(2),MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0+3),IERR)
         N_REQ0 = N_REQ0 + 3
      ELSE
         M2 => MESHES(NOM)%OMESH(NM)
         M2%IIO_CC_S(1:M2%NFCC_S(2)) = M3%IIO_CC_R(1:M3%NFCC_R(2))
         M2%JJO_CC_S(1:M2%NFCC_S(2)) = M3%JJO_CC_R(1:M3%NFCC_R(2))
         M2%KKO_CC_S(1:M2%NFCC_S(2)) = M3%KKO_CC_R(1:M3%NFCC_R(2))
      ENDIF
   ENDDO
ENDDO

IF ( (N_REQ0>0) .AND. (N_MPI_PROCESSES>1) ) CALL MPI_WAITALL(N_REQ0,REQ0(1:N_REQ0),MPI_STATUSES_IGNORE,IERR)

RETURN
END SUBROUTINE FILL_IJKO_INTERP_STENCILS


! ------------------------- SEARCH_OTHER_MESHES_FACE ---------------------------------------------

SUBROUTINE SEARCH_OTHER_MESHES_FACE(AXIS,XX,YY,ZZ,NOM,IIO,JJO,KKO)

! Given the point (XX,YY,ZZ), determine which other mesh it intersects and what its indices are.

INTEGER, INTENT(IN) :: AXIS
REAL(EB), INTENT(IN) :: XX,YY,ZZ
REAL(EB) :: XI,YJ,ZK,SGN
INTEGER, INTENT(OUT) :: NOM,IIO,JJO,KKO
TYPE (MESH_TYPE), POINTER :: M2=>NULL()

SELECT CASE(AXIS)
CASE(IAXIS)
   OTHER_MESH_LOOP_X: DO NOM=1,NMESHES
      IF (EVACUATION_ONLY(NOM)) CYCLE OTHER_MESH_LOOP_X
      M2=>MESHES(NOM)
      IF (XX>=M2%XS .AND. XX<=M2%XF .AND.  YY>=M2%YS .AND. YY<=M2%YF .AND. ZZ>=M2%ZS .AND. ZZ<=M2%ZF) THEN
         DO IIO=0,M2%IBAR
            SGN=SIGN(1._EB,XX-M2%X(IIO))
            IF((SGN >  0._EB) .AND. (ABS(XX-M2%X(IIO)) <= M2%DX(IIO+1)/2._EB)) EXIT
            IF((SGN <  0._EB) .AND. (ABS(XX-M2%X(IIO)) <  M2%DX(IIO  )/2._EB)) EXIT
         ENDDO
         YJ  = MAX( 1._EB , MIN( REAL(M2%JBAR,EB)+ALMOST_ONE , M2%CELLSJ(FLOOR((YY-M2%YS)*M2%RDYINT)) + 1._EB ) )
         ZK  = MAX( 1._EB , MIN( REAL(M2%KBAR,EB)+ALMOST_ONE , M2%CELLSK(FLOOR((ZZ-M2%ZS)*M2%RDZINT)) + 1._EB ) )
         JJO = FLOOR(YJ)
         KKO = FLOOR(ZK)
         RETURN
      ENDIF
   ENDDO OTHER_MESH_LOOP_X
CASE(JAXIS)
   OTHER_MESH_LOOP_Y: DO NOM=1,NMESHES
      IF (EVACUATION_ONLY(NOM)) CYCLE OTHER_MESH_LOOP_Y
      M2=>MESHES(NOM)
      IF (XX>=M2%XS .AND. XX<=M2%XF .AND.  YY>=M2%YS .AND. YY<=M2%YF .AND. ZZ>=M2%ZS .AND. ZZ<=M2%ZF) THEN
         DO JJO=0,M2%JBAR
            SGN=SIGN(1._EB,YY-M2%Y(JJO))
            IF((SGN >  0._EB) .AND. (ABS(YY-M2%Y(JJO)) <= M2%DY(JJO+1)/2._EB)) EXIT
            IF((SGN <  0._EB) .AND. (ABS(YY-M2%Y(JJO))  > M2%DY(JJO  )/2._EB)) EXIT
         ENDDO
         XI  = MAX( 1._EB , MIN( REAL(M2%IBAR,EB)+ALMOST_ONE , M2%CELLSI(FLOOR((XX-M2%XS)*M2%RDXINT)) + 1._EB ) )
         ZK  = MAX( 1._EB , MIN( REAL(M2%KBAR,EB)+ALMOST_ONE , M2%CELLSK(FLOOR((ZZ-M2%ZS)*M2%RDZINT)) + 1._EB ) )
         IIO = FLOOR(XI)
         KKO = FLOOR(ZK)
         RETURN
      ENDIF
   ENDDO OTHER_MESH_LOOP_Y
CASE(KAXIS)
   OTHER_MESH_LOOP_Z: DO NOM=1,NMESHES
      IF (EVACUATION_ONLY(NOM)) CYCLE OTHER_MESH_LOOP_Z
      M2=>MESHES(NOM)
      IF (XX>=M2%XS .AND. XX<=M2%XF .AND.  YY>=M2%YS .AND. YY<=M2%YF .AND. ZZ>=M2%ZS .AND. ZZ<=M2%ZF) THEN
         DO KKO=0,M2%KBAR
            SGN=SIGN(1._EB,ZZ-M2%Z(KKO))
            IF((SGN >  0._EB) .AND. (ABS(ZZ-M2%Z(KKO)) <= M2%DZ(KKO+1)/2._EB)) EXIT
            IF((SGN <  0._EB) .AND. (ABS(ZZ-M2%Z(KKO))  > M2%DZ(KKO  )/2._EB)) EXIT
         ENDDO
         XI  = MAX( 1._EB , MIN( REAL(M2%IBAR,EB)+ALMOST_ONE , M2%CELLSI(FLOOR((XX-M2%XS)*M2%RDXINT)) + 1._EB ) )
         YJ  = MAX( 1._EB , MIN( REAL(M2%JBAR,EB)+ALMOST_ONE , M2%CELLSJ(FLOOR((YY-M2%YS)*M2%RDYINT)) + 1._EB ) )
         IIO = FLOOR(XI)
         JJO = FLOOR(YJ)
         RETURN
      ENDIF
   ENDDO OTHER_MESH_LOOP_Z
END SELECT

NOM = 0

END SUBROUTINE SEARCH_OTHER_MESHES_FACE


! ------------------------- GET_INTSTENCILS_FACE3D -------------------------------

SUBROUTINE GET_INTSTENCILS_FACE3D(NM,X1AXIS,X2AXIS,X3AXIS,XIAXIS,XJAXIS,XKAXIS,                 &
                                  P0,P1,NOUT,X1FACEP,X2FACEP,X3FACEP,X2CELLP,X3CELLP,&
                                  DIR_FCT,CI,CII,CIII,CIV,CV,PTS2)

INTEGER,  INTENT(IN) :: NM,X1AXIS,X2AXIS,X3AXIS,XIAXIS,XJAXIS,XKAXIS
REAL(EB), INTENT(IN) :: P0(MAX_DIM),P1(MAX_DIM),NOUT(MAX_DIM),DIR_FCT
REAL(EB), DIMENSION(:), INTENT(IN), POINTER :: X1FACEP,X2FACEP,X3FACEP,X2CELLP,X3CELLP
REAL(EB), INTENT(OUT):: CI,CII,CIII,CIV,CV
INTEGER,  INTENT(OUT):: PTS2(IAXIS:KAXIS,1:MAX_INTERP_POINTS_PLANE)

! Local Variables:
INTEGER :: TESTVAR, FCTN, XNAXIS, X1PLANE, X2PLANE, X3PLANE, IX1, IX2, IX3, IOUT
INTEGER :: PTS(IAXIS:KAXIS,NOD1:NOD4), PTSX(IAXIS:KAXIS,NOD1:NOD4)
REAL(EB):: XB, S, SX1, SX2, SX3, X1X2X3(IAXIS:KAXIS), CE, CB
INTEGER :: GVEC(NOD1:NOD4), GVEC2(NOD1:NOD4), GAS_PTS, ICT, IPT, DUMMY2(IAXIS:KAXIS), DUMMY3
REAL(EB):: XYEL(IAXIS:JAXIS,NOD1:NOD4), VAL, DUMMY(IAXIS:JAXIS)
REAL(EB):: A_COEF,B_COEF,C_COEF,D_COEF,DENOM,AINV(1:2,1:2),FD(1:2),VEC(1:2)
REAL(EB) :: X_CEN, DELX, Y_CEN, DELY, XI, ETA, C1, C2, C3, C4
REAL(EB):: NOUT2(IAXIS:KAXIS)

! Initialize:
CI = 0._EB; CII = 0._EB; CIII = 0._EB; CIV = 0._EB; CV = 0._EB;
PTS2(IAXIS:KAXIS,1:MAX_INTERP_POINTS_PLANE)= 0

TESTVAR = IBM_FFNF

! Define maximum direction, add GEOMEPS factors to avoid symmetry cases with random resulting plane:
NOUT2(IAXIS)=ABS(NOUT(IAXIS))+GEOFCT*GEOMEPS
NOUT2(JAXIS)=ABS(NOUT(JAXIS))+ 0._EB*GEOMEPS
NOUT2(KAXIS)=ABS(NOUT(KAXIS))-GEOFCT*GEOMEPS
XNAXIS = MAXLOC(NOUT2(IAXIS:KAXIS),1)
FCTN = INT(SIGN(1._EB,NOUT(XNAXIS)))

! Line P0+s*nout:
XB = P0(XNAXIS)
XNAXIS_COND : IF ( XNAXIS == X1AXIS ) THEN ! xNaxis equal to x1axis: Search for intersection in Plane x2,x3:

   ! x1 interval (cell) containing xb:
   X1PLANE = -1000
   IF (FCTN > 0 ) THEN
      IF ( XB >= X1FACEP(X1LO_FACE-1) ) THEN
         DO IX1 = X1LO_FACE,X1HI_FACE
            IF ( XB+GEOFCT*GEOMEPS < X1FACEP(IX1) ) THEN
               X1PLANE = IX1
               EXIT
            ENDIF
         ENDDO
      ENDIF
   ELSE
      IF ( XB <= X1FACEP(X1HI_FACE+1) ) THEN
         DO IX1 = X1HI_FACE,X1LO_FACE,-1
            IF ( XB-GEOFCT*GEOMEPS > X1FACEP(IX1) ) THEN
               X1PLANE = IX1
               EXIT
            ENDIF
         ENDDO
      ENDIF
   ENDIF

   ! Test that x1plane is not -1000...

   ! Look for planes in the +ve IAXIS, define s:
   IOUT1_LOOP : DO IOUT=1,PLOUT_MAX

      IX1 = X1PLANE + FCTN*IOUT
      SX1 = X1FACEP(IX1) - XB
      S   = SX1/NOUT(XNAXIS)
      SX2 = S*NOUT(X2AXIS)
      SX3 = S*NOUT(X3AXIS)

      X1X2X3(IAXIS:KAXIS) = (/ X1FACEP(IX1), P0(X2AXIS)+SX2, P0(X3AXIS)+SX3 /)

      ! Now find indexes for interpolation in x2,x3 planes:
      X2PLANE = -1000
      IF ( X1X2X3(JAXIS) >= X2CELLP(X2LO_CELL-1) ) THEN
         DO IX2=X2LO_CELL,X2HI_CELL+1
            IF ( X1X2X3(JAXIS)+GEOFCT*GEOMEPS < X2CELLP(IX2) ) THEN
               X2PLANE = IX2 - 1
               EXIT
            ENDIF
         ENDDO
      ENDIF
      X3PLANE = -1000
      IF ( X1X2X3(KAXIS) >= X3CELLP(X3LO_CELL-1) ) THEN
         DO IX3=X3LO_CELL,X3HI_CELL+1
            IF ( X1X2X3(KAXIS)+GEOFCT*GEOMEPS < X3CELLP(IX3) ) THEN
               X3PLANE = IX3 - 1
               EXIT
            ENDIF
         ENDDO
      ENDIF

      ! Test x2plane, x3plane are not -1000...

      ! Now interpolation along nout: xb-xcen-xint_plane
      IF (DIR_FCT > 0._EB) THEN
         IF ( ABS(X1X2X3(IAXIS)-P1(XNAXIS)) < GEOMEPS ) CYCLE
         CB = (X1X2X3(IAXIS)-P1(XNAXIS)) / SX1
         CE = (P1(XNAXIS)-XB) / SX1
      ELSE
         CB = SX1 / (X1X2X3(IAXIS)-P1(XNAXIS))
         CE =-(P1(XNAXIS)-XB) / (X1X2X3(IAXIS)-P1(XNAXIS))
      ENDIF

      ! The 4 interpolation points are: [ix1 ix2 ix3],
      ! [ix1 ix2+1 ix3], [ix1 ix2+1 ix3+1], [ix1 ix2 ix3+1]:
      PTSX(IAXIS:KAXIS,NOD1) = (/ IX1,   X2PLANE,   X3PLANE /)
      PTSX(IAXIS:KAXIS,NOD2) = (/ IX1, X2PLANE+1,   X3PLANE /)
      PTSX(IAXIS:KAXIS,NOD3) = (/ IX1, X2PLANE+1, X3PLANE+1 /)
      PTSX(IAXIS:KAXIS,NOD4) = (/ IX1,   X2PLANE, X3PLANE+1 /)
      PTS(IAXIS,NOD1:NOD4)   = PTSX(XIAXIS,NOD1:NOD4)
      PTS(JAXIS,NOD1:NOD4)   = PTSX(XJAXIS,NOD1:NOD4)
      PTS(KAXIS,NOD1:NOD4)   = PTSX(XKAXIS,NOD1:NOD4)
      GVEC(NOD1:NOD4) = 1
      GAS_PTS         = 4
      DO IPT=NOD1,NOD4
         IF (MESHES(NM)%FCVAR(PTS(IAXIS,IPT),PTS(JAXIS,IPT),PTS(KAXIS,IPT),TESTVAR,X1AXIS) /= IBM_GASPHASE ) THEN
            GVEC(IPT)= 0
            GAS_PTS  = GAS_PTS - 1
         ENDIF
      ENDDO

      PTS2(IAXIS:KAXIS,NOD1:NOD4) = 0; ICT = 0
      SELECT CASE(GAS_PTS)
      CASE (2,3) ! Only 2 or 3 GASPHASE points:

         IF (GAS_PTS == 2) THEN
            IF (IOUT < PLOUT_MAX) CYCLE ! Try plane further out.
            PTS2(IAXIS:KAXIS,NOD1:NOD3) = PTS(IAXIS:KAXIS,NOD1:NOD3)
            GVEC2(NOD1:NOD3) = GVEC(NOD1:NOD3)
            IF (GVEC(NOD4) == 1) THEN
               IF (GVEC(NOD1) == 0) THEN
                  PTS2(IAXIS:KAXIS,NOD1) = PTS(IAXIS:KAXIS,NOD4)
                  GVEC2(NOD1) = 1
               ELSEIF (GVEC(NOD3) == 0) THEN
                  PTS2(IAXIS:KAXIS,NOD3) = PTS(IAXIS:KAXIS,NOD4)
                  GVEC2(NOD3) = 1
               ENDIF
            ENDIF
         ELSE ! gas_pts == 3
            DO IPT=NOD1,NOD4
               IF (GVEC(IPT) == 1) THEN
                  ICT = ICT + 1
                  PTS2(IAXIS:KAXIS,ICT) = PTS(IAXIS:KAXIS,IPT)
               ENDIF
             ENDDO
         ENDIF
         ! Here Stencil coefficients:
         ! Find interpolation values using plane x2,x3:
         ! This is local IAXIS:JAXIS
         XYEL(IAXIS:JAXIS,NOD1) = (/ X2CELLP(PTS2(X2AXIS,NOD1)), X3CELLP(PTS2(X3AXIS,NOD1)) /)
         XYEL(IAXIS:JAXIS,NOD2) = (/ X2CELLP(PTS2(X2AXIS,NOD2)), X3CELLP(PTS2(X3AXIS,NOD2)) /)
         XYEL(IAXIS:JAXIS,NOD3) = (/ X2CELLP(PTS2(X2AXIS,NOD3)), X3CELLP(PTS2(X3AXIS,NOD3)) /)

         ! Test determinant to check that its +ve, if not swap 2 nodes:
         ! Test that x1-x2-x3 obeys right hand rule:
         VAL = (XYEL(IAXIS,NOD2)-XYEL(IAXIS,NOD1))*(XYEL(JAXIS,NOD3)-XYEL(JAXIS,NOD1)) - &
               (XYEL(JAXIS,NOD2)-XYEL(JAXIS,NOD1))*(XYEL(IAXIS,NOD3)-XYEL(IAXIS,NOD1))

         ! Transformation Matrix for this triangle in x2-x3 plane:
         IF (SIGN(1._EB,VAL) < 0._EB) THEN ! Rotate node 2 and 3 locations
            DUMMY(IAXIS:JAXIS)     = XYEL(IAXIS:JAXIS,NOD2)
            DUMMY2(IAXIS:KAXIS)    = PTS2(IAXIS:KAXIS,NOD2)
            XYEL(IAXIS:JAXIS,NOD2) = XYEL(IAXIS:JAXIS,NOD3)
            XYEL(IAXIS:JAXIS,NOD3) = DUMMY(IAXIS:JAXIS)
            PTS2(IAXIS:KAXIS,NOD2) = PTS2(IAXIS:KAXIS,NOD3)
            PTS2(IAXIS:KAXIS,NOD3) = DUMMY2(IAXIS:KAXIS)
            IF (GAS_PTS == 2) THEN
               DUMMY3     = GVEC2(NOD2)
               GVEC2(NOD2)= GVEC2(NOD3)
               GVEC2(NOD3)= DUMMY3
            ENDIF
         ENDIF

         ! Inverse of transformation matrix:
         A_COEF = XYEL(IAXIS,NOD1) - XYEL(IAXIS,NOD3)
         B_COEF = XYEL(IAXIS,NOD2) - XYEL(IAXIS,NOD3)
         C_COEF = XYEL(JAXIS,NOD1) - XYEL(JAXIS,NOD3)
         D_COEF = XYEL(JAXIS,NOD2) - XYEL(JAXIS,NOD3)
         DENOM  = A_COEF * D_COEF - B_COEF * C_COEF
         AINV(1,1) =  D_COEF / DENOM
         AINV(2,1) = -C_COEF / DENOM
         AINV(1,2) = -B_COEF / DENOM
         AINV(2,2) =  A_COEF / DENOM

         ! Transform back to master Element coordinates
         ! location of point i,j in x2-x3 coordinates:
         FD(1:2) = (/ X1X2X3(JAXIS)-XYEL(IAXIS,NOD3), X1X2X3(KAXIS)-XYEL(JAXIS,NOD3) /)
         VEC(1)  = AINV(1,1)*FD(1) + AINV(1,2)*FD(2)
         VEC(2)  = AINV(2,1)*FD(1) + AINV(2,2)*FD(2)
         ! here xi in vec(1) and eta in vec(2)

         ! Interpolation coefficients in the triangle (shape functions
         ! evaluated on intersection point):
         C1 = VEC(1)                  ! Node 1
         C2 = VEC(2)                  ! Node 2
         C3 = 1._EB - VEC(1) - VEC(2) ! Node 3

         IF (GAS_PTS == 2) THEN
             IF (GVEC2(NOD1) == 0) THEN
                 C2 = C2 + 0.5_EB*C1
                 C3 = C3 + 0.5_EB*C1
                 C1 = 0._EB
             ELSEIF(GVEC2(NOD2) == 0) THEN
                 C1 = C1 + 0.5_EB*C2
                 C3 = C3 + 0.5_EB*C2
                 C2 = 0._EB
             ELSEIF(GVEC2(NOD3) == 0) THEN
                 C1 = C1 + 0.5_EB*C3
                 C2 = C2 + 0.5_EB*C3
                 C3 = 0._EB
             ENDIF
         ENDIF

         ! 4th point is dummy:
         C4 = 0._EB
         PTS2(IAXIS:KAXIS,NOD4) = PTS2(IAXIS:KAXIS,NOD3)

      CASE (4) ! 4 gas_pts, bilinear in the plane:

         ! All GASPHASE:
         PTS2(IAXIS:KAXIS,NOD1:NOD4) = PTS(IAXIS:KAXIS,NOD1:NOD4)

         ! Find interpolation values using plane x2,x3:
         ! This is local IAXIS:JAXIS
         XYEL(IAXIS:JAXIS,NOD1) = (/ X2CELLP(PTS2(X2AXIS,NOD1)), X3CELLP(PTS2(X3AXIS,NOD1)) /)
         XYEL(IAXIS:JAXIS,NOD2) = (/ X2CELLP(PTS2(X2AXIS,NOD2)), X3CELLP(PTS2(X3AXIS,NOD2)) /)
         XYEL(IAXIS:JAXIS,NOD3) = (/ X2CELLP(PTS2(X2AXIS,NOD3)), X3CELLP(PTS2(X3AXIS,NOD3)) /)
         XYEL(IAXIS:JAXIS,NOD4) = (/ X2CELLP(PTS2(X2AXIS,NOD4)), X3CELLP(PTS2(X3AXIS,NOD4)) /)

         ! Center in local x2,x3:
         X_CEN = 0.5_EB * (XYEL(IAXIS,NOD3) + XYEL(IAXIS,NOD1))
         DELX  =          (XYEL(IAXIS,NOD3) - XYEL(IAXIS,NOD1))
         Y_CEN = 0.5_EB * (XYEL(JAXIS,NOD3) + XYEL(JAXIS,NOD1))
         DELY  =          (XYEL(JAXIS,NOD3) - XYEL(JAXIS,NOD1))

         ! Local natural coords:
         XI = 2._EB/DELX*(X1X2X3(JAXIS)-X_CEN)
         ETA= 2._EB/DELY*(X1X2X3(KAXIS)-Y_CEN)

         ! Bilinear coefficients (shape functions evaluated in xi,eta):
         C1 = 0.25_EB*(1._EB-XI)*(1._EB-ETA)
         C2 = 0.25_EB*(1._EB+XI)*(1._EB-ETA)
         C3 = 0.25_EB*(1._EB+XI)*(1._EB+ETA)
         C4 = 0.25_EB*(1._EB-XI)*(1._EB+ETA)

      CASE DEFAULT ! gas_pts < 2

         ! Try plane further out:
         IF ( IOUT == PLOUT_MAX ) THEN
             CB = 1._EB
             CE = 0._EB
             C1 = 0._EB; C2 = 0._EB; C3 = 0._EB; C4 = 0._EB
             PTS2(IAXIS:KAXIS,NOD1:NOD4) = PTS(IAXIS:KAXIS,NOD1:NOD4)
             EXIT
         ENDIF
         CYCLE

      END SELECT

      EXIT

   ENDDO IOUT1_LOOP

ELSEIF ( XNAXIS == X2AXIS ) THEN  ! xNaxis equal to x2axis: Search for intersection in Plane x3,x1:

   ! x2 interval (cell) containing xb:
   X2PLANE = -1000
   IF ( FCTN > 0 ) THEN
      IF ( XB >= X2FACEP(X2LO_FACE-1) ) THEN
         DO IX2=X2LO_FACE,X2HI_FACE
            IF( XB+GEOFCT*GEOMEPS < X2FACEP(IX2) ) THEN
               X2PLANE = IX2 + FCELL - 1
               EXIT
            ENDIF
         ENDDO
      ENDIF
   ELSE
     IF ( XB <= X2FACEP(X2HI_FACE+1) ) THEN
        DO IX2=X2HI_FACE,X2LO_FACE,-1
           IF ( XB-GEOFCT*GEOMEPS > X2FACEP(IX2) ) THEN
              X2PLANE = IX2 + FCELL
              EXIT
           ENDIF
        ENDDO
     ENDIF
   ENDIF

   ! Test that x2plane is not -1...

   ! Look for planes in the +ve IAXIS, define s:
   IOUT2_LOOP : DO IOUT=1,PLOUT_MAX

      IX2 = X2PLANE + FCTN*IOUT
      SX2 = X2CELLP(IX2) - XB
      S   = SX2/NOUT(XNAXIS)
      SX1 = S*NOUT(X1AXIS)
      SX3 = S*NOUT(X3AXIS)

      X1X2X3(IAXIS:KAXIS) = (/ P0(X1AXIS)+SX1, X2CELLP(IX2), P0(X3AXIS)+SX3 /)

      ! Now find indexes for interpolation in x3,x1 planes:
      X1PLANE = -1000
      IF ( X1X2X3(IAXIS) >= X1FACEP(X1LO_FACE-1) ) THEN
         DO IX1=X1LO_FACE,X1HI_FACE+1
            IF ( X1X2X3(IAXIS)+GEOFCT*GEOMEPS < X1FACEP(IX1) ) THEN
               X1PLANE = IX1 - 1
               EXIT
            ENDIF
         ENDDO
      ENDIF
      X3PLANE = -1000
      IF ( X1X2X3(KAXIS) >= X3CELLP(X3LO_CELL-1) ) THEN
         DO IX3=X3LO_CELL,X3HI_CELL+1
            IF ( X1X2X3(KAXIS)+GEOFCT*GEOMEPS < X3CELLP(IX3) ) THEN
               X3PLANE = IX3 - 1
               EXIT
            ENDIF
         ENDDO
      ENDIF

      ! Test x3plane, x1plane are not -1000...

      ! Now interpolation along nout: xb-xcen-xint_plane
      IF (DIR_FCT > 0._EB) THEN
          IF ( ABS(X1X2X3(JAXIS)-P1(XNAXIS)) < GEOMEPS ) CYCLE
          CB = (X1X2X3(JAXIS)-P1(XNAXIS)) / SX2
          CE = (P1(XNAXIS)-XB) / SX2
      ELSE
          CB = SX2 / (X1X2X3(JAXIS)-P1(XNAXIS))
          CE =-(P1(XNAXIS)-XB) / (X1X2X3(JAXIS)-P1(XNAXIS))
      ENDIF

      ! The 4 interpolation points are: [ix1 ix2 ix3],
      ! [ix1 ix2 ix3+1], [ix1+1 ix2 ix3+1], [ix1+1 ix2 ix3]:
      PTSX(IAXIS:KAXIS,NOD1) = (/   X1PLANE, IX2,   X3PLANE /)
      PTSX(IAXIS:KAXIS,NOD2) = (/   X1PLANE, IX2, X3PLANE+1 /)
      PTSX(IAXIS:KAXIS,NOD3) = (/ X1PLANE+1, IX2, X3PLANE+1 /)
      PTSX(IAXIS:KAXIS,NOD4) = (/ X1PLANE+1, IX2,   X3PLANE /)
      PTS(IAXIS,NOD1:NOD4)   = PTSX(XIAXIS,NOD1:NOD4)
      PTS(JAXIS,NOD1:NOD4)   = PTSX(XJAXIS,NOD1:NOD4)
      PTS(KAXIS,NOD1:NOD4)   = PTSX(XKAXIS,NOD1:NOD4)
      GVEC(NOD1:NOD4) = 1
      GAS_PTS         = 4
      DO IPT=NOD1,NOD4
         IF (MESHES(NM)%FCVAR(PTS(IAXIS,IPT),PTS(JAXIS,IPT),PTS(KAXIS,IPT),TESTVAR,X1AXIS) /= IBM_GASPHASE ) THEN
            GVEC(IPT)= 0
            GAS_PTS  = GAS_PTS - 1
         ENDIF
      ENDDO

      PTS2(IAXIS:KAXIS,NOD1:NOD4) = 0; ICT = 0
      SELECT CASE(GAS_PTS)
      CASE (2,3) ! Only 2 or 3 GASPHASE points:

         IF (GAS_PTS == 2) THEN
            IF (IOUT < PLOUT_MAX) CYCLE ! Try plane further out.
            PTS2(IAXIS:KAXIS,NOD1:NOD3) = PTS(IAXIS:KAXIS,NOD1:NOD3)
            GVEC2(NOD1:NOD3) = GVEC(NOD1:NOD3)
            IF (GVEC(NOD4) == 1) THEN
               IF (GVEC(NOD1) == 0) THEN
                  PTS2(IAXIS:KAXIS,NOD1) = PTS(IAXIS:KAXIS,NOD4)
                  GVEC2(NOD1) = 1
               ELSEIF (GVEC(NOD3) == 0) THEN
                  PTS2(IAXIS:KAXIS,NOD3) = PTS(IAXIS:KAXIS,NOD4)
                  GVEC2(NOD3) = 1
               ENDIF
            ENDIF
         ELSE ! gas_pts == 3
            DO IPT=NOD1,NOD4
               IF (GVEC(IPT) == 1) THEN
                  ICT = ICT + 1
                  PTS2(IAXIS:KAXIS,ICT) = PTS(IAXIS:KAXIS,IPT)
               ENDIF
             ENDDO
         ENDIF
         ! Here Stencil coefficients:
         ! Find interpolation values using plane x3,x1:
         ! This is local IAXIS:JAXIS
         XYEL(IAXIS:JAXIS,NOD1) = (/ X3CELLP(PTS2(X3AXIS,NOD1)), X1FACEP(PTS2(X1AXIS,NOD1)) /)
         XYEL(IAXIS:JAXIS,NOD2) = (/ X3CELLP(PTS2(X3AXIS,NOD2)), X1FACEP(PTS2(X1AXIS,NOD2)) /)
         XYEL(IAXIS:JAXIS,NOD3) = (/ X3CELLP(PTS2(X3AXIS,NOD3)), X1FACEP(PTS2(X1AXIS,NOD3)) /)

         ! Test determinant to check that its +ve, if not swap 2 nodes:
         ! Test that x1-x2-x3 obeys right hand rule:
         VAL = (XYEL(IAXIS,NOD2)-XYEL(IAXIS,NOD1))*(XYEL(JAXIS,NOD3)-XYEL(JAXIS,NOD1)) - &
               (XYEL(JAXIS,NOD2)-XYEL(JAXIS,NOD1))*(XYEL(IAXIS,NOD3)-XYEL(IAXIS,NOD1))

         ! Transformation Matrix for this triangle in x2-x3 plane:
         IF (SIGN(1._EB,VAL) < 0._EB) THEN ! Rotate node 2 and 3 locations
            DUMMY(IAXIS:JAXIS)     = XYEL(IAXIS:JAXIS,NOD2)
            DUMMY2(IAXIS:KAXIS)    = PTS2(IAXIS:KAXIS,NOD2)
            XYEL(IAXIS:JAXIS,NOD2) = XYEL(IAXIS:JAXIS,NOD3)
            XYEL(IAXIS:JAXIS,NOD3) = DUMMY(IAXIS:JAXIS)
            PTS2(IAXIS:KAXIS,NOD2) = PTS2(IAXIS:KAXIS,NOD3)
            PTS2(IAXIS:KAXIS,NOD3) = DUMMY2(IAXIS:KAXIS)
            IF (GAS_PTS == 2) THEN
               DUMMY3     = GVEC2(NOD2)
               GVEC2(NOD2)= GVEC2(NOD3)
               GVEC2(NOD3)= DUMMY3
            ENDIF
         ENDIF

         ! Inverse of transformation matrix:
         A_COEF = XYEL(IAXIS,NOD1) - XYEL(IAXIS,NOD3)
         B_COEF = XYEL(IAXIS,NOD2) - XYEL(IAXIS,NOD3)
         C_COEF = XYEL(JAXIS,NOD1) - XYEL(JAXIS,NOD3)
         D_COEF = XYEL(JAXIS,NOD2) - XYEL(JAXIS,NOD3)
         DENOM  = A_COEF * D_COEF - B_COEF * C_COEF
         AINV(1,1) =  D_COEF / DENOM
         AINV(2,1) = -C_COEF / DENOM
         AINV(1,2) = -B_COEF / DENOM
         AINV(2,2) =  A_COEF / DENOM

         ! Transform back to master Element coordinates
         ! location of point i,j in x3-x1 coordinates:
         FD(1:2) = (/ X1X2X3(KAXIS)-XYEL(IAXIS,NOD3), X1X2X3(IAXIS)-XYEL(JAXIS,NOD3) /)
         VEC(1)  = AINV(1,1)*FD(1) + AINV(1,2)*FD(2)
         VEC(2)  = AINV(2,1)*FD(1) + AINV(2,2)*FD(2)
         ! here xi in vec(1) and eta in vec(2)

         ! Interpolation coefficients in the triangle (shape functions
         ! evaluated on intersection point):
         C1 = VEC(1)                  ! Node 1
         C2 = VEC(2)                  ! Node 2
         C3 = 1._EB - VEC(1) - VEC(2) ! Node 3

         IF (GAS_PTS == 2) THEN
             IF (GVEC2(NOD1) == 0) THEN
                 C2 = C2 + 0.5_EB*C1
                 C3 = C3 + 0.5_EB*C1
                 C1 = 0._EB
             ELSEIF(GVEC2(NOD2) == 0) THEN
                 C1 = C1 + 0.5_EB*C2
                 C3 = C3 + 0.5_EB*C2
                 C2 = 0._EB
             ELSEIF(GVEC2(NOD3) == 0) THEN
                 C1 = C1 + 0.5_EB*C3
                 C2 = C2 + 0.5_EB*C3
                 C3 = 0._EB
             ENDIF
         ENDIF

         ! 4th point is dummy:
         C4 = 0._EB
         PTS2(IAXIS:KAXIS,NOD4) = PTS2(IAXIS:KAXIS,NOD3)

      CASE (4) ! 4 gas_pts, bilinear in the plane:

         ! All GASPHASE:
         PTS2(IAXIS:KAXIS,NOD1:NOD4) = PTS(IAXIS:KAXIS,NOD1:NOD4)

         ! Find interpolation values using plane x3,x1:
         ! This is local IAXIS:JAXIS
         XYEL(IAXIS:JAXIS,NOD1) = (/ X3CELLP(PTS2(X3AXIS,NOD1)), X1FACEP(PTS2(X1AXIS,NOD1)) /)
         XYEL(IAXIS:JAXIS,NOD2) = (/ X3CELLP(PTS2(X3AXIS,NOD2)), X1FACEP(PTS2(X1AXIS,NOD2)) /)
         XYEL(IAXIS:JAXIS,NOD3) = (/ X3CELLP(PTS2(X3AXIS,NOD3)), X1FACEP(PTS2(X1AXIS,NOD3)) /)
         XYEL(IAXIS:JAXIS,NOD4) = (/ X3CELLP(PTS2(X3AXIS,NOD4)), X1FACEP(PTS2(X1AXIS,NOD4)) /)

         ! Center in local x3,x1:
         X_CEN = 0.5_EB * (XYEL(IAXIS,NOD3) + XYEL(IAXIS,NOD1))
         DELX  =          (XYEL(IAXIS,NOD3) - XYEL(IAXIS,NOD1))
         Y_CEN = 0.5_EB * (XYEL(JAXIS,NOD3) + XYEL(JAXIS,NOD1))
         DELY  =          (XYEL(JAXIS,NOD3) - XYEL(JAXIS,NOD1))

         ! Local natural coords:
         XI = 2._EB/DELX*(X1X2X3(KAXIS)-X_CEN)
         ETA= 2._EB/DELY*(X1X2X3(IAXIS)-Y_CEN)

         ! Bilinear coefficients (shape functions evaluated in xi,eta):
         C1 = 0.25_EB*(1._EB-XI)*(1._EB-ETA)
         C2 = 0.25_EB*(1._EB+XI)*(1._EB-ETA)
         C3 = 0.25_EB*(1._EB+XI)*(1._EB+ETA)
         C4 = 0.25_EB*(1._EB-XI)*(1._EB+ETA)

      CASE DEFAULT ! gas_pts < 2

         ! Try plane further out:
         IF ( IOUT == PLOUT_MAX ) THEN
             CB = 1._EB
             CE = 0._EB
             C1 = 0._EB; C2 = 0._EB; C3 = 0._EB; C4 = 0._EB
             PTS2(IAXIS:KAXIS,NOD1:NOD4) = PTS(IAXIS:KAXIS,NOD1:NOD4)
             EXIT
         ENDIF
         CYCLE

      END SELECT

      EXIT

   ENDDO IOUT2_LOOP

ELSEIF ( XNAXIS == X3AXIS ) THEN  ! xNaxis equal to x3axis: Search for intersection in Plane x1,x2:

   ! x3interval (cell) containing xb:
   X3PLANE = -1000
   IF ( FCTN > 0 ) THEN
      IF ( XB >= X3FACEP(X3LO_FACE-1) ) THEN
         DO IX3=X3LO_FACE,X3HI_FACE
            IF ( XB+GEOFCT*GEOMEPS < X3FACEP(IX3) ) THEN
               X3PLANE = IX3 + FCELL - 1
               EXIT
            ENDIF
         ENDDO
      ENDIF
   ELSE
     IF ( XB <= X3FACEP(X3HI_FACE+1) ) THEN
         DO IX3=X3HI_FACE,X3LO_FACE,-1
             IF ( XB-GEOFCT*GEOMEPS > X3FACEP(IX3) ) THEN
                 X3PLANE = IX3 + FCELL
                 EXIT
             ENDIF
         ENDDO
     ENDIF
   ENDIF

   ! Test that x3plane is not -1...
   IOUT3_LOOP : DO IOUT=1,PLOUT_MAX

      IX3 = X3PLANE + FCTN*IOUT
      SX3 = X3CELLP(IX3) - XB
      S   = SX3/NOUT(XNAXIS)
      SX1 = S*NOUT(X1AXIS)
      SX2 = S*NOUT(X2AXIS)

      X1X2X3(IAXIS:KAXIS) = (/ P0(X1AXIS)+SX1, P0(X2AXIS)+SX2, X3CELLP(IX3) /)

      ! Now find indexes for interpolation in x3,x1 planes:
      X1PLANE = -1000
      IF ( X1X2X3(IAXIS) >= X1FACEP(X1LO_FACE-1) ) THEN
         DO IX1=X1LO_FACE,X1HI_FACE+1
            IF ( X1X2X3(IAXIS)+GEOFCT*GEOMEPS < X1FACEP(IX1) ) THEN
               X1PLANE = IX1 - 1
               EXIT
            ENDIF
         ENDDO
      ENDIF
      X2PLANE = -1000
      IF ( X1X2X3(JAXIS) >= X2CELLP(X2LO_CELL-1) ) THEN
         DO IX2=X2LO_CELL,X2HI_CELL+1
            IF ( X1X2X3(JAXIS)+GEOFCT*GEOMEPS < X2CELLP(IX2) ) THEN
               X2PLANE = IX2 - 1
               EXIT
            ENDIF
         ENDDO
      ENDIF

      ! Test x1plane, x2plane are not -1000...

      ! Now interpolation along nout: xb-xcen-xint_plane:
      IF ( DIR_FCT > 0._EB ) THEN
          IF ( ABS(X1X2X3(KAXIS)-P1(XNAXIS)) < GEOMEPS ) CYCLE
          CB = (X1X2X3(KAXIS)-P1(XNAXIS)) / SX3
          CE = (P1(XNAXIS)-XB) / SX3
      ELSE
          CB = SX3 / (X1X2X3(KAXIS)-P1(XNAXIS))
          CE =-(P1(XNAXIS)-XB) / (X1X2X3(KAXIS)-P1(XNAXIS))
      ENDIF

      ! The 4 interpolation points are: [ix1 ix2 ix3],
      ! [ix1+1 ix2 ix3], [ix1+1 ix2+1 ix3], [ix1 ix2+1 ix3]:
      PTSX(IAXIS:KAXIS,NOD1) = (/   X1PLANE,   X2PLANE, IX3 /)
      PTSX(IAXIS:KAXIS,NOD2) = (/ X1PLANE+1,   X2PLANE, IX3 /)
      PTSX(IAXIS:KAXIS,NOD3) = (/ X1PLANE+1, X2PLANE+1, IX3 /)
      PTSX(IAXIS:KAXIS,NOD4) = (/   X1PLANE, X2PLANE+1, IX3 /)
      PTS(IAXIS,NOD1:NOD4)   = PTSX(XIAXIS,NOD1:NOD4)
      PTS(JAXIS,NOD1:NOD4)   = PTSX(XJAXIS,NOD1:NOD4)
      PTS(KAXIS,NOD1:NOD4)   = PTSX(XKAXIS,NOD1:NOD4)
      GVEC(NOD1:NOD4) = 1
      GAS_PTS         = 4
      DO IPT=NOD1,NOD4
         IF (MESHES(NM)%FCVAR(PTS(IAXIS,IPT),PTS(JAXIS,IPT),PTS(KAXIS,IPT),TESTVAR,X1AXIS) /= IBM_GASPHASE ) THEN
            GVEC(IPT)= 0
            GAS_PTS  = GAS_PTS - 1
         ENDIF
      ENDDO

      PTS2(IAXIS:KAXIS,NOD1:NOD4) = 0; ICT = 0
      SELECT CASE(GAS_PTS)
      CASE (2,3) ! Only 2 or 3 GASPHASE points:

         IF (GAS_PTS == 2) THEN
            IF (IOUT < PLOUT_MAX) CYCLE ! Try plane further out.
            PTS2(IAXIS:KAXIS,NOD1:NOD3) = PTS(IAXIS:KAXIS,NOD1:NOD3)
            GVEC2(NOD1:NOD3) = GVEC(NOD1:NOD3)
            IF (GVEC(NOD4) == 1) THEN
               IF (GVEC(NOD1) == 0) THEN
                  PTS2(IAXIS:KAXIS,NOD1) = PTS(IAXIS:KAXIS,NOD4)
                  GVEC2(NOD1) = 1
               ELSEIF (GVEC(NOD3) == 0) THEN
                  PTS2(IAXIS:KAXIS,NOD3) = PTS(IAXIS:KAXIS,NOD4)
                  GVEC2(NOD3) = 1
               ENDIF
            ENDIF
         ELSE ! gas_pts == 3
            DO IPT=NOD1,NOD4
               IF (GVEC(IPT) == 1) THEN
                  ICT = ICT + 1
                  PTS2(IAXIS:KAXIS,ICT) = PTS(IAXIS:KAXIS,IPT)
               ENDIF
             ENDDO
         ENDIF
         ! Here Stencil coefficients:
         ! Find interpolation values using plane x1,x2:
         ! This is local IAXIS:JAXIS
         XYEL(IAXIS:JAXIS,NOD1) = (/ X1FACEP(PTS2(X1AXIS,NOD1)), X2CELLP(PTS2(X2AXIS,NOD1)) /)
         XYEL(IAXIS:JAXIS,NOD2) = (/ X1FACEP(PTS2(X1AXIS,NOD2)), X2CELLP(PTS2(X2AXIS,NOD2)) /)
         XYEL(IAXIS:JAXIS,NOD3) = (/ X1FACEP(PTS2(X1AXIS,NOD3)), X2CELLP(PTS2(X2AXIS,NOD3)) /)

         ! Test determinant to check that its +ve, if not swap 2 nodes:
         ! Test that x1-x2-x3 obeys right hand rule:
         VAL = (XYEL(IAXIS,NOD2)-XYEL(IAXIS,NOD1))*(XYEL(JAXIS,NOD3)-XYEL(JAXIS,NOD1)) - &
               (XYEL(JAXIS,NOD2)-XYEL(JAXIS,NOD1))*(XYEL(IAXIS,NOD3)-XYEL(IAXIS,NOD1))

         ! Transformation Matrix for this triangle in x2-x3 plane:
         IF (SIGN(1._EB,VAL) < 0._EB) THEN ! Rotate node 2 and 3 locations
            DUMMY(IAXIS:JAXIS)     = XYEL(IAXIS:JAXIS,NOD2)
            DUMMY2(IAXIS:KAXIS)    = PTS2(IAXIS:KAXIS,NOD2)
            XYEL(IAXIS:JAXIS,NOD2) = XYEL(IAXIS:JAXIS,NOD3)
            XYEL(IAXIS:JAXIS,NOD3) = DUMMY(IAXIS:JAXIS)
            PTS2(IAXIS:KAXIS,NOD2) = PTS2(IAXIS:KAXIS,NOD3)
            PTS2(IAXIS:KAXIS,NOD3) = DUMMY2(IAXIS:KAXIS)
            IF (GAS_PTS == 2) THEN
               DUMMY3     = GVEC2(NOD2)
               GVEC2(NOD2)= GVEC2(NOD3)
               GVEC2(NOD3)= DUMMY3
            ENDIF
         ENDIF

         ! Inverse of transformation matrix:
         A_COEF = XYEL(IAXIS,NOD1) - XYEL(IAXIS,NOD3)
         B_COEF = XYEL(IAXIS,NOD2) - XYEL(IAXIS,NOD3)
         C_COEF = XYEL(JAXIS,NOD1) - XYEL(JAXIS,NOD3)
         D_COEF = XYEL(JAXIS,NOD2) - XYEL(JAXIS,NOD3)
         DENOM  = A_COEF * D_COEF - B_COEF * C_COEF
         AINV(1,1) =  D_COEF / DENOM
         AINV(2,1) = -C_COEF / DENOM
         AINV(1,2) = -B_COEF / DENOM
         AINV(2,2) =  A_COEF / DENOM

         ! Transform back to master Element coordinates
         ! location of point i,j in x1-x2 coordinates:
         FD(1:2) = (/ X1X2X3(IAXIS)-XYEL(IAXIS,NOD3), X1X2X3(JAXIS)-XYEL(JAXIS,NOD3) /)
         VEC(1)  = AINV(1,1)*FD(1) + AINV(1,2)*FD(2)
         VEC(2)  = AINV(2,1)*FD(1) + AINV(2,2)*FD(2)
         ! here xi in vec(1) and eta in vec(2)

         ! Interpolation coefficients in the triangle (shape functions
         ! evaluated on intersection point):
         C1 = VEC(1)                  ! Node 1
         C2 = VEC(2)                  ! Node 2
         C3 = 1._EB - VEC(1) - VEC(2) ! Node 3

         IF (GAS_PTS == 2) THEN
             IF (GVEC2(NOD1) == 0) THEN
                 C2 = C2 + 0.5_EB*C1
                 C3 = C3 + 0.5_EB*C1
                 C1 = 0._EB
             ELSEIF(GVEC2(NOD2) == 0) THEN
                 C1 = C1 + 0.5_EB*C2
                 C3 = C3 + 0.5_EB*C2
                 C2 = 0._EB
             ELSEIF(GVEC2(NOD3) == 0) THEN
                 C1 = C1 + 0.5_EB*C3
                 C2 = C2 + 0.5_EB*C3
                 C3 = 0._EB
             ENDIF
         ENDIF

         ! 4th point is dummy:
         C4 = 0._EB
         PTS2(IAXIS:KAXIS,NOD4) = PTS2(IAXIS:KAXIS,NOD3)

      CASE (4) ! 4 gas_pts, bilinear in the plane:

         ! All GASPHASE:
         PTS2(IAXIS:KAXIS,NOD1:NOD4) = PTS(IAXIS:KAXIS,NOD1:NOD4)

         ! Find interpolation values using plane x1,x2:
         ! This is local IAXIS:JAXIS
         XYEL(IAXIS:JAXIS,NOD1) = (/ X1FACEP(PTS2(X1AXIS,NOD1)), X2CELLP(PTS2(X2AXIS,NOD1)) /)
         XYEL(IAXIS:JAXIS,NOD2) = (/ X1FACEP(PTS2(X1AXIS,NOD2)), X2CELLP(PTS2(X2AXIS,NOD2)) /)
         XYEL(IAXIS:JAXIS,NOD3) = (/ X1FACEP(PTS2(X1AXIS,NOD3)), X2CELLP(PTS2(X2AXIS,NOD3)) /)
         XYEL(IAXIS:JAXIS,NOD4) = (/ X1FACEP(PTS2(X1AXIS,NOD4)), X2CELLP(PTS2(X2AXIS,NOD4)) /)

         ! Center in local x1,x2:
         X_CEN = 0.5_EB * (XYEL(IAXIS,NOD3) + XYEL(IAXIS,NOD1))
         DELX  =          (XYEL(IAXIS,NOD3) - XYEL(IAXIS,NOD1))
         Y_CEN = 0.5_EB * (XYEL(JAXIS,NOD3) + XYEL(JAXIS,NOD1))
         DELY  =          (XYEL(JAXIS,NOD3) - XYEL(JAXIS,NOD1))

         ! Local natural coords:
         XI = 2._EB/DELX*(X1X2X3(IAXIS)-X_CEN)
         ETA= 2._EB/DELY*(X1X2X3(JAXIS)-Y_CEN)

         ! Bilinear coefficients (shape functions evaluated in xi,eta):
         C1 = 0.25_EB*(1._EB-XI)*(1._EB-ETA)
         C2 = 0.25_EB*(1._EB+XI)*(1._EB-ETA)
         C3 = 0.25_EB*(1._EB+XI)*(1._EB+ETA)
         C4 = 0.25_EB*(1._EB-XI)*(1._EB+ETA)

      CASE DEFAULT ! gas_pts < 2

         ! Try plane further out:
         IF ( IOUT == PLOUT_MAX ) THEN
             CB = 1._EB
             CE = 0._EB
             C1 = 0._EB; C2 = 0._EB; C3 = 0._EB; C4 = 0._EB
             PTS2(IAXIS:KAXIS,NOD1:NOD4) = PTS(IAXIS:KAXIS,NOD1:NOD4)
             EXIT
         ENDIF
         CYCLE

      END SELECT

      EXIT

   ENDDO IOUT3_LOOP

ENDIF XNAXIS_COND

! Coefficients:
CI  = CB
CII = CE*C1
CIII= CE*C2
CIV = CE*C3
CV  = CE*C4

RETURN
END SUBROUTINE GET_INTSTENCILS_FACE3D


! ------------------------- GET_INTSTENCILS_VOL3D -------------------------------

SUBROUTINE GET_INTSTENCILS_VOL3D(NM,P0,P1,NOUT,DIR_FCT,TESTVAR,CI,CII,CIII,CIV,CV,PTS2)

INTEGER,  INTENT(IN) :: NM, TESTVAR
REAL(EB), INTENT(IN) :: P0(MAX_DIM),P1(MAX_DIM),NOUT(MAX_DIM),DIR_FCT
REAL(EB), INTENT(OUT):: CI,CII,CIII,CIV,CV
INTEGER,  INTENT(OUT):: PTS2(IAXIS:KAXIS,1:MAX_INTERP_POINTS_PLANE)

! Local Variables:
INTEGER :: FCTN, XNAXIS, XPLANE, YPLANE, ZPLANE, I, J, K, IOUT
INTEGER :: PTS(IAXIS:KAXIS,NOD1:NOD4)
REAL(EB):: XB, S, SX, SY, SZ, XYZ(IAXIS:KAXIS), CE, CB
INTEGER :: GVEC(NOD1:NOD4), GVEC2(NOD1:NOD4), GAS_PTS, ICT, IPT, DUMMY2(IAXIS:KAXIS), DUMMY3
REAL(EB):: XYEL(IAXIS:JAXIS,NOD1:NOD4), VAL, DUMMY(IAXIS:JAXIS)
REAL(EB):: A_COEF,B_COEF,C_COEF,D_COEF,DENOM,AINV(1:2,1:2),FD(1:2),VEC(1:2)
REAL(EB) :: X_CEN, DELX, Y_CEN, DELY, XI, ETA, C1, C2, C3, C4
REAL(EB):: NOUT2(IAXIS:KAXIS)

! Initialize:
CI = 0._EB; CII = 0._EB; CIII = 0._EB; CIV = 0._EB; CV = 0._EB;
PTS2(IAXIS:KAXIS,1:MAX_INTERP_POINTS_PLANE)= 0

! Define maximum direction, add GEOMEPS factors to avoid symmetry cases with random resulting plane:
NOUT2(IAXIS)=ABS(NOUT(IAXIS))+GEOFCT*GEOMEPS
NOUT2(JAXIS)=ABS(NOUT(JAXIS))+ 0._EB*GEOMEPS
NOUT2(KAXIS)=ABS(NOUT(KAXIS))-GEOFCT*GEOMEPS
XNAXIS = MAXLOC(NOUT2(IAXIS:KAXIS),1)
FCTN = INT(SIGN(1._EB,NOUT(XNAXIS)))

! Line P0+s*nout:
XB = P0(XNAXIS)
SELECT CASE(XNAXIS)

   CASE(IAXIS) ! Search plane in the X direction:

      ! xinterval (cell) containing xb:
      XPLANE = -1
      IF (FCTN > 0 ) THEN
         IF ( XB >= XFACE(ILO_FACE-1) ) THEN
            DO I = ILO_FACE,IHI_FACE
               IF ( XB+GEOFCT*GEOMEPS < XFACE(I) ) THEN
                  XPLANE = I + FCELL - 1
                  EXIT
               ENDIF
            ENDDO
         ENDIF
      ELSE
         IF ( XB <= XFACE(IHI_FACE+1) ) THEN
            DO I=IHI_FACE,ILO_FACE,-1
               IF ( XB-GEOFCT*GEOMEPS > XFACE(I) ) THEN
                  XPLANE = I + FCELL
                  EXIT
               ENDIF
            ENDDO
         ENDIF
      ENDIF

      ! Test that xplane is not -1...

      ! Look for planes in the +ve IAXIS, define s:
      IOUT1_LOOP : DO IOUT=1,PLOUT_MAX

         I  = XPLANE + FCTN*IOUT
         SX = XCELL(I) - XB;
         S  = SX / NOUT(XNAXIS)
         SY = S  * NOUT(JAXIS)
         SZ = S  * NOUT(KAXIS)

         XYZ(IAXIS:KAXIS) = (/ XCELL(I), P0(JAXIS)+SY, P0(KAXIS)+SZ /)

         ! NOW FIND INDEXES FOR INTERPOLATION IN Y,Z PLANES:
         YPLANE = -1
         IF ( XYZ(JAXIS) >= YCELL(JLO_CELL-1) ) THEN
            DO J=JLO_CELL,JHI_CELL+1
               IF ( XYZ(JAXIS)+GEOFCT*GEOMEPS < YCELL(J) ) THEN
                  YPLANE = J-1
                  EXIT
               ENDIF
            ENDDO
         ENDIF
         ZPLANE = -1
         IF ( XYZ(KAXIS) >= ZCELL(KLO_CELL-1) ) THEN
            DO K=KLO_CELL,KHI_CELL+1
               IF ( XYZ(KAXIS)+GEOFCT*GEOMEPS < ZCELL(K) ) THEN
                  ZPLANE = K-1
                  EXIT
               ENDIF
            ENDDO
         ENDIF

         ! Test yplane, zplane are not -1...

         ! Now interpolation along nout: xb-xcen-xint_plane
         IF (DIR_FCT > 0._EB) THEN
            CB = (XYZ(IAXIS)-P1(XNAXIS)) / SX
            CE = (P1(XNAXIS)-XB) / SX
         ELSE
            CB = SX / (XYZ(IAXIS)-P1(XNAXIS))
            CE =-(P1(XNAXIS)-XB) / (XYZ(IAXIS)-P1(XNAXIS))
         ENDIF

         ! The 4 interpolation points are: [ix1 ix2 ix3],
         ! [ix1 ix2+1 ix3], [ix1 ix2+1 ix3+1], [ix1 ix2 ix3+1]:
         PTS(IAXIS:KAXIS,NOD1) = (/ I,   YPLANE,   ZPLANE /)
         PTS(IAXIS:KAXIS,NOD2) = (/ I, YPLANE+1,   ZPLANE /)
         PTS(IAXIS:KAXIS,NOD3) = (/ I, YPLANE+1, ZPLANE+1 /)
         PTS(IAXIS:KAXIS,NOD4) = (/ I,   YPLANE, ZPLANE+1 /)
         GVEC(NOD1:NOD4) = 1
         GAS_PTS         = 4
         DO IPT=NOD1,NOD4
            IF (MESHES(NM)%CCVAR(PTS(IAXIS,IPT),PTS(JAXIS,IPT),PTS(KAXIS,IPT),TESTVAR) /= IBM_GASPHASE ) THEN
               GVEC(IPT)= 0
               GAS_PTS  = GAS_PTS - 1
            ENDIF
         ENDDO

         PTS2(IAXIS:KAXIS,NOD1:NOD4) = 0; ICT = 0
         SELECT CASE(GAS_PTS)
         CASE (2,3) ! Only 2 or 3 GASPHASE points:

            IF (GAS_PTS == 2) THEN
               IF (IOUT < PLOUT_MAX) CYCLE ! Try plane further out.
               PTS2(IAXIS:KAXIS,NOD1:NOD3) = PTS(IAXIS:KAXIS,NOD1:NOD3)
               GVEC2(NOD1:NOD3) = GVEC(NOD1:NOD3)
               IF (GVEC(NOD4) == 1) THEN
                  IF (GVEC(NOD1) == 0) THEN
                     PTS2(IAXIS:KAXIS,NOD1) = PTS(IAXIS:KAXIS,NOD4)
                     GVEC2(NOD1) = 1
                  ELSEIF (GVEC(NOD3) == 0) THEN
                     PTS2(IAXIS:KAXIS,NOD3) = PTS(IAXIS:KAXIS,NOD4)
                     GVEC2(NOD3) = 1
                  ENDIF
               ENDIF
            ELSE ! gas_pts == 3
               DO IPT=NOD1,NOD4
                  IF (GVEC(IPT) == 1) THEN
                     ICT = ICT + 1
                     PTS2(IAXIS:KAXIS,ICT) = PTS(IAXIS:KAXIS,IPT)
                  ENDIF
                ENDDO
            ENDIF
            ! Here Stencil coefficients:
            ! Find interpolation values using plane y,z:
            ! This is local IAXIS:JAXIS
            XYEL(IAXIS:JAXIS,NOD1) = (/ YCELL(PTS2(JAXIS,NOD1)), ZCELL(PTS2(KAXIS,NOD1)) /)
            XYEL(IAXIS:JAXIS,NOD2) = (/ YCELL(PTS2(JAXIS,NOD2)), ZCELL(PTS2(KAXIS,NOD2)) /)
            XYEL(IAXIS:JAXIS,NOD3) = (/ YCELL(PTS2(JAXIS,NOD3)), ZCELL(PTS2(KAXIS,NOD3)) /)

            ! Test determinant to check that its +ve, if not swap 2 nodes:
            ! Test that x1-x2-x3 obeys right hand rule:
            VAL = (XYEL(IAXIS,NOD2)-XYEL(IAXIS,NOD1))*(XYEL(JAXIS,NOD3)-XYEL(JAXIS,NOD1)) - &
                  (XYEL(JAXIS,NOD2)-XYEL(JAXIS,NOD1))*(XYEL(IAXIS,NOD3)-XYEL(IAXIS,NOD1))

            ! Transformation Matrix for this triangle in y-z plane:
            IF (SIGN(1._EB,VAL) < 0._EB) THEN ! Rotate node 2 and 3 locations
               DUMMY(IAXIS:JAXIS)     = XYEL(IAXIS:JAXIS,NOD2)
               DUMMY2(IAXIS:KAXIS)    = PTS2(IAXIS:KAXIS,NOD2)
               XYEL(IAXIS:JAXIS,NOD2) = XYEL(IAXIS:JAXIS,NOD3)
               XYEL(IAXIS:JAXIS,NOD3) = DUMMY(IAXIS:JAXIS)
               PTS2(IAXIS:KAXIS,NOD2) = PTS2(IAXIS:KAXIS,NOD3)
               PTS2(IAXIS:KAXIS,NOD3) = DUMMY2(IAXIS:KAXIS)
               IF (GAS_PTS == 2) THEN
                  DUMMY3     = GVEC2(NOD2)
                  GVEC2(NOD2)= GVEC2(NOD3)
                  GVEC2(NOD3)= DUMMY3
               ENDIF
            ENDIF

            ! Inverse of transformation matrix:
            A_COEF = XYEL(IAXIS,NOD1) - XYEL(IAXIS,NOD3)
            B_COEF = XYEL(IAXIS,NOD2) - XYEL(IAXIS,NOD3)
            C_COEF = XYEL(JAXIS,NOD1) - XYEL(JAXIS,NOD3)
            D_COEF = XYEL(JAXIS,NOD2) - XYEL(JAXIS,NOD3)
            DENOM  = A_COEF * D_COEF - B_COEF * C_COEF
            AINV(1,1) =  D_COEF / DENOM
            AINV(2,1) = -C_COEF / DENOM
            AINV(1,2) = -B_COEF / DENOM
            AINV(2,2) =  A_COEF / DENOM

            ! Transform back to master Element coordinates
            ! location of point i,j in y-z coordinates:
            FD(1:2) = (/ XYZ(JAXIS)-XYEL(IAXIS,NOD3), XYZ(KAXIS)-XYEL(JAXIS,NOD3) /)
            VEC(1)  = AINV(1,1)*FD(1) + AINV(1,2)*FD(2)
            VEC(2)  = AINV(2,1)*FD(1) + AINV(2,2)*FD(2)
            ! here xi in vec(1) and eta in vec(2)

            ! Interpolation coefficients in the triangle (shape functions
            ! evaluated on intersection point):
            C1 = VEC(1)                  ! Node 1
            C2 = VEC(2)                  ! Node 2
            C3 = 1._EB - VEC(1) - VEC(2) ! Node 3

            IF (GAS_PTS == 2) THEN
                IF (GVEC2(NOD1) == 0) THEN
                    C2 = C2 + 0.5_EB*C1
                    C3 = C3 + 0.5_EB*C1
                    C1 = 0._EB
                ELSEIF(GVEC2(NOD2) == 0) THEN
                    C1 = C1 + 0.5_EB*C2
                    C3 = C3 + 0.5_EB*C2
                    C2 = 0._EB
                ELSEIF(GVEC2(NOD3) == 0) THEN
                    C1 = C1 + 0.5_EB*C3
                    C2 = C2 + 0.5_EB*C3
                    C3 = 0._EB
                ENDIF
            ENDIF

            ! 4th point is dummy:
            C4 = 0._EB
            PTS2(IAXIS:KAXIS,NOD4) = PTS2(IAXIS:KAXIS,NOD3)

         CASE (4) ! 4 gas_pts, bilinear in the plane:

            ! All GASPHASE:
            PTS2(IAXIS:KAXIS,NOD1:NOD4) = PTS(IAXIS:KAXIS,NOD1:NOD4)

            ! Find interpolation values using plane x2,x3:
            ! This is local IAXIS:JAXIS
            XYEL(IAXIS:JAXIS,NOD1)= (/ YCELL(PTS2(JAXIS,NOD1)), ZCELL(PTS2(KAXIS,NOD1)) /)
            XYEL(IAXIS:JAXIS,NOD2)= (/ YCELL(PTS2(JAXIS,NOD2)), ZCELL(PTS2(KAXIS,NOD2)) /)
            XYEL(IAXIS:JAXIS,NOD3)= (/ YCELL(PTS2(JAXIS,NOD3)), ZCELL(PTS2(KAXIS,NOD3)) /)
            XYEL(IAXIS:JAXIS,NOD4)= (/ YCELL(PTS2(JAXIS,NOD4)), ZCELL(PTS2(KAXIS,NOD4)) /)

            ! Center in local x2,x3:
            X_CEN = 0.5_EB * (XYEL(IAXIS,NOD3) + XYEL(IAXIS,NOD1))
            DELX  =          (XYEL(IAXIS,NOD3) - XYEL(IAXIS,NOD1))
            Y_CEN = 0.5_EB * (XYEL(JAXIS,NOD3) + XYEL(JAXIS,NOD1))
            DELY  =          (XYEL(JAXIS,NOD3) - XYEL(JAXIS,NOD1))

            ! Local natural coords:
            XI = 2._EB/DELX*(XYZ(JAXIS)-X_CEN)
            ETA= 2._EB/DELY*(XYZ(KAXIS)-Y_CEN)

            ! Bilinear coefficients (shape functions evaluated in xi,eta):
            C1 = 0.25_EB*(1._EB-XI)*(1._EB-ETA)
            C2 = 0.25_EB*(1._EB+XI)*(1._EB-ETA)
            C3 = 0.25_EB*(1._EB+XI)*(1._EB+ETA)
            C4 = 0.25_EB*(1._EB-XI)*(1._EB+ETA)

         CASE DEFAULT ! gas_pts < 2

            ! Try plane further out:
            IF ( IOUT == PLOUT_MAX ) THEN
                C1 = 0._EB; C2 = 0._EB; C3 = 0._EB; C4 = 0._EB
                IF(GAS_PTS==1) THEN
                  IF    (GVEC(NOD1) == 1) THEN
                     C1 = 1._EB
                  ELSEIF(GVEC(NOD2) == 1) THEN
                     C2 = 1._EB
                  ELSEIF(GVEC(NOD3) == 1) THEN
                     C3 = 1._EB
                  ELSEIF(GVEC(NOD4) == 1) THEN
                     C4 = 1._EB
                  ENDIF
                ELSE
                  CB = 1._EB
                  CE = 0._EB
                ENDIF
                PTS2(IAXIS:KAXIS,NOD1:NOD4) = PTS(IAXIS:KAXIS,NOD1:NOD4)
                EXIT
            ENDIF
            CYCLE

         END SELECT

         EXIT

      ENDDO IOUT1_LOOP

   CASE(JAXIS) ! Search plane in the Y direction:

      ! y interval (cell) containing xb:
      YPLANE = -1
      IF (FCTN > 0 ) THEN
         IF ( XB >= YFACE(JLO_FACE-1) ) THEN
            DO J = JLO_FACE,JHI_FACE
               IF ( XB+GEOFCT*GEOMEPS < YFACE(J) ) THEN
                  YPLANE = J + FCELL - 1
                  EXIT
               ENDIF
            ENDDO
         ENDIF
      ELSE
         IF ( XB <= YFACE(JHI_FACE+1) ) THEN
            DO J = JHI_FACE,JLO_FACE,-1
               IF ( XB-GEOFCT*GEOMEPS > YFACE(J) ) THEN
                  YPLANE = J + FCELL
                  EXIT
               ENDIF
            ENDDO
         ENDIF
      ENDIF

      ! Test that yplane is not -1...

      ! Look for planes in the +ve JAXIS, define s:
      IOUT2_LOOP : DO IOUT=1,PLOUT_MAX

         J  = YPLANE + FCTN*IOUT
         SY = YCELL(J) - XB
         S  = SY / NOUT(XNAXIS)
         SX = S  *  NOUT(IAXIS)
         SZ = S  *  NOUT(KAXIS)

         XYZ(IAXIS:KAXIS) = (/ P0(IAXIS)+SX, YCELL(J), P0(KAXIS)+SZ /)

         ! Now find indexes for interpolation in z,x planes:
         XPLANE = -1
         IF ( XYZ(IAXIS) >= XCELL(ILO_CELL-1) ) THEN
            DO I=ILO_CELL,IHI_CELL+1
               IF ( XYZ(IAXIS)+GEOFCT*GEOMEPS < XCELL(I) ) THEN
                  XPLANE = I-1
                  EXIT
               ENDIF
            ENDDO
         ENDIF
         ZPLANE = -1
         IF ( XYZ(KAXIS) >= ZCELL(KLO_CELL-1) ) THEN
            DO K=KLO_CELL,KHI_CELL+1
               IF ( XYZ(KAXIS)+GEOFCT*GEOMEPS < ZCELL(K) ) THEN
                  ZPLANE = K-1
                  EXIT
               ENDIF
            ENDDO
         ENDIF

         ! Test zplane, xplane are not -1...

         ! Now interpolation along nout: xb-xcen-xint_plane
         IF (DIR_FCT > 0._EB) THEN
             CB = (XYZ(JAXIS)-P1(XNAXIS)) / SY
             CE = (P1(XNAXIS)-XB) / SY
         ELSE
             CB = SY / (XYZ(JAXIS)-P1(XNAXIS))
             CE =-(P1(XNAXIS)-XB) / (XYZ(JAXIS)-P1(XNAXIS))
         ENDIF

         ! The 4 interpolation points are: [ix1 ix2 ix3],
         ! [ix1 ix2 ix3+1], [ix1+1 ix2 ix3+1], [ix1+1 ix2 ix3]:
         PTS(IAXIS:KAXIS,NOD1) = (/   XPLANE, J,   ZPLANE /)
         PTS(IAXIS:KAXIS,NOD2) = (/   XPLANE, J, ZPLANE+1 /)
         PTS(IAXIS:KAXIS,NOD3) = (/ XPLANE+1, J, ZPLANE+1 /)
         PTS(IAXIS:KAXIS,NOD4) = (/ XPLANE+1, J,   ZPLANE /)
         GVEC(NOD1:NOD4) = 1
         GAS_PTS         = 4
         DO IPT=NOD1,NOD4
            IF (MESHES(NM)%CCVAR(PTS(IAXIS,IPT),PTS(JAXIS,IPT),PTS(KAXIS,IPT),TESTVAR) /= IBM_GASPHASE ) THEN
               GVEC(IPT)= 0
               GAS_PTS  = GAS_PTS - 1
            ENDIF
         ENDDO

         PTS2(IAXIS:KAXIS,NOD1:NOD4) = 0; ICT = 0
         SELECT CASE(GAS_PTS)
         CASE (2,3) ! Only 2 or 3 GASPHASE points:

            IF (GAS_PTS == 2) THEN
               IF (IOUT < PLOUT_MAX) CYCLE ! Try plane further out.
               PTS2(IAXIS:KAXIS,NOD1:NOD3) = PTS(IAXIS:KAXIS,NOD1:NOD3)
               GVEC2(NOD1:NOD3) = GVEC(NOD1:NOD3)
               IF (GVEC(NOD4) == 1) THEN
                  IF (GVEC(NOD1) == 0) THEN
                     PTS2(IAXIS:KAXIS,NOD1) = PTS(IAXIS:KAXIS,NOD4)
                     GVEC2(NOD1) = 1
                  ELSEIF (GVEC(NOD3) == 0) THEN
                     PTS2(IAXIS:KAXIS,NOD3) = PTS(IAXIS:KAXIS,NOD4)
                     GVEC2(NOD3) = 1
                  ENDIF
               ENDIF
            ELSE ! gas_pts == 3
               DO IPT=NOD1,NOD4
                  IF (GVEC(IPT) == 1) THEN
                     ICT = ICT + 1
                     PTS2(IAXIS:KAXIS,ICT) = PTS(IAXIS:KAXIS,IPT)
                  ENDIF
                ENDDO
            ENDIF

            ! Here Stencil coefficients:
            ! Find interpolation values using plane z,x:
            ! This is local IAXIS:JAXIS
            XYEL(IAXIS:JAXIS,NOD1) = (/ ZCELL(PTS2(KAXIS,NOD1)), XCELL(PTS2(IAXIS,NOD1)) /)
            XYEL(IAXIS:JAXIS,NOD2) = (/ ZCELL(PTS2(KAXIS,NOD2)), XCELL(PTS2(IAXIS,NOD2)) /)
            XYEL(IAXIS:JAXIS,NOD3) = (/ ZCELL(PTS2(KAXIS,NOD3)), XCELL(PTS2(IAXIS,NOD3)) /)

            ! Test determinant to check that its +ve, if not swap 2 nodes:
            ! Test that x1-x2-x3 obeys right hand rule:
            VAL = (XYEL(IAXIS,NOD2)-XYEL(IAXIS,NOD1))*(XYEL(JAXIS,NOD3)-XYEL(JAXIS,NOD1)) - &
                  (XYEL(JAXIS,NOD2)-XYEL(JAXIS,NOD1))*(XYEL(IAXIS,NOD3)-XYEL(IAXIS,NOD1))

            ! Transformation Matrix for this triangle in y-z plane:
            IF (SIGN(1._EB,VAL) < 0._EB) THEN ! Rotate node 2 and 3 locations
               DUMMY(IAXIS:JAXIS)     = XYEL(IAXIS:JAXIS,NOD2)
               DUMMY2(IAXIS:KAXIS)    = PTS2(IAXIS:KAXIS,NOD2)
               XYEL(IAXIS:JAXIS,NOD2) = XYEL(IAXIS:JAXIS,NOD3)
               XYEL(IAXIS:JAXIS,NOD3) = DUMMY(IAXIS:JAXIS)
               PTS2(IAXIS:KAXIS,NOD2) = PTS2(IAXIS:KAXIS,NOD3)
               PTS2(IAXIS:KAXIS,NOD3) = DUMMY2(IAXIS:KAXIS)
               IF (GAS_PTS == 2) THEN
                  DUMMY3     = GVEC2(NOD2)
                  GVEC2(NOD2)= GVEC2(NOD3)
                  GVEC2(NOD3)= DUMMY3
               ENDIF
            ENDIF

            ! Inverse of transformation matrix:
            A_COEF = XYEL(IAXIS,NOD1) - XYEL(IAXIS,NOD3)
            B_COEF = XYEL(IAXIS,NOD2) - XYEL(IAXIS,NOD3)
            C_COEF = XYEL(JAXIS,NOD1) - XYEL(JAXIS,NOD3)
            D_COEF = XYEL(JAXIS,NOD2) - XYEL(JAXIS,NOD3)
            DENOM  = A_COEF * D_COEF - B_COEF * C_COEF
            AINV(1,1) =  D_COEF / DENOM
            AINV(2,1) = -C_COEF / DENOM
            AINV(1,2) = -B_COEF / DENOM
            AINV(2,2) =  A_COEF / DENOM

            ! Transform back to master Element coordinates
            ! location of point i,j in z-x coordinates:
            FD(1:2) = (/ XYZ(KAXIS)-XYEL(IAXIS,NOD3), XYZ(IAXIS)-XYEL(JAXIS,NOD3) /)
            VEC(1)  = AINV(1,1)*FD(1) + AINV(1,2)*FD(2)
            VEC(2)  = AINV(2,1)*FD(1) + AINV(2,2)*FD(2)
            ! here xi in vec(1) and eta in vec(2)

            ! Interpolation coefficients in the triangle (shape functions
            ! evaluated on intersection point):
            C1 = VEC(1)                  ! Node 1
            C2 = VEC(2)                  ! Node 2
            C3 = 1._EB - VEC(1) - VEC(2) ! Node 3

            IF (GAS_PTS == 2) THEN
                IF (GVEC2(NOD1) == 0) THEN
                    C2 = C2 + 0.5_EB*C1
                    C3 = C3 + 0.5_EB*C1
                    C1 = 0._EB
                ELSEIF(GVEC2(NOD2) == 0) THEN
                    C1 = C1 + 0.5_EB*C2
                    C3 = C3 + 0.5_EB*C2
                    C2 = 0._EB
                ELSEIF(GVEC2(NOD3) == 0) THEN
                    C1 = C1 + 0.5_EB*C3
                    C2 = C2 + 0.5_EB*C3
                    C3 = 0._EB
                ENDIF
            ENDIF

            ! 4th point is dummy:
            C4 = 0._EB
            PTS2(IAXIS:KAXIS,NOD4) = PTS2(IAXIS:KAXIS,NOD3)

         CASE (4) ! 4 gas_pts, bilinear in the plane:

            ! All GASPHASE:
            PTS2(IAXIS:KAXIS,NOD1:NOD4) = PTS(IAXIS:KAXIS,NOD1:NOD4)

            ! Find interpolation values using plane x2,x3:
            ! This is local IAXIS:JAXIS
            XYEL(IAXIS:JAXIS,NOD1)= (/ ZCELL(PTS2(KAXIS,NOD1)), XCELL(PTS2(IAXIS,NOD1)) /)
            XYEL(IAXIS:JAXIS,NOD2)= (/ ZCELL(PTS2(KAXIS,NOD2)), XCELL(PTS2(IAXIS,NOD2)) /)
            XYEL(IAXIS:JAXIS,NOD3)= (/ ZCELL(PTS2(KAXIS,NOD3)), XCELL(PTS2(IAXIS,NOD3)) /)
            XYEL(IAXIS:JAXIS,NOD4)= (/ ZCELL(PTS2(KAXIS,NOD4)), XCELL(PTS2(IAXIS,NOD4)) /)

            ! Center in local x2,x3:
            X_CEN = 0.5_EB * (XYEL(IAXIS,NOD3) + XYEL(IAXIS,NOD1))
            DELX  =          (XYEL(IAXIS,NOD3) - XYEL(IAXIS,NOD1))
            Y_CEN = 0.5_EB * (XYEL(JAXIS,NOD3) + XYEL(JAXIS,NOD1))
            DELY  =          (XYEL(JAXIS,NOD3) - XYEL(JAXIS,NOD1))

            ! Local natural coords:
            XI = 2._EB/DELX*(XYZ(KAXIS)-X_CEN)
            ETA= 2._EB/DELY*(XYZ(IAXIS)-Y_CEN)

            ! Bilinear coefficients (shape functions evaluated in xi,eta):
            C1 = 0.25_EB*(1._EB-XI)*(1._EB-ETA)
            C2 = 0.25_EB*(1._EB+XI)*(1._EB-ETA)
            C3 = 0.25_EB*(1._EB+XI)*(1._EB+ETA)
            C4 = 0.25_EB*(1._EB-XI)*(1._EB+ETA)

         CASE DEFAULT ! gas_pts < 2

            ! Try plane further out:
            IF ( IOUT == PLOUT_MAX ) THEN
               C1 = 0._EB; C2 = 0._EB; C3 = 0._EB; C4 = 0._EB
               IF(GAS_PTS==1) THEN
                 IF    (GVEC(NOD1) == 1) THEN
                    C1 = 1._EB
                 ELSEIF(GVEC(NOD2) == 1) THEN
                    C2 = 1._EB
                 ELSEIF(GVEC(NOD3) == 1) THEN
                    C3 = 1._EB
                 ELSEIF(GVEC(NOD4) == 1) THEN
                    C4 = 1._EB
                 ENDIF
               ELSE
                 CB = 1._EB
                 CE = 0._EB
               ENDIF
               PTS2(IAXIS:KAXIS,NOD1:NOD4) = PTS(IAXIS:KAXIS,NOD1:NOD4)
               EXIT
            ENDIF
            CYCLE

         END SELECT

         EXIT

      ENDDO IOUT2_LOOP


   CASE(KAXIS) ! Search plane in the Z direction:

      ! Z interval (cell) containing xb:
      ZPLANE = -1
      IF (FCTN > 0 ) THEN
         IF ( XB >= ZFACE(KLO_FACE-1) ) THEN
            DO K = KLO_FACE,KHI_FACE
               IF ( XB+GEOFCT*GEOMEPS < ZFACE(K) ) THEN
                  ZPLANE = K + FCELL - 1
                  EXIT
               ENDIF
            ENDDO
         ENDIF
      ELSE
         IF ( XB <= ZFACE(KHI_FACE+1) ) THEN
            DO K = KHI_FACE,KLO_FACE,-1
               IF ( XB-GEOFCT*GEOMEPS > ZFACE(K) ) THEN
                  ZPLANE = K + FCELL
                  EXIT
               ENDIF
            ENDDO
         ENDIF
      ENDIF

      ! Test that zplane is not -1...

      ! Look for planes in the +ve KAXIS, define s:
      IOUT3_LOOP : DO IOUT=1,PLOUT_MAX

         K  = ZPLANE + FCTN*IOUT
         SZ = ZCELL(K) - XB
         S  = SZ / NOUT(XNAXIS)
         SX = S  *  NOUT(IAXIS)
         SY = S  *  NOUT(JAXIS)

         XYZ(IAXIS:KAXIS) = (/ P0(IAXIS)+SX, P0(JAXIS)+SY, ZCELL(K) /)

         ! Now find indexes for interpolation in x,y planes:
         XPLANE = -1
         IF ( XYZ(IAXIS) >= XCELL(ILO_CELL-1) ) THEN
            DO I=ILO_CELL,IHI_CELL+1
               IF ( XYZ(IAXIS)+GEOFCT*GEOMEPS < XCELL(I) ) THEN
                  XPLANE = I-1
                  EXIT
               ENDIF
            ENDDO
         ENDIF
         YPLANE = -1
         IF ( XYZ(JAXIS) >= YCELL(JLO_CELL-1) ) THEN
            DO J=JLO_CELL,JHI_CELL+1
               IF ( XYZ(JAXIS)+GEOFCT*GEOMEPS < YCELL(J) ) THEN
                  YPLANE = J-1
                  EXIT
               ENDIF
            ENDDO
         ENDIF

         ! Test xplane, yplane are not -1...

         ! Now interpolation along nout: xb-xcen-xint_plane
         IF (DIR_FCT > 0) THEN
             CB = (XYZ(KAXIS)-P1(XNAXIS)) / SZ
             CE = (P1(XNAXIS)-XB) / SZ
         ELSE
             CB = SZ / (XYZ(KAXIS)-P1(XNAXIS))
             CE =-(P1(XNAXIS)-XB) / (XYZ(KAXIS)-P1(XNAXIS))
         ENDIF

         ! The 4 interpolation points are: [ix1 ix2 ix3],
         ! [ix1+1 ix2 ix3], [ix1+1 ix2+1 ix3], [ix1 ix2+1 ix3]:
         PTS(IAXIS:KAXIS,NOD1) = (/   XPLANE,   YPLANE,  K /)
         PTS(IAXIS:KAXIS,NOD2) = (/ XPLANE+1,   YPLANE,  K /)
         PTS(IAXIS:KAXIS,NOD3) = (/ XPLANE+1, YPLANE+1,  K /)
         PTS(IAXIS:KAXIS,NOD4) = (/   XPLANE, YPLANE+1,  K /)
         GVEC(NOD1:NOD4) = 1
         GAS_PTS         = 4
         DO IPT=NOD1,NOD4
            IF (MESHES(NM)%CCVAR(PTS(IAXIS,IPT),PTS(JAXIS,IPT),PTS(KAXIS,IPT),TESTVAR) /= IBM_GASPHASE ) THEN
               GVEC(IPT)= 0
               GAS_PTS  = GAS_PTS - 1
            ENDIF
         ENDDO

         PTS2(IAXIS:KAXIS,NOD1:NOD4) = 0; ICT = 0
         SELECT CASE(GAS_PTS)
         CASE (2,3) ! Only 2 or 3 GASPHASE points:

            IF (GAS_PTS == 2) THEN
               IF (IOUT < PLOUT_MAX) CYCLE ! Try plane further out.
               PTS2(IAXIS:KAXIS,NOD1:NOD3) = PTS(IAXIS:KAXIS,NOD1:NOD3)
               GVEC2(NOD1:NOD3) = GVEC(NOD1:NOD3)
               IF (GVEC(NOD4) == 1) THEN
                  IF (GVEC(NOD1) == 0) THEN
                     PTS2(IAXIS:KAXIS,NOD1) = PTS(IAXIS:KAXIS,NOD4)
                     GVEC2(NOD1) = 1
                  ELSEIF (GVEC(NOD3) == 0) THEN
                     PTS2(IAXIS:KAXIS,NOD3) = PTS(IAXIS:KAXIS,NOD4)
                     GVEC2(NOD3) = 1
                  ENDIF
               ENDIF
            ELSE ! gas_pts == 3
               DO IPT=NOD1,NOD4
                  IF (GVEC(IPT) == 1) THEN
                     ICT = ICT + 1
                     PTS2(IAXIS:KAXIS,ICT) = PTS(IAXIS:KAXIS,IPT)
                  ENDIF
                ENDDO
            ENDIF

            ! Here Stencil coefficients:
            ! Find interpolation values using plane x,y:
            ! This is local IAXIS:JAXIS
            XYEL(IAXIS:JAXIS,NOD1) = (/ XCELL(PTS2(IAXIS,NOD1)), YCELL(PTS2(JAXIS,NOD1)) /)
            XYEL(IAXIS:JAXIS,NOD2) = (/ XCELL(PTS2(IAXIS,NOD2)), YCELL(PTS2(JAXIS,NOD2)) /)
            XYEL(IAXIS:JAXIS,NOD3) = (/ XCELL(PTS2(IAXIS,NOD3)), YCELL(PTS2(JAXIS,NOD3)) /)

            ! Test determinant to check that its +ve, if not swap 2 nodes:
            ! Test that x1-x2-x3 obeys right hand rule:
            VAL = (XYEL(IAXIS,NOD2)-XYEL(IAXIS,NOD1))*(XYEL(JAXIS,NOD3)-XYEL(JAXIS,NOD1)) - &
                  (XYEL(JAXIS,NOD2)-XYEL(JAXIS,NOD1))*(XYEL(IAXIS,NOD3)-XYEL(IAXIS,NOD1))

            ! Transformation Matrix for this triangle in x-y plane:
            IF (SIGN(1._EB,VAL) < 0._EB) THEN ! Rotate node 2 and 3 locations
               DUMMY(IAXIS:JAXIS)     = XYEL(IAXIS:JAXIS,NOD2)
               DUMMY2(IAXIS:KAXIS)    = PTS2(IAXIS:KAXIS,NOD2)
               XYEL(IAXIS:JAXIS,NOD2) = XYEL(IAXIS:JAXIS,NOD3)
               XYEL(IAXIS:JAXIS,NOD3) = DUMMY(IAXIS:JAXIS)
               PTS2(IAXIS:KAXIS,NOD2) = PTS2(IAXIS:KAXIS,NOD3)
               PTS2(IAXIS:KAXIS,NOD3) = DUMMY2(IAXIS:KAXIS)
               IF (GAS_PTS == 2) THEN
                  DUMMY3     = GVEC2(NOD2)
                  GVEC2(NOD2)= GVEC2(NOD3)
                  GVEC2(NOD3)= DUMMY3
               ENDIF
            ENDIF

            ! Inverse of transformation matrix:
            A_COEF = XYEL(IAXIS,NOD1) - XYEL(IAXIS,NOD3)
            B_COEF = XYEL(IAXIS,NOD2) - XYEL(IAXIS,NOD3)
            C_COEF = XYEL(JAXIS,NOD1) - XYEL(JAXIS,NOD3)
            D_COEF = XYEL(JAXIS,NOD2) - XYEL(JAXIS,NOD3)
            DENOM  = A_COEF * D_COEF - B_COEF * C_COEF
            AINV(1,1) =  D_COEF / DENOM
            AINV(2,1) = -C_COEF / DENOM
            AINV(1,2) = -B_COEF / DENOM
            AINV(2,2) =  A_COEF / DENOM

            ! Transform back to master Element coordinates
            ! location of point i,j in x-y coordinates:
            FD(1:2) = (/ XYZ(IAXIS)-XYEL(IAXIS,NOD3), XYZ(JAXIS)-XYEL(JAXIS,NOD3) /)
            VEC(1)  = AINV(1,1)*FD(1) + AINV(1,2)*FD(2)
            VEC(2)  = AINV(2,1)*FD(1) + AINV(2,2)*FD(2)
            ! here xi in vec(1) and eta in vec(2)

            ! Interpolation coefficients in the triangle (shape functions
            ! evaluated on intersection point):
            C1 = VEC(1)                  ! Node 1
            C2 = VEC(2)                  ! Node 2
            C3 = 1._EB - VEC(1) - VEC(2) ! Node 3

            IF (GAS_PTS == 2) THEN
                IF (GVEC2(NOD1) == 0) THEN
                    C2 = C2 + 0.5_EB*C1
                    C3 = C3 + 0.5_EB*C1
                    C1 = 0._EB
                ELSEIF(GVEC2(NOD2) == 0) THEN
                    C1 = C1 + 0.5_EB*C2
                    C3 = C3 + 0.5_EB*C2
                    C2 = 0._EB
                ELSEIF(GVEC2(NOD3) == 0) THEN
                    C1 = C1 + 0.5_EB*C3
                    C2 = C2 + 0.5_EB*C3
                    C3 = 0._EB
                ENDIF
            ENDIF

            ! 4th point is dummy:
            C4 = 0._EB
            PTS2(IAXIS:KAXIS,NOD4) = PTS2(IAXIS:KAXIS,NOD3)

         CASE (4) ! 4 gas_pts, bilinear in the plane:

            ! All GASPHASE:
            PTS2(IAXIS:KAXIS,NOD1:NOD4) = PTS(IAXIS:KAXIS,NOD1:NOD4)

            ! Find interpolation values using plane x2,x3:
            ! This is local IAXIS:JAXIS
            XYEL(IAXIS:JAXIS,NOD1) = (/ XCELL(PTS2(IAXIS,NOD1)), YCELL(PTS2(JAXIS,NOD1)) /)
            XYEL(IAXIS:JAXIS,NOD2) = (/ XCELL(PTS2(IAXIS,NOD2)), YCELL(PTS2(JAXIS,NOD2)) /)
            XYEL(IAXIS:JAXIS,NOD3) = (/ XCELL(PTS2(IAXIS,NOD3)), YCELL(PTS2(JAXIS,NOD3)) /)
            XYEL(IAXIS:JAXIS,NOD4) = (/ XCELL(PTS2(IAXIS,NOD4)), YCELL(PTS2(JAXIS,NOD4)) /)

            ! Center in local x2,x3:
            X_CEN = 0.5_EB * (XYEL(IAXIS,NOD3) + XYEL(IAXIS,NOD1))
            DELX  =          (XYEL(IAXIS,NOD3) - XYEL(IAXIS,NOD1))
            Y_CEN = 0.5_EB * (XYEL(JAXIS,NOD3) + XYEL(JAXIS,NOD1))
            DELY  =          (XYEL(JAXIS,NOD3) - XYEL(JAXIS,NOD1))

            ! Local natural coords:
            XI = 2._EB/DELX*(XYZ(IAXIS)-X_CEN)
            ETA= 2._EB/DELY*(XYZ(JAXIS)-Y_CEN)

            ! Bilinear coefficients (shape functions evaluated in xi,eta):
            C1 = 0.25_EB*(1._EB-XI)*(1._EB-ETA)
            C2 = 0.25_EB*(1._EB+XI)*(1._EB-ETA)
            C3 = 0.25_EB*(1._EB+XI)*(1._EB+ETA)
            C4 = 0.25_EB*(1._EB-XI)*(1._EB+ETA)

         CASE DEFAULT ! gas_pts < 2

            ! Try plane further out:
            IF ( IOUT == PLOUT_MAX ) THEN
               C1 = 0._EB; C2 = 0._EB; C3 = 0._EB; C4 = 0._EB
               IF(GAS_PTS==1) THEN
                 IF    (GVEC(NOD1) == 1) THEN
                    C1 = 1._EB
                 ELSEIF(GVEC(NOD2) == 1) THEN
                    C2 = 1._EB
                 ELSEIF(GVEC(NOD3) == 1) THEN
                    C3 = 1._EB
                 ELSEIF(GVEC(NOD4) == 1) THEN
                    C4 = 1._EB
                 ENDIF
               ELSE
                 CB = 1._EB
                 CE = 0._EB
               ENDIF
               PTS2(IAXIS:KAXIS,NOD1:NOD4) = PTS(IAXIS:KAXIS,NOD1:NOD4)
               EXIT
            ENDIF
            CYCLE

         END SELECT

         EXIT

      ENDDO IOUT3_LOOP

END SELECT

! Coefficients:
CI  =    CB
CII = CE*C1
CIII= CE*C2
CIV = CE*C3
CV  = CE*C4

RETURN
END SUBROUTINE GET_INTSTENCILS_VOL3D


! --------------------------- GET_CLSPT_INBCF -----------------------------------

SUBROUTINE GET_CLSPT_INBCF(NM,XYZ,INBFC,INBFC_LOC,XYZ_IP,DIST,FOUNDPT,INSEG)

INTEGER,  INTENT(IN) :: NM, INBFC, INBFC_LOC
REAL(EB), INTENT(IN) :: XYZ(MAX_DIM)
REAL(EB), INTENT(OUT):: XYZ_IP(MAX_DIM), DIST
LOGICAL,  INTENT(OUT):: FOUNDPT, INSEG

! Local Variables:
INTEGER :: CFELEM(1:IBM_MAXVERT_CUTFACE),BODTRI(1:2)
INTEGER :: X1AXIS,X2AXIS,X3AXIS
INTEGER :: IBOD,IWSEL,NVFACE,IPT
REAL(EB):: NVEC(MAX_DIM),ANVEC(MAX_DIM),P0(MAX_DIM),A,B,C,D,PROJ_COEFF,XYZ_P(MAX_DIM)
REAL(EB):: AREAI,PTCEN(IAXIS:JAXIS),V1(IAXIS:JAXIS),V2(IAXIS:JAXIS)
REAL(EB):: SQRDIST, SQRDISTI, X2X3_1(IAXIS:JAXIS), X2X3_2(IAXIS:JAXIS)
REAL(EB):: DP(IAXIS:JAXIS),PCM1(IAXIS:JAXIS),PCM2(IAXIS:JAXIS),X2X3_IP(IAXIS:JAXIS)
REAL(EB):: T,DPDOTDP,SLOC

! Initialize:
XYZ_IP(IAXIS:KAXIS) = 0._EB
DIST    = 1._EB / GEOMEPS
FOUNDPT = .FALSE.
INSEG   = .FALSE.

CFELEM(1:IBM_MAXVERT_CUTFACE)  = MESHES(NM)%CUT_FACE(INBFC)%CFELEM(1:IBM_MAXVERT_CUTFACE,INBFC_LOC)
BODTRI(1:2)  = MESHES(NM)%CUT_FACE(INBFC)%BODTRI(1:2,INBFC_LOC)

! normal vector to boundary surface triangle:
IBOD    = BODTRI(1)
IWSEL   = BODTRI(2)
NVEC(IAXIS:KAXIS)    = GEOMETRY(IBOD)%FACES_NORMAL(IAXIS:KAXIS,IWSEL)
NVFACE  = CFELEM(1)

! Plane equation for INBOUNDARY cut-face plane:
! Location of first point in cf polygon is P0:
IPT = 1
P0(IAXIS:KAXIS) = MESHES(NM)%CUT_FACE(INBFC)%XYZVERT(IAXIS:KAXIS,CFELEM(IPT+1))
A = NVEC(IAXIS)
B = NVEC(JAXIS)
C = NVEC(KAXIS)
D = -(A*P0(IAXIS) + B*P0(JAXIS) + C*P0(KAXIS))

! Project xyz point into plane of cf polygon:
PROJ_COEFF = (A*XYZ(IAXIS)+B*XYZ(JAXIS)+C*XYZ(KAXIS)) + D ! /dot(n,n) = 1
XYZ_P(IAXIS:KAXIS) = XYZ(IAXIS:KAXIS) - PROJ_COEFF*NVEC(IAXIS:KAXIS)

! Which Cartesian plane we project to?
ANVEC(IAXIS) = ABS(NVEC(IAXIS)); ANVEC(JAXIS) = ABS(NVEC(JAXIS)); ANVEC(KAXIS) = ABS(NVEC(KAXIS))
IF ( MAX(ANVEC(IAXIS),MAX(ANVEC(JAXIS),ANVEC(KAXIS))) == ANVEC(IAXIS) ) THEN
   X1AXIS = IAXIS; X2AXIS = JAXIS; X3AXIS = KAXIS
ELSEIF ( MAX(ANVEC(IAXIS),MAX(ANVEC(JAXIS),ANVEC(KAXIS))) == ANVEC(JAXIS) ) THEN
   X1AXIS = JAXIS; X2AXIS = KAXIS; X3AXIS = IAXIS
ELSE
   X1AXIS = KAXIS; X2AXIS = IAXIS; X3AXIS = JAXIS
ENDIF

! Now find closest point in projected plane:
! First: Test if point is inside cf area: Compute area of triangles formed
! by projected point xyz_p in x2,x3 plane and cf XYZvert, resp to
! CUT_FACE.area*nvec(x1axis), i.e. cut-face area projected on the Cartesian
! plane orthogonal to x1axis:
AREAI = 0._EB
PTCEN(IAXIS:JAXIS) = XYZ_P( (/ X2AXIS, X3AXIS /) )
DO IPT=1,NVFACE-1
   V1(IAXIS:JAXIS) = MESHES(NM)%CUT_FACE(INBFC)%XYZVERT( (/ X2AXIS, X3AXIS /) ,CFELEM(IPT+1)) - &
                     PTCEN(IAXIS:JAXIS)
   V2(IAXIS:JAXIS) = MESHES(NM)%CUT_FACE(INBFC)%XYZVERT( (/ X2AXIS, X3AXIS /) ,CFELEM(IPT+2)) - &
                     PTCEN(IAXIS:JAXIS)
   AREAI = AREAI + ABS(V1(IAXIS)*V2(JAXIS)-V1(JAXIS)*V2(IAXIS))  ! NORM(CROSS(V1,V2));
ENDDO
! Last seg:
V1(IAXIS:JAXIS) = MESHES(NM)%CUT_FACE(INBFC)%XYZVERT( (/ X2AXIS, X3AXIS /) ,CFELEM(NVFACE+1)) - &
                  PTCEN(IAXIS:JAXIS)
V2(IAXIS:JAXIS) = MESHES(NM)%CUT_FACE(INBFC)%XYZVERT( (/ X2AXIS, X3AXIS /) ,CFELEM(       2)) - &
                  PTCEN(IAXIS:JAXIS)
AREAI = (AREAI + ABS(V1(IAXIS)*V2(JAXIS)-V1(JAXIS)*V2(IAXIS))) / 2._EB

! Test if inside:
IF ( ABS(AREAI-MESHES(NM)%CUT_FACE(INBFC)%AREA(INBFC_LOC)*ANVEC(X1AXIS)) < GEOMEPS ) THEN
   ! Same areas, xyz_p inside INBOUNDARY cut-face:
   XYZ_IP(IAXIS:KAXIS) = XYZ_P(IAXIS:KAXIS)
   DIST   = SQRT( (XYZ(IAXIS)-XYZ_IP(IAXIS))**2._EB + &
                  (XYZ(JAXIS)-XYZ_IP(JAXIS))**2._EB + &
                  (XYZ(KAXIS)-XYZ_IP(KAXIS))**2._EB )
   FOUNDPT= .TRUE.
   RETURN
ENDIF

! Second, test against segments: Find closest point in segments in x2,x3 plane:
SQRDIST = 1._EB / GEOMEPS
DO IPT=1,NVFACE-1

    X2X3_1(IAXIS:JAXIS) = MESHES(NM)%CUT_FACE(INBFC)%XYZVERT((/ X2AXIS, X3AXIS /) ,CFELEM(IPT+1))
    X2X3_2(IAXIS:JAXIS) = MESHES(NM)%CUT_FACE(INBFC)%XYZVERT((/ X2AXIS, X3AXIS /) ,CFELEM(IPT+2))

    ! Smallest distance from point PC to segment x2x3_1-x2x3_2:
    DP(IAXIS:JAXIS)     = X2X3_2(IAXIS:JAXIS) - X2X3_1(IAXIS:JAXIS)
    PCM1(IAXIS:JAXIS)   =  PTCEN(IAXIS:JAXIS) - X2X3_1(IAXIS:JAXIS)
    T      = DP(IAXIS)*PCM1(IAXIS) + DP(JAXIS)*PCM1(JAXIS)
    DPDOTDP= DP(IAXIS)**2._EB + DP(JAXIS)**2._EB

    IF ( T <= 0._EB ) THEN
        SQRDISTI = PCM1(IAXIS)**2._EB + PCM1(JAXIS)**2._EB ! x2x3_1 is closest pt.
        T = 0._EB
    ELSEIF ( T >= DPDOTDP ) THEN
        PCM2(IAXIS:JAXIS) = PTCEN(IAXIS:JAXIS) - X2X3_2(IAXIS:JAXIS)
        SQRDISTI = PCM2(IAXIS)**2._EB + PCM2(JAXIS)**2._EB ! x2x3_2 is closest pt.
        T = DPDOTDP
    ELSE
        SQRDISTI =(PCM1(IAXIS)**2._EB + PCM1(JAXIS)**2._EB) - T**2._EB/DPDOTDP
    ENDIF

    ! Test:
    IF ( SQRDISTI < SQRDIST ) THEN
        SQRDIST = SQRDISTI
        SLOC    = (T/DPDOTDP)
        X2X3_IP(IAXIS:JAXIS) = X2X3_1(IAXIS:JAXIS) + SLOC * DP(IAXIS:JAXIS) ! intersection point in segment,
                                                                            ! plane x2,x3
        FOUNDPT= .TRUE.
        INSEG  = .TRUE.
    ENDIF
ENDDO

! Now pass x2x3 intersection point to 3D:
IF (FOUNDPT) THEN
    SELECT CASE(X1AXIS)
        CASE(IAXIS)
            XYZ_IP(JAXIS) = X2X3_IP(IAXIS)
            XYZ_IP(KAXIS) = X2X3_IP(JAXIS)
            XYZ_IP(IAXIS) = (-B*XYZ_IP(JAXIS) -C*XYZ_IP(KAXIS) - D)/A
        CASE(JAXIS)
            XYZ_IP(KAXIS) = X2X3_IP(IAXIS)
            XYZ_IP(IAXIS) = X2X3_IP(JAXIS)
            XYZ_IP(JAXIS) = (-A*XYZ_IP(IAXIS) -C*XYZ_IP(KAXIS) - D)/B
        CASE(KAXIS)
            XYZ_IP(IAXIS) = X2X3_IP(IAXIS)
            XYZ_IP(JAXIS) = X2X3_IP(JAXIS)
            XYZ_IP(KAXIS) = (-A*XYZ_IP(IAXIS) -B*XYZ_IP(JAXIS) - D)/C
    END SELECT
    DIST   = SQRT( (XYZ(IAXIS)-XYZ_IP(IAXIS))**2._EB + &
                   (XYZ(JAXIS)-XYZ_IP(JAXIS))**2._EB + &
                   (XYZ(KAXIS)-XYZ_IP(KAXIS))**2._EB )
ENDIF


RETURN
END SUBROUTINE GET_CLSPT_INBCF


! -------------------------- GET_CLOSEPT_CCVT -----------------------------------

SUBROUTINE GET_CLOSEPT_CCVT(NM,XYZ,ICC,XYZ_IP,DIST,FOUNDPT,IFCPT,IFCPT_LOC)

INTEGER,  INTENT(IN) :: NM, ICC
REAL(EB), INTENT(IN) :: XYZ(MAX_DIM)
REAL(EB), INTENT(OUT):: XYZ_IP(MAX_DIM), DIST
INTEGER,  INTENT(OUT):: IFCPT, IFCPT_LOC
LOGICAL,  INTENT(OUT):: FOUNDPT

! Local Variables:
INTEGER :: I,J,K,IJK(MAX_DIM),IJK_CELL(MAX_DIM),LOWHIGH,IND_ADD
INTEGER :: X1AXIS,X2AXIS,X3AXIS,XIAXIS,XJAXIS,XKAXIS,CEI,ICF,IX2,IX3
LOGICAL :: INLIST, ISCORN
INTEGER :: INDXI(MAX_DIM),IPT,IVERT,ICORN,INDI,INDJ,INDK
REAL(EB), POINTER, DIMENSION(:) :: X2FC,X3FC!,X1FC,X1CL,X2CL,X3CL,DX1FC,DX2FC,DX3FC,DX1CL,DX2CL,DX3CL
REAL(EB):: DV(MAX_DIM),XY1(1:4,IAXIS:JAXIS)
INTEGER :: JJ,KK,INDXI1(IAXIS:JAXIS),INDXI2(IAXIS:JAXIS),INDXI3(IAXIS:JAXIS),INDXI4(IAXIS:JAXIS)
LOGICAL :: CEIFLG

! Initialize:
XYZ_IP(IAXIS:KAXIS) = 0._EB
DIST    = 1._EB / GEOMEPS
FOUNDPT = .FALSE.
IFCPT   = 0; IFCPT_LOC = 0

! Here we need to look at Cartesian faces that are boundary of
! CUT_CELL(icc) (which has only regular or Gasphase cut-faces of regular
! size and find if a corner point (or sigular point) is type SOLID. The
! point found provides xyz_ip:
IJK_CELL(IAXIS:KAXIS) = MESHES(NM)%CUT_CELL(ICC)%IJK(IAXIS:KAXIS)

! Loop on different planes:
LOWHIGH_IND_LOOP : DO LOWHIGH=LOW_IND,HIGH_IND

   IND_ADD = LOWHIGH - LOW_IND  ! Index to add for face LOW-HIGH resp to cell.

   X1AXIS_LOOP : DO X1AXIS=IAXIS,KAXIS

      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         I = IJK_CELL(IAXIS)-FCELL+IND_ADD
         J = IJK_CELL(JAXIS)
         K = IJK_CELL(KAXIS)
         X2AXIS = JAXIS; X3AXIS = KAXIS
         ! location in I,J,K of x1,x2,x3 axes:
         XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS
         ! Centroid coordinates in x1,x2,x3 axes:
         ! X2CL => YCELL; DX2CL => DYCELL
         ! X3CL => ZCELL; DX3CL => DZCELL
         ! X1FC => XFACE
         X2FC => YFACE
         X3FC => ZFACE

      CASE(JAXIS)
         I = IJK_CELL(IAXIS)
         J = IJK_CELL(JAXIS)-FCELL+IND_ADD
         K = IJK_CELL(KAXIS)
         X2AXIS = KAXIS; X3AXIS = IAXIS
         ! location in I,J,K of x1,x2,x3 axes:
         XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS
         ! Centroid coordinates in x1,x2,x3 axes:
         ! X2CL => ZCELL; DX2CL => DZCELL
         ! X3CL => XCELL; DX3CL => DXCELL
         ! X1FC => YFACE;
         X2FC => ZFACE;
         X3FC => XFACE;
      CASE(KAXIS)

         I = IJK_CELL(IAXIS)
         J = IJK_CELL(JAXIS)
         K = IJK_CELL(KAXIS)-FCELL+IND_ADD
         X2AXIS = IAXIS; X3AXIS = JAXIS
         ! location in I,J,K of x1,x2,x3 axes:
         XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS
         ! Face coordinates in x1,x2,x3 axes:
         ! X2CL => XCELL; DX2CL => DXCELL
         ! X3CL => YCELL; DX3CL => DYCELL
         ! X1FC => ZFACE
         X2FC => XFACE
         X3FC => YFACE

      END SELECT

      ! Drop if face is regular GASPHASE:
      IF ( MESHES(NM)%FCVAR(I,J,K,IBM_FGSC,X1AXIS) == IBM_GASPHASE ) CYCLE

      ! Face IJK:
      IJK(IAXIS:KAXIS) = (/ I, J, K /)

      ! Cartesian Face centroid location x2-x3 plane:
      CEI = MESHES(NM)%FCVAR(I,J,K,IBM_IDCE,X1AXIS)
      ICF = MESHES(NM)%FCVAR(I,J,K,IBM_IDCF,X1AXIS)

      ! We might have single point CEIs:
      CEIFLG = .FALSE.
      IF (CEI <= 0) THEN
         CEIFLG = .TRUE.
      ELSEIF ( MESHES(NM)%CUT_EDGE(CEI)%NVERT == 1 ) THEN
         CEIFLG = .TRUE.
      ENDIF

      IF (CEIFLG) THEN ! Cut face is one regular face, with one SOLID vertex.

         ! Figure out which vertex is SOLID and location:
         INLIST = .FALSE.
         DO IX3=0,1
            DO IX2=0,1
               ! Vertex axes:
               INDXI(IAXIS:KAXIS) = (/ IJK(X1AXIS), IJK(X2AXIS)-FCELL+IX2, IJK(X3AXIS)-FCELL+IX3 /) ! x1,x2,x3
               INDI = INDXI(XIAXIS)
               INDJ = INDXI(XJAXIS)
               INDK = INDXI(XKAXIS)
               IF ( MESHES(NM)%VERTVAR(INDI,INDJ,INDK,IBM_VGSC) == IBM_SOLID ) THEN
                  INLIST = .TRUE.
                  EXIT
               ENDIF
            ENDDO
            IF (INLIST) THEN
               XYZ_IP(IAXIS:KAXIS)  = (/ XFACE(INDI), YFACE(INDJ), ZFACE(INDK) /)
               DIST   = SQRT( (XYZ(IAXIS)-XYZ_IP(IAXIS))**2._EB + &
                              (XYZ(JAXIS)-XYZ_IP(JAXIS))**2._EB + &
                              (XYZ(KAXIS)-XYZ_IP(KAXIS))**2._EB )
               IFCPT  = ICF
               ! Find local point:
               DO IPT=1,MESHES(NM)%CUT_FACE(ICF)%NVERT
                  DV = MESHES(NM)%CUT_FACE(ICF)%XYZVERT(IAXIS:KAXIS,IPT) - XYZ_IP(IAXIS:KAXIS)
                  IF( (ABS(DV(IAXIS))+ABS(DV(JAXIS))+ABS(DV(KAXIS))) < GEOMEPS ) THEN
                     IFCPT_LOC = IPT
                     EXIT
                  ENDIF
               ENDDO
               FOUNDPT = .TRUE.
               RETURN
            ENDIF
         ENDDO

         ! Check if there are more than 4 vertices, get vertex that is not in corners:
         IF ( MESHES(NM)%CUT_FACE(ICF)%NVERT > 4 ) THEN

            JJ = IJK(X2AXIS); KK = IJK(X3AXIS)
            ! Vertex at index jj-FCELL,kk-FCELL:
            INDXI1(IAXIS:JAXIS) = (/ JJ-FCELL  , KK-FCELL   /) ! Local x2,x3
            ! Vertex at index jj-FCELL+1,kk-FCELL:
            INDXI2(IAXIS:JAXIS) = (/ JJ-FCELL+1, KK-FCELL   /) ! Local x2,x3
            ! Vertex at index jj-FCELL+1,kk-FCELL+1:
            INDXI3(IAXIS:JAXIS) = (/ JJ-FCELL+1, KK-FCELL+1 /) ! Local x2,x3
            ! Vertex at index jj-FCELL,kk-FCELL+1:
            INDXI4(IAXIS:JAXIS) = (/ JJ-FCELL  , KK-FCELL+1 /) ! Local x2,x3

            XY1(1:4,IAXIS) = (/ X2FC(INDXI1(IAXIS)), X2FC(INDXI2(IAXIS)), &
                                X2FC(INDXI3(IAXIS)), X2FC(INDXI4(IAXIS)) /)
            XY1(1:4,JAXIS) = (/ X3FC(INDXI1(JAXIS)), X3FC(INDXI2(JAXIS)), &
                                X3FC(INDXI3(JAXIS)), X3FC(INDXI4(JAXIS)) /)

            ! Find vertex:
            DO IVERT=1,MESHES(NM)%CUT_FACE(ICF)%NVERT
               ISCORN = .FALSE.
               DO ICORN=1,4
                  IF( SQRT( (XY1(ICORN,IAXIS)-MESHES(NM)%CUT_FACE(ICF)%XYZVERT(X2AXIS,IVERT))**2._EB + &
                            (XY1(ICORN,JAXIS)-MESHES(NM)%CUT_FACE(ICF)%XYZVERT(X3AXIS,IVERT))**2._EB ) &
                            < GEOMEPS) THEN
                     ISCORN = .TRUE.
                     EXIT
                  ENDIF
               ENDDO
               IF (.NOT.ISCORN) THEN
                  XYZ_IP(IAXIS:KAXIS) = MESHES(NM)%CUT_FACE(ICF)%XYZVERT(IAXIS:KAXIS,IVERT)
                  INLIST = .TRUE.
                  EXIT
               ENDIF
            ENDDO
            IF (INLIST) THEN
               DIST   = SQRT( (XYZ(IAXIS)-XYZ_IP(IAXIS))**2._EB + &
                              (XYZ(JAXIS)-XYZ_IP(JAXIS))**2._EB + &
                              (XYZ(KAXIS)-XYZ_IP(KAXIS))**2._EB )
               IFCPT     = ICF
               IFCPT_LOC = IVERT
               FOUNDPT   = .TRUE.
               RETURN
            ENDIF

         ENDIF

      ENDIF ! CEI <= 0

      !NULLIFY(X2CL,X3CL,DX2CL,DX3CL,X1FC,X2FC,X3FC)
      NULLIFY(X2FC,X3FC)

   ENDDO X1AXIS_LOOP

ENDDO LOWHIGH_IND_LOOP


RETURN
END SUBROUTINE GET_CLOSEPT_CCVT


! ----------------------- SET_CCIBM_MATVEC_DATA ---------------------------------

SUBROUTINE SET_CCIBM_MATVEC_DATA

USE MPI

! Local variables:
INTEGER :: NM, I, IPROC, IERR

! Explicit CC time integration: Set threshold volume of linked cells to 0.95 of Cartesian cell vol.
IF (.NOT.DO_IMPLICIT_CCREGION) CCVOL_LINK=0.95_EB

! 1. Define unknown numbers for Scalars:
CALL GET_MATRIX_INDEXES_Z

! 2. For each IBM_GASPHASE (cut or regular) face, find global numeration of the volumes
! that share it, store a list of areas and centroids for diffussion operator in FV form.
! 3. Get IBM_GASPHASE regular faces data, for scalars Z:
CALL GET_GASPHASE_REGFACES_DATA

! 4. Get IBM_GASPHASE cut-faces data:
CALL GET_GASPHASE_CUTFACES_DATA ! Here there is no need to populate CELL_LIST on CUT_FACE,
                                ! list of low/high cut-cell volumes that share the cut-face, as
                                ! this has been done before calling SET_CCIBM_MATVEC_DATA, when calling
                                ! GET_CRTCFCC_INTERPOLATION_STENCILS.

! 5. Get EXIM faces data:
CALL GET_GASPHASE_EXIMFACES_DATA

! 6. Exchange information at block boundaries for IBM_RCFACE_Z, CUT_FACE
! fields on each mesh:
CALL GET_BOUNDFACE_GEOM_INFO

! 7. Get nonzeros graph of the scalar diffusion/advection matrix, defined as:
!    - NNZ_D_MAT_Z(1:NUNKZ_LOCAL) Number of nonzeros on per matrix row.
!    - JD_MAT_Z(1:NNZ_ROW_Z,1:NUNKZ_LOCAL) Column location of nonzeros, global numeration.
NUNKZ_LOCAL = sum(NUNKZ_LOC(1:NMESHES)) ! Filled in GET_MATRIX_INDEXES, only nonzeros are for meshes
                                        ! that belong to this process.
NUNKZ_TOTAL = sum(NUNKZ_TOT(1:NMESHES))

IF (MYID==0) THEN
   WRITE(LU_ERR,*) ' '
   IF (DO_IMPLICIT_CCREGION) THEN
      WRITE(LU_ERR,'(A)') ' Cut-cell region scalar transport advanced implicitly.'
      WRITE(LU_ERR,'(A)') ' Using GLMAT as Implicit Scalar transport solver on cut-cell region.'
   ELSE
      WRITE(LU_ERR,'(A)') ' Cut-cell region scalar transport advanced explicitly.'
   ENDIF
   WRITE(LU_ERR,'(A)') ' List of Scalar unknown numbers per proc:'
ENDIF
DO IPROC=0,N_MPI_PROCESSES-1
   CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
   IF(MYID==IPROC) WRITE(LU_ERR,'(A,I8,A,I8)') ' MYID=',MYID,', NUNKZ_LOCAL=',NUNKZ_LOCAL
ENDDO

! Allocate NNZ_D_MAT_Z, JD_MAT_Z:
ALLOCATE( NNZ_D_MAT_Z(1:NUNKZ_LOCAL) )
ALLOCATE( JD_MAT_Z(1:NNZ_ROW_Z,1:NUNKZ_LOCAL) ) ! Contains on first index nonzeros per local row.
NNZ_D_MAT_Z(:) = 0
JD_MAT_Z(:,:)  = HUGE(I)

! Find NM_START: first mesh that belongs to the processor.
NM_START = IBM_UNDEFINED
DO NM=1,NMESHES
   IF (PROCESS(NM)/=MYID) CYCLE
   NM_START = NM
   EXIT
ENDDO

IF (DO_IMPLICIT_CCREGION) CALL GET_MATRIXGRAPH_SCALARS

! 8. Build Mass (volumes) matrix for scalars:
CALL GET_MMATRIX_SCALAR_3D

! Allocate rhs and solution arrays for species:
ALLOCATE( F_Z(1:NUNKZ_LOCAL) , F_Z0(1:NUNKZ_LOCAL,1:N_TOTAL_SCALARS) , RZ_Z(1:NUNKZ_LOCAL) , RZ_ZS(1:NUNKZ_LOCAL) )
ALLOCATE( RZ_Z0(1:NUNKZ_LOCAL,1:N_TOTAL_SCALARS) )

IF (DO_IMPLICIT_CCREGION) THEN
   ! Allocate advection + diffusion matrix to add diffusion part:
   ALLOCATE( D_MAT_Z(1:NNZ_ROW_Z,1:NUNKZ_LOCAL), D_MAT_Z0(1:NNZ_ROW_Z,1:NUNKZ_LOCAL,1:N_TOTAL_SCALARS) )
   ALLOCATE( D_MAT_RHO(1:NNZ_ROW_Z,1:NUNKZ_LOCAL), D_MAT_RHO0(1:NNZ_ROW_Z,1:NUNKZ_LOCAL) )

   ! Allocate rhs and solution arrays for density:
   ALLOCATE( F_RHO(1:NUNKZ_LOCAL) , F_RHO0(1:NUNKZ_LOCAL) , RZ_RHO(1:NUNKZ_LOCAL) , RZ_RHOS(1:NUNKZ_LOCAL) )
   ALLOCATE( RZ_RHO0(1:NUNKZ_LOCAL) )
   IF (TRAP_CORR) THEN
      ALLOCATE( TR_Z(1:NUNKZ_LOCAL,1:N_TOTAL_SCALARS))
      ALLOCATE( TR_RHO(1:NUNKZ_LOCAL) )
   ENDIF

   ! Total number of nonzeros for JD_MAT_Z, D_MAT_Z:
   TOT_NNZ_Z = sum( NNZ_D_MAT_Z(1:NUNKZ_LOCAL) )
   ! Allocate A_Z IA_Z and JA_Z matrices:
   ALLOCATE ( A_Z(TOT_NNZ_Z) , IA_Z(NUNKZ_LOCAL+1) , JA_Z(TOT_NNZ_Z) )
   ! Define CLUSTER_SPARSE_SOLVER control parameter vector iparmZ, and matrix handle PT_Z:
   ALLOCATE(IPARMZ(64)); IPARMZ(:) = 0
   ALLOCATE(PT_Z(64))
ENDIF

#ifdef WITH_MKL
! Do nothing.
#else
! Here WITH_MKL preprocessor flag has not been defined. Therefore we can't integrate implicitly the
! cut-cell region.
IF (DO_IMPLICIT_CCREGION) THEN
   IF (MYID==0) THEN
      WRITE(LU_ERR,*) 'Error: MKL Library compile flag was not defined for DO_IMPLICIT_CCREGION=.TRUE. and'
      WRITE(LU_ERR,*) 'implicit time integration of cut-cell region.'
   ENDIF
   STOP_STATUS = SETUP_STOP
ENDIF
#endif



RETURN
END SUBROUTINE SET_CCIBM_MATVEC_DATA

! ---------------------- GET_BOUNDFACE_GEOM_INFO --------------------------------
SUBROUTINE GET_BOUNDFACE_GEOM_INFO

! Work deferred.

RETURN
END SUBROUTINE GET_BOUNDFACE_GEOM_INFO

! --------------------- GET_BOUNDFACE_GEOM_INFO_H --------------------------------
SUBROUTINE GET_BOUNDFACE_GEOM_INFO_H

! Work deferred.

RETURN
END SUBROUTINE GET_BOUNDFACE_GEOM_INFO_H

! ----------------------- FILL_UNKZ_GUARDCELLS ---------------------------------
SUBROUTINE FILL_UNKZ_GUARDCELLS

USE MPI

! Local Variables:
INTEGER :: NM,NOM,IERR
TYPE (MESH_TYPE), POINTER :: M,M4
TYPE (OMESH_TYPE), POINTER :: M2,M3
INTEGER, ALLOCATABLE, DIMENSION(:) :: REQ0
INTEGER :: N_REQ0, NICC_R, ICC, ICC1, NCELL, JCC, NOMICC
INTEGER, ALLOCATABLE, DIMENSION(:) :: NCC_SV
TYPE (WALL_TYPE), POINTER :: WC
TYPE (EXTERNAL_WALL_TYPE), POINTER :: EWC
INTEGER :: ISTR,IEND,JSTR,JEND,KSTR,KEND,II,JJ,KK,IIO,JJO,KKO,IW,N_INT

! First allocate buffers to receive UNKZ information:
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   IF (EVACUATION_ONLY(NM)) CYCLE
   DO NOM=1,NMESHES
      IF (EVACUATION_ONLY(NOM)) CYCLE
      IF (MESHES(NM)%OMESH(NOM)%NIC_R>0) THEN
         M3 => MESHES(NM)%OMESH(NOM)
         ALLOCATE(M3%UNKZ_CT_R(M3%NIC_R))
      ENDIF
      IF (MESHES(NM)%OMESH(NOM)%NICC_R(1)>0) THEN
         M3 => MESHES(NM)%OMESH(NOM)
         ALLOCATE(M3%ICC_UNKZ_CC_R(M3%NICC_R(1)))
         ALLOCATE(M3%UNKZ_CC_R(M3%NICC_R(2)))

         ! Dump cut-cell indexes on sending mesh NOM, whose info will be received:
         NICC_R = 0
         DO ICC=MESHES(NM)%N_CUTCELL_MESH+1,MESHES(NM)%N_CUTCELL_MESH+MESHES(NM)%N_GCCUTCELL_MESH
            IF (MESHES(NM)%CUT_CELL(ICC)%NOMICC(1) /= NOM) CYCLE
            NICC_R = NICC_R + 1
            M3%ICC_UNKZ_CC_R(NICC_R) = MESHES(NM)%CUT_CELL(ICC)%NOMICC(2)
         ENDDO
      ENDIF
   ENDDO
ENDDO

CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)

IF (N_MPI_PROCESSES>1) ALLOCATE(REQ0(2*NMESHES**2))

N_REQ0 = 0

! Exchange number of cut-cells information to be exchanged between MESH and OMESHES:
DO NM=1,NMESHES
   IF (EVACUATION_ONLY(NM)) CYCLE
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      IF (EVACUATION_ONLY(NOM)) CYCLE
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MYID .AND. MESHES(NOM)%CONNECTED_MESH(NM)) THEN
         M2 => MESHES(NOM)%OMESH(NM)
         N_REQ0 = N_REQ0 + 1
         CALL MPI_IRECV(M2%NICC_S(1),2,MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ENDIF
   ENDDO
ENDDO

! DEFINITION NCC_S:   MESHES(NOM)%OMESH(NM)%NCC_S   = MESHES(NM)%OMESH(NOM)%NCC_R

DO NM=1,NMESHES
   CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)  ! This call orders the sending mesh by mesh.
   IF (PROCESS(NM)/=MYID) CYCLE
   IF (EVACUATION_ONLY(NM)) CYCLE
   DO NOM=1,NMESHES
      IF (EVACUATION_ONLY(NOM)) CYCLE
      IF (.NOT.MESHES(NM)%CONNECTED_MESH(NOM)) CYCLE
      M3 => MESHES(NM)%OMESH(NOM)
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NOM)/=MYID .AND. MESHES(NM)%CONNECTED_MESH(NOM)) THEN
         N_REQ0 = N_REQ0 + 1
         CALL MPI_ISEND(M3%NICC_R(1),2,MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ELSE
         M2 => MESHES(NOM)%OMESH(NM)
         M2%NICC_S(1:2) = M3%NICC_R(1:2)
      ENDIF
   ENDDO
ENDDO

IF ( (N_REQ0>0) .AND. (N_MPI_PROCESSES>1) ) THEN
   CALL MPI_WAITALL(N_REQ0,REQ0(1:N_REQ0),MPI_STATUSES_IGNORE,IERR)
ENDIF

! At this point values of M2%NICC_S should have been received.

! Definition: MESHES(NOM)%OMESH(NM)%UNKZ_CT_S(:) = MESHES(NM)%OMESH(NOM)%UNKZ_CT_R(:)
!             MESHES(NOM)%OMESH(NM)%UNKZ_CC_S(:) = MESHES(NM)%OMESH(NOM)%UNKZ_CC_R(:)

! Now allocate buffers to send UNKZ information:
DO NM=1,NMESHES
   IF (EVACUATION_ONLY(NM)) CYCLE
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      IF (EVACUATION_ONLY(NOM)) CYCLE
      IF (MESHES(NOM)%OMESH(NM)%NIC_S>0) THEN
         M2 => MESHES(NOM)%OMESH(NM)
         ALLOCATE(M2%UNKZ_CT_S(M2%NIC_S))
      ENDIF

      IF (MESHES(NOM)%OMESH(NM)%NICC_S(1)>0) THEN
         M2 => MESHES(NOM)%OMESH(NM)
         ALLOCATE(M2%ICC_UNKZ_CC_S(M2%NICC_S(1)))
         ALLOCATE(M2%UNKZ_CC_S(M2%NICC_S(2)))
      ENDIF
   ENDDO
ENDDO

! Exchange list of cutcells in ICC_UNKZ_CC_S/R:
N_REQ0 = 0
DO NM=1,NMESHES
   IF (EVACUATION_ONLY(NM)) CYCLE
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      IF (EVACUATION_ONLY(NOM)) CYCLE
      M2 => MESHES(NOM)%OMESH(NM)
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MYID .AND. M2%NICC_S(1)>0) THEN
         N_REQ0 = N_REQ0 + 1
         CALL MPI_IRECV(M2%ICC_UNKZ_CC_S(1),M2%NICC_S(1),MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ENDIF
   ENDDO
ENDDO
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   IF (EVACUATION_ONLY(NM)) CYCLE
   DO NOM=1,NMESHES
      IF (EVACUATION_ONLY(NOM)) CYCLE
      M3 => MESHES(NM)%OMESH(NOM)
      IF (M3%NICC_R(1)<1) CYCLE
      IF (PROCESS(NOM)/=MYID) THEN
         N_REQ0 = N_REQ0 + 1
         CALL MPI_ISEND(M3%ICC_UNKZ_CC_R(1),M3%NICC_R(1),MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ELSE
         M2 => MESHES(NOM)%OMESH(NM)
         M2%ICC_UNKZ_CC_S(1:M2%NICC_S(1)) = M3%ICC_UNKZ_CC_R(1:M3%NICC_R(1))
      ENDIF
   ENDDO
ENDDO

IF ( (N_REQ0>0) .AND. (N_MPI_PROCESSES>1) ) CALL MPI_WAITALL(N_REQ0,REQ0(1:N_REQ0),MPI_STATUSES_IGNORE,IERR)

! Senders populate UNKZ_CC_S with computed UNKZ values:
ALLOCATE(NCC_SV(1:NMESHES));
DO NM=1,NMESHES
   IF (EVACUATION_ONLY(NM)) CYCLE
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      IF (EVACUATION_ONLY(NOM)) CYCLE
      M2 => MESHES(NOM)%OMESH(NM)
      IF (M2%NICC_S(1)<1) CYCLE
      M => MESHES(NOM)
      NCC_SV(NOM) = 0
      DO ICC1=1,M2%NICC_S(1)
         ICC = M2%ICC_UNKZ_CC_S(ICC1)
         NCELL=M%CUT_CELL(ICC)%NCELL
         DO JCC=1,NCELL
            NCC_SV(NOM) = NCC_SV(NOM) + 1
            M2%UNKZ_CC_S(NCC_SV(NOM)) = M%CUT_CELL(ICC)%UNKZ(JCC)
            IF ( M%CUT_CELL(ICC)%UNKZ(JCC) == IBM_UNDEFINED) &
            WRITE(LU_ERR,*) 'NOM MESH UNKZ UNDEFINED',NOM,ICC,JCC,M%CUT_CELL(ICC)%IJK(1:3),M%CUT_CELL(ICC)%UNKZ(JCC)
         ENDDO
      ENDDO
   ENDDO
ENDDO
DEALLOCATE(NCC_SV)

! Finally exchange UNKZ values:
N_REQ0 = 0
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   IF (EVACUATION_ONLY(NM)) CYCLE
   DO NOM=1,NMESHES
      IF (EVACUATION_ONLY(NOM)) CYCLE
      M3 => MESHES(NM)%OMESH(NOM)
      IF (M3%NICC_R(1)<1) CYCLE
      IF (PROCESS(NOM)/=MYID) THEN
         N_REQ0 = N_REQ0 + 1
         CALL MPI_IRECV(M3%UNKZ_CC_R(1),M3%NICC_R(2),MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ELSE
         M2 => MESHES(NOM)%OMESH(NM)
         M3%UNKZ_CC_R(1:M3%NICC_R(2)) = M2%UNKZ_CC_S(1:M2%NICC_S(2))
      ENDIF
   ENDDO
ENDDO

DO NM=1,NMESHES
   IF (EVACUATION_ONLY(NM)) CYCLE
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      IF (EVACUATION_ONLY(NOM)) CYCLE
      M2 => MESHES(NOM)%OMESH(NM)
      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MYID .AND. M2%NICC_S(1)>0) THEN
         N_REQ0 = N_REQ0 + 1
         CALL MPI_ISEND(M2%UNKZ_CC_S(1),M2%NICC_S(2),MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ENDIF
   ENDDO
ENDDO

IF ( (N_REQ0>0) .AND. (N_MPI_PROCESSES>1) ) CALL MPI_WAITALL(N_REQ0,REQ0(1:N_REQ0),MPI_STATUSES_IGNORE,IERR)

! Copy to guard-cell cut-cells:
ALLOCATE(NCC_SV(1:NMESHES));
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   M => MESHES(NM)
   NCC_SV(:)=0
   DO ICC=M%N_CUTCELL_MESH+1,M%N_CUTCELL_MESH+M%N_GCCUTCELL_MESH
      NOM   = M%CUT_CELL(ICC)%NOMICC(1)
      IF (NOM == 0) CYCLE
      NOMICC= M%CUT_CELL(ICC)%NOMICC(2)
      DO JCC=1,M%CUT_CELL(ICC)%NCELL
         NCC_SV(NOM)=NCC_SV(NOM)+1
         MESHES(NOM)%CUT_CELL(NOMICC)%UNKZ(JCC) = M%OMESH(NOM)%UNKZ_CC_R(NCC_SV(NOM))
         M%CUT_CELL(ICC)%UNKZ(JCC) = MESHES(NOM)%CUT_CELL(NOMICC)%UNKZ(JCC)
      ENDDO
   ENDDO
ENDDO
DEALLOCATE(NCC_SV)

! Finally Exchange Cartesian cell UNKZ:
N_REQ0 = 0
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   IF (EVACUATION_ONLY(NM)) CYCLE
   M => MESHES(NM)
   DO NOM=1,NMESHES
      IF (EVACUATION_ONLY(NOM)) CYCLE
      M3 => MESHES(NM)%OMESH(NOM)
      IF (M3%NIC_R<1) CYCLE

      M4 => MESHES(NOM)

      ! X direction bounds:
      ILO_FACE = 0                    ! Low mesh boundary face index.
      IHI_FACE = M4%IBAR              ! High mesh boundary face index.
      ISTR     = ILO_FACE - NGUARD    ! Allocation start x arrays.
      IEND     = IHI_FACE + NGUARD    ! Allocation end x arrays.

      ! Y direction bounds:
      JLO_FACE = 0                    ! Low mesh boundary face index.
      JHI_FACE = M4%JBAR              ! High mesh boundary face index.
      JSTR     = JLO_FACE - NGUARD    ! Allocation start y arrays.
      JEND     = JHI_FACE + NGUARD    ! Allocation end y arrays.

      ! Z direction bounds:
      KLO_FACE = 0                    ! Low mesh boundary face index.
      KHI_FACE = M4%KBAR              ! High mesh boundary face index.
      KSTR     = KLO_FACE - NGUARD    ! Allocation start z arrays.
      KEND     = KHI_FACE + NGUARD    ! Allocation end z arrays.

      N_INT = (IEND-ISTR+1)*(JEND-JSTR+1)*(KEND-KSTR+1)

      IF (PROCESS(NOM)/=MYID) THEN
         N_REQ0 = N_REQ0 + 1
         CALL MPI_IRECV(M4%CCVAR(ISTR,JSTR,KSTR,IBM_UNKZ),N_INT,MPI_INTEGER,PROCESS(NOM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ELSE
         ! M4%CCVAR(:,:,:,IBM_UNKZ) = M4%CCVAR(:,:,:,IBM_UNKZ) ! No need, IBM_UNKZ has already been numbered in M4
      ENDIF
   ENDDO
ENDDO

DO NM=1,NMESHES
   IF (EVACUATION_ONLY(NM)) CYCLE
   DO NOM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
      IF (EVACUATION_ONLY(NOM)) CYCLE
      M2 => MESHES(NOM)%OMESH(NM)
      IF(M2%NIC_S<1) CYCLE

      M4 => MESHES(NOM)

      ! X direction bounds:
      ILO_FACE = 0                    ! Low mesh boundary face index.
      IHI_FACE = M4%IBAR              ! High mesh boundary face index.
      ISTR     = ILO_FACE - NGUARD    ! Allocation start x arrays.
      IEND     = IHI_FACE + NGUARD    ! Allocation end x arrays.

      ! Y direction bounds:
      JLO_FACE = 0                    ! Low mesh boundary face index.
      JHI_FACE = M4%JBAR              ! High mesh boundary face index.
      JSTR     = JLO_FACE - NGUARD    ! Allocation start y arrays.
      JEND     = JHI_FACE + NGUARD    ! Allocation end y arrays.

      ! Z direction bounds:
      KLO_FACE = 0                    ! Low mesh boundary face index.
      KHI_FACE = M4%KBAR              ! High mesh boundary face index.
      KSTR     = KLO_FACE - NGUARD    ! Allocation start z arrays.
      KEND     = KHI_FACE + NGUARD    ! Allocation end z arrays.

      N_INT = (IEND-ISTR+1)*(JEND-JSTR+1)*(KEND-KSTR+1)

      IF (N_MPI_PROCESSES>1 .AND. NM/=NOM .AND. PROCESS(NM)/=MYID) THEN
         N_REQ0 = N_REQ0 + 1
         CALL MPI_ISEND(M4%CCVAR(ISTR,JSTR,KSTR,IBM_UNKZ),N_INT,MPI_INTEGER,PROCESS(NM),NM,MPI_COMM_WORLD,REQ0(N_REQ0),IERR)
      ENDIF
   ENDDO
ENDDO

IF ( (N_REQ0>0) .AND. (N_MPI_PROCESSES>1) ) CALL MPI_WAITALL(N_REQ0,REQ0(1:N_REQ0),MPI_STATUSES_IGNORE,IERR)

! Finally Copy from NOM to NMs the unknown numbers UNKZ:
MESH_LOOP_F : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

    CALL POINT_TO_MESH(NM)

    EXTERNAL_WALL_LOOP : DO IW=1,N_EXTERNAL_WALL_CELLS

       WC=>WALL(IW)
       EWC=>EXTERNAL_WALL(IW)
       IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE EXTERNAL_WALL_LOOP

       II  = WC%ONE_D%II
       JJ  = WC%ONE_D%JJ
       KK  = WC%ONE_D%KK
       NOM = EWC%NOM

       ! This assumes all meshes at same level of refinement:
       IIO = EWC%IIO_MIN
       JJO = EWC%JJO_MIN
       KKO = EWC%KKO_MIN

       CCVAR(II,JJ,KK,IBM_UNKZ) = MESHES(NOM)%CCVAR(IIO,JJO,KKO,IBM_UNKZ)

    ENDDO EXTERNAL_WALL_LOOP
ENDDO MESH_LOOP_F



IF (N_MPI_PROCESSES>1) THEN
   DEALLOCATE(REQ0)
   CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
ENDIF

RETURN
END SUBROUTINE FILL_UNKZ_GUARDCELLS

! ----------------------------- GET_CC_UNKH ------------------------------------

SUBROUTINE GET_CC_UNKH(I,J,K,IUNKH)

INTEGER, INTENT(IN) :: I,J,K
INTEGER, INTENT(OUT):: IUNKH

! Local variable:
INTEGER :: ICC

IUNKH    = IBM_UNDEFINED ! This is < 0.
! Second if PRES_ON_CARTESIAN = .FALSE. populate HP for cut-cells:
IF (.NOT.PRES_ON_CARTESIAN) THEN

   ! Code here refers to a fully unstructured pressure solver where each cut-cell has an independent
   ! pressure unknown, as is the case with scalars advection.
   ! To do.

ELSEIF (PRES_ON_CARTESIAN .AND. .NOT.PRES_ON_WHOLE_DOMAIN ) THEN

   ! Regular gas cell, taken care of before.
   ! Check cut-cell:
   ICC = CCVAR(I,J,K,IBM_IDCC)
   ! If theres is a cut-cell ICC then CUT_CELL(ICC)%UNKH(1) has been populated.
   IF (ICC > 0) IUNKH = CUT_CELL(ICC)%UNKH(1)

ENDIF


RETURN
END SUBROUTINE GET_CC_UNKH


! ----------------------------- GET_CC_IROW ------------------------------------

SUBROUTINE GET_CC_IROW(I,J,K,IROW)

INTEGER, INTENT(IN) :: I,J,K
INTEGER, INTENT(OUT):: IROW

! Local variable:
INTEGER :: ICC

IROW    = IBM_UNDEFINED ! This is < 0.
! Second if PRES_ON_CARTESIAN = .FALSE. populate HP for cut-cells:
IF (.NOT.PRES_ON_CARTESIAN) THEN

   ! Code here refers to a fully unstructured pressure solver where each cut-cell has an independent
   ! pressure unknown, as is the case with scalars advection.
   ! To do.

ELSEIF (PRES_ON_CARTESIAN .AND. .NOT.PRES_ON_WHOLE_DOMAIN ) THEN

   ! Regular gas cell, taken care of before.
   ! Check cut-cell:
   ICC = CCVAR(I,J,K,IBM_IDCC)
   ! If theres is a cut-cell ICC then CUT_CELL(ICC)%UNKH(1) has been populated.
   IF (ICC > 0) IROW     = CUT_CELL(ICC)%UNKH(1) - UNKH_IND(NM_START)

ENDIF


RETURN
END SUBROUTINE GET_CC_IROW

! ----------------------------- GET_CUTCELL_HP ------------------------------------


SUBROUTINE GET_CUTCELL_HP(NM,HP)

INTEGER, INTENT(IN) :: NM
REAL(EB), INTENT(INOUT), POINTER, DIMENSION(:,:,:) :: HP

! Local Variables:
INTEGER :: I,J,K,IROW,ICC

! Second if PRES_ON_CARTESIAN = .FALSE. populate HP for cut-cells:
IF (.NOT.PRES_ON_CARTESIAN) THEN

   ! Code here refers to a fully unstructured pressure solver where each cut-cell has an independent
   ! pressure unknown, as is the case with scalars advection.
   ! To do.

ELSEIF (PRES_ON_CARTESIAN .AND. .NOT.PRES_ON_WHOLE_DOMAIN ) THEN

   CUTCELL_LOOP : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH

      I = MESHES(NM)%CUT_CELL(ICC)%IJK(IAXIS)
      J = MESHES(NM)%CUT_CELL(ICC)%IJK(JAXIS)
      K = MESHES(NM)%CUT_CELL(ICC)%IJK(KAXIS)

      IROW     = MESHES(NM)%CUT_CELL(ICC)%UNKH(1) - UNKH_IND(NM_START)

      ! Assign to HP:
      HP(I,J,K) = -X_H(IROW)

   ENDDO CUTCELL_LOOP

ENDIF


RETURN
END SUBROUTINE GET_CUTCELL_HP

! ----------------------------- GET_CUTCELL_FH ------------------------------------

SUBROUTINE GET_CUTCELL_FH(NM)

INTEGER, INTENT(IN) :: NM

! Local Variables:
INTEGER :: I,J,K,IROW,ICC

! Second if PRES_ON_CARTESIAN = .FALSE. populate source for cut-cells:
IF (.NOT.PRES_ON_CARTESIAN) THEN

   ! WORK HERE !!!! EITHER USE IBM FN on cut-faces or FVX, FVY, FVZ on regular faces
   ! of cut-cells. Compute integral on boundary cut faces (Div Theorem).

ELSEIF (PRES_ON_CARTESIAN .AND. .NOT.PRES_ON_WHOLE_DOMAIN ) THEN

   ! FVX(I,J,K), FVY(I,J,K), FVZ(I,J,K) have been populated for Cartesian faces which
   ! underlay gasphase cut-faces. They have also been populated on IBM_SOLID type , and regular faces.
   ! We use these values directly to define the div(F) term, rhs of Poisson in Cartesian cells of type
   ! IBM_CUTCFE. Their divergence has been added to PRHS in routine PRESSURE_SOLVER:
   CUTCELL_LOOP : DO ICC=1,MESHES(NM)%N_CUTCELL_MESH

      I = MESHES(NM)%CUT_CELL(ICC)%IJK(IAXIS)
      J = MESHES(NM)%CUT_CELL(ICC)%IJK(JAXIS)
      K = MESHES(NM)%CUT_CELL(ICC)%IJK(KAXIS)

      IROW     = MESHES(NM)%CUT_CELL(ICC)%UNKH(1) - UNKH_IND(NM_START)

      ! This might have the buoyancy div term DDDT wrong !!! - CHECK -

      ! Add to F_H:
      F_H(IROW) = F_H(IROW) + PRHS(I,J,K) * DX(I)*DY(J)*DZ(K)

   ENDDO CUTCELL_LOOP

ENDIF


RETURN
END SUBROUTINE GET_CUTCELL_FH

! ---------------------------- GET_H_MATRIX_CC ------------------------------------

SUBROUTINE GET_H_MATRIX_CC(NM,NM1,D_MAT_HP)

! This routine assumes the calling subroutine has called POINT_TO_MESH for NM.

INTEGER, INTENT(IN) :: NM,NM1
REAL(EB), POINTER, DIMENSION(:,:) :: D_MAT_HP

! Local Variables:
INTEGER :: X1AXIS,IFACE,ICF,I,J,K,IND(LOW_IND:HIGH_IND),IND_LOC(LOW_IND:HIGH_IND)
INTEGER :: LOCROW_1,LOCROW_2,ILOC,JLOC,JCOL,IROW,IW
REAL(EB) :: AF,IDX,BIJ,KFACE(2,2)
TYPE(WALL_TYPE), POINTER :: WC=>NULL()

IF (.NOT. ASSOCIATED(D_MAT_HP)) THEN
   WRITE(LU_ERR,*) 'GET_H_MATRIX_CC in geom.f90: Pointer D_MAT_HP not associated.'
   RETURN
ENDIF

IF ( PRES_ON_WHOLE_DOMAIN ) RETURN ! No cut-cell related info needed.

! X direction bounds:
ILO_FACE = 0                    ! Low mesh boundary face index.
IHI_FACE = IBAR                 ! High mesh boundary face index.
ILO_CELL = ILO_FACE + FCELL     ! First internal cell index. See notes.
IHI_CELL = IHI_FACE + FCELL - 1 ! Last internal cell index.

! Y direction bounds:
JLO_FACE = 0                    ! Low mesh boundary face index.
JHI_FACE = JBAR                 ! High mesh boundary face index.
JLO_CELL = JLO_FACE + FCELL     ! First internal cell index. See notes.
JHI_CELL = JHI_FACE + FCELL - 1 ! Last internal cell index.

! Z direction bounds:
KLO_FACE = 0                    ! Low mesh boundary face index.
KHI_FACE = KBAR                 ! High mesh boundary face index.
KLO_CELL = KLO_FACE + FCELL     ! First internal cell index. See notes.
KHI_CELL = KHI_FACE + FCELL - 1 ! Last internal cell index.

! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
DO IFACE=1,MESHES(NM)%IBM_NRCFACE_H

   I      = MESHES(NM)%IBM_RCFACE_H(IFACE)%IJK(IAXIS)
   J      = MESHES(NM)%IBM_RCFACE_H(IFACE)%IJK(JAXIS)
   K      = MESHES(NM)%IBM_RCFACE_H(IFACE)%IJK(KAXIS)
   X1AXIS = MESHES(NM)%IBM_RCFACE_H(IFACE)%IJK(KAXIS+1)

   ! Unknowns on related cells:
   IND(LOW_IND)  = MESHES(NM)%IBM_RCFACE_H(IFACE)%UNK(LOW_IND)
   IND(HIGH_IND) = MESHES(NM)%IBM_RCFACE_H(IFACE)%UNK(HIGH_IND)

   IND_LOC(LOW_IND) = IND(LOW_IND) - UNKH_IND(NM1) ! All row indexes must refer to ind_loc.
   IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKH_IND(NM1)

   ! Row ind(1),ind(2):
   LOCROW_1 = LOW_IND
   LOCROW_2 = HIGH_IND
   SELECT CASE(X1AXIS)
      CASE(IAXIS)
         AF = DY(J)*DZ(K)
         IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
         IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
      CASE(JAXIS)
         AF = DX(I)*DZ(K)
         IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
         IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
      CASE(KAXIS)
         AF = DX(I)*DY(J)
         IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
         IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row.
   ENDSELECT

   IDX = 1._EB / ( MESHES(NM)%IBM_RCFACE_H(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                   MESHES(NM)%IBM_RCFACE_H(IFACE)%XCEN(X1AXIS,LOW_IND) )

   ! Now add to Adiff corresponding coeff:
   BIJ   = IDX*AF

   !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
   KFACE(1,1) = BIJ; KFACE(2,1) =-BIJ; KFACE(1,2) =-BIJ; KFACE(2,2) = BIJ

   DO ILOC=LOCROW_1,LOCROW_2   ! Local row number in Kface
      DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
          IROW=IND_LOC(ILOC)                                ! Process Local Unknown number.
          JCOL=MESHES(NM)%IBM_RCFACE_H(IFACE)%JD(ILOC,JLOC) ! Local position of coef in D_MAT_H
          ! Add coefficient:
          D_MAT_HP(JCOL,IROW) = D_MAT_HP(JCOL,IROW) + KFACE(ILOC,JLOC)
      ENDDO
   ENDDO

ENDDO

! Now Gasphase CUT_FACES:
IF ( .NOT.PRES_ON_CARTESIAN ) THEN

   DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH

      IF ( MESHES(NM)%CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
      ! Drop if cut-face on a wall-cell, and type different than INTERPOLATED_BOUNDARY or PERIODIC_BOUNDARY.
      IW=MESHES(NM)%CUT_FACE(ICF)%IWC
      IF( IW > 0 ) THEN
         WC=>WALL(IW)
         IF (.NOT.( WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                    WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) ) CYCLE
      ENDIF
      I = MESHES(NM)%CUT_FACE(ICF)%IJK(IAXIS)
      J = MESHES(NM)%CUT_FACE(ICF)%IJK(JAXIS)
      K = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS+1)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
         CASE(JAXIS)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
         CASE(KAXIS)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row.
      ENDSELECT

      DO IFACE=1,MESHES(NM)%CUT_FACE(ICF)%NFACE

         !% Unknowns on related cells:
         IND(LOW_IND)  = MESHES(NM)%CUT_FACE(ICF)%UNKH(LOW_IND,IFACE)
         IND(HIGH_IND) = MESHES(NM)%CUT_FACE(ICF)%UNKH(HIGH_IND,IFACE)

         IND_LOC(LOW_IND) = IND(LOW_IND) - UNKH_IND(NM1) ! All row indexes must refer to ind_loc.
         IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKH_IND(NM1)

         AF = MESHES(NM)%CUT_FACE(ICF)%AREA(IFACE)
         IDX= 1._EB/ ( MESHES(NM)%CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE) - &
                       MESHES(NM)%CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE) )

         ! Now add to Adiff corresponding coeff:
         BIJ   = IDX*AF

         !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
         KFACE(1,1) = BIJ; KFACE(2,1) =-BIJ; KFACE(1,2) =-BIJ; KFACE(2,2) = BIJ

         DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
            DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
                IROW=IND_LOC(ILOC)
                JCOL=MESHES(NM)%CUT_FACE(ICF)%JDH(ILOC,JLOC,IFACE)
                ! Add coefficient:
                D_MAT_HP(JCOL,IROW) = D_MAT_HP(JCOL,IROW) + KFACE(ILOC,JLOC)
            ENDDO
         ENDDO

      ENDDO

   ENDDO

ELSE ! PRES_ON_CARTESIAN

   DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH

      IF ( MESHES(NM)%CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
      ! Drop if cut-face on a wall-cell, and type different than INTERPOLATED_BOUNDARY or PERIODIC_BOUNDARY.
      IW=MESHES(NM)%CUT_FACE(ICF)%IWC
      IF( IW > 0 ) THEN
         WC=>WALL(IW)
         IF (.NOT.( WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                    WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) ) CYCLE
      ENDIF
      I = MESHES(NM)%CUT_FACE(ICF)%IJK(IAXIS)
      J = MESHES(NM)%CUT_FACE(ICF)%IJK(JAXIS)
      K = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS+1)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            AF = DY(J)*DZ(K)
            IDX= 1._EB/DXN(I)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
         CASE(JAXIS)
            AF = DX(I)*DZ(K)
            IDX= 1._EB/DYN(J)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
         CASE(KAXIS)
            AF = DX(I)*DY(J)
            IDX= 1._EB/DZN(K)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row.
      ENDSELECT

      IFACE = 1 ! First location for UNKH has the unique H unknown
                ! for the cut-cells underlying Cartesian cell.

      !% Unknowns on related cells:
      IND(LOW_IND)  = MESHES(NM)%CUT_FACE(ICF)%UNKH(LOW_IND,IFACE)
      IND(HIGH_IND) = MESHES(NM)%CUT_FACE(ICF)%UNKH(HIGH_IND,IFACE)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKH_IND(NM1) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKH_IND(NM1)

      ! Now add to Adiff corresponding coeff:
      BIJ   = IDX*AF

      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = BIJ; KFACE(2,1) =-BIJ; KFACE(1,2) =-BIJ; KFACE(2,2) = BIJ

      DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
         DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
             IROW=IND_LOC(ILOC)
             JCOL=MESHES(NM)%CUT_FACE(ICF)%JDH(ILOC,JLOC,IFACE)
             ! Add coefficient:
             D_MAT_HP(JCOL,IROW) = D_MAT_HP(JCOL,IROW) + KFACE(ILOC,JLOC)
         ENDDO
      ENDDO

   ENDDO

ENDIF

RETURN
END SUBROUTINE GET_H_MATRIX_CC


! -------------------------- GET_CC_MATRIXGRAPH_H ---------------------------------

SUBROUTINE GET_CC_MATRIXGRAPH_H(NM,NM1,LOOP_FLAG)

INTEGER, INTENT(IN) :: NM,NM1
LOGICAL, INTENT(IN) :: LOOP_FLAG

! Local Variables:
INTEGER :: X1AXIS,IFACE,ICF,I,J,K,IND(LOW_IND:HIGH_IND),IND_LOC(LOW_IND:HIGH_IND)
INTEGER :: LOCROW_1,LOCROW_2,LOCROW,IIND,NII,ILOC,IW
TYPE(WALL_TYPE), POINTER :: WC=>NULL()

IF ( PRES_ON_WHOLE_DOMAIN ) RETURN ! No need to deal with cut-faces.

! X direction bounds:
ILO_FACE = 0                    ! Low mesh boundary face index.
IHI_FACE = MESHES(NM)%IBAR      ! High mesh boundary face index.
ILO_CELL = ILO_FACE + FCELL     ! First internal cell index. See notes.
IHI_CELL = IHI_FACE + FCELL - 1 ! Last internal cell index.

! Y direction bounds:
JLO_FACE = 0                    ! Low mesh boundary face index.
JHI_FACE = MESHES(NM)%JBAR      ! High mesh boundary face index.
JLO_CELL = JLO_FACE + FCELL     ! First internal cell index. See notes.
JHI_CELL = JHI_FACE + FCELL - 1 ! Last internal cell index.

! Z direction bounds:
KLO_FACE = 0                    ! Low mesh boundary face index.
KHI_FACE = MESHES(NM)%KBAR      ! High mesh boundary face index.
KLO_CELL = KLO_FACE + FCELL     ! First internal cell index. See notes.
KHI_CELL = KHI_FACE + FCELL - 1 ! Last internal cell index.


LOOP_FLAG_COND : IF ( LOOP_FLAG ) THEN ! MESH_LOOP_1 in calling routine.

   ! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
   DO IFACE=1,MESHES(NM)%IBM_NRCFACE_H
      I      = MESHES(NM)%IBM_RCFACE_H(IFACE)%IJK(IAXIS)
      J      = MESHES(NM)%IBM_RCFACE_H(IFACE)%IJK(JAXIS)
      K      = MESHES(NM)%IBM_RCFACE_H(IFACE)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%IBM_RCFACE_H(IFACE)%IJK(KAXIS+1)
      ! Unknowns on related cells:
      IND(LOW_IND)  = MESHES(NM)%IBM_RCFACE_H(IFACE)%UNK(LOW_IND)
      IND(HIGH_IND) = MESHES(NM)%IBM_RCFACE_H(IFACE)%UNK(HIGH_IND)
      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKH_IND(NM1) ! Row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKH_IND(NM1)
      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
         CASE(JAXIS)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
         CASE(KAXIS)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row.
      ENDSELECT
      ! Add to global matrix arrays:
      CALL ADD_INPLACE_NNZ_H_WHLDOM(LOCROW_1,LOCROW_2,IND,IND_LOC)
   ENDDO

   IF ( .NOT.PRES_ON_CARTESIAN ) THEN
      DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
         IF ( MESHES(NM)%CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
         ! Drop if cut-face on a wall-cell, and type different than INTERPOLATED_BOUNDARY or PERIODIC_BOUNDARY.
         IW=MESHES(NM)%CUT_FACE(ICF)%IWC
         IF( IW > 0 ) THEN
            WC=>WALL(IW)
            IF (.NOT.( WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                       WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) ) CYCLE
         ENDIF
         I = MESHES(NM)%CUT_FACE(ICF)%IJK(IAXIS)
         J = MESHES(NM)%CUT_FACE(ICF)%IJK(JAXIS)
         K = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS)
         X1AXIS = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS+1)
         ! Row ind(1),ind(2):
         LOCROW_1 = LOW_IND
         LOCROW_2 = HIGH_IND
         SELECT CASE(X1AXIS)
            CASE(IAXIS)
               IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
               IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
            CASE(JAXIS)
               IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
               IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
            CASE(KAXIS)
               IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
               IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row.
         ENDSELECT
         DO IFACE=1,MESHES(NM)%CUT_FACE(ICF)%NFACE
            !% Unknowns on related cells:
            IND(LOW_IND)  = MESHES(NM)%CUT_FACE(ICF)%UNKH(LOW_IND,IFACE)
            IND(HIGH_IND) = MESHES(NM)%CUT_FACE(ICF)%UNKH(HIGH_IND,IFACE)
            IND_LOC(LOW_IND) = IND(LOW_IND) - UNKH_IND(NM1) ! Row indexes refer to ind_loc.
            IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKH_IND(NM1)
            ! Add to global matrix arrays:
            CALL ADD_INPLACE_NNZ_H_WHLDOM(LOCROW_1,LOCROW_2,IND,IND_LOC)
         ENDDO
      ENDDO
   ELSE ! PRES_ON_CARTESIAN
      DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH

         IF ( MESHES(NM)%CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
         ! Drop if cut-face on a wall-cell, and type different than INTERPOLATED_BOUNDARY or PERIODIC_BOUNDARY.
         IW=MESHES(NM)%CUT_FACE(ICF)%IWC
         IF( IW > 0 ) THEN
            WC=>WALL(IW)
            IF (.NOT.( WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                       WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) ) CYCLE
         ENDIF
         I = MESHES(NM)%CUT_FACE(ICF)%IJK(IAXIS)
         J = MESHES(NM)%CUT_FACE(ICF)%IJK(JAXIS)
         K = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS)
         X1AXIS = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS+1)
         ! Row ind(1),ind(2):
         LOCROW_1 = LOW_IND
         LOCROW_2 = HIGH_IND
         SELECT CASE(X1AXIS)
            CASE(IAXIS)
               IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
               IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
            CASE(JAXIS)
               IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
               IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
            CASE(KAXIS)
               IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
               IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row.
         ENDSELECT
         IFACE = 1 ! First location for UNKH has the unique H unknown
                   ! for the cut-cells underlying Cartesian cell.
         ! Unknowns on related cells:
         IND(LOW_IND)  = MESHES(NM)%CUT_FACE(ICF)%UNKH(LOW_IND,IFACE)
         IND(HIGH_IND) = MESHES(NM)%CUT_FACE(ICF)%UNKH(HIGH_IND,IFACE)
         IND_LOC(LOW_IND) = IND(LOW_IND) - UNKH_IND(NM1) ! row indexes refer to ind_loc.
         IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKH_IND(NM1)
         ! Add to global matrix arrays:
         CALL ADD_INPLACE_NNZ_H_WHLDOM(LOCROW_1,LOCROW_2,IND,IND_LOC)
      ENDDO
   ENDIF

   ! Somewhere here should have the contribution of IBM_INBOUNDARY cut-faces,
   ! for Dirichlet BCs:
   !!!

ELSE ! MESH_LOOP_2 in calling routine.

   ! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
   DO IFACE=1,MESHES(NM)%IBM_NRCFACE_H
      I      = MESHES(NM)%IBM_RCFACE_H(IFACE)%IJK(IAXIS)
      J      = MESHES(NM)%IBM_RCFACE_H(IFACE)%IJK(JAXIS)
      K      = MESHES(NM)%IBM_RCFACE_H(IFACE)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%IBM_RCFACE_H(IFACE)%IJK(KAXIS+1)
      ! Unknowns on related cells:
      IND(LOW_IND)  = MESHES(NM)%IBM_RCFACE_H(IFACE)%UNK(LOW_IND)
      IND(HIGH_IND) = MESHES(NM)%IBM_RCFACE_H(IFACE)%UNK(HIGH_IND)
      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKH_IND(NM1) ! Row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKH_IND(NM1)
      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
         CASE(JAXIS)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
         CASE(KAXIS)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row.
      ENDSELECT
      MESHES(NM)%IBM_RCFACE_H(IFACE)%JD(1:2,1:2) = 0
      ! Add to global matrix arrays:
      DO LOCROW=LOCROW_1,LOCROW_2
         DO IIND=LOW_IND,HIGH_IND
            NII = NNZ_D_MAT_H(IND_LOC(LOCROW))
            DO ILOC=1,NII
               IF ( IND(IIND) == JD_MAT_H(ILOC,IND_LOC(LOCROW)) ) THEN
                   MESHES(NM)%IBM_RCFACE_H(IFACE)%JD(LOCROW,IIND) = ILOC
                   EXIT
               ENDIF
            ENDDO
         ENDDO
      ENDDO
   ENDDO

   IF ( .NOT.PRES_ON_CARTESIAN ) THEN
      ! Now Gasphase CUT_FACES:
      DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
         IF ( MESHES(NM)%CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
         ! Drop if cut-face on a wall-cell, and type different than INTERPOLATED_BOUNDARY or PERIODIC_BOUNDARY.
         IW=MESHES(NM)%CUT_FACE(ICF)%IWC
         IF( IW > 0 ) THEN
            WC=>WALL(IW)
            IF (.NOT.( WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                       WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) ) CYCLE
         ENDIF
         I = MESHES(NM)%CUT_FACE(ICF)%IJK(IAXIS)
         J = MESHES(NM)%CUT_FACE(ICF)%IJK(JAXIS)
         K = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS)
         X1AXIS = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS+1)
         ! Row ind(1),ind(2):
         LOCROW_1 = LOW_IND
         LOCROW_2 = HIGH_IND
         SELECT CASE(X1AXIS)
            CASE(IAXIS)
               IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
               IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
            CASE(JAXIS)
               IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
               IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
            CASE(KAXIS)
               IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
               IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row.
         ENDSELECT
         MESHES(NM)%CUT_FACE(ICF)%JDH(:,:,:) = 0
         DO IFACE=1,MESHES(NM)%CUT_FACE(ICF)%NFACE
            !% Unknowns on related cells:
            IND(LOW_IND)  = MESHES(NM)%CUT_FACE(ICF)%UNKH(LOW_IND,IFACE)
            IND(HIGH_IND) = MESHES(NM)%CUT_FACE(ICF)%UNKH(HIGH_IND,IFACE)
            IND_LOC(LOW_IND) = IND(LOW_IND) - UNKH_IND(NM1) ! Row indexes refer to ind_loc.
            IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKH_IND(NM1)
            ! Add to global matrix arrays:
            DO LOCROW=LOCROW_1,LOCROW_2
               DO IIND=LOW_IND,HIGH_IND
                  NII = NNZ_D_MAT_H(IND_LOC(LOCROW))
                  DO ILOC=1,NII
                     IF ( IND(IIND) == JD_MAT_H(ILOC,IND_LOC(LOCROW)) ) THEN
                         MESHES(NM)%CUT_FACE(ICF)%JDH(LOCROW,IIND,IFACE) = ILOC
                         EXIT
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO

   ELSE ! PRES_ON_CARTESIAN

      ! Now Gasphase CUT_FACES:
      DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH
         IF ( MESHES(NM)%CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
         ! Drop if cut-face on a wall-cell, and type different than INTERPOLATED_BOUNDARY or PERIODIC_BOUNDARY.
         IW=MESHES(NM)%CUT_FACE(ICF)%IWC
         IF( IW > 0 ) THEN
            WC=>WALL(IW)
            IF (.NOT.( WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                       WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY ) ) CYCLE
         ENDIF
         I = MESHES(NM)%CUT_FACE(ICF)%IJK(IAXIS)
         J = MESHES(NM)%CUT_FACE(ICF)%IJK(JAXIS)
         K = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS)
         X1AXIS = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS+1)
         ! Row ind(1),ind(2):
         LOCROW_1 = LOW_IND
         LOCROW_2 = HIGH_IND
         SELECT CASE(X1AXIS)
            CASE(IAXIS)
               IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
               IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
            CASE(JAXIS)
               IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
               IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row.
            CASE(KAXIS)
               IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row.
               IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row.
         ENDSELECT
         MESHES(NM)%CUT_FACE(ICF)%JDH(:,:,:) = 0
         IFACE = 1
         !% Unknowns on related cells:
         IND(LOW_IND)  = MESHES(NM)%CUT_FACE(ICF)%UNKH(LOW_IND,IFACE)
         IND(HIGH_IND) = MESHES(NM)%CUT_FACE(ICF)%UNKH(HIGH_IND,IFACE)
         IND_LOC(LOW_IND) = IND(LOW_IND) - UNKH_IND(NM1) ! Row indexes refer to ind_loc.
         IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKH_IND(NM1)
         ! Add to global matrix arrays:
         DO LOCROW=LOCROW_1,LOCROW_2
            DO IIND=LOW_IND,HIGH_IND
               NII = NNZ_D_MAT_H(IND_LOC(LOCROW))
               DO ILOC=1,NII
                  IF ( IND(IIND) == JD_MAT_H(ILOC,IND_LOC(LOCROW)) ) THEN
                      MESHES(NM)%CUT_FACE(ICF)%JDH(LOCROW,IIND,IFACE) = ILOC
                      EXIT
                  ENDIF
               ENDDO
            ENDDO
         ENDDO
      ENDDO
   ENDIF

   ! Somewhere here should have the contribution of IBM_INBOUNDARY cut-faces, for Dirichlet BCs:
   !!!

ENDIF LOOP_FLAG_COND

RETURN
END SUBROUTINE GET_CC_MATRIXGRAPH_H

! ------------------------ ADD_INPLACE_NNZ_H_WHLDOM -------------------------------

SUBROUTINE ADD_INPLACE_NNZ_H_WHLDOM(LOCROW_1,LOCROW_2,IND,IND_LOC)

INTEGER, INTENT(IN) :: LOCROW_1,LOCROW_2,IND(LOW_IND:HIGH_IND),IND_LOC(LOW_IND:HIGH_IND)

! Local Variables:
INTEGER LOCROW, IIND, NII, ILOC, JLOC
LOGICAL INLIST

LOCROW_LOOP : DO LOCROW=LOCROW_1,LOCROW_2
   DO IIND=LOW_IND,HIGH_IND
      NII = NNZ_D_MAT_H(IND_LOC(LOCROW))
      ! Check that column index hasn't been already counted:
      INLIST = .FALSE.
      DO ILOC=1,NII
         IF ( IND(IIND) == JD_MAT_H(ILOC,IND_LOC(LOCROW)) ) THEN
            INLIST = .TRUE.
            EXIT
         ENDIF
      ENDDO
      IF ( INLIST ) CYCLE

      ! Now add in place:
      NII = NII + 1
      DO ILOC=1,NII
          IF ( JD_MAT_H(ILOC,IND_LOC(LOCROW)) > IND(IIND) ) EXIT
      ENDDO
      DO JLOC=NII,ILOC+1,-1
          JD_MAT_H(JLOC,IND_LOC(LOCROW)) = JD_MAT_H(JLOC-1,IND_LOC(LOCROW))
      ENDDO
      NNZ_D_MAT_H(IND_LOC(LOCROW))   = NII
      JD_MAT_H(ILOC,IND_LOC(LOCROW)) = IND(IIND)
   ENDDO
ENDDO LOCROW_LOOP

RETURN
END SUBROUTINE ADD_INPLACE_NNZ_H_WHLDOM


! ------------------------ GET_ADVDIFFMATRIX_SCALAR_SYMM_3D ------------------------------

SUBROUTINE GET_ADVDIFFMATRIX_SCALAR_SYMM_3D(N)

USE MATH_FUNCTIONS, ONLY: INTERPOLATE1D_UNIFORM
INTEGER, INTENT(IN) :: N

! Local Variables:
INTEGER :: NM
INTEGER :: I,J,K
REAL(EB):: PRFCT,D_Z_TEMP(-1:0),D_Z_N(0:5000),RHO_D,X1F,TMPV(-1:0),RHOPV(-1:0),RHOPVN(-1:0),TMP_ISIDE
INTEGER :: X1AXIS,IFACE,IND(LOW_IND:HIGH_IND),IND_LOC(LOW_IND:HIGH_IND),ISIDE,ICF
INTEGER :: LOCROW_1,LOCROW_2,ILOC,JLOC,IROW,JCOL,ICC,JCC,IW
REAL(EB):: AF,IDX,CCM1,CCP1,BIJ,KFACE(2,2),CIJP,CIJM,VELC,VELD,ALPHAP1,AM_P1,AP_P1
LOGICAL, PARAMETER :: ALL_GODUNOV = .FALSE. ! If false uses centered interpolation for diffusion velocity.
REAL(EB),PARAMETER :: DO_ADV = 1._EB
REAL(EB), POINTER, DIMENSION(:,:,:) :: RHOPN=>NULL(),RHOP=>NULL(),UP=>NULL(),VP=>NULL(),WP=>NULL()

LOGICAL, PARAMETER :: END_OF_STEP_RHO=.FALSE.
LOGICAL, PARAMETER :: DIFF_FROM_DIVG =.TRUE.

VELD = 0._EB

! Set D_MAT_Z to zero for species N, will add implicit parts of diffusion + advection:
D_MAT_Z = 0._EB

! Diffusivity lookup table for species N:
D_Z_N = D_Z(:,N)

! 1. Regular gasphase faces, connecting regular cells:
! Mesh Loop:
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN
      IF (END_OF_STEP_RHO) THEN
         RHOPN=> RHO
         RHOP => RHOS
         PRFCT= 0._EB
      ELSE
         RHOPN=> RHOS
         RHOP => RHO
         PRFCT= 1._EB
      ENDIF
      UP   => U
      VP   => V
      WP   => W
   ELSE
      IF (END_OF_STEP_RHO) THEN
         RHOPN=> RHOS
         RHOP => RHO
         PRFCT= 1._EB
      ELSE
         RHOPN=> RHO
         RHOP => RHOS
         PRFCT= 0._EB
      ENDIF
      UP   => US
      VP   => VS
      WP   => WS
   ENDIF

   ! X direction bounds:
   ILO_FACE = 0                    ! Low mesh boundary face index.
   IHI_FACE = IBAR                 ! High mesh boundary face index.

   ! Y direction bounds:
   JLO_FACE = 0                    ! Low mesh boundary face index.
   JHI_FACE = JBAR                 ! High mesh boundary face index.

   ! Z direction bounds:
   KLO_FACE = 0                    ! Low mesh boundary face index.
   KHI_FACE = KBAR                 ! High mesh boundary face index.

   ! IAXIS faces:
   X1AXIS = IAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      IW = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I+FCELL-1,J,K,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I+FCELL  ,J,K,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Face area and x and dx:
      AF = DY(J)*DZ(K)
      IDX= 1._EB/DXN(I)

      ! Diffusive Part:
      ! Linear interpolation coefficients:
      CCM1 = 0.5_EB ! Uniform Grid
      CCP1 = 0.5_EB

      ! Interpolate D_Z to the face:
      IF (DNS) THEN
         DO ISIDE=-1,0
            CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMP(I+FCELL+ISIDE,J,K),D_Z_TEMP(ISIDE))
         ENDDO
      ELSE ! LES
         DO ISIDE=-1,0
            D_Z_TEMP(ISIDE)= MU(I+FCELL+ISIDE,J,K)*RSC/RHOP(I+FCELL+ISIDE,J,K)
         ENDDO
      ENDIF
      RHOPVN(-1:0)= RHOPN(I+FCELL-1:I+FCELL  ,J,K)
      RHOPV(-1:0) =  RHOP(I+FCELL-1:I+FCELL  ,J,K)
      RHO_D   = CCM1*RHOPV(-1)*D_Z_TEMP(-1) + CCP1*RHOPV(0)*D_Z_TEMP(0)

      IF ( DIFF_FROM_DIVG ) THEN
         RHO_D = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D(N)
         RHOPVN(-1:0)=MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%RHOPVN(-1:0)
      ENDIF

      ! Now add to Adiff corresponding coeff:
      BIJ   = RHO_D*IDX*AF

      ! Advective Part: Velocity u
      VELC = UP(I,J,K)

      ! Matrix coefficients:
      ALPHAP1 = SIGN( 1._EB, VELC)
      AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
      AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
      CIJM = DO_ADV*AM_P1*VELC*AF
      CIJP = DO_ADV*AP_P1*VELC*AF

      ! Now add to A corresponding advection and diffusion coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = BIJ/RHOPVN(-1)+CIJM; KFACE(2,1) =-BIJ/RHOPVN(-1)-CIJM
      KFACE(1,2) =-BIJ/RHOPVN( 0)+CIJP; KFACE(2,2) = BIJ/RHOPVN( 0)-CIJP

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( I == ILO_FACE )  LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
      IF ( I == IHI_FACE )  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.

      DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
         DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
             IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
             JCOL=MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%JD(ILOC,JLOC) ! Local position of coef in D_MAT_Z
             ! Add coefficient:
             D_MAT_Z(JCOL,IROW) = D_MAT_Z(JCOL,IROW) + KFACE(ILOC,JLOC)
         ENDDO
      ENDDO

      MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%RHO_D(N) = RHO_D ! Store diffusivities to use in CCDIVG.
      MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%VELD(N) = VELD
      MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%RHOPVN(-1:0)= RHOPVN(-1:0)

   ENDDO

   ! JAXIS faces:
   X1AXIS = JAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      IW = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I,J+FCELL-1,K,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I,J+FCELL  ,K,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Face area and x and dx:
      AF = DX(I)*DZ(K)
      IDX= 1._EB/DYN(J)

      ! Linear interpolation coefficients:
      CCM1 = 0.5_EB ! Uniform Grid
      CCP1 = 0.5_EB

      ! Interpolate D_Z to the face:
      IF (DNS) THEN
         DO ISIDE=-1,0
            CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMP(I,J+FCELL+ISIDE,K),D_Z_TEMP(ISIDE))
         ENDDO
      ELSE ! LES
         DO ISIDE=-1,0
            D_Z_TEMP(ISIDE)= MU(I,J+FCELL+ISIDE,K)*RSC/RHOP(I,J+FCELL+ISIDE,K)
         ENDDO
      ENDIF
      RHOPVN(-1:0) = RHOPN(I,J+FCELL-1:J+FCELL  ,K)
      RHOPV(-1:0)  =  RHOP(I,J+FCELL-1:J+FCELL  ,K)
      RHO_D = CCM1*RHOPV(-1)*D_Z_TEMP(-1) + CCP1*RHOPV(0)*D_Z_TEMP(0)

      IF ( DIFF_FROM_DIVG ) THEN
         RHO_D = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D(N)
         RHOPVN(-1:0)=MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%RHOPVN(-1:0)
      ENDIF

      ! Now add to Adiff corresponding coeff:
      BIJ   = RHO_D*IDX*AF

      ! Advective Part: Velocity v
      VELC = VP(I,J,K)

      ! Matrix coefficients:
      ALPHAP1 = SIGN( 1._EB, VELC)
      AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
      AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
      CIJM = DO_ADV*AM_P1*VELC*AF
      CIJP = DO_ADV*AP_P1*VELC*AF

      ! Now add to A corresponding advection and diffusion coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = BIJ/RHOPVN(-1)+CIJM; KFACE(2,1) =-BIJ/RHOPVN(-1)-CIJM
      KFACE(1,2) =-BIJ/RHOPVN( 0)+CIJP; KFACE(2,2) = BIJ/RHOPVN( 0)-CIJP

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( J == JLO_FACE )  LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
      IF ( J == JHI_FACE )  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.

      DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
         DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
             IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
             JCOL=MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%JD(ILOC,JLOC) ! Local position of coef in D_MAT_Z
             ! Add coefficient:
             D_MAT_Z(JCOL,IROW) = D_MAT_Z(JCOL,IROW) + KFACE(ILOC,JLOC)
         ENDDO
      ENDDO

      MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%RHO_D(N) = RHO_D ! Store diffusivities to use in CCDIVG.
      MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%VELD(N) = VELD
      MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%RHOPVN(-1:0)= RHOPVN(-1:0)

   ENDDO

   ! KAXIS faces:
   X1AXIS = KAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      IW = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I,J,K+FCELL-1,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I,J,K+FCELL  ,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Face area and x and dx:
      AF = DX(I)*DY(J)
      IDX= 1._EB/DZN(K)

      ! Linear interpolation coefficients:
      CCM1 = 0.5_EB ! Uniform Grid
      CCP1 = 0.5_EB

      ! Interpolate D_Z to the face:
      IF (DNS) THEN
         DO ISIDE=-1,0
            CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMP(I,J,K+FCELL+ISIDE),D_Z_TEMP(ISIDE))
         ENDDO
      ELSE
         DO ISIDE=-1,0
            D_Z_TEMP(ISIDE)= MU(I,J,K+FCELL+ISIDE)*RSC/RHOP(I,J,K+FCELL+ISIDE)
         ENDDO
      ENDIF
      RHOPVN(-1:0)= RHOPN(I,J,K+FCELL-1:K+FCELL  )
      RHOPV(-1:0) =  RHOP(I,J,K+FCELL-1:K+FCELL  )
      RHO_D = CCM1*RHOPV(-1)*D_Z_TEMP(-1) + CCP1*RHOPV(0)*D_Z_TEMP(0)

      IF ( DIFF_FROM_DIVG ) THEN
         RHO_D = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D(N)
         RHOPVN(-1:0)=MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%RHOPVN(-1:0)
      ENDIF

      ! Now add to Adiff corresponding coeff:
      BIJ   = RHO_D*IDX*AF

      ! Advective Part: Velocity w
      VELC = WP(I,J,K)

      ! Matrix coefficients:
      ALPHAP1 = SIGN( 1._EB, VELC)
      AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
      AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
      CIJM = AM_P1*DO_ADV*VELC*AF
      CIJP = AP_P1*DO_ADV*VELC*AF

      ! Now add to A corresponding advection and diffusion coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = BIJ/RHOPVN(-1)+CIJM; KFACE(2,1) =-BIJ/RHOPVN(-1)-CIJM
      KFACE(1,2) =-BIJ/RHOPVN( 0)+CIJP; KFACE(2,2) = BIJ/RHOPVN( 0)-CIJP

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( K == KLO_FACE )  LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
      IF ( K == KHI_FACE )  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.

      DO ILOC=LOCROW_1,LOCROW_2   ! Local row number in Kface
         DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
             IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
             JCOL=MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%JD(ILOC,JLOC) ! Local position of coef in D_MAT_Z
             ! Add coefficient:
             D_MAT_Z(JCOL,IROW) = D_MAT_Z(JCOL,IROW) + KFACE(ILOC,JLOC)
         ENDDO
      ENDDO

      MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%RHO_D(N) = RHO_D ! Store diffusivities to use in CCDIVG.
      MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%VELD(N) = VELD
      MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%RHOPVN(-1:0)= RHOPVN(-1:0)

   ENDDO

   ! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
   DO IFACE=1,MESHES(NM)%IBM_NRCFACE_Z

      IW = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I      = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(IAXIS)
      J      = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(JAXIS)
      K      = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(KAXIS+1)

      ! Unknowns on related cells:
      IND(LOW_IND)  = MESHES(NM)%IBM_RCFACE_Z(IFACE)%UNK(LOW_IND)
      IND(HIGH_IND) = MESHES(NM)%IBM_RCFACE_Z(IFACE)%UNK(HIGH_IND)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            AF = DY(J)*DZ(K)
            X1F= MESHES(NM)%X(I)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
            IDX = 1._EB / ( MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                            MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND) )
            ! Linear interpolation coefficients:
            CCM1 = IDX*(MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
            CCP1 = IDX*(X1F -MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND))

            TMPV(-1:0)  = TMP(I+FCELL-1:I+FCELL,J,K)
            RHOPVN(-1:0)= RHOPN(I+FCELL-1:I+FCELL,J,K)
            RHOPV(-1:0) = RHOP(I+FCELL-1:I+FCELL,J,K)
            DO ISIDE=-1,0
               SELECT CASE(MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
               CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
                  ! TMPV(ISIDE) = TMPV(ISIDE)
               CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
                  JCC = MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
                  TMPV(ISIDE) = MESHES(NM)%CUT_CELL(ICC)%TMP(JCC)
                  RHOPV(ISIDE)=        PRFCT *MESHES(NM)%CUT_CELL(ICC)%RHO(JCC) + &
                                (1._EB-PRFCT)*MESHES(NM)%CUT_CELL(ICC)%RHOS(JCC)
                  RHOPVN(ISIDE)=(1._EB-PRFCT)*MESHES(NM)%CUT_CELL(ICC)%RHO(JCC) + &
                                       PRFCT *MESHES(NM)%CUT_CELL(ICC)%RHOS(JCC)
               CASE DEFAULT
                  print*, 'MESHES(NM)%IBM_NRCFACE_Z face not connected to REG or CC cell',NM,IFACE
                  TMPV(ISIDE) = -1._EB
               END SELECT
            ENDDO
            ! Advective Part: Velocity u
            VELC = UP(I,J,K)
            DO ISIDE=-1,0
               D_Z_TEMP(ISIDE)= MU(I+FCELL+ISIDE,J,K)*RSC/RHOPV(ISIDE) ! Here we use the cut-cells
                                                                       ! underlying Cartesian turb MU.
            ENDDO

         CASE(JAXIS)
            AF = DX(I)*DZ(K)
            X1F= MESHES(NM)%Y(J)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
            IDX = 1._EB / ( MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                            MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND) )
            ! Linear interpolation coefficients:
            CCM1 = IDX*(MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
            CCP1 = IDX*(X1F -MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND))

            TMPV(-1:0)  = TMP(I,J+FCELL-1:J+FCELL,K)
            RHOPVN(-1:0)= RHOPN(I,J+FCELL-1:J+FCELL,K)
            RHOPV(-1:0) = RHOP(I,J+FCELL-1:J+FCELL,K)
            DO ISIDE=-1,0
               SELECT CASE(MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
               CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
                  ! TMPV(ISIDE) = TMPV(ISIDE)
                  ! RHOPV(ISIDE)= RHOPV(ISIDE)
               CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
                  JCC = MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
                  TMPV(ISIDE) = MESHES(NM)%CUT_CELL(ICC)%TMP(JCC)
                  RHOPV(ISIDE)=        PRFCT *MESHES(NM)%CUT_CELL(ICC)%RHO(JCC) + &
                                (1._EB-PRFCT)*MESHES(NM)%CUT_CELL(ICC)%RHOS(JCC)
                  RHOPVN(ISIDE)=(1._EB-PRFCT)*MESHES(NM)%CUT_CELL(ICC)%RHO(JCC) + &
                                       PRFCT *MESHES(NM)%CUT_CELL(ICC)%RHOS(JCC)
               CASE DEFAULT
                  print*, 'MESHES(NM)%IBM_NRCFACE_Z face not connected to REG or CC cell',NM,IFACE
                  TMPV(ISIDE) = -1._EB
               END SELECT
            ENDDO
            ! Advective Part: Velocity v
            VELC = VP(I,J,K)
            DO ISIDE=-1,0
               D_Z_TEMP(ISIDE)= MU(I,J+FCELL+ISIDE,K)*RSC/RHOPV(ISIDE) ! Here we use the cut-cells
                                                                       ! underlying Cartesian turb MU.
            ENDDO

         CASE(KAXIS)
            AF = DX(I)*DY(J)
            X1F= MESHES(NM)%Z(K)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
            IDX = 1._EB / ( MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                            MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND) )
            ! Linear interpolation coefficients:
            CCM1 = IDX*(MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
            CCP1 = IDX*(X1F -MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND))

            TMPV(-1:0)  = TMP(I,J,K+FCELL-1:K+FCELL)
            RHOPVN(-1:0)= RHOPN(I,J,K+FCELL-1:K+FCELL)
            RHOPV(-1:0) = RHOP(I,J,K+FCELL-1:K+FCELL)
            DO ISIDE=-1,0
               SELECT CASE(MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
               CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
                  ! TMPV(ISIDE) = TMPV(ISIDE)
                  ! RHOPV(ISIDE)= RHOPV(ISIDE)
               CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
                  JCC = MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
                  TMPV(ISIDE) = MESHES(NM)%CUT_CELL(ICC)%TMP(JCC)
                  RHOPV(ISIDE)=        PRFCT *MESHES(NM)%CUT_CELL(ICC)%RHO(JCC) + &
                                (1._EB-PRFCT)*MESHES(NM)%CUT_CELL(ICC)%RHOS(JCC)
                  RHOPVN(ISIDE)=(1._EB-PRFCT)*MESHES(NM)%CUT_CELL(ICC)%RHO(JCC) + &
                                       PRFCT *MESHES(NM)%CUT_CELL(ICC)%RHOS(JCC)
               CASE DEFAULT
                  print*, 'MESHES(NM)%IBM_NRCFACE_Z face not connected to REG or CC cell',NM,IFACE
                  TMPV(ISIDE) = -1._EB
               END SELECT
            ENDDO
            ! Advective Part: Velocity w
            VELC = WP(I,J,K)
            DO ISIDE=-1,0
               D_Z_TEMP(ISIDE)= MU(I,J,K+FCELL+ISIDE)*RSC/RHOPV(ISIDE) ! Here we use the cut-cells
                                                                       ! underlying Cartesian turb MU.
            ENDDO

      ENDSELECT

      ! Interpolate D_Z to the face, linear interpolation:
      IF (DNS) THEN
         DO ISIDE=-1,0
            CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMPV(ISIDE),D_Z_TEMP(ISIDE))
         ENDDO
      ENDIF
      RHO_D = CCM1*RHOPV(-1)*D_Z_TEMP(-1) + CCP1*RHOPV(0)*D_Z_TEMP(0)

      IF ( DIFF_FROM_DIVG ) THEN
         RHO_D=IBM_RCFACE_Z(IFACE)%RHO_D(N)
         RHOPVN(-1:0)=IBM_RCFACE_Z(IFACE)%RHOPVN(-1:0)
      ENDIF

      ! Now add to Adiff corresponding coeff:
      BIJ   = RHO_D*IDX*AF

      ! Matrix coefficients for advection:
      ALPHAP1 = SIGN( 1._EB, VELC)
      AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
      AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
      CIJM = DO_ADV*AM_P1*VELC*AF
      CIJP = DO_ADV*AP_P1*VELC*AF

      ! Now add to A corresponding advection and diffusion coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = BIJ/RHOPVN(-1)+CIJM; KFACE(2,1) =-BIJ/RHOPVN(-1)-CIJM
      KFACE(1,2) =-BIJ/RHOPVN( 0)+CIJP; KFACE(2,2) = BIJ/RHOPVN( 0)-CIJP

      DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
         DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
             IROW=IND_LOC(ILOC)                                ! Process Local Unknown number.
             JCOL=MESHES(NM)%IBM_RCFACE_Z(IFACE)%JD(ILOC,JLOC) ! Local position of coef in D_MAT_Z
             ! Add coefficient:
             D_MAT_Z(JCOL,IROW) = D_MAT_Z(JCOL,IROW) + KFACE(ILOC,JLOC)
         ENDDO
      ENDDO

      MESHES(NM)%IBM_RCFACE_Z(IFACE)%RHO_D(N) = RHO_D ! Store diffusivities to use in CCDIVG.
      MESHES(NM)%IBM_RCFACE_Z(IFACE)%VELD(N)  = VELD
      MESHES(NM)%IBM_RCFACE_Z(IFACE)%RHOPVN(-1:0)= RHOPVN(-1:0)

   ENDDO

   ! Now Gasphase CUT_FACES:
   DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH

      IF ( MESHES(NM)%CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
      IW = MESHES(NM)%CUT_FACE(ICF)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I = MESHES(NM)%CUT_FACE(ICF)%IJK(IAXIS)
      J = MESHES(NM)%CUT_FACE(ICF)%IJK(JAXIS)
      K = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS+1)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         CASE(JAXIS)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         CASE(KAXIS)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
      ENDSELECT

      DO IFACE=1,MESHES(NM)%CUT_FACE(ICF)%NFACE

         !% Unknowns on related cells:
         IND(LOW_IND)  = MESHES(NM)%CUT_FACE(ICF)%UNKZ(LOW_IND,IFACE)
         IND(HIGH_IND) = MESHES(NM)%CUT_FACE(ICF)%UNKZ(HIGH_IND,IFACE)

         IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
         IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

         AF = MESHES(NM)%CUT_FACE(ICF)%AREA(IFACE)
         X1F= MESHES(NM)%CUT_FACE(ICF)%XYZCEN(X1AXIS,IFACE)
         IDX= 1._EB/ ( MESHES(NM)%CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE) - &
                       MESHES(NM)%CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE) )
         CCM1= IDX*(MESHES(NM)%CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE)-X1F)
         CCP1= IDX*(X1F-MESHES(NM)%CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE))

         ! Interpolate D_Z to the face, linear interpolation:
         DO ISIDE=-1,0
            SELECT CASE(MESHES(NM)%CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = MESHES(NM)%CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
               JCC = MESHES(NM)%CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
               TMP_ISIDE = MESHES(NM)%CUT_CELL(ICC)%TMP(JCC)
               RHOPV(ISIDE)=        PRFCT *MESHES(NM)%CUT_CELL(ICC)%RHO(JCC) + &
                             (1._EB-PRFCT)*MESHES(NM)%CUT_CELL(ICC)%RHOS(JCC)
               RHOPVN(ISIDE)=(1._EB-PRFCT)*MESHES(NM)%CUT_CELL(ICC)%RHO(JCC) + &
                                    PRFCT *MESHES(NM)%CUT_CELL(ICC)%RHOS(JCC)
            CASE DEFAULT
               print*, 'MESHES(NM)%CUT_FACE face not connected to CC cell',NM,IFACE
               TMP_ISIDE = -1._EB
            END SELECT
            IF (DNS) CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMP_ISIDE,D_Z_TEMP(ISIDE))
         ENDDO
         SELECT CASE(X1AXIS)
            CASE(IAXIS)
               DO ISIDE=-1,0
                  D_Z_TEMP(ISIDE)= MU(I+FCELL+ISIDE,J,K)*RSC/RHOPV(ISIDE) ! Here we use the cut-cells
                                                                          ! underlying Cartesian turb MU.
               ENDDO
            CASE(JAXIS)
               DO ISIDE=-1,0
                  D_Z_TEMP(ISIDE)= MU(I,J+FCELL+ISIDE,K)*RSC/RHOPV(ISIDE) ! Here we use the cut-cells
                                                                          ! underlying Cartesian turb MU.
               ENDDO
            CASE(KAXIS)
               DO ISIDE=-1,0
                  D_Z_TEMP(ISIDE)= MU(I,J,K+FCELL+ISIDE)*RSC/RHOPV(ISIDE) ! Here we use the cut-cells
                                                                          ! underlying Cartesian turb MU.
               ENDDO
         ENDSELECT
         RHO_D = CCM1*RHOPV(-1)*D_Z_TEMP(-1) + CCP1*RHOPV(0)*D_Z_TEMP(0)

         IF ( DIFF_FROM_DIVG ) THEN
            RHO_D=MESHES(NM)%CUT_FACE(ICF)%RHO_D(N,IFACE)
            RHOPVN(-1:0)=MESHES(NM)%CUT_FACE(ICF)%RHOPVN(-1:0,IFACE)
         ENDIF

         ! Now add to Adiff corresponding coeff:
         BIJ   = RHO_D*IDX*AF

         ! Matrix coefficients for advection:
         VELC =        PRFCT *MESHES(NM)%CUT_FACE(ICF)%VEL(IFACE) + &
                (1._EB-PRFCT)*MESHES(NM)%CUT_FACE(ICF)%VELS(IFACE)

         ALPHAP1 = SIGN( 1._EB, VELC)
         AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
         AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
         CIJM = DO_ADV*AM_P1*VELC*AF
         CIJP = DO_ADV*AP_P1*VELC*AF

         ! Now add to A corresponding advection and diffusion coeffs:
         !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
         KFACE(1,1) = BIJ/RHOPVN(-1)+CIJM; KFACE(2,1) =-BIJ/RHOPVN(-1)-CIJM
         KFACE(1,2) =-BIJ/RHOPVN( 0)+CIJP; KFACE(2,2) = BIJ/RHOPVN( 0)-CIJP

         DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
            DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
                IROW=IND_LOC(ILOC)                                     ! Process Local Unknown number.
                JCOL=MESHES(NM)%CUT_FACE(ICF)%JDZ(ILOC,JLOC,IFACE) ! Local position of coef in D_MAT_Z
                ! Add coefficient:
                D_MAT_Z(JCOL,IROW) = D_MAT_Z(JCOL,IROW) + KFACE(ILOC,JLOC)
            ENDDO
         ENDDO

         MESHES(NM)%CUT_FACE(ICF)%RHO_D(N,IFACE) = RHO_D ! Store diffusivities to use in CCDIVG.
         MESHES(NM)%CUT_FACE(ICF)%VELD(N,IFACE) = VELD
         MESHES(NM)%CUT_FACE(ICF)%RHOPVN(-1:0,IFACE)= RHOPVN(-1:0)

      ENDDO

   ENDDO

ENDDO MESH_LOOP


RETURN
END SUBROUTINE GET_ADVDIFFMATRIX_SCALAR_SYMM_3D


! ------------------------- GET_DIFFMATRIX_SCALAR_3D ------------------------------

SUBROUTINE GET_ADVDIFFMATRIX_SCALAR_3D(N)

USE MATH_FUNCTIONS, ONLY: INTERPOLATE1D_UNIFORM
USE MANUFACTURED_SOLUTIONS, ONLY: DIFF_MMS
INTEGER, INTENT(IN) :: N

! Local Variables:
INTEGER :: NM
INTEGER :: I,J,K
REAL(EB):: PRFCT,D_Z_TEMP(-1:0),MUV(-1:0),D_Z_N(0:5000),DIFF_FACE,X1F,TMPV(-1:0),RHOPV(-1:0),TMP_ISIDE
INTEGER :: X1AXIS,IFACE,IND(LOW_IND:HIGH_IND),IND_LOC(LOW_IND:HIGH_IND),ISIDE,ICF
INTEGER :: LOCROW_1,LOCROW_2,ILOC,JLOC,IROW,JCOL,ICC,JCC,IW
REAL(EB):: AF,IDX,CCM1,CCP1,BIJ,KFACE(2,2),CIJP,CIJM,VELC,VELD,ALPHAP1,AM_P1,AP_P1
LOGICAL, PARAMETER :: ALL_GODUNOV = .FALSE. ! If false uses centered interpolation for diffusion velocity.
REAL(EB),PARAMETER :: DO_ADV = 1._EB
REAL(EB), POINTER, DIMENSION(:,:,:) :: RHOP=>NULL(),UP=>NULL(),VP=>NULL(),WP=>NULL()

LOGICAL :: END_OF_STEP_RHO, DIFF_FROM_DIVG

IF (IMP_REGION_FROM_MATRIX_DIFF) THEN
   END_OF_STEP_RHO=.TRUE.
   DIFF_FROM_DIVG=.FALSE.
ELSE
   END_OF_STEP_RHO=.FALSE.
   DIFF_FROM_DIVG=.TRUE.
ENDIF

! Set D_MAT_Z to zero for species N, will add implicit parts of diffusion + advection:
D_MAT_Z = 0._EB

! Diffusivity lookup table for species N:
D_Z_N = D_Z(:,N)

! 1. Regular gasphase faces, connecting regular cells:
! Mesh Loop:
MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   IF (PREDICTOR) THEN
      IF (END_OF_STEP_RHO) THEN
         RHOP => RHOS
         PRFCT= 0._EB
      ELSE
         RHOP => RHO
         PRFCT= 1._EB
      ENDIF
      UP   => U
      VP   => V
      WP   => W
   ELSE
      IF (END_OF_STEP_RHO) THEN
         RHOP => RHO
         PRFCT= 1._EB
      ELSE
         RHOP => RHOS
         PRFCT= 0._EB
      ENDIF
      UP   => US
      VP   => VS
      WP   => WS
   ENDIF

   ! X direction bounds:
   ILO_FACE = 0                    ! Low mesh boundary face index.
   IHI_FACE = IBAR                 ! High mesh boundary face index.

   ! Y direction bounds:
   JLO_FACE = 0                    ! Low mesh boundary face index.
   JHI_FACE = JBAR                 ! High mesh boundary face index.

   ! Z direction bounds:
   KLO_FACE = 0                    ! Low mesh boundary face index.
   KHI_FACE = KBAR                 ! High mesh boundary face index.

   ! IAXIS faces:
   X1AXIS = IAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      IW = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I+FCELL-1,J,K,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I+FCELL  ,J,K,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Face area and x and dx:
      AF = DY(J)*DZ(K)
      IDX= 1._EB/DXN(I)

      ! Diffusive Part:
      ! Linear interpolation coefficients:
      CCM1 = 0.5_EB ! Uniform Grid
      CCP1 = 0.5_EB

      ! Interpolate D_Z to the face:
      IF (DNS) THEN
         IF(PERIODIC_TEST==7) THEN
            ! Interpolate D_Z to the face:
            DO ISIDE=-1,0
               D_Z_TEMP(ISIDE) = DIFF_MMS / RHOP(I+FCELL+ISIDE,J,K)
            ENDDO
         ELSE
            ! Interpolate D_Z to the face:
            DO ISIDE=-1,0
               CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMP(I+FCELL+ISIDE,J,K),D_Z_TEMP(ISIDE))
            ENDDO
         ENDIF
      ELSE ! LES
         DO ISIDE=-1,0
            D_Z_TEMP(ISIDE)= MU(I+FCELL+ISIDE,J,K)*RSC/RHOP(I+FCELL+ISIDE,J,K)
         ENDDO
      ENDIF
      DIFF_FACE = CCM1*D_Z_TEMP(-1) + CCP1*D_Z_TEMP(0)

      IF(DIFF_FROM_DIVG) DIFF_FACE=MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%DIFF_FACE(N)

      ! Now add to Adiff corresponding coeff:
      BIJ   = DIFF_FACE*IDX*AF

      ! Advective Part: Velocity u+D/rho drho/dx
      VELC = UP(I,J,K)
      VELD = DIFF_FACE*2._EB*IDX*(RHOP(I+FCELL  ,J,K)-RHOP(I+FCELL-1,J,K))/ &
                                 (RHOP(I+FCELL  ,J,K)+RHOP(I+FCELL-1,J,K))


      ! Matrix coefficients:
      IF (ALL_GODUNOV) THEN
         ALPHAP1 = SIGN( 1._EB, VELC+VELD)
         AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
         AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
         CIJM = AM_P1*(DO_ADV*VELC+VELD)*AF
         CIJP = AP_P1*(DO_ADV*VELC+VELD)*AF
      ELSE ! Use centered interpolation for Diffusive velocity term D/rho drho/dx.
         ALPHAP1 = SIGN( 1._EB, VELC)
         AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
         AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
         CIJM = (DO_ADV*AM_P1*VELC+0.5_EB*VELD)*AF
         CIJP = (DO_ADV*AP_P1*VELC+0.5_EB*VELD)*AF
      ENDIF

      ! Now add to A corresponding advection and diffusion coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = BIJ+CIJM; KFACE(2,1) =-BIJ-CIJM; KFACE(1,2) =-BIJ+CIJP; KFACE(2,2) =BIJ-CIJP

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( I == ILO_FACE )  LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
      IF ( I == IHI_FACE )  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.

      DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
         DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
             IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
             JCOL=MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%JD(ILOC,JLOC) ! Local position of coef in D_MAT_Z
             ! Add coefficient:
             D_MAT_Z(JCOL,IROW) = D_MAT_Z(JCOL,IROW) + KFACE(ILOC,JLOC)
         ENDDO
      ENDDO

      MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%DIFF_FACE(N) = DIFF_FACE ! Store diffusivities to use in CCDIVG.
      MESHES(NM)%IBM_REGFACE_IAXIS_Z(IFACE)%VELD(N) = VELD

   ENDDO

   ! JAXIS faces:
   X1AXIS = JAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      IW = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I,J+FCELL-1,K,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I,J+FCELL  ,K,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Face area and x and dx:
      AF = DX(I)*DZ(K)
      IDX= 1._EB/DYN(J)

      ! Linear interpolation coefficients:
      CCM1 = 0.5_EB ! Uniform Grid
      CCP1 = 0.5_EB

      ! Interpolate D_Z to the face:
      IF (DNS) THEN
         IF(PERIODIC_TEST==7) THEN
            ! Interpolate D_Z to the face:
            DO ISIDE=-1,0
               D_Z_TEMP(ISIDE) = DIFF_MMS / RHOP(I,J+FCELL+ISIDE,K)
            ENDDO
         ELSE
            ! Interpolate D_Z to the face:
            DO ISIDE=-1,0
               CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMP(I,J+FCELL+ISIDE,K),D_Z_TEMP(ISIDE))
            ENDDO
         ENDIF
      ELSE ! LES
         DO ISIDE=-1,0
            D_Z_TEMP(ISIDE)= MU(I,J+FCELL+ISIDE,K)*RSC/RHOP(I,J+FCELL+ISIDE,K)
         ENDDO
      ENDIF
      DIFF_FACE = CCM1*D_Z_TEMP(-1) + CCP1*D_Z_TEMP(0)

      IF(DIFF_FROM_DIVG) DIFF_FACE=MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%DIFF_FACE(N)
      ! Now add to Adiff corresponding coeff:
      BIJ   = DIFF_FACE*IDX*AF

      ! Advective Part: Velocity v+D/rho drho/dy
      VELC = VP(I,J,K)
      VELD = DIFF_FACE*2._EB*IDX*(RHOP(I,J+FCELL  ,K)-RHOP(I,J+FCELL-1,K))/ &
                                 (RHOP(I,J+FCELL  ,K)+RHOP(I,J+FCELL-1,K))

      ! Matrix coefficients:
      IF (ALL_GODUNOV) THEN
         ALPHAP1 = SIGN( 1._EB, VELC+VELD)
         AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
         AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
         CIJM = AM_P1*(DO_ADV*VELC+VELD)*AF
         CIJP = AP_P1*(DO_ADV*VELC+VELD)*AF
      ELSE ! Use centered interpolation for Diffusive velocity term D/rho drho/dx.
         ALPHAP1 = SIGN( 1._EB, VELC)
         AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
         AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
         CIJM = (DO_ADV*AM_P1*VELC+0.5_EB*VELD)*AF
         CIJP = (DO_ADV*AP_P1*VELC+0.5_EB*VELD)*AF
      ENDIF

      ! Now add to A corresponding advection and diffusion coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = BIJ+CIJM; KFACE(2,1) =-BIJ-CIJM; KFACE(1,2) =-BIJ+CIJP; KFACE(2,2) =BIJ-CIJP

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( J == JLO_FACE )  LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
      IF ( J == JHI_FACE )  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.

      DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
         DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
             IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
             JCOL=MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%JD(ILOC,JLOC) ! Local position of coef in D_MAT_Z
             ! Add coefficient:
             D_MAT_Z(JCOL,IROW) = D_MAT_Z(JCOL,IROW) + KFACE(ILOC,JLOC)
         ENDDO
      ENDDO

      MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%DIFF_FACE(N) = DIFF_FACE ! Store diffusivities to use in CCDIVG.
      MESHES(NM)%IBM_REGFACE_JAXIS_Z(IFACE)%VELD(N) = VELD

   ENDDO

   ! KAXIS faces:
   X1AXIS = KAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      IW = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
      J  = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
      K  = MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I,J,K+FCELL-1,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I,J,K+FCELL  ,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Face area and x and dx:
      AF = DX(I)*DY(J)
      IDX= 1._EB/DZN(K)

      ! Linear interpolation coefficients:
      CCM1 = 0.5_EB ! Uniform Grid
      CCP1 = 0.5_EB

      ! Interpolate D_Z to the face:
      IF (DNS) THEN
         IF(PERIODIC_TEST==7) THEN
            ! Interpolate D_Z to the face:
            DO ISIDE=-1,0
               D_Z_TEMP(ISIDE) = DIFF_MMS / RHOP(I,J,K+FCELL+ISIDE)
            ENDDO
         ELSE
            ! Interpolate D_Z to the face:
            DO ISIDE=-1,0
               CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMP(I,J,K+FCELL+ISIDE),D_Z_TEMP(ISIDE))
            ENDDO
         ENDIF
      ELSE
         DO ISIDE=-1,0
            D_Z_TEMP(ISIDE)= MU(I,J,K+FCELL+ISIDE)*RSC/RHOP(I,J,K+FCELL+ISIDE)
         ENDDO
      ENDIF
      DIFF_FACE = CCM1*D_Z_TEMP(-1) + CCP1*D_Z_TEMP(0)

      IF(DIFF_FROM_DIVG) DIFF_FACE=MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%DIFF_FACE(N)
      ! Now add to Adiff corresponding coeff:
      BIJ   = DIFF_FACE*IDX*AF

      ! Advective Part: Velocity w+D/rho drho/dz
      VELC = WP(I,J,K)
      VELD = DIFF_FACE*2._EB*IDX*(RHOP(I,J,K+FCELL  )-RHOP(I,J,K+FCELL-1))/ &
                                 (RHOP(I,J,K+FCELL  )+RHOP(I,J,K+FCELL-1))

      ! Matrix coefficients:
      IF (ALL_GODUNOV) THEN
         ALPHAP1 = SIGN( 1._EB, VELC+VELD)
         AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
         AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
         CIJM = AM_P1*(DO_ADV*VELC+VELD)*AF
         CIJP = AP_P1*(DO_ADV*VELC+VELD)*AF
      ELSE ! Use centered interpolation for Diffusive velocity term D/rho drho/dx.
         ALPHAP1 = SIGN( 1._EB, VELC)
         AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
         AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
         CIJM = (DO_ADV*AM_P1*VELC+0.5_EB*VELD)*AF
         CIJP = (DO_ADV*AP_P1*VELC+0.5_EB*VELD)*AF
      ENDIF

      ! Now add to A corresponding advection and diffusion coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = BIJ+CIJM; KFACE(2,1) =-BIJ-CIJM; KFACE(1,2) =-BIJ+CIJP; KFACE(2,2) =BIJ-CIJP

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( K == KLO_FACE )  LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
      IF ( K == KHI_FACE )  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.

      DO ILOC=LOCROW_1,LOCROW_2   ! Local row number in Kface
         DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
             IROW=IND_LOC(ILOC)   ! Process Local Unknown number.
             JCOL=MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%JD(ILOC,JLOC) ! Local position of coef in D_MAT_Z
             ! Add coefficient:
             D_MAT_Z(JCOL,IROW) = D_MAT_Z(JCOL,IROW) + KFACE(ILOC,JLOC)
         ENDDO
      ENDDO

      MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%DIFF_FACE(N) = DIFF_FACE ! Store diffusivities to use in CCDIVG.
      MESHES(NM)%IBM_REGFACE_KAXIS_Z(IFACE)%VELD(N) = VELD

   ENDDO

   ! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
   DO IFACE=1,MESHES(NM)%IBM_NRCFACE_Z

      IW = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I      = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(IAXIS)
      J      = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(JAXIS)
      K      = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%IBM_RCFACE_Z(IFACE)%IJK(KAXIS+1)

      ! Unknowns on related cells:
      IND(LOW_IND)  = MESHES(NM)%IBM_RCFACE_Z(IFACE)%UNK(LOW_IND)
      IND(HIGH_IND) = MESHES(NM)%IBM_RCFACE_Z(IFACE)%UNK(HIGH_IND)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            AF = DY(J)*DZ(K)
            X1F= MESHES(NM)%X(I)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
            IDX = 1._EB / ( MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                            MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND) )
            ! Linear interpolation coefficients:
            CCM1 = IDX*(MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
            CCP1 = IDX*(X1F -MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND))

            TMPV(-1:0)  = TMP(I+FCELL-1:I+FCELL,J,K)
            RHOPV(-1:0) = RHOP(I+FCELL-1:I+FCELL,J,K)
            DO ISIDE=-1,0
               SELECT CASE(MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
               CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
                  ! TMPV(ISIDE) = TMPV(ISIDE)
               CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
                  JCC = MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
                  TMPV(ISIDE) = MESHES(NM)%CUT_CELL(ICC)%TMP(JCC)
                  RHOPV(ISIDE)=        PRFCT *MESHES(NM)%CUT_CELL(ICC)%RHO(JCC) + &
                                (1._EB-PRFCT)*MESHES(NM)%CUT_CELL(ICC)%RHOS(JCC)
               CASE DEFAULT
                  print*, 'MESHES(NM)%IBM_NRCFACE_Z face not connected to REG or CC cell',NM,IFACE
                  TMPV(ISIDE) = -1._EB
               END SELECT
               D_Z_TEMP(ISIDE)= MU(I+FCELL+ISIDE,J,K)*RSC/RHOPV(ISIDE) ! Here we use the cut-cells
                                                                       ! underlying Cartesian turb MU.
            ENDDO
            ! Advective Part: Velocity u+D/rho drho/dx
            VELC = UP(I,J,K)
            VELD = IDX*(     RHOPV(0)-     RHOPV(-1))/ &
                       (CCP1*RHOPV(0)+CCM1*RHOPV(-1)) ! DIFF_FACE further down.

         CASE(JAXIS)
            AF = DX(I)*DZ(K)
            X1F= MESHES(NM)%Y(J)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
            IDX = 1._EB / ( MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                            MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND) )
            ! Linear interpolation coefficients:
            CCM1 = IDX*(MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
            CCP1 = IDX*(X1F -MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND))

            TMPV(-1:0)  = TMP(I,J+FCELL-1:J+FCELL,K)
            RHOPV(-1:0) = RHOP(I,J+FCELL-1:J+FCELL,K)
            DO ISIDE=-1,0
               SELECT CASE(MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
               CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
                  ! TMPV(ISIDE) = TMPV(ISIDE)
                  ! RHOPV(ISIDE)= RHOPV(ISIDE)
               CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
                  JCC = MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
                  TMPV(ISIDE) = MESHES(NM)%CUT_CELL(ICC)%TMP(JCC)
                  RHOPV(ISIDE)=        PRFCT *MESHES(NM)%CUT_CELL(ICC)%RHO(JCC) + &
                                (1._EB-PRFCT)*MESHES(NM)%CUT_CELL(ICC)%RHOS(JCC)
               CASE DEFAULT
                  print*, 'MESHES(NM)%IBM_NRCFACE_Z face not connected to REG or CC cell',NM,IFACE
                  TMPV(ISIDE) = -1._EB
               END SELECT
               D_Z_TEMP(ISIDE)= MU(I,J+FCELL+ISIDE,K)*RSC/RHOPV(ISIDE) ! Here we use the cut-cells
                                                                       ! underlying Cartesian turb MU.
            ENDDO
            ! Advective Part: Velocity v+D/rho drho/dy
            VELC = VP(I,J,K)
            VELD = IDX*(     RHOPV(0)-     RHOPV(-1))/ &
                       (CCP1*RHOPV(0)+CCM1*RHOPV(-1)) ! DIFF_FACE further down.

         CASE(KAXIS)
            AF = DX(I)*DY(J)
            X1F= MESHES(NM)%Z(K)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
            IDX = 1._EB / ( MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND) - &
                            MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND) )
            ! Linear interpolation coefficients:
            CCM1 = IDX*(MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,HIGH_IND)-X1F)
            CCP1 = IDX*(X1F -MESHES(NM)%IBM_RCFACE_Z(IFACE)%XCEN(X1AXIS,LOW_IND))

            TMPV(-1:0)  = TMP(I,J,K+FCELL-1:K+FCELL)
            RHOPV(-1:0) = RHOP(I,J,K+FCELL-1:K+FCELL)
            DO ISIDE=-1,0
               SELECT CASE(MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(1,ISIDE+2))
               CASE(IBM_FTYPE_RGGAS) ! Regular cell -> use stored TMPV from TMP array.
                  ! TMPV(ISIDE) = TMPV(ISIDE)
                  ! RHOPV(ISIDE)= RHOPV(ISIDE)
               CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
                  ICC = MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(2,ISIDE+2)
                  JCC = MESHES(NM)%IBM_RCFACE_Z(IFACE)%CELL_LIST(3,ISIDE+2)
                  TMPV(ISIDE) = MESHES(NM)%CUT_CELL(ICC)%TMP(JCC)
                  RHOPV(ISIDE)=        PRFCT *MESHES(NM)%CUT_CELL(ICC)%RHO(JCC) + &
                                (1._EB-PRFCT)*MESHES(NM)%CUT_CELL(ICC)%RHOS(JCC)
               CASE DEFAULT
                  print*, 'MESHES(NM)%IBM_NRCFACE_Z face not connected to REG or CC cell',NM,IFACE
                  TMPV(ISIDE) = -1._EB
               END SELECT
               D_Z_TEMP(ISIDE)= MU(I,J,K+FCELL+ISIDE)*RSC/RHOPV(ISIDE) ! Here we use the cut-cells
                                                                       ! underlying Cartesian turb MU.
            ENDDO
            ! Advective Part: Velocity w+D/rho drho/dz
            VELC = WP(I,J,K)
            VELD = IDX*(     RHOPV(0)-     RHOPV(-1))/ &
                       (CCP1*RHOPV(0)+CCM1*RHOPV(-1)) ! DIFF_FACE further down.

      ENDSELECT

      ! Interpolate D_Z to the face, linear interpolation:
      IF (DNS) THEN
         IF(PERIODIC_TEST==7) THEN
            ! Interpolate D_Z to the face:
            DO ISIDE=-1,0
               D_Z_TEMP(ISIDE) = DIFF_MMS / RHOPV(ISIDE)
            ENDDO
         ELSE
            DO ISIDE=-1,0
               CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMPV(ISIDE),D_Z_TEMP(ISIDE))
            ENDDO
         ENDIF
      ENDIF
      DIFF_FACE = CCM1*D_Z_TEMP(-1) + CCP1*D_Z_TEMP(0)

      IF(DIFF_FROM_DIVG) DIFF_FACE=MESHES(NM)%IBM_RCFACE_Z(IFACE)%DIFF_FACE(N)
      ! Now add to Adiff corresponding coeff:
      BIJ   = DIFF_FACE*IDX*AF

      ! Matrix coefficients for advection:
      VELD = DIFF_FACE*VELD
      IF (ALL_GODUNOV) THEN
         ALPHAP1 = SIGN( 1._EB, VELC+VELD)
         AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
         AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
         CIJM = AM_P1*(DO_ADV*VELC+VELD)*AF
         CIJP = AP_P1*(DO_ADV*VELC+VELD)*AF
      ELSE ! Use centered interpolation for Diffusive velocity term D/rho drho/dx.
         ALPHAP1 = SIGN( 1._EB, VELC)
         AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
         AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
         CIJM = (DO_ADV*AM_P1*VELC+0.5_EB*VELD)*AF
         CIJP = (DO_ADV*AP_P1*VELC+0.5_EB*VELD)*AF
      ENDIF

      ! Now add to A corresponding advection and diffusion coeffs:
      !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
      KFACE(1,1) = BIJ+CIJM; KFACE(2,1) =-BIJ-CIJM; KFACE(1,2) =-BIJ+CIJP; KFACE(2,2) =BIJ-CIJP

      DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
         DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
             IROW=IND_LOC(ILOC)                                ! Process Local Unknown number.
             JCOL=MESHES(NM)%IBM_RCFACE_Z(IFACE)%JD(ILOC,JLOC) ! Local position of coef in D_MAT_Z
             ! Add coefficient:
             D_MAT_Z(JCOL,IROW) = D_MAT_Z(JCOL,IROW) + KFACE(ILOC,JLOC)
         ENDDO
      ENDDO

      MESHES(NM)%IBM_RCFACE_Z(IFACE)%DIFF_FACE(N) = DIFF_FACE ! Store diffusivities to use in CCDIVG.
      MESHES(NM)%IBM_RCFACE_Z(IFACE)%VELD(N) = VELD

   ENDDO

   ! Now Gasphase CUT_FACES:
   DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH

      IF ( MESHES(NM)%CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
      IW = MESHES(NM)%CUT_FACE(ICF)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I = MESHES(NM)%CUT_FACE(ICF)%IJK(IAXIS)
      J = MESHES(NM)%CUT_FACE(ICF)%IJK(JAXIS)
      K = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = MESHES(NM)%CUT_FACE(ICF)%IJK(KAXIS+1)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            MUV(-1:0) = MU(I+FCELL-1:I+FCELL  ,J,K)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         CASE(JAXIS)
            MUV(-1:0) = MU(I,J+FCELL-1:J+FCELL  ,K)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         CASE(KAXIS)
            MUV(-1:0) = MU(I,J,K+FCELL-1:K+FCELL  )
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
      ENDSELECT

      DO IFACE=1,MESHES(NM)%CUT_FACE(ICF)%NFACE

         !% Unknowns on related cells:
         IND(LOW_IND)  = MESHES(NM)%CUT_FACE(ICF)%UNKZ(LOW_IND,IFACE)
         IND(HIGH_IND) = MESHES(NM)%CUT_FACE(ICF)%UNKZ(HIGH_IND,IFACE)

         IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
         IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

         AF = MESHES(NM)%CUT_FACE(ICF)%AREA(IFACE)
         X1F= MESHES(NM)%CUT_FACE(ICF)%XYZCEN(X1AXIS,IFACE)
         IDX= 1._EB/ ( MESHES(NM)%CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE) - &
                       MESHES(NM)%CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE) )
         CCM1= IDX*(MESHES(NM)%CUT_FACE(ICF)%XCENHIGH(X1AXIS,IFACE)-X1F)
         CCP1= IDX*(X1F-MESHES(NM)%CUT_FACE(ICF)%XCENLOW(X1AXIS, IFACE))

         ! Interpolate D_Z to the face, linear interpolation:
         DO ISIDE=-1,0
            SELECT CASE(MESHES(NM)%CUT_FACE(ICF)%CELL_LIST(1,ISIDE+2,IFACE))
            CASE(IBM_FTYPE_CFGAS) ! Cut-cell -> use Temperature value from CUT_CELL data struct:
               ICC = MESHES(NM)%CUT_FACE(ICF)%CELL_LIST(2,ISIDE+2,IFACE)
               JCC = MESHES(NM)%CUT_FACE(ICF)%CELL_LIST(3,ISIDE+2,IFACE)
               TMP_ISIDE = MESHES(NM)%CUT_CELL(ICC)%TMP(JCC)
               RHOPV(ISIDE)=        PRFCT *MESHES(NM)%CUT_CELL(ICC)%RHO(JCC) + &
                             (1._EB-PRFCT)*MESHES(NM)%CUT_CELL(ICC)%RHOS(JCC)
            CASE DEFAULT
               print*, 'MESHES(NM)%CUT_FACE face not connected to CC cell',NM,IFACE
               TMP_ISIDE = -1._EB
            END SELECT
            IF (DNS) THEN
               IF(PERIODIC_TEST==7) THEN
                  D_Z_TEMP(ISIDE) = DIFF_MMS / RHOPV(ISIDE)
               ELSE
                  CALL INTERPOLATE1D_UNIFORM(LBOUND(D_Z_N,1),D_Z_N,TMP_ISIDE,D_Z_TEMP(ISIDE))
               ENDIF
            ELSE
               D_Z_TEMP(ISIDE)= MUV(ISIDE)*RSC/RHOPV(ISIDE)
            ENDIF
         ENDDO
         DIFF_FACE = CCM1*D_Z_TEMP(-1) + CCP1*D_Z_TEMP(0)

         IF(DIFF_FROM_DIVG) DIFF_FACE=MESHES(NM)%CUT_FACE(ICF)%DIFF_FACE(N,IFACE)
         ! Now add to Adiff corresponding coeff:
         BIJ   = DIFF_FACE*IDX*AF

         ! Matrix coefficients for advection:
         VELC =        PRFCT *MESHES(NM)%CUT_FACE(ICF)%VEL(IFACE) + &
                (1._EB-PRFCT)*MESHES(NM)%CUT_FACE(ICF)%VELS(IFACE)

         ! print*, "VELC=",VELC
         ! print*, "RHOPV=",RHOPV,'avg=',CCP1*RHOPV(0)+CCM1*RHOPV(-1)
         VELD = DIFF_FACE*IDX*(     RHOPV(0)-     RHOPV(-1))/ &
                              (CCP1*RHOPV(0)+CCM1*RHOPV(-1)) ! DIFF_FACE further down.

         IF (ALL_GODUNOV) THEN
            ALPHAP1 = SIGN( 1._EB, VELC+VELD)
            AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
            AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
            CIJM = AM_P1*(DO_ADV*VELC+VELD)*AF
            CIJP = AP_P1*(DO_ADV*VELC+VELD)*AF
         ELSE ! Use centered interpolation for Diffusive velocity term D/rho drho/dx.
            ALPHAP1 = SIGN( 1._EB, VELC)
            AM_P1 = 0.5_EB*(1._EB+ALPHAP1*(1._EB-BRP1))
            AP_P1 = 0.5_EB*(1._EB-ALPHAP1*(1._EB-BRP1))
            CIJM = (DO_ADV*AM_P1*VELC+0.5_EB*VELD)*AF
            CIJP = (DO_ADV*AP_P1*VELC+0.5_EB*VELD)*AF
         ENDIF

         ! Now add to A corresponding advection and diffusion coeffs:
         !    Cols 1,2: ind(LOW_IND) ind(HIGH_IND), Rows 1,2: ind_loc(LOW_IND) ind_loc(HIGH_IND)
         KFACE(1,1) = BIJ+CIJM; KFACE(2,1) =-BIJ-CIJM; KFACE(1,2) =-BIJ+CIJP; KFACE(2,2) =BIJ-CIJP

         DO ILOC=LOCROW_1,LOCROW_2 ! Local row number in Kface
            DO JLOC=LOW_IND,HIGH_IND ! Local col number in Kface, JD
                IROW=IND_LOC(ILOC)                                     ! Process Local Unknown number.
                JCOL=MESHES(NM)%CUT_FACE(ICF)%JDZ(ILOC,JLOC,IFACE) ! Local position of coef in D_MAT_Z
                ! Add coefficient:
                D_MAT_Z(JCOL,IROW) = D_MAT_Z(JCOL,IROW) + KFACE(ILOC,JLOC)
            ENDDO
         ENDDO

         MESHES(NM)%CUT_FACE(ICF)%DIFF_FACE(N,IFACE) = DIFF_FACE ! Store diffusivities to use in CCDIVG.
         MESHES(NM)%CUT_FACE(ICF)%VELD(N,IFACE) = VELD

      ENDDO

   ENDDO

ENDDO MESH_LOOP


RETURN
END SUBROUTINE GET_ADVDIFFMATRIX_SCALAR_3D


! --------------------------- GET_MMATRIX_SCALAR_3D -------------------------------

SUBROUTINE GET_MMATRIX_SCALAR_3D


! Local Variables:
INTEGER :: NM
INTEGER :: I,J,K,IROW,IROW_LOC,JDIAG,ICC,ICC2

! Allocate mass matrix: Diagonal containing cell volumes on implicit region:
ALLOCATE(  M_MAT_Z(1:NUNKZ_LOCAL) );  M_MAT_Z = 0._EB
ALLOCATE( JM_MAT_Z(1:NUNKZ_LOCAL) ); JM_MAT_Z = 0 ! local index of diagonal entry in JD_MAT_Z

! Mesh Loop:
MESH_LOOP : DO NM=1,NMESHES

   IF (PROCESS(NM)/=MYID) CYCLE

   CALL POINT_TO_MESH(NM)

   ! X direction bounds:
   ILO_FACE = 0                    ! Low mesh boundary face index.
   IHI_FACE = IBAR                 ! High mesh boundary face index.
   ILO_CELL = ILO_FACE + FCELL     ! First internal cell index. See notes.
   IHI_CELL = IHI_FACE + FCELL - 1 ! Last internal cell index.

   ! Y direction bounds:
   JLO_FACE = 0                    ! Low mesh boundary face index.
   JHI_FACE = JBAR                 ! High mesh boundary face index.
   JLO_CELL = JLO_FACE + FCELL     ! First internal cell index. See notes.
   JHI_CELL = JHI_FACE + FCELL - 1 ! Last internal cell index.

   ! Z direction bounds:
   KLO_FACE = 0                    ! Low mesh boundary face index.
   KHI_FACE = KBAR                 ! High mesh boundary face index.
   KLO_CELL = KLO_FACE + FCELL     ! First internal cell index. See notes.
   KHI_CELL = KHI_FACE + FCELL - 1 ! Last internal cell index.


   ! 1. Number Regular GASPHASE cells:
   DO K=KLO_CELL,KHI_CELL
      DO J=JLO_CELL,JHI_CELL
         DO I=ILO_CELL,IHI_CELL
            IF (MESHES(NM)%CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE ! Either explicit region or solid cell.
            IROW = MESHES(NM)%CCVAR(I,J,K,IBM_UNKZ)
            IROW_LOC = IROW - UNKZ_IND(NM_START)
            M_MAT_Z(IROW_LOC) = M_MAT_Z(IROW_LOC) + DX(I)*DY(J)*DZ(K)
         ENDDO
      ENDDO
   ENDDO
   IF (DO_IMPLICIT_CCREGION) THEN
      DO K=KLO_CELL,KHI_CELL
         DO J=JLO_CELL,JHI_CELL
            DO I=ILO_CELL,IHI_CELL
               IF (MESHES(NM)%CCVAR(I,J,K,IBM_UNKZ) <= 0) CYCLE ! Either explicit region or solid cell.
               IROW = MESHES(NM)%CCVAR(I,J,K,IBM_UNKZ)
               IROW_LOC = IROW - UNKZ_IND(NM_START)
               ! Now find diagonal in JD_MAT_Z(1:NNZ_ROW_Z,1:NUNKZ_LOCAL)
               DO JDIAG=1,NNZ_ROW_Z
                  IF(IROW == JD_MAT_Z(JDIAG,IROW_LOC)) THEN
                     JM_MAT_Z(IROW_LOC) = JDIAG
                     EXIT
                  ENDIF
               ENDDO
               IF ( JM_MAT_Z(IROW_LOC) == 0 ) &
               WRITE(LU_ERR,*) 'GET_MMATRIX_SCALAR_3D: Error, diag not found for M at IROW_LOC=',IROW_LOC
            ENDDO
         ENDDO
      ENDDO
   ENDIF


   ! 2. Now Cut cells:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      DO ICC2 = 1,MESHES(NM)%CUT_CELL(ICC)%NCELL
         IROW     = MESHES(NM)%CUT_CELL(ICC)%UNKZ(ICC2)
         IROW_LOC = IROW - UNKZ_IND(NM_START)
         M_MAT_Z(IROW_LOC) = M_MAT_Z(IROW_LOC) + MESHES(NM)%CUT_CELL(ICC)%VOLUME(ICC2)
      ENDDO
   ENDDO
   IF (DO_IMPLICIT_CCREGION) THEN
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         DO ICC2 = 1,MESHES(NM)%CUT_CELL(ICC)%NCELL
            IROW     = MESHES(NM)%CUT_CELL(ICC)%UNKZ(ICC2)
            IROW_LOC = IROW - UNKZ_IND(NM_START)
            ! Now find diagonal in JD_MAT_Z(1:NNZ_ROW_Z,1:NUNKZ_LOCAL)
            DO JDIAG=1,NNZ_ROW_Z
               IF(IROW == JD_MAT_Z(JDIAG,IROW_LOC)) THEN
                  JM_MAT_Z(IROW_LOC) = JDIAG
                  EXIT
               ENDIF
            ENDDO
            IF ( JM_MAT_Z(IROW_LOC) == 0 ) &
            WRITE(LU_ERR,*) 'GET_MMATRIX_SCALAR_3D CC: Error, diag not found for M at IROW_LOC=',IROW_LOC
         ENDDO
      ENDDO
   ENDIF

ENDDO MESH_LOOP

RETURN
END SUBROUTINE GET_MMATRIX_SCALAR_3D



! --------------------- CALL GET_MATRIXGRAPH_SCALARS -----------------------------

SUBROUTINE GET_MATRIXGRAPH_SCALARS

! Local Variables:
INTEGER :: NM
INTEGER :: X1AXIS,IFACE,ICF,I,J,K,IND(LOW_IND:HIGH_IND),IND_LOC(LOW_IND:HIGH_IND)
INTEGER :: LOCROW_1,LOCROW_2,LOCROW,IIND,NII,ILOC,IW

! First run over all regular and gasphase cut faces and insert-add lists of
! related unknows per unknown:
MESH_LOOP_1 : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! X direction bounds:
   ILO_FACE = 0                    ! Low mesh boundary face index.
   IHI_FACE = IBAR                 ! High mesh boundary face index.
   ILO_CELL = ILO_FACE + FCELL     ! First internal cell index. See notes.
   IHI_CELL = IHI_FACE + FCELL - 1 ! Last internal cell index.

   ! Y direction bounds:
   JLO_FACE = 0                    ! Low mesh boundary face index.
   JHI_FACE = JBAR                 ! High mesh boundary face index.
   JLO_CELL = JLO_FACE + FCELL     ! First internal cell index. See notes.
   JHI_CELL = JHI_FACE + FCELL - 1 ! Last internal cell index.

   ! Z direction bounds:
   KLO_FACE = 0                    ! Low mesh boundary face index.
   KHI_FACE = KBAR                 ! High mesh boundary face index.
   KLO_CELL = KLO_FACE + FCELL     ! First internal cell index. See notes.
   KHI_CELL = KHI_FACE + FCELL - 1 ! Last internal cell index.

   ! IAXIS faces:
   X1AXIS = IAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      IW = IBM_REGFACE_IAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
      J  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
      K  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I+FCELL-1,J,K,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I+FCELL  ,J,K,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( I == ILO_FACE )  LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
      IF ( I == IHI_FACE )  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.

      CALL ADD_INPLACE_NNZ_SCALARS(LOCROW_1,LOCROW_2,IND,IND_LOC)

   ENDDO

   ! JAXIS faces:
   X1AXIS = JAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      IW = IBM_REGFACE_JAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
      J  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
      K  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I,J+FCELL-1,K,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I,J+FCELL  ,K,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( J == JLO_FACE )  LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
      IF ( J == JHI_FACE )  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.

      CALL ADD_INPLACE_NNZ_SCALARS(LOCROW_1,LOCROW_2,IND,IND_LOC)

   ENDDO

   ! KAXIS faces:
   X1AXIS = KAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      IW = IBM_REGFACE_KAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
      J  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
      K  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I,J,K+FCELL-1,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I,J,K+FCELL  ,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( K == KLO_FACE )  LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
      IF ( K == KHI_FACE )  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.

      CALL ADD_INPLACE_NNZ_SCALARS(LOCROW_1,LOCROW_2,IND,IND_LOC)

   ENDDO

   ! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
   DO IFACE=1,MESHES(NM)%IBM_NRCFACE_Z

     IW = IBM_RCFACE_Z(IFACE)%IWC
     IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                             WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I      = IBM_RCFACE_Z(IFACE)%IJK(IAXIS)
      J      = IBM_RCFACE_Z(IFACE)%IJK(JAXIS)
      K      = IBM_RCFACE_Z(IFACE)%IJK(KAXIS)
      X1AXIS = IBM_RCFACE_Z(IFACE)%IJK(KAXIS+1)

      ! Unknowns on related cells:
      IND(LOW_IND)  = IBM_RCFACE_Z(IFACE)%UNK(LOW_IND)
      IND(HIGH_IND) = IBM_RCFACE_Z(IFACE)%UNK(HIGH_IND)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND

      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         CASE(JAXIS)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         CASE(KAXIS)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
      ENDSELECT

      CALL ADD_INPLACE_NNZ_SCALARS(LOCROW_1,LOCROW_2,IND,IND_LOC)

   ENDDO

   ! Now Gasphase CUT_FACES:
   DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH

      IF ( CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
      IW = CUT_FACE(ICF)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I = CUT_FACE(ICF)%IJK(IAXIS)
      J = CUT_FACE(ICF)%IJK(JAXIS)
      K = CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND

      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         CASE(JAXIS)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         CASE(KAXIS)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
      ENDSELECT

      DO IFACE=1,MESHES(NM)%CUT_FACE(ICF)%NFACE

         !% Unknowns on related cells:
         IND(LOW_IND)  = MESHES(NM)%CUT_FACE(ICF)%UNKZ(LOW_IND,IFACE)
         IND(HIGH_IND) = MESHES(NM)%CUT_FACE(ICF)%UNKZ(HIGH_IND,IFACE)

         IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
         IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

         CALL ADD_INPLACE_NNZ_SCALARS(LOCROW_1,LOCROW_2,IND,IND_LOC)

      ENDDO

   ENDDO

ENDDO MESH_LOOP_1


! Now add local column location to Faces data structures:
MESH_LOOP_2 : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! X direction bounds:
   ILO_FACE = 0                    ! Low mesh boundary face index.
   IHI_FACE = IBAR                 ! High mesh boundary face index.
   ILO_CELL = ILO_FACE + FCELL     ! First internal cell index. See notes.
   IHI_CELL = IHI_FACE + FCELL - 1 ! Last internal cell index.

   ! Y direction bounds:
   JLO_FACE = 0                    ! Low mesh boundary face index.
   JHI_FACE = JBAR                 ! High mesh boundary face index.
   JLO_CELL = JLO_FACE + FCELL     ! First internal cell index. See notes.
   JHI_CELL = JHI_FACE + FCELL - 1 ! Last internal cell index.

   ! Z direction bounds:
   KLO_FACE = 0                    ! Low mesh boundary face index.
   KHI_FACE = KBAR                 ! High mesh boundary face index.
   KLO_CELL = KLO_FACE + FCELL     ! First internal cell index. See notes.
   KHI_CELL = KHI_FACE + FCELL - 1 ! Last internal cell index.

   ! IAXIS faces:
   X1AXIS = IAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      IW = IBM_REGFACE_IAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(IAXIS)
      J  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(JAXIS)
      K  = IBM_REGFACE_IAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I+FCELL-1,J,K,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I+FCELL  ,J,K,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( I == ILO_FACE )  LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
      IF ( I == IHI_FACE )  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.

      IBM_REGFACE_IAXIS_Z(IFACE)%JD(1:2,1:2) = 0
      DO LOCROW=LOCROW_1,LOCROW_2
         DO IIND=LOW_IND,HIGH_IND
            NII = NNZ_D_MAT_Z(IND_LOC(LOCROW))
            DO ILOC=1,NII
               IF ( IND(IIND) == JD_MAT_Z(ILOC,IND_LOC(LOCROW)) ) THEN
                   IBM_REGFACE_IAXIS_Z(IFACE)%JD(LOCROW,IIND) = ILOC
                   EXIT
               ENDIF
            ENDDO
         ENDDO
      ENDDO

   ENDDO

   ! JAXIS faces:
   X1AXIS = JAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      IW = IBM_REGFACE_JAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(IAXIS)
      J  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(JAXIS)
      K  = IBM_REGFACE_JAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I,J+FCELL-1,K,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I,J+FCELL  ,K,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( J == JLO_FACE )  LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
      IF ( J == JHI_FACE )  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.

      IBM_REGFACE_JAXIS_Z(IFACE)%JD(1:2,1:2) = 0
      DO LOCROW=LOCROW_1,LOCROW_2
         DO IIND=LOW_IND,HIGH_IND
            NII = NNZ_D_MAT_Z(IND_LOC(LOCROW))
            DO ILOC=1,NII
               IF ( IND(IIND) == JD_MAT_Z(ILOC,IND_LOC(LOCROW)) ) THEN
                   IBM_REGFACE_JAXIS_Z(IFACE)%JD(LOCROW,IIND) = ILOC
                   EXIT
               ENDIF
            ENDDO
         ENDDO
      ENDDO

   ENDDO

   ! KAXIS faces:
   X1AXIS = KAXIS
   DO IFACE=1,MESHES(NM)%IBM_NREGFACE_Z(X1AXIS)

      IW = IBM_REGFACE_KAXIS_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(IAXIS)
      J  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(JAXIS)
      K  = IBM_REGFACE_KAXIS_Z(IFACE)%IJK(KAXIS)

      ! Unknowns on related cells:
      IND(LOW_IND)  = CCVAR(I,J,K+FCELL-1,IBM_UNKZ)
      IND(HIGH_IND) = CCVAR(I,J,K+FCELL  ,IBM_UNKZ)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND
      IF ( K == KLO_FACE )  LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
      IF ( K == KHI_FACE )  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.

      IBM_REGFACE_KAXIS_Z(IFACE)%JD(1:2,1:2) = 0
      DO LOCROW=LOCROW_1,LOCROW_2
         DO IIND=LOW_IND,HIGH_IND
            NII = NNZ_D_MAT_Z(IND_LOC(LOCROW))
            DO ILOC=1,NII
               IF ( IND(IIND) == JD_MAT_Z(ILOC,IND_LOC(LOCROW)) ) THEN
                   IBM_REGFACE_KAXIS_Z(IFACE)%JD(LOCROW,IIND) = ILOC
                   EXIT
               ENDIF
            ENDDO
         ENDDO
      ENDDO

   ENDDO

   ! Regular faces connecting gasphase-gasphase or gasphase- cut-cells:
   DO IFACE=1,MESHES(NM)%IBM_NRCFACE_Z

      IW = IBM_RCFACE_Z(IFACE)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I      = IBM_RCFACE_Z(IFACE)%IJK(IAXIS)
      J      = IBM_RCFACE_Z(IFACE)%IJK(JAXIS)
      K      = IBM_RCFACE_Z(IFACE)%IJK(KAXIS)
      X1AXIS = IBM_RCFACE_Z(IFACE)%IJK(KAXIS+1)

      ! Unknowns on related cells:
      IND(LOW_IND)  = IBM_RCFACE_Z(IFACE)%UNK(LOW_IND)
      IND(HIGH_IND) = IBM_RCFACE_Z(IFACE)%UNK(HIGH_IND)

      IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
      IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND

      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         CASE(JAXIS)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         CASE(KAXIS)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
      ENDSELECT

      IBM_RCFACE_Z(IFACE)%JD(1:2,1:2) = 0
      DO LOCROW=LOCROW_1,LOCROW_2
         DO IIND=LOW_IND,HIGH_IND
            NII = NNZ_D_MAT_Z(IND_LOC(LOCROW))
            DO ILOC=1,NII
               IF ( IND(IIND) == JD_MAT_Z(ILOC,IND_LOC(LOCROW)) ) THEN
                   IBM_RCFACE_Z(IFACE)%JD(LOCROW,IIND) = ILOC
                   EXIT
               ENDIF
            ENDDO
         ENDDO
      ENDDO

   ENDDO

   ! Now Gasphase CUT_FACES:
   DO ICF = 1,MESHES(NM)%N_CUTFACE_MESH

      IF ( CUT_FACE(ICF)%STATUS /= IBM_GASPHASE ) CYCLE
      IW = CUT_FACE(ICF)%IWC
      IF((IW > 0) .AND. .NOT.(WALL(IW)%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. &
                              WALL(IW)%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) CYCLE

      I = CUT_FACE(ICF)%IJK(IAXIS)
      J = CUT_FACE(ICF)%IJK(JAXIS)
      K = CUT_FACE(ICF)%IJK(KAXIS)
      X1AXIS = CUT_FACE(ICF)%IJK(KAXIS+1)

      ! Row ind(1),ind(2):
      LOCROW_1 = LOW_IND
      LOCROW_2 = HIGH_IND

      SELECT CASE(X1AXIS)
         CASE(IAXIS)
            IF ( I == ILO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( I == IHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         CASE(JAXIS)
            IF ( J == JLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( J == JHI_FACE ) LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
         CASE(KAXIS)
            IF ( K == KLO_FACE ) LOCROW_1 = HIGH_IND ! Only high side unknown row, i.e. in the current mesh.
            IF ( K == KHI_FACE)  LOCROW_2 =  LOW_IND ! Only low side unknown row, i.e. in the current mesh.
      ENDSELECT

      CUT_FACE(ICF)%JDZ(:,:,:) = 0
      DO IFACE=1,CUT_FACE(ICF)%NFACE

         !% Unknowns on related cells:
         IND(LOW_IND)  = CUT_FACE(ICF)%UNKZ(LOW_IND,IFACE)
         IND(HIGH_IND) = CUT_FACE(ICF)%UNKZ(HIGH_IND,IFACE)

         IND_LOC(LOW_IND) = IND(LOW_IND) - UNKZ_IND(NM_START) ! All row indexes must refer to ind_loc.
         IND_LOC(HIGH_IND)= IND(HIGH_IND)- UNKZ_IND(NM_START)

         DO LOCROW=LOCROW_1,LOCROW_2
            DO IIND=LOW_IND,HIGH_IND
               NII = NNZ_D_MAT_Z(IND_LOC(LOCROW))
               DO ILOC=1,NII
                  IF ( IND(IIND) == JD_MAT_Z(ILOC,IND_LOC(LOCROW)) ) THEN
                      CUT_FACE(ICF)%JDZ(LOCROW,IIND,IFACE) = ILOC
                      EXIT
                  ENDIF
               ENDDO
            ENDDO
         ENDDO
      ENDDO

   ENDDO

ENDDO MESH_LOOP_2


RETURN
END SUBROUTINE GET_MATRIXGRAPH_SCALARS


! ------------------------ ADD_INPLACE_NNZ_SCALARS -------------------------------

SUBROUTINE ADD_INPLACE_NNZ_SCALARS(LOCROW_1,LOCROW_2,IND,IND_LOC)

! Local Variables:
INTEGER, INTENT(IN) :: LOCROW_1,LOCROW_2,IND(LOW_IND:HIGH_IND),IND_LOC(LOW_IND:HIGH_IND)
INTEGER LOCROW, IIND, NII, ILOC, JLOC
LOGICAL INLIST

DO LOCROW=LOCROW_1,LOCROW_2
   DO IIND=LOW_IND,HIGH_IND
      NII = NNZ_D_MAT_Z(IND_LOC(LOCROW))
      ! Check that column index hasn't been already counted:
      INLIST = .FALSE.
      DO ILOC=1,NII
         IF ( IND(IIND) == JD_MAT_Z(ILOC,IND_LOC(LOCROW)) ) THEN
            INLIST = .TRUE.
            EXIT
         ENDIF
      ENDDO
      IF ( INLIST ) CYCLE

      ! Now add in place:
      NII = NII + 1
      DO ILOC=1,NII
          IF ( JD_MAT_Z(ILOC,IND_LOC(LOCROW)) > IND(IIND) ) EXIT
      ENDDO
      DO JLOC=NII,ILOC+1,-1
          JD_MAT_Z(JLOC,IND_LOC(LOCROW)) = JD_MAT_Z(JLOC-1,IND_LOC(LOCROW))
      ENDDO
      NNZ_D_MAT_Z(IND_LOC(LOCROW))   = NII
      JD_MAT_Z(ILOC,IND_LOC(LOCROW)) = IND(IIND)
   ENDDO
ENDDO

RETURN
END SUBROUTINE ADD_INPLACE_NNZ_SCALARS

! ---------------------- GET_GASPHASE_EXIMFACES_DATA -----------------------------

SUBROUTINE GET_GASPHASE_EXIMFACES_DATA

#ifdef MPI_ENABLED
USE MPI
#endif

! Local Variables:
INTEGER :: NM
INTEGER :: ILO,IHI,JLO,JHI,KLO,KHI
INTEGER :: IEXIM, IEXIM_ALLOC
INTEGER :: I,J,K,X1AXIS

#ifdef MPI_ENABLED
INTEGER :: IERR
#endif

! IW,IOR,II,JJ,KK,IIF,JJF,KKF
!TYPE(WALL_TYPE), POINTER :: WC=>NULL()

REAL(EB) :: FCT,IJK_DOT_AREA(IAXIS:KAXIS),IJK_DOT_AREA_AUX(IAXIS:KAXIS)

INTEGER :: IBNDINT,IC

! Mesh Loop:
IJK_DOT_AREA(IAXIS:KAXIS) = 0._EB
MAIN_MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! X direction bounds:
   ILO_FACE = 0                    ! Low mesh boundary face index.
   IHI_FACE = IBAR                 ! High mesh boundary face index.
   ILO_CELL = ILO_FACE + FCELL     ! First internal cell index. See notes.
   IHI_CELL = IHI_FACE + FCELL - 1 ! Last internal cell index.

   ! Y direction bounds:
   JLO_FACE = 0                    ! Low mesh boundary face index.
   JHI_FACE = JBAR                 ! High mesh boundary face index.
   JLO_CELL = JLO_FACE + FCELL     ! First internal cell index. See notes.
   JHI_CELL = JHI_FACE + FCELL - 1 ! Last internal cell index.

   ! Z direction bounds:
   KLO_FACE = 0                    ! Low mesh boundary face index.
   KHI_FACE = KBAR                 ! High mesh boundary face index.
   KLO_CELL = KLO_FACE + FCELL     ! First internal cell index. See notes.
   KHI_CELL = KHI_FACE + FCELL - 1 ! Last internal cell index.

   ! First count EXIM faces number for allocation:
   IEXIM = 0

   ! x1axis = IAXIS:
   ILO = ILO_FACE; IHI = IHI_FACE
   JLO = JLO_CELL; JHI = JHI_CELL
   KLO = KLO_CELL; KHI = KHI_CELL
   DO K=KLO,KHI
      DO J=JLO,JHI
         DO I=ILO,IHI
            IF ( CCVAR(I+FCELL-1,J,K,IBM_CGSC) /= IBM_GASPHASE ) CYCLE
            IF ( CCVAR(I+FCELL  ,J,K,IBM_CGSC) /= IBM_GASPHASE ) CYCLE
            IF(( SIGN(1,CCVAR(I+FCELL-1,J,K,IBM_UNKZ))*SIGN(1,CCVAR(I+FCELL  ,J,K,IBM_UNKZ))) < 0 ) IEXIM = IEXIM + 1
         ENDDO
      ENDDO
   ENDDO
   ! x1axis = JAXIS:
   ILO = ILO_CELL; IHI = IHI_CELL
   JLO = JLO_FACE; JHI = JHI_FACE
   KLO = KLO_CELL; KHI = KHI_CELL
   DO K=KLO,KHI
      DO J=JLO,JHI
         DO I=ILO,IHI
            IF ( CCVAR(I,J+FCELL-1,K,IBM_CGSC) /= IBM_GASPHASE ) CYCLE
            IF ( CCVAR(I,J+FCELL  ,K,IBM_CGSC) /= IBM_GASPHASE ) CYCLE
            IF(( SIGN(1,CCVAR(I,J+FCELL-1,K,IBM_UNKZ))*SIGN(1,CCVAR(I,J+FCELL  ,K,IBM_UNKZ))) < 0 ) IEXIM = IEXIM + 1
         ENDDO
      ENDDO
   ENDDO
   ! x1axis = KAXIS:
   ILO = ILO_CELL; IHI = IHI_CELL
   JLO = JLO_CELL; JHI = JHI_CELL
   KLO = KLO_FACE; KHI = KHI_FACE
   DO K=KLO,KHI
      DO J=JLO,JHI
         DO I=ILO,IHI
            IF ( CCVAR(I,J,K+FCELL-1,IBM_CGSC) /= IBM_GASPHASE ) CYCLE
            IF ( CCVAR(I,J,K+FCELL  ,IBM_CGSC) /= IBM_GASPHASE ) CYCLE
            IF(( SIGN(1,CCVAR(I,J,K+FCELL-1,IBM_UNKZ))*SIGN(1,CCVAR(I,J,K+FCELL  ,IBM_UNKZ))) < 0 ) IEXIM = IEXIM + 1
         ENDDO
      ENDDO
   ENDDO

   ! Now Allocate:
   IEXIM_ALLOC = IEXIM
   ALLOCATE( MESHES(NM)%IBM_EXIM_FACE(IEXIM) )

   ! Finally Populate:
   IEXIM = 0
   ! First block boundary IEXIM FACES, then internal:
   IBNDINT_LOOP : DO IBNDINT=1,3

      IF(IBNDINT==3) MESHES(NM)%IBM_NBBEXIMFACE_MESH = IEXIM ! EXIM faces in block boundaries.

      ! x1axis = IAXIS:
      X1AXIS = IAXIS
      SELECT CASE(IBNDINT)
      CASE(1)
         ILO = ILO_FACE; IHI = ILO_FACE
         JLO = JLO_CELL; JHI = JHI_CELL
         KLO = KLO_CELL; KHI = KHI_CELL
      CASE(2)
         ILO = IHI_FACE; IHI = IHI_FACE
         JLO = JLO_CELL; JHI = JHI_CELL
         KLO = KLO_CELL; KHI = KHI_CELL
      CASE(3)
         ILO = ILO_FACE+1; IHI = IHI_FACE-1
         JLO = JLO_CELL;   JHI = JHI_CELL
         KLO = KLO_CELL;   KHI = KHI_CELL
      END SELECT
      DO K=KLO,KHI
         DO J=JLO,JHI
            DO I=ILO,IHI
               ! Test effect of these two conditionals on Domain boundaries.
               IF ( CCVAR(I+FCELL-1,J,K,IBM_CGSC) /= IBM_GASPHASE ) CYCLE
               IF ( CCVAR(I+FCELL  ,J,K,IBM_CGSC) /= IBM_GASPHASE ) CYCLE

               IF(( SIGN(1,CCVAR(I+FCELL-1,J,K,IBM_UNKZ))*SIGN(1,CCVAR(I+FCELL  ,J,K,IBM_UNKZ))) < 0 ) THEN
                  ! Do not add EXIM faces for block laying on the explicit region:
                  IF (I==ILO_FACE .AND. CCVAR(I+FCELL-1,J,K,IBM_UNKZ) > 0) CYCLE
                  IF (I==IHI_FACE .AND. CCVAR(I+FCELL  ,J,K,IBM_UNKZ) > 0) CYCLE

                  IEXIM = IEXIM + 1
                  MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(IAXIS:KAXIS+1) = (/ I, J, K, X1AXIS /)
                  ALLOCATE(MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FLX(LOW_IND:HIGH_IND,1:N_TOTAL_SCALARS))
                  MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FLX = 0._EB
                  MESHES(NM)%IBM_EXIM_FACE(IEXIM)%AREA = DY(J) * DZ(K)
                  IF ( CCVAR(I+FCELL-1,J,K,IBM_UNKZ) > 0 ) THEN
                     MESHES(NM)%IBM_EXIM_FACE(IEXIM)%LHFACE = HIGH_IND ! High face of NUNK>0 cell.
                     MESHES(NM)%IBM_EXIM_FACE(IEXIM)%UNKZ   = CCVAR(I+FCELL-1,J,K,IBM_UNKZ)
                  ELSEIF ( CCVAR(I+FCELL  ,J,K,IBM_UNKZ) > 0 ) THEN
                     MESHES(NM)%IBM_EXIM_FACE(IEXIM)%LHFACE = LOW_IND
                     MESHES(NM)%IBM_EXIM_FACE(IEXIM)%UNKZ   = CCVAR(I+FCELL  ,J,K,IBM_UNKZ)
                  ENDIF
                  FCT = REAL(2*MESHES(NM)%IBM_EXIM_FACE(IEXIM)%LHFACE-3,EB)
                  IJK_DOT_AREA(X1AXIS) = IJK_DOT_AREA(X1AXIS) + FCT*MESHES(NM)%IBM_EXIM_FACE(IEXIM)%AREA
                  IF (I == ILO_FACE) THEN
                     IC = CELL_INDEX(I+FCELL  ,J,K)
                     MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IWC   = WALL_INDEX(IC,-X1AXIS)
                  ELSEIF (I == IHI_FACE) THEN
                     IC = CELL_INDEX(I+FCELL-1,J,K)
                     MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IWC   = WALL_INDEX(IC, X1AXIS)
                  ENDIF
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      ! axis = JAXIS:
      X1AXIS = JAXIS
      SELECT CASE(IBNDINT)
      CASE(1)
         ILO = ILO_CELL; IHI = IHI_CELL
         JLO = JLO_FACE; JHI = JLO_FACE
         KLO = KLO_CELL; KHI = KHI_CELL
      CASE(2)
         ILO = ILO_CELL; IHI = IHI_CELL
         JLO = JHI_FACE; JHI = JHI_FACE
         KLO = KLO_CELL; KHI = KHI_CELL
      CASE(3)
         ILO = ILO_CELL;   IHI = IHI_CELL
         JLO = JLO_FACE+1; JHI = JHI_FACE-1
         KLO = KLO_CELL;   KHI = KHI_CELL
      END SELECT
      DO K=KLO,KHI
         DO J=JLO,JHI
            DO I=ILO,IHI
               ! Test effect of these two conditionals on Domain boundaries.
               IF ( CCVAR(I,J+FCELL-1,K,IBM_CGSC) /= IBM_GASPHASE ) CYCLE
               IF ( CCVAR(I,J+FCELL  ,K,IBM_CGSC) /= IBM_GASPHASE ) CYCLE

               IF(( SIGN(1,CCVAR(I,J+FCELL-1,K,IBM_UNKZ))*SIGN(1,CCVAR(I,J+FCELL  ,K,IBM_UNKZ))) < 0 ) THEN
                  ! Do not add EXIM faces for block laying on the explicit region:
                  IF (J==JLO_FACE .AND. CCVAR(I,J+FCELL-1,K,IBM_UNKZ) > 0) CYCLE
                  IF (J==JHI_FACE .AND. CCVAR(I,J+FCELL  ,K,IBM_UNKZ) > 0) CYCLE

                  IEXIM = IEXIM + 1
                  MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(IAXIS:KAXIS+1) = (/ I, J, K, X1AXIS /)
                  ALLOCATE(MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FLX(LOW_IND:HIGH_IND,1:N_TOTAL_SCALARS))
                  MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FLX = 0._EB
                  MESHES(NM)%IBM_EXIM_FACE(IEXIM)%AREA = DX(I) * DZ(K)
                  IF ( CCVAR(I,J+FCELL-1,K,IBM_UNKZ) > 0 ) THEN
                     MESHES(NM)%IBM_EXIM_FACE(IEXIM)%LHFACE = HIGH_IND ! High face of NUNK>0 cell.
                     MESHES(NM)%IBM_EXIM_FACE(IEXIM)%UNKZ   = CCVAR(I,J+FCELL-1,K,IBM_UNKZ)
                  ELSEIF ( CCVAR(I,J+FCELL  ,K,IBM_UNKZ) > 0 ) THEN
                     MESHES(NM)%IBM_EXIM_FACE(IEXIM)%LHFACE = LOW_IND
                     MESHES(NM)%IBM_EXIM_FACE(IEXIM)%UNKZ   = CCVAR(I,J+FCELL  ,K,IBM_UNKZ)
                  ENDIF
                  FCT = REAL(2*MESHES(NM)%IBM_EXIM_FACE(IEXIM)%LHFACE-3,EB)
                  IJK_DOT_AREA(X1AXIS) = IJK_DOT_AREA(X1AXIS) + FCT*MESHES(NM)%IBM_EXIM_FACE(IEXIM)%AREA
                  IF (J == JLO_FACE) THEN
                     IC = CELL_INDEX(I,J+FCELL  ,K)
                     MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IWC   = WALL_INDEX(IC,-X1AXIS)
                  ELSEIF (J == JHI_FACE) THEN
                     IC = CELL_INDEX(I,J+FCELL-1,K)
                     MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IWC   = WALL_INDEX(IC, X1AXIS)
                  ENDIF
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      ! axis = KAXIS:
      X1AXIS = KAXIS
      SELECT CASE(IBNDINT)
      CASE(1)
         ILO = ILO_CELL; IHI = IHI_CELL
         JLO = JLO_CELL; JHI = JHI_CELL
         KLO = KLO_FACE; KHI = KLO_FACE
      CASE(2)
         ILO = ILO_CELL; IHI = IHI_CELL
         JLO = JLO_CELL; JHI = JHI_CELL
         KLO = KHI_FACE; KHI = KHI_FACE
      CASE(3)
         ILO = ILO_CELL;   IHI = IHI_CELL
         JLO = JLO_CELL;   JHI = JHI_CELL
         KLO = KLO_FACE+1; KHI = KHI_FACE-1
      END SELECT
      DO K=KLO,KHI
         DO J=JLO,JHI
            DO I=ILO,IHI
               ! Test effect of these two conditionals on Domain boundaries.
               IF ( CCVAR(I,J,K+FCELL-1,IBM_CGSC) /= IBM_GASPHASE ) CYCLE
               IF ( CCVAR(I,J,K+FCELL  ,IBM_CGSC) /= IBM_GASPHASE ) CYCLE

               IF(( SIGN(1,CCVAR(I,J,K+FCELL-1,IBM_UNKZ))*SIGN(1,CCVAR(I,J,K+FCELL  ,IBM_UNKZ))) < 0 ) THEN
                  ! Do not add EXIM faces for block laying on the explicit region:
                  IF (K==KLO_FACE .AND. CCVAR(I,J,K+FCELL-1,IBM_UNKZ) > 0) CYCLE
                  IF (K==KHI_FACE .AND. CCVAR(I,J,K+FCELL  ,IBM_UNKZ) > 0) CYCLE

                  IEXIM = IEXIM + 1
                  MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IJK(IAXIS:KAXIS+1) = (/ I, J, K, X1AXIS /)
                  ALLOCATE(MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FLX(LOW_IND:HIGH_IND,1:N_TOTAL_SCALARS))
                  MESHES(NM)%IBM_EXIM_FACE(IEXIM)%FLX = 0._EB
                  MESHES(NM)%IBM_EXIM_FACE(IEXIM)%AREA = DX(I) * DY(J)
                  IF ( CCVAR(I,J,K+FCELL-1,IBM_UNKZ) > 0 ) THEN
                     MESHES(NM)%IBM_EXIM_FACE(IEXIM)%LHFACE = HIGH_IND ! High face of NUNK>0 cell.
                     MESHES(NM)%IBM_EXIM_FACE(IEXIM)%UNKZ   = CCVAR(I,J,K+FCELL-1,IBM_UNKZ)
                  ELSEIF ( CCVAR(I,J,K+FCELL  ,IBM_UNKZ) > 0 ) THEN
                     MESHES(NM)%IBM_EXIM_FACE(IEXIM)%LHFACE = LOW_IND
                     MESHES(NM)%IBM_EXIM_FACE(IEXIM)%UNKZ   = CCVAR(I,J,K+FCELL  ,IBM_UNKZ)
                  ENDIF
                  FCT = REAL(2*MESHES(NM)%IBM_EXIM_FACE(IEXIM)%LHFACE-3,EB)
                  IJK_DOT_AREA(X1AXIS) = IJK_DOT_AREA(X1AXIS) + FCT*MESHES(NM)%IBM_EXIM_FACE(IEXIM)%AREA
                  IF (K == KLO_FACE) THEN
                     IC = CELL_INDEX(I,J,K+FCELL  )
                     MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IWC   = WALL_INDEX(IC,-X1AXIS)
                  ELSEIF (K == KHI_FACE) THEN
                     IC = CELL_INDEX(I,J,K+FCELL-1)
                     MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IWC   = WALL_INDEX(IC, X1AXIS)
                  ENDIF
               ENDIF
            ENDDO
         ENDDO
      ENDDO

   ENDDO IBNDINT_LOOP

   ! Here IBM_NEXIMFACE_MESH might end up being less than size of MESHES(NM)%IBM_EXIM_FACE(:), because
   ! EXIM faces tied to a cell on the guard-cell region are not taken into account (are dealt with on the
   ! neighbor mesh).
   MESHES(NM)%IBM_NEXIMFACE_MESH = IEXIM

   ! WRITE(LU_ERR,*) "EXIM faces test: MYID, MESH, IEXIM_ALLOC, NEXIMFACE_MESH=",&
   !                 MYID,NM,IEXIM_ALLOC,MESHES(NM)%IBM_NEXIMFACE_MESH

ENDDO MAIN_MESH_LOOP

! Now all reduce:
#ifdef MPI_ENABLED
IF (N_MPI_PROCESSES > 1) THEN
   IJK_DOT_AREA_AUX(IAXIS:KAXIS)=IJK_DOT_AREA(IAXIS:KAXIS)
   CALL MPI_ALLREDUCE(IJK_DOT_AREA_AUX(1), IJK_DOT_AREA(1), MAX_DIM, MPI_DOUBLE_PRECISION, &
                      MPI_SUM, MPI_COMM_WORLD, IERR)
ENDIF
#endif
IF (MYID==0) WRITE(LU_ERR,"(A,3E12.4)") " GEOM EXIM faces test: Int{dot(ei,n)}dS, i=IAXIS:KAXIS =", &
                                        IJK_DOT_AREA(IAXIS:KAXIS)

! Debug flag test:
#ifdef DEBUG_MATVEC_DATA
DBG_MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
#ifdef MPI_ENABLED
   CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
#endif /* MPI_ENABLED */
   IF(MYID==PROCESS(NM)) THEN
   CALL POINT_TO_MESH(NM)
   WRITE(LU_ERR,*) ' '
   WRITE(LU_ERR,*) 'MYID, NM, NEXIMFACE, NBBEXIMFACE : ', &
   MYID,NM,MESHES(NM)%IBM_NEXIMFACE_MESH,MESHES(NM)%IBM_NBBEXIMFACE_MESH
   DO IEXIM=1,MESHES(NM)%IBM_NBBEXIMFACE_MESH
      WRITE(LU_ERR,*) 'BB EXIMFACE, IEXIM, IWC=',IEXIM,MESHES(NM)%IBM_EXIM_FACE(IEXIM)%IWC
   ENDDO
  ENDIF
#ifdef MPI_ENABLED
   CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
#endif /* MPI_ENABLED */
ENDDO DBG_MESH_LOOP
#endif /* DEBUG_MATVEC_DATA */


RETURN
END SUBROUTINE GET_GASPHASE_EXIMFACES_DATA

! --------------------------- GET_H_CUTFACES ------------------------------------

SUBROUTINE GET_H_CUTFACES

! Local variables:
INTEGER :: NM
INTEGER :: NCELL,ICC,JCC,IFC,IFACE,LOWHIGH,ICF1,ICF2
INTEGER :: IW,II,JJ,KK,IIF,JJF,KKF,IOR,LOWHIGH_TEST,X1AXIS
TYPE (WALL_TYPE), POINTER :: WC

! Mesh loop:
MAIN_MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! Now Pressure:
   if ( PRES_ON_WHOLE_DOMAIN ) CYCLE ! No need to build matrix this way, i.e. fft solver/structured solve
                                     ! will be used for pressure.

   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      NCELL = CUT_CELL(ICC)%NCELL
      DO JCC=1,NCELL
         DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
            IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
            ! If face type in face_list is not IBM_FTYPE_CFGAS, drop:
            IF ( CUT_CELL(ICC)%FACE_LIST(1,IFACE) /= IBM_FTYPE_CFGAS ) CYCLE

            ! Which face?
            LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
            ICF1    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
            ICF2    = CUT_CELL(ICC)%FACE_LIST(5,IFACE)

            IF ( LOWHIGH == LOW_IND) THEN ! Cut-face on low side of cut-cell:

               IF ( .NOT.PRES_ON_CARTESIAN ) THEN ! Unstructured H Poisson matrix build, use cut-cell vols:
                  CUT_FACE(ICF1)%UNKH(HIGH_IND,ICF2) = CUT_CELL(ICC)%UNKH(JCC)
                  !  XCENH already filled in scalars.

               ELSE ! Unstructured build, use underlying cartesian cells:
                  CUT_FACE(ICF1)%UNKH(HIGH_IND,ICF2) = CUT_CELL(ICC)%UNKH(1)
                  !  XCENH is the Cartesian cell center of high side cell.

               ENDIF

            ELSE ! HIGH

               IF ( .NOT.PRES_ON_CARTESIAN ) THEN ! Unstructured H Poisson matrix build, use cut-cell vols:
                  CUT_FACE(ICF1)%UNKH(LOW_IND,ICF2) = CUT_CELL(ICC)%UNKH(JCC)
                  !  XCENL already filled in scalars.

               ELSE ! Unstructured build, use underlying cartesian cells:
                  CUT_FACE(ICF1)%UNKH(LOW_IND,ICF2) = CUT_CELL(ICC)%UNKH(1)
                  !  XCENL is the Cartesian cell center of the low side cell.
                  !  LOW_IND and HIGH_IND numbers will be repeated for all icf2 IBM_GASPHASE cut-faces.

               ENDIF

            ENDIF

         ENDDO
      ENDDO
   ENDDO

   ! Now Apply external wall cell loop for guard-cell cut cells:
   GUARD_CUT_CELL_LOOP :  DO IW=1,N_EXTERNAL_WALL_CELLS
      WC=>WALL(IW)
      IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE GUARD_CUT_CELL_LOOP

      II  = WC%ONE_D%II
      JJ  = WC%ONE_D%JJ
      KK  = WC%ONE_D%KK
      IOR = WC%ONE_D%IOR

      ! Drop if face is not of type IBM_CUTCFE:
      X1AXIS=ABS(IOR)
      SELECT CASE(IOR)
      CASE( IAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=HIGH_IND ! Face on high side of Guard-Cell
      CASE(-IAXIS)
         IIF=II-1; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=LOW_IND
      CASE( JAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=HIGH_IND
      CASE(-JAXIS)
         IIF=II  ; JJF=JJ-1; KKF=KK
         LOWHIGH_TEST=LOW_IND
      CASE( KAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=HIGH_IND
      CASE(-KAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK-1
         LOWHIGH_TEST=LOW_IND
      END SELECT

      IF (FCVAR(IIF,JJF,KKF,IBM_FGSC,X1AXIS) /= IBM_CUTCFE) CYCLE GUARD_CUT_CELL_LOOP

      ! Copy CCVAR(II,JJ,KK,IBM_CGSC) to guard cell:
      ICC = MESHES(NM)%CCVAR(II,JJ,KK,IBM_IDCC)

      DO JCC=1,CUT_CELL(ICC)%NCELL

         ! Loop faces and test:
         DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)

            IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
            ! Which face ?
            LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)

            IF ( CUT_CELL(ICC)%FACE_LIST(1,IFACE) /= IBM_FTYPE_CFGAS) CYCLE ! Must Be gasphase cut-face
            IF ( LOWHIGH                              /= LOWHIGH_TEST) CYCLE ! In same side as EWC from guard-cell
            IF ( CUT_CELL(ICC)%FACE_LIST(3,IFACE) /= X1AXIS) CYCLE ! Normal to same axis as EWC

            ICF1    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
            ICF2    = CUT_CELL(ICC)%FACE_LIST(5,IFACE)

            IF ( LOWHIGH == LOW_IND) THEN ! Cut-face on low side of cut-cell:
               IF ( .NOT.PRES_ON_CARTESIAN ) THEN ! Unstructured H Poisson matrix build, use cut-cell vols:
                  CUT_FACE(ICF1)%UNKH(HIGH_IND,ICF2) = CUT_CELL(ICC)%UNKH(JCC)
               ELSE ! Unstructured build, use underlying cartesian cells:
                  CUT_FACE(ICF1)%UNKH(HIGH_IND,ICF2) = CUT_CELL(ICC)%UNKH(1)
               ENDIF
            ELSE ! HIGH
               IF ( .NOT.PRES_ON_CARTESIAN ) THEN ! Unstructured H Poisson matrix build, use cut-cell vols:
                  CUT_FACE(ICF1)%UNKH(LOW_IND,ICF2) = CUT_CELL(ICC)%UNKH(JCC)
               ELSE ! Unstructured build, use underlying cartesian cells:
                  CUT_FACE(ICF1)%UNKH(LOW_IND,ICF2) = CUT_CELL(ICC)%UNKH(1)
               ENDIF
            ENDIF

         ENDDO
      ENDDO
   ENDDO GUARD_CUT_CELL_LOOP

ENDDO MAIN_MESH_LOOP


RETURN
END SUBROUTINE GET_H_CUTFACES

! ---------------------- GET_GASPHASE_CUTFACES_DATA -----------------------------

SUBROUTINE GET_GASPHASE_CUTFACES_DATA

#if defined(DEBUG_MATVEC_DATA) && defined(MPI_ENABLED)
USE MPI
#endif

! Local variables:
INTEGER :: NM
INTEGER :: NCELL,ICC,JCC,IFC,IFACE,LOWHIGH,ICF1,ICF2
INTEGER :: IW,II,JJ,KK,IIF,JJF,KKF,IOR,IIG,JJG,KKG,LOWHIGH_TEST,LOWHIGH_TEST_G,X1AXIS
TYPE (WALL_TYPE), POINTER :: WC

#if defined(DEBUG_MATVEC_DATA) && defined(MPI_ENABLED)
INTEGER :: IERR
#endif

! Mesh loop:
MAIN_MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! First Scalars:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      NCELL = CUT_CELL(ICC)%NCELL
      DO JCC=1,NCELL
         DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
            IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
            ! If face type in face_list is not IBM_FTYPE_CFGAS, drop:
            IF ( CUT_CELL(ICC)%FACE_LIST(1,IFACE) /= IBM_FTYPE_CFGAS ) CYCLE

            ! Which face?
            LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
            ICF1    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
            ICF2    = CUT_CELL(ICC)%FACE_LIST(5,IFACE)

            IF ( LOWHIGH == LOW_IND) THEN ! Cut-face on low side of cut-cell:

               CUT_FACE(ICF1)%UNKZ(HIGH_IND,ICF2)        = CUT_CELL(ICC)%UNKZ(JCC)
               CUT_FACE(ICF1)%XCENHIGH(IAXIS:KAXIS,ICF2) = CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)

            ELSE ! HIGH

               CUT_FACE(ICF1)%UNKZ(LOW_IND,ICF2)         = CUT_CELL(ICC)%UNKZ(JCC)
               CUT_FACE(ICF1)%XCENLOW(IAXIS:KAXIS,ICF2)  = CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)

            ENDIF

         ENDDO
      ENDDO
   ENDDO

   ! Now Apply external wall cell loop for guard-cell cut cells:
   GUARD_CUT_CELL_LOOP :  DO IW=1,N_EXTERNAL_WALL_CELLS
      WC=>WALL(IW)

      II  = WC%ONE_D%II
      JJ  = WC%ONE_D%JJ
      KK  = WC%ONE_D%KK
      IOR = WC%ONE_D%IOR

      ! Drop if face is not of type IBM_CUTCFE:
      X1AXIS=ABS(IOR)
      SELECT CASE(IOR)
      CASE( IAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST  =HIGH_IND ! Face on high side of Guard-Cell
         LOWHIGH_TEST_G= LOW_IND
      CASE(-IAXIS)
         IIF=II-1; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST  = LOW_IND
         LOWHIGH_TEST_G=HIGH_IND
      CASE( JAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST  =HIGH_IND
         LOWHIGH_TEST_G= LOW_IND
      CASE(-JAXIS)
         IIF=II  ; JJF=JJ-1; KKF=KK
         LOWHIGH_TEST  = LOW_IND
         LOWHIGH_TEST_G=HIGH_IND
      CASE( KAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST  =HIGH_IND
         LOWHIGH_TEST_G= LOW_IND
      CASE(-KAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK-1
         LOWHIGH_TEST  = LOW_IND
         LOWHIGH_TEST_G=HIGH_IND
      END SELECT

      IF (FCVAR(IIF,JJF,KKF,IBM_FGSC,X1AXIS) /= IBM_CUTCFE) CYCLE GUARD_CUT_CELL_LOOP

      IIG  = WC%ONE_D%IIG
      JJG  = WC%ONE_D%JJG
      KKG  = WC%ONE_D%KKG

      ! Add IWC field to CUT_FACE from internal cell:
      ICC = MESHES(NM)%CCVAR(IIG,JJG,KKG,IBM_IDCC)
      DO JCC=1,CUT_CELL(ICC)%NCELL
         ! Loop faces and test:
         DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
            IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
            ! Which face ?
            LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
            IF ( CUT_CELL(ICC)%FACE_LIST(1,IFACE) /= IBM_FTYPE_CFGAS) CYCLE ! Must Be gasphase cut-face
            IF ( LOWHIGH                          /=  LOWHIGH_TEST_G) CYCLE ! In same side as EWC from internal cell
            IF ( CUT_CELL(ICC)%FACE_LIST(3,IFACE) /= X1AXIS) CYCLE ! Normal to same axis as EWC
            ICF1    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
            CUT_FACE(ICF1)%IWC = IW ! Rest of info from internal cut-cell has been filled in previous ICC loop.
         ENDDO
      ENDDO

      ! Now CCVAR(II,JJ,KK,IBM_CGSC) from guard cell:
      ICC = MESHES(NM)%CCVAR(II,JJ,KK,IBM_IDCC)
      DO JCC=1,CUT_CELL(ICC)%NCELL
         ! Loop faces and test:
         DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
            IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
            ! Which face ?
            LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
            IF ( CUT_CELL(ICC)%FACE_LIST(1,IFACE) /= IBM_FTYPE_CFGAS) CYCLE ! Must Be gasphase cut-face
            IF ( LOWHIGH                              /= LOWHIGH_TEST) CYCLE ! In same side as EWC from guard-cell
            IF ( CUT_CELL(ICC)%FACE_LIST(3,IFACE) /= X1AXIS) CYCLE ! Normal to same axis as EWC

            ICF1    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
            ICF2    = CUT_CELL(ICC)%FACE_LIST(5,IFACE)

            IF ( LOWHIGH == LOW_IND) THEN ! Cut-face on low side of cut-cell:
               CUT_FACE(ICF1)%UNKZ(HIGH_IND,ICF2)        = CUT_CELL(ICC)%UNKZ(JCC)
               CUT_FACE(ICF1)%XCENHIGH(IAXIS:KAXIS,ICF2) = CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)
            ELSE ! HIGH
               CUT_FACE(ICF1)%UNKZ(LOW_IND,ICF2)         = CUT_CELL(ICC)%UNKZ(JCC)
               CUT_FACE(ICF1)%XCENLOW(IAXIS:KAXIS,ICF2)  = CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)
            ENDIF

         ENDDO
      ENDDO
   ENDDO GUARD_CUT_CELL_LOOP

ENDDO MAIN_MESH_LOOP

#ifdef DEBUG_MATVEC_DATA
DBG_MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
#ifdef MPI_ENABLED
   CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
#endif /* MPI_ENABLED */
   IF(MYID==PROCESS(NM)) THEN
   CALL POINT_TO_MESH(NM)
   WRITE(LU_ERR,*) ' '
   WRITE(LU_ERR,*) 'MYID, NM, N_BBCUTFACE_MESH : ',MYID,NM,MESHES(NM)%N_BBCUTFACE_MESH
   DO IFC=1,MESHES(NM)%N_BBCUTFACE_MESH
      IF(CUT_FACE(IFC)%STATUS/=IBM_GASPHASE) CYCLE
      WRITE(LU_ERR,*) 'BB CUT_FACE, IFC, IWC=',IFC,CUT_FACE(IFC)%IWC,CUT_FACE(IFC)%STATUS
   ENDDO
  ENDIF
#ifdef MPI_ENABLED
   CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
#endif /* MPI_ENABLED */
ENDDO DBG_MESH_LOOP
#endif /* DEBUG_MATVEC_DATA */

RETURN
END SUBROUTINE GET_GASPHASE_CUTFACES_DATA


! ---------------------------- GET_RCFACES_H ------------------------------------

SUBROUTINE GET_RCFACES_H(NM)


INTEGER, INTENT(IN) :: NM

! Local Variables:
INTEGER :: IRC,IIFC,X1AXIS,X2AXIS,X3AXIS
INTEGER, ALLOCATABLE, DIMENSION(:,:,:,:) :: IJKFACE
INTEGER :: NCELL,ICC,JCC,IJK(MAX_DIM),IFC,IFACE,LOWHIGH
INTEGER :: XIAXIS,XJAXIS,XKAXIS,INDXI1(MAX_DIM),INCELL,JNCELL,KNCELL,INFACE,JNFACE,KNFACE
INTEGER :: ISTR, IEND, JSTR, JEND, KSTR, KEND
LOGICAL :: INLIST

INTEGER :: IW,II,JJ,KK,IIF,JJF,KKF,IOR,LOWHIGH_TEST,IIG,JJG,KKG
TYPE (WALL_TYPE), POINTER :: WC

LOGICAL :: FLGIN

! Test for Pressure Solver:
IF ( (PRES_METHOD /= "GLMAT") .OR. (PRES_ON_WHOLE_DOMAIN) ) RETURN ! No need to build matrix as
                                                                   ! unstructured.

! Mesh sizes:
NXB=IBAR; NYB=JBAR; NZB=KBAR

! X direction bounds:
ILO_FACE = 0                    ! Low mesh boundary face index.
IHI_FACE = IBAR                 ! High mesh boundary face index.
ILO_CELL = ILO_FACE + FCELL     ! First internal cell index. See notes.
IHI_CELL = IHI_FACE + FCELL - 1 ! Last internal cell index.
ISTR     = ILO_FACE - NGUARD    ! Allocation start x arrays.
IEND     = IHI_FACE + NGUARD    ! Allocation end x arrays.

! Y direction bounds:
JLO_FACE = 0                    ! Low mesh boundary face index.
JHI_FACE = JBAR                 ! High mesh boundary face index.
JLO_CELL = JLO_FACE + FCELL     ! First internal cell index. See notes.
JHI_CELL = JHI_FACE + FCELL - 1 ! Last internal cell index.
JSTR     = JLO_FACE - NGUARD    ! Allocation start y arrays.
JEND     = JHI_FACE + NGUARD    ! Allocation end y arrays.

! Z direction bounds:
KLO_FACE = 0                    ! Low mesh boundary face index.
KHI_FACE = KBAR                 ! High mesh boundary face index.
KLO_CELL = KLO_FACE + FCELL     ! First internal cell index. See notes.
KHI_CELL = KHI_FACE + FCELL - 1 ! Last internal cell index.
KSTR     = KLO_FACE - NGUARD    ! Allocation start z arrays.
KEND     = KHI_FACE + NGUARD    ! Allocation end z arrays.

! First count for allocation:
ALLOCATE( IJKFACE(ILO_FACE:IHI_FACE,JLO_FACE:JHI_FACE,KLO_FACE:KHI_FACE,IAXIS:KAXIS) )
IJKFACE(:,:,:,:) = 0
DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
   NCELL = CUT_CELL(ICC)%NCELL
   IJK(IAXIS:KAXIS) = CUT_CELL(ICC)%IJK(IAXIS:KAXIS)
   DO JCC=1,NCELL
      ! Loop faces and test:
      DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
         IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
         ! If face type in face_list is not IBM_FTYPE_RGGAS, drop:
         IF(CUT_CELL(ICC)%FACE_LIST(1,IFACE) /= IBM_FTYPE_RGGAS) CYCLE
         ! Which face?
         LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
         X1AXIS  = CUT_CELL(ICC)%FACE_LIST(3,IFACE)
         SELECT CASE(X1AXIS)
         CASE(IAXIS)
            X2AXIS = JAXIS; X3AXIS = KAXIS
            ! location in I,J,K od x2,x2,x3 axes:
            XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS
         CASE(JAXIS)
            X2AXIS = KAXIS; X3AXIS = IAXIS
            ! location in I,J,K od x2,x2,x3 axes:
            XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS
         CASE(KAXIS)
            X2AXIS = IAXIS; X3AXIS = JAXIS
            ! location in I,J,K od x2,x2,x3 axes:
            XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS
         END SELECT

         IF (LOWHIGH == LOW_IND) THEN
            ! Face indexes:
            INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-FCELL, IJK(X2AXIS), IJK(X3AXIS) /)
            INFACE = INDXI1(XIAXIS)
            JNFACE = INDXI1(XJAXIS)
            KNFACE = INDXI1(XKAXIS)

            ! Location of next Cartesian cell:
            INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-1, IJK(X2AXIS), IJK(X3AXIS) /)
            INCELL = INDXI1(XIAXIS)
            JNCELL = INDXI1(XJAXIS)
            KNCELL = INDXI1(XKAXIS)

            IF ( MESHES(NM)%CCVAR(INCELL,JNCELL,KNCELL,IBM_UNKH) > 0 ) THEN
               IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS) = 1
            ELSEIF ( MESHES(NM)%CCVAR(INCELL,JNCELL,KNCELL,IBM_CGSC) == IBM_CUTCFE ) THEN ! Cut-cell.
               IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS) = 1
            ENDIF
         ELSE ! HIGH_IND
            ! Face indexes:
            INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-FCELL+1, IJK(X2AXIS), IJK(X3AXIS) /)
            INFACE = INDXI1(XIAXIS)
            JNFACE = INDXI1(XJAXIS)
            KNFACE = INDXI1(XKAXIS)

            ! Location of next Cartesian cell:
            INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)+1, IJK(X2AXIS), IJK(X3AXIS) /)
            INCELL = INDXI1(XIAXIS)
            JNCELL = INDXI1(XJAXIS)
            KNCELL = INDXI1(XKAXIS)

            IF ( MESHES(NM)%CCVAR(INCELL,JNCELL,KNCELL,IBM_UNKH) > 0 ) THEN
               IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS) = 1
            ELSEIF ( MESHES(NM)%CCVAR(INCELL,JNCELL,KNCELL,IBM_CGSC) == IBM_CUTCFE ) THEN ! Cut-cell.
               IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS) = 1
            ENDIF
         ENDIF

      ENDDO
   ENDDO
ENDDO

! Check for RCFACE_H on the boundary of the domain, where the cut-cell is in the cut-cell region.
! Now Apply external wall cell loop for guard-cell cut cells:
GUARD_CUT_CELL_LOOP_1 :  DO IW=1,N_EXTERNAL_WALL_CELLS
   WC=>WALL(IW)
   II  = WC%ONE_D%II
   JJ  = WC%ONE_D%JJ
   KK  = WC%ONE_D%KK
   IOR = WC%ONE_D%IOR

   ! Which face:
   X1AXIS=ABS(IOR)
   SELECT CASE(IOR)
   CASE( IAXIS)
      IIF=II  ; JJF=JJ  ; KKF=KK
   CASE(-IAXIS)
      IIF=II-1; JJF=JJ  ; KKF=KK
   CASE( JAXIS)
      IIF=II  ; JJF=JJ  ; KKF=KK
   CASE(-JAXIS)
      IIF=II  ; JJF=JJ-1; KKF=KK
   CASE( KAXIS)
      IIF=II  ; JJF=JJ  ; KKF=KK
   CASE(-KAXIS)
      IIF=II  ; JJF=JJ  ; KKF=KK-1
   END SELECT

   IF (WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY) THEN
      ! Drop if FACE is not type IBM_GASPHASE
      IF (FCVAR(IIF,JJF,KKF,IBM_FGSC,X1AXIS) /= IBM_GASPHASE) CYCLE GUARD_CUT_CELL_LOOP_1

      IIG  = WC%ONE_D%IIG
      JJG  = WC%ONE_D%JJG
      KKG  = WC%ONE_D%KKG

      ! Is this an actual RCFACE_VEL laying on the mesh boundary, where the cut-cell is in the guard-cell region?
      FLGIN = (CCVAR(II,JJ,KK,IBM_CGSC)==IBM_CUTCFE) .AND. (CCVAR(IIG,JJG,KKG,IBM_CGSC)==IBM_GASPHASE)

      IF(.NOT.FLGIN) CYCLE GUARD_CUT_CELL_LOOP_1

      IJKFACE(IIF,JJF,KKF,X1AXIS) = 1

   ELSE ! All other types of BCs (SOLID_BOUNDARY, NULL_BOUNDARY, OPEN_BOUNDARY) will not be added to RCFACES_H.

      IJKFACE(IIF,JJF,KKF,X1AXIS) = 0

   ENDIF

ENDDO GUARD_CUT_CELL_LOOP_1

IRC = SUM(IJKFACE(:,:,:,:))
IF (IRC == 0) THEN
   DEALLOCATE(IJKFACE)
   RETURN
ELSE
   ! Compute xc, yc, zc:
   ! Populate position and cell size arrays: Uniform grid implementation.
   ! X direction:
   ALLOCATE(XCELL(ISTR:IEND));  XCELL = 1._EB/GEOMEPS ! Initialize huge.
   XCELL(ILO_CELL-1:IHI_CELL+1) = MESHES(NM)%XC(ILO_CELL-1:IHI_CELL+1)

   ! Y direction:
   ALLOCATE(YCELL(JSTR:JEND));  YCELL = 1._EB/GEOMEPS ! Initialize huge.
   YCELL(JLO_CELL-1:JHI_CELL+1) = MESHES(NM)%YC(JLO_CELL-1:JHI_CELL+1)

   ! Z direction:
   ALLOCATE(ZCELL(KSTR:KEND));  ZCELL = 1._EB/GEOMEPS ! Initialize huge.
   ZCELL(KLO_CELL-1:KHI_CELL+1) = MESHES(NM)%ZC(KLO_CELL-1:KHI_CELL+1)
ENDIF

MESHES(NM)%IBM_NRCFACE_H = IRC ! Same number of regular - cut cell faces as scalars.
ALLOCATE( MESHES(NM)%IBM_RCFACE_H(IRC) )
IRC = 0
DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
   NCELL = CUT_CELL(ICC)%NCELL
   IJK(IAXIS:KAXIS) = CUT_CELL(ICC)%IJK(IAXIS:KAXIS)

   DO JCC=1,NCELL
      ! Loop faces and test:
      DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)

         IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)

         ! If face type in face_list is not IBM_FTYPE_RGGAS, drop:
         IF(CUT_CELL(ICC)%FACE_LIST(1,IFACE) /= IBM_FTYPE_RGGAS) CYCLE

         ! Which face?
         LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
         X1AXIS  = CUT_CELL(ICC)%FACE_LIST(3,IFACE)

         SELECT CASE(X1AXIS)
         CASE(IAXIS)
            X2AXIS = JAXIS
            X3AXIS = KAXIS
            ! location in I,J,K od x2,x2,x3 axes:
            XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS
         CASE(JAXIS)
            X2AXIS = KAXIS
            X3AXIS = IAXIS
            ! location in I,J,K od x2,x2,x3 axes:
            XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS
         CASE(KAXIS)
            X2AXIS = IAXIS
            X3AXIS = JAXIS
            ! location in I,J,K od x2,x2,x3 axes:
            XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS
         END SELECT

         IF_LOW_HIGH_H : IF (LOWHIGH == LOW_IND) THEN

            ! Face indexes:
            INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-FCELL, IJK(X2AXIS), IJK(X3AXIS) /)
            INFACE = INDXI1(XIAXIS)
            JNFACE = INDXI1(XJAXIS)
            KNFACE = INDXI1(XKAXIS)

            IF(IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS) /= 1) CYCLE ! This is to cycle external WALL CELLs of types other
                                                                ! than INTERPOLATED_BOUNDARY of PERIODIC_BOUNDARY.

            ! Location of next Cartesian cell:
            INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-1, IJK(X2AXIS), IJK(X3AXIS) /)
            INCELL = INDXI1(XIAXIS)
            JNCELL = INDXI1(XJAXIS)
            KNCELL = INDXI1(XKAXIS)

            IF ( .NOT.PRES_ON_CARTESIAN ) THEN ! Unstructured pressure Poisson matrix build,
                                               ! use cut-cell vols:
               IF ( MESHES(NM)%CCVAR(INCELL,JNCELL,KNCELL,IBM_UNKH) > 0 ) THEN

                  ! Add face to IBM_RCFACE_H data structure:
                  IRC = IRC + 1
                  MESHES(NM)%IBM_RCFACE_H(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)

                  ! Can compute Area and centroid location of reg
                  ! face when building matrix.

                  ! Add all info required for matrix build:
                  ! Cell at i-1, i.e. regular GASPHASE:
                  MESHES(NM)%IBM_RCFACE_H(IRC)%UNK(LOW_IND) = MESHES(NM)%CCVAR(INCELL,JNCELL,KNCELL,IBM_UNKH)
                  MESHES(NM)%IBM_RCFACE_H(IRC)%XCEN(IAXIS:KAXIS,LOW_IND) = &
                      (/ XCELL(INCELL), YCELL(JNCELL), ZCELL(KNCELL) /)

                  ! Cell at i+1, i.e. cut-cell:
                  MESHES(NM)%IBM_RCFACE_H(IRC)%UNK(HIGH_IND) = CUT_CELL(ICC)%UNKH(JCC)
                  MESHES(NM)%IBM_RCFACE_H(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND) = &
                      CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)

               ELSEIF ( MESHES(NM)%CCVAR(INCELL,JNCELL,KNCELL,IBM_CGSC) == IBM_CUTCFE ) THEN ! Cut-cell.

                  ! Test that Cut-cell to Cut-cell reg face hasn't been added before:
                  INLIST = .FALSE.
                  DO IIFC=1,IRC
                     IF ( MESHES(NM)%IBM_RCFACE_H(IIFC)%IJK(IAXIS)   /= INFACE ) CYCLE
                     IF ( MESHES(NM)%IBM_RCFACE_H(IIFC)%IJK(JAXIS)   /= JNFACE ) CYCLE
                     IF ( MESHES(NM)%IBM_RCFACE_H(IIFC)%IJK(KAXIS)   /= KNFACE ) CYCLE
                     IF ( MESHES(NM)%IBM_RCFACE_H(IIFC)%IJK(KAXIS+1) /= X1AXIS ) CYCLE
                     INLIST = .TRUE.
                     EXIT
                  ENDDO
                  IF (INLIST) THEN
                     ! Cell at i+1, i.e. cut-cell:
                     MESHES(NM)%IBM_RCFACE_H(IIFC)%UNK(HIGH_IND) = CUT_CELL(ICC)%UNKH(JCC)
                     MESHES(NM)%IBM_RCFACE_H(IIFC)%XCEN(IAXIS:KAXIS,HIGH_IND) = &
                           CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)
                     CYCLE
                  ENDIF

                  ! Add face to IBM_RCFACE_H data structure:
                  IRC = IRC + 1
                  MESHES(NM)%IBM_RCFACE_H(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)

                  ! Can compute Area and centroid location of reg
                  ! face when building matrix.

                  ! Add all info required for matrix build:
                  ! Cell at i+1, i.e. cut-cell:
                  MESHES(NM)%IBM_RCFACE_H(IRC)%UNK(HIGH_IND) = CUT_CELL(ICC)%UNKH(JCC)
                  MESHES(NM)%IBM_RCFACE_H(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND) = &
                      CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)

               ENDIF

            ELSE ! Unstructured build, use underlying cartesian cells:

               IF (MESHES(NM)%CCVAR(INCELL,JNCELL,KNCELL,IBM_UNKH) > 0 ) THEN ! Regular Gasphase

                  ! Add face to IBM_RCFACE_H data structure:
                  IRC = IRC + 1
                  MESHES(NM)%IBM_RCFACE_H(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)

                  ! Can compute Area and centroid location of reg
                  ! face when building matrix.

                  ! Add all info required for matrix build:
                  ! Cell at i-1, i.e. regular GASPHASE:
                  MESHES(NM)%IBM_RCFACE_H(IRC)%UNK(LOW_IND) = MESHES(NM)%CCVAR(INCELL,JNCELL,KNCELL,IBM_UNKH)
                  MESHES(NM)%IBM_RCFACE_H(IRC)%XCEN(IAXIS:KAXIS,LOW_IND) = &
                      (/ XCELL(INCELL), YCELL(JNCELL), ZCELL(KNCELL) /)

                  ! Cell at i+1, i.e. cut-cell:
                  MESHES(NM)%IBM_RCFACE_H(IRC)%UNK(HIGH_IND) = CUT_CELL(ICC)%UNKH(1)
                  MESHES(NM)%IBM_RCFACE_H(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND) = &
                      (/ XCELL(IJK(IAXIS)), YCELL(IJK(JAXIS)), ZCELL(IJK(KAXIS)) /)

               ELSEIF ( MESHES(NM)%CCVAR(INCELL,JNCELL,KNCELL,IBM_CGSC) == IBM_CUTCFE ) THEN ! Cut-cell.

                  ! Test that Cut-cell to Cut-cell reg face hasn't been added before:
                  INLIST = .FALSE.
                  DO IIFC=1,IRC
                     IF ( MESHES(NM)%IBM_RCFACE_H(IIFC)%IJK(IAXIS)   /= INFACE ) CYCLE
                     IF ( MESHES(NM)%IBM_RCFACE_H(IIFC)%IJK(JAXIS)   /= JNFACE ) CYCLE
                     IF ( MESHES(NM)%IBM_RCFACE_H(IIFC)%IJK(KAXIS)   /= KNFACE ) CYCLE
                     IF ( MESHES(NM)%IBM_RCFACE_H(IIFC)%IJK(KAXIS+1) /= X1AXIS ) CYCLE
                     INLIST = .TRUE.
                     EXIT
                  ENDDO
                  IF (INLIST) THEN
                     ! Cell at i+1, i.e. cut-cell:
                     MESHES(NM)%IBM_RCFACE_H(IIFC)%UNK(HIGH_IND) = CUT_CELL(ICC)%UNKH(1)
                     MESHES(NM)%IBM_RCFACE_H(IIFC)%XCEN(IAXIS:KAXIS,HIGH_IND) = &
                     (/ XCELL(IJK(IAXIS)), YCELL(IJK(JAXIS)), ZCELL(IJK(KAXIS)) /)
                     CYCLE
                  ENDIF

                  ! Add face to IBM_RCFACE_H data structure:
                  IRC = IRC + 1
                  MESHES(NM)%IBM_RCFACE_H(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)

                  ! Can compute Area and centroid location of reg
                  ! face when building matrix.

                  ! Add all info required for matrix build:
                  ! Cell at i+1, i.e. cut-cell:
                  MESHES(NM)%IBM_RCFACE_H(IRC)%UNK(HIGH_IND) = CUT_CELL(ICC)%UNKH(1)
                  MESHES(NM)%IBM_RCFACE_H(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND) = &
                      (/ XCELL(IJK(IAXIS)), YCELL(IJK(JAXIS)), ZCELL(IJK(KAXIS)) /)

               ENDIF
            ENDIF

         ELSE ! IF_LOW_HIGH_H : HIGH_IND

            ! Face indexes:
            INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-FCELL+1, IJK(X2AXIS), IJK(X3AXIS) /)
            INFACE = INDXI1(XIAXIS)
            JNFACE = INDXI1(XJAXIS)
            KNFACE = INDXI1(XKAXIS)

            IF(IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS) /= 1) CYCLE ! This is to cycle external WALL CELLs of types other
                                                                ! than INTERPOLATED_BOUNDARY of PERIODIC_BOUNDARY.

            ! Location of next Cartesian cell:
            INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)+1, IJK(X2AXIS), IJK(X3AXIS) /)
            INCELL = INDXI1(XIAXIS)
            JNCELL = INDXI1(XJAXIS)
            KNCELL = INDXI1(XKAXIS)

            IF ( .NOT.PRES_ON_CARTESIAN ) THEN ! Unstructured pressure Poisson matrix build,
                                               ! use cut-cell vols:

               IF ( MESHES(NM)%CCVAR(INCELL,JNCELL,KNCELL,IBM_UNKH) > 0 ) THEN

                  ! Add face to IBM_RCFACE_H data structure:
                  IRC = IRC + 1
                  MESHES(NM)%IBM_RCFACE_H(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)

                  ! Can compute Area and centroid location of reg
                  ! face when building matrix.

                  ! Add all info required for matrix build:
                  ! Cell at i-1, i.e. cut-cell:
                  MESHES(NM)%IBM_RCFACE_H(IRC)%UNK(LOW_IND) = CUT_CELL(ICC)%UNKH(JCC)
                  MESHES(NM)%IBM_RCFACE_H(IRC)%XCEN(IAXIS:KAXIS,LOW_IND) = &
                      CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)

                  ! Cell at i+1, i.e. regular GASPHASE:
                  MESHES(NM)%IBM_RCFACE_H(IRC)%UNK(HIGH_IND) = &
                  MESHES(NM)%CCVAR(INCELL,JNCELL,KNCELL,IBM_UNKH)
                  MESHES(NM)%IBM_RCFACE_H(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND) = &
                      (/ XCELL(INCELL), YCELL(JNCELL), ZCELL(KNCELL) /)

               ELSEIF ( MESHES(NM)%CCVAR(INCELL,JNCELL,KNCELL,IBM_CGSC) == IBM_CUTCFE ) THEN ! Cut-cell.

                  ! Test that Cut-cell to Cut-cell reg face hasn't been added before:
                  INLIST = .FALSE.
                  DO IIFC=1,IRC
                     IF ( MESHES(NM)%IBM_RCFACE_H(IIFC)%IJK(IAXIS)   /= INFACE ) CYCLE
                     IF ( MESHES(NM)%IBM_RCFACE_H(IIFC)%IJK(JAXIS)   /= JNFACE ) CYCLE
                     IF ( MESHES(NM)%IBM_RCFACE_H(IIFC)%IJK(KAXIS)   /= KNFACE ) CYCLE
                     IF ( MESHES(NM)%IBM_RCFACE_H(IIFC)%IJK(KAXIS+1) /= X1AXIS ) CYCLE
                     INLIST = .TRUE.
                     EXIT
                  ENDDO
                  IF (INLIST) THEN
                     ! Cell at i-1, i.e. cut-cell:
                     MESHES(NM)%IBM_RCFACE_H(IIFC)%UNK(LOW_IND) = CUT_CELL(ICC)%UNKH(JCC)
                     MESHES(NM)%IBM_RCFACE_H(IIFC)%XCEN(IAXIS:KAXIS,LOW_IND) = &
                     CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)
                     CYCLE
                  ENDIF

                  ! Add face to REGC_FACE_H  data structure:
                  IRC = IRC + 1
                  MESHES(NM)%IBM_RCFACE_H(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)

                  ! Can compute Area and centroid location of reg
                  ! face when building matrix.

                  ! Add all info required for matrix build:
                  ! Cell at i-1, i.e. cut-cell:
                  MESHES(NM)%IBM_RCFACE_H(IRC)%UNK(LOW_IND) = CUT_CELL(ICC)%UNKH(JCC)
                  MESHES(NM)%IBM_RCFACE_H(IRC)%XCEN(IAXIS:KAXIS,LOW_IND) = &
                      CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)

               ENDIF

            ELSE ! Unstructured build, use underlying cartesian cells:

               IF ( MESHES(NM)%CCVAR(INCELL,JNCELL,KNCELL,IBM_UNKH) > 0 ) THEN ! Regular Gasphase

                  ! Add face to REGC_FACE_H  data structure:
                  IRC = IRC + 1
                  MESHES(NM)%IBM_RCFACE_H(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)

                  ! Can compute Area and centroid location of reg
                  ! face when building matrix.

                  ! Add all info required for matrix build:
                  ! Cell at i-1, i.e. cut-cell:
                  MESHES(NM)%IBM_RCFACE_H(IRC)%UNK(LOW_IND) = CUT_CELL(ICC)%UNKH(1)
                  MESHES(NM)%IBM_RCFACE_H(IRC)%XCEN(IAXIS:KAXIS,LOW_IND) = &
                      (/ XCELL(IJK(IAXIS)), YCELL(IJK(JAXIS)), ZCELL(IJK(KAXIS)) /)

                  ! Cell at i+1, i.e. regular GASPHASE:
                  MESHES(NM)%IBM_RCFACE_H(IRC)%UNK(HIGH_IND) = &
                  MESHES(NM)%CCVAR(INCELL,JNCELL,KNCELL,IBM_UNKH)
                  MESHES(NM)%IBM_RCFACE_H(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND) = &
                      (/ XCELL(INCELL), YCELL(JNCELL), ZCELL(KNCELL) /)

               ELSEIF ( MESHES(NM)%CCVAR(INCELL,JNCELL,KNCELL,IBM_CGSC) == IBM_CUTCFE ) THEN ! Cut-cell.

                  ! Test that Cut-cell to Cut-cell reg face hasn't been added before:
                  INLIST = .FALSE.
                  DO IIFC=1,IRC
                     IF ( MESHES(NM)%IBM_RCFACE_H(IIFC)%IJK(IAXIS)   /= INFACE ) CYCLE
                     IF ( MESHES(NM)%IBM_RCFACE_H(IIFC)%IJK(JAXIS)   /= JNFACE ) CYCLE
                     IF ( MESHES(NM)%IBM_RCFACE_H(IIFC)%IJK(KAXIS)   /= KNFACE ) CYCLE
                     IF ( MESHES(NM)%IBM_RCFACE_H(IIFC)%IJK(KAXIS+1) /= X1AXIS ) CYCLE
                     INLIST = .TRUE.
                     EXIT
                  ENDDO
                  IF (INLIST) THEN
                     ! Cell at i-1, i.e. cut-cell:
                     MESHES(NM)%IBM_RCFACE_H(IIFC)%UNK(LOW_IND) = CUT_CELL(ICC)%UNKH(1)
                     MESHES(NM)%IBM_RCFACE_H(IIFC)%XCEN(IAXIS:KAXIS,LOW_IND) = &
                     (/ XCELL(IJK(IAXIS)), YCELL(IJK(JAXIS)), ZCELL(IJK(KAXIS)) /)
                     CYCLE
                  ENDIF

                  ! Add face to REGC_FACE_H  data structure:
                  IRC = IRC + 1
                  MESHES(NM)%IBM_RCFACE_H(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)

                  ! Can compute Area and centroid location of reg
                  ! face when building matrix.

                  ! Add all info required for matrix build:
                  ! Cell at i-1, i.e. cut-cell:
                  MESHES(NM)%IBM_RCFACE_H(IRC)%UNK(LOW_IND) = CUT_CELL(ICC)%UNKH(1)
                  MESHES(NM)%IBM_RCFACE_H(IRC)%XCEN(IAXIS:KAXIS,LOW_IND) = &
                      (/ XCELL(IJK(IAXIS)), YCELL(IJK(JAXIS)), ZCELL(IJK(KAXIS)) /)

               ENDIF
            ENDIF ! .NOT.PRES_ON_CARTESIAN

         ENDIF IF_LOW_HIGH_H

      ENDDO
   ENDDO
ENDDO

GUARD_CUT_CELL_LOOP_2 :  DO IW=1,N_EXTERNAL_WALL_CELLS
   WC=>WALL(IW)
   IF (.NOT.(WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY .OR. WC%BOUNDARY_TYPE==PERIODIC_BOUNDARY)) &
   CYCLE GUARD_CUT_CELL_LOOP_2

   II  = WC%ONE_D%II
   JJ  = WC%ONE_D%JJ
   KK  = WC%ONE_D%KK
   IOR = WC%ONE_D%IOR

   ! Which face:
   X1AXIS=ABS(IOR)
   SELECT CASE(IOR)
   CASE( IAXIS)
      IIF=II  ; JJF=JJ  ; KKF=KK
      LOWHIGH_TEST=HIGH_IND ! Face on high side of Guard-Cell
   CASE(-IAXIS)
      IIF=II-1; JJF=JJ  ; KKF=KK
      LOWHIGH_TEST=LOW_IND
   CASE( JAXIS)
      IIF=II  ; JJF=JJ  ; KKF=KK
      LOWHIGH_TEST=HIGH_IND
   CASE(-JAXIS)
      IIF=II  ; JJF=JJ-1; KKF=KK
      LOWHIGH_TEST=LOW_IND
   CASE( KAXIS)
      IIF=II  ; JJF=JJ  ; KKF=KK
      LOWHIGH_TEST=HIGH_IND
   CASE(-KAXIS)
      IIF=II  ; JJF=JJ  ; KKF=KK-1
      LOWHIGH_TEST=LOW_IND
   END SELECT

   ! Drop if FACE is not type IBM_GASPHASE
   IF (FCVAR(IIF,JJF,KKF,IBM_FGSC,X1AXIS) /= IBM_GASPHASE) CYCLE GUARD_CUT_CELL_LOOP_2

   IIG  = WC%ONE_D%IIG
   JJG  = WC%ONE_D%JJG
   KKG  = WC%ONE_D%KKG

   ! Is this an actual RCFACE_H laying on the mesh boundary, where the cut-cell is in the guard-cell region?
   FLGIN = (CCVAR(II,JJ,KK,IBM_CGSC)==IBM_CUTCFE) .AND. (CCVAR(IIG,JJG,KKG,IBM_UNKH) > 0)

   IF(.NOT.FLGIN) CYCLE GUARD_CUT_CELL_LOOP_2

   ICC=CCVAR(II,JJ,KK,IBM_IDCC)
   DO JCC=1,CUT_CELL(ICC)%NCELL
      ! Loop faces and test:
      DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
         IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
         ! Which face ?
         LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
         IF ( CUT_CELL(ICC)%FACE_LIST(1,IFACE) /= IBM_FTYPE_RGGAS) CYCLE ! Must Be gasphase cut-face
         IF ( LOWHIGH                              /= LOWHIGH_TEST) CYCLE ! In same side as EWC from guard-cell
         IF ( CUT_CELL(ICC)%FACE_LIST(3,IFACE) /= X1AXIS) CYCLE ! Normal to same axis as EWC

          ! If so, we need to add it to the IBM_RCFACE_H list:
         IF (LOWHIGH == LOW_IND) THEN ! Face on low side of guard cut-cell

            IF ( .NOT.PRES_ON_CARTESIAN ) THEN ! Unstructured pressure Poisson matrix build,
                                               ! use cut-cell vols:
               ! Work deferred.

            ELSE ! Solve Poisson on underlying unstructured Cartesian mesh.

               ! Add face to IBM_RCFACE_H data structure:
               IRC = IRC + 1
               MESHES(NM)%IBM_RCFACE_H(IRC)%IJK(IAXIS:KAXIS+1) = (/ IIF, JJF, KKF, X1AXIS/)

               ! Add all info required for matrix build:
               ! Cell at i-1, i.e. regular GASPHASE:
               MESHES(NM)%IBM_RCFACE_H(IRC)%UNK(LOW_IND) = CCVAR(IIG,JJG,KKG,IBM_UNKH)
               MESHES(NM)%IBM_RCFACE_H(IRC)%XCEN(IAXIS:KAXIS,LOW_IND) = &
               (/ XCELL(IIG), YCELL(JJG), ZCELL(KKG) /)

               ! Cell at i+1, i.e. cut-cell:
               MESHES(NM)%IBM_RCFACE_H(IRC)%UNK(HIGH_IND) = CUT_CELL(ICC)%UNKH(1)
               MESHES(NM)%IBM_RCFACE_H(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND) = &
               (/ XCELL(II), YCELL(JJ), ZCELL(KK) /)

            ENDIF

         ELSEIF(LOWHIGH == HIGH_IND) THEN ! Face on high side of guard cut-cell

            IF ( .NOT.PRES_ON_CARTESIAN ) THEN ! Unstructured pressure Poisson matrix build,
                                               ! use cut-cell vols:
               ! Work deferred.

            ELSE ! Solve Poisson on underlying unstructured Cartesian mesh.

               ! Add face to IBM_RCFACE_H data structure:
               IRC = IRC + 1
               MESHES(NM)%IBM_RCFACE_H(IRC)%IJK(IAXIS:KAXIS+1) = (/ IIF, JJF, KKF, X1AXIS/)

               ! Add all info required for matrix build:
               ! Cell at i-1, i.e. cut-cell:
               MESHES(NM)%IBM_RCFACE_H(IRC)%UNK(LOW_IND) = CUT_CELL(ICC)%UNKH(1)
               MESHES(NM)%IBM_RCFACE_H(IRC)%XCEN(IAXIS:KAXIS,LOW_IND) = &
               (/ XCELL(II), YCELL(JJ), ZCELL(KK) /)

               ! Cell at i+1, i.e. regular GASPHASE:
               MESHES(NM)%IBM_RCFACE_H(IRC)%UNK(HIGH_IND) = CCVAR(IIG,JJG,KKG,IBM_UNKH)
               MESHES(NM)%IBM_RCFACE_H(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND) = &
               (/ XCELL(IIG), YCELL(JJG), ZCELL(KKG) /)
            ENDIF

         ENDIF
         ! At this point the face has been found, cycle:
         CYCLE GUARD_CUT_CELL_LOOP_2
      ENDDO
   ENDDO

ENDDO GUARD_CUT_CELL_LOOP_2

DEALLOCATE(XCELL,YCELL,ZCELL)
DEALLOCATE(IJKFACE)

RETURN
END SUBROUTINE GET_RCFACES_H

! ---------------------- GET_GASPHASE_REGFACES_DATA -----------------------------

SUBROUTINE GET_GASPHASE_REGFACES_DATA

#if defined(DEBUG_MATVEC_DATA) && defined(MPI_ENABLED)
USE MPI
#endif

! Local variables:
INTEGER :: NM
INTEGER :: ILO,IHI,JLO,JHI,KLO,KHI
INTEGER :: I,J,K,II,IREG,IRC,IIFC,X1AXIS,X2AXIS,X3AXIS
INTEGER, ALLOCATABLE, DIMENSION(:,:) :: IJKBUFFER
INTEGER, ALLOCATABLE, DIMENSION(:,:,:,:,:) :: IJKFACE
INTEGER :: NCELL,ICC,JCC,IJK(MAX_DIM),IFC,IFACE,LOWHIGH
INTEGER :: XIAXIS,XJAXIS,XKAXIS,INDXI1(MAX_DIM),INCELL,JNCELL,KNCELL,INFACE,JNFACE,KNFACE
INTEGER :: ISTR, IEND, JSTR, JEND, KSTR, KEND
LOGICAL :: INLIST

INTEGER :: IW,JJ,KK,IIF,JJF,KKF,IOR,LOWHIGH_TEST,IIG,JJG,KKG
INTEGER :: IBNDINT,IC
TYPE (WALL_TYPE), POINTER :: WC

LOGICAL :: FLGIN

INTEGER, PARAMETER :: OZPOS=0, ICPOS=1, JCPOS=2, IFPOS=3

#if defined(DEBUG_MATVEC_DATA) && defined(MPI_ENABLED)
INTEGER :: IERR
#endif

! Mesh loop:
MAIN_MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! Mesh sizes:
   NXB=IBAR
   NYB=JBAR
   NZB=KBAR

   ! X direction bounds:
   ILO_FACE = 0                    ! Low mesh boundary face index.
   IHI_FACE = IBAR                 ! High mesh boundary face index.
   ILO_CELL = ILO_FACE + FCELL     ! First internal cell index. See notes.
   IHI_CELL = IHI_FACE + FCELL - 1 ! Last internal cell index.
   ISTR     = ILO_FACE - NGUARD    ! Allocation start x arrays.
   IEND     = IHI_FACE + NGUARD    ! Allocation end x arrays.


   ! Y direction bounds:
   JLO_FACE = 0                    ! Low mesh boundary face index.
   JHI_FACE = JBAR                 ! High mesh boundary face index.
   JLO_CELL = JLO_FACE + FCELL     ! First internal cell index. See notes.
   JHI_CELL = JHI_FACE + FCELL - 1 ! Last internal cell index.
   JSTR     = JLO_FACE - NGUARD    ! Allocation start y arrays.
   JEND     = JHI_FACE + NGUARD    ! Allocation end y arrays.

   ! Z direction bounds:
   KLO_FACE = 0                    ! Low mesh boundary face index.
   KHI_FACE = KBAR                 ! High mesh boundary face index.
   KLO_CELL = KLO_FACE + FCELL     ! First internal cell index. See notes.
   KHI_CELL = KHI_FACE + FCELL - 1 ! Last internal cell index.
   KSTR     = KLO_FACE - NGUARD    ! Allocation start z arrays.
   KEND     = KHI_FACE + NGUARD    ! Allocation end z arrays.

   ! Define grid arrays for this mesh:
   ! Populate position and cell size arrays: Uniform grid implementation.
   ! X direction:
   ALLOCATE(XCELL(ISTR:IEND));  XCELL = 1._EB/GEOMEPS ! Initialize huge.
   XCELL(ILO_CELL-1:IHI_CELL+1) = MESHES(NM)%XC(ILO_CELL-1:IHI_CELL+1)

   ! Y direction:
   ALLOCATE(YCELL(JSTR:JEND));  YCELL = 1._EB/GEOMEPS ! Initialize huge.
   YCELL(JLO_CELL-1:JHI_CELL+1) = MESHES(NM)%YC(JLO_CELL-1:JHI_CELL+1)

   ! Z direction:
   ALLOCATE(ZCELL(KSTR:KEND));  ZCELL = 1._EB/GEOMEPS ! Initialize huge.
   ZCELL(KLO_CELL-1:KHI_CELL+1) = MESHES(NM)%ZC(KLO_CELL-1:KHI_CELL+1)

   ! Set starting number of regular faces for NM to zero:
   MESHES(NM)%IBM_NREGFACE_Z(IAXIS:KAXIS) = 0

   ! 1. Regular GASPHASE faces connected to Gasphase cells:
   ALLOCATE(IJKBUFFER(IAXIS:KAXIS+1,1:(NXB+1)*(NYB+1)*(NZB+1)))

   ! First Scalars:
   ! axis = IAXIS:
   X1AXIS = IAXIS
   IJKBUFFER(:,:)=0; IREG = 0
   ! First Reg Faces in mesh block boundaries, then inside mesh. Count for allocation:
   IBNDINT_LOOP_X : DO IBNDINT=1,3
      IF(IBNDINT==3) MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)=IREG ! REG faces in block boundaries.
      SELECT CASE(IBNDINT)
      CASE(1)
         ILO = ILO_FACE; IHI = ILO_FACE
         JLO = JLO_CELL; JHI = JHI_CELL
         KLO = KLO_CELL; KHI = KHI_CELL
         DO K=KLO,KHI
            DO J=JLO,JHI
               DO I=ILO,IHI
                  IF (CCVAR(I+FCELL-1,J,K,IBM_UNKZ) <= 0) CYCLE
                  IF (CCVAR(I+FCELL  ,J,K,IBM_UNKZ) <= 0) CYCLE
                  IREG = IREG + 1
                  IC   = CELL_INDEX(I+FCELL  ,J,K)
                  IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, WALL_INDEX(IC,-X1AXIS) /) ! Face on low side of cell.
               ENDDO
            ENDDO
         ENDDO
      CASE(2)
         ILO = IHI_FACE; IHI = IHI_FACE
         JLO = JLO_CELL; JHI = JHI_CELL
         KLO = KLO_CELL; KHI = KHI_CELL
         DO K=KLO,KHI
            DO J=JLO,JHI
               DO I=ILO,IHI
                  IF (CCVAR(I+FCELL-1,J,K,IBM_UNKZ) <= 0) CYCLE
                  IF (CCVAR(I+FCELL  ,J,K,IBM_UNKZ) <= 0) CYCLE
                  IREG = IREG + 1
                  IC = CELL_INDEX(I+FCELL-1,J,K)
                  IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, WALL_INDEX(IC, X1AXIS) /) ! Face on high side of cell.
               ENDDO
            ENDDO
         ENDDO
      CASE(3)
         ILO = ILO_FACE+1; IHI = IHI_FACE-1
         JLO = JLO_CELL;   JHI = JHI_CELL
         KLO = KLO_CELL;   KHI = KHI_CELL
         DO K=KLO,KHI
            DO J=JLO,JHI
               DO I=ILO,IHI
                  IF (CCVAR(I+FCELL-1,J,K,IBM_UNKZ) <= 0) CYCLE
                  IF (CCVAR(I+FCELL  ,J,K,IBM_UNKZ) <= 0) CYCLE
                  IREG = IREG + 1
                  IJKBUFFER(IAXIS:KAXIS,IREG) = (/ I, J, K /)
               ENDDO
            ENDDO
         ENDDO
      END SELECT
   ENDDO IBNDINT_LOOP_X
   MESHES(NM)%IBM_NREGFACE_Z(X1AXIS) = IREG
   IF(ALLOCATED(MESHES(NM)%IBM_REGFACE_IAXIS_Z)) DEALLOCATE(MESHES(NM)%IBM_REGFACE_IAXIS_Z)
   ALLOCATE(MESHES(NM)%IBM_REGFACE_IAXIS_Z(IREG))
   DO II=1,IREG
      MESHES(NM)%IBM_REGFACE_IAXIS_Z(II)%IJK(IAXIS:KAXIS) = IJKBUFFER(IAXIS:KAXIS,II)
      MESHES(NM)%IBM_REGFACE_IAXIS_Z(II)%IWC = IJKBUFFER(KAXIS+1,II)
   ENDDO

   ! axis = JAXIS:
   X1AXIS = JAXIS
   IJKBUFFER(:,:)=0; IREG = 0
   ! First Reg Faces in mesh block boundaries, then inside mesh. Count for allocation:
   IBNDINT_LOOP_Y : DO IBNDINT=1,3
      IF(IBNDINT==3) MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)=IREG ! REG faces in block boundaries.
      SELECT CASE(IBNDINT)
      CASE(1)
         ILO = ILO_CELL; IHI = IHI_CELL
         JLO = JLO_FACE; JHI = JLO_FACE
         KLO = KLO_CELL; KHI = KHI_CELL
         DO K=KLO,KHI
            DO J=JLO,JHI
               DO I=ILO,IHI
                  IF (CCVAR(I,J+FCELL-1,K,IBM_UNKZ) <= 0) CYCLE
                  IF (CCVAR(I,J+FCELL  ,K,IBM_UNKZ) <= 0) CYCLE
                  IREG = IREG + 1
                  IC   = CELL_INDEX(I,J+FCELL  ,K)
                  IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, WALL_INDEX(IC,-X1AXIS) /) ! Face on low side of cell.
               ENDDO
            ENDDO
         ENDDO
      CASE(2)
         ILO = ILO_CELL; IHI = IHI_CELL
         JLO = JHI_FACE; JHI = JHI_FACE
         KLO = KLO_CELL; KHI = KHI_CELL
         DO K=KLO,KHI
            DO J=JLO,JHI
               DO I=ILO,IHI
                  IF (CCVAR(I,J+FCELL-1,K,IBM_UNKZ) <= 0) CYCLE
                  IF (CCVAR(I,J+FCELL  ,K,IBM_UNKZ) <= 0) CYCLE
                  IREG = IREG + 1
                  IC   = CELL_INDEX(I,J+FCELL-1,K)
                  IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, WALL_INDEX(IC, X1AXIS) /) ! Face on high side of cell.
               ENDDO
            ENDDO
         ENDDO
      CASE(3)
         ILO = ILO_CELL;   IHI = IHI_CELL
         JLO = JLO_FACE+1; JHI = JHI_FACE-1
         KLO = KLO_CELL;   KHI = KHI_CELL
         DO K=KLO,KHI
            DO J=JLO,JHI
               DO I=ILO,IHI
                  IF (CCVAR(I,J+FCELL-1,K,IBM_UNKZ) <= 0) CYCLE
                  IF (CCVAR(I,J+FCELL  ,K,IBM_UNKZ) <= 0) CYCLE
                  IREG = IREG + 1
                  IJKBUFFER(IAXIS:KAXIS,IREG) = (/ I, J, K /)
               ENDDO
            ENDDO
         ENDDO
      END SELECT
   ENDDO IBNDINT_LOOP_Y
   MESHES(NM)%IBM_NREGFACE_Z(X1AXIS) = IREG
   IF(ALLOCATED(MESHES(NM)%IBM_REGFACE_JAXIS_Z)) DEALLOCATE(MESHES(NM)%IBM_REGFACE_JAXIS_Z)
   ALLOCATE(MESHES(NM)%IBM_REGFACE_JAXIS_Z(IREG))
   DO II=1,IREG
      MESHES(NM)%IBM_REGFACE_JAXIS_Z(II)%IJK(IAXIS:KAXIS) = IJKBUFFER(IAXIS:KAXIS,II)
      MESHES(NM)%IBM_REGFACE_JAXIS_Z(II)%IWC = IJKBUFFER(KAXIS+1,II)
   ENDDO

   ! axis = KAXIS:
   X1AXIS = KAXIS
   IJKBUFFER(:,:)=0; IREG = 0
   ! First Reg Faces in mesh block boundaries, then inside mesh.
   IBNDINT_LOOP_Z : DO IBNDINT=1,3
      IF(IBNDINT==3) MESHES(NM)%IBM_NBBREGFACE_Z(X1AXIS)=IREG ! REG faces in block boundaries.
      SELECT CASE(IBNDINT)
      CASE(1)
         ILO = ILO_CELL; IHI = IHI_CELL
         JLO = JLO_CELL; JHI = JHI_CELL
         KLO = KLO_FACE; KHI = KLO_FACE
         DO K=KLO,KHI
            DO J=JLO,JHI
               DO I=ILO,IHI
                  IF (CCVAR(I,J,K+FCELL-1,IBM_UNKZ) <= 0) CYCLE
                  IF (CCVAR(I,J,K+FCELL  ,IBM_UNKZ) <= 0) CYCLE
                  IREG = IREG + 1
                  IC   = CELL_INDEX(I,J,K+FCELL  )
                  IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, WALL_INDEX(IC,-X1AXIS) /)  ! Face on low side of cell.
               ENDDO
            ENDDO
         ENDDO
      CASE(2)
         ILO = ILO_CELL; IHI = IHI_CELL
         JLO = JLO_CELL; JHI = JHI_CELL
         KLO = KHI_FACE; KHI = KHI_FACE
         DO K=KLO,KHI
            DO J=JLO,JHI
               DO I=ILO,IHI
                  IF (CCVAR(I,J,K+FCELL-1,IBM_UNKZ) <= 0) CYCLE
                  IF (CCVAR(I,J,K+FCELL  ,IBM_UNKZ) <= 0) CYCLE
                  IREG = IREG + 1
                  IC   = CELL_INDEX(I,J,K+FCELL-1)
                  IJKBUFFER(IAXIS:KAXIS+1,IREG) = (/ I, J, K, WALL_INDEX(IC, X1AXIS) /)  ! Face on high side of cell.
               ENDDO
            ENDDO
         ENDDO
      CASE(3)
         ILO = ILO_CELL;   IHI = IHI_CELL
         JLO = JLO_CELL;   JHI = JHI_CELL
         KLO = KLO_FACE+1; KHI = KHI_FACE-1
         DO K=KLO,KHI
            DO J=JLO,JHI
               DO I=ILO,IHI
                  IF (CCVAR(I,J,K+FCELL-1,IBM_UNKZ) <= 0) CYCLE
                  IF (CCVAR(I,J,K+FCELL  ,IBM_UNKZ) <= 0) CYCLE
                  IREG = IREG + 1
                  IJKBUFFER(IAXIS:KAXIS,IREG) = (/ I, J, K /)
               ENDDO
            ENDDO
         ENDDO
      END SELECT
   ENDDO IBNDINT_LOOP_Z
   MESHES(NM)%IBM_NREGFACE_Z(X1AXIS) = IREG
   IF(ALLOCATED(MESHES(NM)%IBM_REGFACE_KAXIS_Z)) DEALLOCATE(MESHES(NM)%IBM_REGFACE_KAXIS_Z)
   ALLOCATE(MESHES(NM)%IBM_REGFACE_KAXIS_Z(IREG))
   DO II=1,IREG
      MESHES(NM)%IBM_REGFACE_KAXIS_Z(II)%IJK(IAXIS:KAXIS) = IJKBUFFER(IAXIS:KAXIS,II)
      MESHES(NM)%IBM_REGFACE_KAXIS_Z(II)%IWC = IJKBUFFER(KAXIS+1,II)
   ENDDO

   ! 2. Lists of Regular Gasphase faces, connected to one regular gasphase and
   ! one cut-cell:
   ! First count for allocation:
   ALLOCATE( IJKFACE(ILO_FACE:IHI_FACE,JLO_FACE:JHI_FACE,KLO_FACE:KHI_FACE,IAXIS:KAXIS,OZPOS:IFPOS) )
   IJKFACE(:,:,:,:,:) = 0
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      NCELL = CUT_CELL(ICC)%NCELL
      IJK(IAXIS:KAXIS) = CUT_CELL(ICC)%IJK(IAXIS:KAXIS)
      DO JCC=1,NCELL
         ! Loop faces and test:
         DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
            IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
            ! If face type in face_list is not IBM_FTYPE_RGGAS, drop:
            IF(CUT_CELL(ICC)%FACE_LIST(1,IFACE) /= IBM_FTYPE_RGGAS) CYCLE
            ! Which face?
            LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
            X1AXIS  = CUT_CELL(ICC)%FACE_LIST(3,IFACE)
            SELECT CASE(X1AXIS)
            CASE(IAXIS)
               X2AXIS = JAXIS; X3AXIS = KAXIS
               ! location in I,J,K od x2,x2,x3 axes:
               XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS
            CASE(JAXIS)
               X2AXIS = KAXIS; X3AXIS = IAXIS
               ! location in I,J,K od x2,x2,x3 axes:
               XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS
            CASE(KAXIS)
               X2AXIS = IAXIS; X3AXIS = JAXIS
               ! location in I,J,K od x2,x2,x3 axes:
               XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS
            END SELECT

            ! Face indexes:
            INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-FCELL+(LOWHIGH-1), IJK(X2AXIS), IJK(X3AXIS) /)
            INFACE = INDXI1(XIAXIS)
            JNFACE = INDXI1(XJAXIS)
            KNFACE = INDXI1(XKAXIS)

            IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,OZPOS) = 1
            IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,ICPOS) = ICC
            IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,JCPOS) = JCC
            IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,IFPOS) = IFACE

         ENDDO
      ENDDO
   ENDDO

   ! Check for RCFACE_Z on the boundary of the domain, where the cut-cell is in the guard-cell region.
   ! Now Apply external wall cell loop for guard-cell cut cells:
   GUARD_CUT_CELL_LOOP_1A :  DO IW=1,N_EXTERNAL_WALL_CELLS
      WC=>WALL(IW)

      II  = WC%ONE_D%II
      JJ  = WC%ONE_D%JJ
      KK  = WC%ONE_D%KK
      IOR = WC%ONE_D%IOR

      ! Which face:
      X1AXIS=ABS(IOR)
      SELECT CASE(IOR)
      CASE( IAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=HIGH_IND ! Face on high side of Guard-Cell
      CASE(-IAXIS)
         IIF=II-1; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=LOW_IND
      CASE( JAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=HIGH_IND
      CASE(-JAXIS)
         IIF=II  ; JJF=JJ-1; KKF=KK
         LOWHIGH_TEST=LOW_IND
      CASE( KAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=HIGH_IND
      CASE(-KAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK-1
         LOWHIGH_TEST=LOW_IND
      END SELECT

      ! Drop if FACE is not type IBM_GASPHASE
      IF (FCVAR(IIF,JJF,KKF,IBM_FGSC,X1AXIS) /= IBM_GASPHASE) CYCLE GUARD_CUT_CELL_LOOP_1A

      IIG  = WC%ONE_D%IIG
      JJG  = WC%ONE_D%JJG
      KKG  = WC%ONE_D%KKG

      ! Is this an actual RCFACE laying on the mesh boundary, where the cut-cell is in the guard-cell region?
      FLGIN = (CCVAR(II,JJ,KK,IBM_CGSC)==IBM_CUTCFE) ! Note that this will overrride the Cut-cell to cut-cell case in
                                                     ! the block boundary, picked up in previous loop. Thats fine.

      IF(.NOT.FLGIN) CYCLE GUARD_CUT_CELL_LOOP_1A

      ICC=CCVAR(II,JJ,KK,IBM_IDCC)
      DO JCC=1,CUT_CELL(ICC)%NCELL
         ! Loop faces and test:
         DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)
            IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
            ! Which face ?
            LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
            IF ( CUT_CELL(ICC)%FACE_LIST(1,IFACE) /= IBM_FTYPE_RGGAS) CYCLE ! Must Be gasphase cut-face
            IF ( LOWHIGH                             /= LOWHIGH_TEST) CYCLE ! In same side as EWC from guard-cell
            IF ( CUT_CELL(ICC)%FACE_LIST(3,IFACE) /= X1AXIS) CYCLE ! Normal to same axis as EWC

            IJKFACE(IIF,JJF,KKF,X1AXIS,OZPOS) = 1
            IJKFACE(IIF,JJF,KKF,X1AXIS,ICPOS) = ICC
            IJKFACE(IIF,JJF,KKF,X1AXIS,JCPOS) = JCC
            IJKFACE(IIF,JJF,KKF,X1AXIS,IFPOS) = IFACE

            CYCLE GUARD_CUT_CELL_LOOP_1A
         ENDDO
      ENDDO

   ENDDO GUARD_CUT_CELL_LOOP_1A

   IRC = SUM(IJKFACE(:,:,:,:,OZPOS))
   IF (IRC == 0) THEN
      DEALLOCATE(XCELL,YCELL,ZCELL)
      DEALLOCATE(IJKBUFFER,IJKFACE)
      CYCLE
   ENDIF

   ! Now actual computation for Scalars:
   ALLOCATE( MESHES(NM)%IBM_RCFACE_Z(IRC) )
   IRC = 0
   ! Start with external wall cells:
   GUARD_CUT_CELL_LOOP_1B :  DO IW=1,N_EXTERNAL_WALL_CELLS
      WC=>WALL(IW)
      II  = WC%ONE_D%II
      JJ  = WC%ONE_D%JJ
      KK  = WC%ONE_D%KK
      IOR = WC%ONE_D%IOR

      ! Which face:
      X1AXIS=ABS(IOR)
      SELECT CASE(IOR)
      CASE( IAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=HIGH_IND ! Face on high side of Guard-Cell
      CASE(-IAXIS)
         IIF=II-1; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=LOW_IND
      CASE( JAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=HIGH_IND
      CASE(-JAXIS)
         IIF=II  ; JJF=JJ-1; KKF=KK
         LOWHIGH_TEST=LOW_IND
      CASE( KAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK
         LOWHIGH_TEST=HIGH_IND
      CASE(-KAXIS)
         IIF=II  ; JJF=JJ  ; KKF=KK-1
         LOWHIGH_TEST=LOW_IND
      END SELECT

      IF(IJKFACE(IIF,JJF,KKF,X1AXIS,OZPOS) < 1) CYCLE GUARD_CUT_CELL_LOOP_1B ! Not an RCFACE_Z.

      ! None of the following defined RCFACES in block boundaries have been added to IBM_RCFACE_Z before:
      ICC = IJKFACE(IIF,JJF,KKF,X1AXIS,ICPOS)
      JCC = IJKFACE(IIF,JJF,KKF,X1AXIS,JCPOS)
      IFACE = IJKFACE(IIF,JJF,KKF,X1AXIS,IFPOS)
      IJK(IAXIS:KAXIS) = CUT_CELL(ICC)%IJK(IAXIS:KAXIS)
      ! Which face?
      LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)

      ! Add face to RC face:
      SELECT CASE(X1AXIS)
      CASE(IAXIS)
         X2AXIS = JAXIS
         X3AXIS = KAXIS
         ! location in I,J,K od x2,x2,x3 axes:
         XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS
      CASE(JAXIS)
         X2AXIS = KAXIS
         X3AXIS = IAXIS
         ! location in I,J,K od x2,x2,x3 axes:
         XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS
      CASE(KAXIS)
         X2AXIS = IAXIS
         X3AXIS = JAXIS
         ! location in I,J,K od x2,x2,x3 axes:
         XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS
      END SELECT

      IF_LOW_HIGH_1B : IF (LOWHIGH == LOW_IND) THEN

         ! Face indexes:
         INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-FCELL, IJK(X2AXIS), IJK(X3AXIS) /)
         INFACE = INDXI1(XIAXIS)
         JNFACE = INDXI1(XJAXIS)
         KNFACE = INDXI1(XKAXIS)

         ! Location of next Cartesian cell:
         INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-1, IJK(X2AXIS), IJK(X3AXIS) /)
         INCELL = INDXI1(XIAXIS)
         JNCELL = INDXI1(XJAXIS)
         KNCELL = INDXI1(XKAXIS)

         ! Scalar:
         IF (CCVAR(INCELL,JNCELL,KNCELL,IBM_CGSC) == IBM_GASPHASE ) THEN ! next cell is reg-cell:

            ! Set OZPOS to 2, to be used in next cycle:
            IJKFACE(IIF,JJF,KKF,X1AXIS,OZPOS) = 2
            ! Add face to IBM_RCFACE_Z data structure:
            IRC = IRC + 1
            MESHES(NM)%IBM_RCFACE_Z(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)
            MESHES(NM)%IBM_RCFACE_Z(IRC)%IWC = IW ! Locate WALL CELL for boundary MESHES(NM)%IBM_RCFACE_Z(IRC).

            ! Can compute Area and centroid location of reg
            ! face when building matrix.

            ! Add all info required for matrix build:
            ! Cell at i-1, i.e. regular GASPHASE:
            MESHES(NM)%IBM_RCFACE_Z(IRC)%UNK(LOW_IND) = CCVAR(INCELL,JNCELL,KNCELL,IBM_UNKZ)
            MESHES(NM)%IBM_RCFACE_Z(IRC)%XCEN(IAXIS:KAXIS,LOW_IND) = &
            (/ XCELL(INCELL), YCELL(JNCELL), ZCELL(KNCELL) /)
            MESHES(NM)%IBM_RCFACE_Z(IRC)%CELL_LIST(IAXIS:KAXIS+1,LOW_IND) = &
            (/ IBM_FTYPE_RGGAS, INCELL, JNCELL, KNCELL /)

            ! Cell at i+1, i.e. cut-cell:
            MESHES(NM)%IBM_RCFACE_Z(IRC)%UNK(HIGH_IND) = CUT_CELL(ICC)%UNKZ(JCC)
            MESHES(NM)%IBM_RCFACE_Z(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND) = &
            CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)
            MESHES(NM)%IBM_RCFACE_Z(IRC)%CELL_LIST(IAXIS:KAXIS+1,HIGH_IND) = &
            (/ IBM_FTYPE_CFGAS, ICC, JCC, IFC /)

         ELSEIF(CCVAR(INCELL,JNCELL,KNCELL,IBM_CGSC) == IBM_CUTCFE) THEN ! next cell is cc:

            ! Set OZPOS to 2, to be used in next cycle:
            IJKFACE(IIF,JJF,KKF,X1AXIS,OZPOS) = 2
            ! Add face to IBM_RCFACE_Z  data structure:
            IRC = IRC + 1
            MESHES(NM)%IBM_RCFACE_Z(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)
            MESHES(NM)%IBM_RCFACE_Z(IRC)%IWC = IW ! Locate WALL CELL for boundary MESHES(NM)%IBM_RCFACE_Z(IRC).

            ! Can compute Area and centroid location of reg
            ! face when building matrix.

            ! Add all info required for matrix build:
            ! Cell at i+1, i.e. cut-cell:
            MESHES(NM)%IBM_RCFACE_Z(IRC)%UNK(HIGH_IND) = CUT_CELL(ICC)%UNKZ(JCC)
            MESHES(NM)%IBM_RCFACE_Z(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND) = &
            CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)
            MESHES(NM)%IBM_RCFACE_Z(IRC)%CELL_LIST(IAXIS:KAXIS+1,HIGH_IND) = &
            (/ IBM_FTYPE_CFGAS, ICC, JCC, IFC /)

         ELSE
            WRITE(LU_ERR,*) 'MISSING BOUNDARY RCFACE',IIF,JJF,KKF,X1AXIS
         ENDIF

      ELSE ! IF_LOW_HIGH : HIGH_IND

         ! Face indexes:
         INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-FCELL+1, IJK(X2AXIS), IJK(X3AXIS) /)
         INFACE = INDXI1(XIAXIS)
         JNFACE = INDXI1(XJAXIS)
         KNFACE = INDXI1(XKAXIS)

         ! Location of next Cartesian cell:
         INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)+1, IJK(X2AXIS), IJK(X3AXIS) /)
         INCELL = INDXI1(XIAXIS)
         JNCELL = INDXI1(XJAXIS)
         KNCELL = INDXI1(XKAXIS)

         IF (CCVAR(INCELL,JNCELL,KNCELL,IBM_CGSC) == IBM_GASPHASE ) THEN

            ! Set OZPOS to 2, to be used in next cycle:
            IJKFACE(IIF,JJF,KKF,X1AXIS,OZPOS) = 2
            ! Add face to IBM_RCFACE_Z data structure:
            IRC = IRC + 1
            MESHES(NM)%IBM_RCFACE_Z(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)
            MESHES(NM)%IBM_RCFACE_Z(IRC)%IWC = IW ! Locate WALL CELL for boundary MESHES(NM)%IBM_RCFACE_Z(IRC).

            ! Can compute Area and centroid location of reg
            ! face when building matrix.

            ! Add all info required for matrix build:
            ! Cell at i-1, i.e. cut-cell:
            MESHES(NM)%IBM_RCFACE_Z(IRC)%UNK(LOW_IND) = CUT_CELL(ICC)%UNKZ(JCC)
            MESHES(NM)%IBM_RCFACE_Z(IRC)%XCEN(IAXIS:KAXIS,LOW_IND) = &
                 CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)
            MESHES(NM)%IBM_RCFACE_Z(IRC)%CELL_LIST(IAXIS:KAXIS+1,LOW_IND) = &
            (/ IBM_FTYPE_CFGAS, ICC, JCC, IFC /)

            ! Cell at i+1, i.e. regular GASPHASE:
            MESHES(NM)%IBM_RCFACE_Z(IRC)%UNK(HIGH_IND) = CCVAR(INCELL,JNCELL,KNCELL,IBM_UNKZ)
            MESHES(NM)%IBM_RCFACE_Z(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND) = &
                       (/ XCELL(INCELL), YCELL(JNCELL), ZCELL(KNCELL) /)
            MESHES(NM)%IBM_RCFACE_Z(IRC)%CELL_LIST(IAXIS:KAXIS+1,HIGH_IND) = &
            (/ IBM_FTYPE_RGGAS, INCELL, JNCELL, KNCELL /)

         ELSEIF(CCVAR(INCELL,JNCELL,KNCELL,IBM_CGSC) == IBM_CUTCFE) THEN ! next cell is cc:

            ! Set OZPOS to 2, to be used in next cycle:
            IJKFACE(IIF,JJF,KKF,X1AXIS,OZPOS) = 2
            ! Add face to IBM_RCFACE_Z data structure:
            IRC = IRC + 1
            MESHES(NM)%IBM_RCFACE_Z(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)
            MESHES(NM)%IBM_RCFACE_Z(IRC)%IWC = IW ! Locate WALL CELL for boundary MESHES(NM)%IBM_RCFACE_Z(IRC).

            ! Can compute Area and centroid location of reg
            ! face when building matrix.

            ! Add high cell info required for matrix build:
            ! Cell at i-1, i.e. cut-cell:
            MESHES(NM)%IBM_RCFACE_Z(IRC)%UNK(LOW_IND) = CUT_CELL(ICC)%UNKZ(JCC)
            MESHES(NM)%IBM_RCFACE_Z(IRC)%XCEN(IAXIS:KAXIS,LOW_IND) = &
                CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)
            MESHES(NM)%IBM_RCFACE_Z(IRC)%CELL_LIST(IAXIS:KAXIS+1,LOW_IND) = &
            (/ IBM_FTYPE_CFGAS, ICC, JCC, IFC /)

           ELSE
              WRITE(LU_ERR,*) 'MISSING BOUNDARY RCFACE',IIF,JJF,KKF,X1AXIS
         ENDIF
      ENDIF IF_LOW_HIGH_1B

   ENDDO GUARD_CUT_CELL_LOOP_1B

   ! Number of RC faces defined in block boundaries:
   MESHES(NM)%IBM_NBBRCFACE_Z = IRC

   ! Now run regular cut-cell loop to define internal RCFACES:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      NCELL = CUT_CELL(ICC)%NCELL
      IJK(IAXIS:KAXIS) = CUT_CELL(ICC)%IJK(IAXIS:KAXIS)

      DO JCC=1,NCELL
         ! Loop faces and test:
         IFC_LOOP : DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)

            IFACE = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)

            ! If face type in face_list is not IBM_FTYPE_RGGAS, drop:
            IF(CUT_CELL(ICC)%FACE_LIST(1,IFACE) /= IBM_FTYPE_RGGAS) CYCLE IFC_LOOP

            ! Which face?
            LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
            X1AXIS  = CUT_CELL(ICC)%FACE_LIST(3,IFACE)

            SELECT CASE(X1AXIS)
            CASE(IAXIS)
               X2AXIS = JAXIS
               X3AXIS = KAXIS
               ! location in I,J,K od x2,x2,x3 axes:
               XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS
            CASE(JAXIS)
               X2AXIS = KAXIS
               X3AXIS = IAXIS
               ! location in I,J,K od x2,x2,x3 axes:
               XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS
            CASE(KAXIS)
               X2AXIS = IAXIS
               X3AXIS = JAXIS
               ! location in I,J,K od x2,x2,x3 axes:
               XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS
            END SELECT

            IF_LOW_HIGH : IF (LOWHIGH == LOW_IND) THEN

               ! Face indexes:
               INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-FCELL, IJK(X2AXIS), IJK(X3AXIS) /)
               INFACE = INDXI1(XIAXIS)
               JNFACE = INDXI1(XJAXIS)
               KNFACE = INDXI1(XKAXIS)

               ! Location of next Cartesian cell:
               INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-1, IJK(X2AXIS), IJK(X3AXIS) /)
               INCELL = INDXI1(XIAXIS)
               JNCELL = INDXI1(XJAXIS)
               KNCELL = INDXI1(XKAXIS)

               ! Scalar:
               IF (CCVAR(INCELL,JNCELL,KNCELL,IBM_UNKZ) > 0 ) THEN ! next cell is reg-cell:

                  IF(IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,OZPOS) == 2) CYCLE IFC_LOOP ! CC-REG face already counted in
                                                                                     ! external boundary loop.

                  ! Add face to IBM_RCFACE_Z data structure:
                  IRC = IRC + 1
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)

                  ! Can compute Area and centroid location of reg
                  ! face when building matrix.

                  ! Add all info required for matrix build:
                  ! Cell at i-1, i.e. regular GASPHASE:
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%UNK(LOW_IND) = CCVAR(INCELL,JNCELL,KNCELL,IBM_UNKZ)
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%XCEN(IAXIS:KAXIS,LOW_IND) = &
                  (/ XCELL(INCELL), YCELL(JNCELL), ZCELL(KNCELL) /)
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%CELL_LIST(IAXIS:KAXIS+1,LOW_IND) = &
                  (/ IBM_FTYPE_RGGAS, INCELL, JNCELL, KNCELL /)

                  ! Cell at i+1, i.e. cut-cell:
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%UNK(HIGH_IND) = CUT_CELL(ICC)%UNKZ(JCC)
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND) = &
                  CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%CELL_LIST(IAXIS:KAXIS+1,HIGH_IND) = &
                  (/ IBM_FTYPE_CFGAS, ICC, JCC, IFC /)

               ELSEIF(CCVAR(INCELL,JNCELL,KNCELL,IBM_CGSC) == IBM_CUTCFE) THEN ! next cell is cc:

                  ! Test that Cut-cell to Cut-cell reg face hasn't been added before:
                  INLIST = .FALSE.
                  DO IIFC=1,IRC
                     IF ( MESHES(NM)%IBM_RCFACE_Z(IIFC)%IJK(IAXIS)   /= INFACE ) CYCLE
                     IF ( MESHES(NM)%IBM_RCFACE_Z(IIFC)%IJK(JAXIS)   /= JNFACE ) CYCLE
                     IF ( MESHES(NM)%IBM_RCFACE_Z(IIFC)%IJK(KAXIS)   /= KNFACE ) CYCLE
                     IF ( MESHES(NM)%IBM_RCFACE_Z(IIFC)%IJK(KAXIS+1) /= X1AXIS ) CYCLE
                     INLIST = .TRUE.
                     EXIT
                  ENDDO
                  IF (INLIST) THEN
                     ! This cut-cell is on the high side of face iifc:
                     ! Cell at i+1, i.e. cut-cell:
                     MESHES(NM)%IBM_RCFACE_Z(IIFC)%UNK(HIGH_IND) = CUT_CELL(ICC)%UNKZ(JCC)
                     MESHES(NM)%IBM_RCFACE_Z(IIFC)%XCEN(IAXIS:KAXIS,HIGH_IND) = &
                     CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)
                     MESHES(NM)%IBM_RCFACE_Z(IIFC)%CELL_LIST(IAXIS:KAXIS+1,HIGH_IND) = &
                     (/ IBM_FTYPE_CFGAS, ICC, JCC, IFC /)
                     CYCLE IFC_LOOP
                  ENDIF

                  ! Add face to IBM_RCFACE_Z  data structure:
                  IRC = IRC + 1
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)

                  ! Can compute Area and centroid location of reg
                  ! face when building matrix.

                  ! Add all info required for matrix build:
                  ! Cell at i+1, i.e. cut-cell:
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%UNK(HIGH_IND) = CUT_CELL(ICC)%UNKZ(JCC)
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND) = &
                  CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%CELL_LIST(IAXIS:KAXIS+1,HIGH_IND) = &
                  (/ IBM_FTYPE_CFGAS, ICC, JCC, IFC /)

               ENDIF

            ELSE ! IF_LOW_HIGH : HIGH_IND

               ! Face indexes:
               INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)-FCELL+1, IJK(X2AXIS), IJK(X3AXIS) /)
               INFACE = INDXI1(XIAXIS)
               JNFACE = INDXI1(XJAXIS)
               KNFACE = INDXI1(XKAXIS)

               ! Location of next Cartesian cell:
               INDXI1(IAXIS:KAXIS) = (/ IJK(X1AXIS)+1, IJK(X2AXIS), IJK(X3AXIS) /)
               INCELL = INDXI1(XIAXIS)
               JNCELL = INDXI1(XJAXIS)
               KNCELL = INDXI1(XKAXIS)

               IF (CCVAR(INCELL,JNCELL,KNCELL,IBM_UNKZ) > 0 ) THEN

                  IF(IJKFACE(INFACE,JNFACE,KNFACE,X1AXIS,OZPOS) == 2) CYCLE IFC_LOOP ! CC-REG face already counted in
                                                                                     ! external boundary loop.

                  ! Add face to IBM_RCFACE_Z data structure:
                  IRC = IRC + 1
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)

                  ! Can compute Area and centroid location of reg
                  ! face when building matrix.

                  ! Add all info required for matrix build:
                  ! Cell at i-1, i.e. cut-cell:
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%UNK(LOW_IND) = CUT_CELL(ICC)%UNKZ(JCC)
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%XCEN(IAXIS:KAXIS,LOW_IND) = &
                       CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%CELL_LIST(IAXIS:KAXIS+1,LOW_IND) = &
                  (/ IBM_FTYPE_CFGAS, ICC, JCC, IFC /)

                  ! Cell at i+1, i.e. regular GASPHASE:
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%UNK(HIGH_IND) = CCVAR(INCELL,JNCELL,KNCELL,IBM_UNKZ)
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%XCEN(IAXIS:KAXIS,HIGH_IND) = &
                             (/ XCELL(INCELL), YCELL(JNCELL), ZCELL(KNCELL) /)
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%CELL_LIST(IAXIS:KAXIS+1,HIGH_IND) = &
                  (/ IBM_FTYPE_RGGAS, INCELL, JNCELL, KNCELL /)

               ELSEIF(CCVAR(INCELL,JNCELL,KNCELL,IBM_CGSC) == IBM_CUTCFE) THEN ! next cell is cc:

                  ! Test that Cut-cell to Cut-cell reg face hasn't been added before:
                  INLIST = .FALSE.
                  DO IIFC=1,IRC
                     IF ( MESHES(NM)%IBM_RCFACE_Z(IIFC)%IJK(IAXIS)   /= INFACE ) CYCLE
                     IF ( MESHES(NM)%IBM_RCFACE_Z(IIFC)%IJK(JAXIS)   /= JNFACE ) CYCLE
                     IF ( MESHES(NM)%IBM_RCFACE_Z(IIFC)%IJK(KAXIS)   /= KNFACE ) CYCLE
                     IF ( MESHES(NM)%IBM_RCFACE_Z(IIFC)%IJK(KAXIS+1) /= X1AXIS ) CYCLE
                     INLIST = .TRUE.
                     EXIT
                  ENDDO
                  IF (INLIST) THEN
                     ! This cut-cell is on the high side of face iifc:
                     ! Cell at i-1, i.e. cut-cell:
                     MESHES(NM)%IBM_RCFACE_Z(IIFC)%UNK(LOW_IND) = CUT_CELL(ICC)%UNKZ(JCC)
                     MESHES(NM)%IBM_RCFACE_Z(IIFC)%XCEN(IAXIS:KAXIS,LOW_IND) = &
                          CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)
                     MESHES(NM)%IBM_RCFACE_Z(IIFC)%CELL_LIST(IAXIS:KAXIS+1,LOW_IND) = &
                     (/ IBM_FTYPE_CFGAS, ICC, JCC, IFC /)
                     CYCLE IFC_LOOP
                  ENDIF

                  ! Add face to IBM_RCFACE_Z data structure:
                  IRC = IRC + 1
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%IJK(IAXIS:KAXIS+1) = (/ INFACE, JNFACE, KNFACE, X1AXIS/)

                  ! Can compute Area and centroid location of reg
                  ! face when building matrix.

                  ! Add high cell info required for matrix build:
                  ! Cell at i-1, i.e. cut-cell:
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%UNK(LOW_IND) = CUT_CELL(ICC)%UNKZ(JCC)
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%XCEN(IAXIS:KAXIS,LOW_IND) = &
                      CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,JCC)
                  MESHES(NM)%IBM_RCFACE_Z(IRC)%CELL_LIST(IAXIS:KAXIS+1,LOW_IND) = &
                  (/ IBM_FTYPE_CFGAS, ICC, JCC, IFC /)

               ENDIF
            ENDIF IF_LOW_HIGH

         ENDDO IFC_LOOP

      ENDDO
   ENDDO

   ! Final number of RC faces:
   MESHES(NM)%IBM_NRCFACE_Z = IRC

   ! Cell centered positions and cell sizes:
   IF (ALLOCATED(XCELL)) DEALLOCATE(XCELL)
   IF (ALLOCATED(YCELL)) DEALLOCATE(YCELL)
   IF (ALLOCATED(ZCELL)) DEALLOCATE(ZCELL)
   IF (ALLOCATED(IJKBUFFER)) DEALLOCATE(IJKBUFFER)
   IF (ALLOCATED(IJKFACE))   DEALLOCATE(IJKFACE)

ENDDO MAIN_MESH_LOOP


#ifdef DEBUG_MATVEC_DATA
DBG_MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
#ifdef MPI_ENABLED
   CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
#endif /* MPI_ENABLED */
   IF(MYID/=PROCESS(NM)) CYCLE DBG_MESH_LOOP
   CALL POINT_TO_MESH(NM)
   WRITE(LU_ERR,*) ' '
   WRITE(LU_ERR,*) 'MYID, NM : ',MYID,NM
   WRITE(LU_ERR,*) 'IBM_NBBREGFACE(1:3) : ',MESHES(NM)%IBM_NBBREGFACE_Z(IAXIS:KAXIS)
   WRITE(LU_ERR,*) 'IBM_NREGFACE(1:3)   : ',MESHES(NM)%IBM_NREGFACE_Z(IAXIS:KAXIS)
   WRITE(LU_ERR,*) 'IBM_NRCFACE_Z, IBM_NBBRCFACE_Z : ', &
                    MESHES(NM)%IBM_NRCFACE_Z,MESHES(NM)%IBM_NBBRCFACE_Z
ENDDO DBG_MESH_LOOP
#endif /* DEBUG_MATVEC_DATA */

RETURN
END SUBROUTINE GET_GASPHASE_REGFACES_DATA


! ------------------ NUMBER_UNKH_CUTCELLS ---------------------------

SUBROUTINE NUMBER_UNKH_CUTCELLS(FLAG12,NM,NUNKH_LC)

LOGICAL, INTENT(IN) :: FLAG12
INTEGER, INTENT(IN) :: NM
INTEGER, INTENT(INOUT) :: NUNKH_LC(1:NMESHES)

! Local Variables:
INTEGER :: ICC, JCC, NCELL

FLAG12_COND : IF (FLAG12) THEN
   ! Initialize Cut-cell unknown numbers as undefined.
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      CUT_CELL(ICC)%UNKH(:) = IBM_UNDEFINED
   ENDDO
   IF(PRES_ON_CARTESIAN) THEN ! Use Underlying Cartesian cells: Method 2.
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         NUNKH_LC(NM) = NUNKH_LC(NM) + 1
         CUT_CELL(ICC)%UNKH(1) = NUNKH_LC(NM)
      ENDDO
   ELSE ! Unstructured pressure solve: Method 1.
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         NCELL = CUT_CELL(ICC)%NCELL
         DO JCC=1,NCELL
             NUNKH_LC(NM) = NUNKH_LC(NM) + 1
             CUT_CELL(ICC)%UNKH(JCC) = NUNKH_LC(NM)
         ENDDO
      ENDDO
   ENDIF

ELSE
   IF (PRES_ON_CARTESIAN) THEN ! Use Underlying Cartesian cells: Method 2.

      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         CUT_CELL(ICC)%UNKH(1) = CUT_CELL(ICC)%UNKH(1) + UNKH_IND(NM)
      ENDDO

   ELSE ! Unstructured pressure solve: Method 1.

      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         NCELL = CUT_CELL(ICC)%NCELL
         DO JCC=1,NCELL
            CUT_CELL(ICC)%UNKH(JCC) = CUT_CELL(ICC)%UNKH(JCC) + UNKH_IND(NM)
         ENDDO
      ENDDO

   ENDIF

ENDIF FLAG12_COND

RETURN
END SUBROUTINE NUMBER_UNKH_CUTCELLS

! ------------------- COPY_CC_HS_TO_UNKH ----------------------------

SUBROUTINE COPY_CC_HS_TO_UNKH(NM)

INTEGER, INTENT(IN) :: NM

! Local Variables:
INTEGER :: NOM,ICC,II,JJ,KK,IOR,IW,IIO,JJO,KKO
TYPE (OMESH_TYPE), POINTER :: OM
TYPE (WALL_TYPE), POINTER :: WC
TYPE (EXTERNAL_WALL_TYPE), POINTER :: EWC

IF (PRES_ON_CARTESIAN) THEN ! Use Underlying Cartesian cells: Method 2.

   ! Loop over external wall cells:
   EXTERNAL_WALL_LOOP: DO IW=1,N_EXTERNAL_WALL_CELLS

      WC=>WALL(IW)
      EWC=>EXTERNAL_WALL(IW)
      IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) CYCLE EXTERNAL_WALL_LOOP

      II  = WC%ONE_D%II
      JJ  = WC%ONE_D%JJ
      KK  = WC%ONE_D%KK
      IOR = WC%ONE_D%IOR
      NOM = EWC%NOM
      OM => OMESH(NOM)

      ! This assumes all meshes at the same level of refinement:
      KKO=EWC%KKO_MIN
      JJO=EWC%JJO_MIN
      IIO=EWC%IIO_MIN

      ICC=CCVAR(II,JJ,KK,IBM_IDCC)

      IF(.NOT.PRES_ON_WHOLE_DOMAIN) THEN
         IF (ICC > 0) THEN ! Cut-cells on this guard-cell Cartesian cell.
            MESHES(NM)%CUT_CELL(ICC)%UNKH(1) = INT(OM%HS(IIO,JJO,KKO))
         ELSE
            MESHES(NM)%CCVAR(II,JJ,KK,IBM_UNKH) = INT(OM%HS(IIO,JJO,KKO))
         ENDIF
      ELSE
         MESHES(NM)%CCVAR(II,JJ,KK,IBM_UNKH) = INT(OM%HS(IIO,JJO,KKO))
         IF (ICC > 0) MESHES(NM)%CUT_CELL(ICC)%UNKH(1) = MESHES(NM)%CCVAR(II,JJ,KK,IBM_UNKH)
      ENDIF


      OM%HS(IIO,JJO,KKO) = 0._EB ! (VAR_CC == UNKH)

   ENDDO EXTERNAL_WALL_LOOP

ELSE

   ! Unstructured pressure solve: Method 1.
   WRITE(LU_ERR,*) 'COPY_CC_UNKH_TO_HS Error: Unstructured pressure solve not implemented yet.'

ENDIF

RETURN
END SUBROUTINE COPY_CC_HS_TO_UNKH

! ------------------- COPY_CC_UNKH_TO_HS ----------------------------

SUBROUTINE COPY_CC_UNKH_TO_HS(NM)

INTEGER, INTENT(IN) :: NM

! Local Variables:
INTEGER :: I,J,K,ICC

IF (PRES_ON_CARTESIAN) THEN ! Use Underlying Cartesian cells: Method 2.

   IF(.NOT.PRES_ON_WHOLE_DOMAIN) THEN
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         I = MESHES(NM)%CUT_CELL(ICC)%IJK(IAXIS)
         J = MESHES(NM)%CUT_CELL(ICC)%IJK(JAXIS)
         K = MESHES(NM)%CUT_CELL(ICC)%IJK(KAXIS)
         HS(I,J,K)= REAL(MESHES(NM)%CUT_CELL(ICC)%UNKH(1),EB)
      ENDDO
   ELSE
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         I = MESHES(NM)%CUT_CELL(ICC)%IJK(IAXIS)
         J = MESHES(NM)%CUT_CELL(ICC)%IJK(JAXIS)
         K = MESHES(NM)%CUT_CELL(ICC)%IJK(KAXIS)
         MESHES(NM)%CUT_CELL(ICC)%UNKH(1) = INT(HS(I,J,K))
      ENDDO
   ENDIF

ELSE

   ! Unstructured pressure solve: Method 1.
   WRITE(LU_ERR,*) 'COPY_CC_UNKH_TO_HS Error: Unstructured pressure solve not implemented yet.'

ENDIF



RETURN
END SUBROUTINE COPY_CC_UNKH_TO_HS

! ---------------- DEFINE_REGULAR_CUTFACES --------------------------

SUBROUTINE DEFINE_REGULAR_CUTFACES(NM,ISTR,IEND,JSTR,JEND,KSTR,KEND,BNDINT_FLAG)

INTEGER, INTENT(IN) :: NM
INTEGER, INTENT(IN) :: ISTR, IEND, JSTR, JEND, KSTR, KEND
LOGICAL, INTENT(IN) :: BNDINT_FLAG

! Local Variables:
INTEGER :: ILO,IHI,JLO,JHI,KLO,KHI,X1AXIS,NVERT,NFACE,I,J,K,NCUTFACE
INTEGER :: IBNDINT,BNDINT_LOW,BNDINT_HIGH

LOGICAL, ALLOCATABLE, SAVE, DIMENSION(:,:,:,:) :: IJK_COUNTED

CALL POINT_TO_MESH(NM)

! Mesh sizes:
NXB=IBAR
NYB=JBAR
NZB=KBAR

! Test Sizes:
IF (PERIODIC_TEST == 7 ) THEN
   VAL_TESTX_LOW =-.5_EB
   VAL_TESTX_HIGH= .5_EB
   VAL_TESTY_LOW = YS
   VAL_TESTY_HIGH= YF
   VAL_TESTZ_LOW =-.5_EB
   VAL_TESTZ_HIGH= .5_EB
ELSEIF (PERIODIC_TEST == 11) THEN
   VAL_TESTX_LOW =-.5_EB
   VAL_TESTX_HIGH= .5_EB
   VAL_TESTY_LOW = YS
   VAL_TESTY_HIGH= YF
   VAL_TESTZ_LOW = ZS
   VAL_TESTZ_HIGH= ZF
ELSEIF (PERIODIC_TEST == 103) THEN
   VAL_TESTX_LOW =-1.0_EB
   VAL_TESTX_HIGH= 1.0_EB
   VAL_TESTY_LOW =-1.0_EB
   VAL_TESTY_HIGH= 1.0_EB
   VAL_TESTZ_LOW = 1.0_EB
   VAL_TESTZ_HIGH= 3.0_EB
ENDIF


! Main Loop on block NM:
IF (BNDINT_FLAG) THEN
   ALLOCATE( IJK_COUNTED(ISTR:IEND,JSTR:JEND,KSTR:KEND,IAXIS:KAXIS) ); IJK_COUNTED=.FALSE.
   BNDINT_LOW  = 1
   BNDINT_HIGH = 3
ELSE
   BNDINT_LOW  = 4
   BNDINT_HIGH = 4
ENDIF

IBNDINT_LOOP : DO IBNDINT=BNDINT_LOW,BNDINT_HIGH ! 1,2 refers to block boundary faces, 3 to internal faces,
                                                 ! 4 guard-cell faces.

   ! When switching to internal faces, copy number of external faces already computed.
   IF (IBNDINT == 3) MESHES(NM)%N_BBCUTFACE_MESH = MESHES(NM)%N_CUTFACE_MESH

   ! First tag and define Gasphase cut-faces in X,Y,Z directions.
   ! X direction:
   ! IAXIS gasphase cut-faces:
   JLO = JLO_CELL; JHI = JHI_CELL
   KLO = KLO_CELL; KHI = KHI_CELL
   SELECT CASE(IBNDINT)
   CASE(1)
      ILO = ILO_FACE; IHI = ILO_FACE
   CASE(2)
      ILO = IHI_FACE; IHI = IHI_FACE
   CASE(3)
      ILO = ILO_FACE+1; IHI = IHI_FACE-1
   CASE(4)
      ILO = ILO_FACE-CCGUARD; IHI= IHI_FACE+CCGUARD
      JLO = JLO-CCGUARD; JHI = JHI+CCGUARD
      KLO = KLO-CCGUARD; KHI = KHI+CCGUARD
   END SELECT
   X1AXIS=IAXIS
   NVERT = 4
   NFACE = 1
   DO I=ILO,IHI
      DO J=JLO,JHI
         DO K=KLO,KHI

            ! If cut-cell centroid is outside the test box -> drop:
            IF(XFACE(I) < (VAL_TESTX_LOW +GEOMEPS)) CYCLE; IF(XFACE(I) > (VAL_TESTX_HIGH-GEOMEPS)) CYCLE
            IF(YCELL(J) < (VAL_TESTY_LOW +GEOMEPS)) CYCLE; IF(YCELL(J) > (VAL_TESTY_HIGH-GEOMEPS)) CYCLE
            IF(ZCELL(K) < (VAL_TESTZ_LOW +GEOMEPS)) CYCLE; IF(ZCELL(K) > (VAL_TESTZ_HIGH-GEOMEPS)) CYCLE

            ! Drop if cut-face has already been counted:
            IF( IJK_COUNTED(I,J,K,X1AXIS) ) CYCLE; IJK_COUNTED(I,J,K,X1AXIS)=.TRUE.

            FCVAR(I,J,K,IBM_FGSC,X1AXIS)=IBM_CUTCFE

            NCUTFACE = MESHES(NM)%N_CUTFACE_MESH + MESHES(NM)%N_GCCUTFACE_MESH + 1
            IF (BNDINT_FLAG) THEN
               MESHES(NM)%N_CUTFACE_MESH = NCUTFACE
            ELSE
               MESHES(NM)%N_GCCUTFACE_MESH = MESHES(NM)%N_GCCUTFACE_MESH + 1
            ENDIF

            FCVAR(I,J,K,IBM_IDCF,X1AXIS) = NCUTFACE
            CUT_FACE(NCUTFACE)%NVERT  = NVERT
            CUT_FACE(NCUTFACE)%NFACE  = NFACE
            CUT_FACE(NCUTFACE)%IJK(1:MAX_DIM+1) = (/ I, J, K, X1AXIS /)
            CUT_FACE(NCUTFACE)%STATUS = IBM_GASPHASE
            CALL NEW_FACE_ALLOC(NM,NCUTFACE,NVERT,NFACE,NVERT+1)

            ! Vertices:
            CUT_FACE(NCUTFACE)%XYZVERT(IAXIS:KAXIS,1) = (/ XFACE(I), YFACE(J-1), ZFACE(K-1) /)
            CUT_FACE(NCUTFACE)%XYZVERT(IAXIS:KAXIS,2) = (/ XFACE(I), YFACE(J  ), ZFACE(K-1) /)
            CUT_FACE(NCUTFACE)%XYZVERT(IAXIS:KAXIS,3) = (/ XFACE(I), YFACE(J  ), ZFACE(K  ) /)
            CUT_FACE(NCUTFACE)%XYZVERT(IAXIS:KAXIS,4) = (/ XFACE(I), YFACE(J-1), ZFACE(K  ) /)

            ! Centroid:
            CUT_FACE(NCUTFACE)%XYZCEN(IAXIS:KAXIS,NFACE) = 0.5_EB* &
            (/ XFACE(I  )+XFACE(I  ), YFACE(J-1)+YFACE(J  ), ZFACE(K-1)+ZFACE(K  ) /)

            ! Load Ordered nodes to CFELEM and geom properties:
            CUT_FACE(NCUTFACE)%CFELEM(1:NVERT+1,NFACE) = (/ NVERT, 1, 2, 3, 4 /)
            CUT_FACE(NCUTFACE)%AREA(NFACE) = DYCELL(J)*DZCELL(K)

            ! Fields for cut-cell volume/centroid computation:
            ! dot(i,nc)*int(x)dA, where nc=j => dot(i,nc)=0:
            CUT_FACE(NCUTFACE)%INXAREA(NFACE)   =   XFACE(I)*CUT_FACE(NCUTFACE)%AREA(NFACE)
            ! dot(i,nc)*int(x^2)dA, where nc=j => dot(i,nc)=0:
            CUT_FACE(NCUTFACE)%INXSQAREA(NFACE) =   XFACE(I)**2._EB*CUT_FACE(NCUTFACE)%AREA(NFACE)
            ! dot(j,nc)*int(y^2)dA, where y=yface(J) constant nc=j:
            CUT_FACE(NCUTFACE)%JNYSQAREA(NFACE) = 0._EB
            ! dot(k,nc)*int(z^2)dA, where nc=j => dot(k,nc)=0:
            CUT_FACE(NCUTFACE)%KNZSQAREA(NFACE) = 0._EB
         ENDDO
      ENDDO
   ENDDO

   ! Y direction:
   ! JAXIS gasphase cut-faces:
   ILO = ILO_CELL; IHI = IHI_CELL
   KLO = KLO_CELL; KHI = KHI_CELL
   SELECT CASE(IBNDINT)
   CASE(1)
      JLO = JLO_FACE; JHI = JLO_FACE
   CASE(2)
      JLO = JHI_FACE; JHI = JHI_FACE
   CASE(3)
      JLO = JLO_FACE+1; JHI = JHI_FACE-1
   CASE(4)
      JLO = JLO_FACE-CCGUARD; JHI = JHI_FACE+CCGUARD
      ILO = ILO-CCGUARD; IHI = IHI+CCGUARD
      KLO = KLO-CCGUARD; KHI = KHI+CCGUARD
   END SELECT
   X1AXIS=JAXIS
   NVERT = 4
   NFACE = 1
   DO I=ILO,IHI
      DO J=JLO,JHI
         DO K=KLO,KHI

            ! If cut-cell centroid is outside the test box -> drop:
            IF(XCELL(I) < (VAL_TESTX_LOW +GEOMEPS)) CYCLE; IF(XCELL(I) > (VAL_TESTX_HIGH-GEOMEPS)) CYCLE
            IF(YFACE(J) < (VAL_TESTY_LOW +GEOMEPS)) CYCLE; IF(YFACE(J) > (VAL_TESTY_HIGH-GEOMEPS)) CYCLE
            IF(ZCELL(K) < (VAL_TESTZ_LOW +GEOMEPS)) CYCLE; IF(ZCELL(K) > (VAL_TESTZ_HIGH-GEOMEPS)) CYCLE

            ! Drop if cut-face has already been counted:
            IF( IJK_COUNTED(I,J,K,X1AXIS) ) CYCLE; IJK_COUNTED(I,J,K,X1AXIS)=.TRUE.

            FCVAR(I,J,K,IBM_FGSC,X1AXIS)=IBM_CUTCFE

            NCUTFACE = MESHES(NM)%N_CUTFACE_MESH + MESHES(NM)%N_GCCUTFACE_MESH + 1
            IF (BNDINT_FLAG) THEN
               MESHES(NM)%N_CUTFACE_MESH = NCUTFACE
            ELSE
               MESHES(NM)%N_GCCUTFACE_MESH = MESHES(NM)%N_GCCUTFACE_MESH + 1
            ENDIF

            FCVAR(I,J,K,IBM_IDCF,X1AXIS) = NCUTFACE
            CUT_FACE(NCUTFACE)%NVERT  = NVERT
            CUT_FACE(NCUTFACE)%NFACE  = NFACE
            CUT_FACE(NCUTFACE)%IJK(1:MAX_DIM+1) = (/ I, J, K, X1AXIS /)
            CUT_FACE(NCUTFACE)%STATUS = IBM_GASPHASE
            CALL NEW_FACE_ALLOC(NM,NCUTFACE,NVERT,NFACE,NVERT+1)


            ! Vertices:
            CUT_FACE(NCUTFACE)%XYZVERT(IAXIS:KAXIS,1) = (/ XFACE(I-1), YFACE(J), ZFACE(K-1) /)
            CUT_FACE(NCUTFACE)%XYZVERT(IAXIS:KAXIS,2) = (/ XFACE(I-1), YFACE(J), ZFACE(K  ) /)
            CUT_FACE(NCUTFACE)%XYZVERT(IAXIS:KAXIS,3) = (/ XFACE(I  ), YFACE(J), ZFACE(K  ) /)
            CUT_FACE(NCUTFACE)%XYZVERT(IAXIS:KAXIS,4) = (/ XFACE(I  ), YFACE(J), ZFACE(K-1) /)

            ! Centroid:
            CUT_FACE(NCUTFACE)%XYZCEN(IAXIS:KAXIS,NFACE) = 0.5_EB* &
            (/ XFACE(I-1)+XFACE(I  ), YFACE(J  )+YFACE(J  ), ZFACE(K-1)+ZFACE(K  ) /)

            ! Load Ordered nodes to CFELEM and geom properties:
            CUT_FACE(NCUTFACE)%CFELEM(1:NVERT+1,NFACE) = (/ NVERT, 1, 2, 3, 4 /)
            CUT_FACE(NCUTFACE)%AREA(NFACE) = DXCELL(I)*DZCELL(K)

            ! Fields for cut-cell volume/centroid computation:
            ! dot(i,nc)*int(x)dA, where nc=j => dot(i,nc)=0:
            CUT_FACE(NCUTFACE)%INXAREA(NFACE)   = 0._EB
            ! dot(i,nc)*int(x^2)dA, where nc=j => dot(i,nc)=0:
            CUT_FACE(NCUTFACE)%INXSQAREA(NFACE) = 0._EB
            ! dot(j,nc)*int(y^2)dA, where y=yface(J) constant nc=j:
            CUT_FACE(NCUTFACE)%JNYSQAREA(NFACE) = YFACE(J)**2._EB*CUT_FACE(NCUTFACE)%AREA(NFACE)
            ! dot(k,nc)*int(z^2)dA, where nc=j => dot(k,nc)=0:
            CUT_FACE(NCUTFACE)%KNZSQAREA(NFACE) = 0._EB
         ENDDO
      ENDDO
   ENDDO

   ! Z direction:
   ! KAXIS gasphase cut-faces:
   ILO = ILO_CELL; IHI = IHI_CELL
   JLO = JLO_CELL; JHI = JHI_CELL
   SELECT CASE(IBNDINT)
   CASE(1)
      KLO = KLO_FACE; KHI = KLO_FACE
   CASE(2)
      KLO = KHI_FACE; KHI = KHI_FACE
   CASE(3)
      KLO = KLO_FACE+1; KHI = KHI_FACE-1
   CASE(4)
      KLO = KLO_FACE-CCGUARD; KHI = KHI_FACE+CCGUARD
      ILO = ILO-CCGUARD; IHI = IHI+CCGUARD
      JLO = JLO-CCGUARD; JHI = JHI+CCGUARD
   END SELECT
   X1AXIS=KAXIS
   NVERT = 4
   NFACE = 1
   DO I=ILO,IHI
      DO J=JLO,JHI
         DO K=KLO,KHI

            ! If cut-cell centroid is outside the test box -> drop:
            IF(XCELL(I) < (VAL_TESTX_LOW +GEOMEPS)) CYCLE; IF(XCELL(I) > (VAL_TESTX_HIGH-GEOMEPS)) CYCLE
            IF(YCELL(J) < (VAL_TESTY_LOW +GEOMEPS)) CYCLE; IF(YCELL(J) > (VAL_TESTY_HIGH-GEOMEPS)) CYCLE
            IF(ZFACE(K) < (VAL_TESTZ_LOW +GEOMEPS)) CYCLE; IF(ZFACE(K) > (VAL_TESTZ_HIGH-GEOMEPS)) CYCLE

            ! Drop if cut-face has already been counted:
            IF( IJK_COUNTED(I,J,K,X1AXIS) ) CYCLE; IJK_COUNTED(I,J,K,X1AXIS)=.TRUE.

            FCVAR(I,J,K,IBM_FGSC,X1AXIS)=IBM_CUTCFE

            NCUTFACE = MESHES(NM)%N_CUTFACE_MESH + MESHES(NM)%N_GCCUTFACE_MESH + 1
            IF (BNDINT_FLAG) THEN
               MESHES(NM)%N_CUTFACE_MESH = NCUTFACE
            ELSE
               MESHES(NM)%N_GCCUTFACE_MESH = MESHES(NM)%N_GCCUTFACE_MESH + 1
            ENDIF

            FCVAR(I,J,K,IBM_IDCF,X1AXIS) = NCUTFACE
            CUT_FACE(NCUTFACE)%NVERT  = NVERT
            CUT_FACE(NCUTFACE)%NFACE  = NFACE
            CUT_FACE(NCUTFACE)%IJK(1:MAX_DIM+1) = (/ I, J, K, X1AXIS /)
            CUT_FACE(NCUTFACE)%STATUS = IBM_GASPHASE
            CALL NEW_FACE_ALLOC(NM,NCUTFACE,NVERT,NFACE,NVERT+1)


            ! Vertices:
            CUT_FACE(NCUTFACE)%XYZVERT(IAXIS:KAXIS,1) = (/ XFACE(I-1), YFACE(J-1), ZFACE(K) /)
            CUT_FACE(NCUTFACE)%XYZVERT(IAXIS:KAXIS,2) = (/ XFACE(I  ), YFACE(J-1), ZFACE(K) /)
            CUT_FACE(NCUTFACE)%XYZVERT(IAXIS:KAXIS,3) = (/ XFACE(I  ), YFACE(J  ), ZFACE(K) /)
            CUT_FACE(NCUTFACE)%XYZVERT(IAXIS:KAXIS,4) = (/ XFACE(I-1), YFACE(J  ), ZFACE(K) /)

            ! Centroid:
            CUT_FACE(NCUTFACE)%XYZCEN(IAXIS:KAXIS,NFACE) = 0.5_EB* &
            (/ XFACE(I-1)+XFACE(I  ), YFACE(J-1)+YFACE(J  ), ZFACE(K  )+ZFACE(K  ) /)

            ! Load Ordered nodes to CFELEM and geom properties:
            CUT_FACE(NCUTFACE)%CFELEM(1:NVERT+1,NFACE) = (/ NVERT, 1, 2, 3, 4 /)
            CUT_FACE(NCUTFACE)%AREA(NFACE) = DXCELL(I)*DYCELL(J)

            ! Fields for cut-cell volume/centroid computation:
            ! dot(i,nc)*int(x)dA, where nc=j => dot(i,nc)=0:
            CUT_FACE(NCUTFACE)%INXAREA(NFACE)   = 0._EB
            ! dot(i,nc)*int(x^2)dA, where nc=j => dot(i,nc)=0:
            CUT_FACE(NCUTFACE)%INXSQAREA(NFACE) = 0._EB
            ! dot(j,nc)*int(y^2)dA, where y=yface(J) constant nc=j:
            CUT_FACE(NCUTFACE)%JNYSQAREA(NFACE) = 0._EB
            ! dot(k,nc)*int(z^2)dA, where nc=j => dot(k,nc)=0:
            CUT_FACE(NCUTFACE)%KNZSQAREA(NFACE) = ZFACE(K)**2._EB*CUT_FACE(NCUTFACE)%AREA(NFACE)
         ENDDO
      ENDDO
   ENDDO

ENDDO IBNDINT_LOOP

IF (.NOT.BNDINT_FLAG) DEALLOCATE( IJK_COUNTED )

RETURN
END SUBROUTINE DEFINE_REGULAR_CUTFACES


! ------------------ GET_MATRIX_INDEXES_Z ---------------------------
SUBROUTINE GET_MATRIX_INDEXES_Z
USE MPI
IMPLICIT NONE

! Local variables:
INTEGER :: NM
INTEGER :: ILO,IHI,JLO,JHI,KLO,KHI
INTEGER :: I,J,K,ICC,JCC,NCELL,INGH,JNGH,KNGH,IERR,IPT
INTEGER, PARAMETER :: IMPADD = 1
INTEGER, PARAMETER :: SHFTM(1:3,1:6) = RESHAPE((/-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1/),(/3,6/))
LOGICAL :: CRTCELL_FLG

INTEGER :: X1AXIS,LOWHIGH,ILH,IFC,IFACE,IFC2,IFACE2,IRC,ICC2,JCC2,VAL_UNKZ
REAL(EB):: CCVOL_THRES,VAL_CVOL

LOGICAL :: QUITLINK_FLG

! Define local number of cut-cell:
IF (ALLOCATED(NUNKZ_LOC)) DEALLOCATE(NUNKZ_LOC)
ALLOCATE(NUNKZ_LOC(1:NMESHES)); NUNKZ_LOC = 0

! Cell numbers for Scalar equations:
MAIN_MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! Mesh sizes:
   NXB=IBAR
   NYB=JBAR
   NZB=KBAR

   ! X direction bounds:
   ILO_FACE = 0                    ! Low mesh boundary face index.
   IHI_FACE = IBAR                 ! High mesh boundary face index.
   ILO_CELL = ILO_FACE + FCELL     ! First internal cell index. See notes.
   IHI_CELL = IHI_FACE + FCELL - 1 ! Last internal cell index.

   ! Y direction bounds:
   JLO_FACE = 0                    ! Low mesh boundary face index.
   JHI_FACE = JBAR                 ! High mesh boundary face index.
   JLO_CELL = JLO_FACE + FCELL     ! First internal cell index. See notes.
   JHI_CELL = JHI_FACE + FCELL - 1 ! Last internal cell index.

   ! Z direction bounds:
   KLO_FACE = 0                    ! Low mesh boundary face index.
   KHI_FACE = KBAR                 ! High mesh boundary face index.
   KLO_CELL = KLO_FACE + FCELL     ! First internal cell index. See notes.
   KHI_CELL = KHI_FACE + FCELL - 1 ! Last internal cell index.

   ! Initialize unknown numbers for Z:
   ! We assume SET_CUTCELLS_3D has been called and CCVAR has been allocated:
   CCVAR(:,:,:,IBM_UNKZ) = IBM_UNDEFINED
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      CUT_CELL(ICC)%UNKZ(:) = IBM_UNDEFINED
   ENDDO

   ! 1. Number regular GASPHASE cells:
   ILO = ILO_CELL; IHI = IHI_CELL
   JLO = JLO_CELL; JHI = JHI_CELL
   KLO = KLO_CELL; KHI = KHI_CELL

   IF (PERIODIC_TEST==103 .OR. PERIODIC_TEST==11 .OR. PERIODIC_TEST==7) THEN
      DO K=KLO,KHI
         DO J=JLO,JHI
            DO I=ILO,IHI

               ! If regular cell centroid is outside the test box + DELTA -> drop:
               IF(XC(I) < (VAL_TESTX_LOW-DX(I) +GEOMEPS)) CYCLE; IF(XC(I) > (VAL_TESTX_HIGH+DX(I)-GEOMEPS)) CYCLE
               IF(YC(J) < (VAL_TESTY_LOW-DY(J) +GEOMEPS)) CYCLE; IF(YC(J) > (VAL_TESTY_HIGH+DY(J)-GEOMEPS)) CYCLE
               IF(ZC(K) < (VAL_TESTZ_LOW-DZ(K) +GEOMEPS)) CYCLE; IF(ZC(K) > (VAL_TESTZ_HIGH+DZ(K)-GEOMEPS)) CYCLE
               IF(CCVAR(I,J,K,IBM_CGSC) /= IBM_GASPHASE) CYCLE
               NUNKZ_LOC(NM) = NUNKZ_LOC(NM) + 1
               CCVAR(I,J,K,IBM_UNKZ) = NUNKZ_LOC(NM)
            ENDDO
         ENDDO
      ENDDO
   ENDIF

   ! Loop on Cartesian cells, number unknowns for cells type IBM_CUTCFE and surrounding IBM_GASPHASE:
   DO K=KLO-1,KHI+1
      DO J=JLO-1,JHI+1
         DO I=ILO-1,IHI+1

            ! Drop if cartesian cell is not type IBM_CUTCFE:
            IF (  CCVAR(I,J,K,IBM_CGSC) /= IBM_CUTCFE ) CYCLE

            ! First Add the Cut-Cell
            ICC  = CCVAR(I,J,K,IBM_IDCC)
            IF (ICC <= MESHES(NM)%N_CUTCELL_MESH) THEN ! Don't number guard-cell cut-cells.
               NCELL= CUT_CELL(ICC)%NCELL
               CCVOL_THRES = CCVOL_LINK*DX(I)*DY(J)*DZ(K)
               DO JCC=1,NCELL
                  IF ( CUT_CELL(ICC)%VOLUME(JCC) < CCVOL_THRES) CYCLE ! Small cell, dealt with later.
                  NUNKZ_LOC(NM) = NUNKZ_LOC(NM) + 1
                  CUT_CELL(ICC)%UNKZ(JCC) = NUNKZ_LOC(NM)
               ENDDO
            ENDIF

            ! First Run over Neighbors: Case 27 cells.
            SELECT CASE(IMPADD)
            CASE(0)
               ! No corner neighbors, only 6 face neighbors of Cartesian cell.
               DO IPT=1,6
                  KNGH=K+SHFTM(KAXIS,IPT)
                  IF ( (KNGH < KLO_CELL) .OR. (KNGH > KHI_CELL) ) CYCLE
                  JNGH=J+SHFTM(JAXIS,IPT)
                  IF ( (JNGH < JLO_CELL) .OR. (JNGH > JHI_CELL) ) CYCLE
                  INGH=I+SHFTM(IAXIS,IPT)
                  ! Either not GASPHASE or already counted:
                  IF ( (CCVAR(INGH,JNGH,KNGH,IBM_CGSC) /= IBM_GASPHASE) .OR. &
                       (CCVAR(INGH,JNGH,KNGH,IBM_UNKZ)  > 0) ) CYCLE
                  IF ( (INGH < ILO_CELL) .OR. (INGH > IHI_CELL) ) CYCLE

                  ! Add Scalar unknown:
                  NUNKZ_LOC(NM) = NUNKZ_LOC(NM) + 1
                  CCVAR(INGH,JNGH,KNGH,IBM_UNKZ) = NUNKZ_LOC(NM)

               ENDDO

            CASE DEFAULT
               ! Only Internal cells for the mesh in the stencil (I-IMPADD:I+IMPADD,J-IMPADD:J+IMPADD,K-IMPADD:K+IMPADD)
               ! aound Cartesian cell I,J,K of type IBM_CUTCFE:
               DO KNGH=K-IMPADD,K+IMPADD
                  IF ( (KNGH < KLO_CELL) .OR. (KNGH > KHI_CELL) ) CYCLE
                  DO JNGH=J-IMPADD,J+IMPADD
                     IF ( (JNGH < JLO_CELL) .OR. (JNGH > JHI_CELL) ) CYCLE
                     DO INGH=I-IMPADD,I+IMPADD
                        ! Either not GASPHASE or already counted:
                        IF ( (CCVAR(INGH,JNGH,KNGH,IBM_CGSC) /= IBM_GASPHASE) .OR. &
                             (CCVAR(INGH,JNGH,KNGH,IBM_UNKZ)  > 0) ) CYCLE
                        IF ( (INGH < ILO_CELL) .OR. (INGH > IHI_CELL) ) CYCLE

                        ! Add Scalar unknown:
                        NUNKZ_LOC(NM) = NUNKZ_LOC(NM) + 1
                        CCVAR(INGH,JNGH,KNGH,IBM_UNKZ) = NUNKZ_LOC(NM)

                     ENDDO
                  ENDDO
               ENDDO
            END SELECT

         ENDDO
      ENDDO
   ENDDO

ENDDO MAIN_MESH_LOOP

! Define total number of unknowns and global unknow index start per MESH:
IF (ALLOCATED(NUNKZ_TOT)) DEALLOCATE(NUNKZ_TOT)
ALLOCATE(NUNKZ_TOT(1:NMESHES)); NUNKZ_TOT = 0
IF (N_MPI_PROCESSES > 1) THEN
   CALL MPI_ALLREDUCE(NUNKZ_LOC, NUNKZ_TOT, NMESHES, MPI_INTEGER, MPI_SUM, MPI_COMM_WORLD, IERR)
ELSE
   NUNKZ_TOT = NUNKZ_LOC
ENDIF
! Define global start indexes for each mesh:
IF (ALLOCATED(UNKZ_ILC)) DEALLOCATE(UNKZ_ILC)
ALLOCATE(UNKZ_ILC(1:NMESHES)); UNKZ_ILC(1:NMESHES) = 0
IF (ALLOCATED(UNKZ_IND)) DEALLOCATE(UNKZ_IND)
ALLOCATE(UNKZ_IND(1:NMESHES)); UNKZ_IND(1:NMESHES) = 0
DO NM=2,NMESHES
   UNKZ_ILC(NM) = UNKZ_ILC(NM-1) + NUNKZ_LOC(NM-1)
   UNKZ_IND(NM) = UNKZ_IND(NM-1) + NUNKZ_TOT(NM-1)
ENDDO

! Cell numbers for Scalar equationsin global numeration:
MAIN_MESH_LOOP2 : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! Mesh sizes:
   NXB=IBAR; NYB=JBAR; NZB=KBAR

   ! X direction bounds:
   ILO_FACE = 0                    ! Low mesh boundary face index.
   IHI_FACE = IBAR                 ! High mesh boundary face index.
   ILO_CELL = ILO_FACE + FCELL     ! First internal cell index. See notes.
   IHI_CELL = IHI_FACE + FCELL - 1 ! Last internal cell index.

   ! Y direction bounds:
   JLO_FACE = 0                    ! Low mesh boundary face index.
   JHI_FACE = JBAR                 ! High mesh boundary face index.
   JLO_CELL = JLO_FACE + FCELL     ! First internal cell index. See notes.
   JHI_CELL = JHI_FACE + FCELL - 1 ! Last internal cell index.

   ! Z direction bounds:
   KLO_FACE = 0                    ! Low mesh boundary face index.
   KHI_FACE = KBAR                 ! High mesh boundary face index.
   KLO_CELL = KLO_FACE + FCELL     ! First internal cell index. See notes.
   KHI_CELL = KHI_FACE + FCELL - 1 ! Last internal cell index.

   ! 1. Number regular GASPHASE cells within the implicit region:
   ILO = ILO_CELL; IHI = IHI_CELL
   JLO = JLO_CELL; JHI = JHI_CELL
   KLO = KLO_CELL; KHI = KHI_CELL
   DO K=KLO,KHI
      DO J=JLO,JHI
         DO I=ILO,IHI
            IF (CCVAR(I,J,K,IBM_CGSC) /= IBM_GASPHASE) CYCLE
            IF (CCVAR(I,J,K,IBM_UNKZ) <= 0 ) CYCLE ! Drop if regular GASPHASE cell has not been assigned unknown number.
            CCVAR(I,J,K,IBM_UNKZ) = CCVAR(I,J,K,IBM_UNKZ) + UNKZ_IND(NM)
         ENDDO
      ENDDO
   ENDDO
   ! 2. Number cut-cells:
   DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
      NCELL = MESHES(NM)%CUT_CELL(ICC)%NCELL
      I = CUT_CELL(ICC)%IJK(IAXIS)
      J = CUT_CELL(ICC)%IJK(JAXIS)
      K = CUT_CELL(ICC)%IJK(KAXIS)
      CCVOL_THRES = CCVOL_LINK*DX(I)*DY(J)*DZ(K)
      DO JCC=1,NCELL
         IF ( CUT_CELL(ICC)%VOLUME(JCC) < CCVOL_THRES) CYCLE ! Small cell, dealt with later.
         CUT_CELL(ICC)%UNKZ(JCC) = CUT_CELL(ICC)%UNKZ(JCC) + UNKZ_IND(NM)
      ENDDO
   ENDDO

ENDDO MAIN_MESH_LOOP2

! Finally link small cells to surrounding cells:
! Add initial index UNKX_ind to mesh blocks (regular + cut-cells):
! NOTE: This linking scheme assumes there are no small cells trapped against a block boundary, i.e. there is a path
! within the mesh between them and a large cell.
! NOTE2: This scheme links to unknowns local to the mesh, therefore parallel consistency is not maintained.
MAIN_MESH_LOOP3 : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   LINK_LOOP : DO ! Cut-cell linking loop for small cells. -> Algo defined by CCVOL_LINK.

      QUITLINK_FLG = .TRUE.

      ! First attempt to link to regular GASPHASE cells:
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         NCELL = CUT_CELL(ICC)%NCELL
         I = CUT_CELL(ICC)%IJK(IAXIS)
         J = CUT_CELL(ICC)%IJK(JAXIS)
         K = CUT_CELL(ICC)%IJK(KAXIS)
         CCVOL_THRES = CCVOL_LINK*DX(I)*DY(J)*DZ(K)
         DO JCC=1,NCELL
            IF ( CUT_CELL(ICC)%UNKZ(JCC) > 0 ) CYCLE

            ! Small cells, get IBM_UNKZ from a large cell neighbor:
            VAL_UNKZ = IBM_UNDEFINED
            VAL_CVOL = CCVOL_THRES
            IFC_LOOP3A : DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)

               IFACE   = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)
               LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
               ILH     = 2*LOWHIGH - 3 ! -1 for LOW_IND, 1 for HIGH_IND

               SELECT CASE(CUT_CELL(ICC)%FACE_LIST(1,IFACE)) ! 1. Check if a surrounding cell is a regular cell:
               CASE(IBM_FTYPE_RGGAS) ! REGULAR GASPHASE
                  X1AXIS  = CUT_CELL(ICC)%FACE_LIST(3,IFACE)
                  CRTCELL_FLG = .FALSE.
                  SELECT CASE(X1AXIS)
                  ! Using IBM_UNKZ in the following conditionals assures no guard-cells outside of the domain (except
                  ! case of periodic boundaries) are chosen. Deals with domain BCs.
                  CASE(IAXIS)
                     IF(CCVAR(I+ILH,J,K,IBM_UNKZ) > 0) THEN ! Regular Cartesian Cell
                        VAL_UNKZ = CCVAR(I+ILH,J,K,IBM_UNKZ)
                        CRTCELL_FLG = .TRUE.
                     ENDIF
                  CASE(JAXIS)
                     IF(CCVAR(I,J+ILH,K,IBM_UNKZ) > 0) THEN ! Regular Cartesian Cell
                        VAL_UNKZ = CCVAR(I,J+ILH,K,IBM_UNKZ)
                        CRTCELL_FLG = .TRUE.
                     ENDIF
                  CASE(KAXIS)
                     IF(CCVAR(I,J,K+ILH,IBM_UNKZ) > 0) THEN ! Regular Cartesian Cell
                        VAL_UNKZ = CCVAR(I,J,K+ILH,IBM_UNKZ)
                        CRTCELL_FLG = .TRUE.
                     ENDIF
                  END SELECT
                  IF ( CRTCELL_FLG ) EXIT IFC_LOOP3A

               END SELECT

            ENDDO IFC_LOOP3A

            CUT_CELL(ICC)%UNKZ(JCC) = VAL_UNKZ
         ENDDO
      ENDDO

      ! Then attempt to connect to large cut-cells, or already connected small cells (CUT_CELL(OCC)%UNKZ(JCC) > 0):
      DO ICC=1,MESHES(NM)%N_CUTCELL_MESH
         NCELL = CUT_CELL(ICC)%NCELL
         I = CUT_CELL(ICC)%IJK(IAXIS)
         J = CUT_CELL(ICC)%IJK(JAXIS)
         K = CUT_CELL(ICC)%IJK(KAXIS)
         CCVOL_THRES = CCVOL_LINK*DX(I)*DY(J)*DZ(K)
         DO JCC=1,NCELL
            IF ( CUT_CELL(ICC)%UNKZ(JCC) > 0 ) CYCLE

            ! Small cells, get IBM_UNKZ from a large cell neighbor:
            VAL_UNKZ = IBM_UNDEFINED
            VAL_CVOL = -GEOMEPS
            IFC_LOOP3 : DO IFC=1,CUT_CELL(ICC)%CCELEM(1,JCC)

               IFACE   = CUT_CELL(ICC)%CCELEM(IFC+1,JCC)

               IF((CUT_CELL(ICC)%FACE_LIST(1,IFACE)==IBM_FTYPE_CFINB) .OR. &
                  (CUT_CELL(ICC)%FACE_LIST(1,IFACE)==IBM_FTYPE_SVERT)) CYCLE IFC_LOOP3

               LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
               ILH     = 2*LOWHIGH - 3 ! -1 for LOW_IND, 1 for HIGH_IND

               ! Cycle if surrounding cell is located in the guard-cell region, if so drop, as we don't have
               ! at this point unknown numbers on guard-cells/guard-cell ccs:
               X1AXIS  = CUT_CELL(ICC)%FACE_LIST(3,IFACE)
               SELECT CASE(X1AXIS)
               CASE(IAXIS)
                  IF( (I+ILH < 1) .OR. (I+ILH > IBAR) ) CYCLE IFC_LOOP3
               CASE(JAXIS)
                  IF( (J+ILH < 1) .OR. (J+ILH > JBAR) ) CYCLE IFC_LOOP3
               CASE(KAXIS)
                  IF( (K+ILH < 1) .OR. (K+ILH > KBAR) ) CYCLE IFC_LOOP3
               END SELECT

               SELECT CASE(CUT_CELL(ICC)%FACE_LIST(1,IFACE)) ! 1. Check if a surrounding cell is a regular cell:
               CASE(IBM_FTYPE_RGGAS) ! REGULAR GASPHASE
                  !X1AXIS  = CUT_CELL(ICC)%FACE_LIST(3,IFACE)

                  SELECT CASE(X1AXIS)
                  CASE(IAXIS)
                     IF(CCVAR(I+ILH,J,K,IBM_UNKZ) <= 0) THEN ! Cut - cell. Array IBM_RCFACE_VEL is used.
                        IRC = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
                        ICC2= MESHES(NM)%IBM_RCFACE_VEL(IRC)%CELL_LIST(2,LOWHIGH,1)
                        JCC2= MESHES(NM)%IBM_RCFACE_VEL(IRC)%CELL_LIST(3,LOWHIGH,1)
                        IF ( CUT_CELL(ICC2)%VOLUME(JCC2) < VAL_CVOL) CYCLE IFC_LOOP3
                        IF ( CUT_CELL(ICC2)%UNKZ(JCC2) <= 0) CYCLE IFC_LOOP3
                        VAL_CVOL = CUT_CELL(ICC2)%VOLUME(JCC2)
                        VAL_UNKZ = CUT_CELL(ICC2)%UNKZ(JCC2)
                     ENDIF
                  CASE(JAXIS)
                     IF(CCVAR(I,J+ILH,K,IBM_UNKZ) <= 0) THEN ! Cut - cell. Array IBM_RCFACE_VEL is used.
                        IRC = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
                        ICC2= MESHES(NM)%IBM_RCFACE_VEL(IRC)%CELL_LIST(2,LOWHIGH,1)
                        JCC2= MESHES(NM)%IBM_RCFACE_VEL(IRC)%CELL_LIST(3,LOWHIGH,1)
                        IF ( CUT_CELL(ICC2)%VOLUME(JCC2) < VAL_CVOL) CYCLE IFC_LOOP3
                        IF ( CUT_CELL(ICC2)%UNKZ(JCC2) <= 0) CYCLE IFC_LOOP3
                        VAL_CVOL = CUT_CELL(ICC2)%VOLUME(JCC2)
                        VAL_UNKZ = CUT_CELL(ICC2)%UNKZ(JCC2)
                     ENDIF
                  CASE(KAXIS)
                     IF(CCVAR(I,J,K+ILH,IBM_UNKZ) <= 0) THEN ! Cut - cell. Array IBM_RCFACE_VEL is used.
                        IRC = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
                        ICC2= MESHES(NM)%IBM_RCFACE_VEL(IRC)%CELL_LIST(2,LOWHIGH,1)
                        JCC2= MESHES(NM)%IBM_RCFACE_VEL(IRC)%CELL_LIST(3,LOWHIGH,1)
                        IF ( CUT_CELL(ICC2)%VOLUME(JCC2) < VAL_CVOL) CYCLE IFC_LOOP3
                        IF ( CUT_CELL(ICC2)%UNKZ(JCC2) <= 0) CYCLE IFC_LOOP3
                        VAL_CVOL = CUT_CELL(ICC2)%VOLUME(JCC2)
                        VAL_UNKZ = CUT_CELL(ICC2)%UNKZ(JCC2)
                     ENDIF
                  END SELECT

               CASE(IBM_FTYPE_CFGAS) ! 2. Check for large surrounding cut-cells:

                  IFC2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
                  IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)

                  ICC2    = CUT_FACE(IFC2)%CELL_LIST(2,LOWHIGH,IFACE2)
                  JCC2    = CUT_FACE(IFC2)%CELL_LIST(3,LOWHIGH,IFACE2)

                  IF ( CUT_CELL(ICC2)%VOLUME(JCC2) < VAL_CVOL) CYCLE IFC_LOOP3
                  IF ( CUT_CELL(ICC2)%UNKZ(JCC2) <= 0) CYCLE IFC_LOOP3

                  VAL_CVOL = CUT_CELL(ICC2)%VOLUME(JCC2)
                  VAL_UNKZ = CUT_CELL(ICC2)%UNKZ(JCC2)

               END SELECT

            ENDDO IFC_LOOP3

            ! This small cut-cell still has an undefined unknown, redo link-loop to test for updated unknown number on
            ! neighbors:
            IF (VAL_UNKZ <= 0) THEN
               QUITLINK_FLG = .FALSE.
            ENDIF

            CUT_CELL(ICC)%UNKZ(JCC) = VAL_UNKZ
         ENDDO
      ENDDO

      IF (QUITLINK_FLG) EXIT LINK_LOOP

   ENDDO LINK_LOOP

ENDDO MAIN_MESH_LOOP3

! Exchange Guardcell + guard cc information on IBM_UNKZ:
CALL FILL_UNKZ_GUARDCELLS

RETURN
END SUBROUTINE GET_MATRIX_INDEXES_Z

! ---------------------------- SET_CUTCELLS -------------------------------------

SUBROUTINE SET_CUTCELLS_3D
USE MPI
USE COMP_FUNCTIONS, ONLY: CURRENT_TIME
IMPLICIT NONE

! Local indexes:
INTEGER :: ILO,IHI,JLO,JHI,KLO,KHI
INTEGER :: I,J,K,KK
INTEGER :: X1AXIS, X2AXIS, X3AXIS
INTEGER :: XIAXIS, XJAXIS, XKAXIS
INTEGER :: X2LO, X2HI, X3LO, X3HI
INTEGER :: X2LO_CELL, X2HI_CELL, X3LO_CELL, X3HI_CELL
INTEGER :: ISTR, IEND, JSTR, JEND, KSTR, KEND
INTEGER :: NM, NOM

! Miscellaneous:
REAL(EB), DIMENSION(MAX_DIM) :: PLNORMAL
INTEGER,  DIMENSION(MAX_DIM) :: INDX1
REAL(EB) :: X1PLN, X3RAY
REAL(EB) :: DX2_MIN, DX3_MIN
LOGICAL :: TRI_ONPLANE_ONLY
LOGICAL, SAVE :: FIRST_CALL = .TRUE.
INTEGER :: IBM_CUTCELLS_FOUND_MESH
INTEGER :: NCUTFACE_IAXIS, NCUTFACE_JAXIS, NCUTFACE_KAXIS, ICE1, ICF1, NFACE, IERR, &
           NCUTEDGE_IBCC, NCUTEDGE_IBCF
REAL(EB):: CF_AREA_IAXIS=0._EB, CF_AREA_JAXIS=0._EB, CF_AREA_KAXIS=0._EB, &
           CF_INXAREA_IAXIS=0._EB,CF_INXAREA_JAXIS=0._EB,CF_INXAREA_KAXIS=0._EB, &
           CF_INXSQAREA_IAXIS=0._EB,CF_INXSQAREA_JAXIS=0._EB,CF_INXSQAREA_KAXIS=0._EB, &
           CF_JNYSQAREA_IAXIS=0._EB,CF_JNYSQAREA_JAXIS=0._EB,CF_JNYSQAREA_KAXIS=0._EB, &
           CF_KNZSQAREA_IAXIS=0._EB,CF_KNZSQAREA_JAXIS=0._EB,CF_KNZSQAREA_KAXIS=0._EB
REAL(EB):: SLEN_GEOM, AREA_GEOM, VOLUME_GEOM, SLEN_IBCC, SLEN, DV(MAX_DIM), XYZCEN_GEOM(MAX_DIM), &
           DM_XYZCEN(MAX_DIM), CCGP_XYZCEN(MAX_DIM), DM_XYZCEN_AUX(MAX_DIM), CCGP_XYZCEN_AUX(MAX_DIM)
INTEGER :: SEG(NOD1:NOD2), NEDGE, IEDGE, IFACE, IG

INTEGER :: NCUTFACE_INB, ICC1, ICC2, NCELL, IGC
REAL(EB):: CF_AREA_INB=0._EB, CF_INXAREA_INB=0._EB, CF_INXSQAREA_INB=0._EB, &
           CF_JNYSQAREA_INB=0._EB, CF_KNZSQAREA_INB=0._EB, CF_AREA_INB_AUX=0._EB
REAL(EB):: CC_VOLUME_INB=0._EB, DM_VOLUME=0._EB, GP_VOLUME=0._EB, &
           CC_VOLUME_INB_AUX=0._EB, DM_VOLUME_AUX=0._EB, GP_VOLUME_AUX=0._EB

LOGICAL, ALLOCATABLE, DIMENSION(:) :: CC_COMPUTE_MESH

REAL(EB) :: TNOW

LOGICAL :: WRITE_CFACE_STATS = .FALSE.

INTEGER, SAVE :: CALL_COUNT = 0

#ifdef DEBUG_SET_CUTCELLS
#define WRITE_GEOM_DEBUG
#endif
#ifdef WRITE_GEOM_DEBUG
REAL(EB):: VERT_AUX(IAXIS:KAXIS)
INTEGER :: ING,INOD,IWSEL,IEL,FACE_AUX(NOD1:NOD3),VOL_AUX(NOD1:NOD4)
CHARACTER(30) :: FILENAME
#endif


! Reset variables:
IBM_NEDGECROSS = 0
IBM_NCUTEDGE   = 0
IBM_NCUTFACE   = 0
IBM_NCUTCELL   = 0

IF (FIRST_CALL) THEN

   ! Initialize GEOMETRY fields used by CC_IBM:
   CALL IBM_INIT_GEOM
   FIRST_CALL = .FALSE.

ENDIF

TNOW=CURRENT_TIME()

#ifdef WRITE_GEOM_DEBUG

! Write meshes file:
WRITE(FILENAME,'(A)') "./GEOMETRY_MESHES.dat"
OPEN(UNIT=33, file=TRIM(FILENAME), status='unknown')
MESH_LOOP : DO NM=1,NMESHES

   IF (PROCESS(NM)/=MYID) CYCLE

   ! Mesh sizes:
   NXB=MESHES(NM)%IBAR
   NYB=MESHES(NM)%JBAR
   NZB=MESHES(NM)%KBAR

   WRITE(33,'(4I8,6F16.8)') NM,NXB,NYB,NZB,MESHES(NM)%X(0),MESHES(NM)%X(NXB),&
                                           MESHES(NM)%Y(0),MESHES(NM)%Y(NYB),&
                                           MESHES(NM)%Z(0),MESHES(NM)%Z(NZB)
ENDDO MESH_LOOP
CLOSE(33)

! Write geometry file:
GEOM_LOOP : DO ING=1,N_GEOMETRY

   ! Write Vertices:
   WRITE(FILENAME,'(A,I4.4,A)') "./GEOMETRY_",ING,"_VERTS.dat"
   OPEN(UNIT=33, file=TRIM(FILENAME), status='unknown')
   DO INOD=1,GEOMETRY(ING)%N_VERTS
      VERT_AUX(IAXIS:KAXIS) = GEOMETRY(ING)%VERTS(MAX_DIM*(INOD-1)+1:MAX_DIM*INOD)
      WRITE(33,'(3F22.14)') VERT_AUX(IAXIS:KAXIS)
   ENDDO
   CLOSE(33)

   ! Write faces:
   WRITE(FILENAME,'(A,I4.4,A)') "./GEOMETRY_",ING,"_FACES.dat"
   OPEN(UNIT=33, file=TRIM(FILENAME), status='unknown')
   DO IWSEL=1,GEOMETRY(ING)%N_FACES
      FACE_AUX(NOD1:NOD3)=GEOMETRY(ING)%FACES(NODS_WSEL*(IWSEL-1)+1:NODS_WSEL*IWSEL)
      WRITE(33,'(3I10)') FACE_AUX(NOD1:NOD3)
   ENDDO
   CLOSE(33)

   ! Write Volumes:
   WRITE(FILENAME,'(A,I4.4,A)') "./GEOMETRY_",ING,"_VOLUS.dat"
   OPEN(UNIT=33, file=TRIM(FILENAME), status='unknown')
   DO IEL=1,GEOMETRY(ING)%N_VOLUS
      VOL_AUX(NOD1:NOD4)=GEOMETRY(ING)%VOLUS(NODS_VLEL*(IEL-1)+1:NODS_VLEL*IEL)
      WRITE(33,'(4I10)') VOL_AUX(NOD1:NOD4)
   ENDDO
   CLOSE(33)

ENDDO GEOM_LOOP
#endif

! Select MESHES assigned to processor and OMESHES of these. Cut-cells will be computed for all of them.
ALLOCATE(CC_COMPUTE_MESH(1:NMESHES)); CC_COMPUTE_MESH = .FALSE.
DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
   CC_COMPUTE_MESH(NM)=.TRUE. ! Compute cut-cells for my meshes.
   DO NOM=1,NMESHES
      IF (MESHES(NM)%OMESH(NOM)%NIC_R > 0) CC_COMPUTE_MESH(NOM)=.TRUE. ! There are cells from mesh NOM that are
                                                                       ! guardcells of mesh NM.
   ENDDO
ENDDO

! Main Loop over Meshes
MAIN_MESH_LOOP : DO NM=1,NMESHES

   IF (.NOT.CC_COMPUTE_MESH(NM)) CYCLE ! Only MESHES assigned to processor and OMESHES of these.
   IF (PERIODIC_TEST==105 .AND. PROCESS(NM)/=MYID) CYCLE ! Don't do OMESHES for PERIODIC_TEST==105

   CALL POINT_TO_MESH(NM)

   ! Mesh sizes:
   NXB=IBAR
   NYB=JBAR
   NZB=KBAR

   ! X direction bounds:
   ILO_FACE = 0                    ! Low mesh boundary face index.
   IHI_FACE = IBAR                 ! High mesh boundary face index.
   ILO_CELL = ILO_FACE + FCELL     ! First internal cell index. See notes.
   IHI_CELL = IHI_FACE + FCELL - 1 ! Last internal cell index.
   ISTR     = ILO_FACE - NGUARD    ! Allocation start x arrays.
   IEND     = IHI_FACE + NGUARD    ! Allocation end x arrays.

   ! Y direction bounds:
   JLO_FACE = 0                    ! Low mesh boundary face index.
   JHI_FACE = JBAR                 ! High mesh boundary face index.
   JLO_CELL = JLO_FACE + FCELL     ! First internal cell index. See notes.
   JHI_CELL = JHI_FACE + FCELL - 1 ! Last internal cell index.
   JSTR     = JLO_FACE - NGUARD    ! Allocation start y arrays.
   JEND     = JHI_FACE + NGUARD    ! Allocation end y arrays.

   ! Z direction bounds:
   KLO_FACE = 0                    ! Low mesh boundary face index.
   KHI_FACE = KBAR                 ! High mesh boundary face index.
   KLO_CELL = KLO_FACE + FCELL     ! First internal cell index. See notes.
   KHI_CELL = KHI_FACE + FCELL - 1 ! Last internal cell index.
   KSTR     = KLO_FACE - NGUARD    ! Allocation start z arrays.
   KEND     = KHI_FACE + NGUARD    ! Allocation end z arrays.

   ! Define grid arrays for this mesh:
   ! Populate position and cell size arrays: Uniform grid implementation.
   ! X direction:
   ALLOCATE(DXCELL(ISTR:IEND)); DXCELL(ILO_CELL-1:IHI_CELL+1) = DX(ILO_CELL-1:IHI_CELL+1)
   DO IGC=2,NGUARD
      DXCELL(ILO_CELL-IGC)=DXCELL(ILO_CELL-IGC+1)
      DXCELL(IHI_CELL+IGC)=DXCELL(IHI_CELL+IGC-1)
   ENDDO
   ALLOCATE(DXFACE(ISTR:IEND)); DXFACE(ILO_FACE:IHI_FACE)= DXN(ILO_FACE:IHI_FACE)
   DO IGC=1,NGUARD
      DXFACE(ILO_FACE-IGC)=DXFACE(ILO_FACE-IGC+1)
      DXFACE(IHI_FACE+IGC)=DXFACE(ILO_FACE+IGC-1)
   ENDDO
   ALLOCATE(XCELL(ISTR:IEND));  XCELL = 1._EB/GEOMEPS ! Initialize huge.
   XCELL(ILO_CELL-1:IHI_CELL+1) = XC(ILO_CELL-1:IHI_CELL+1)
   DO IGC=2,NGUARD
      XCELL(ILO_CELL-IGC)=XCELL(ILO_CELL-IGC+1)-DXFACE(ILO_FACE-IGC+1)
      XCELL(IHI_CELL+IGC)=XCELL(IHI_CELL+IGC-1)+DXFACE(IHI_FACE+IGC-1)
   ENDDO
   ALLOCATE(XFACE(ISTR:IEND));  XFACE = 1._EB/GEOMEPS ! Initialize huge.
   XFACE(ILO_FACE:IHI_FACE) = X(ILO_FACE:IHI_FACE)
   DO IGC=1,NGUARD
      XFACE(ILO_FACE-IGC)=XFACE(ILO_FACE-IGC+1)-DXCELL(ILO_CELL-IGC)
      XFACE(IHI_FACE+IGC)=XFACE(IHI_FACE+IGC-1)+DXCELL(IHI_CELL+IGC)
   ENDDO

   ! Y direction:
   ALLOCATE(DYCELL(JSTR:JEND)); DYCELL(JLO_CELL-1:JHI_CELL+1)= DY(JLO_CELL-1:JHI_CELL+1)
   DO IGC=2,NGUARD
      DYCELL(JLO_CELL-IGC)=DYCELL(JLO_CELL-IGC+1)
      DYCELL(JHI_CELL+IGC)=DYCELL(JHI_CELL+IGC-1)
   ENDDO
   ALLOCATE(DYFACE(JSTR:JEND)); DYFACE(JLO_FACE:JHI_FACE)= DYN(JLO_FACE:JHI_FACE)
   DO IGC=1,NGUARD
      DYFACE(JLO_FACE-IGC)=DYFACE(JLO_FACE-IGC+1)
      DYFACE(JHI_FACE+IGC)=DYFACE(JHI_FACE+IGC-1)
   ENDDO
   ALLOCATE(YCELL(JSTR:JEND));  YCELL = 1._EB/GEOMEPS ! Initialize huge.
   YCELL(JLO_CELL-1:JHI_CELL+1) = YC(JLO_CELL-1:JHI_CELL+1)
   DO IGC=2,NGUARD
      YCELL(JLO_CELL-IGC)=YCELL(JLO_CELL-IGC+1)-DYFACE(JLO_FACE-IGC+1)
      YCELL(JHI_CELL+IGC)=YCELL(JHI_CELL+IGC-1)+DYFACE(JHI_FACE+IGC-1)
   ENDDO
   ALLOCATE(YFACE(JSTR:JEND));  YFACE = 1._EB/GEOMEPS ! Initialize huge.
   YFACE(JLO_FACE:JHI_FACE) = Y(JLO_FACE:JHI_FACE)
   DO IGC=1,NGUARD
      YFACE(JLO_FACE-IGC)=YFACE(JLO_FACE-IGC+1)-DYCELL(JLO_CELL-IGC)
      YFACE(JHI_FACE+IGC)=YFACE(JHI_FACE+IGC-1)+DYCELL(JHI_CELL+IGC)
   ENDDO

   ! Z direction:
   ALLOCATE(DZCELL(KSTR:KEND)); DZCELL(KLO_CELL-1:KHI_CELL+1)= DZ(KLO_CELL-1:KHI_CELL+1)
   DO IGC=2,NGUARD
      DZCELL(KLO_CELL-IGC)=DZCELL(KLO_CELL-IGC+1)
      DZCELL(KHI_CELL+IGC)=DZCELL(KHI_CELL+IGC-1)
   ENDDO
   ALLOCATE(DZFACE(KSTR:KEND)); DZFACE(KLO_FACE:KHI_FACE)= DZN(KLO_FACE:KHI_FACE)
   DO IGC=1,NGUARD
      DZFACE(KLO_FACE-IGC)=DZFACE(KLO_FACE-IGC+1)
      DZFACE(KHI_FACE+IGC)=DZFACE(KHI_FACE+IGC-1)
   ENDDO
   ALLOCATE(ZCELL(KSTR:KEND));  ZCELL = 1._EB/GEOMEPS ! Initialize huge.
   ZCELL(KLO_CELL-1:KHI_CELL+1) = ZC(KLO_CELL-1:KHI_CELL+1)
   DO IGC=2,NGUARD
      ZCELL(KLO_CELL-IGC)=ZCELL(KLO_CELL-IGC+1)-DZFACE(KLO_FACE-IGC+1)
      ZCELL(KHI_CELL+IGC)=ZCELL(KHI_CELL+IGC-1)+DZFACE(KHI_FACE+IGC-1)
   ENDDO
   ALLOCATE(ZFACE(KSTR:KEND));  ZFACE = 1._EB/GEOMEPS ! Initialize huge.
   ZFACE(KLO_FACE:KHI_FACE) = Z(KLO_FACE:KHI_FACE)
   DO IGC=1,NGUARD
      ZFACE(KLO_FACE-IGC)=ZFACE(KLO_FACE-IGC+1)-DZCELL(KLO_CELL-IGC)
      ZFACE(KHI_FACE+IGC)=ZFACE(KHI_FACE+IGC-1)+DZCELL(KHI_CELL+IGC)
   ENDDO

   ! Initialize CC_IBM arrays for mesh NM:
   ! Vertices:
   IF (.NOT. ALLOCATED(MESHES(NM)%VERTVAR)) &
      ALLOCATE(MESHES(NM)%VERTVAR(ISTR:IEND,JSTR:JEND,KSTR:KEND,IBM_NVVARS))
   MESHES(NM)%VERTVAR = 0
   MESHES(NM)%VERTVAR(:,:,:,IBM_VGSC) = IBM_GASPHASE

   ! Cartesian Edges:
   IF (.NOT. ALLOCATED(MESHES(NM)%ECVAR)) &
      ALLOCATE(MESHES(NM)%ECVAR(ISTR:IEND,JSTR:JEND,KSTR:KEND,IBM_NEVARS,MAX_DIM))
   MESHES(NM)%ECVAR = 0
   MESHES(NM)%ECVAR(:,:,:,IBM_EGSC,:) = IBM_GASPHASE

   ! Cartesian Faces:
   IF (.NOT. ALLOCATED(MESHES(NM)%FCVAR)) &
      ALLOCATE(MESHES(NM)%FCVAR(ISTR:IEND,JSTR:JEND,KSTR:KEND,IBM_NFVARS,MAX_DIM))
   MESHES(NM)%FCVAR = 0
   MESHES(NM)%FCVAR(:,:,:,IBM_FGSC,:) = IBM_GASPHASE

   ! Cartesian cells:
   IF (.NOT. ALLOCATED(MESHES(NM)%CCVAR)) &
      ALLOCATE(MESHES(NM)%CCVAR(ISTR:IEND,JSTR:JEND,KSTR:KEND,IBM_NCVARS))
   MESHES(NM)%CCVAR = 0
   MESHES(NM)%CCVAR(:,:,:,IBM_CGSC) = IBM_GASPHASE

   ! Define EDGE_CROSS, CUT_EDGE, CUT_FACE and CUT_CELL arrays size for this mesh, and allocate:
   IF(PERIODIC_TEST==11)THEN
      IBM_CUTCELLS_FOUND_MESH =  (NXB+2) / 2 * (NYB+1) * (NZB+1)
   ELSEIF(PERIODIC_TEST==7) THEN
      IBM_CUTCELLS_FOUND_MESH =  (NXB+1) * (NYB+1) * (NZB+1) / 4
   ELSE
      IBM_CUTCELLS_FOUND_MESH = 28 * NXB * NYB * NZB / (NXB + NYB + NZB) ! Beast approach. NEED TO REFINE THIS.
   ENDIF

   ! Here we have to allocate the size of MESHES(NM)%EDGE_CROSS:
   MESHES(NM)%N_EDGE_CROSS = 0 ! Reset EDCROSS counter for mesh NM.
   MESHES(NM)%MAX_N_EDGECROSS_MESH = 3 * IBM_CUTCELLS_FOUND_MESH
   IF (ALLOCATED(MESHES(NM)%EDGE_CROSS)) DEALLOCATE(MESHES(NM)%EDGE_CROSS)
   ALLOCATE( MESHES(NM)%EDGE_CROSS( MESHES(NM)%MAX_N_EDGECROSS_MESH ) )

   ! Here we have to allocate the size of MESHES(NM)%CUT_EDGE:
   MESHES(NM)%N_CUTEDGE_MESH = 0   ! Reset CUTEDGE counter for mesh NM.
   MESHES(NM)%MAX_N_CUTEDGE_MESH = 3 * IBM_CUTCELLS_FOUND_MESH
   IF (ALLOCATED(MESHES(NM)%CUT_EDGE)) DEALLOCATE(MESHES(NM)%CUT_EDGE)
   ALLOCATE( MESHES(NM)%CUT_EDGE( MESHES(NM)%MAX_N_CUTEDGE_MESH ) )

   ! Here we have to allocate the size of MESHES(NM)%CUT_FACE:
   MESHES(NM)%N_CUTFACE_MESH     = 0   ! Reset CUTFACE counter for mesh NM.
   MESHES(NM)%N_BBCUTFACE_MESH   = 0; MESHES(NM)%N_GCCUTFACE_MESH = 0
   MESHES(NM)%MAX_N_CUTFACE_MESH = 3 * IBM_CUTCELLS_FOUND_MESH
   IF (ALLOCATED(MESHES(NM)%CUT_FACE)) DEALLOCATE(MESHES(NM)%CUT_FACE)
   ALLOCATE( MESHES(NM)%CUT_FACE( MESHES(NM)%MAX_N_CUTFACE_MESH ) )

   ! Here we have to allocate the size of MESHES(NM)%CUT_CELL:
   MESHES(NM)%N_CUTCELL_MESH     = 0   ! Reset CUTCELL counter for mesh NM.
   MESHES(NM)%N_GCCUTCELL_MESH   = 0
   MESHES(NM)%MAX_N_CUTCELL_MESH = IBM_CUTCELLS_FOUND_MESH
   IF (ALLOCATED(MESHES(NM)%CUT_CELL)) DEALLOCATE(MESHES(NM)%CUT_CELL)
   ALLOCATE( MESHES(NM)%CUT_CELL( MESHES(NM)%MAX_N_CUTCELL_MESH ) )

   ! Do Loop for different x1 planes:
   X1AXIS_LOOP : DO X1AXIS=IAXIS,KAXIS

      SELECT CASE(X1AXIS)
       CASE(IAXIS)

          PLNORMAL = (/ 1._EB, 0._EB, 0._EB/)
          ILO = ILO_FACE-CCGUARD;  IHI = IHI_FACE+CCGUARD
          JLO = JLO_FACE;  JHI = JLO_FACE
          KLO = KLO_FACE;  KHI = KLO_FACE

          ! x2, x3 axes parameters:
          X2AXIS = JAXIS; X2LO = JLO_FACE-CCGUARD; X2HI = JHI_FACE+CCGUARD
          X3AXIS = KAXIS; X3LO = KLO_FACE-CCGUARD; X3HI = KHI_FACE+CCGUARD

          ! location in I,J,K of x2,x2,x3 axes:
          XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS

          ! Face coordinates in x1,x2,x3 axes:
          ALLOCATE(X1FACE(ISTR:IEND),DX1FACE(ISTR:IEND))
          X1FACE = XFACE; DX1FACE = DXFACE
          ALLOCATE(X2FACE(JSTR:JEND),DX2FACE(JSTR:JEND))
          X2FACE = YFACE; DX2FACE = DYFACE
          ALLOCATE(X3FACE(KSTR:KEND),DX3FACE(KSTR:KEND))
          X3FACE = ZFACE; DX3FACE = DZFACE

          ! x2 cell center parameters:
          X2LO_CELL = JLO_CELL-CCGUARD; X2HI_CELL = JHI_CELL+CCGUARD
          ALLOCATE(X2CELL(JSTR:JEND),DX2CELL(JSTR:JEND))
          X2CELL = YCELL; DX2CELL = DYCELL

          ! x3 cell center parameters:
          X3LO_CELL = KLO_CELL-CCGUARD; X3HI_CELL = KHI_CELL+CCGUARD
          ALLOCATE(X3CELL(KSTR:KEND),DX3CELL(KSTR:KEND))
          X3CELL = ZCELL; DX3CELL = DZCELL

       CASE(JAXIS)

          PLNORMAL = (/ 0._EB, 1._EB, 0._EB/)
          ILO = ILO_FACE;  IHI = ILO_FACE
          JLO = JLO_FACE-CCGUARD;  JHI = JHI_FACE+CCGUARD
          KLO = KLO_FACE;  KHI = KLO_FACE

          ! x2, x3 axes parameters:
          X2AXIS = KAXIS; X2LO = KLO_FACE-CCGUARD; X2HI = KHI_FACE+CCGUARD
          X3AXIS = IAXIS; X3LO = ILO_FACE-CCGUARD; X3HI = IHI_FACE+CCGUARD

          ! location in I,J,K of x2,x2,x3 axes:
          XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS

          ! Face coordinates in x1,x2,x3 axes:
          ALLOCATE(X1FACE(JSTR:JEND),DX1FACE(JSTR:JEND))
          X1FACE = YFACE; DX1FACE = DYFACE
          ALLOCATE(X2FACE(KSTR:KEND),DX2FACE(KSTR:KEND))
          X2FACE = ZFACE; DX2FACE = DZFACE
          ALLOCATE(X3FACE(ISTR:IEND),DX3FACE(ISTR:IEND))
          X3FACE = XFACE; DX3FACE = DXFACE

          ! x2 cell center parameters:
          X2LO_CELL = KLO_CELL-CCGUARD; X2HI_CELL = KHI_CELL+CCGUARD
          ALLOCATE(X2CELL(KSTR:KEND),DX2CELL(KSTR:KEND))
          X2CELL = ZCELL; DX2CELL = DZCELL

          ! x3 cell center parameters:
          X3LO_CELL = ILO_CELL-CCGUARD; X3HI_CELL = IHI_CELL+CCGUARD
          ALLOCATE(X3CELL(ISTR:IEND),DX3CELL(ISTR:IEND))
          X3CELL = XCELL; DX3CELL = DXCELL

       CASE(KAXIS)

          PLNORMAL = (/ 0._EB, 0._EB, 1._EB/)
          ILO = ILO_FACE;  IHI = ILO_FACE
          JLO = JLO_FACE;  JHI = JLO_FACE
          KLO = KLO_FACE-CCGUARD;  KHI = KHI_FACE+CCGUARD

          ! x2, x3 axes parameters:
          X2AXIS = IAXIS; X2LO = ILO_FACE-CCGUARD; X2HI = IHI_FACE+CCGUARD
          X3AXIS = JAXIS; X3LO = JLO_FACE-CCGUARD; X3HI = JHI_FACE+CCGUARD

          ! location in I,J,K of x2,x2,x3 axes:
          XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS

          ! Face coordinates in x1,x2,x3 axes:
          ALLOCATE(X1FACE(KSTR:KEND),DX1FACE(KSTR:KEND))
          X1FACE = ZFACE; DX1FACE = DZFACE
          ALLOCATE(X2FACE(ISTR:IEND),DX2FACE(ISTR:IEND))
          X2FACE = XFACE; DX2FACE = DXFACE
          ALLOCATE(X3FACE(JSTR:JEND),DX3FACE(JSTR:JEND))
          X3FACE = YFACE; DX3FACE = DYFACE

          ! x2 cell center parameters:
          X2LO_CELL = ILO_CELL-CCGUARD; X2HI_CELL = IHI_CELL+CCGUARD
          ALLOCATE(X2CELL(ISTR:IEND),DX2CELL(ISTR:IEND))
          X2CELL = XCELL; DX2CELL = DXCELL

          ! x3 cell center parameters:
          X3LO_CELL = JLO_CELL-CCGUARD; X3HI_CELL = JHI_CELL+CCGUARD
          ALLOCATE(X3CELL(JSTR:JEND),DX3CELL(JSTR:JEND))
          X3CELL = YCELL; DX3CELL = DYCELL

      END SELECT

      ! Loop Coordinate Planes:
      DO K=KLO,KHI
         DO J=JLO,JHI
            DO I=ILO,IHI

               ! Which Plane?
               INDX1(IAXIS:KAXIS) = (/ I, J, K /)
               X1PLN = X1FACE(INDX1(X1AXIS))

               ! Get intersection of body on plane defined by X1PLN, normal to X1AXIS:
               DX2_MIN = MINVAL(DX2CELL(X2LO_CELL:X2HI_CELL))
               DX3_MIN = MINVAL(DX3CELL(X3LO_CELL:X3HI_CELL))
               TRI_ONPLANE_ONLY = .FALSE.
               CALL GET_BODINT_PLANE(X1AXIS,X1PLN,PLNORMAL,X2AXIS,X3AXIS,DX2_MIN,DX3_MIN,TRI_ONPLANE_ONLY)

               ! Test that there is an intersection:
               IF ((BODINT_PLANE%NSGLS+BODINT_PLANE%NSEGS+BODINT_PLANE%NTRIS) == 0) CYCLE

               ! Drop if node locations outside block plane area:
               IF ((X2FACE(X2LO)-MAXVAL(BODINT_PLANE%XYZ(X2AXIS,1:BODINT_PLANE%NNODS))) > GEOMEPS) CYCLE
               IF ((MINVAL(BODINT_PLANE%XYZ(X2AXIS,1:BODINT_PLANE%NNODS))-X2FACE(X2HI)) > GEOMEPS) CYCLE
               IF ((X3FACE(X3LO)-MAXVAL(BODINT_PLANE%XYZ(X3AXIS,1:BODINT_PLANE%NNODS))) > GEOMEPS) CYCLE
               IF ((MINVAL(BODINT_PLANE%XYZ(X3AXIS,1:BODINT_PLANE%NNODS))-X3FACE(X3HI)) > GEOMEPS) CYCLE

               ! For plane normal to X1AXIS, shoot rays along X2AXIS on all X3AXIS gridline
               ! locations, get intersection data: Loop x3 axis locations
               DO KK=X3LO,X3HI

                  ! x3 location of ray along x2, on the x2-x3 plane:
                  X3RAY = X3FACE(KK)

                  ! Intersections along x2 for X3RAY x3 location:
                  CALL GET_X2_INTERSECTIONS(X2AXIS,X3AXIS,X3RAY,X1PLN)

                  ! Drop x2 ray if all intersections are outside of the MESH block domain:
                  IF (IBM_N_CRS > 0) THEN
                     IF ((X2FACE(X2LO)-IBM_SVAR_CRS(IBM_N_CRS)) > GEOMEPS) THEN
                        CYCLE
                     ELSEIF (IBM_SVAR_CRS(1)-X2FACE(X2HI) > GEOMEPS) THEN
                        CYCLE
                     ENDIF
                  ENDIF

                  ! Now for this ray, set vertex types in MESHES(NM)%VERTVAR(:,:,:,IBM_VGSC):
                  CALL GET_X2_VERTVAR(X1AXIS,X2LO,X2HI,NM,I,KK)

                  ! Now define Crossings on Cartesian Edges and Body segments:
                  ! Cartesian cut-edges:
                  CALL GET_CARTEDGE_CUTEDGES(X1AXIS,X2AXIS,X3AXIS,XIAXIS,XJAXIS,XKAXIS, &
                                             NM,X2LO_CELL,X2HI_CELL,INDX1,KK)

                  ! Set segment crossings:
                  ! This data is defined by plane, add to current:
                  ! - BODINT_PLANE : Data structure with information for crossings on
                  !                      body segments.
                  !                   % NBCROSS(1:NSEGS)        = Number of crossings
                  !                                               on the segment.
                  !                   % SVAR(1:NBCROSS,1:NSEGS) = distance from node 1
                  !                                               along the segment.
                  CALL GET_BODX2_INTERSECTIONS(X2AXIS,X3AXIS,X3RAY)

               ENDDO ! KK - x3 gridlines.

               ! Now for segments not aligned with x3, define
               ! intersections with grid line vertices:
               CALL GET_BODX3_INTERSECTIONS(X2AXIS,X3AXIS,X2LO,X2HI)

               ! After these loops all segments should contain points from Node1,
               ! cross 1, cross 2, ..., Node2, in ascending sbod order.
               ! Time to generate the body IBM_INBOUNDARY edges on faces and add
               ! to MESHES(NM)%CUT_EDGE:
               CALL GET_CARTFACE_CUTEDGES(X1AXIS,X2AXIS,X3AXIS,                   &
                                          XIAXIS,XJAXIS,XKAXIS,NM,                &
                                          X2LO,X2HI,X3LO,X3HI,X2LO_CELL,X2HI_CELL,&
                                          X3LO_CELL,X3HI_CELL,INDX1)

            ENDDO ! I index
         ENDDO ! J index
      ENDDO ! K index

      ! Deallocate local plane arrays:
      DEALLOCATE(X1FACE,X2FACE,X3FACE,X2CELL,X3CELL)
      DEALLOCATE(DX1FACE,DX2FACE,DX3FACE,DX2CELL,DX3CELL)

   ENDDO X1AXIS_LOOP

   ! Now Define the INBOUNDARY cut-edge inside Cartesian cells:
   CALL GET_CARTCELL_CUTEDGES(NM,ISTR,IEND,JSTR,JEND,KSTR,KEND)

   ! 1. Cartesian GASPHASE cut-faces:
   ! Loops for IAXIS, JAXIS, KAXIS faces: For FCVAR i,j,k, axis
   ! - Define Cartesian Boundary Edges indexes.
   ! - From ECVAR(i,j,k,IDCE,axis) figure out Entries in CUT_EDGE (GASPHASE segs).
   ! - From FCVAR(i,j,k,IDCE,axis) figure out entries in CUT_EDGE (INBOUNDCF segs).
   ! - Reorder Edges, figure out if there are disjoint areas present.
   ! - Load into CUT_FACE <=> FCVAR(i,j,k,IDCF,axis).
   CALL GET_CARTFACE_CUTFACES(NM,ISTR,IEND,JSTR,JEND,KSTR,KEND,.TRUE.)

   ! 2. INBOUNDARY cut-faces:
   CALL GET_CARTCELL_CUTFACES(NM,ISTR,IEND,JSTR,JEND,KSTR,KEND,.TRUE.)

   ! Guard-cell Cartesian GASPHASE and INBOUNDARY cut-faces:
   CALL GET_CARTFACE_CUTFACES(NM,ISTR,IEND,JSTR,JEND,KSTR,KEND,.FALSE.)
   CALL GET_CARTCELL_CUTFACES(NM,ISTR,IEND,JSTR,JEND,KSTR,KEND,.FALSE.)

   ! Finally: Definition of cut-cells:
   CALL GET_CARTCELL_CUTCELLS(NM)

   ! Deallocate arrays:
   ! Face centered positions and cell sizes:
   IF (ALLOCATED(XFACE)) DEALLOCATE(XFACE)
   IF (ALLOCATED(YFACE)) DEALLOCATE(YFACE)
   IF (ALLOCATED(ZFACE)) DEALLOCATE(ZFACE)
   IF (ALLOCATED(DXFACE)) DEALLOCATE(DXFACE)
   IF (ALLOCATED(DYFACE)) DEALLOCATE(DYFACE)
   IF (ALLOCATED(DZFACE)) DEALLOCATE(DZFACE)

   ! Cell centered positions and cell sizes:
   IF (ALLOCATED(XCELL)) DEALLOCATE(XCELL)
   IF (ALLOCATED(YCELL)) DEALLOCATE(YCELL)
   IF (ALLOCATED(ZCELL)) DEALLOCATE(ZCELL)
   IF (ALLOCATED(DXCELL)) DEALLOCATE(DXCELL)
   IF (ALLOCATED(DYCELL)) DEALLOCATE(DYCELL)
   IF (ALLOCATED(DZCELL)) DEALLOCATE(DZCELL)

   ! Here we the SOLID array, to tag when writing slices:

ENDDO MAIN_MESH_LOOP

! Add to SET_CUTCELLS_3D loop time:
T_CC_USED(SET_CUTCELLS_TIME_INDEX) = T_CC_USED(SET_CUTCELLS_TIME_INDEX) + CURRENT_TIME() - TNOW

! Define FDS SOLID array for IBM_SOLID cells:
!CALL SET_FDS_SOLID_CELLS

! Fill Guardcells for CCVAR IBM_CGSC and CUT_CELL for meshes assigned to MPI process:
CALL SET_GC_CUTCELLS_3D

! Allocate and define entries for solid side CFACES:
IF(PERIODIC_TEST/=105) CALL GET_INBCUTFACES_TO_CFACE

! Write out:
! Increasee SET_CUTCELLS_3D call counter by 1:
CALL_COUNT = CALL_COUNT + 1
IF(PERIODIC_TEST==105) THEN
   CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
   IF(CALL_COUNT > 1) RETURN
ENDIF

! Loop over geometry:
SLEN_GEOM = 0._EB; AREA_GEOM = 0._EB; VOLUME_GEOM = 0._EB; XYZCEN_GEOM(IAXIS:KAXIS) = 0._EB
DO IG=1,N_GEOMETRY

   ! Add length of wet surface edges:
   DO IEDGE=1,GEOMETRY(IG)%N_EDGES
      SEG(NOD1:NOD2)  = GEOMETRY(IG)%EDGES(NOD1:NOD2,IEDGE)
      DV(IAXIS:KAXIS) = GEOMETRY(IG)%VERTS(MAX_DIM*(SEG(NOD2)-1)+1:MAX_DIM*SEG(NOD2)) - &
                        GEOMETRY(IG)%VERTS(MAX_DIM*(SEG(NOD1)-1)+1:MAX_DIM*SEG(NOD1))
      SLEN = SQRT( DV(IAXIS)**2._EB + DV(JAXIS)**2._EB + DV(KAXIS)**2._EB )
      SLEN_GEOM = SLEN_GEOM + SLEN
   ENDDO

   ! Add to wet surface Areas:
   DO IFACE=1,GEOMETRY(IG)%N_FACES
      if ( GEOMETRY(IG)%FACES_AREA(IFACE) < GEOMEPS ) &
         print*, "GEOM FACE=",IFACE,", AREA=",GEOMETRY(IG)%FACES_AREA(IFACE)
   ENDDO
   AREA_GEOM = AREA_GEOM + GEOMETRY(IG)%GEOM_AREA

   ! Add to GEOMETRY volume:
   VOLUME_GEOM = VOLUME_GEOM + GEOMETRY(IG)%GEOM_VOLUME

   ! Add to XYZCEN for geometries:
   XYZCEN_GEOM(IAXIS:KAXIS)= XYZCEN_GEOM(IAXIS:KAXIS) + GEOMETRY(IG)%GEOM_VOLUME * GEOMETRY(IG)%GEOM_XYZCEN(IAXIS:KAXIS)
ENDDO
IF(N_GEOMETRY > 0) XYZCEN_GEOM(IAXIS:KAXIS)=XYZCEN_GEOM(IAXIS:KAXIS)/VOLUME_GEOM

! Loop over meshes:
NCUTFACE_INB = 0
CF_AREA_INB=0._EB
CC_VOLUME_INB=0._EB
GP_VOLUME=0._EB
DM_XYZCEN(IAXIS:KAXIS) = 0._EB
CCGP_XYZCEN(IAXIS:KAXIS) = 0._EB
DO NM=1,NMESHES

   CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)

   IF (PROCESS(NM)/=MYID) CYCLE

   DO ICF1 = 1,MESHES(NM)%N_CUTFACE_MESH
     IF (MESHES(NM)%CUT_FACE(ICF1)%STATUS == IBM_INBOUNDARY) THEN
        NFACE = MESHES(NM)%CUT_FACE(ICF1)%NFACE
        CF_AREA_INB = CF_AREA_INB + SUM(MESHES(NM)%CUT_FACE(ICF1)%AREA(1:NFACE))
     ENDIF
   ENDDO

   DO ICC1 = 1,MESHES(NM)%N_CUTCELL_MESH
      NCELL = MESHES(NM)%CUT_CELL(ICC1)%NCELL
      DO ICC2=1,NCELL
         CCGP_XYZCEN(IAXIS:KAXIS) = CCGP_XYZCEN(IAXIS:KAXIS) + MESHES(NM)%CUT_CELL(ICC1)%VOLUME(ICC2) * &
                                                               MESHES(NM)%CUT_CELL(ICC1)%XYZCEN(IAXIS:KAXIS,ICC2)
         IF ( MESHES(NM)%CUT_CELL(ICC1)%VOLUME(ICC2) < 0._EB) &
             WRITE(LU_ERR,*) "Cut-cell=",ICC1,ICC2,", VOL=",MESHES(NM)%CUT_CELL(ICC1)%VOLUME(ICC2)
      ENDDO
      CC_VOLUME_INB = CC_VOLUME_INB + SUM(MESHES(NM)%CUT_CELL(ICC1)%VOLUME(1:NCELL))
   ENDDO

   ! Regular gasphase cells:
   DO K=1,MESHES(NM)%KBAR
      DO J=1,MESHES(NM)%JBAR
         DO I=1,MESHES(NM)%IBAR

            IF ( MESHES(NM)%CCVAR(I,J,K,IBM_CGSC) == IBM_GASPHASE) THEN
              SLEN = MESHES(NM)%DX(I)*MESHES(NM)%DY(J)*MESHES(NM)%DZ(K)
              GP_VOLUME = GP_VOLUME + SLEN
              CCGP_XYZCEN(IAXIS) = CCGP_XYZCEN(IAXIS) + SLEN * MESHES(NM)%XC(I)
              CCGP_XYZCEN(JAXIS) = CCGP_XYZCEN(JAXIS) + SLEN * MESHES(NM)%YC(J)
              CCGP_XYZCEN(KAXIS) = CCGP_XYZCEN(KAXIS) + SLEN * MESHES(NM)%ZC(K)
            ENDIF
         ENDDO
      ENDDO
   ENDDO

   ! Domain volume:
   SLEN = (MESHES(NM)%XF-MESHES(NM)%XS)*(MESHES(NM)%YF-MESHES(NM)%YS)*(MESHES(NM)%ZF-MESHES(NM)%ZS)
   DM_VOLUME = DM_VOLUME + SLEN
   ! Domain Centroid:
   DM_XYZCEN(IAXIS) = DM_XYZCEN(IAXIS) + SLEN * 0.5_EB*(MESHES(NM)%XF+MESHES(NM)%XS)
   DM_XYZCEN(JAXIS) = DM_XYZCEN(JAXIS) + SLEN * 0.5_EB*(MESHES(NM)%YF+MESHES(NM)%YS)
   DM_XYZCEN(KAXIS) = DM_XYZCEN(KAXIS) + SLEN * 0.5_EB*(MESHES(NM)%ZF+MESHES(NM)%ZS)
ENDDO

! Allreduce areas:
IF (N_MPI_PROCESSES > 1) THEN
   CF_AREA_INB_AUX = CF_AREA_INB
   CALL MPI_ALLREDUCE(CF_AREA_INB_AUX, CF_AREA_INB, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD, IERR)
ENDIF

IF (MYID == 0) THEN
WRITE(LU_ERR,"(/A)") ' Computational Geometry: Sanity tests for cut-cell region'
WRITE(LU_ERR,"(A,E11.4,A,E11.4,A,E11.4)") &
' GEOM Surf  Area=',AREA_GEOM,', InBoundary Cut-faces Area=',CF_AREA_INB, &
', Relative Difference=',(AREA_GEOM-CF_AREA_INB)/(AREA_GEOM+GEOMEPS)
ENDIF

! Allreduce Cut-cell, GASPHASE volumes:
IF (N_MPI_PROCESSES > 1) THEN
   CC_VOLUME_INB_AUX = CC_VOLUME_INB
   CALL MPI_ALLREDUCE(CC_VOLUME_INB_AUX, CC_VOLUME_INB, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD, IERR)

   GP_VOLUME_AUX = GP_VOLUME
   CALL MPI_ALLREDUCE(GP_VOLUME_AUX, GP_VOLUME, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD, IERR)

   DM_VOLUME_AUX = DM_VOLUME
   CALL MPI_ALLREDUCE(DM_VOLUME_AUX, DM_VOLUME, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD, IERR)

   CCGP_XYZCEN_AUX(IAXIS:KAXIS) = CCGP_XYZCEN(IAXIS:KAXIS)
   CALL MPI_ALLREDUCE(CCGP_XYZCEN_AUX, CCGP_XYZCEN, 3, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD, IERR)

   DM_XYZCEN_AUX(IAXIS:KAXIS) = DM_XYZCEN(IAXIS:KAXIS)
   CALL MPI_ALLREDUCE(DM_XYZCEN_AUX, DM_XYZCEN, 3, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD, IERR)

ENDIF
CCGP_XYZCEN(IAXIS:KAXIS) = CCGP_XYZCEN(IAXIS:KAXIS) / (CC_VOLUME_INB+GP_VOLUME)
DM_XYZCEN(IAXIS:KAXIS)   = DM_XYZCEN(IAXIS:KAXIS)   / DM_VOLUME


IF (MYID == 0) THEN
WRITE(LU_ERR,"(A,E11.4,A,E11.4,A,E11.4)") &
' GEOM Gas Volume=',DM_VOLUME-VOLUME_GEOM,', Cut/Regl Gas cells Volume=',GP_VOLUME+CC_VOLUME_INB, &
', Relative Difference=',((DM_VOLUME-VOLUME_GEOM)-(GP_VOLUME+CC_VOLUME_INB))/(DM_VOLUME-VOLUME_GEOM)
ENDIF

IF (MYID == 0) THEN
   WRITE(LU_ERR,"(A,3E12.4)") &
   ' GEOM Centroid               =',XYZCEN_GEOM(IAXIS:KAXIS)
   WRITE(LU_ERR,"(A,3E12.4)") &
   ' DOMAIN-GEOM Centroid        =',(DM_XYZCEN(IAXIS:KAXIS)*DM_VOLUME - XYZCEN_GEOM(IAXIS:KAXIS)*VOLUME_GEOM) / &
   (DM_VOLUME-VOLUME_GEOM)
   WRITE(LU_ERR,"(A,3E12.4)") &
   ' Cut/Regl Gas cells Centroid =',CCGP_XYZCEN(IAXIS:KAXIS)
   WRITE(LU_ERR,"(A,3E12.4)") &
   ' Centroid Relative Difference=',CCGP_XYZCEN(IAXIS:KAXIS)-&
   (DM_XYZCEN(IAXIS:KAXIS)*DM_VOLUME - XYZCEN_GEOM(IAXIS:KAXIS)*VOLUME_GEOM) / &
   (DM_VOLUME-VOLUME_GEOM)
ENDIF


! Write out more detailed stats:
!WRITE_CFACE_STATS = .TRUE.
IF (.NOT.WRITE_CFACE_STATS) RETURN

! Loop over meshes:
DO NM=1,NMESHES

   CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)

   IF (PROCESS(NM)/=MYID) CYCLE

   NCUTEDGE_IBCC = 0; SLEN_IBCC = 0._EB
   NCUTEDGE_IBCF = 0
   ! Number of CUT_EDGE for this mesh:
   DO ICE1 = 1,MESHES(NM)%N_CUTEDGE_MESH
      select case(MESHES(NM)%CUT_EDGE(ICE1)%STATUS)
      case(IBM_INBOUNDCC)

         NEDGE = MESHES(NM)%CUT_EDGE(ICE1)%NEDGE
         NCUTEDGE_IBCC = NCUTEDGE_IBCC + NEDGE

         DO IEDGE=1,NEDGE
            SEG(NOD1:NOD2)  = MESHES(NM)%CUT_EDGE(ICE1)%CEELEM(NOD1:NOD2,IEDGE)
            DV(IAXIS:KAXIS) = MESHES(NM)%CUT_EDGE(ICE1)%XYZVERT(IAXIS:KAXIS,SEG(NOD2)) - &
                              MESHES(NM)%CUT_EDGE(ICE1)%XYZVERT(IAXIS:KAXIS,SEG(NOD1))
            SLEN = SQRT( DV(IAXIS)**2._EB + DV(JAXIS)**2._EB + DV(KAXIS)**2._EB )
            SLEN_IBCC = SLEN_IBCC + SLEN
         ENDDO
      case(IBM_INBOUNDCF)
         select case(MESHES(NM)%CUT_EDGE(ICE1)%ijk(4))
              case(IAXIS)
                  if(MESHES(NM)%CUT_EDGE(ICE1)%ijk(IAXIS) == MESHES(NM)%IBAR) CYCLE
              case(JAXIS)
                  if(MESHES(NM)%CUT_EDGE(ICE1)%ijk(JAXIS) == MESHES(NM)%JBAR) CYCLE
              case(KAXIS)
                  if(MESHES(NM)%CUT_EDGE(ICE1)%ijk(KAXIS) == MESHES(NM)%KBAR) CYCLE
         end select
         NCUTEDGE_IBCF = NCUTEDGE_IBCF + MESHES(NM)%CUT_EDGE(ICE1)%NEDGE
      end select
   ENDDO

   WRITE(LU_ERR,*) 'CUTEDGE=',PROCESS(NM),NM,MESHES(NM)%N_CUTEDGE_MESH,MESHES(NM)%N_EDGE_CROSS
   WRITE(LU_ERR,*) 'NCUTEDGE_IBCF =',NCUTEDGE_IBCF
   WRITE(LU_ERR,*) 'NCUTEDGE_IBCC =',NCUTEDGE_IBCC, ', SLEN_IBCC =',SLEN_IBCC,', SLEN_GEOM =',SLEN_GEOM

   NCUTFACE_IAXIS = 0
   NCUTFACE_JAXIS = 0
   NCUTFACE_KAXIS = 0
   CF_AREA_IAXIS=0._EB;      CF_AREA_JAXIS=0._EB;      CF_AREA_KAXIS=0._EB
   CF_INXAREA_IAXIS=0._EB;   CF_INXAREA_JAXIS=0._EB;   CF_INXAREA_KAXIS=0._EB
   CF_INXSQAREA_IAXIS=0._EB; CF_INXSQAREA_JAXIS=0._EB; CF_INXSQAREA_KAXIS=0._EB
   CF_JNYSQAREA_IAXIS=0._EB; CF_JNYSQAREA_JAXIS=0._EB; CF_JNYSQAREA_KAXIS=0._EB
   CF_KNZSQAREA_IAXIS=0._EB; CF_KNZSQAREA_JAXIS=0._EB; CF_KNZSQAREA_KAXIS=0._EB
   NCUTFACE_INB = 0
   CF_AREA_INB=0._EB; CF_INXAREA_INB=0._EB;
   CF_INXSQAREA_INB=0._EB; CF_JNYSQAREA_INB=0._EB; CF_KNZSQAREA_INB=0._EB
   DO ICF1 = 1,MESHES(NM)%N_CUTFACE_MESH
     IF (MESHES(NM)%CUT_FACE(ICF1)%STATUS == IBM_GASPHASE) THEN
        NFACE = MESHES(NM)%CUT_FACE(ICF1)%NFACE
        X1AXIS=MESHES(NM)%CUT_FACE(ICF1)%IJK(MAX_DIM+1)

        SELECT CASE(X1AXIS)
           CASE(IAXIS)
              NCUTFACE_IAXIS = NCUTFACE_IAXIS + NFACE
              CF_AREA_IAXIS = CF_AREA_IAXIS + SUM(MESHES(NM)%CUT_FACE(ICF1)%AREA(1:NFACE))
              CF_INXAREA_IAXIS = CF_INXAREA_IAXIS + SUM(MESHES(NM)%CUT_FACE(ICF1)%INXAREA(1:NFACE))
              CF_INXSQAREA_IAXIS=CF_INXSQAREA_IAXIS+SUM(MESHES(NM)%CUT_FACE(ICF1)%INXSQAREA(1:NFACE))
              CF_JNYSQAREA_IAXIS=CF_JNYSQAREA_IAXIS+SUM(MESHES(NM)%CUT_FACE(ICF1)%JNYSQAREA(1:NFACE))
              CF_KNZSQAREA_IAXIS=CF_KNZSQAREA_IAXIS+SUM(MESHES(NM)%CUT_FACE(ICF1)%KNZSQAREA(1:NFACE))
           CASE(JAXIS)
              NCUTFACE_JAXIS = NCUTFACE_JAXIS + NFACE
              CF_AREA_JAXIS = CF_AREA_JAXIS + SUM(MESHES(NM)%CUT_FACE(ICF1)%AREA(1:NFACE))
              CF_INXAREA_JAXIS = CF_INXAREA_JAXIS + SUM(MESHES(NM)%CUT_FACE(ICF1)%INXAREA(1:NFACE))
              CF_INXSQAREA_JAXIS=CF_INXSQAREA_JAXIS+SUM(MESHES(NM)%CUT_FACE(ICF1)%INXSQAREA(1:NFACE))
              CF_JNYSQAREA_JAXIS=CF_JNYSQAREA_JAXIS+SUM(MESHES(NM)%CUT_FACE(ICF1)%JNYSQAREA(1:NFACE))
              CF_KNZSQAREA_JAXIS=CF_KNZSQAREA_JAXIS+SUM(MESHES(NM)%CUT_FACE(ICF1)%KNZSQAREA(1:NFACE))
           CASE(KAXIS)
              NCUTFACE_KAXIS = NCUTFACE_KAXIS + NFACE
              CF_AREA_KAXIS = CF_AREA_KAXIS + SUM(MESHES(NM)%CUT_FACE(ICF1)%AREA(1:NFACE))
              CF_INXAREA_KAXIS = CF_INXAREA_KAXIS + SUM(MESHES(NM)%CUT_FACE(ICF1)%INXAREA(1:NFACE))
              CF_INXSQAREA_KAXIS=CF_INXSQAREA_KAXIS+SUM(MESHES(NM)%CUT_FACE(ICF1)%INXSQAREA(1:NFACE))
              CF_JNYSQAREA_KAXIS=CF_JNYSQAREA_KAXIS+SUM(MESHES(NM)%CUT_FACE(ICF1)%JNYSQAREA(1:NFACE))
              CF_KNZSQAREA_KAXIS=CF_KNZSQAREA_KAXIS+SUM(MESHES(NM)%CUT_FACE(ICF1)%KNZSQAREA(1:NFACE))
        END SELECT
     ELSE ! IBM_INBOUNDARY..
        NFACE = MESHES(NM)%CUT_FACE(ICF1)%NFACE

        CF_AREA_INB = CF_AREA_INB + SUM(MESHES(NM)%CUT_FACE(ICF1)%AREA(1:NFACE))
        CF_INXAREA_INB = CF_INXAREA_INB + SUM(MESHES(NM)%CUT_FACE(ICF1)%INXAREA(1:NFACE))
        CF_INXSQAREA_INB=CF_INXSQAREA_INB+SUM(MESHES(NM)%CUT_FACE(ICF1)%INXSQAREA(1:NFACE))
        CF_JNYSQAREA_INB=CF_JNYSQAREA_INB+SUM(MESHES(NM)%CUT_FACE(ICF1)%JNYSQAREA(1:NFACE))
        CF_KNZSQAREA_INB=CF_KNZSQAREA_INB+SUM(MESHES(NM)%CUT_FACE(ICF1)%KNZSQAREA(1:NFACE))


     ENDIF
   ENDDO
   WRITE(LU_ERR,*) ' '
   WRITE(LU_ERR,*) 'CUTFACE=',PROCESS(NM),NM,MESHES(NM)%N_CUTFACE_MESH
   WRITE(LU_ERR,*) 'CUTFACE X Y Z=',NCUTFACE_IAXIS,NCUTFACE_JAXIS,NCUTFACE_KAXIS
   WRITE(LU_ERR,*) 'CF_AREA X Y Z=',CF_AREA_IAXIS,CF_AREA_JAXIS,CF_AREA_KAXIS
   WRITE(LU_ERR,*) 'CF_INXAREA X Y Z=',CF_INXAREA_IAXIS,CF_INXAREA_JAXIS,CF_INXAREA_KAXIS
   WRITE(LU_ERR,*) 'CF_INXSQAREA X Y Z=',CF_INXSQAREA_IAXIS,CF_INXSQAREA_JAXIS,CF_INXSQAREA_KAXIS
   WRITE(LU_ERR,*) 'CF_JNYSQAREA X Y Z=',CF_JNYSQAREA_IAXIS,CF_JNYSQAREA_JAXIS,CF_JNYSQAREA_KAXIS
   WRITE(LU_ERR,*) 'CF_KNZSQAREA X Y Z=',CF_KNZSQAREA_IAXIS,CF_KNZSQAREA_JAXIS,CF_KNZSQAREA_KAXIS
   WRITE(LU_ERR,*) ' '
   WRITE(LU_ERR,*) 'CUTFACE INB=',NCUTFACE_INB
   WRITE(LU_ERR,*) 'CF_AREA, CF_INXAREA INB=',CF_AREA_INB,CF_INXAREA_INB
   WRITE(LU_ERR,*) 'CF_INXSQAREA INB =',CF_INXSQAREA_INB,CF_JNYSQAREA_INB,CF_KNZSQAREA_INB

ENDDO


RETURN

CONTAINS

! ------------------------ SET_FDS_SOLID_CELLS -----------------------------------

! SUBROUTINE SET_FDS_SOLID_CELLS
!
! ! Local Variables:
! INTEGER :: CELL_COUNT_AUX
! LOGICAL, ALLOCATABLE, DIMENSION(:) :: SOLID_AUX
! REAL(EB), ALLOCATABLE, DIMENSION(:,:) :: UVW_GHOST_AUX
!
! ! Main Loop:
! MESH_LOOP : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX
!
!    CALL POINT_TO_MESH(NM)
!
!    CELL_COUNT_AUX = CELL_COUNT(NM)
!    ! First loop add GEOM data to CELL_COUNT:
!    DO K=0,KBP1
!       DO J=0,JBP1
!          DO I=0,IBP1
!             ! Add cells of type IBM_SOLID and IBM_CUTFACE to CELL_COUNT:
!             IF((CELL_INDEX(I,J,K)==0) .AND. CCVAR(I,J,K,IBM_CGSC)==IBM_SOLID) CELL_COUNT_AUX = CELL_COUNT_AUX + 1
!          ENDDO
!       ENDDO
!    ENDDO
!
!    NULLIFY(SOLID)
!    IF(ALLOCATED(SOLID_AUX)) DEALLOCATE(SOLID_AUX); ALLOCATE(SOLID_AUX(0:CELL_COUNT(NM)))
!    SOLID_AUX(0:CELL_COUNT(NM))=MESHES(NM)%SOLID(0:CELL_COUNT(NM))
!    DEALLOCATE(MESHES(NM)%SOLID); ALLOCATE(MESHES(NM)%SOLID(0:CELL_COUNT_AUX))
!    SOLID => MESHES(NM)%SOLID
!    SOLID(:) = .FALSE.
!    SOLID(0:CELL_COUNT(NM)) = SOLID_AUX(0:CELL_COUNT(NM))
!
!    NULLIFY(UVW_GHOST)
!    IF(ALLOCATED(UVW_GHOST_AUX)) DEALLOCATE(UVW_GHOST_AUX); ALLOCATE(UVW_GHOST_AUX(0:CELL_COUNT(NM),3))
!    UVW_GHOST_AUX(0:CELL_COUNT(NM),1:3)=MESHES(NM)%UVW_GHOST(0:CELL_COUNT(NM),1:3)
!    DEALLOCATE(MESHES(NM)%UVW_GHOST); ALLOCATE(MESHES(NM)%UVW_GHOST(0:CELL_COUNT_AUX,3))
!    UVW_GHOST => MESHES(NM)%UVW_GHOST
!    UVW_GHOST(:,:) = 0._EB
!    UVW_GHOST(0:CELL_COUNT(NM),1:3) = UVW_GHOST_AUX(0:CELL_COUNT(NM),1:3)
!
!    ! Second loop, Add info to CELL_INDEX, SOLID from GEOMs:
!    CELL_COUNT_AUX = CELL_COUNT(NM)
!    DO K=0,KBP1
!       DO J=0,JBP1
!          DO I=0,IBP1
!             ! Add cells of type IBM_SOLID and IBM_CUTFACE to CELL_COUNT:
!             IF((CELL_INDEX(I,J,K)==0) .AND. CCVAR(I,J,K,IBM_CGSC)==IBM_SOLID) THEN
!                CELL_COUNT_AUX = CELL_COUNT_AUX + 1
!                CELL_INDEX(I,J,K) = CELL_COUNT_AUX
!                SOLID(CELL_COUNT_AUX) = .TRUE. ! Define cell as FDS SOLID type.
!             ENDIF
!          ENDDO
!       ENDDO
!    ENDDO
!
!    CELL_COUNT(NM) = CELL_COUNT_AUX
!
! ENDDO MESH_LOOP
!
! IF(ALLOCATED(SOLID_AUX)) DEALLOCATE(SOLID_AUX)
! IF(ALLOCATED(UVW_GHOST_AUX)) DEALLOCATE(UVW_GHOST_AUX)
!
! RETURN
! END SUBROUTINE SET_FDS_SOLID_CELLS

! ---------------------- GET_INBCUTFACES_TO_CFACE --------------------------------

SUBROUTINE GET_INBCUTFACES_TO_CFACE

USE MEMORY_FUNCTIONS, ONLY: ALLOCATE_STORAGE

! Local Variables:
INTEGER :: ICF, CFACE_INDEX_LOCAL, SURF_INDEX, IBOD, IWSEL

! Main Loop:
MESH_LOOP_1 : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   ! ALLOCATE to zero size, size is dynamically increased in ALLOCATE_STORAGE:
   IF(ALLOCATED(MESHES(NM)%CFACE)) DEALLOCATE(MESHES(NM)%CFACE)
   MESHES(NM)%N_CFACE_CELLS_DIM = 1000
   ALLOCATE(MESHES(NM)%CFACE(0:MESHES(NM)%N_CFACE_CELLS_DIM))
   ! Deallocate CFACEs storage array for this mesh, if necessary.
   IF(ALLOCATED(MESHES(NM)%CFACE_STORAGE)) DEALLOCATE(MESHES(NM)%CFACE_STORAGE)
   ALLOCATE(MESHES(NM)%CFACE_STORAGE(0:N_SURF))

   ! Define pointers among IBM_INBOUNDARY CUT_FACE and CFACE:
   CFACE_INDEX_LOCAL = 0
   DO ICF=1,MESHES(NM)%N_CUTFACE_MESH
      IF(CUT_FACE(ICF)%STATUS /= IBM_INBOUNDARY) CYCLE

      DO IFACE=1,CUT_FACE(ICF)%NFACE
         ! Option, we'll see if it is required: Cycle Areas less than GEOMEPS^2, insignificantly small.
         ! IF(CUT_FACE(ICF)%AREA(IFACE) < GEOMEPS*GEOMEPS) CYCLE
         CFACE_INDEX_LOCAL = CFACE_INDEX_LOCAL + 1
         ! Index in CFACE for cut-face in (ICF,IFACE) of CUT_FACE.
         CUT_FACE(ICF)%CFACE_INDEX(IFACE) = CFACE_INDEX_LOCAL

         SURF_INDEX = CUT_FACE(ICF)%SURF_INDEX(IFACE)
         CALL ALLOCATE_STORAGE(NM,SURF_INDEX,CFACE_INDEX=CFACE_INDEX_LOCAL)

         MESHES(NM)%CFACE(CFACE_INDEX_LOCAL)%X = CUT_FACE(ICF)%XYZCEN(IAXIS,IFACE)
         MESHES(NM)%CFACE(CFACE_INDEX_LOCAL)%Y = CUT_FACE(ICF)%XYZCEN(JAXIS,IFACE)
         MESHES(NM)%CFACE(CFACE_INDEX_LOCAL)%Z = CUT_FACE(ICF)%XYZCEN(KAXIS,IFACE)
         MESHES(NM)%CFACE(CFACE_INDEX_LOCAL)%AREA= CUT_FACE(ICF)%AREA(IFACE)
         MESHES(NM)%CFACE(CFACE_INDEX_LOCAL)%VEL_ERR_NEW=CUT_FACE(ICF)%VEL(IFACE) - 0._EB ! Assumes zero veloc of solid.

         ! Normal to cut-face:
         IBOD =CUT_FACE(ICF)%BODTRI(1,IFACE)
         IWSEL=CUT_FACE(ICF)%BODTRI(2,IFACE)
         MESHES(NM)%CFACE(CFACE_INDEX_LOCAL)%NVEC(IAXIS:KAXIS) = GEOMETRY(IBOD)%FACES_NORMAL(IAXIS:KAXIS,IWSEL)

         ! Now populate cut-face information:
         MESHES(NM)%CFACE(CFACE_INDEX_LOCAL)%CUT_FACE_IND1 = ICF
         MESHES(NM)%CFACE(CFACE_INDEX_LOCAL)%CUT_FACE_IND2 = IFACE

         ! Boundary CFACES processed are defined of type SOLID_BOUNDARY
         MESHES(NM)%CFACE(CFACE_INDEX_LOCAL)%BOUNDARY_TYPE = SOLID_BOUNDARY

      ENDDO
   ENDDO
   MESHES(NM)%N_CFACE_CELLS = CFACE_INDEX_LOCAL

ENDDO MESH_LOOP_1

RETURN
END SUBROUTINE GET_INBCUTFACES_TO_CFACE


! ------------------------- SET_GC_CUTCELLS_3D -----------------------------------

SUBROUTINE SET_GC_CUTCELLS_3D

! Local Variables:
INTEGER :: IW,II,JJ,KK,IOR,IIO,JJO,KKO,IIF,JJF,KKF,IIOF,JJOF,KKOF,ICF,ICOF,IFACE,X1AXIS,ICC,NMICC
REAL(EB):: DXYZCEN(IAXIS:KAXIS), DIFF
TYPE (WALL_TYPE), POINTER :: WC
TYPE (EXTERNAL_WALL_TYPE), POINTER :: EWC
LOGICAL :: TWINMATCH
INTEGER, PARAMETER :: INDADD(1:3,1:6) = RESHAPE((/-1,0,0,0,0,0,0,-1,0,0,0,0,0,0,-1,0,0,0/),(/3,6/))
INTEGER, PARAMETER :: MYAXIS(1:6) = (/ IAXIS,IAXIS,JAXIS,JAXIS,KAXIS,KAXIS /)

IF (CCGUARD == 0) RETURN

! Meshes Loop:
! First Mesh Loop:
! Define links among the NM assigned external cut-faces and NOM mesh cut-faces:
MESH_LOOP_1 : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   EXTERNAL_WALL_LOOP_1 : DO IW=1,N_EXTERNAL_WALL_CELLS

      WC=>WALL(IW)
      EWC=>EXTERNAL_WALL(IW)
      IF (.NOT.(WC%BOUNDARY_TYPE == INTERPOLATED_BOUNDARY .OR. &
                WC%BOUNDARY_TYPE == MIRROR_BOUNDARY) ) CYCLE EXTERNAL_WALL_LOOP_1

      II  = WC%ONE_D%II
      JJ  = WC%ONE_D%JJ
      KK  = WC%ONE_D%KK
      IOR = WC%ONE_D%IOR
      IF(WC%BOUNDARY_TYPE == INTERPOLATED_BOUNDARY) THEN
         NOM = EWC%NOM ! Use Other Mesh Data.
         IIO = EWC%IIO_MIN
         JJO = EWC%JJO_MIN
         KKO = EWC%KKO_MIN
         IF ((EWC%IIO_MAX+EWC%JJO_MAX+EWC%KKO_MAX- &
             (EWC%IIO_MIN+EWC%JJO_MIN+EWC%KKO_MIN)) > 0) THEN ! There is an OMESH on finer refinement level, not allowed.
         WRITE(LU_ERR,*) 'SET_GC_CUTCELLS_3D Error: GEOM not allowed to cross meshes at different refinement levels.'
         ENDIF
         ! Define underlying Cartesian faces indexes:
         SELECT CASE(IOR)
         CASE( IAXIS) ! Lower X boundary for Mesh NM, Higher for mesh NOM.
            IIF = II    ; JJF = JJ    ; KKF = KK
            IIOF= IIO   ; JJOF= JJO   ; KKOF= KKO  ! High side I boundary face has the same index as the high boundary cell
         CASE(-IAXIS) ! Higher X boundary for Mesh NM, Lower for mesh NOM.
            IIF = II - 1; JJF = JJ    ; KKF = KK
            IIOF= IIO- 1; JJOF= JJO   ; KKOF= KKO
         CASE( JAXIS) ! Lower Y boundary for Mesh NM, Higher for mesh NOM.
            IIF = II    ; JJF = JJ    ; KKF = KK
            IIOF= IIO   ; JJOF= JJO   ; KKOF= KKO  ! High side J boundary face has the same index as the high boundary cell
         CASE(-JAXIS) ! Higher Y boundary for Mesh NM, Lower for mesh NOM.
            IIF = II    ; JJF = JJ - 1; KKF = KK
            IIOF= IIO   ; JJOF= JJO- 1; KKOF= KKO
         CASE( KAXIS) ! Lower Z boundary for Mesh NM, Higher for mesh NOM.
            IIF = II    ; JJF = JJ    ; KKF = KK
            IIOF= IIO   ; JJOF= JJO   ; KKOF= KKO  ! High side K boundary face has the same index as the high boundary cell
         CASE(-KAXIS) ! Higher Z boundary for Mesh NM, Lower for mesh NOM.
            IIF = II    ; JJF = JJ    ; KKF = KK - 1
            IIOF= IIO   ; JJOF= JJO   ; KKOF= KKO- 1
         END SELECT
      ELSEIF(WC%BOUNDARY_TYPE == MIRROR_BOUNDARY) THEN
         NOM = NM ! Use cut face data, same mesh.
         ! Define underlying Cartesian faces indexes:
         SELECT CASE(IOR)
         CASE( IAXIS) ! Lower X boundary for Mesh NM, Higher for mesh NOM.
            IIF = II    ; JJF = JJ    ; KKF = KK
         CASE(-IAXIS) ! Higher X boundary for Mesh NM, Lower for mesh NOM.
            IIF = II - 1; JJF = JJ    ; KKF = KK
         CASE( JAXIS) ! Lower Y boundary for Mesh NM, Higher for mesh NOM.
            IIF = II    ; JJF = JJ    ; KKF = KK
         CASE(-JAXIS) ! Higher Y boundary for Mesh NM, Lower for mesh NOM.
            IIF = II    ; JJF = JJ - 1; KKF = KK
         CASE( KAXIS) ! Lower Z boundary for Mesh NM, Higher for mesh NOM.
            IIF = II    ; JJF = JJ    ; KKF = KK
         CASE(-KAXIS) ! Higher Z boundary for Mesh NM, Lower for mesh NOM.
            IIF = II    ; JJF = JJ    ; KKF = KK - 1
         END SELECT
         IIOF=IIF; JJOF=JJF; KKOF=KKF
      ENDIF

      ! Now Obtain the CUT_FACE for the same face on NM-NOM:
      X1AXIS=ABS(IOR)

      IF(MESHES( NM)%FCVAR(IIF ,JJF , KKF,IBM_FGSC,X1AXIS) /= IBM_CUTCFE) CYCLE EXTERNAL_WALL_LOOP_1

      ICF = MESHES( NM)%FCVAR(IIF ,JJF , KKF,IBM_IDCF,X1AXIS)
      ICOF= MESHES(NOM)%FCVAR(IIOF,JJOF,KKOF,IBM_IDCF,X1AXIS)

      ! Test that centroids match:
      TWINMATCH=.TRUE.
      DO IFACE=1,MESHES(NM)%CUT_FACE(ICF)%NFACE
         DXYZCEN(IAXIS:KAXIS) = MESHES( NM)%CUT_FACE( ICF)%XYZCEN(IAXIS:KAXIS,IFACE)   - &
                                MESHES(NOM)%CUT_FACE(ICOF)%XYZCEN(IAXIS:KAXIS,IFACE)
         DIFF=SQRT(DXYZCEN(IAXIS)**2._EB+DXYZCEN(JAXIS)**2._EB+DXYZCEN(KAXIS)**2._EB)
         IF (DIFF > GEOMEPS) TWINMATCH=.FALSE.
      ENDDO

      IF (TWINMATCH) THEN
         MESHES(NM)%CUT_FACE(ICF)%NOMICF(1:2)=(/ NOM, ICOF /)
         MESHES(NOM)%CUT_FACE(ICOF)%NOMICF(1:2)=(/  NM,  ICF /)
      ELSE
         WRITE(LU_ERR,*) 'SET_GC_CUTCELLS_3D Error: MESH=',NM,', CUT_FACE=',ICF,' does not match OMESH=',&
                         NOM,', CUT_FACE=',ICOF
      ENDIF

   ENDDO EXTERNAL_WALL_LOOP_1

ENDDO MESH_LOOP_1


! Second mesh loop:
! Define cut-cell data on guard-cell region to be communicated:
MESH_LOOP_2 : DO NM=LOWER_MESH_INDEX,UPPER_MESH_INDEX

   CALL POINT_TO_MESH(NM)

   EXTERNAL_WALL_LOOP_2 : DO IW=1,N_EXTERNAL_WALL_CELLS

      WC=>WALL(IW)
      EWC=>EXTERNAL_WALL(IW)
      IF (.NOT.(WC%BOUNDARY_TYPE == INTERPOLATED_BOUNDARY .OR. &
                WC%BOUNDARY_TYPE == MIRROR_BOUNDARY) ) CYCLE EXTERNAL_WALL_LOOP_2

      II  = WC%ONE_D%II
      JJ  = WC%ONE_D%JJ
      KK  = WC%ONE_D%KK
      IOR = WC%ONE_D%IOR
      IF(WC%BOUNDARY_TYPE == INTERPOLATED_BOUNDARY) THEN
         NOM = EWC%NOM ! Use Other Mesh Data.
         IIO = EWC%IIO_MIN
         JJO = EWC%JJO_MIN
         KKO = EWC%KKO_MIN
      ELSEIF(WC%BOUNDARY_TYPE == MIRROR_BOUNDARY) THEN
         NOM = NM ! Use gas cell data, same mesh.
         IIO = WC%ONE_D%IIG
         JJO = WC%ONE_D%JJG
         KKO = WC%ONE_D%KKG
      ENDIF

      IF (MESHES(NM)%CCVAR(II,JJ,KK,IBM_CGSC) == IBM_CUTCFE) THEN
         ICC   = MESHES(NOM)%CCVAR(IIO,JJO,KKO,IBM_IDCC)
         NMICC = MESHES(NM)%CCVAR(II,JJ,KK,IBM_IDCC)
         MESHES(NM)%CUT_CELL(NMICC)%NOMICC = (/ NOM, ICC /)
         NCELL = MESHES(NOM)%CUT_CELL(ICC)%NCELL
         ! Add NCELL cut-cells to OM%NCC_R:
         MESHES(NM)%OMESH(NOM)%NICC_R(1) = MESHES(NM)%OMESH(NOM)%NICC_R(1) + 1
         MESHES(NM)%OMESH(NOM)%NICC_R(2) = MESHES(NM)%OMESH(NOM)%NICC_R(2) + NCELL
      ENDIF

   ENDDO EXTERNAL_WALL_LOOP_2

ENDDO MESH_LOOP_2


RETURN

END SUBROUTINE SET_GC_CUTCELLS_3D

END SUBROUTINE SET_CUTCELLS_3D


! -------------------------- GET_BODINT_PLANE -----------------------------------

SUBROUTINE GET_BODINT_PLANE(X1AXIS,X1PLN,PLNORMAL,X2AXIS,X3AXIS,DX2_MIN,DX3_MIN,TRI_ONPLANE_ONLY)

USE COMP_FUNCTIONS, ONLY: CURRENT_TIME
IMPLICIT NONE
INTEGER, INTENT(IN) :: X1AXIS, X2AXIS, X3AXIS
REAL(EB),INTENT(IN) :: X1PLN, DX2_MIN, DX3_MIN, PLNORMAL(MAX_DIM)
LOGICAL, INTENT(IN) :: TRI_ONPLANE_ONLY

! Local variables:
INTEGER :: IG, IBIN, IWSEL, IWSELDUM, IEDGE, ISGL, ISEG, ITRI, NINDTRI, EDGE_TRI
REAL(EB):: LEDGE, XYZV(MAX_DIM,NODS_WSEL)
INTEGER :: ELEM(NODS_WSEL), IND_P(NODS_WSEL), NTRIS, NSEGS
REAL(EB):: DOT1, DOT2, DOT3
LOGICAL :: INTFLG, INLIST
REAL(EB):: LN1(MAX_DIM,NOD1:NOD2), LN2(MAX_DIM,NOD1:NOD2)
REAL(EB):: XYZ_INT1(MAX_DIM), XYZ_INT2(MAX_DIM)
INTEGER :: SEG(NOD1:NOD2), EDGES(NOD1:NOD2,3), VEC3(3)
REAL(EB):: X2X3(IAXIS:JAXIS,NODS_WSEL), AREALOC
REAL(EB):: XP1(IAXIS:JAXIS), XP2(IAXIS:JAXIS), TX2P(IAXIS:JAXIS), TX3P(IAXIS:JAXIS)
REAL(EB):: NMTX2P
INTEGER :: IWSEL1, IWSEL2, ELEM1(NODS_WSEL), ELEM2(NODS_WSEL)
REAL(EB):: XYZ1(MAX_DIM), NXYZ1(MAX_DIM), NX3P1, N1(IAXIS:JAXIS), NMNL
REAL(EB):: XYZ2(MAX_DIM), NXYZ2(MAX_DIM), NX3P2, N2(IAXIS:JAXIS)
REAL(EB):: X3PVERT, PVERT(IAXIS:JAXIS), X3P1, P1CEN(IAXIS:JAXIS), X3P2, P2CEN(IAXIS:JAXIS)
INTEGER :: VCT(2)
REAL(EB):: PCT(IAXIS:JAXIS,1:2), V1(IAXIS:JAXIS), V2(IAXIS:JAXIS), CRSSNV, CTST
REAL(EB):: VEC(IAXIS:JAXIS,1:2)
INTEGER, ALLOCATABLE, DIMENSION(:,:) :: SEGAUX, INDSEGAUX, SEGTYPEAUX
REAL(EB):: X3_1, X2_1, X3_2, X2_2, SLEN, SBOD
INTEGER :: ISEG_NEW, NBCROSS
REAL(EB):: DELBIN
INTEGER :: ILO_BIN, IHI_BIN

REAL(EB), SAVE :: MAX_LEDGE
LOGICAL,  SAVE :: FIRST_CALL=.TRUE.
INTEGER,  SAVE :: N_VERTS_TOT, N_FACES_TOT

REAL(EB) :: TNOW

#ifdef DEBUG_SET_CUTCELLS
INTEGER :: INOD
CHARACTER(100) :: BIPL_FILE
#endif

TNOW = CURRENT_TIME()

IF (FIRST_CALL) THEN
   ! Define BODINT_PLANE allocation sizes, hard wired for now:
   ! Maximum number of vertices and elements in BODINT_PLANE:
   N_VERTS_TOT=0; N_FACES_TOT=0
   DO IG=1,N_GEOMETRY
      N_VERTS_TOT = N_VERTS_TOT + GEOMETRY(IG)%N_VERTS
      N_FACES_TOT = N_FACES_TOT + GEOMETRY(IG)%N_FACES
   ENDDO

   ! Conservative estimate:
   IBM_MAX_NNODS = 2 * N_VERTS_TOT
   IBM_MAX_NSGLS = N_VERTS_TOT
   IBM_MAX_NSEGS = N_FACES_TOT
   IBM_MAX_NTRIS = N_FACES_TOT

   ! Maximum number of grid crossings on BODINT_PLANE segments:
   MAX_LEDGE = GEOMEPS ! Initialize to a small number.
   DO IG=1,N_GEOMETRY
      LEDGE = GEOMETRY(IG)%MAX_LEDGE ! This has been computed at setup in GET_GEOM_TRIBIN
      MAX_LEDGE = MAX(MAX_LEDGE,LEDGE)
   ENDDO

   IF ( ALLOCATED(BODINT_PLANE%XYZ)  )      DEALLOCATE(BODINT_PLANE%XYZ)
   IF ( ALLOCATED(BODINT_PLANE%SGLS) )      DEALLOCATE(BODINT_PLANE%SGLS)
   IF ( ALLOCATED(BODINT_PLANE%SEGS) )      DEALLOCATE(BODINT_PLANE%SEGS)
   IF ( ALLOCATED(BODINT_PLANE%TRIS) )      DEALLOCATE(BODINT_PLANE%TRIS)
   IF ( ALLOCATED(BODINT_PLANE%INDSGL) )    DEALLOCATE(BODINT_PLANE%INDSGL)
   IF ( ALLOCATED(BODINT_PLANE%INDSEG) )    DEALLOCATE(BODINT_PLANE%INDSEG)
   IF ( ALLOCATED(BODINT_PLANE%INDTRI) )    DEALLOCATE(BODINT_PLANE%INDTRI)
   IF ( ALLOCATED(BODINT_PLANE%X2ALIGNED) ) DEALLOCATE(BODINT_PLANE%X2ALIGNED)
   IF ( ALLOCATED(BODINT_PLANE%X3ALIGNED) ) DEALLOCATE(BODINT_PLANE%X3ALIGNED)
   IF ( ALLOCATED(BODINT_PLANE%NBCROSS) )   DEALLOCATE(BODINT_PLANE%NBCROSS)
   IF ( ALLOCATED(BODINT_PLANE%SVAR) )      DEALLOCATE(BODINT_PLANE%SVAR)
   IF ( ALLOCATED(BODINT_PLANE%SEGTYPE) )   DEALLOCATE(BODINT_PLANE%SEGTYPE)
   IF ( ALLOCATED(BODINT_PLANE%NOD_PERM) )  DEALLOCATE(BODINT_PLANE%NOD_PERM)

   ALLOCATE(BODINT_PLANE%      XYZ(IAXIS:KAXIS,            IBM_MAX_NNODS))
   ALLOCATE(BODINT_PLANE% NOD_PERM(IBM_MAX_NNODS))
   ALLOCATE(BODINT_PLANE%     SGLS(NOD1,                   IBM_MAX_NSGLS))
   ALLOCATE(BODINT_PLANE%     SEGS(NOD1:NOD2,              IBM_MAX_NSEGS))
   ALLOCATE(BODINT_PLANE%     TRIS(NOD1:NOD3,              IBM_MAX_NTRIS))
   ALLOCATE(BODINT_PLANE%   INDSGL(IBM_MAX_WSTRIANG_SGL+2, IBM_MAX_NSGLS))
   ALLOCATE(BODINT_PLANE%   INDSEG(IBM_MAX_WSTRIANG_SEG+2, IBM_MAX_NSEGS))
   ALLOCATE(BODINT_PLANE%   INDTRI(IBM_MAX_WSTRIANG_TRI+1, IBM_MAX_NTRIS))
   ALLOCATE(BODINT_PLANE%X2ALIGNED(IBM_MAX_NSEGS))
   ALLOCATE(BODINT_PLANE%X3ALIGNED(IBM_MAX_NSEGS))
   ALLOCATE(BODINT_PLANE%  NBCROSS(IBM_MAX_NSEGS))
   ALLOCATE(BODINT_PLANE%     SVAR(IBM_MAX_NBCROSS,        IBM_MAX_NSEGS))  ! Here first index is ibcross.
   ALLOCATE(BODINT_PLANE%  SEGTYPE(LOW_IND:HIGH_IND,       IBM_MAX_NSEGS))

   FIRST_CALL=.FALSE.
ENDIF

IBM_MAX_NBCROSS_OLD = IBM_MAX_NBCROSS
IBM_MAX_NBCROSS = MAX(4,CEILING(3._EB*MAX_LEDGE/MIN(DX2_MIN, DX3_MIN))) ! Rough estimate.

! Now allocate BODINT_PLANE:
BODINT_PLANE%NNODS = 0
BODINT_PLANE%NSGLS = 0
BODINT_PLANE%NSEGS = 0
BODINT_PLANE%NTRIS = 0
IF (IBM_MAX_NBCROSS > IBM_MAX_NBCROSS_OLD) THEN
   IF ( ALLOCATED(BODINT_PLANE%SVAR) )      DEALLOCATE(BODINT_PLANE%SVAR)
   ALLOCATE(BODINT_PLANE%     SVAR(IBM_MAX_NBCROSS,        IBM_MAX_NSEGS))  ! Here first index is ibcross.
ENDIF

! Main Loop over Geometries:
MAIN_GEOM_LOOP : DO IG=1,N_GEOMETRY

   DELBIN  = GEOMETRY(IG)%TBAXIS(X1AXIS)%DELBIN
   ILO_BIN = MAX(1,CEILING((X1PLN-GEOMEPS-GEOMETRY(IG)%GEOM_BOX( LOW_IND,X1AXIS))/DELBIN))
   IHI_BIN = MIN(GEOMETRY(IG)%TBAXIS(X1AXIS)%N_BINS,CEILING((X1PLN+GEOMEPS-GEOMETRY(IG)%GEOM_BOX( LOW_IND,X1AXIS))/DELBIN))

   ! Find for this geometry where does the plane lay on triangle bins:
   IBIN_DO : DO IBIN=ILO_BIN,IHI_BIN !1,GEOMETRY(IG)%TBAXIS(X1AXIS)%N_BINS

   IF ( X1PLN < GEOMETRY(IG)%TBAXIS(X1AXIS)%TRIBIN(IBIN)%X1_LOW-GEOMEPS)  CYCLE
   IF ( X1PLN > GEOMETRY(IG)%TBAXIS(X1AXIS)%TRIBIN(IBIN)%X1_HIGH+GEOMEPS) CYCLE

   ! Loop surface triangles:
!   DO IWSEL =1,GEOMETRY(IG)%N_FACES
   DO IWSELDUM=1,GEOMETRY(IG)%TBAXIS(X1AXIS)%TRIBIN(IBIN)%NTL

      IWSEL=GEOMETRY(IG)%TBAXIS(X1AXIS)%TRIBIN(IBIN)%TRI_LIST(IWSELDUM)

      ! Test low-high vertices of triangle along x1axis vs plane (O(NT) operation):
      ! IF( (GEOMETRY(IG)%FACECUBE( LOW_IND,X1AXIS,IWSEL)-X1PLN) > GEOMEPS) CYCLE
      ! IF( (X1PLN-GEOMETRY(IG)%FACECUBE(HIGH_IND,X1AXIS,IWSEL)) > GEOMEPS) CYCLE

      IF( (GEOMETRY(IG)%TBAXIS(X1AXIS)%TRIBIN(IBIN)%FACECUBE( LOW_IND,IWSELDUM)-X1PLN) > GEOMEPS) CYCLE
      IF( (X1PLN-GEOMETRY(IG)%TBAXIS(X1AXIS)%TRIBIN(IBIN)%FACECUBE(HIGH_IND,IWSELDUM)) > GEOMEPS) CYCLE

      ! WSELEM(NOD1:NOD3) = GEOMETRY(IG)%FACES(NODS_WSEL*(IWSEL-1)+1:NODS_WSEL*IWSEL)
      ! ! Triangles NODES coordinates:
      ! DO INOD=NOD1,NOD3
      !    XYZV(IAXIS:KAXIS,INOD) = GEOMETRY(IG)%VERTS(MAX_DIM*(WSELEM(INOD)-1)+1:MAX_DIM*WSELEM(INOD))
      ! ENDDO

      XYZV(IAXIS:KAXIS,NOD1:NOD3) = GEOMETRY(IG)%TBAXIS(X1AXIS)%TRIBIN(IBIN)%XYZV(IAXIS:KAXIS,NOD1:NOD3,IWSELDUM)

      ! Compute simplified dot(PLNORMAL,XYZV-XYZPLANE):
      DOT1 = XYZV(X1AXIS,NOD1) - X1PLN
      DOT2 = XYZV(X1AXIS,NOD2) - X1PLN
      DOT3 = XYZV(X1AXIS,NOD3) - X1PLN
      IF ( ABS(DOT1) <= GEOMEPS ) DOT1 = 0._EB
      IF ( ABS(DOT2) <= GEOMEPS ) DOT2 = 0._EB
      IF ( ABS(DOT3) <= GEOMEPS ) DOT3 = 0._EB

      ! Test if IWSEL lays in X1PLN:
      IF ( (ABS(DOT1)+ABS(DOT2)+ABS(DOT3)) == 0._EB ) THEN

         ! Force nodes location in X1PLN plane:
         XYZV(X1AXIS,NOD1:NOD3) = X1PLN

         ! Index to point 1 of triangle in BODINT_PLANE%XYZ list:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZV(IAXIS:KAXIS,NOD1),IND_P(NOD1))

         ! Index to point 2 of triangle in BODINT_PLANE%XYZ list:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZV(IAXIS:KAXIS,NOD2),IND_P(NOD2))

         ! Index to point 3 of triangle in BODINT_PLANE%XYZ list:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZV(IAXIS:KAXIS,NOD3),IND_P(NOD3))

         ! Do we need to test if we already have this triangle on
         ! the list? Shouldn't unless repeated -> Possibility for
         ! zero thickness.
         NTRIS = BODINT_PLANE % NTRIS + 1
         BODINT_PLANE % NTRIS = NTRIS
         BODINT_PLANE % TRIS(NOD1:NOD3,NTRIS) = IND_P
         BODINT_PLANE % INDTRI(1:2,NTRIS) = (/ IWSEL, IG /)

         CYCLE ! Next WSELEM

      ENDIF

      ! Test if we are looking for intersection triangles only:
      IF (TRI_ONPLANE_ONLY) CYCLE

      ! Case a: Typical intersections:
      ! Points 1,2 on on side of plane, point 3 on the other:
      IF ( ((DOT1 > 0._EB) .AND. (DOT2 > 0._EB) .AND. (DOT3 < 0._EB)) .OR. &
           ((DOT1 < 0._EB) .AND. (DOT2 < 0._EB) .AND. (DOT3 > 0._EB)) ) THEN

         ! Line 1, from node 2 to 3:
         LN1(IAXIS:KAXIS,NOD1) = XYZV(IAXIS:KAXIS,NOD2)
         LN1(IAXIS:KAXIS,NOD2) = XYZV(IAXIS:KAXIS,NOD3)

         CALL LINE_INTERSECT_COORDPLANE(X1AXIS,X1PLN,PLNORMAL,LN1,XYZ_INT1,INTFLG)

         !IF (.NOT. INTFLG) THEN
         !  print*, "Error GET_BODINT_PLANE: No intersection on LN1, typical 1."
         !ENDIF

         ! Index to XYZ_INT1:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT1,IND_P(NOD1))

         ! Line 2, from node 1 to 3:
         LN2(IAXIS:KAXIS,NOD1) = XYZV(IAXIS:KAXIS,NOD1)
         LN2(IAXIS:KAXIS,NOD2) = XYZV(IAXIS:KAXIS,NOD3)

         CALL LINE_INTERSECT_COORDPLANE(X1AXIS,X1PLN,PLNORMAL,LN2,XYZ_INT2,INTFLG)

         !IF (.NOT. INTFLG) THEN
         !  print*, "Error GET_BODINT_PLANE: No intersection on LN2, typical 1."
         !ENDIF

         ! Index to XYZ_INT2:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT2,IND_P(NOD2))

         ! Now add segment:
         NSEGS = BODINT_PLANE % NSEGS + 1
         BODINT_PLANE % NSEGS = NSEGS
         IF ( DOT1 > 0._EB ) THEN ! First case, counterclockwise p1 to p2
            BODINT_PLANE%SEGS(NOD1:NOD2,NSEGS) = (/ IND_P(NOD1), IND_P(NOD2) /)
         ELSE
            BODINT_PLANE%SEGS(NOD1:NOD2,NSEGS) = (/ IND_P(NOD2), IND_P(NOD1) /)
         ENDIF
         BODINT_PLANE%INDSEG(1:4,NSEGS) = (/ 1, IWSEL, 0, IG /)
         BODINT_PLANE%SEGTYPE(1:2,NSEGS)= (/ IBM_SOLID, IBM_GASPHASE /)

         CYCLE ! Next WSELEM

      ENDIF
      ! Points 2,3 on one side of plane, point 1 on the other:
      IF ( ((DOT2 > 0._EB) .AND. (DOT3 > 0._EB) .AND. (DOT1 < 0._EB)) .OR. &
           ((DOT2 < 0._EB) .AND. (DOT3 < 0._EB) .AND. (DOT1 > 0._EB)) ) THEN

           ! Line 1, from node 1 to 2:
           LN1(IAXIS:KAXIS,NOD1) = XYZV(IAXIS:KAXIS,NOD1)
           LN1(IAXIS:KAXIS,NOD2) = XYZV(IAXIS:KAXIS,NOD2)

           CALL LINE_INTERSECT_COORDPLANE(X1AXIS,X1PLN,PLNORMAL,LN1,XYZ_INT1,INTFLG)

           !IF (.NOT. INTFLG) THEN
           !  print*, "Error GET_BODINT_PLANE: No intersection on LN1, typical 2."
           !ENDIF

           ! Index to XYZ_INT1:
           CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT1,IND_P(NOD1))

           ! Line 2, from node 1 to 3:
           LN2(IAXIS:KAXIS,NOD1) = XYZV(IAXIS:KAXIS,NOD1)
           LN2(IAXIS:KAXIS,NOD2) = XYZV(IAXIS:KAXIS,NOD3)

           CALL LINE_INTERSECT_COORDPLANE(X1AXIS,X1PLN,PLNORMAL,LN2,XYZ_INT2,INTFLG)

           !IF (.NOT. INTFLG) THEN
           !  print*, "Error GET_BODINT_PLANE: No intersection on LN2, typical 2."
           !ENDIF

           ! Index to XYZ_INT2:
           CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT2,IND_P(NOD2))

           ! Now add segment:
           NSEGS = BODINT_PLANE % NSEGS + 1
           BODINT_PLANE % NSEGS = NSEGS
           IF ( DOT2 > 0._EB ) THEN ! Second case, counterclockwise p2 to p1
              BODINT_PLANE%SEGS(NOD1:NOD2,NSEGS) = (/ IND_P(NOD2), IND_P(NOD1) /)
           ELSE
              BODINT_PLANE%SEGS(NOD1:NOD2,NSEGS) = (/ IND_P(NOD1), IND_P(NOD2) /)
           ENDIF
           BODINT_PLANE%INDSEG(1:4,NSEGS) = (/ 1, IWSEL, 0, IG /)
           BODINT_PLANE%SEGTYPE(1:2,NSEGS)= (/ IBM_SOLID, IBM_GASPHASE /)

           CYCLE ! Next WSELEM

      ENDIF
      ! Points 1,3 on one side of plane, point 2 on the other:
      IF ( ((DOT1 > 0._EB) .AND. (DOT3 > 0._EB) .AND. (DOT2 < 0._EB)) .OR. &
           ((DOT1 < 0._EB) .AND. (DOT3 < 0._EB) .AND. (DOT2 > 0._EB)) ) THEN

           ! Line 1, from node 1 to 2:
           LN1(IAXIS:KAXIS,NOD1) = XYZV(IAXIS:KAXIS,NOD1)
           LN1(IAXIS:KAXIS,NOD2) = XYZV(IAXIS:KAXIS,NOD2)

           CALL LINE_INTERSECT_COORDPLANE(X1AXIS,X1PLN,PLNORMAL,LN1,XYZ_INT1,INTFLG)

           !IF (.NOT. INTFLG) THEN
           !  print*, "Error GET_BODINT_PLANE: No intersection on LN1, typical 3."
           !ENDIF

           ! Index to XYZ_INT1:
           CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT1,IND_P(NOD1))

           ! Line 2, from node 2 to 3:
           LN2(IAXIS:KAXIS,NOD1) = XYZV(IAXIS:KAXIS,NOD2)
           LN2(IAXIS:KAXIS,NOD2) = XYZV(IAXIS:KAXIS,NOD3)

           CALL LINE_INTERSECT_COORDPLANE(X1AXIS,X1PLN,PLNORMAL,LN2,XYZ_INT2,INTFLG)

           !IF (.NOT. INTFLG) THEN
           !  print*, "Error GET_BODINT_PLANE: No intersection on LN2, typical 2."
           !ENDIF

           ! Index to XYZ_INT2:
           CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT2,IND_P(NOD2))

           ! Now add segment:
           NSEGS = BODINT_PLANE % NSEGS + 1
           BODINT_PLANE % NSEGS = NSEGS
           IF ( DOT1 > 0._EB ) THEN ! Third case, counterclockwise p1 to p2
              BODINT_PLANE%SEGS(NOD1:NOD2,NSEGS) = (/ IND_P(NOD1), IND_P(NOD2) /)
           ELSE
              BODINT_PLANE%SEGS(NOD1:NOD2,NSEGS) = (/ IND_P(NOD2), IND_P(NOD1) /)
           ENDIF
           BODINT_PLANE%INDSEG(1:4,NSEGS) = (/ 1, IWSEL, 0, IG /)
           BODINT_PLANE%SEGTYPE(1:2,NSEGS)= (/ IBM_SOLID, IBM_GASPHASE /)

           CYCLE ! Next WSELEM

      ENDIF

      ! Case b: only one point intersection. They will be used to define
      ! Solid vertex points in case of coincidence.
      ! Point 1 is on the plane:
      IF ( (DOT1 == 0._EB) .AND. ( ((DOT2 > 0._EB) .AND. (DOT3 > 0._EB)) .OR. &
                                   ((DOT2 < 0._EB) .AND. (DOT3 < 0._EB)) ) ) THEN

         ! First node is an intersection point:
         XYZ_INT1 = XYZV(IAXIS:KAXIS,NOD1); XYZ_INT1(X1AXIS) = X1PLN

         ! Index to XYZ_INT1:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT1,IND_P(NOD1))

         ! Add index to singles:
         ! Find if oriented segment is in list:
         INLIST = .FALSE.
         DO ISGL=1,BODINT_PLANE%NSGLS
            IF (BODINT_PLANE%SGLS(NOD1,ISGL) == IND_P(NOD1)) THEN
               INLIST = .TRUE.
               EXIT
            ENDIF
         ENDDO
         IF (.NOT.INLIST) THEN
            ISGL = BODINT_PLANE%NSGLS + 1
            BODINT_PLANE % NSGLS = ISGL
            BODINT_PLANE % SGLS(NOD1,ISGL) = IND_P(NOD1)
            BODINT_PLANE % INDSGL(1:2,ISGL) = (/ 1, IWSEL /)
            BODINT_PLANE % INDSGL(IBM_MAX_WSTRIANG_SGL+2,ISGL) = IG
         ELSE
            NINDTRI = BODINT_PLANE % INDSGL(1,ISGL) + 1
            !IF (NINDTRI > IBM_MAX_WSTRIANG_SGL) THEN
            !   print*, "Error GET_BODINT_PLANE: number of triangles per node > IBM_MAX_WSTRIANG_SGL."
            !ENDIF
            BODINT_PLANE % INDSGL(1,ISGL) = NINDTRI
            BODINT_PLANE % INDSGL(NINDTRI+1,ISGL) = IWSEL
         ENDIF

         CYCLE ! Next WSELEM

      ENDIF
      ! Point 2 is on the plane:
      IF ( (DOT2 == 0._EB) .AND. ( ((DOT1 > 0._EB) .AND. (DOT3 > 0._EB)) .OR. &
                                   ((DOT1 < 0._EB) .AND. (DOT3 < 0._EB)) ) ) THEN

         ! Second node is an intersection point:
         XYZ_INT1 = XYZV(IAXIS:KAXIS,NOD2); XYZ_INT1(X1AXIS) = X1PLN

         ! Index to XYZ_INT1:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT1,IND_P(NOD1))

         ! Add index to singles:
         ! Find if oriented segment is in list:
         INLIST = .FALSE.
         DO ISGL=1,BODINT_PLANE%NSGLS
            IF (BODINT_PLANE%SGLS(NOD1,ISGL) == IND_P(NOD1)) THEN
               INLIST = .TRUE.
               EXIT
            ENDIF
         ENDDO
         IF (.NOT.INLIST) THEN
            ISGL = BODINT_PLANE%NSGLS + 1
            BODINT_PLANE % NSGLS = ISGL
            BODINT_PLANE % SGLS(NOD1,ISGL) = IND_P(NOD1)
            BODINT_PLANE % INDSGL(1:2,ISGL) = (/ 1, IWSEL /)
            BODINT_PLANE % INDSGL(IBM_MAX_WSTRIANG_SGL+2,ISGL) = IG
         ELSE
            NINDTRI = BODINT_PLANE % INDSGL(1,ISGL) + 1
            !IF (NINDTRI > IBM_MAX_WSTRIANG_SGL) THEN
            !   print*, "Error GET_BODINT_PLANE: number of triangles per node > IBM_MAX_WSTRIANG_SGL."
            !ENDIF
            BODINT_PLANE % INDSGL(1,ISGL) = NINDTRI
            BODINT_PLANE % INDSGL(NINDTRI+1,ISGL) = IWSEL
         ENDIF

         CYCLE ! Next WSELEM

      ENDIF
      ! Point 3 is on the plane:
      IF ( (DOT3 == 0._EB) .AND. ( ((DOT1 > 0._EB) .AND. (DOT2 > 0._EB)) .OR. &
                                   ((DOT1 < 0._EB) .AND. (DOT2 < 0._EB)) ) ) THEN

         ! Third node is an intersection point:
         XYZ_INT1 = XYZV(IAXIS:KAXIS,NOD3); XYZ_INT1(X1AXIS) = X1PLN

         ! Index to XYZ_INT1:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT1,IND_P(NOD1))

         ! Add index to singles:
         ! Find if single element is in list:
         INLIST = .FALSE.
         DO ISGL=1,BODINT_PLANE%NSGLS
            IF (BODINT_PLANE%SGLS(NOD1,ISGL) == IND_P(NOD1)) THEN
               INLIST = .TRUE.
               EXIT
            ENDIF
         ENDDO
         IF (.NOT.INLIST) THEN
            ISGL = BODINT_PLANE%NSGLS + 1
            BODINT_PLANE % NSGLS = ISGL
            BODINT_PLANE % SGLS(NOD1,ISGL) = IND_P(NOD1)
            BODINT_PLANE % INDSGL(1:2,ISGL) = (/ 1, IWSEL /)
            BODINT_PLANE % INDSGL(IBM_MAX_WSTRIANG_SGL+2,ISGL) = IG
         ELSE
            NINDTRI = BODINT_PLANE % INDSGL(1,ISGL) + 1
            !IF (NINDTRI > IBM_MAX_WSTRIANG_SGL) THEN
            !   print*, "Error GET_BODINT_PLANE: number of triangles per node > IBM_MAX_WSTRIANG_SGL."
            !ENDIF
            BODINT_PLANE % INDSGL(1,ISGL) = NINDTRI
            BODINT_PLANE % INDSGL(NINDTRI+1,ISGL) = IWSEL
         ENDIF

         CYCLE ! Next WSELEM

      ENDIF

      ! Case c: one node is part of the intersection:
      ! Node 1 is in the plane:
      IF ( (DOT1 == 0._EB) .AND. ( ((DOT2 > 0._EB) .AND. (DOT3 < 0._EB)) .OR. &
                                   ((DOT2 < 0._EB) .AND. (DOT3 > 0._EB)) ) ) THEN

         ! First node is an intersection point:
         XYZ_INT1 = XYZV(IAXIS:KAXIS,NOD1); XYZ_INT1(X1AXIS) = X1PLN

         ! Index to XYZ_INT1:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT1,IND_P(NOD1))

         ! Line 2, from node 2 to 3:
         LN2(IAXIS:KAXIS,NOD1) = XYZV(IAXIS:KAXIS,NOD2)
         LN2(IAXIS:KAXIS,NOD2) = XYZV(IAXIS:KAXIS,NOD3)

         CALL LINE_INTERSECT_COORDPLANE(X1AXIS,X1PLN,PLNORMAL,LN2,XYZ_INT2,INTFLG)

         !IF (.NOT. INTFLG) THEN
         !  print*, "Error GET_BODINT_PLANE: No intersection on LN2, Case C 1."
         !ENDIF

         ! Index to XYZ_INT2:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT2,IND_P(NOD2))

         ! Now add segment:
         NSEGS = BODINT_PLANE % NSEGS + 1
         BODINT_PLANE % NSEGS = NSEGS
         IF ( DOT2 > 0._EB ) THEN ! Second case, counterclockwise p2 to p1
            BODINT_PLANE%SEGS(NOD1:NOD2,NSEGS) = (/ IND_P(NOD2), IND_P(NOD1) /)
         ELSE
            BODINT_PLANE%SEGS(NOD1:NOD2,NSEGS) = (/ IND_P(NOD1), IND_P(NOD2) /)
         ENDIF
         BODINT_PLANE%INDSEG(1:4,NSEGS) = (/ 1, IWSEL, 0, IG /)
         BODINT_PLANE%SEGTYPE(1:2,NSEGS)= (/ IBM_SOLID, IBM_GASPHASE /)

         CYCLE ! Next WSELEM

      ENDIF
      ! Node 2 is in the plane:
      IF ( (DOT2 == 0._EB) .AND. ( ((DOT1 > 0._EB) .AND. (DOT3 < 0._EB)) .OR. &
                                   ((DOT1 < 0._EB) .AND. (DOT3 > 0._EB)) ) ) THEN

         ! Second node is an intersection point:
         XYZ_INT1 = XYZV(IAXIS:KAXIS,NOD2); XYZ_INT1(X1AXIS) = X1PLN

         ! Index to XYZ_INT1:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT1,IND_P(NOD1))

         ! Line 2, from node 1 to 3:
         LN2(IAXIS:KAXIS,NOD1) = XYZV(IAXIS:KAXIS,NOD1)
         LN2(IAXIS:KAXIS,NOD2) = XYZV(IAXIS:KAXIS,NOD3)

         CALL LINE_INTERSECT_COORDPLANE(X1AXIS,X1PLN,PLNORMAL,LN2,XYZ_INT2,INTFLG)

         !IF (.NOT. INTFLG) THEN
         !  print*, "Error GET_BODINT_PLANE: No intersection on LN2, Case C 2."
         !ENDIF

         ! Index to XYZ_INT2:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT2,IND_P(NOD2))

         ! Now add segment:
         NSEGS = BODINT_PLANE % NSEGS + 1
         BODINT_PLANE % NSEGS = NSEGS
         IF ( DOT1 > 0._EB ) THEN
            BODINT_PLANE%SEGS(NOD1:NOD2,NSEGS) = (/ IND_P(NOD1), IND_P(NOD2) /)
         ELSE
            BODINT_PLANE%SEGS(NOD1:NOD2,NSEGS) = (/ IND_P(NOD2), IND_P(NOD1) /)
         ENDIF
         BODINT_PLANE%INDSEG(1:4,NSEGS) = (/ 1, IWSEL, 0, IG /)
         BODINT_PLANE%SEGTYPE(1:2,NSEGS)= (/ IBM_SOLID, IBM_GASPHASE /)

         CYCLE ! Next WSELEM

      ENDIF
      ! Node 3 is in the plane:
      IF ( (DOT3 == 0._EB) .AND. ( ((DOT1 > 0._EB) .AND. (DOT2 < 0._EB)) .OR. &
                                   ((DOT1 < 0._EB) .AND. (DOT2 > 0._EB)) ) ) THEN

         ! Third node is an intersection point:
         XYZ_INT1 = XYZV(IAXIS:KAXIS,NOD3); XYZ_INT1(X1AXIS) = X1PLN

         ! Index to XYZ_INT1:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT1,IND_P(NOD1))

         ! Line 2, from node 1 to 2:
         LN2(IAXIS:KAXIS,NOD1) = XYZV(IAXIS:KAXIS,NOD1)
         LN2(IAXIS:KAXIS,NOD2) = XYZV(IAXIS:KAXIS,NOD2)

         CALL LINE_INTERSECT_COORDPLANE(X1AXIS,X1PLN,PLNORMAL,LN2,XYZ_INT2,INTFLG)

         !IF (.NOT. INTFLG) THEN
         !  print*, "Error GET_BODINT_PLANE: No intersection on LN2, Case C 3."
         !ENDIF

         ! Index to XYZ_INT2:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT2,IND_P(NOD2))

         ! Now add segment:
         NSEGS = BODINT_PLANE % NSEGS + 1
         BODINT_PLANE % NSEGS = NSEGS
         IF ( DOT1 > 0._EB ) THEN
            BODINT_PLANE%SEGS(NOD1:NOD2,NSEGS) = (/ IND_P(NOD2), IND_P(NOD1) /)
         ELSE
            BODINT_PLANE%SEGS(NOD1:NOD2,NSEGS) = (/ IND_P(NOD1), IND_P(NOD2) /)
         ENDIF
         BODINT_PLANE%INDSEG(1:4,NSEGS) = (/ 1, IWSEL, 0, IG /)
         BODINT_PLANE%SEGTYPE(1:2,NSEGS)= (/ IBM_SOLID, IBM_GASPHASE /)

         CYCLE ! Next WSELEM

      ENDIF

      ! Case D: A triangle segment is in the plane.
      ! Intersection is line 1-2:
      IF ( (DOT1 == 0._EB) .AND. (DOT2 == 0._EB) ) THEN

         ! First node:
         XYZ_INT1 = XYZV(IAXIS:KAXIS,NOD1); XYZ_INT1(X1AXIS) = X1PLN

         ! Index to XYZ_INT1:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT1,IND_P(NOD1))

         ! Second node:
         XYZ_INT2 = XYZV(IAXIS:KAXIS,NOD2); XYZ_INT2(X1AXIS) = X1PLN

         ! Index to XYZ_INT2:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT2,IND_P(NOD2))

         ! Set oriented segment regarding plane:
         IF ( DOT3 > 0._EB ) THEN
            SEG(NOD1:NOD2) = (/ IND_P(NOD1), IND_P(NOD2) /)
         ELSE
            SEG(NOD1:NOD2) = (/ IND_P(NOD2), IND_P(NOD1) /)
         ENDIF
         ! Find if oriented segment is in list:
         INLIST = .FALSE.
         DO ISEG=1,BODINT_PLANE%NSEGS
            ! IF ( ANY(BODINT_PLANE%SEGS(NOD1:NOD2,ISEG) == SEG(NOD1)) .AND. &
            !      ANY(BODINT_PLANE%SEGS(NOD1:NOD2,ISEG) == SEG(NOD2)) ) THEN
            !    INLIST = .TRUE.
            !    EXIT
            ! ENDIF
            IF ( (BODINT_PLANE%SEGS(NOD1,ISEG) == SEG(NOD1)) .AND. &
                 (BODINT_PLANE%SEGS(NOD2,ISEG) == SEG(NOD2)) ) THEN
               INLIST = .TRUE.
               EXIT
            ENDIF
            IF ( (BODINT_PLANE%SEGS(NOD1,ISEG) == SEG(NOD2)) .AND. &
                 (BODINT_PLANE%SEGS(NOD2,ISEG) == SEG(NOD1)) ) THEN
               INLIST = .TRUE.
               EXIT
            ENDIF
         ENDDO
         IF (.NOT.INLIST) THEN
            ISEG = BODINT_PLANE%NSEGS + 1
            BODINT_PLANE%NSEGS = ISEG
            BODINT_PLANE%SEGS(NOD1:NOD2,ISEG) = SEG
            EDGE_TRI = GEOMETRY(IG)%FACE_EDGES(EDG1,IWSEL) ! 1st edge: Ed1 NOD1-NOD2, Ed2 NOD2-NOD3, Ed3 NOD3-NOD1.
            VEC3(1) = GEOMETRY(IG)%EDGE_FACES(1,EDGE_TRI)
            VEC3(2) = GEOMETRY(IG)%EDGE_FACES(2,EDGE_TRI)
            VEC3(3) = GEOMETRY(IG)%EDGE_FACES(4,EDGE_TRI)
            BODINT_PLANE%INDSEG(1:4,ISEG) = (/ VEC3(1), VEC3(2), VEC3(3), IG /)
         ENDIF

         CYCLE ! Next WSELEM

      ENDIF
      ! Intersection is line 2-3:
      IF ( (DOT2 == 0._EB) .AND. (DOT3 == 0._EB) ) THEN

         ! Second node:
         XYZ_INT1 = XYZV(IAXIS:KAXIS,NOD2); XYZ_INT1(X1AXIS) = X1PLN

         ! Index to XYZ_INT1:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT1,IND_P(NOD1))

         ! Third node:
         XYZ_INT2 = XYZV(IAXIS:KAXIS,NOD3); XYZ_INT2(X1AXIS) = X1PLN

         ! Index to XYZ_INT2:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT2,IND_P(NOD2))

         ! Set oriented segment regarding plane:
         IF ( DOT1 > 0._EB ) THEN
            SEG(NOD1:NOD2) = (/ IND_P(NOD1), IND_P(NOD2) /)
         ELSE
            SEG(NOD1:NOD2) = (/ IND_P(NOD2), IND_P(NOD1) /)
         ENDIF
         ! Find if oriented segment is in list:
         INLIST = .FALSE.
         DO ISEG=1,BODINT_PLANE%NSEGS
            ! IF ( ANY(BODINT_PLANE%SEGS(NOD1:NOD2,ISEG) == SEG(NOD1)) .AND. &
            !      ANY(BODINT_PLANE%SEGS(NOD1:NOD2,ISEG) == SEG(NOD2)) ) THEN
            !    INLIST = .TRUE.
            !    EXIT
            ! ENDIF
            IF ( (BODINT_PLANE%SEGS(NOD1,ISEG) == SEG(NOD1)) .AND. &
                 (BODINT_PLANE%SEGS(NOD2,ISEG) == SEG(NOD2)) ) THEN
               INLIST = .TRUE.
               EXIT
            ENDIF
            IF ( (BODINT_PLANE%SEGS(NOD1,ISEG) == SEG(NOD2)) .AND. &
                 (BODINT_PLANE%SEGS(NOD2,ISEG) == SEG(NOD1)) ) THEN
               INLIST = .TRUE.
               EXIT
            ENDIF
         ENDDO
         IF (.NOT.INLIST) THEN
            ISEG = BODINT_PLANE%NSEGS + 1
            BODINT_PLANE%NSEGS = ISEG
            BODINT_PLANE%SEGS(NOD1:NOD2,ISEG) = SEG
            EDGE_TRI = GEOMETRY(IG)%FACE_EDGES(EDG2,IWSEL) ! 2nd edge: Ed1 NOD1-NOD2, Ed2 NOD2-NOD3, Ed3 NOD3-NOD1.
            VEC3(1) = GEOMETRY(IG)%EDGE_FACES(1,EDGE_TRI)
            VEC3(2) = GEOMETRY(IG)%EDGE_FACES(2,EDGE_TRI)
            VEC3(3) = GEOMETRY(IG)%EDGE_FACES(4,EDGE_TRI)
            BODINT_PLANE%INDSEG(1:4,ISEG) = (/ VEC3(1), VEC3(2), VEC3(3), IG /)
         ENDIF

         CYCLE ! Next WSELEM

      ENDIF
      ! Intersection is line 3-1:
      IF ( (DOT3 == 0._EB) .AND. (DOT1 == 0._EB) ) THEN

         ! Third node:
         XYZ_INT1 = XYZV(IAXIS:KAXIS,NOD3); XYZ_INT1(X1AXIS) = X1PLN

         ! Index to XYZ_INT1:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT1,IND_P(NOD1))

         ! First node:
         XYZ_INT2 = XYZV(IAXIS:KAXIS,NOD1); XYZ_INT2(X1AXIS) = X1PLN

         ! Index to XYZ_INT2:
         CALL GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ_INT2,IND_P(NOD2))

         ! Set oriented segment regarding plane:
         IF ( DOT2 > 0._EB ) THEN
            SEG(NOD1:NOD2) = (/ IND_P(NOD1), IND_P(NOD2) /)
         ELSE
            SEG(NOD1:NOD2) = (/ IND_P(NOD2), IND_P(NOD1) /)
         ENDIF
         ! Find if oriented segment is in list:
         INLIST = .FALSE.
         DO ISEG=1,BODINT_PLANE%NSEGS
            ! IF ( ANY(BODINT_PLANE%SEGS(NOD1:NOD2,ISEG) == SEG(NOD1)) .AND. &
            !      ANY(BODINT_PLANE%SEGS(NOD1:NOD2,ISEG) == SEG(NOD2)) ) THEN
            !    INLIST = .TRUE.
            !    EXIT
            ! ENDIF
            IF ( (BODINT_PLANE%SEGS(NOD1,ISEG) == SEG(NOD1)) .AND. &
                 (BODINT_PLANE%SEGS(NOD2,ISEG) == SEG(NOD2)) ) THEN
               INLIST = .TRUE.
               EXIT
            ENDIF
            IF ( (BODINT_PLANE%SEGS(NOD1,ISEG) == SEG(NOD2)) .AND. &
                 (BODINT_PLANE%SEGS(NOD2,ISEG) == SEG(NOD1)) ) THEN
               INLIST = .TRUE.
               EXIT
            ENDIF
         ENDDO
         IF (.NOT.INLIST) THEN
            ISEG = BODINT_PLANE%NSEGS + 1
            BODINT_PLANE%NSEGS = ISEG
            BODINT_PLANE%SEGS(NOD1:NOD2,ISEG) = SEG
            EDGE_TRI = GEOMETRY(IG)%FACE_EDGES(EDG3,IWSEL) ! 3rd edge: Ed1 NOD1-NOD2, Ed2 NOD2-NOD3, Ed3 NOD3-NOD1.
            VEC3(1) = GEOMETRY(IG)%EDGE_FACES(1,EDGE_TRI)
            VEC3(2) = GEOMETRY(IG)%EDGE_FACES(2,EDGE_TRI)
            VEC3(3) = GEOMETRY(IG)%EDGE_FACES(4,EDGE_TRI)
            BODINT_PLANE%INDSEG(1:4,ISEG) = (/ VEC3(1), VEC3(2), VEC3(3), IG /)
         ENDIF

         CYCLE ! Next WSELEM

      ENDIF

      ! If you get to this point -> you have a problem:
      print*, "Error GET_BODINT_PLANE: Missed wet surface Triangle =",IWSEL

   ENDDO ! IWSEL

   EXIT IBIN_DO ! No need to test more bins.

   ENDDO IBIN_DO

ENDDO MAIN_GEOM_LOOP


! Next step is to Test triangles sides normals on plane against the obtained
! segments normals. If two identical segments found contain oposite
! normals, drop the segment in BODINT_PLANE%SEGS:
IF ( BODINT_PLANE%NTRIS > 0 ) THEN

   DO ITRI=1,BODINT_PLANE%NTRIS

      ! Triang conectivities:
      ELEM(NOD1:NOD3) = BODINT_PLANE%TRIS(NOD1:NOD3,ITRI)

      ! Coordinates in x2, x3 directions:
      X2X3(IAXIS,NOD1:NOD3) = (/ BODINT_PLANE%XYZ(X2AXIS,ELEM(NOD1)), &
                                 BODINT_PLANE%XYZ(X2AXIS,ELEM(NOD2)), &
                                 BODINT_PLANE%XYZ(X2AXIS,ELEM(NOD3)) /)
      X2X3(JAXIS,NOD1:NOD3) = (/ BODINT_PLANE%XYZ(X3AXIS,ELEM(NOD1)), &
                                 BODINT_PLANE%XYZ(X3AXIS,ELEM(NOD2)), &
                                 BODINT_PLANE%XYZ(X3AXIS,ELEM(NOD3)) /)

      ! Test Area sign, if -ve switch node order:
      AREALOC = 0.5_EB*(X2X3(IAXIS,NOD1)*X2X3(JAXIS,NOD2) - X2X3(IAXIS,NOD2)*X2X3(JAXIS,NOD1) + &
                        X2X3(IAXIS,NOD2)*X2X3(JAXIS,NOD3) - X2X3(IAXIS,NOD3)*X2X3(JAXIS,NOD2) + &
                        X2X3(IAXIS,NOD3)*X2X3(JAXIS,NOD1) - X2X3(IAXIS,NOD1)*X2X3(JAXIS,NOD3))
      IF (AREALOC < 0._EB) THEN
         ISEG    = ELEM(3)
         ELEM(3) = ELEM(2)
         ELEM(2)  =   ISEG
      ENDIF

      ! Now corresponding segments, ordered normal outside of plane x2-x3.
      EDGES(NOD1:NOD2,1) = (/ ELEM(1), ELEM(2) /) ! edge 1.
      EDGES(NOD1:NOD2,2) = (/ ELEM(2), ELEM(3) /) ! edge 2.
      EDGES(NOD1:NOD2,3) = (/ ELEM(3), ELEM(1) /)

      ! Now Test against segments, Beast approach:
      DO IEDGE=1,3
         DO ISEG=1,BODINT_PLANE%NSEGS
            IF ( (BODINT_PLANE%SEGS(NOD1,ISEG) == EDGES(NOD2,IEDGE)) .AND. &
                 (BODINT_PLANE%SEGS(NOD2,ISEG) == EDGES(NOD1,IEDGE)) ) THEN ! Edge normals
                                                                              ! oriented in opposite dirs.
               ! Set to SOLID SOLID segtype from BODINT_PLANE.SEGS
               BODINT_PLANE%SEGTYPE(NOD1:NOD2,ISEG)=(/ IBM_SOLID, IBM_SOLID /)

            ENDIF
         ENDDO
      ENDDO

   ENDDO
ENDIF

! For segments that are related to 2 Wet Surface triangles, test if they are of type GG or SS:
DO ISEG=1,BODINT_PLANE%NSEGS
    IF (BODINT_PLANE%INDSEG(1,ISEG) > 1) THEN ! Related to 2 WS triangles:

       SEG(NOD1:NOD2) = BODINT_PLANE%SEGS(NOD1:NOD2,ISEG)

       ! Segment nodes positions:
       XP1(IAXIS:JAXIS) = BODINT_PLANE%XYZ( (/X2AXIS,X3AXIS/) ,SEG(NOD1))
       XP2(IAXIS:JAXIS) = BODINT_PLANE%XYZ( (/X2AXIS,X3AXIS/) ,SEG(NOD2))

       ! Unit normal versor along x2p (axis directed from NOD2 to NOD1):
       NMTX2P = SQRT( (XP1(IAXIS)-XP2(IAXIS))**2._EB + (XP1(JAXIS)-XP2(JAXIS))**2._EB )
       TX2P(IAXIS:JAXIS) = (XP1(IAXIS:JAXIS)-XP2(IAXIS:JAXIS)) * NMTX2P**(-1._EB)
       ! Versor along x3p.
       TX3P(IAXIS:JAXIS) = (/ -TX2P(JAXIS), TX2P(IAXIS) /)

       ! Now related WS triangles centroids:
       IWSEL1 = BODINT_PLANE%INDSEG(2,ISEG)
       IWSEL2 = BODINT_PLANE%INDSEG(3,ISEG)
       IG     = BODINT_PLANE%INDSEG(4,ISEG)

       ! Centroid of WS elem 1:
       ELEM1(NOD1:NOD3)  = GEOMETRY(IG)%FACES(NODS_WSEL*(IWSEL1-1)+1:NODS_WSEL*IWSEL1)
       XYZ1(IAXIS:KAXIS) = ( GEOMETRY(IG)%VERTS(MAX_DIM*(ELEM1(NOD1)-1)+1:MAX_DIM*ELEM1(NOD1)) + &
                             GEOMETRY(IG)%VERTS(MAX_DIM*(ELEM1(NOD2)-1)+1:MAX_DIM*ELEM1(NOD2)) + &
                             GEOMETRY(IG)%VERTS(MAX_DIM*(ELEM1(NOD3)-1)+1:MAX_DIM*ELEM1(NOD3)) ) / 3._EB
       NXYZ1(IAXIS:KAXIS)= GEOMETRY(IG)%FACES_NORMAL(IAXIS:KAXIS,IWSEL1)
       ! Normal versor in x3p-x1 direction:
       NX3P1 = TX3P(IAXIS)*NXYZ1(X2AXIS) + TX3P(JAXIS)*NXYZ1(X3AXIS)
       N1(IAXIS:JAXIS) = (/ NX3P1, NXYZ1(X1AXIS) /)
       NMNL = SQRT( N1(IAXIS)**2._EB + N1(JAXIS)**2._EB )
       N1 = N1 * NMNL**(-1._EB)

       ! Centroid of WS elem 2:
       ELEM2(NOD1:NOD3)  = GEOMETRY(IG)%FACES(NODS_WSEL*(IWSEL2-1)+1:NODS_WSEL*IWSEL2)
       XYZ2(IAXIS:KAXIS) = ( GEOMETRY(IG)%VERTS(MAX_DIM*(ELEM2(NOD1)-1)+1:MAX_DIM*ELEM2(NOD1)) + &
                             GEOMETRY(IG)%VERTS(MAX_DIM*(ELEM2(NOD2)-1)+1:MAX_DIM*ELEM2(NOD2)) + &
                             GEOMETRY(IG)%VERTS(MAX_DIM*(ELEM2(NOD3)-1)+1:MAX_DIM*ELEM2(NOD3)) ) / 3._EB
       NXYZ2(IAXIS:KAXIS)= GEOMETRY(IG)%FACES_NORMAL(IAXIS:KAXIS,IWSEL2)
       ! Normal versor in x3p-x1 direction:
       NX3P2 = TX3P(IAXIS)*NXYZ2(X2AXIS) + TX3P(JAXIS)*NXYZ2(X3AXIS)
       N2(IAXIS:JAXIS) = (/ NX3P2, NXYZ2(X1AXIS) /)
       NMNL = SQRT( N2(IAXIS)**2._EB + N2(JAXIS)**2._EB )
       N2 = N2 * NMNL**(-1._EB)

       ! Define points in plane x3p-x1:
       ! vertex point:
       X3PVERT = TX3P(IAXIS)*XP1(IAXIS) + TX3P(JAXIS)*XP1(JAXIS)
       PVERT(IAXIS:JAXIS) = (/ X3PVERT, X1PLN /)
       ! First triangle centroid:
       X3P1 = TX3P(IAXIS)*XYZ1(X2AXIS) + TX3P(JAXIS)*XYZ1(X3AXIS)
       P1CEN(IAXIS:JAXIS) = (/ X3P1, XYZ1(X1AXIS) /)
       ! Second triangle centroid:
       X3P2 = TX3P(IAXIS)*XYZ2(X2AXIS) + TX3P(JAXIS)*XYZ2(X3AXIS)
       P2CEN(IAXIS:JAXIS) = (/ X3P2, XYZ2(X1AXIS) /)

       VCT(1:2) = 0
       PCT(IAXIS:JAXIS,1:2) = 0._EB

       ! Segment on triangle 1:
       V1(IAXIS:JAXIS) = P1CEN(IAXIS:JAXIS) - PVERT(IAXIS:JAXIS)
       CRSSNV = N1(IAXIS)*V1(JAXIS) - N1(JAXIS)*V1(IAXIS)
       IF (CRSSNV > 0._EB) THEN
           ! v1 stays as is, and is second segment:
           VEC(IAXIS:JAXIS,2) = V1(IAXIS:JAXIS)
           PCT(IAXIS:JAXIS,2) = P1CEN(IAXIS:JAXIS)
           VCT(2) = 1
       ELSE
           ! -v1 is the first segment:
           VEC(IAXIS:JAXIS,1) = -V1(IAXIS:JAXIS)
           PCT(IAXIS:JAXIS,1) = P1CEN(IAXIS:JAXIS)
           VCT(1) = 1
       ENDIF

       ! Segment on triangle 2:
       V2(IAXIS:JAXIS) = P2CEN(IAXIS:JAXIS) - PVERT(IAXIS:JAXIS)
       CRSSNV = N2(IAXIS)*V2(JAXIS) - N2(JAXIS)*V2(IAXIS)
       IF (CRSSNV > 0._EB) THEN
           ! v2 stays as is, and is second segment:
           VEC(IAXIS:JAXIS,2) = V2(IAXIS:JAXIS)
           PCT(IAXIS:JAXIS,2) = P2CEN(IAXIS:JAXIS)
           VCT(2) = 1
       ELSE
           ! -v2 is the first segment:
           VEC(IAXIS:JAXIS,1) = -V2(IAXIS:JAXIS)
           PCT(IAXIS:JAXIS,1) = P2CEN(IAXIS:JAXIS)
           VCT(1) = 1
       ENDIF

       IF ( (VCT(1) == 0) .OR. (VCT(2) == 0) ) THEN
          print*, "Error GET_BODINT_PLANE: One component of vct == 0."
       ENDIF

       ! Cross product of v1 and v2 gives magnitude along x2p axis:
       CTST = VEC(IAXIS,1)*VEC(JAXIS,2) - VEC(JAXIS,1)*VEC(IAXIS,2)

       ! Now tests:
       ! Start with SOLID GASPHASE  definition for segtype:
       BODINT_PLANE%SEGTYPE(NOD1:NOD2,ISEG) = (/ IBM_SOLID, IBM_GASPHASE /)

       ! Test for SOLID SOLID condition:
       IF ( ((PCT(JAXIS,1)-X1PLN) > -GEOMEPS) .AND.  &
            ((PCT(JAXIS,2)-X1PLN) > -GEOMEPS) .AND. (CTST < GEOMEPS) ) THEN
           BODINT_PLANE%SEGTYPE(NOD1:NOD2,ISEG) = (/ IBM_SOLID, IBM_SOLID /)
           CYCLE
       ELSEIF (((PCT(JAXIS,1)-X1PLN) < GEOMEPS) .AND. &
              ((PCT(JAXIS,2)-X1PLN) < GEOMEPS) .AND. (CTST < GEOMEPS) ) THEN
           BODINT_PLANE%SEGTYPE(NOD1:NOD2,ISEG) = (/ IBM_SOLID, IBM_SOLID /)
           CYCLE
       ENDIF

       ! Test for GASPHASE GASPHASE condition:
       IF ( ((PCT(JAXIS,1)-X1PLN) > GEOMEPS) .AND.  &
            ((PCT(JAXIS,2)-X1PLN) > GEOMEPS) .AND. (CTST > GEOMEPS) ) THEN
            BODINT_PLANE%SEGTYPE(NOD1:NOD2,ISEG) = (/ IBM_GASPHASE, IBM_GASPHASE /)
            CYCLE
       ELSEIF (((PCT(1,JAXIS)-X1PLN) < -GEOMEPS) .AND.  &
              ((PCT(2,JAXIS)-X1PLN) < -GEOMEPS) .AND. (CTST > GEOMEPS) ) THEN
            BODINT_PLANE%SEGTYPE(NOD1:NOD2,ISEG) = (/ IBM_GASPHASE, IBM_GASPHASE /)
            CYCLE
       ENDIF

    ENDIF
ENDDO


! For the time being, as BODINT_PLANE is used to create Cartesian face cut-faces
! We eliminate from the list the SEGTYPE=[SOLID SOLID] segments:
ALLOCATE(SEGAUX(NOD1:NOD2,BODINT_PLANE%NSEGS))
ALLOCATE(INDSEGAUX(IBM_MAX_WSTRIANG_SEG+2,BODINT_PLANE%NSEGS))
ALLOCATE(SEGTYPEAUX(NOD1:NOD2,BODINT_PLANE%NSEGS))

ISEG_NEW = 0
DO ISEG=1,BODINT_PLANE%NSEGS
    IF ( (BODINT_PLANE%SEGTYPE(NOD1,ISEG) == IBM_SOLID) .AND. &
         (BODINT_PLANE%SEGTYPE(NOD2,ISEG) == IBM_SOLID) ) CYCLE

       ISEG_NEW = ISEG_NEW + 1
       SEGAUX(NOD1:NOD2,ISEG_NEW) = BODINT_PLANE%SEGS(NOD1:NOD2,ISEG)
       INDSEGAUX(1:IBM_MAX_WSTRIANG_SEG+2,ISEG_NEW) = &
          BODINT_PLANE%INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,ISEG)
       SEGTYPEAUX(NOD1:NOD2,ISEG_NEW) = BODINT_PLANE%SEGTYPE(NOD1:NOD2,ISEG)
ENDDO
BODINT_PLANE%NSEGS = ISEG_NEW
BODINT_PLANE%SEGS(NOD1:NOD2,1:ISEG_NEW) = SEGAUX(NOD1:NOD2,1:ISEG_NEW)
BODINT_PLANE%INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,1:ISEG_NEW) = INDSEGAUX(1:IBM_MAX_WSTRIANG_SEG+2,1:ISEG_NEW)
BODINT_PLANE%SEGTYPE(NOD1:NOD2,1:ISEG_NEW) = SEGTYPEAUX(NOD1:NOD2,1:ISEG_NEW)

DEALLOCATE(SEGAUX,INDSEGAUX,SEGTYPEAUX)


! Segments Crossings fields:
! Initialize nbcross with segment nodes locations:
BODINT_PLANE%NBCROSS(1:BODINT_PLANE%NSEGS)                   =  0
BODINT_PLANE%SVAR(1:IBM_MAX_NBCROSS,1:BODINT_PLANE%NSEGS)    = -1._EB

! Add segment ends as crossings:
DO ISEG=1,BODINT_PLANE%NSEGS

   ! End nodes to cross:
   SEG(NOD1:NOD2) = BODINT_PLANE%SEGS(NOD1:NOD2,ISEG)
   XYZ1(IAXIS:KAXIS) = BODINT_PLANE%XYZ(IAXIS:KAXIS,SEG(NOD1))
   XYZ2(IAXIS:KAXIS) = BODINT_PLANE%XYZ(IAXIS:KAXIS,SEG(NOD2))

   ! x2_x3 of segment point 1:
   X2_1 = XYZ1(X2AXIS); X3_1 = XYZ1(X3AXIS)
   ! x2_x3 of segment point 2:
   X2_2 = XYZ2(X2AXIS); X3_2 = XYZ2(X3AXIS)

   ! Segment length:
   SLEN = SQRT( (X2_2-X2_1)**2._EB + (X3_2-X3_1)**2._EB )

   ! First node:
   SBOD = 0._EB
   ! Add crossing to BODINT_PLANE:
   NBCROSS = BODINT_PLANE%NBCROSS(ISEG) + 1
   BODINT_PLANE%NBCROSS(ISEG) = NBCROSS
   BODINT_PLANE%SVAR(NBCROSS,ISEG) = SBOD

   ! Second node:
   SBOD = SLEN
   ! Add crossing to BODINT_PLANE:
   NBCROSS = BODINT_PLANE%NBCROSS(ISEG) + 1
   BODINT_PLANE%NBCROSS(ISEG) = NBCROSS
   BODINT_PLANE%SVAR(NBCROSS,ISEG) = SBOD

ENDDO

#ifdef DEBUG_SET_CUTCELLS
! Write out:
WRITE(BIPL_FILE,'(A,A,I3.3,A)') TRIM(CHID),'_BODINT_PLANE_',MYID,'.csv'
OPEN(333,FILE=TRIM(BIPL_FILE),STATUS='UNKNOWN')
WRITE(333,*) 'X1AXIS,X2AXIS,X3AXIS,X1PLN,GEOMEPS'
WRITE(333,*) X1AXIS,X2AXIS,X3AXIS,X1PLN,GEOMEPS
WRITE(333,*) 'NNODS, NSEGS, NSGLS, NTRIS'
WRITE(333,*) BODINT_PLANE%NNODS,BODINT_PLANE%NSEGS,BODINT_PLANE%NSGLS,BODINT_PLANE%NTRIS
DO INOD=1,BODINT_PLANE%NNODS
   WRITE(333,*) BODINT_PLANE%XYZ(IAXIS:KAXIS,INOD)
END DO
DO ISEG=1,BODINT_PLANE%NSEGS
   WRITE(333,*) BODINT_PLANE%SEGS(NOD1:NOD2,ISEG)
END DO
DO ISGL=1,BODINT_PLANE%NSGLS
   WRITE(333,*) BODINT_PLANE%SGLS(NOD1,ISGL)
END DO
DO ITRI=1,BODINT_PLANE%NTRIS
   WRITE(333,*) BODINT_PLANE%TRIS(NOD1:NOD3,ITRI)
ENDDO
CLOSE(333)
#endif /* DEBUG_SET_CUTCELLS */

T_CC_USED(GET_BODINT_PLANE_TIME_INDEX) = T_CC_USED(GET_BODINT_PLANE_TIME_INDEX) + CURRENT_TIME() - TNOW

RETURN
END SUBROUTINE GET_BODINT_PLANE


! -------------------------- GET_X2INTERSECTIONS --------------------------------

SUBROUTINE GET_X2_INTERSECTIONS(X2AXIS,X3AXIS,X3RAY,X1PLN)

USE COMP_FUNCTIONS, ONLY: CURRENT_TIME, SHUTDOWN
IMPLICIT NONE
INTEGER, INTENT(IN) :: X2AXIS, X3AXIS
REAL(EB),INTENT(IN) :: X3RAY,X1PLN

! Local Variables:
INTEGER :: ISGL, SGL, ISEG, SEG(NOD1:NOD2)
REAL(EB):: XYZ1(MAX_DIM), XYZ2(MAX_DIM), X2_1, X2_2, X3_1, X3_2, DOT1, DOT2
REAL(EB):: SVARI, STANI(IAXIS:JAXIS)
INTEGER :: ICRSI(LOW_IND:HIGH_IND), SCRSI, ISSEG(LOW_IND:HIGH_IND), GAM(LOW_IND:HIGH_IND)
REAL(EB):: X3MIN, X3MAX, DV12(MAX_DIM), MODTI, NOMLI(IAXIS:JAXIS)
LOGICAL :: OUTRAY

INTEGER :: IBM_N_CRS_AUX
REAL(EB):: IBM_SVAR_CRS_AUX(IBM_MAXCROSS_X2)
!INTEGER :: IBM_IS_CRS_AUX(IBM_MAXCROSS_X2)
INTEGER :: IBM_IS_CRS2_AUX(LOW_IND:HIGH_IND,IBM_MAXCROSS_X2)
REAL(EB):: IBM_SEG_TAN_AUX(IAXIS:JAXIS,IBM_MAXCROSS_X2)
INTEGER :: IBM_SEG_CRS_AUX(IBM_MAXCROSS_X2)
INTEGER :: CRS_NUM(IBM_MAXCROSS_X2),IND_CRS(LOW_IND:HIGH_IND,IBM_MAXCROSS_X2)
INTEGER :: LEFT_MEDIA, NCRS_REMAIN
INTEGER :: ICRS, ICRS1, ICRS2, IDCR, IND_LEFT, IND_RIGHT
LOGICAL :: DROP_SS_GG, FOUND_LEFT, NOT_COUNTED(IBM_MAXCROSS_X2), USE_INT_POINT(IBM_MAXCROSS_X2)

REAL(EB) :: TNOW
! INTEGER :: IAUX

TNOW = CURRENT_TIME()

! Initialize crossings arrays:
IBM_N_CRS = 0
IBM_SVAR_CRS = 1._EB / GEOMEPS
IBM_IS_CRS   = IBM_UNDEFINED
IBM_IS_CRS2  = IBM_UNDEFINED
IBM_SEG_TAN  = 0._EB
IBM_SEG_CRS  = 0

! First Single points:
! Treat them as [GASPHASE GASPHASE] crossings:
DO ISGL=1,BODINT_PLANE%NSGLS

   SGL = BODINT_PLANE%SGLS(NOD1,ISGL)
   XYZ1(IAXIS:KAXIS) = BODINT_PLANE%XYZ(IAXIS:KAXIS,SGL)

   ! x2-x3 coordinates of point:
   X2_1 = XYZ1(X2AXIS)
   X3_1 = XYZ1(X3AXIS)

   ! Dot product dot(X_1-XRAY,e3)
   DOT1 = X3_1-X3RAY
   IF (ABS(DOT1) <= GEOMEPS) DOT1=0._EB

   IF ( ABS(DOT1) == 0._EB ) THEN
       ! Point 1:
       SVARI = X2_1
       ICRSI(LOW_IND:HIGH_IND) = IBM_GASPHASE
       SCRSI = -ISGL
       STANI(IAXIS:JAXIS)  = 0._EB

       ! Insertion sort:
       CALL INSERT_RAY_CROSS(SVARI,ICRSI,SCRSI,STANI) ! Modifies crossings arrays.

   ENDIF

ENDDO

! Now Segments:
SEGMENTS_LOOP : DO ISEG=1,BODINT_PLANE%NSEGS

   SEG(NOD1:NOD2)    = BODINT_PLANE%SEGS(NOD1:NOD2,ISEG)
   XYZ1(IAXIS:KAXIS) = BODINT_PLANE%XYZ(IAXIS:KAXIS,SEG(NOD1))
   XYZ2(IAXIS:KAXIS) = BODINT_PLANE%XYZ(IAXIS:KAXIS,SEG(NOD2))

   ! x2,x3 coordinates of segment:
   X2_1 = XYZ1(X2AXIS)
   X3_1 = XYZ1(X3AXIS) ! Lower index endpoint.
   X2_2 = XYZ2(X2AXIS)
   X3_2 = XYZ2(X3AXIS) ! Upper index endpoint.

   ! Is segment aligned with x3 direction?
   BODINT_PLANE%X3ALIGNED(ISEG) = (ABS(X2_2-X2_1) < GEOMEPS)
   ! Is segment aligned with x2 rays?:
   BODINT_PLANE%X2ALIGNED(ISEG) = (ABS(X3_2-X3_1) < GEOMEPS)

   ! First Test if the whole segment is on one side of the Ray:
   ! Test segment crosses the ray, or is in geomepsilon proximity
   ! of it:
   X3MIN = MIN(X3_1,X3_2)
   X3MAX = MAX(X3_1,X3_2)
   OUTRAY=(((X3RAY-X3MAX) > GEOMEPS) .OR. ((X3MIN-X3RAY) > GEOMEPS))

   IF (OUTRAY) CYCLE

   DOT1 = X3_1-X3RAY
   DOT2 = X3_2-X3RAY

   IF (ABS(DOT1) <= GEOMEPS) DOT1 = 0._EB
   IF (ABS(DOT2) <= GEOMEPS) DOT2 = 0._EB

   ! Segment tangent unit vector.
   DV12(IAXIS:JAXIS) = XYZ2( (/ X2AXIS, X3AXIS /) ) - XYZ1( (/ X2AXIS, X3AXIS /) )
   MODTI = SQRT( DV12(IAXIS)**2._EB + DV12(JAXIS)**2._EB )
   STANI(IAXIS:JAXIS)  = DV12(IAXIS:JAXIS) * MODTI**(-1._EB)
   NOMLI(IAXIS:JAXIS)  = (/ STANI(JAXIS), -STANI(IAXIS) /)
   ISSEG(LOW_IND:HIGH_IND) = BODINT_PLANE%SEGTYPE(LOW_IND:HIGH_IND,ISEG)

   ! For x2, in local x2-x3 coords e2=(1,0):
   GAM(LOW_IND) = (1 + NINT(SIGN( 1._EB, NOMLI(IAXIS))) ) / 2  !(1+SIGN(DOT_PRODUCT(NOMLI,e2)))/2;
   GAM(HIGH_IND)= (1 - NINT(SIGN( 1._EB, NOMLI(IAXIS))) ) / 2  !(1-SIGN(DOT_PRODUCT(NOMLI,e2)))/2;

   ! Test if whole segment is in ray, if so add segment nodes as crossings:
   IF ( (ABS(DOT1)+ABS(DOT2)) == 0._EB ) THEN

      ! Count both points as crossings:
      ! Point 1:
      SVARI = MIN(X2_1,X2_2)
      ICRSI(LOW_IND:HIGH_IND) = (/ IBM_GASPHASE, IBM_SOLID /)
      SCRSI = ISEG

      ! Insertion sort:
      CALL INSERT_RAY_CROSS(SVARI,ICRSI,SCRSI,STANI)

      ! Point 2:
      SVARI = MAX(X2_1,X2_2)
      ICRSI(LOW_IND:HIGH_IND) = (/ IBM_SOLID, IBM_GASPHASE /)
      SCRSI = ISEG

      ! Insertion sort:
      CALL INSERT_RAY_CROSS(SVARI,ICRSI,SCRSI,STANI)

      CYCLE

   ENDIF

   ! Now nodes individually:
   IF ( ABS(DOT1) == 0._EB ) THEN

      ! Point 1:
      SVARI = X2_1

      ! LOW and HIGH media type, using the segment definition:
      ICRSI(LOW_IND) = GAM(LOW_IND)*ISSEG(LOW_IND) + GAM(HIGH_IND)*ISSEG(HIGH_IND)
      ICRSI(HIGH_IND)= GAM(LOW_IND)*ISSEG(HIGH_IND)+ GAM(HIGH_IND)*ISSEG(LOW_IND)

      SCRSI = ISEG

      ! Insertion sort:
      CALL INSERT_RAY_CROSS(SVARI,ICRSI,SCRSI,STANI)

      CYCLE

   ENDIF
   IF ( ABS(DOT2) == 0._EB ) THEN

      ! Point 2:
      SVARI = X2_2

      ! LOW and HIGH_IND media type, using the segment definition:
      ICRSI(LOW_IND) = GAM(LOW_IND)*ISSEG(LOW_IND) + GAM(HIGH_IND)*ISSEG(HIGH_IND)
      ICRSI(HIGH_IND)= GAM(LOW_IND)*ISSEG(HIGH_IND)+ GAM(HIGH_IND)*ISSEG(LOW_IND)
      SCRSI = ISEG

      ! Insertion sort:
      CALL INSERT_RAY_CROSS(SVARI,ICRSI,SCRSI,STANI)

      CYCLE

   ENDIF

   ! Finally regular case:
   ! Points 1 on one side of ray, point 2 on the other:
   ! IF ((DOT1 > 0. .AND. DOT2 < 0.) .OR. (DOT1 < 0. .AND. DOT2 > 0.))
   IF ( DOT1*DOT2 < 0._EB ) THEN

      ! Intersection Point along segment:
      !DS    = (X3RAY-X3_1) / (X3_2-X3_1)
      !SVARI = X2_1 + DS*(X2_2-X2_1)
      SVARI = X2_1 + (X3RAY-X3_1) * (X2_2-X2_1) / (X3_2-X3_1)

      ! LOW and HIGH media type, using the segment definition:
      ICRSI(LOW_IND) = GAM(LOW_IND)*ISSEG(LOW_IND) + GAM(HIGH_IND)*ISSEG(HIGH_IND)
      ICRSI(HIGH_IND)= GAM(LOW_IND)*ISSEG(HIGH_IND)+ GAM(HIGH_IND)*ISSEG(LOW_IND)
      SCRSI = ISEG

      ! Insertion sort:
      CALL INSERT_RAY_CROSS(SVARI,ICRSI,SCRSI,STANI)

      CYCLE

   ENDIF

   print*, "Error GET_X2INTERSECTIONS: Missed segment=",ISEG

ENDDO SEGMENTS_LOOP

! Do we have any intersections?
IF ( IBM_N_CRS == 0 ) RETURN

! Once all intersections and corresponding tags have been found, there
! might be points that lay on the same x2 location. Intersections type
! GG are dropped when other types are present at the same s. The remaining
! are reordered such that media continuity is preserved as the ray is
! covered for increasing s, by looking at the high side type of the
! adjacent intersection point to the left (if the intersection is the one
! with lowest s, the media to the left is type IBM_GASPHASE). Points of same
! type are collapsed. The final unique intersection type is obtained by
! using the LOW type of the first intersection and the HIGH type of the
! last intersection found at a given s.

IBM_N_CRS_AUX    = 0
IBM_SVAR_CRS_AUX = 1._EB/GEOMEPS ! svar = x2_intersection
IBM_IS_CRS2_AUX  = IBM_UNDEFINED ! Is the intersection an actual GS.
IBM_SEG_CRS_AUX  = 0             ! Segment containing the crossing.
IBM_SEG_TAN_AUX  = 0._EB         ! Segment orientation for each intersection.

! Count how many crossings with different SVAR:
CRS_NUM      = 0
ICRS         = 1
CRS_NUM(ICRS)= 1
IND_CRS      = 0
IND_CRS(LOW_IND, CRS_NUM(ICRS)) = ICRS-1
IND_CRS(HIGH_IND,CRS_NUM(ICRS)) = IND_CRS(HIGH_IND,ICRS)+1

DO ICRS=2,IBM_N_CRS
   IF ( ABS(IBM_SVAR_CRS(ICRS)-IBM_SVAR_CRS(ICRS-1)) < GEOMEPS ) THEN
      CRS_NUM(ICRS) = CRS_NUM(ICRS-1)
   ELSE
      CRS_NUM(ICRS) = CRS_NUM(ICRS-1)+1
      IND_CRS(LOW_IND,CRS_NUM(ICRS)) = ICRS-1
   ENDIF
   IND_CRS(HIGH_IND,CRS_NUM(ICRS)) = IND_CRS(HIGH_IND,CRS_NUM(ICRS))+1
ENDDO

! This is where we merge intersections at same svar location (i.e. same CRS_NUM value):
! Loop over different crossings:
LEFT_MEDIA = IBM_GASPHASE
DO IDCR=1,CRS_NUM(IBM_N_CRS)

   IBM_N_CRS_AUX = IBM_N_CRS_AUX + 1
   ! Case of single crossing with new svar:
   IF ( IND_CRS(HIGH_IND,IDCR) == 1 ) THEN

      ICRS =IND_CRS(LOW_IND,IDCR) + 1

      IF ( IBM_IS_CRS2(LOW_IND,ICRS) /= LEFT_MEDIA ) THEN
         ! Check if this is a single point SGLS which was initially tagged as IBM_GASPHASE,
         ! if so switch media type to LEFT_MEDIA
         IF (IBM_SEG_CRS(ICRS) < 0) THEN
            IBM_IS_CRS2(LOW_IND:HIGH_IND,ICRS) = LEFT_MEDIA
         ELSE
            WRITE(LU_ERR,*) "Error GET_X2INTERSECTIONS: IS_CRS(LOW_IND,ICRS) ~= LEFT_MEDIA, media continuity problem"
            WRITE(LU_ERR,*) "X1PLN=",X1PLN,ICRS,", X2AXIS,X3AXIS=",X2AXIS,X3AXIS,", X3RAY=",X3RAY
            IF(IDCR==1) WRITE(LU_ERR,*) "CHECK THAT YOUR &GEOM SURFACE NORMALS PONT OUTSIDE INTO THE GASPHASE."
            CALL SHUTDOWN("")
         ENDIF
      ENDIF

      IBM_SVAR_CRS_AUX(IBM_N_CRS_AUX)             = IBM_SVAR_CRS(ICRS)
      IBM_IS_CRS2_AUX(LOW_IND:HIGH_IND,IBM_N_CRS_AUX)     = IBM_IS_CRS2(LOW_IND:HIGH_IND,ICRS)
      IBM_SEG_CRS_AUX(IBM_N_CRS_AUX)              = IBM_SEG_CRS(ICRS)
      IBM_SEG_TAN_AUX(IAXIS:JAXIS,IBM_N_CRS_AUX)  = IBM_SEG_TAN(IAXIS:JAXIS,ICRS)
      LEFT_MEDIA = IBM_IS_CRS2(HIGH_IND,ICRS)

      CYCLE

   ENDIF

   ! Case of several crossings with new svar:
   DROP_SS_GG = .FALSE.
   DO ICRS=IND_CRS(LOW_IND,IDCR)+1,IND_CRS(LOW_IND,IDCR)+IND_CRS(HIGH_IND,IDCR)
      IF ( IBM_IS_CRS2(LOW_IND,ICRS) /= IBM_IS_CRS2(HIGH_IND,ICRS) ) THEN
         DROP_SS_GG = .TRUE.
         EXIT
      ENDIF
   ENDDO

   ! Variables related to new svar crossing:
   ICRS = IND_CRS(LOW_IND,IDCR) + 1
   IBM_SVAR_CRS_AUX(IBM_N_CRS_AUX)             = IBM_SVAR_CRS(ICRS)
   IBM_SEG_CRS_AUX(IBM_N_CRS_AUX)              = IBM_SEG_CRS(ICRS)
   IBM_SEG_TAN_AUX(IAXIS:JAXIS,IBM_N_CRS_AUX)  = IBM_SEG_TAN(IAXIS:JAXIS,ICRS)

   ! Now figure out the type of crossing:
   NOT_COUNTED = .TRUE.
   NCRS_REMAIN = IND_CRS(HIGH_IND,IDCR)
   IF (DROP_SS_GG) THEN

      ! Points of the same type are collapsed:
      USE_INT_POINT(IND_CRS(LOW_IND,IDCR)+1:IND_CRS(LOW_IND,IDCR)+IND_CRS(HIGH_IND,IDCR)) = .TRUE.
      DO ICRS1 = IND_CRS(LOW_IND,IDCR)+1, IND_CRS(LOW_IND,IDCR)+IND_CRS(HIGH_IND,IDCR) ! Pivot Loop
         IF(.NOT.USE_INT_POINT(ICRS1)) CYCLE ! Don't use collapsed point as pivot.
         DO ICRS2 = IND_CRS(LOW_IND,IDCR)+1, IND_CRS(LOW_IND,IDCR)+IND_CRS(HIGH_IND,IDCR)
            IF( (ICRS2==ICRS1) .OR. .NOT.USE_INT_POINT(ICRS2) ) CYCLE ! Don't use pivot, or collapsed point.
            IF( (IBM_IS_CRS2(LOW_IND ,ICRS1) == IBM_IS_CRS2(LOW_IND ,ICRS2)) .AND. &
                (IBM_IS_CRS2(HIGH_IND,ICRS1) == IBM_IS_CRS2(HIGH_IND,ICRS2)) ) USE_INT_POINT(ICRS2) = .FALSE.
         ENDDO
      ENDDO

      ! Left Side:
      FOUND_LEFT = .FALSE.
      IND_LEFT   = 0
      IND_RIGHT  = 0
      DO ICRS=IND_CRS(LOW_IND,IDCR)+1,IND_CRS(LOW_IND,IDCR)+IND_CRS(HIGH_IND,IDCR)
         ! Case crossing type GG or SS, drop:
         IF (IBM_IS_CRS2(LOW_IND,ICRS) == IBM_IS_CRS2(HIGH_IND,ICRS)) CYCLE
         ! Case collapsed point, drop:
         IF (.NOT.USE_INT_POINT(ICRS)) CYCLE

         IND_LEFT  =  IND_LEFT + IBM_IS_CRS2(LOW_IND,ICRS)
         IND_RIGHT = IND_RIGHT + IBM_IS_CRS2(HIGH_IND,ICRS)
      ENDDO

      if (IND_LEFT  /= 0) IND_LEFT = SIGN(1,IND_LEFT)
      if (IND_RIGHT /= 0) IND_RIGHT = SIGN(1,IND_RIGHT)

      IF (ABS(IND_LEFT)+ABS(IND_RIGHT) == 0) THEN ! Same number of SG and GS crossings,
                                                  ! both sides of the crossing
                                                  ! defined as left_media:
         IBM_IS_CRS2_AUX(LOW_IND:HIGH_IND,IBM_N_CRS_AUX)     = LEFT_MEDIA
      ELSEIF (IND_LEFT == LEFT_MEDIA) THEN
         IBM_IS_CRS2_AUX(LOW_IND:HIGH_IND,IBM_N_CRS_AUX) = (/ IND_LEFT, IND_RIGHT /) ! GS or SG.
      ELSE
         WRITE(LU_ERR,*) "Error GET_X2INTERSECTIONS: DROP_SS_GG = .TRUE., Didn't find left side continuity."
         ! WRITE(LU_ERR,*) "BODINT_PLANE, NSGLS, NSEGS=",BODINT_PLANE%NSGLS,BODINT_PLANE%NSEGS
         ! WRITE(LU_ERR,*) "X1PLN, X2AXIS, X3AXIS, X3RAY=",X1PLN,X2AXIS,X3AXIS,X3RAY
         WRITE(LU_ERR,*) "IBM_N_CRS=",IBM_N_CRS,", IDCR=",IDCR
         WRITE(LU_ERR,*) ICRS,"IND_LEFT=",IND_LEFT,", IND_RIGHT=",IND_RIGHT
         WRITE(LU_ERR,*) "IBM_IS_CRS2(LOW_IND:HIGH_IND,ICRS)",IBM_IS_CRS2(LOW_IND:HIGH_IND,ICRS)
         ! DO IAUX=1,IBM_N_CRS
         !    WRITE(LU_ERR,*) IAUX,CRS_NUM(IBM_N_CRS),IND_LEFT,IND_RIGHT,IBM_SVAR_CRS(IND_CRS(LOW_IND,IAUX)+1)
         ! ENDDO
         ! WRITE(LU_ERR,*) ' '
         ! PAUSE
      ENDIF
      LEFT_MEDIA = IBM_IS_CRS2_AUX(HIGH_IND,IBM_N_CRS_AUX)

   ELSE ! Intersections are either GG or SS

      ! Left side:
      FOUND_LEFT = .FALSE.
      DO ICRS=IND_CRS(LOW_IND,IDCR)+1,IND_CRS(LOW_IND,IDCR)+IND_CRS(HIGH_IND,IDCR)

         ! Case GG or SS with IBM_IS_CRS2(LOW_IND,ICRS) == LEFT_MEDIA:
         ! This collapses all types SS or GG that have the left side
         ! type. Note they should all be one type (either GG or SS):
         IF (IBM_IS_CRS2(LOW_IND,ICRS) == LEFT_MEDIA) THEN
            IBM_IS_CRS2_AUX(LOW_IND:HIGH_IND,IBM_N_CRS_AUX) = IBM_IS_CRS2(LOW_IND:HIGH_IND,ICRS)
            NOT_COUNTED(ICRS) = .FALSE.
            NCRS_REMAIN = NCRS_REMAIN-1
            FOUND_LEFT = .TRUE.
         ENDIF
      ENDDO

      IF (.NOT.FOUND_LEFT) print*, "Error GET_X2INTERSECTIONS: DROP_SS_GG = .FALSE., Didn't find left side continuity."

      IF ( NCRS_REMAIN /= 0) print*, "Error GET_X2INTERSECTIONS: DROP_SS_GG = .FALSE., NCRS_REMAIN /= 0."

      LEFT_MEDIA = IBM_IS_CRS2_AUX(HIGH_IND,IBM_N_CRS_AUX)

   ENDIF

ENDDO

! Copy final results:
IBM_N_CRS    = IBM_N_CRS_AUX
IBM_SVAR_CRS(1:IBM_MAXCROSS_X2)             = IBM_SVAR_CRS_AUX(1:IBM_MAXCROSS_X2)
IBM_SEG_CRS(1:IBM_MAXCROSS_X2)              = IBM_SEG_CRS_AUX(1:IBM_MAXCROSS_X2)
IBM_SEG_TAN(IAXIS:JAXIS,1:IBM_MAXCROSS_X2)  = IBM_SEG_TAN_AUX(IAXIS:JAXIS,1:IBM_MAXCROSS_X2)
! IBM_IS_CRS2(LOW_IND:HIGH_IND,1:IBM_MAXCROSS_X2) = IBM_IS_CRS2_AUX(LOW_IND:HIGH_IND,1:IBM_MAXCROSS_X2)

DO ICRS=1,IBM_N_CRS
  IBM_IS_CRS(ICRS) = 2*( IBM_IS_CRS2_AUX(LOW_IND,ICRS) + 1 ) - IBM_IS_CRS2_AUX(HIGH_IND,ICRS)
ENDDO


! Write out:
! print*, "X3RAY=",X3RAY,", Intersect X2=",IBM_N_CRS
! DO ICRS=1,IBM_N_CRS
!    print*, ICRS,", ",IBM_SVAR_CRS(ICRS),", ",IBM_IS_CRS(ICRS)
! ENDDO

T_CC_USED(GET_X2_INTERSECTIONS_TIME_INDEX) = T_CC_USED(GET_X2_INTERSECTIONS_TIME_INDEX) + CURRENT_TIME() - TNOW

RETURN
END SUBROUTINE GET_X2_INTERSECTIONS


! ------------------------- INSERT_RAY_CROSS ------------------------------------

SUBROUTINE INSERT_RAY_CROSS(SVARI,ICRSI,SCRSI,STANI)

REAL(EB), INTENT(IN) :: SVARI, STANI(IAXIS:JAXIS)
INTEGER,  INTENT(IN) :: ICRSI(LOW_IND:HIGH_IND), SCRSI

! Local Variables:
INTEGER :: ICRS, IDUM

IBM_N_CRS = IBM_N_CRS + 1

! Test maximum crossings defined:
! IF ( IBM_N_CRS > IBM_MAXCROSS_X2) THEN
!    WRITE(LU_ERR,*) "Error INSERT_RAY_CROSS: IBM_N_CRS > IBM_MAXCROSS_X2."
!    DO IDUM = 1,IBM_N_CRS
!       WRITE(LU_ERR,*) IDUM,IBM_SVAR_CRS(IDUM)
!    ENDDO
! ENDIF

! Add in place, ascending value order:
DO ICRS=1,IBM_N_CRS ! The updated IBM_N_CRS is for ICRS to reach the
                    ! initialization value IBM_SVAR_CRS(ICRS)=1/GEOMEPS.
   IF ( SVARI < IBM_SVAR_CRS(ICRS) ) EXIT
ENDDO

! Here copy from the back (updated IBM_N_CRS) to the ICRS location:
! if ICRS=IBM_N_CRS -> nothing gets copied:
DO IDUM = IBM_N_CRS,ICRS+1,-1
   IBM_SVAR_CRS(IDUM)           = IBM_SVAR_CRS(IDUM-1)
   IBM_IS_CRS2(LOW_IND:HIGH_IND,IDUM)   = IBM_IS_CRS2(LOW_IND:HIGH_IND,IDUM-1)
   IBM_SEG_CRS(IDUM)            = IBM_SEG_CRS(IDUM-1);
   IBM_SEG_TAN(IAXIS:JAXIS,IDUM)= IBM_SEG_TAN(IAXIS:JAXIS,IDUM-1);
ENDDO

IBM_SVAR_CRS(ICRS)             = SVARI              ! x2 location.
IBM_IS_CRS2(LOW_IND:HIGH_IND,ICRS)     = ICRSI(LOW_IND:HIGH_IND)    ! Does point separate GASPHASE from SOLID?
IBM_SEG_CRS(ICRS)              = SCRSI              ! Segment on BOINT_PLANE the crossing belongs to.
IBM_SEG_TAN(IAXIS:JAXIS,ICRS)  = STANI(IAXIS:JAXIS) ! IBM_SEG_TAN might not be needed in new implementation.

RETURN
END SUBROUTINE INSERT_RAY_CROSS

! ----------------------- GET_BODINT_NODE_INDEX ----------------------------------

SUBROUTINE GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ,IND_PI)

INTEGER,  INTENT(IN)  :: X2AXIS,X3AXIS
REAL(EB), INTENT(IN)  :: XYZ(MAX_DIM)
INTEGER,  INTENT(OUT) :: IND_PI

! Local variables:
INTEGER :: INOD=1, PIVOT(LOW_IND:HIGH_IND), INOD2
REAL(EB):: DIFFX2, DIFFX3

! Test if XYZ is already on BODINT_PLANE%XYZ:
IND_PI = -1 ! Initialize to negative index.
IF (BODINT_PLANE%NNODS < LINSEARCH_LIMIT) THEN
   ! Linear Search:
   DO INOD=1,BODINT_PLANE%NNODS
      DIFFX2 = BODINT_PLANE%XYZ(X2AXIS,BODINT_PLANE%NOD_PERM(INOD))-XYZ(X2AXIS)
      IF( DIFFX2 > GEOMEPS ) THEN
         EXIT
      ELSEIF( ABS(DIFFX2) <= GEOMEPS) THEN
         DIFFX3 = BODINT_PLANE%XYZ(X3AXIS,BODINT_PLANE%NOD_PERM(INOD))-XYZ(X3AXIS)
         IF ( DIFFX3 > GEOMEPS ) THEN
            EXIT
         ELSEIF ( ABS(DIFFX3) <= GEOMEPS ) THEN
            IND_PI = BODINT_PLANE%NOD_PERM(INOD)
            RETURN
         ENDIF
      ENDIF
   ENDDO
ELSE
   ! Binary Search:
   PIVOT(LOW_IND) = 0
   PIVOT(HIGH_IND)= BODINT_PLANE%NNODS + 1
   DO WHILE( (PIVOT(HIGH_IND)-PIVOT(LOW_IND)) > 1)
      INOD   = (PIVOT(LOW_IND)+PIVOT(HIGH_IND))/2
      DIFFX2 = BODINT_PLANE%XYZ(X2AXIS,BODINT_PLANE%NOD_PERM(INOD))-XYZ(X2AXIS)
      IF( DIFFX2 < -GEOMEPS ) THEN
         PIVOT(LOW_IND) = INOD
      ELSEIF( DIFFX2 > GEOMEPS ) THEN
         PIVOT(HIGH_IND)= INOD
      ELSE ! ABS(DIFFX2) < GEOMEPS
         DIFFX3 = BODINT_PLANE%XYZ(X3AXIS,BODINT_PLANE%NOD_PERM(INOD))-XYZ(X3AXIS)
         IF ( DIFFX3 < -GEOMEPS ) THEN
            PIVOT(LOW_IND) = INOD
         ELSEIF( DIFFX3 > GEOMEPS ) THEN
            PIVOT(HIGH_IND)= INOD
         ELSE ! ABS(DIFFX3) < GEOMEPS
            IND_PI = BODINT_PLANE%NOD_PERM(INOD)
            RETURN
         ENDIF
      ENDIF
   ENDDO
   INOD=PIVOT(HIGH_IND)
ENDIF

! Insert add NOD_PERM permutation array, O(NP) operation:
DO INOD2=BODINT_PLANE%NNODS+1,INOD+1,-1
  BODINT_PLANE%NOD_PERM(INOD2) = BODINT_PLANE%NOD_PERM(INOD2-1)
ENDDO
IND_PI = BODINT_PLANE%NNODS + 1
BODINT_PLANE%NNODS = IND_PI
BODINT_PLANE%NOD_PERM(INOD) = IND_PI
BODINT_PLANE%XYZ(IAXIS:KAXIS,IND_PI) = XYZ(IAXIS:KAXIS)

RETURN
END SUBROUTINE GET_BODINT_NODE_INDEX


! ---------------------- GET_BODINT_NODE_INDEX ----------------------------------

! SUBROUTINE GET_BODINT_NODE_INDEX(X2AXIS,X3AXIS,XYZ,IND_PI)
!
! INTEGER,  INTENT(IN)  :: X2AXIS,X3AXIS
! REAL(EB), INTENT(IN)  :: XYZ(MAX_DIM)
! INTEGER,  INTENT(OUT) :: IND_PI
!
! ! Local variables:
! !LOGICAL :: INLIST
! INTEGER :: INOD
!
! ! Test if XYZ is already on BODINT_PLANE%XYZ:
! ! INLIST = .FALSE.
! IND_PI = -1 ! Initialize to negative index.
! DO INOD=1,BODINT_PLANE%NNODS
!    IF(ABS(BODINT_PLANE%XYZ(X2AXIS,INOD)-XYZ(X2AXIS)) > GEOMEPS) CYCLE
!    IF(ABS(BODINT_PLANE%XYZ(X3AXIS,INOD)-XYZ(X3AXIS)) > GEOMEPS) CYCLE
!    IND_PI = INOD
!    RETURN
! ENDDO
!
! WRITE(LU_ERR,*) 'X2AXIS,X3AXIS',X2AXIS,X3AXIS,BODINT_PLANE%NNODS,INOD
! IND_PI = BODINT_PLANE%NNODS + 1
! BODINT_PLANE%NNODS = IND_PI
! BODINT_PLANE%XYZ(IAXIS:KAXIS,IND_PI) = XYZ
! DO INOD=1,BODINT_PLANE%NNODS
!    WRITE(LU_ERR,*) INOD,BODINT_PLANE%XYZ(IAXIS:KAXIS,INOD)
! ENDDO
! RETURN
! END SUBROUTINE GET_BODINT_NODE_INDEX


! -------------------- LINE_INTERSECT_COORDPLANE --------------------------------

SUBROUTINE LINE_INTERSECT_COORDPLANE(X1AXIS,X1PLN,PLNORMAL,LNC,XYZ_INT,INTFLG)

INTEGER, INTENT(IN)  :: X1AXIS
REAL(EB), INTENT(IN) :: X1PLN,PLNORMAL(MAX_DIM),LNC(MAX_DIM,NOD1:NOD2)
REAL(EB), INTENT(OUT):: XYZ_INT(MAX_DIM)
LOGICAL, INTENT(OUT) :: INTFLG

! Local variables:
REAL(EB) :: DVEC(MAX_DIM), DIRV(MAX_DIM), NMDV, DENOM, PLNEQ, TLINE

! Initialize:
INTFLG = .FALSE.
XYZ_INT(IAXIS:KAXIS) = 0._EB

! Preliminary calculations:
DVEC(IAXIS:KAXIS) = LNC(IAXIS:KAXIS,NOD2) - LNC(IAXIS:KAXIS,NOD1)
NMDV = SQRT( DVEC(IAXIS)**2._EB + DVEC(JAXIS)**2._EB + DVEC(KAXIS)**2._EB )
DIRV = DVEC(IAXIS:KAXIS) * NMDV**(-1._EB)
DENOM = DIRV(IAXIS)*PLNORMAL(IAXIS) +DIRV(JAXIS)*PLNORMAL(JAXIS) +DIRV(KAXIS)*PLNORMAL(KAXIS)
PLNEQ = LNC(IAXIS,NOD1)*PLNORMAL(IAXIS) + &
        LNC(JAXIS,NOD1)*PLNORMAL(JAXIS) + &
        LNC(KAXIS,NOD1)*PLNORMAL(KAXIS) - X1PLN

! Line parallel to plane:
IF ( ABS(DENOM) < GEOMEPS ) THEN
   ! Check if seg lies on plane or not.
   ! Do this by checking if node one of segment is on plane.
   IF ( ABS(PLNEQ) < GEOMEPS ) THEN
      XYZ_INT(IAXIS:KAXIS) = LNC(IAXIS:KAXIS,NOD1); XYZ_INT(X1AXIS) = X1PLN
      INTFLG = .TRUE.
   ENDIF
   RETURN
ENDIF

! Non parallel case:
TLINE = -PLNEQ/DENOM  ! Coordinate along the line LNC.
XYZ_INT(IAXIS:KAXIS) = LNC(IAXIS:KAXIS,NOD1) + TLINE*DIRV(IAXIS:KAXIS) ! Intersection point.
XYZ_INT(X1AXIS) = X1PLN ! Force X1AXIS coordinate to be the planes value.
INTFLG = .TRUE.

RETURN
END SUBROUTINE LINE_INTERSECT_COORDPLANE


! ------------------------- IBM_INIT_GEOM ---------------------------------------

SUBROUTINE IBM_INIT_GEOM

! Local Variables:
INTEGER :: IG, IWSEL, INOD, IEDGE, NWSEL, NWSEDG, IEDLIST, IX
INTEGER :: WSELEM(NOD1:NOD3),SEG(NOD1:NOD2)
REAL(EB):: XYZV(MAX_DIM,NODS_WSEL), V12(MAX_DIM), V23(MAX_DIM), WSNORM(MAX_DIM)
REAL(EB):: X12(MAX_DIM), X23(MAX_DIM), X31(MAX_DIM), SQAREA(MAX_DIM), INT2
REAL(EB):: MGNRM, XCEN
LOGICAL :: INLIST

! Geometry loop:
GEOMETRY_LOOP : DO IG=1,N_GEOMETRY

   NWSEL = GEOMETRY(IG)%N_FACES

   ! Allocate fields of Geometry used by IBM:
   ! WS Faces normal unit vectors:
   IF (ALLOCATED(GEOMETRY(IG)%FACES_NORMAL)) DEALLOCATE(GEOMETRY(IG)%FACES_NORMAL)
   ALLOCATE(GEOMETRY(IG)%FACES_NORMAL(MAX_DIM,NWSEL))
   ! WS Faces areas:
   IF (ALLOCATED(GEOMETRY(IG)%FACES_AREA)) DEALLOCATE(GEOMETRY(IG)%FACES_AREA)
   ALLOCATE(GEOMETRY(IG)%FACES_AREA(NWSEL))
   ! WS Faces edges:
   IF (ALLOCATED(GEOMETRY(IG)%EDGES)) DEALLOCATE(GEOMETRY(IG)%EDGES)
   ALLOCATE(GEOMETRY(IG)%EDGES(NOD1:NOD2,3*NWSEL)) ! Size large enough to take care of surfaces
                                         ! (zero thickness immersed solids) and 3D domains
                                         ! boundaries (what we call wet surfaces).
   ! WS Faces edges:
   IF (ALLOCATED(GEOMETRY(IG)%FACE_EDGES)) DEALLOCATE(GEOMETRY(IG)%FACE_EDGES)
   ALLOCATE(GEOMETRY(IG)%FACE_EDGES(EDG1:EDG3,NWSEL)) ! Edges in GEOMETRY(IG)%EDGES for this triangle.
   ! WS Edges faces:
   IF (ALLOCATED(GEOMETRY(IG)%EDGE_FACES)) DEALLOCATE(GEOMETRY(IG)%EDGE_FACES)
   ALLOCATE(GEOMETRY(IG)%EDGE_FACES(5,3*NWSEL)) ! Triangles sharing this edge [niel iwel1 LocEdge1 iwel2 LocEdge2]

   GEOMETRY(IG)%GEOM_VOLUME    = 0._EB
   GEOMETRY(IG)%GEOM_AREA      = 0._EB
   GEOMETRY(IG)%GEOM_XYZCEN(:) = 0._EB

   ! Compute normal, area and volume:
   SQAREA(IAXIS:KAXIS) = 0._EB
   DO IWSEL=1,NWSEL

      WSELEM(NOD1:NOD3) = GEOMETRY(IG)%FACES(NODS_WSEL*(IWSEL-1)+1:NODS_WSEL*IWSEL)

      ! Triangles NODES coordinates:
      DO INOD=NOD1,NOD3
         XYZV(IAXIS:KAXIS,INOD) = GEOMETRY(IG)%VERTS(MAX_DIM*(WSELEM(INOD)-1)+1:MAX_DIM*WSELEM(INOD))
      ENDDO

      V12(IAXIS:KAXIS) = XYZV(IAXIS:KAXIS,NOD2) - XYZV(IAXIS:KAXIS,NOD1)
      V23(IAXIS:KAXIS) = XYZV(IAXIS:KAXIS,NOD3) - XYZV(IAXIS:KAXIS,NOD2)

      ! Cross V12 x V23:
      WSNORM(IAXIS) = V12(JAXIS)*V23(KAXIS) - V12(KAXIS)*V23(JAXIS)
      WSNORM(JAXIS) = V12(KAXIS)*V23(IAXIS) - V12(IAXIS)*V23(KAXIS)
      WSNORM(KAXIS) = V12(IAXIS)*V23(JAXIS) - V12(JAXIS)*V23(IAXIS)

      MGNRM = SQRT( WSNORM(IAXIS)**2._EB + WSNORM(JAXIS)**2._EB + WSNORM(KAXIS)**2._EB )

      XCEN  = (XYZV(IAXIS,NOD1) + XYZV(IAXIS,NOD2) + XYZV(IAXIS,NOD3)) / 3._EB

      IF(MGNRM < GEOMEPS) THEN
         WRITE(LU_ERR,*) 'FACE IWSEL=',IWSEL,', Connectivity=',WSELEM(NOD1:NOD3),', Norm Cross=',MGNRM
      ENDIF

      ! Assign to GEOMETRY:
      GEOMETRY(IG)%FACES_NORMAL(IAXIS:KAXIS,IWSEL) = WSNORM(IAXIS:KAXIS) * MGNRM**(-1._EB)
      GEOMETRY(IG)%FACES_AREA(IWSEL) = MGNRM/2._EB
      ! Total Area and Volume for GEOMETRY(IG).
      GEOMETRY(IG)%GEOM_AREA  = GEOMETRY(IG)%GEOM_AREA  + GEOMETRY(IG)%FACES_AREA(IWSEL)
      GEOMETRY(IG)%GEOM_VOLUME= GEOMETRY(IG)%GEOM_VOLUME+ & ! Divergence theorem with F = x i, assumes we have a volume.
      GEOMETRY(IG)%FACES_NORMAL(IAXIS,IWSEL)*XCEN*GEOMETRY(IG)%FACES_AREA(IWSEL)

      ! Define Centroid:
      X12(IAXIS:KAXIS) = 0.5_EB*(XYZV(IAXIS:KAXIS,NOD1) + XYZV(IAXIS:KAXIS,NOD2))
      X23(IAXIS:KAXIS) = 0.5_EB*(XYZV(IAXIS:KAXIS,NOD2) + XYZV(IAXIS:KAXIS,NOD3))
      X31(IAXIS:KAXIS) = 0.5_EB*(XYZV(IAXIS:KAXIS,NOD3) + XYZV(IAXIS:KAXIS,NOD1))
      ! dot(i,nc) int(x^2)dA, dot(j,nc) int(y^2)dA, dot(k,nc) int(z^2)dA
      DO IX=IAXIS,KAXIS
         INT2 = (X12(IX)**2._EB + X23(IX)**2._EB + X31(IX)**2._EB) / 3._EB
         SQAREA(IX) = SQAREA(IX) + GEOMETRY(IG)%FACES_NORMAL(IX,IWSEL)*INT2*GEOMETRY(IG)%FACES_AREA(IWSEL) ! Midpt rule.
      ENDDO
   ENDDO

   ! Geometry Centroid:
   DO IX=IAXIS,KAXIS
      GEOMETRY(IG)%GEOM_XYZCEN(IX) = SQAREA(IX) / (2._EB * GEOMETRY(IG)%GEOM_VOLUME)
   ENDDO

   NWSEDG = 0
   DO IWSEL=1,NWSEL

      WSELEM(NOD1:NOD3) = GEOMETRY(IG)%FACES(NODS_WSEL*(IWSEL-1)+1:NODS_WSEL*IWSEL)

      DO IEDGE=EDG1,EDG3

         SEG(NOD1:NOD2) = WSELEM(NOD1:NOD2)

         ! Test triangles edge iedge is already on list
         ! GEOMETRY(IG)%EDGES. Makes use of fact that two triangles
         ! sharing an edge have opposite connectivity for it (right hand
         ! rule for connectivity for normal outside solid).
         INLIST = .FALSE.
         DO IEDLIST=1,NWSEDG
            ! TEST SEG(2)=EDGE(1) AND SEG(1)=EDGE(2):
            IF ( (SEG(NOD1) == GEOMETRY(IG)%EDGES(NOD2,IEDLIST)) .AND. &
                 (SEG(NOD2) == GEOMETRY(IG)%EDGES(NOD1,IEDLIST)) ) THEN
               INLIST = .TRUE.
               EXIT
            ENDIF
         ENDDO
         IF (INLIST) THEN ! LOCAL EDGE ALREADY ON LIST.
             GEOMETRY(IG)%EDGE_FACES(1,IEDLIST)   = 2
             GEOMETRY(IG)%EDGE_FACES(4,IEDLIST)   = IWSEL;
             GEOMETRY(IG)%EDGE_FACES(5,IEDLIST)   = IEDGE;
             GEOMETRY(IG)%FACE_EDGES(IEDGE,IWSEL) = IEDLIST;
         ELSE ! NEW ENTRY ON LIST
             NWSEDG = NWSEDG + 1;
             GEOMETRY(IG)%EDGES(NOD1:NOD2,NWSEDG) = SEG(NOD1:NOD2)
             GEOMETRY(IG)%EDGE_FACES(1,NWSEDG)    = 1
             GEOMETRY(IG)%EDGE_FACES(2,NWSEDG)    = IWSEL
             GEOMETRY(IG)%EDGE_FACES(3,NWSEDG)    = IEDGE
             GEOMETRY(IG)%FACE_EDGES(IEDGE,IWSEL) = NWSEDG
         ENDIF

         WSELEM=CSHIFT(WSELEM,1)

      ENDDO
   ENDDO

   GEOMETRY(IG)%N_EDGES = NWSEDG

ENDDO GEOMETRY_LOOP

! Print out of computed result:
! DO IG=1,N_GEOMETRY
!    NWSEL = GEOMETRY(IG)%N_FACES
!    DO IWSEL=1,NWSEL
!       print*, IWSEL,GEOMETRY(IG)%FACES_AREA(IWSEL)
!    ENDDO
!    DO IWSEL=1,NWSEL
!       print*, IWSEL,GEOMETRY(IG)%FACES_NORMAL(IAXIS:KAXIS,IWSEL)
!    ENDDO
!    print*, "EDGES="
!    DO NWSEDG=1,GEOMETRY(IG)%N_EDGES
!       print*, NWSEDG,GEOMETRY(IG)%EDGES(NOD1:NOD2,NWSEDG)
!    ENDDO
!    DO NWSEDG=1,GEOMETRY(IG)%N_EDGES
!       print*, GEOMETRY(IG)%EDGE_FACES(1:5,NWSEDG)
!    ENDDO
!    print*, "FACES="
!    DO IWSEL=1,NWSEL
!       print*, IWSEL,GEOMETRY(IG)%FACE_EDGES(EDG1:EDG3,IWSEL)
!    ENDDO
! ENDDO

RETURN
END SUBROUTINE IBM_INIT_GEOM

! ------------------------- GET_X2_VERTVAR --------------------------------------

SUBROUTINE GET_X2_VERTVAR(X1AXIS,X2LO,X2HI,NM,I,KK)

USE COMP_FUNCTIONS, ONLY: CURRENT_TIME

INTEGER, INTENT(IN) :: X1AXIS,X2LO,X2HI,NM,I,KK

! Local Variables:
INTEGER :: ICRS,ICRS1,JSTR,JEND,JJ,X2LO_LOC,X2HI_LOC
REAL(EB):: TNOW

TNOW=CURRENT_TIME()

! Increase by one the search size:
X2LO_LOC = X2LO  !- 1
X2HI_LOC = X2HI  !+ 1

! Work By Edge, Only one x1axis=IAXIS needs to be used:
SELECT CASE(X1AXIS)
CASE(IAXIS)
   ! Case of GG, SS points:
   DO ICRS=1,IBM_N_CRS
      ! If is_crs(icrs) == GG, SS, SGG see if crossing is
      ! exactly on a Cartesian cell vertex:
      SELECT CASE(IBM_IS_CRS(ICRS))
      CASE(IBM_GG,IBM_SS)

         ! Optimized and will ONLY work for Uniform Grids:
         JSTR = MAX(X2LO_LOC,   FLOOR((IBM_SVAR_CRS(ICRS)-GEOMEPS-X2FACE(X2LO_LOC))/DX2FACE(X2LO_LOC)) + X2LO_LOC)
         JEND = MIN(X2HI_LOC, CEILING((IBM_SVAR_CRS(ICRS)+GEOMEPS-X2FACE(X2LO_LOC))/DX2FACE(X2LO_LOC)) + X2LO_LOC)

         DO JJ=JSTR,JEND
            ! Crossing on Vertex?
            IF ( ABS(X2FACE(JJ)-IBM_SVAR_CRS(ICRS)) < GEOMEPS ) THEN
               MESHES(NM)%VERTVAR(I,JJ,KK,IBM_VGSC) = IBM_SOLID
               EXIT
            ENDIF
         ENDDO

      END SELECT
   ENDDO

   ! Other cases:
   DO ICRS=1,IBM_N_CRS-1
      ! Case GS-SG: All Cartesian vertices are set to IBM_SOLID.
      IF (IBM_IS_CRS(ICRS) == IBM_GS) THEN
         ! Find corresponding SG intersection:
         DO ICRS1=ICRS+1,IBM_N_CRS
            IF (IBM_IS_CRS(ICRS1) == IBM_SG) EXIT
         ENDDO
         ! Optimized for UG:
         JSTR = MAX(X2LO_LOC, CEILING(( IBM_SVAR_CRS(ICRS)-GEOMEPS-X2FACE(X2LO_LOC))/DX2FACE(X2LO_LOC)) + X2LO_LOC)
         JEND = MIN(X2HI_LOC,   FLOOR((IBM_SVAR_CRS(ICRS1)+GEOMEPS-X2FACE(X2LO_LOC))/DX2FACE(X2LO_LOC)) + X2LO_LOC)

         DO JJ=JSTR,JEND
            MESHES(NM)%VERTVAR(I,JJ,KK,IBM_VGSC) = IBM_SOLID
         ENDDO
      ENDIF
   ENDDO

! CASE(JAXIS)
!
!    ! Case of GG, SS points:
!    DO ICRS=1,IBM_N_CRS
!       ! If is_crs(icrs) == GG, SS, SGG see if crossing is
!       ! exactly on a Cartesian cell vertex:
!       SELECT CASE(IBM_IS_CRS(ICRS))
!       CASE(IBM_GG,IBM_SS)
!
!          ! Low guard-cell region:
!          JJ= X2LO_LOC
!          ! Crossing on Vertex?
!          IF ( ABS(X2FACE(JJ)-IBM_SVAR_CRS(ICRS)) < GEOMEPS ) MESHES(NM)%VERTVAR(KK,I,JJ,IBM_VGSC) = IBM_SOLID
!
!          ! Hi guard-cell region:
!          JJ= X2HI_LOC
!          ! Crossing on Vertex?
!          IF ( ABS(X2FACE(JJ)-IBM_SVAR_CRS(ICRS)) < GEOMEPS ) MESHES(NM)%VERTVAR(KK,I,JJ,IBM_VGSC) = IBM_SOLID
!
!       END SELECT
!    ENDDO
!
!    ! Other cases:
!    DO ICRS=1,IBM_N_CRS-1
!       ! Case GS-SG: All Cartesian vertices are set to IBM_SOLID.
!       IF (IBM_IS_CRS(ICRS) == IBM_GS) THEN
!          ! Find corresponding SG intersection:
!          DO ICRS1=ICRS+1,IBM_N_CRS
!             IF (IBM_IS_CRS(ICRS1) == IBM_SG) EXIT
!          ENDDO
!
!          ! Optimized for UG:
!          JSTR = MAX(X2LO_LOC, CEILING(( IBM_SVAR_CRS(ICRS)-GEOMEPS-X2FACE(X2LO_LOC))/DX2FACE(X2LO_LOC)) + X2LO_LOC)
!          JEND = MIN(X2LO    ,   FLOOR((IBM_SVAR_CRS(ICRS1)+GEOMEPS-X2FACE(X2LO_LOC))/DX2FACE(X2LO_LOC)) + X2LO_LOC)
!
!          DO JJ=JSTR,JEND
!             MESHES(NM)%VERTVAR(KK,I,JJ,IBM_VGSC) = IBM_SOLID
!          ENDDO
!
!          ! Optimized for UG:
!          JSTR = MAX(X2HI    , CEILING(( IBM_SVAR_CRS(ICRS)-GEOMEPS-X2FACE(X2LO_LOC))/DX2FACE(X2LO_LOC)) + X2LO_LOC)
!          JEND = MIN(X2HI_LOC,   FLOOR((IBM_SVAR_CRS(ICRS1)+GEOMEPS-X2FACE(X2LO_LOC))/DX2FACE(X2LO_LOC)) + X2LO_LOC)
!
!          DO JJ=JSTR,JEND
!             MESHES(NM)%VERTVAR(KK,I,JJ,IBM_VGSC) = IBM_SOLID
!          ENDDO
!       ENDIF
!    ENDDO
!
! CASE(KAXIS)
!
!    ! Case of GG, SS points:
!    DO ICRS=1,IBM_N_CRS
!       ! If is_crs(icrs) == GG, SS, SGG see if crossing is
!       ! exactly on a Cartesian cell vertex:
!       SELECT CASE(IBM_IS_CRS(ICRS))
!       CASE(IBM_GG,IBM_SS)
!
!          ! Low guard-cell region:
!          JJ= X2LO_LOC
!          ! Crossing on Vertex?
!          IF ( ABS(X2FACE(JJ)-IBM_SVAR_CRS(ICRS)) < GEOMEPS ) MESHES(NM)%VERTVAR(JJ,KK,I,IBM_VGSC) = IBM_SOLID
!
!          ! Hi guard-cell region:
!          JJ= X2HI_LOC
!          ! Crossing on Vertex?
!          IF ( ABS(X2FACE(JJ)-IBM_SVAR_CRS(ICRS)) < GEOMEPS ) MESHES(NM)%VERTVAR(JJ,KK,I,IBM_VGSC) = IBM_SOLID
!
!       END SELECT
!    ENDDO
!
!    ! Other cases:
!    DO ICRS=1,IBM_N_CRS-1
!       ! Case GS-SG: All Cartesian vertices are set to IBM_SOLID.
!       IF (IBM_IS_CRS(ICRS) == IBM_GS) THEN
!          ! Find corresponding SG intersection:
!          DO ICRS1=ICRS+1,IBM_N_CRS
!             IF (IBM_IS_CRS(ICRS1) == IBM_SG) EXIT
!          ENDDO
!
!          ! Optimized for UG:
!          JSTR = MAX(X2LO_LOC, CEILING(( IBM_SVAR_CRS(ICRS)-GEOMEPS-X2FACE(X2LO_LOC))/DX2FACE(X2LO_LOC)) + X2LO_LOC)
!          JEND = MIN(X2LO    ,   FLOOR((IBM_SVAR_CRS(ICRS1)+GEOMEPS-X2FACE(X2LO_LOC))/DX2FACE(X2LO_LOC)) + X2LO_LOC)
!
!          DO JJ=JSTR,JEND
!             MESHES(NM)%VERTVAR(JJ,KK,I,IBM_VGSC) = IBM_SOLID
!          ENDDO
!
!          ! Optimized for UG:
!          JSTR = MAX(X2HI    , CEILING(( IBM_SVAR_CRS(ICRS)-GEOMEPS-X2FACE(X2LO_LOC))/DX2FACE(X2LO_LOC)) + X2LO_LOC)
!          JEND = MIN(X2HI_LOC,   FLOOR((IBM_SVAR_CRS(ICRS1)+GEOMEPS-X2FACE(X2LO_LOC))/DX2FACE(X2LO_LOC)) + X2LO_LOC)
!
!          DO JJ=JSTR,JEND
!             MESHES(NM)%VERTVAR(JJ,KK,I,IBM_VGSC) = IBM_SOLID
!          ENDDO
!       ENDIF
!    ENDDO

END SELECT

T_CC_USED(GET_X2_VERTVAR_TIME_INDEX) = T_CC_USED(GET_X2_VERTVAR_TIME_INDEX) + CURRENT_TIME() - TNOW

RETURN
END SUBROUTINE GET_X2_VERTVAR

! -------------------------- GET_CARTEDGE_CUTEDGES ------------------------------

SUBROUTINE GET_CARTEDGE_CUTEDGES(X1AXIS,X2AXIS,X3AXIS,XIAXIS,XJAXIS,XKAXIS, &
                                 NM,X2LO_CELL,X2HI_CELL,INDX1,KK)

USE COMP_FUNCTIONS, ONLY: CURRENT_TIME

INTEGER, INTENT(IN) :: X1AXIS,X2AXIS,X3AXIS,XIAXIS,XJAXIS,XKAXIS, &
                       NM,X2LO_CELL,X2HI_CELL,INDX1(MAX_DIM),KK

! Local Variables:
INTEGER :: NEDGECROSS, NEDGECROSS_OLD, NCUTEDGE, JJ, INDXI(MAX_DIM), INDI, INDJ, INDK
INTEGER :: INDI1, INDJ1, INDK1, INDIE, INDJE, INDKE, NCROSS, ICROSS, ICRS, JSTR
INTEGER :: JJLOW, JJHIGH, JJADD
REAL(EB):: DELJJ
LOGICAL :: VSOLID, DIF, VFLUID
REAL(EB):: X123VERT(MAX_DIM,IBM_MAXCROSS_EDGE), XCEN, YCEN, ZCEN, SCEN, XYZCEN(IAXIS:KAXIS)
INTEGER :: NEDGE, NVERT, IVERT
LOGICAL :: IS_GASPHASE
REAL(EB) :: TNOW

TNOW=CURRENT_TIME()

! INTEGER, ALLOCATABLE, DIMENSION(:,:) :: CEELEMAUX, INDSEGAUX
! INTEGER :: NEDGE_SIZE

!  Now define Crossings on Cartesian Edges and Body segments:
!  - Edges: MESHES(NM) % ECVAR(:,:,:,IBM_EGSC,IAXIS) =
!                        ECVAR(:,:,:,IBM_EGSC,JAXIS) = IBM_GASPHASE, IBM_SOLID or IBM_CUTCFE
!                        ECVAR(:,:,:,IBM_EGSC,KAXIS) =
!                        ECVAR(:,:,:,IBM_ECRS,IAXIS) =
!                        ECVAR(:,:,:,IBM_ECRS,JAXIS) = Index to Corresponding EDGE_CROSS array.
!                        ECVAR(:,:,:,IBM_ECRS,KAXIS) =
!           MESHES(NM) % EDGE_CROSS: Data structure with
!                        crossings per cartesian edge information.
!                       .NCROSS = Number of crossings.
!                       .SVAR(1:NCROSS)   = distances along edge from lower
!                                           Cartesian vertex.
!           Note: Crossings right on vertices do not need to be added,
!           they are taken care of by setting VERTVAR(iv,jv,kv,IBM_VGSC,lb)=IBM_SOLID.
!           MESHES(NM) % CUT_EDGE: Data structure with info on IBM_GASPHASE cut-edges,
!                        per Cartesian Edge and IBM_INBOUNDARY cut-edges, per
!                        Cartesian Face:
!                       .NVERT  = number of vertices on cut-edges.
!                       .NEDGE  = number of cut-edges.
!                       .XYZVERT(IAXIS:KAXIS,1:NVERT) = Segments Vertices
!                       .CEELEM(NOD1:NOD2,1:NEDGE) = Segments connectivity list.
!                       .STATUS = IBM_GASPHASE or IBM_INBOUNDARY; if latter
!                       .IJK    = [I J K AXIS] for Cartesian Edge if status = IBM_GASPHASE
!                               = [I J K AXIS] for Cartesian Face if status = IBM_INBOUNDARY
!                       .INDSEG(1:4,1:NEDGE)   = [nwel iwel1 iwel2 ibod] if status = IBM_INBOUNDARY
!           Also:
!                       ECVAR(:,:,:,IBM_IDCE,IAXIS,:) =
!                       ECVAR(:,:,:,IBM_IDCE,IAXIS,:) = index on CUT_EDGE location.
!                       ECVAR(:,:,:,IBM_IDCE,IAXIS,:) =
!
!  Now figure out which segment the intersections belong to, also
!  add intersections to body segments.
!  As defined, a Cartesian CUT_EDGE is defined by:
!  1. A crossing.
!  2. A VERTVAR(iv,jv,kv,IBM_VGSC,lb) =    IBM_SOLID and another
!       VERTVAR(iv,jv,kv,IBM_VGSC,lb) = IBM_GASPHASE

! Set initially edges with MESHES(NM)%VERTVAR vertices == IBM_SOLID to IBM_SOLID status:
DO JJ=X2LO_CELL,X2HI_CELL

    ! Vert at index JJ-FCELL:
    INDXI(IAXIS:KAXIS) = (/ INDX1(X1AXIS), JJ-FCELL, KK /) ! Local x1,x2,x3
    INDI=INDXI(XIAXIS)
    INDJ=INDXI(XJAXIS)
    INDK=INDXI(XKAXIS)
    ! Vert at index JJ-FCELL+1:
    INDXI(IAXIS:KAXIS) = (/ INDX1(X1AXIS), JJ-FCELL+1, KK /) ! Local x1,x2,x3
    INDI1=INDXI(XIAXIS)
    INDJ1=INDXI(XJAXIS)
    INDK1=INDXI(XKAXIS)
    ! Edge at index JJ:
    INDXI(IAXIS:KAXIS) = (/ INDX1(X1AXIS), JJ, KK /) ! Local x1,x2,x3
    INDIE=INDXI(XIAXIS)
    INDJE=INDXI(XJAXIS)
    INDKE=INDXI(XKAXIS)

    IF ((MESHES(NM)%VERTVAR(INDI ,INDJ ,INDK ,IBM_VGSC) == IBM_SOLID) .AND. &
        (MESHES(NM)%VERTVAR(INDI1,INDJ1,INDK1,IBM_VGSC) == IBM_SOLID) )     &
         MESHES(NM)%ECVAR(INDIE,INDJE,INDKE,IBM_EGSC,X2AXIS) = IBM_SOLID

ENDDO


NEDGECROSS_OLD = MESHES(NM) % N_EDGE_CROSS
! Edges with Crossings not on VERTICES:
ICRS_DO : DO ICRS=1,IBM_N_CRS

    ! Skip SOLID-SOLID intersections, as there is no media crossing:
    IF (IBM_IS_CRS(ICRS) == IBM_SS) CYCLE

    ! Check location on grid of crossing:
    ! See if crossing is exactly on a Cartesian cell vertex:
    ! Optimized for UG:
    JSTR = FLOOR( (IBM_SVAR_CRS(ICRS)-GEOMEPS-X2CELL(X2LO_CELL))/DX2CELL(X2LO_CELL) ) + X2LO_CELL

    ! Discard cut-edges on Cartesian edges laying > X2HI_CELL.
    IF (JSTR < X2LO_CELL-1) CYCLE
    IF (JSTR > X2HI_CELL+1) CYCLE

    ! Check on candidate cells
    JJ_DO : DO JJ=JSTR,JSTR ! Cell indexing:

        DELJJ = ABS(X2CELL(JJ)-IBM_SVAR_CRS(ICRS)) - DX2CELL(X2LO_CELL)/2._EB

        ! Crossing on Vertex?
        IF ( ABS(DELJJ) < GEOMEPS ) THEN ! Add crossing to two edges:
            JJLOW=0; JJHIGH=1
        ELSEIF ( DELJJ < -GEOMEPS ) THEN ! Crossing in jj Edge.
            JJLOW=0; JJHIGH=0
        ELSEIF ( DELJJ > GEOMEPS ) THEN ! Crossing in jj+1 Edge.
            JJLOW=1; JJHIGH=1
        ENDIF

        DO JJADD=JJLOW,JJHIGH
            ! Edge in the left:
            ! Edge at index JJ or JJ+1:
            INDXI(IAXIS:KAXIS) = (/ INDX1(X1AXIS), JJ+JJADD, KK /) ! Local x1,x2,x3
            INDIE=INDXI(XIAXIS)
            INDJE=INDXI(XJAXIS)
            INDKE=INDXI(XKAXIS)

            ! Set MESHES(NM)%ECVAR(IE,JE,KE,IBM_EGSC,X2AXIS) = IBM_CUTCFE:
            ICROSS = MESHES(NM)%ECVAR(INDIE,INDJE,INDKE,IBM_ECRS,X2AXIS)

            IF ( ICROSS > 0 ) THEN ! Edge has crossings already.

                ! Populate EDGECROSS struct:
                NCROSS = MESHES(NM)%EDGE_CROSS(ICROSS)%NCROSS + 1
                MESHES(NM)%EDGE_CROSS(ICROSS) % NCROSS       = NCROSS
                MESHES(NM)%EDGE_CROSS(ICROSS) % SVAR(NCROSS) = IBM_SVAR_CRS(ICRS)
                MESHES(NM)%EDGE_CROSS(ICROSS) % ISVAR(NCROSS)= IBM_IS_CRS(ICRS)

            ELSE ! No crossings yet.

                NEDGECROSS = MESHES(NM)%N_EDGE_CROSS + 1
                MESHES(NM)%ECVAR(INDIE,INDJE,INDKE,IBM_EGSC,X2AXIS) = IBM_CUTCFE
                MESHES(NM)%N_EDGE_CROSS                      = NEDGECROSS
                MESHES(NM)%ECVAR(INDIE,INDJE,INDKE,IBM_ECRS,X2AXIS) = NEDGECROSS

                ! Populate EDGECROSS struct:
                NCROSS = 1
                MESHES(NM)%EDGE_CROSS(NEDGECROSS) % NCROSS       = NCROSS
                MESHES(NM)%EDGE_CROSS(NEDGECROSS) % SVAR(NCROSS) = IBM_SVAR_CRS(ICRS)
                MESHES(NM)%EDGE_CROSS(NEDGECROSS) % ISVAR(NCROSS)= IBM_IS_CRS(ICRS)
                MESHES(NM)%EDGE_CROSS(NEDGECROSS) % IJK(1:4) = (/ INDIE, INDJE, INDKE, X2AXIS /)

            ENDIF

        ENDDO

    ENDDO JJ_DO

ENDDO ICRS_DO

! Now Define MESHES(NM)%CUT_EDGE for IBM_GASPHASE cut-edges:
! First: Run over crossings and set MESHES(NM)%IBM_CUT_EDGES:
DO ICROSS=NEDGECROSS_OLD+1,MESHES(NM)%N_EDGE_CROSS

   ! Discard edge outside of blocks ranges for ray on x2axis:
   IF ( (MESHES(NM)%EDGE_CROSS(ICROSS)%IJK(X2AXIS) < X2LO_CELL) .OR. &
        (MESHES(NM)%EDGE_CROSS(ICROSS)%IJK(X2AXIS) > X2HI_CELL) ) CYCLE

   NCROSS = MESHES(NM)%EDGE_CROSS(ICROSS)%NCROSS

   ! Edge Location in x1,x2,x3 axes:
   ! Vert at index JJ-FCELL:
   INDXI(IAXIS:KAXIS) = (/ MESHES(NM)%EDGE_CROSS(ICROSS)%IJK(X1AXIS),       &
                           MESHES(NM)%EDGE_CROSS(ICROSS)%IJK(X2AXIS)-FCELL, &
                           MESHES(NM)%EDGE_CROSS(ICROSS)%IJK(X3AXIS) /) ! Local x1,x2,x3
   INDI=INDXI(XIAXIS)
   INDJ=INDXI(XJAXIS)
   INDK=INDXI(XKAXIS)
   ! Vert at index JJ-FCELL+1:
   INDXI(IAXIS:KAXIS) = (/ MESHES(NM)%EDGE_CROSS(ICROSS)%IJK(X1AXIS),           &
                           MESHES(NM)%EDGE_CROSS(ICROSS)%IJK(X2AXIS)-FCELL+1,   &
                           MESHES(NM)%EDGE_CROSS(ICROSS)%IJK(X3AXIS) /) ! Local x1,x2,x3
   INDI1=INDXI(XIAXIS)
   INDJ1=INDXI(XJAXIS)
   INDK1=INDXI(XKAXIS)
   ! Edge at index jj:
   INDXI(IAXIS:KAXIS) = (/ MESHES(NM)%EDGE_CROSS(ICROSS)%IJK(X1AXIS),    &
                           MESHES(NM)%EDGE_CROSS(ICROSS)%IJK(X2AXIS),    &
                           MESHES(NM)%EDGE_CROSS(ICROSS)%IJK(X3AXIS) /) ! Local x1,x2,x3
   INDIE=INDXI(XIAXIS) ! i.e. MESHES(NM)%EDGE_CROSS(ICROSS)%IJK(IAXIS), etc.
   INDJE=INDXI(XJAXIS)
   INDKE=INDXI(XKAXIS)

   ! Discard Edge with one EDGECROSS and both vertices having VERTVAR = IBM_SOLID:
   ! The crossing is on one of the edge vertices.
   IF ( (NCROSS == 1)                                                 .AND. &
        (MESHES(NM)%VERTVAR(INDI ,INDJ ,INDK ,IBM_VGSC) == IBM_SOLID) .AND. &
        (MESHES(NM)%VERTVAR(INDI1,INDJ1,INDK1,IBM_VGSC) == IBM_SOLID) ) THEN

      MESHES(NM)%ECVAR(INDIE,INDJE,INDKE,IBM_EGSC,X2AXIS) = IBM_SOLID
      CYCLE

   ENDIF

   ! Discard cases for edge with two crossings:
   IF ( NCROSS == 2 ) THEN

      VSOLID = (MESHES(NM)%VERTVAR(INDI ,INDJ ,INDK ,IBM_VGSC) == IBM_SOLID) .AND. &
               (MESHES(NM)%VERTVAR(INDI1,INDJ1,INDK1,IBM_VGSC) == IBM_SOLID)

      ! Test if crossings lay on same location + solid vertices:
      DIF  = ( MESHES(NM)%EDGE_CROSS(ICROSS)%SVAR(2) - &
               MESHES(NM)%EDGE_CROSS(ICROSS)%SVAR(1) ) < GEOMEPS
      IF (DIF .AND. VSOLID) THEN
           MESHES(NM)%ECVAR(INDIE,INDJE,INDKE,IBM_EGSC,X2AXIS) = IBM_SOLID
           CYCLE
      ENDIF

      DIF  = (ABS(X2FACE(MESHES(NM)%EDGE_CROSS(ICROSS)%IJK(X2AXIS)-FCELL  ) -     &
                         MESHES(NM)%EDGE_CROSS(ICROSS)%SVAR(1)) < GEOMEPS)  .AND. &
             (ABS(X2FACE(MESHES(NM)%EDGE_CROSS(ICROSS)%IJK(X2AXIS)-FCELL+1) -     &
                         MESHES(NM)%EDGE_CROSS(ICROSS)%SVAR(2)) < GEOMEPS)

      VFLUID  = (MESHES(NM)%EDGE_CROSS(ICROSS)%ISVAR(1) == IBM_GS)  .AND. &
                (MESHES(NM)%EDGE_CROSS(ICROSS)%ISVAR(2) == IBM_SG)

      IF (DIF .AND. VSOLID .AND. VFLUID) THEN
         MESHES(NM)%ECVAR(INDIE,INDJE,INDKE,IBM_EGSC,X2AXIS) = IBM_SOLID
         CYCLE
      ENDIF

   ENDIF

   ! New CUT_EDGE struct for this edge:
   NCUTEDGE = MESHES(NM)%N_CUTEDGE_MESH + 1
   MESHES(NM)%N_CUTEDGE_MESH                       = NCUTEDGE
   MESHES(NM)%ECVAR(INDIE,INDJE,INDKE,IBM_IDCE,X2AXIS)= NCUTEDGE
   MESHES(NM)%CUT_EDGE(NCUTEDGE)%STATUS           = IBM_GASPHASE
   MESHES(NM)%CUT_EDGE(NCUTEDGE)%IJK(1:MAX_DIM+1) = MESHES(NM)%EDGE_CROSS(ICROSS)%IJK(1:MAX_DIM+1)
   MESHES(NM)%CUT_EDGE(NCUTEDGE)%IJK(MAX_DIM+2)   = IBM_UNDEFINED ! No need to define type of CUT_EDGE
                                                                      ! (is IBM_GASPHASE).
   ! First Vertices:
   NVERT = NCROSS + 2
   MESHES(NM)%CUT_EDGE(NCUTEDGE)%NVERT = NVERT
   X123VERT(IAXIS:KAXIS,1:NVERT) = 0._EB
   X123VERT(IAXIS,1:NVERT)   = X1FACE(MESHES(NM)%EDGE_CROSS(ICROSS)%IJK(X1AXIS))
   X123VERT(JAXIS,1)         = X2FACE(MESHES(NM)%EDGE_CROSS(ICROSS)%IJK(X2AXIS)-FCELL)
   X123VERT(JAXIS,2:NCROSS+1)= MESHES(NM)%EDGE_CROSS(ICROSS)%SVAR(1:NCROSS)
   X123VERT(JAXIS,NVERT)     = X2FACE(MESHES(NM)%EDGE_CROSS(ICROSS)%IJK(X2AXIS)-FCELL+1)
   X123VERT(KAXIS,1:NVERT)   = X3FACE(MESHES(NM)%EDGE_CROSS(ICROSS)%IJK(X3AXIS))

   ! Allocate new edge XYZVERT, CEELEM, INDSEG
   CALL NEW_EDGE_ALLOC(NM,NCUTEDGE,NVERT,IBM_ALLOC_DELEM)
   DO IVERT=1,MESHES(NM)%CUT_EDGE(NCUTEDGE)%NVERT
      MESHES(NM)%CUT_EDGE(NCUTEDGE)%XYZVERT(IAXIS:KAXIS,IVERT) = &
                        X123VERT( (/ XIAXIS, XJAXIS, XKAXIS /) ,IVERT)
   ENDDO

   ! Now Cut Edges:
   ! Cross type:
   !VERT_TYPE(1)          = MESHES(NM)%VERTVAR(indI ,indJ ,indK ,IBM_VGSC)
   !VERT_TYPE(2:NCROSS+1) = MESHES(NM)%EDGE_CROSS(ICROSS)%ISVAR(1:NCROSS)
   !VERT_TYPE(NVERT)      = MESHES(NM)%VERTVAR(indI1,indJ1,indK1,IBM_VGSC)

   ! This assumes crossings are ordered for increasing svar, no repeated svar:
   NEDGE = 0
   MESHES(NM)%CUT_EDGE(NCUTEDGE)%NEDGE = NEDGE
   DO IVERT=1,MESHES(NM)%CUT_EDGE(NCUTEDGE)%NVERT-1

      ! Drop zero length edge (in x2 local dir):
      IF (ABS(X123VERT(JAXIS,IVERT)-X123VERT(JAXIS,IVERT+1)) < GEOMEPS) CYCLE

      ! Define if the cut-edge is gasphase:
      ! Ray tracing for the center of the cut-edge most robust.
      XCEN  = 0.5_EB*(MESHES(NM)%CUT_EDGE(NCUTEDGE)%XYZVERT(IAXIS,IVERT  ) + &
                      MESHES(NM)%CUT_EDGE(NCUTEDGE)%XYZVERT(IAXIS,IVERT+1))
      YCEN  = 0.5_EB*(MESHES(NM)%CUT_EDGE(NCUTEDGE)%XYZVERT(JAXIS,IVERT  ) + &
                      MESHES(NM)%CUT_EDGE(NCUTEDGE)%XYZVERT(JAXIS,IVERT+1))
      ZCEN  = 0.5_EB*(MESHES(NM)%CUT_EDGE(NCUTEDGE)%XYZVERT(KAXIS,IVERT  ) + &
                      MESHES(NM)%CUT_EDGE(NCUTEDGE)%XYZVERT(KAXIS,IVERT+1))
      XYZCEN(IAXIS:KAXIS) = (/ XCEN, YCEN, ZCEN /)

      ! Do a SOLID crossing count up to XYZcen(x2axis):
      SCEN=XYZCEN(X2AXIS)
      CALL GET_IS_GASPHASE(SCEN,IS_GASPHASE)
      ![isgasphase]=get_isgasphase(n_crs,svar_crs,is_crs,scen);

      IF ( IS_GASPHASE ) THEN
         NEDGE = NEDGE + 1
         ! Test for size of CEELEM, INDSEG, if smaller than NEDGE reallocate:
         CALL REALLOCATE_EDGE_ELEM(NM,NCUTEDGE,NEDGE)
         MESHES(NM)%CUT_EDGE(NCUTEDGE)%NEDGE = NEDGE
         MESHES(NM)%CUT_EDGE(NCUTEDGE)%CEELEM(NOD1:NOD2,NEDGE) = (/ IVERT, IVERT+1 /)
      ENDIF
   ENDDO

   IF (MESHES(NM)%CUT_EDGE(NCUTEDGE)%NEDGE == 0) THEN ! REWIND
      DEALLOCATE(MESHES(NM)%CUT_EDGE(NCUTEDGE)%XYZVERT)
      DEALLOCATE(MESHES(NM)%CUT_EDGE(NCUTEDGE)%CEELEM)
      DEALLOCATE(MESHES(NM)%CUT_EDGE(NCUTEDGE)%INDSEG)
      NCUTEDGE = NCUTEDGE - 1
      MESHES(NM)%N_CUTEDGE_MESH                        = NCUTEDGE
      MESHES(NM)%ECVAR(INDIE,INDJE,INDKE,IBM_IDCE,X2AXIS) = 0
   ENDIF

ENDDO

T_CC_USED(GET_CARTEDGE_CUTEDGES_TIME_INDEX) = T_CC_USED(GET_CARTEDGE_CUTEDGES_TIME_INDEX) + CURRENT_TIME() - TNOW

RETURN
END SUBROUTINE GET_CARTEDGE_CUTEDGES

! ----------------------------- NEW_EDGE_ALLOC ----------------------------------

SUBROUTINE NEW_EDGE_ALLOC(NM,CEI,NVERTALLOC,NEDGEALLOC)

INTEGER, INTENT(IN) :: NM, CEI, NVERTALLOC, NEDGEALLOC

ALLOCATE(MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,1:NVERTALLOC))
ALLOCATE(MESHES(NM)%CUT_EDGE(CEI)%NOD_PERM(1:NVERTALLOC))
ALLOCATE(MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,1:NEDGEALLOC))
ALLOCATE(MESHES(NM)%CUT_EDGE(CEI)%INDSEG(IBM_MAX_WSTRIANG_SEG+2,1:NEDGEALLOC))

MESHES(NM)%CUT_EDGE(CEI)%XYZVERT = 0._EB
MESHES(NM)%CUT_EDGE(CEI)%NOD_PERM= IBM_UNDEFINED
MESHES(NM)%CUT_EDGE(CEI)%CEELEM  = IBM_UNDEFINED
MESHES(NM)%CUT_EDGE(CEI)%INDSEG  = IBM_UNDEFINED

RETURN

END SUBROUTINE NEW_EDGE_ALLOC

! ------------------ REALLOCATE_EDGE_VERT(NM,CEI,NVERT) -------------------------

SUBROUTINE REALLOCATE_EDGE_VERT(NM,CEI,NVERT)

INTEGER, INTENT(IN) :: NM, CEI, NVERT

! Local Variables:
INTEGER :: NVERT_SIZE
REAL(EB), ALLOCATABLE, DIMENSION(:,:) :: XYZVERTAUX
INTEGER,  ALLOCATABLE, DIMENSION(:)   :: NOD_PERMAUX

NVERT_SIZE = SIZE(MESHES(NM)%CUT_EDGE(CEI)%XYZVERT, DIM=2)

IF (NVERT > NVERT_SIZE) THEN ! Reallocate XYZVERT
   ALLOCATE(XYZVERTAUX(IAXIS:KAXIS,1:NVERT_SIZE))
   XYZVERTAUX(IAXIS:KAXIS,1:NVERT_SIZE) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(:,:)
   DEALLOCATE(MESHES(NM)%CUT_EDGE(CEI)%XYZVERT)
   ALLOCATE(MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,1:NVERT_SIZE+IBM_ALLOC_DVERT))
   MESHES(NM)%CUT_EDGE(CEI)%XYZVERT = 0._EB
   MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,1:NVERT_SIZE) = XYZVERTAUX(IAXIS:KAXIS,1:NVERT_SIZE)

   ALLOCATE(NOD_PERMAUX(1:NVERT_SIZE))
   NOD_PERMAUX(1:NVERT_SIZE) = MESHES(NM)%CUT_EDGE(CEI)%NOD_PERM(1:NVERT_SIZE)
   DEALLOCATE(MESHES(NM)%CUT_EDGE(CEI)%NOD_PERM)
   ALLOCATE(MESHES(NM)%CUT_EDGE(CEI)%NOD_PERM(1:NVERT_SIZE+IBM_ALLOC_DVERT))
   MESHES(NM)%CUT_EDGE(CEI)%NOD_PERM = IBM_UNDEFINED
   MESHES(NM)%CUT_EDGE(CEI)%NOD_PERM(1:NVERT_SIZE) = NOD_PERMAUX(1:NVERT_SIZE)

   DEALLOCATE(XYZVERTAUX, NOD_PERMAUX)
ENDIF

RETURN

END SUBROUTINE REALLOCATE_EDGE_VERT

! ------------------ REALLOCATE_EDGE_ELEM(NM,CEI,NEDGE) -------------------------

SUBROUTINE REALLOCATE_EDGE_ELEM(NM,CEI,NEDGE)

INTEGER, INTENT(IN) :: NM, CEI, NEDGE

! Local Variables:
INTEGER :: NEDGE_SIZE, IBM_ALLOC_ELEM
INTEGER, ALLOCATABLE, DIMENSION(:,:) :: CEELEMAUX, INDSEGAUX

NEDGE_SIZE = SIZE(MESHES(NM)%CUT_EDGE(CEI)%CEELEM, DIM=2)

IF (NEDGE > NEDGE_SIZE) THEN ! Reallocate CEELEM,

   IBM_ALLOC_ELEM = MAX(NEDGE-NEDGE_SIZE,IBM_ALLOC_DELEM)

   ALLOCATE(CEELEMAUX(NOD1:NOD2,1:NEDGE_SIZE), INDSEGAUX(IBM_MAX_WSTRIANG_SEG+2,1:NEDGE_SIZE))
   CEELEMAUX(:,:) = MESHES(NM)%CUT_EDGE(CEI)%CEELEM(:,:)
   INDSEGAUX(:,:) = MESHES(NM)%CUT_EDGE(CEI)%INDSEG(:,:)

   DEALLOCATE(MESHES(NM)%CUT_EDGE(CEI)%CEELEM,MESHES(NM)%CUT_EDGE(CEI)%INDSEG)

   ALLOCATE(MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,1:NEDGE_SIZE+IBM_ALLOC_ELEM))
   MESHES(NM)%CUT_EDGE(CEI)%CEELEM = IBM_UNDEFINED
   MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,1:NEDGE_SIZE) = CEELEMAUX(NOD1:NOD2,1:NEDGE_SIZE)

   ALLOCATE(MESHES(NM)%CUT_EDGE(CEI)%INDSEG(IBM_MAX_WSTRIANG_SEG+2,1:NEDGE_SIZE+IBM_ALLOC_ELEM))
   MESHES(NM)%CUT_EDGE(CEI)%INDSEG = IBM_UNDEFINED
   MESHES(NM)%CUT_EDGE(CEI)%INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,1:NEDGE_SIZE) = &
   INDSEGAUX(1:IBM_MAX_WSTRIANG_SEG+2,1:NEDGE_SIZE)

   DEALLOCATE(CEELEMAUX,INDSEGAUX)
ENDIF

RETURN

END SUBROUTINE REALLOCATE_EDGE_ELEM

! -------------------------- GET_ISGASPHASE -------------------------------------

SUBROUTINE GET_IS_GASPHASE(SCEN,IS_GASPHASE)

REAL(EB), INTENT(IN) :: SCEN
LOGICAL, INTENT(OUT) :: IS_GASPHASE

! Local Variables:
LOGICAL :: IS_GASPHASE_LEFT, IS_GASPHASE_RIGHT
INTEGER :: ICRS

! Count GS,SG intersections from both sides:
IS_GASPHASE_LEFT = .TRUE.
DO ICRS=1,IBM_N_CRS

   IF (SCEN < IBM_SVAR_CRS(ICRS)) CYCLE

   ! If solid change state:
   IF ( (IBM_IS_CRS(ICRS) == IBM_GS) .OR. (IBM_IS_CRS(ICRS) == IBM_SG) ) THEN
        IS_GASPHASE_LEFT = .NOT.IS_GASPHASE_LEFT
   ENDIF
ENDDO

IS_GASPHASE_RIGHT = .TRUE.
DO ICRS=IBM_N_CRS,1,-1
    IF (SCEN > IBM_SVAR_CRS(ICRS)) CYCLE

    ! If solid change state:
    IF ( (IBM_IS_CRS(ICRS) == IBM_GS) .OR. (IBM_IS_CRS(ICRS) == IBM_SG) ) THEN
        IS_GASPHASE_RIGHT = .NOT.IS_GASPHASE_RIGHT
    ENDIF
ENDDO

! If at least one of left and right are true -> add
! IBM_GASPHASE cut-edge:
IS_GASPHASE = IS_GASPHASE_LEFT .OR. IS_GASPHASE_RIGHT

RETURN
END SUBROUTINE GET_IS_GASPHASE

! --------------------- GET_BODX2_INTERSECTIONS ---------------------------------

SUBROUTINE GET_BODX2_INTERSECTIONS(X2AXIS,X3AXIS,X3RAY)

USE COMP_FUNCTIONS, ONLY: CURRENT_TIME

INTEGER, INTENT(IN) :: X2AXIS,X3AXIS
REAL(EB),INTENT(IN) :: X3RAY

! Local Variables:
REAL(EB) :: XYZ1(MAX_DIM), XYZ2(MAX_DIM), X2_1, X2_2, X3_1, X3_2, SLEN, SBOD
REAL(EB) :: STANI(IAXIS:JAXIS), DV(IAXIS:JAXIS)
INTEGER  :: ICRS, ISEG, SEG(NOD1:NOD2), NBCROSS, IBCR, IDUM
REAL(EB) :: TNOW

TNOW=CURRENT_TIME()


IF ( BODINT_PLANE%NSEGS == 0) RETURN

DO ICRS=1,IBM_N_CRS

   ISEG = IBM_SEG_CRS(ICRS)

   IF (ISEG < 0) CYCLE ! it is a single point element.

   SEG(NOD1:NOD2)    = BODINT_PLANE%SEGS(NOD1:NOD2,ISEG)
   XYZ1(IAXIS:KAXIS) = BODINT_PLANE%XYZ(IAXIS:KAXIS,SEG(NOD1))
   XYZ2(IAXIS:KAXIS) = BODINT_PLANE%XYZ(IAXIS:KAXIS,SEG(NOD2))

   ! x2_x3 of segment point 1:
   X2_1 = XYZ1(X2AXIS); X3_1 = XYZ1(X3AXIS)
   ! x2_x3 of segment point 2:
   X2_2 = XYZ2(X2AXIS); X3_2 = XYZ2(X3AXIS)

   ! Segment length:
   SLEN = SQRT( (X2_2-X2_1)**2._EB + (X3_2-X3_1)**2._EB )

   ! Unit vector along segment:
   STANI(IAXIS:JAXIS) = IBM_SEG_TAN(IAXIS:JAXIS,ICRS)

   ! S coordinate along segment:
   DV(IAXIS:JAXIS)= (/ (IBM_SVAR_CRS(ICRS)-X2_1), (X3RAY-X3_1) /)
   SBOD = DV(IAXIS)*STANI(IAXIS)+DV(JAXIS)*STANI(JAXIS)

   ! If crossing is at one end, cycle:
   IF ( (ABS(SBOD) < GEOMEPS) .OR. (ABS(SBOD-SLEN) < GEOMEPS) ) CYCLE

   ! Add crossing to BODINT_PLANE, insertion sort:
   NBCROSS  = BODINT_PLANE%NBCROSS(ISEG) + 1
   BODINT_PLANE%SVAR(NBCROSS,ISEG) = 1._EB/GEOMEPS
   DO IBCR=1,NBCROSS
    IF ( SBOD < BODINT_PLANE%SVAR(IBCR,ISEG) ) EXIT
   ENDDO

   ! Here copy from the back (updated nbcross) to the ibcr location:
   DO IDUM = NBCROSS,IBCR+1,-1
      BODINT_PLANE%SVAR(IDUM,ISEG) = BODINT_PLANE%SVAR(IDUM-1,ISEG)
   ENDDO
   BODINT_PLANE%SVAR(IBCR,ISEG) = SBOD
   BODINT_PLANE%NBCROSS(ISEG)   = NBCROSS

ENDDO

T_CC_USED(GET_BODX2X3_INTERSECTIONS_TIME_INDEX) = T_CC_USED(GET_BODX2X3_INTERSECTIONS_TIME_INDEX) + CURRENT_TIME() - TNOW
RETURN
END SUBROUTINE GET_BODX2_INTERSECTIONS

! ----------------------- GET_BODX3_INTERSECTIONS -------------------------------

SUBROUTINE GET_BODX3_INTERSECTIONS(X2AXIS,X3AXIS,X2LO,X2HI)

USE COMP_FUNCTIONS, ONLY: CURRENT_TIME

INTEGER,  INTENT(IN) :: X2AXIS,X3AXIS,X2LO,X2HI

! Local Variables:
REAL(EB) :: XYZ1(MAX_DIM), XYZ2(MAX_DIM), X2_1, X2_2, X3_1, X3_2, SLEN, SBOD
REAL(EB) :: STANI(IAXIS:JAXIS), DV(IAXIS:JAXIS), MINX, MAXX, XI1, XI2, DX2_1, DX2_2
INTEGER  :: ISEG, SEG(NOD1:NOD2), NBCROSS, IBCR, IDUM, JSTR, JEND, JJ
LOGICAL  :: ISCONT
REAL(EB) :: TNOW

TNOW=CURRENT_TIME()

DO ISEG=1,BODINT_PLANE%NSEGS

   if(BODINT_PLANE%X3ALIGNED(ISEG)) CYCLE ! This segment is not aligned with x3.

   SEG(NOD1:NOD2)    = BODINT_PLANE%SEGS(NOD1:NOD2,ISEG)
   XYZ1(IAXIS:KAXIS) = BODINT_PLANE%XYZ(IAXIS:KAXIS,SEG(NOD1))
   XYZ2(IAXIS:KAXIS) = BODINT_PLANE%XYZ(IAXIS:KAXIS,SEG(NOD2))

   ! x2_x3 of segment point 1:
   X2_1 = XYZ1(X2AXIS); X3_1 = XYZ1(X3AXIS)
   ! x2_x3 of segment point 2:
   X2_2 = XYZ2(X2AXIS); X3_2 = XYZ2(X3AXIS)

   ! Segment length:
   SLEN = SQRT( (X2_2-X2_1)**2._EB + (X3_2-X3_1)**2._EB )

   ! Unit vector along segment:
   STANI(IAXIS:JAXIS) = (/ (X2_2-X2_1), (X3_2-X3_1) /)*SLEN**(-1._EB)

   ! Optimized for UG:
   MINX = MIN(X2_1,X2_2)
   MAXX = MAX(X2_1,X2_2)
   JSTR = MAX(X2LO, CEILING((  MINX-GEOMEPS-X2FACE(X2LO))/DX2FACE(X2LO))+X2LO)
   JEND = MIN(X2HI,   FLOOR((  MAXX+GEOMEPS-X2FACE(X2LO))/DX2FACE(X2LO))+X2LO)

   DO JJ=JSTR,JEND

      ! S coordinate along segment:
      DX2_1 = X2_2 - X2FACE(JJ)
      DX2_2 = X2FACE(JJ) - X2_1
      XI1   = DX2_1 / (X2_2-X2_1)
      XI2   = DX2_2 / (X2_2-X2_1)
      DV(IAXIS:JAXIS) = (/ DX2_2, (XI1-1._EB)*X3_1+XI2*X3_2 /)
      SBOD = DV(IAXIS)*STANI(IAXIS)+DV(JAXIS)*STANI(JAXIS)

      ! If crossing is already defined, cycle:
      NBCROSS = BODINT_PLANE%NBCROSS(ISEG)
      ISCONT = .FALSE.
      DO IBCR=1,NBCROSS
         IF ( ABS(SBOD-BODINT_PLANE%SVAR(IBCR,ISEG)) < GEOMEPS ) ISCONT = .TRUE.
      ENDDO
      IF (ISCONT) CYCLE

      ! Add crossing to BODINT_PLANE, insertion sort:
      NBCROSS = BODINT_PLANE%NBCROSS(ISEG) + 1
      BODINT_PLANE%SVAR(NBCROSS,ISEG) = 1._EB/GEOMEPS
      DO IBCR=1,NBCROSS
         IF ( SBOD < BODINT_PLANE%SVAR(IBCR,ISEG) ) EXIT
      ENDDO

      ! Here copy from the back (updated nbcross) to the ibcr location:
      DO IDUM = NBCROSS,IBCR+1,-1
         BODINT_PLANE%SVAR(IDUM,ISEG) = BODINT_PLANE%SVAR(IDUM-1,ISEG)
      ENDDO
      BODINT_PLANE%SVAR(IBCR,ISEG) = SBOD
      BODINT_PLANE%NBCROSS(ISEG)   = NBCROSS

   ENDDO

ENDDO

T_CC_USED(GET_BODX2X3_INTERSECTIONS_TIME_INDEX) = T_CC_USED(GET_BODX2X3_INTERSECTIONS_TIME_INDEX) + CURRENT_TIME() - TNOW

RETURN
END SUBROUTINE GET_BODX3_INTERSECTIONS

! ----------------------- GET_CARTFACE_CUTEDGES ---------------------------------

SUBROUTINE GET_CARTFACE_CUTEDGES(X1AXIS,X2AXIS,X3AXIS,                   &
                                 XIAXIS,XJAXIS,XKAXIS,NM      ,          &
                                 X2LO,X2HI,X3LO,X3HI,X2LO_CELL,X2HI_CELL,     &
                                 X3LO_CELL,X3HI_CELL,INDX1)

USE COMP_FUNCTIONS, ONLY: CURRENT_TIME

INTEGER,  INTENT(IN) :: X1AXIS,X2AXIS,X3AXIS,XIAXIS,XJAXIS,XKAXIS,NM, &
                        X2LO,X2HI,X3LO,X3HI,X2LO_CELL,X2HI_CELL,           &
                        X3LO_CELL,X3HI_CELL,INDX1(MAX_DIM)

! Local Variables:
REAL(EB) :: XYZ1(MAX_DIM), XYZ2(MAX_DIM), X2_1, X2_2, X3_1, X3_2, SLEN
REAL(EB) :: STANI(IAXIS:JAXIS), SNORI(IAXIS:JAXIS), X2RAY, X3RAY
INTEGER  :: ISEG, SEG(NOD1:NOD2), NBCROSS, IEDGE, JJ, KK, JJ2, KK2, IPFACE, NPFACE, INOD1, INOD2
LOGICAL  :: ADD2FACES, INRAY, CONDAX
INTEGER  :: INDSEG(1:IBM_MAX_WSTRIANG_SEG+2), NTRISEG, CETYPE, JJ2VEC(LOW_IND:HIGH_IND), KK2VEC(LOW_IND:HIGH_IND)
REAL(EB) :: SVAR1, SVAR2, SVAR12, XPOS
INTEGER  :: INDXI(IAXIS:KAXIS), INDIF, INDJF, INDKF, CEI, NVERT, NEDGE, DIRAXIS
REAL(EB) :: XYZV1(IAXIS:KAXIS), XYZV1LC(IAXIS:KAXIS)
REAL(EB) :: XYZV2(IAXIS:KAXIS), XYZV2LC(IAXIS:KAXIS)
REAL(EB) :: TNOW

TNOW=CURRENT_TIME()

! Segment by segment define the INBOUNDARY MESHES(NM)%IBM_CUT_EDGES between crossings
! and individualize the Cartesian face they belong to.
! NCUTEDGEOLD   = MESHES(NM)%N_CUTEDGE_MESH + 1
SEGS_LOOP : DO ISEG=1,BODINT_PLANE%NSEGS

   NBCROSS = BODINT_PLANE%NBCROSS(ISEG) ! Cross points include Node1, Node2
   SEG(NOD1:NOD2)    = BODINT_PLANE%SEGS(NOD1:NOD2,ISEG)
   XYZ1(IAXIS:KAXIS) = BODINT_PLANE%XYZ(IAXIS:KAXIS,SEG(NOD1))
   XYZ2(IAXIS:KAXIS) = BODINT_PLANE%XYZ(IAXIS:KAXIS,SEG(NOD2))

   ! x2_x3 of segment point 1:
   X2_1 = XYZ1(X2AXIS); X3_1 = XYZ1(X3AXIS)
   ! x2_x3 of segment point 2:
   X2_2 = XYZ2(X2AXIS); X3_2 = XYZ2(X3AXIS)

   ! Normal out:
   SLEN = SQRT( (X2_2-X2_1)**2._EB + (X3_2-X3_1)**2._EB )
   STANI(IAXIS:JAXIS) = (/ (X2_2-X2_1), (X3_2-X3_1) /)*SLEN**(-1._EB)
   SNORI(IAXIS:JAXIS) = (/ STANI(JAXIS), -STANI(IAXIS) /)

   INDSEG(1:IBM_MAX_WSTRIANG_SEG+2) = BODINT_PLANE%INDSEG(1:IBM_MAX_WSTRIANG_SEG+2, ISEG)
   NTRISEG = INDSEG(1)

   ADD2FACES = .FALSE.
   ! Type to be assigned to cut edges:
   CETYPE = 2*(BODINT_PLANE%SEGTYPE(LOW_IND,ISEG)+1) - BODINT_PLANE%SEGTYPE(HIGH_IND,ISEG)
   IF ( CETYPE == IBM_GG ) ADD2FACES = .TRUE.

   INRAY  = .FALSE.

   ! Different cases:
   ! First check if segment geomepsilon aligned with x2:
   IF (BODINT_PLANE%X2ALIGNED(ISEG)) THEN

      ! Test if node1 of segment is in geomepsilon vicinity of an x2 ray
      DO KK=X3LO,X3HI
         ! x3 location of ray along x2, on the x2-x3 plane:
         X3RAY = X3FACE(KK)
         IF ( ABS(X3RAY-X3_1) < GEOMEPS ) THEN
            INRAY = .TRUE.
            EXIT
         ENDIF
      ENDDO

      IF (INRAY) THEN ! Segment in x2 ray defined by x3 face index kk.

         ! 1. INB cut-edges on top of an x2 gridline, assign to cut-face
         !    defined by normal out.
         KK2VEC(LOW_IND:HIGH_IND) = 0
         IF (ADD2FACES) THEN
             NPFACE   = 2
             KK2VEC(LOW_IND) = KK + FCELL
             KK2VEC(HIGH_IND)= KK + FCELL - 1
         ELSE
             NPFACE = 1
             if ( SNORI(JAXIS) > 0._EB ) THEN ! add 1 to index kk+FCELL-1 (i.e. lower face index)
                 KK2VEC(LOW_IND) = KK + FCELL
             ELSE
                 KK2VEC(LOW_IND)= KK + FCELL - 1
             ENDIF
         ENDIF

         DO IPFACE=1,NPFACE

            KK2 = KK2VEC(IPFACE)

            ! Figure out which cut faces the inboundary cut-edges of
            ! this segment belong to:
            ! We have nbcross-1 INBOUNDARY CUT_EDGEs to generate.
            DO IEDGE=1,NBCROSS-1

               ! Location along Segment:
               SVAR1 = BODINT_PLANE%SVAR(IEDGE  ,ISEG)
               SVAR2 = BODINT_PLANE%SVAR(IEDGE+1,ISEG)
               ! Location of midpoint of cut-edge:
               SVAR12 = 0.5_EB * (SVAR1+SVAR2)
               ! Define Cartesian segment this cut-edge belongs:
               XPOS   = X2_1 + SVAR12*STANI(IAXIS)
               JJ2 = FLOOR((XPOS-X2FACE(X2LO))/DX2FACE(X2LO)) + X2LO_CELL

               ! Discard cut-edges on faces laying on x2hi.
               IF ((JJ2 < X2LO_CELL) .OR. (JJ2 > X2HI_CELL)) CYCLE
               IF ((KK2 < X3LO_CELL) .OR. (KK2 > X3HI_CELL)) CYCLE

               ! Face indexes:
               INDXI(IAXIS:KAXIS) = (/ INDX1(X1AXIS), JJ2, KK2 /) ! Local x1,x2,x3
               INDIF=INDXI(XIAXIS)
               INDJF=INDXI(XJAXIS)
               INDKF=INDXI(XKAXIS)

               ! Now the face is, FCVAR (x1axis):
               IF (MESHES(NM)%FCVAR(INDIF,INDJF,INDKF,IBM_IDCE,X1AXIS) > 0) THEN ! There is already
                                                                                 ! an entry in CUT_EDGE.
                  CEI = MESHES(NM)%FCVAR(INDIF,INDJF,INDKF,IBM_IDCE,X1AXIS)
               ELSE ! We need a new entry in CUT_EDGE
                  CEI      = MESHES(NM)%N_CUTEDGE_MESH + 1
                  MESHES(NM)%N_CUTEDGE_MESH                       = CEI
                  MESHES(NM)%FCVAR(INDIF,INDJF,INDKF,IBM_IDCE,X1AXIS)= CEI
                  MESHES(NM)%CUT_EDGE(CEI)%NVERT   = 0
                  CALL NEW_EDGE_ALLOC(NM,CEI,IBM_ALLOC_DVERT,IBM_ALLOC_DELEM)
                  MESHES(NM)%CUT_EDGE(CEI)%NEDGE   = 0
                  MESHES(NM)%CUT_EDGE(CEI)%IJK(1:MAX_DIM+2) = (/ INDIF, INDJF, INDKF, X1AXIS, CETYPE /)
                  MESHES(NM)%CUT_EDGE(CEI)%STATUS  = IBM_INBOUNDCF
               ENDIF

               ! Add vertices, non repeated vertex entries at this point.
               NVERT = MESHES(NM)%CUT_EDGE(CEI)%NVERT
               ! Define vertices for this segment:
               !                                           xv1                      yv1                     zv1
               XYZV1LC(IAXIS:KAXIS)= (/ X1FACE(INDX1(X1AXIS)), X2_1+STANI(IAXIS)*SVAR1, X3_1+STANI(JAXIS)*SVAR1 /)
               XYZV1(IAXIS) = XYZV1LC(XIAXIS)
               XYZV1(JAXIS) = XYZV1LC(XJAXIS)
               XYZV1(KAXIS) = XYZV1LC(XKAXIS)
               CALL INSERT_FACE_VERT(XYZV1,NM,CEI,NVERT,INOD1)
               !                                           xv2                      yv2                     zv2
               XYZV2LC(IAXIS:KAXIS)= (/ X1FACE(INDX1(X1AXIS)), X2_1+STANI(IAXIS)*SVAR2, X3_1+STANI(JAXIS)*SVAR2 /)
               XYZV2(IAXIS) = XYZV2LC(XIAXIS)
               XYZV2(JAXIS) = XYZV2LC(XJAXIS)
               XYZV2(KAXIS) = XYZV2LC(XKAXIS)
               CALL INSERT_FACE_VERT(XYZV2,NM,CEI,NVERT,INOD2)

               NEDGE = MESHES(NM)%CUT_EDGE(CEI)%NEDGE
               CALL REALLOCATE_EDGE_ELEM(NM,CEI,NEDGE+1)
               IF ( NPFACE == 1 ) THEN
                  MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,NEDGE+1) = (/ INOD1, INOD2 /)
               ELSE
                  DIRAXIS = X2AXIS
                  CONDAX  = (XYZV2(DIRAXIS)-XYZV1(DIRAXIS)) > 0
                  IF ( KK2 == KK+FCELL-1 ) THEN
                     IF (CONDAX) THEN
                        MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,NEDGE+1) = (/ INOD1, INOD2 /)
                     ELSE
                        MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,NEDGE+1) = (/ INOD2, INOD1 /)
                     ENDIF
                  ELSE
                     IF (CONDAX) THEN
                        MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,NEDGE+1) = (/ INOD2, INOD1 /)
                     ELSE
                        MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,NEDGE+1) = (/ INOD1, INOD2 /)
                     ENDIF
                  ENDIF
               ENDIF
               MESHES(NM)%CUT_EDGE(CEI)%INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,NEDGE+1) = &
                               BODINT_PLANE%INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,ISEG)
               MESHES(NM)%CUT_EDGE(CEI)%NVERT = NVERT
               MESHES(NM)%CUT_EDGE(CEI)%NEDGE = NEDGE+1

            ENDDO
         ENDDO
         CYCLE ! Skips rest of iseg loop, for this ISEG.
      ENDIF

   ! Second check if segment geomepsilon aligned with x3:
   ELSEIF (BODINT_PLANE%X3ALIGNED(ISEG)) THEN

      ! Test if node1 of segment is in geomepsilon vicinity of an x3 ray
      DO JJ=X2LO,X2HI
         ! x2 location of ray along x3, on the x2-x3 plane:
         X2RAY = X2FACE(JJ)
         IF ( ABS(X2RAY-X2_1) < GEOMEPS ) THEN
            INRAY = .TRUE.
            EXIT
         ENDIF
      ENDDO

      IF (INRAY) THEN ! Segment in x3 ray defined by x2 face index JJ

         ! 1. INB cut-edges on top of an x3 gridline, assign to cut-face
         !    defined by normal out.
         JJ2VEC(LOW_IND:HIGH_IND) = 0
         IF (ADD2FACES) THEN
            NPFACE = 2
            JJ2VEC(LOW_IND)  = JJ + FCELL
            JJ2VEC(HIGH_IND) = JJ + FCELL - 1
         ELSE
            NPFACE = 1
            IF ( SNORI(IAXIS) > 0._EB ) THEN ! add 1 to index jj+FCELL-1 (i.e. lower face index)
               JJ2VEC(LOW_IND) = JJ + FCELL
            ELSE
               JJ2VEC(LOW_IND) = JJ + FCELL - 1
            ENDIF
         ENDIF

         DO IPFACE=1,NPFACE

            JJ2 = JJ2VEC(IPFACE)

            ! Figure out which cut faces the inboundary cut-edges of
            ! this segment belong to:
            ! We have NBCROSS-1 INBOUNDARY CUT_EDGEs to generate.
            DO IEDGE=1,NBCROSS-1

               ! Location along Segment:
               SVAR1 = BODINT_PLANE%SVAR(IEDGE  ,ISEG)
               SVAR2 = BODINT_PLANE%SVAR(IEDGE+1,ISEG)
               ! Location of midpoint of cut-edge:
               SVAR12 = 0.5_EB * (SVAR1+SVAR2)

               ! Define Cartesian segment this cut-edge belongs:
               XPOS = X3_1 + SVAR12*STANI(JAXIS)
               KK2 = FLOOR((XPOS-X3FACE(X3LO))/DX3FACE(X3LO)) + X3LO_CELL

               ! Discard cut-edges on faces laying on x3hi.
               IF ((JJ2 < X2LO_CELL) .OR. (JJ2 > X2HI_CELL)) CYCLE
               IF ((KK2 < X3LO_CELL) .OR. (KK2 > X3HI_CELL)) CYCLE

               ! Face indexes:
               INDXI(IAXIS:KAXIS) = (/ INDX1(X1AXIS), JJ2, KK2 /) ! Local x1,x2,x3
               INDIF=INDXI(XIAXIS)
               INDJF=INDXI(XJAXIS)
               INDKF=INDXI(XKAXIS)

               ! Now the face is, FCVAR (x1axis):
               IF (MESHES(NM)%FCVAR(INDIF,INDJF,INDKF,IBM_IDCE,X1AXIS) > 0) THEN ! There is already
                                                                                 ! an entry in CUT_EDGE.
                  CEI = MESHES(NM)%FCVAR(INDIF,INDJF,INDKF,IBM_IDCE,X1AXIS)
               ELSE ! We need a new entry in CUT_EDGE
                  CEI      = MESHES(NM)%N_CUTEDGE_MESH + 1
                  MESHES(NM)%N_CUTEDGE_MESH                       = CEI
                  MESHES(NM)%FCVAR(INDIF,INDJF,INDKF,IBM_IDCE,X1AXIS)= CEI
                  MESHES(NM)%CUT_EDGE(CEI)%NVERT   = 0
                  CALL NEW_EDGE_ALLOC(NM,CEI,IBM_ALLOC_DVERT,IBM_ALLOC_DELEM)
                  MESHES(NM)%CUT_EDGE(CEI)%NEDGE   = 0
                  MESHES(NM)%CUT_EDGE(CEI)%IJK(1:MAX_DIM+2) = (/ INDIF, INDJF, INDKF, X1AXIS, CETYPE /)
                  MESHES(NM)%CUT_EDGE(CEI)%STATUS  = IBM_INBOUNDCF
               ENDIF

               ! Add vertices, non repeated vertex entries at this point.
               NVERT = MESHES(NM)%CUT_EDGE(CEI)%NVERT
               ! Define vertices for this segment:
               !                                           xv1                      yv1                     zv1
               XYZV1LC(IAXIS:KAXIS)= (/ X1FACE(INDX1(X1AXIS)), X2_1+STANI(IAXIS)*SVAR1, X3_1+STANI(JAXIS)*SVAR1 /)
               XYZV1(IAXIS) = XYZV1LC(XIAXIS)
               XYZV1(JAXIS) = XYZV1LC(XJAXIS)
               XYZV1(KAXIS) = XYZV1LC(XKAXIS)
               CALL INSERT_FACE_VERT(XYZV1,NM,CEI,NVERT,INOD1)
               !                                           xv2                      yv2                     zv2
               XYZV2LC(IAXIS:KAXIS)= (/ X1FACE(INDX1(X1AXIS)), X2_1+STANI(IAXIS)*SVAR2, X3_1+STANI(JAXIS)*SVAR2 /)
               XYZV2(IAXIS) = XYZV2LC(XIAXIS)
               XYZV2(JAXIS) = XYZV2LC(XJAXIS)
               XYZV2(KAXIS) = XYZV2LC(XKAXIS)
               CALL INSERT_FACE_VERT(XYZV2,NM,CEI,NVERT,INOD2)

               NEDGE = MESHES(NM)%CUT_EDGE(CEI)%NEDGE
               CALL REALLOCATE_EDGE_ELEM(NM,CEI,NEDGE+1)
               IF ( NPFACE == 1 ) THEN
                  MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,NEDGE+1) = (/ INOD1, INOD2 /)
               ELSE
                  DIRAXIS = X3AXIS
                  CONDAX  = (XYZV2(DIRAXIS)-XYZV1(DIRAXIS)) > 0
                  IF ( JJ2 == JJ+FCELL-1 ) THEN
                     IF (CONDAX) THEN
                        MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,NEDGE+1) = (/ INOD2, INOD1 /)
                     ELSE
                        MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,NEDGE+1) = (/ INOD1, INOD2 /)
                     ENDIF
                  ELSE
                     IF (CONDAX) THEN
                        MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,NEDGE+1) = (/ INOD1, INOD2 /)
                     ELSE
                        MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,NEDGE+1) = (/ INOD2, INOD1 /)
                     ENDIF
                  ENDIF
               ENDIF
               MESHES(NM)%CUT_EDGE(CEI)%INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,NEDGE+1) = &
                               BODINT_PLANE%INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,ISEG)
               MESHES(NM)%CUT_EDGE(CEI)%NVERT = NVERT
               MESHES(NM)%CUT_EDGE(CEI)%NEDGE = NEDGE+1

            ENDDO
         ENDDO
         CYCLE ! Skips rest of iseg loop, for this ISEG.
      ENDIF

   ENDIF

   ! 3. Regular case: INB cut-edge with centroid inside a
   !    Cartesian face, assign to corresponding FCVAR IBM_IDCE variable.
   ! This is the most common case, INBOUNDARY edges defined inside x1 faces.
   ! We have NBCROSS-1 INBOUNDARY CUT_EDGEs to generate.
   DO IEDGE=1,NBCROSS-1

      ! Location along Segment:
      SVAR1 = BODINT_PLANE%SVAR(IEDGE  ,ISEG)
      SVAR2 = BODINT_PLANE%SVAR(IEDGE+1,ISEG)
      ! Location of midpoint of cut-edge:
      SVAR12 = 0.5_EB * (SVAR1+SVAR2)

      ! Define Cartesian face this cut-edge belongs:
      XPOS = X2_1 + SVAR12*STANI(IAXIS)
      JJ2  = FLOOR((XPOS-X2FACE(X2LO))/DX2FACE(X2LO)) + X2LO_CELL
      XPOS = X3_1 + SVAR12*STANI(JAXIS)
      KK2  = FLOOR((XPOS-X3FACE(X3LO))/DX3FACE(X3LO)) + X3LO_CELL

      ! Discard cut-edges on faces laying on x2hi and x3hi.
      IF ((JJ2 < X2LO_CELL) .OR. (JJ2 > X2HI_CELL)) CYCLE
      IF ((KK2 < X3LO_CELL) .OR. (KK2 > X3HI_CELL)) CYCLE

      ! Face indexes:
      INDXI(IAXIS:KAXIS) = (/ INDX1(X1AXIS), JJ2, KK2 /) ! Local x1,x2,x3
      INDIF=INDXI(XIAXIS)
      INDJF=INDXI(XJAXIS)
      INDKF=INDXI(XKAXIS)

      ! Now the face is, FCVAR (x1axis):
      IF (MESHES(NM)%FCVAR(INDIF,INDJF,INDKF,IBM_IDCE,X1AXIS) > 0) THEN ! There is already
                                                                        ! an entry in CUT_EDGE.
         CEI = MESHES(NM)%FCVAR(INDIF,INDJF,INDKF,IBM_IDCE,X1AXIS)
      ELSE ! We need a new entry in CUT_EDGE
         CEI      = MESHES(NM)%N_CUTEDGE_MESH + 1
         MESHES(NM)%N_CUTEDGE_MESH                       = CEI
         MESHES(NM)%FCVAR(INDIF,INDJF,INDKF,IBM_IDCE,X1AXIS)= CEI
         MESHES(NM)%CUT_EDGE(CEI)%NVERT   = 0
         CALL NEW_EDGE_ALLOC(NM,CEI,IBM_ALLOC_DVERT,IBM_ALLOC_DELEM)
         MESHES(NM)%CUT_EDGE(CEI)%NEDGE   = 0
         MESHES(NM)%CUT_EDGE(CEI)%IJK(1:MAX_DIM+2) = (/ INDIF, INDJF, INDKF, X1AXIS, CETYPE /)
         MESHES(NM)%CUT_EDGE(CEI)%STATUS  = IBM_INBOUNDCF
      ENDIF

      ! Add vertices, non repeated vertex entries at this point.
      NVERT = MESHES(NM)%CUT_EDGE(CEI)%NVERT

      ! Define vertices for this segment:
      !                                           xv1                      yv1                     zv1
      XYZV1LC(IAXIS:KAXIS)= (/ X1FACE(INDX1(X1AXIS)), X2_1+STANI(IAXIS)*SVAR1, X3_1+STANI(JAXIS)*SVAR1 /)
      XYZV1(IAXIS) = XYZV1LC(XIAXIS)
      XYZV1(JAXIS) = XYZV1LC(XJAXIS)
      XYZV1(KAXIS) = XYZV1LC(XKAXIS)
      CALL INSERT_FACE_VERT(XYZV1,NM,CEI,NVERT,INOD1)
      !                                           xv2                      yv2                     zv2
      XYZV2LC(IAXIS:KAXIS)= (/ X1FACE(INDX1(X1AXIS)), X2_1+STANI(IAXIS)*SVAR2, X3_1+STANI(JAXIS)*SVAR2 /)
      XYZV2(IAXIS) = XYZV2LC(XIAXIS)
      XYZV2(JAXIS) = XYZV2LC(XJAXIS)
      XYZV2(KAXIS) = XYZV2LC(XKAXIS)
      CALL INSERT_FACE_VERT(XYZV2,NM,CEI,NVERT,INOD2)

      NEDGE = MESHES(NM)%CUT_EDGE(CEI)%NEDGE
      CALL REALLOCATE_EDGE_ELEM(NM,CEI,NEDGE+1)
      MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,NEDGE+1) = (/ INOD1, INOD2 /)
      MESHES(NM)%CUT_EDGE(CEI)%INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,NEDGE+1) = &
                      BODINT_PLANE%INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,ISEG)
      MESHES(NM)%CUT_EDGE(CEI)%NVERT = NVERT
      MESHES(NM)%CUT_EDGE(CEI)%NEDGE = NEDGE+1

   ENDDO

ENDDO SEGS_LOOP

T_CC_USED(GET_CARTFACE_CUTEDGES_TIME_INDEX) = T_CC_USED(GET_CARTFACE_CUTEDGES_TIME_INDEX) + CURRENT_TIME() - TNOW

RETURN
END SUBROUTINE GET_CARTFACE_CUTEDGES

! ------------------------- INSERT_FACE_VERT ------------------------------------

SUBROUTINE INSERT_FACE_VERT(XYZV,NM,CEI,NVERT,INOD)

REAL(EB), INTENT(IN)   :: XYZV(MAX_DIM)
INTEGER,  INTENT(IN)   :: NM,CEI
INTEGER,  INTENT(INOUT):: NVERT
INTEGER,  INTENT(OUT)  :: INOD

! Local Variables:
! INTEGER  :: JNOD, JNOD2, PIVOT(LOW_IND:HIGH_IND)
! REAL(EB) :: DV(MAX_DIM)
! IF (NVERT < LINSEARCH_LIMIT) THEN
!    ! Linear Search:
!    DO JNOD=1,NVERT
!       DV(IAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS,MESHES(NM)%CUT_EDGE(CEI)%NOD_PERM(JNOD)) - XYZV(IAXIS)
!       IF( DV(IAXIS) > GEOMEPS ) THEN
!          EXIT
!       ELSEIF( ABS(DV(IAXIS)) <= GEOMEPS) THEN
!          DV(JAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(JAXIS,MESHES(NM)%CUT_EDGE(CEI)%NOD_PERM(JNOD)) - XYZV(JAXIS)
!          IF ( DV(JAXIS) > GEOMEPS ) THEN
!             EXIT
!          ELSEIF ( ABS(DV(JAXIS)) <= GEOMEPS ) THEN
!             DV(KAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(KAXIS,MESHES(NM)%CUT_EDGE(CEI)%NOD_PERM(JNOD)) - XYZV(KAXIS)
!             IF ( DV(KAXIS) > GEOMEPS ) THEN
!                EXIT
!             ELSEIF ( ABS(DV(KAXIS)) <= GEOMEPS ) THEN
!                INOD = MESHES(NM)%CUT_EDGE(CEI)%NOD_PERM(JNOD)
!                RETURN ! XYZV is in XYZVERT(IAXIS:KAXIS,NOD_PERM(JNOD))
!             ENDIF
!          ENDIF
!       ENDIF
!    ENDDO
! ELSE
!    ! Binary Search:
!    PIVOT(LOW_IND) = 0
!    PIVOT(HIGH_IND)= NVERT + 1
!    DO WHILE( (PIVOT(HIGH_IND)-PIVOT(LOW_IND)) > 1)
!       JNOD   = (PIVOT(LOW_IND)+PIVOT(HIGH_IND))/2
!       DV(IAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS,MESHES(NM)%CUT_EDGE(CEI)%NOD_PERM(JNOD)) - XYZV(IAXIS)
!       IF( DV(IAXIS) < -GEOMEPS ) THEN
!          PIVOT(LOW_IND) = JNOD
!       ELSEIF( DV(IAXIS) > GEOMEPS ) THEN
!          PIVOT(HIGH_IND)= JNOD
!       ELSE ! ABS(DV(IAXIS)) < GEOMEPS
!          DV(JAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(JAXIS,MESHES(NM)%CUT_EDGE(CEI)%NOD_PERM(JNOD)) - XYZV(JAXIS)
!          IF ( DV(JAXIS) < -GEOMEPS ) THEN
!             PIVOT(LOW_IND) = JNOD
!          ELSEIF( DV(JAXIS) > GEOMEPS ) THEN
!             PIVOT(HIGH_IND)= JNOD
!          ELSE ! ABS(DV(JAXIS)) < GEOMEPS
!             DV(KAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(KAXIS,MESHES(NM)%CUT_EDGE(CEI)%NOD_PERM(JNOD)) - XYZV(KAXIS)
!             IF ( DV(KAXIS) < -GEOMEPS ) THEN
!                PIVOT(LOW_IND) = JNOD
!             ELSEIF( DV(KAXIS) > GEOMEPS ) THEN
!                PIVOT(HIGH_IND)= JNOD
!             ELSE ! ABS(DV(KAXIS)) < GEOMEPS
!                INOD = MESHES(NM)%CUT_EDGE(CEI)%NOD_PERM(JNOD)
!                RETURN
!             ENDIF
!          ENDIF
!       ENDIF
!    ENDDO
!    JNOD=PIVOT(HIGH_IND)
! ENDIF
! ! Insert add NOD_PERM permutation array, O(NP) operation:
! INOD  = NVERT + 1
! NVERT = INOD
! CALL REALLOCATE_EDGE_VERT(NM,CEI,NVERT)
! DO JNOD2=NVERT,JNOD+1,-1
!   MESHES(NM)%CUT_EDGE(CEI)%NOD_PERM(JNOD2) = MESHES(NM)%CUT_EDGE(CEI)%NOD_PERM(JNOD2-1)
! ENDDO
! MESHES(NM)%CUT_EDGE(CEI)%NOD_PERM(JNOD) = INOD
! MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,INOD) = XYZV(IAXIS:KAXIS)

DO INOD=1,NVERT
   IF( ABS(XYZV(IAXIS)-MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS,INOD)) > GEOMEPS ) CYCLE
   IF( ABS(XYZV(JAXIS)-MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(JAXIS,INOD)) > GEOMEPS ) CYCLE
   IF( ABS(XYZV(KAXIS)-MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(KAXIS,INOD)) > GEOMEPS ) CYCLE
   RETURN
ENDDO
NVERT = NVERT + 1
INOD  = NVERT
CALL REALLOCATE_EDGE_VERT(NM,CEI,NVERT)
MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,INOD) = XYZV(IAXIS:KAXIS)

RETURN
END SUBROUTINE INSERT_FACE_VERT

! ------------------------- INSERT_FACE_VERT_LOC(XYZ,NVERT,INOD1,XYZVERT)

SUBROUTINE INSERT_FACE_VERT_LOC(MAXVERTS,XYZV,NVERT,INOD,XYZVERT)

INTEGER,  INTENT(IN)   :: MAXVERTS
REAL(EB), INTENT(IN)   :: XYZV(MAX_DIM)
REAL(EB), INTENT(INOUT), DIMENSION(IAXIS:KAXIS,1:MAXVERTS) :: XYZVERT  ! Locations of vertices.
INTEGER,  INTENT(INOUT):: NVERT
INTEGER,  INTENT(OUT)  :: INOD

! Local Variables:
! INTEGER  :: JNOD, JNOD2, PIVOT(LOW_IND:HIGH_IND)
! REAL(EB) :: DV(MAX_DIM)
! INTEGER, SAVE :: NOD_PERM(IBM_MAXVERTS_CELL)
! IF (NVERT < LINSEARCH_LIMIT) THEN
!    ! Linear Search:
!    DO JNOD=1,NVERT
!       DV(IAXIS) = XYZVERT(IAXIS,NOD_PERM(JNOD)) - XYZV(IAXIS)
!       IF( DV(IAXIS) > GEOMEPS ) THEN
!          EXIT
!       ELSEIF( ABS(DV(IAXIS)) <= GEOMEPS) THEN
!          DV(JAXIS) = XYZVERT(JAXIS,NOD_PERM(JNOD)) - XYZV(JAXIS)
!          IF ( DV(JAXIS) > GEOMEPS ) THEN
!             EXIT
!          ELSEIF ( ABS(DV(JAXIS)) <= GEOMEPS ) THEN
!             DV(KAXIS) = XYZVERT(KAXIS,NOD_PERM(JNOD)) - XYZV(KAXIS)
!             IF ( DV(KAXIS) > GEOMEPS ) THEN
!                EXIT
!             ELSEIF ( ABS(DV(KAXIS)) <= GEOMEPS ) THEN
!                INOD = NOD_PERM(JNOD)
!                RETURN ! XYZV is in XYZVERT(IAXIS:KAXIS,NOD_PERM(JNOD))
!             ENDIF
!          ENDIF
!       ENDIF
!    ENDDO
! ELSE
!    ! Binary Search:
!    PIVOT(LOW_IND) = 0
!    PIVOT(HIGH_IND)= NVERT + 1
!    DO WHILE( (PIVOT(HIGH_IND)-PIVOT(LOW_IND)) > 1)
!       JNOD   = (PIVOT(LOW_IND)+PIVOT(HIGH_IND))/2
!       DV(IAXIS) = XYZVERT(IAXIS,NOD_PERM(JNOD)) - XYZV(IAXIS)
!       IF( DV(IAXIS) < -GEOMEPS ) THEN
!          PIVOT(LOW_IND) = JNOD
!       ELSEIF( DV(IAXIS) > GEOMEPS ) THEN
!          PIVOT(HIGH_IND)= JNOD
!       ELSE ! ABS(DV(IAXIS)) < GEOMEPS
!          DV(JAXIS) = XYZVERT(JAXIS,NOD_PERM(JNOD)) - XYZV(JAXIS)
!          IF ( DV(JAXIS) < -GEOMEPS ) THEN
!             PIVOT(LOW_IND) = JNOD
!          ELSEIF( DV(JAXIS) > GEOMEPS ) THEN
!             PIVOT(HIGH_IND)= JNOD
!          ELSE ! ABS(DV(JAXIS)) < GEOMEPS
!             DV(KAXIS) = XYZVERT(KAXIS,NOD_PERM(JNOD)) - XYZV(KAXIS)
!             IF ( DV(KAXIS) < -GEOMEPS ) THEN
!                PIVOT(LOW_IND) = JNOD
!             ELSEIF( DV(KAXIS) > GEOMEPS ) THEN
!                PIVOT(HIGH_IND)= JNOD
!             ELSE ! ABS(DV(KAXIS)) < GEOMEPS
!                INOD = NOD_PERM(JNOD)
!                RETURN
!             ENDIF
!          ENDIF
!       ENDIF
!    ENDDO
!    JNOD=PIVOT(HIGH_IND)
! ENDIF
! ! Insert add NOD_PERM permutation array, O(NP) operation:
! INOD  = NVERT + 1
! NVERT = INOD
! IF (NVERT>MAXVERTS) WRITE(LU_ERR,*) 'geom.f90: INSERT_FACE_VERT_LOC, NVERT',NVERT,', higher than IBM_MAXVERTS',MAXVERTS
! DO JNOD2=NVERT,JNOD+1,-1
!   NOD_PERM(JNOD2) = NOD_PERM(JNOD2-1)
! ENDDO
! NOD_PERM(JNOD) = INOD
! XYZVERT(IAXIS:KAXIS,INOD) = XYZV(IAXIS:KAXIS)

DO INOD=1,NVERT
   IF( ABS(XYZV(IAXIS)-XYZVERT(IAXIS,INOD)) > GEOMEPS ) CYCLE
   IF( ABS(XYZV(JAXIS)-XYZVERT(JAXIS,INOD)) > GEOMEPS ) CYCLE
   IF( ABS(XYZV(KAXIS)-XYZVERT(KAXIS,INOD)) > GEOMEPS ) CYCLE
   RETURN
ENDDO
NVERT = NVERT + 1
INOD  = NVERT
IF (NVERT>MAXVERTS) WRITE(LU_ERR,*) 'geom.f90: INSERT_FACE_VERT_LOC, NVERT',NVERT,', higher than IBM_MAXVERTS',MAXVERTS
XYZVERT(IAXIS:KAXIS,INOD) = XYZV(IAXIS:KAXIS)

RETURN
END SUBROUTINE INSERT_FACE_VERT_LOC

! ----------------------- GET_CARTFACE_CUTFACES ---------------------------------

SUBROUTINE GET_CARTFACE_CUTFACES(NM,ISTR,IEND,JSTR,JEND,KSTR,KEND,BNDINT_FLAG)

USE COMP_FUNCTIONS, ONLY: CURRENT_TIME

INTEGER, INTENT(IN) :: NM
INTEGER, INTENT(IN) :: ISTR, IEND, JSTR, JEND, KSTR, KEND
LOGICAL, INTENT(IN) :: BNDINT_FLAG

! Local Variables:
INTEGER :: X1AXIS, X2AXIS, X3AXIS
INTEGER :: XIAXIS, XJAXIS, XKAXIS
INTEGER :: X1LO, X1HI, X2LO, X2HI, X3LO, X3HI
INTEGER :: ILO,IHI,JLO,JHI,KLO,KHI
INTEGER :: II,II2,JJ,KK, CEI
INTEGER ::  INDXI(MAX_DIM),  INDI,  INDJ,  INDK
INTEGER :: INDXI1(MAX_DIM), INDI1, INDJ1, INDK1
INTEGER :: INDXI2(MAX_DIM), INDI2, INDJ2, INDK2
INTEGER :: INDXI3(MAX_DIM), INDI3, INDJ3, INDK3
INTEGER :: INDXI4(MAX_DIM), INDI4, INDJ4, INDK4
INTEGER ::  INDLC(MAX_DIM),  IEDG,  JEDG,  KEDG
INTEGER :: NSEG, ISEG, ISEG2, NVERT, NFACE, NEDGE, IEDGE, NVERT_CART, NSEG_CART
LOGICAL :: OUTFACE1, OUTFACE2, NOTDONE
INTEGER, DIMENSION(NOD1:NOD2,1:IBM_MAXCEELEM_FACE) :: SEG_FACE, SEG_FACE_CART, SEG_FACEAUX
INTEGER, DIMENSION(NOD1:NOD3,1:IBM_MAXCEELEM_FACE) :: SEG_FACE2
REAL(EB), DIMENSION(IBM_MAXCEELEM_FACE) :: ANGSEG, ANGSEGAUX
REAL(EB), DIMENSION(IAXIS:KAXIS,1:IBM_MAXVERTS_FACE)           ::     XYZVERT, XYZVERT_CART  ! Locations of vertices.
INTEGER,  DIMENSION(IBM_MAXVERT_CUTFACE,IBM_MAXCFELEM_FACE)    ::      CFELEM  ! Cut-faces connectivities.
INTEGER, PARAMETER :: MAX_EDG_PER_NODE = IBM_MAXCEELEM_FACE      ! Set to max number of segments allowed per cart face.
INTEGER, DIMENSION(1:MAX_EDG_PER_NODE,1:IBM_MAXVERTS_FACE)     :: NODEDG_FACE
LOGICAL :: SEG_FLAG(IBM_MAXCEELEM_FACE)
INTEGER :: NUMEDG_NODE(IBM_MAXVERTS_FACE)
INTEGER :: INOD, INOD1, INOD2, SEG(NOD1:NOD2)
REAL(EB):: X1, X2, X3, DX2, DX3, XYZV(MAX_DIM), XYZLC(MAX_DIM)
INTEGER :: NUMNOD1, NUMNOD2, NEDI, ICF, ISS, NEWSEG, COUNT, N2COUNT, CTSTART, NSEG_LEFT
REAL(EB):: ANGCOUNT, DANG, DANGI
LOGICAL :: FOUNDSEG, PTSFLAG
INTEGER :: ICF1, ICF2, ICF_PT, IPT, NP, NP1, NP2, NFACE2, NCUTFACE, NVERTFACE
REAL(EB), DIMENSION(IAXIS:JAXIS,1:IBM_MAXVERTS_FACE)           ::     XY
REAL(EB):: AREA, AREA1, AREA2, AREAH, CX2, CX3, DIST12, D12
REAL(EB), DIMENSION(IAXIS:JAXIS) :: XYC1, XYC2, XYH
REAL(EB), DIMENSION(IBM_MAXCFELEM_FACE)                        ::   AREAV  ! Cut-faces areas.
REAL(EB), DIMENSION(IAXIS:KAXIS,1:IBM_MAXCFELEM_FACE)          ::  XYZCEN  ! Cut-faces centroid locations.
REAL(EB), DIMENSION(IAXIS:KAXIS,1:IBM_MAXCFELEM_FACE)          ::  INXAREA, INXSQAREA
INTEGER,  DIMENSION(IBM_MAXCFELEM_FACE) :: FINFACE
INTEGER,  DIMENSION(IBM_MAXVERT_CUTFACE):: CFE,CFEL
INTEGER :: IBNDINT,BNDINT_LOW,BNDINT_HIGH,ILOC

LOGICAL, ALLOCATABLE, SAVE, DIMENSION(:,:,:,:) :: IJK_COUNTED

INTEGER :: NSSEG, NSVERT, NSFACE, NSFACE2
LOGICAL :: ASCDESC
INTEGER :: NV,IV,V(1:IBM_MAXVERTS_FACE)
REAL(EB):: XVERT1(1:IBM_MAXVERTS_FACE),XVERT2(1:IBM_MAXVERTS_FACE)

INTEGER, PARAMETER :: NODC1(1:4) = (/ 1, 2, 1, 2 /)
INTEGER, PARAMETER :: NODC2(1:4) = (/ 1, 2, 2, 1 /)
INTEGER :: SNOD1(NOD1:NOD2), SNOD2(NOD1:NOD2)
REAL(EB) :: XYZ_SEG1(IAXIS:KAXIS,NOD1:NOD2), XYZ_SEG2(IAXIS:KAXIS,NOD1:NOD2)
LOGICAL :: DIFF(1:4)
LOGICAL :: GET_SOLID_CUTFACES = .TRUE.
REAL(EB) :: TNOW

TNOW=CURRENT_TIME()

! Build a set of regular cut-cells in the middle of the domain to do testing.
IF (PERIODIC_TEST == 103 .OR. PERIODIC_TEST == 11 .OR. PERIODIC_TEST == 7) THEN
   CALL DEFINE_REGULAR_CUTFACES(NM,ISTR,IEND,JSTR,JEND,KSTR,KEND,BNDINT_FLAG)
   T_CC_USED(GET_CARTFACE_CUTFACES_TIME_INDEX) = T_CC_USED(GET_CARTFACE_CUTFACES_TIME_INDEX) + CURRENT_TIME() - TNOW
   RETURN
ENDIF

! Test to check cut-cell definition scaling:
IF (PERIODIC_TEST == 105) GET_SOLID_CUTFACES = .FALSE.

! Main Loop on block NM:
IF (BNDINT_FLAG) THEN
   ALLOCATE( IJK_COUNTED(ISTR:IEND,JSTR:JEND,KSTR:KEND,IAXIS:KAXIS) ); IJK_COUNTED=.FALSE.
   BNDINT_LOW  = 1
   BNDINT_HIGH = 3
ELSE
   IF (CCGUARD==0) THEN
      DEALLOCATE( IJK_COUNTED )
      RETURN
   ENDIF
   BNDINT_LOW  = 4
   BNDINT_HIGH = 4
ENDIF

IBNDINT_LOOP : DO IBNDINT=BNDINT_LOW,BNDINT_HIGH ! 1,2 refers to block boundary faces, 3 to internal faces,
                                                 ! 4 guard-cell faces.

   ! When switching to internal faces, copy number of external faces already computed.
   IF (IBNDINT == 3) MESHES(NM)%N_BBCUTFACE_MESH = MESHES(NM)%N_CUTFACE_MESH

   XIAXIS_LOOP : DO X1AXIS=IAXIS,KAXIS

      SELECT CASE(X1AXIS)
      case(IAXIS)

         X2AXIS = JAXIS
         X3AXIS = KAXIS

         ! IAXIS gasphase cut-faces:
         JLO = JLO_CELL; JHI = JHI_CELL
         KLO = KLO_CELL; KHI = KHI_CELL
         SELECT CASE(IBNDINT)
         CASE(1)
            ILO = ILO_FACE; IHI = ILO_FACE
         CASE(2)
            ILO = IHI_FACE; IHI = IHI_FACE
         CASE(3)
            ILO = ILO_FACE+1; IHI = IHI_FACE-1
         CASE(4)
            ILO = ILO_FACE-CCGUARD; IHI= IHI_FACE+CCGUARD
            JLO = JLO-CCGUARD; JHI = JHI+CCGUARD
            KLO = KLO-CCGUARD; KHI = KHI+CCGUARD
         END SELECT

         ! location in I,J,K od x2,x2,x3 axes:
         XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS

         ! Local indexing in x1, x2, x3:
         X1LO = ILO; X1HI = IHI
         X2LO = JLO; X2HI = JHI
         X3LO = KLO; X3HI = KHI

         ! Face coordinates in x1,x2,x3 axes:
         ALLOCATE(X1FACE(ISTR:IEND)); X1FACE = XFACE
         ALLOCATE(X2FACE(JSTR:JEND)); X2FACE = YFACE
         ALLOCATE(X3FACE(KSTR:KEND)); X3FACE = ZFACE

      CASE(JAXIS)

         X2AXIS = KAXIS
         X3AXIS = IAXIS

         ! JAXIS gasphase cut-faces:
         ILO = ILO_CELL; IHI = IHI_CELL
         KLO = KLO_CELL; KHI = KHI_CELL
         SELECT CASE(IBNDINT)
         CASE(1)
            JLO = JLO_FACE; JHI = JLO_FACE
         CASE(2)
            JLO = JHI_FACE; JHI = JHI_FACE
         CASE(3)
            JLO = JLO_FACE+1; JHI = JHI_FACE-1
         CASE(4)
            JLO = JLO_FACE-CCGUARD; JHI = JHI_FACE+CCGUARD
            ILO = ILO-CCGUARD; IHI = IHI+CCGUARD
            KLO = KLO-CCGUARD; KHI = KHI+CCGUARD
         END SELECT

         ! location in I,J,K od x2,x2,x3 axes:
         XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS

         ! Local indexing in x1, x2, x3:
         X1LO = JLO; X1HI = JHI
         X2LO = KLO; X2HI = KHI
         X3LO = ILO; X3HI = IHI

         ! Face coordinates in x1,x2,x3 axes:
         ALLOCATE(X1FACE(JSTR:JEND)); X1FACE = YFACE
         ALLOCATE(X2FACE(KSTR:KEND)); X2FACE = ZFACE
         ALLOCATE(X3FACE(ISTR:IEND)); X3FACE = XFACE

      CASE(KAXIS)

         X2AXIS = IAXIS
         X3AXIS = JAXIS

         ! KAXIS gasphase cut-faces:
         ILO = ILO_CELL; IHI = IHI_CELL
         JLO = JLO_CELL; JHI = JHI_CELL
         SELECT CASE(IBNDINT)
         CASE(1)
            KLO = KLO_FACE; KHI = KLO_FACE
         CASE(2)
            KLO = KHI_FACE; KHI = KHI_FACE
         CASE(3)
            KLO = KLO_FACE+1; KHI = KHI_FACE-1
         CASE(4)
            KLO = KLO_FACE-CCGUARD; KHI = KHI_FACE+CCGUARD
            ILO = ILO-CCGUARD; IHI = IHI+CCGUARD
            JLO = JLO-CCGUARD; JHI = JHI+CCGUARD
         END SELECT

         ! location in I,J,K od x2,x2,x3 axes:
         XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS

         ! Local indexing in x1, x2, x3:
         X1LO = KLO; X1HI = KHI
         X2LO = ILO; X2HI = IHI
         X3LO = JLO; X3HI = JHI

         ! Face coordinates in x1,x2,x3 axes:
         ALLOCATE(X1FACE(KSTR:KEND)); X1FACE = ZFACE
         ALLOCATE(X2FACE(ISTR:IEND)); X2FACE = XFACE
         ALLOCATE(X3FACE(JSTR:JEND)); X3FACE = YFACE

      END SELECT

      ! Loop on Cartesian faces, local x1, x2, x3 indexes:
      DO II=X1LO,X1HI
         DO KK=X3LO,X3HI
            DO JJ=X2LO,X2HI

             ! Face indexes:
             INDXI(IAXIS:KAXIS) = (/ II, JJ, KK /) ! Local x1,x2,x3
             INDI = INDXI(XIAXIS)
             INDJ = INDXI(XJAXIS)
             INDK = INDXI(XKAXIS)

             ! Drop if cut-face has already been counted:
             IF( IJK_COUNTED(INDI,INDJ,INDK,X1AXIS) ) CYCLE; IJK_COUNTED(INDI,INDJ,INDK,X1AXIS)=.TRUE.
             IF(MESHES(NM)%FCVAR(INDI,INDJ,INDK,IBM_FGSC,X1AXIS) == IBM_SOLID) CYCLE

             ! Drop if face not cut-face:
             ! Test for FACE Cartesian edges being cut:
             ! If outface1 is true -> All regular edges for this face:
             ! Edge at index KK-FCELL:
             INDXI1(IAXIS:KAXIS) = (/ II, JJ, KK-FCELL /) ! Local x1,x2,x3
             INDI1 = INDXI1(XIAXIS)
             INDJ1 = INDXI1(XJAXIS)
             INDK1 = INDXI1(XKAXIS)
             ! Edge at index KK-FCELL+1:
             INDXI2(IAXIS:KAXIS) = (/ II, JJ, KK-FCELL+1 /) ! Local x1,x2,x3
             INDI2 = INDXI2(XIAXIS)
             INDJ2 = INDXI2(XJAXIS)
             INDK2 = INDXI2(XKAXIS)
             ! Edge at index JJ-FCELL:
             INDXI3(IAXIS:KAXIS) = (/ II, JJ-FCELL, KK /) ! Local x1,x2,x3
             INDI3 = INDXI3(XIAXIS)
             INDJ3 = INDXI3(XJAXIS)
             INDK3 = INDXI3(XKAXIS)
             ! Edge at index jj-FCELL+1:
             INDXI4(IAXIS:KAXIS) = (/ II, JJ-FCELL+1, KK /) ! Local x1,x2,x3
             INDI4 = INDXI4(XIAXIS)
             INDJ4 = INDXI4(XJAXIS)
             INDK4 = INDXI4(XKAXIS)

             OUTFACE1 = (MESHES(NM)%ECVAR(INDI1,INDJ1,INDK1,IBM_EGSC,X2AXIS) /= IBM_CUTCFE) .AND. &
                        (MESHES(NM)%ECVAR(INDI2,INDJ2,INDK2,IBM_EGSC,X2AXIS) /= IBM_CUTCFE) .AND. &
                        (MESHES(NM)%ECVAR(INDI3,INDJ3,INDK3,IBM_EGSC,X3AXIS) /= IBM_CUTCFE) .AND. &
                        (MESHES(NM)%ECVAR(INDI4,INDJ4,INDK4,IBM_EGSC,X3AXIS) /= IBM_CUTCFE)

             ! Test for face with INB edges:
             ! If outface2 is true -> no INB Edges associated with this face:
             OUTFACE2 = (MESHES(NM)%FCVAR(INDI,INDJ,INDK,IBM_IDCE,X1AXIS) <= 0)

             ! Drop if outface1 & outface2
             IF (OUTFACE1 .AND. OUTFACE2) THEN
                ! Test if IBM_FSID is SOLID:
                IF ((MESHES(NM)%ECVAR(INDI1,INDJ1,INDK1,IBM_EGSC,X2AXIS) == IBM_SOLID) .AND. &
                   (MESHES(NM)%ECVAR(INDI2,INDJ2,INDK2,IBM_EGSC,X2AXIS) == IBM_SOLID) .AND. &
                   (MESHES(NM)%ECVAR(INDI3,INDJ3,INDK3,IBM_EGSC,X3AXIS) == IBM_SOLID) .AND. &
                   (MESHES(NM)%ECVAR(INDI4,INDJ4,INDK4,IBM_EGSC,X3AXIS) == IBM_SOLID) ) THEN
                   MESHES(NM)%FCVAR(INDI,INDJ,INDK,IBM_FGSC,X1AXIS) = IBM_SOLID
                ENDIF
                CYCLE
             ENDIF

             MESHES(NM)%FCVAR(INDI,INDJ,INDK,IBM_FGSC,X1AXIS)   = IBM_CUTCFE

             ! Build segment list:
             NSEG      = 0
             NVERT     = 0
             NFACE     = 0

             SEG_FACE (NOD1:NOD2,1:IBM_MAXCEELEM_FACE)             = IBM_UNDEFINED
             XYZVERT(IAXIS:KAXIS,1:IBM_MAXVERTS_FACE)              = 0._EB
             CFELEM(1:IBM_MAXVERT_CUTFACE,1:IBM_MAXCFELEM_FACE)    = IBM_UNDEFINED
             ANGSEG(1:IBM_MAXCEELEM_FACE)                          = 0._EB

             ! 1. Cartesian IBM_GASPHASE edges, cut-edges:
             ! a. Make a list of segments:
             ! Low x2 cut-edges:
             INDLC(IAXIS:KAXIS) = INDXI3(IAXIS:KAXIS)
             IEDG=INDI3; JEDG=INDJ3; KEDG=INDK3
             CEI = MESHES(NM)%ECVAR(IEDG,JEDG,KEDG,IBM_IDCE,X3AXIS)
             IF ( CEI == 0 ) THEN ! Regular Edge, build segment from grid:
                IF (MESHES(NM)%ECVAR(IEDG,JEDG,KEDG,IBM_EGSC,X3AXIS) /= IBM_SOLID) THEN
                   ! x,y,z of node 1:
                   XYZLC(IAXIS:KAXIS) = (/ X1FACE(INDLC(IAXIS)), &
                                           X2FACE(INDLC(JAXIS)), &
                                           X3FACE(INDLC(KAXIS)-FCELL+1) /)
                   X1 = XYZLC(XIAXIS)
                   X2 = XYZLC(XJAXIS)
                   X3 = XYZLC(XKAXIS)
                   XYZV(IAXIS:KAXIS) = (/ X1, X2, X3 /)
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NVERT,INOD1,XYZVERT)

                   ! x,y,z of node 2:
                   XYZLC(IAXIS:KAXIS) = (/ X1FACE(INDLC(IAXIS)), &
                                           X2FACE(INDLC(JAXIS)), &
                                           X3FACE(INDLC(KAXIS)-FCELL) /)
                   X1 = XYZLC(XIAXIS)
                   X2 = XYZLC(XJAXIS)
                   X3 = XYZLC(XKAXIS)
                   XYZV(IAXIS:KAXIS) = (/ X1, X2, X3 /)
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NVERT,INOD2,XYZVERT)

                   ! ADD segment:
                   NSEG = NSEG + 1
                   SEG_FACE(NOD1:NOD2,NSEG) = (/ INOD1, INOD2 /)
                   ANGSEG(NSEG) = - PI / 2._EB
                ENDIF
             ELSE ! Cut-edge, load CUT_EDGE(CEI) segments
                NEDGE = MESHES(NM)%CUT_EDGE(CEI)%NEDGE
                DO IEDGE=1,NEDGE
                   SEG(NOD1:NOD2) = MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,IEDGE)

                   ! x,y,z of node 1:
                   XYZV(IAXIS:KAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,SEG(NOD2))
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NVERT,INOD1,XYZVERT)

                   ! x,y,z of node 2:
                   XYZV(IAXIS:KAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,SEG(NOD1))
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NVERT,INOD2,XYZVERT)

                   ! ADD segment:
                   NSEG = NSEG + 1
                   SEG_FACE(NOD1:NOD2,NSEG) = (/ INOD1, INOD2 /)
                   ANGSEG(NSEG) = - PI / 2._EB
                ENDDO
             ENDIF

             ! High x2 cut-edges:
             INDLC(IAXIS:KAXIS) = INDXI4(IAXIS:KAXIS)
             IEDG=INDI4; JEDG=INDJ4; KEDG=INDK4
             CEI = MESHES(NM)%ECVAR(IEDG,JEDG,KEDG,IBM_IDCE,X3AXIS)
             IF ( CEI == 0 ) THEN ! Regular Edge, build segment from grid:
                IF (MESHES(NM)%ECVAR(IEDG,JEDG,KEDG,IBM_EGSC,X3AXIS) /= IBM_SOLID) THEN
                   ! x,y,z of node 1:
                   XYZLC(IAXIS:KAXIS) = (/ X1FACE(INDLC(IAXIS)), &
                                           X2FACE(INDLC(JAXIS)), &
                                           X3FACE(INDLC(KAXIS)-FCELL) /)
                   X1 = XYZLC(XIAXIS)
                   X2 = XYZLC(XJAXIS)
                   X3 = XYZLC(XKAXIS)
                   XYZV(IAXIS:KAXIS) = (/ X1, X2, X3 /)
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NVERT,INOD1,XYZVERT)

                   ! x,y,z of node 2:
                   XYZLC(IAXIS:KAXIS) = (/ X1FACE(INDLC(IAXIS)), &
                                           X2FACE(INDLC(JAXIS)), &
                                           X3FACE(INDLC(KAXIS)-FCELL+1) /)
                   X1 = XYZLC(XIAXIS)
                   X2 = XYZLC(XJAXIS)
                   X3 = XYZLC(XKAXIS)
                   XYZV(IAXIS:KAXIS) = (/ X1, X2, X3 /)
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NVERT,INOD2,XYZVERT)

                   ! ADD segment:
                   NSEG = NSEG + 1
                   SEG_FACE(NOD1:NOD2,NSEG) = (/ INOD1, INOD2 /)
                   ANGSEG(NSEG) =   PI / 2._EB
                ENDIF
             ELSE ! Cut-edge, load CUT_EDGE(CEI) segments
                NEDGE = MESHES(NM)%CUT_EDGE(CEI)%NEDGE
                DO IEDGE=1,NEDGE
                   SEG(NOD1:NOD2) = MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,IEDGE)

                   ! x,y,z of node 1:
                   XYZV(IAXIS:KAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,SEG(NOD1))
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NVERT,INOD1,XYZVERT)

                   ! x,y,z of node 2:
                   XYZV(IAXIS:KAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,SEG(NOD2))
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NVERT,INOD2,XYZVERT)

                   ! ADD segment:
                   NSEG = NSEG + 1
                   SEG_FACE(NOD1:NOD2,NSEG) = (/ INOD1, INOD2 /)
                   ANGSEG(NSEG) =   PI / 2._EB
                ENDDO
             ENDIF

             ! Low  x3 cut-edges:
             INDLC(IAXIS:KAXIS) = INDXI1(IAXIS:KAXIS)
             IEDG=INDI1; JEDG=INDJ1; KEDG=INDK1
             CEI = MESHES(NM)%ECVAR(IEDG,JEDG,KEDG,IBM_IDCE,X2AXIS)
             IF ( CEI == 0 ) THEN ! Regular Edge, build segment from grid:
                IF (MESHES(NM)%ECVAR(IEDG,JEDG,KEDG,IBM_EGSC,X2AXIS) /= IBM_SOLID) THEN
                   ! x,y,z of node 1:
                   XYZLC(IAXIS:KAXIS) = (/ X1FACE(INDLC(IAXIS)), &
                                           X2FACE(INDLC(JAXIS)-FCELL), &
                                           X3FACE(INDLC(KAXIS)) /)
                   X1 = XYZLC(XIAXIS)
                   X2 = XYZLC(XJAXIS)
                   X3 = XYZLC(XKAXIS)
                   XYZV(IAXIS:KAXIS) = (/ X1, X2, X3 /)
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NVERT,INOD1,XYZVERT)

                   ! x,y,z of node 2:
                   XYZLC(IAXIS:KAXIS) = (/ X1FACE(INDLC(IAXIS)), &
                                           X2FACE(INDLC(JAXIS)-FCELL+1), &
                                           X3FACE(INDLC(KAXIS)) /)
                   X1 = XYZLC(XIAXIS)
                   X2 = XYZLC(XJAXIS)
                   X3 = XYZLC(XKAXIS)
                   XYZV(IAXIS:KAXIS) = (/ X1, X2, X3 /)
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NVERT,INOD2,XYZVERT)

                   ! ADD segment:
                   NSEG = NSEG + 1
                   SEG_FACE(NOD1:NOD2,NSEG) = (/ INOD1, INOD2 /)
                   ANGSEG(NSEG) = 0._EB
                ENDIF
             ELSE ! Cut-edge, load CUT_EDGE(CEI) segments
                NEDGE = MESHES(NM)%CUT_EDGE(CEI)%NEDGE
                DO IEDGE=1,NEDGE
                   SEG(NOD1:NOD2) = MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,IEDGE)

                   ! x,y,z of node 1:
                   XYZV(IAXIS:KAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,SEG(NOD1))
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NVERT,INOD1,XYZVERT)

                   ! x,y,z of node 2:
                   XYZV(IAXIS:KAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,SEG(NOD2))
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NVERT,INOD2,XYZVERT)

                   ! ADD segment:
                   NSEG = NSEG + 1
                   SEG_FACE(NOD1:NOD2,NSEG) = (/ INOD1, INOD2 /)
                   ANGSEG(NSEG) = 0._EB
                ENDDO
             ENDIF

             ! High x3 cut-edges:
             INDLC(IAXIS:KAXIS) = INDXI2(IAXIS:KAXIS)
             IEDG=INDI2; JEDG=INDJ2; KEDG=INDK2
             CEI = MESHES(NM)%ECVAR(IEDG,JEDG,KEDG,IBM_IDCE,X2AXIS)
             IF ( CEI == 0 ) THEN ! Regular Edge, build segment from grid:
                IF (MESHES(NM)%ECVAR(IEDG,JEDG,KEDG,IBM_EGSC,X2AXIS) /= IBM_SOLID) THEN
                   ! x,y,z of node 1:
                   XYZLC(IAXIS:KAXIS) = (/ X1FACE(INDLC(IAXIS)), &
                                           X2FACE(INDLC(JAXIS)-FCELL+1), &
                                           X3FACE(INDLC(KAXIS)) /)
                   X1 = XYZLC(XIAXIS)
                   X2 = XYZLC(XJAXIS)
                   X3 = XYZLC(XKAXIS)
                   XYZV(IAXIS:KAXIS) = (/ X1, X2, X3 /)
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NVERT,INOD1,XYZVERT)

                   ! x,y,z of node 2:
                   XYZLC(IAXIS:KAXIS) = (/ X1FACE(INDLC(IAXIS)), &
                                           X2FACE(INDLC(JAXIS)-FCELL), &
                                           X3FACE(INDLC(KAXIS)) /)
                   X1 = XYZLC(XIAXIS)
                   X2 = XYZLC(XJAXIS)
                   X3 = XYZLC(XKAXIS)
                   XYZV(IAXIS:KAXIS) = (/ X1, X2, X3 /)
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NVERT,INOD2,XYZVERT)

                   ! ADD segment:
                   NSEG = NSEG + 1
                   SEG_FACE(NOD1:NOD2,NSEG) = (/ INOD1, INOD2 /)
                   ANGSEG(NSEG) = PI
                ENDIF
             ELSE ! Cut-edge, load CUT_EDGE(CEI) segments
                NEDGE = MESHES(NM)%CUT_EDGE(CEI)%NEDGE
                DO IEDGE=1,NEDGE
                   SEG(NOD1:NOD2) = MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,IEDGE)

                   ! x,y,z of node 1:
                   XYZV(IAXIS:KAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,SEG(NOD2))
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NVERT,INOD1,XYZVERT)

                   ! x,y,z of node 2:
                   XYZV(IAXIS:KAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,SEG(NOD1))
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NVERT,INOD2,XYZVERT)

                   ! ADD segment:
                   NSEG = NSEG + 1
                   SEG_FACE(NOD1:NOD2,NSEG) = (/ INOD1, INOD2 /)
                   ANGSEG(NSEG) = PI
                ENDDO
             ENDIF

             ! Store Segment and Vertex list from Cartesian face boundary:
             XYZVERT_CART(IAXIS:KAXIS,1:NVERT)= XYZVERT(IAXIS:KAXIS,1:NVERT)
             SEG_FACE_CART(NOD1:NOD2,1:NSEG)  = SEG_FACE(NOD1:NOD2,1:NSEG)
             NVERT_CART=NVERT; NSEG_CART = NSEG

             ! 2. IBM_INBOUNDARY cut-edges assigned to this face:
             CEI = MESHES(NM)%FCVAR(INDI,INDJ,INDK,IBM_IDCE,X1AXIS)
             IF ( CEI > 0 ) THEN ! There are inboundary cut-edges
                NEDGE = MESHES(NM)%CUT_EDGE(CEI)%NEDGE
                DO IEDGE=1,NEDGE
                   SEG(NOD1:NOD2) = MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,IEDGE)

                   ! x,y,z of node 1:
                   XYZV(IAXIS:KAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,SEG(NOD2))
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NVERT,INOD1,XYZVERT)

                   ! x,y,z of node 2:
                   XYZV(IAXIS:KAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,SEG(NOD1))
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NVERT,INOD2,XYZVERT)

                   ! ADD segment:
                   NSEG = NSEG + 1
                   SEG_FACE(NOD1:NOD2,NSEG) = (/ INOD1, INOD2 /)
                   DX3 = XYZVERT(X3AXIS,INOD2)-XYZVERT(X3AXIS,INOD1)
                   DX2 = XYZVERT(X2AXIS,INOD2)-XYZVERT(X2AXIS,INOD1)
                   ANGSEG(NSEG) = ATAN2(DX3,DX2)

                ENDDO
             ENDIF

             NOTDONE = .TRUE.
             DO WHILE(NOTDONE)
                NOTDONE = .FALSE.
                ! Counts edges that reach nodes:
                NUMEDG_NODE(1:IBM_MAXVERTS_FACE) = 0
                DO ISEG=1,NSEG
                   DO II2=NOD1,NOD2
                      INOD = SEG_FACE(II2,ISEG)
                      NUMEDG_NODE(INOD) = NUMEDG_NODE(INOD) + 1
                   ENDDO
                ENDDO

                ! Drop segments with NUMEDG_NODE(INOD)=1:
                ! The assumption here is that they are IBM_GG IBM_INBOUNDCF
                ! segments with one node inside the Cartface i.e. case Fig
                ! 9(a) in the CompGeom3D notes):
                COUNT = 0
                SEG_FACEAUX (NOD1:NOD2,1:IBM_MAXCEELEM_FACE)             = IBM_UNDEFINED
                ANGSEGAUX(1:IBM_MAXCEELEM_FACE)                          = 0._EB
                DO ISEG=1,NSEG
                   NUMNOD1 = NUMEDG_NODE(SEG_FACE(NOD1,ISEG))
                   NUMNOD2 = NUMEDG_NODE(SEG_FACE(NOD2,ISEG))
                   IF ((NUMNOD1 > 1) .AND. (NUMNOD2 > 1)) THEN
                      COUNT = COUNT + 1
                      SEG_FACEAUX(NOD1:NOD2,COUNT) = SEG_FACE(NOD1:NOD2,ISEG)
                      ANGSEGAUX(COUNT) = ANGSEG(ISEG)
                   ELSE
                      NOTDONE = .TRUE.
                   ENDIF
                ENDDO
                NSEG = COUNT
                SEG_FACE = SEG_FACEAUX
                ANGSEG   = ANGSEGAUX
             ENDDO

             ! Discard face with no conected edges:
             IF ( NSEG == 0 ) THEN
                MESHES(NM)%FCVAR(INDI,INDJ,INDK,IBM_FGSC,X1AXIS) = IBM_SOLID
                CYCLE
             ENDIF

             ! Add segments which have both ends attached to more than two segs:
             count = 0
             DO ISEG=1,NSEG
                NUMNOD1 = NUMEDG_NODE(SEG_FACE(NOD1,ISEG))
                NUMNOD2 = NUMEDG_NODE(SEG_FACE(NOD2,ISEG))
                IF ((NUMNOD1 > 2) .AND. (NUMNOD2 > 2)) THEN
                   COUNT = COUNT + 1
                   SEG_FACE(NOD1:NOD2,NSEG+COUNT) = SEG_FACE( (/ NOD2, NOD1 /) ,ISEG)
                   IF (ANGSEG(ISEG) >= 0._EB) THEN
                      ANGSEG(NSEG+COUNT) = ANGSEG(ISEG) - PI
                   ELSE
                      ANGSEG(NSEG+COUNT) = ANGSEG(ISEG) + PI
                   ENDIF
                ENDIF
             ENDDO
             NSEG = NSEG + COUNT

             ! Fill NODEDG_FACE(IEDGE,INOD), where iedge are edges
             ! that contain inod as first node. This assumes edges are
             ! ordered using the right hand rule on x2-x3 plane.
             ! Also compute the edges angles in x2-x3 plane
             NODEDG_FACE(1:MAX_EDG_PER_NODE,1:IBM_MAXVERTS_FACE) = 0
             DO ISEG=1,NSEG
               INOD1 = SEG_FACE(NOD1,ISEG)
               NEDI  = NODEDG_FACE(1,INOD1) + 1 ! Increase number of edges connected to node by 1.
               NODEDG_FACE(     1,INOD1) = NEDI
               NODEDG_FACE(NEDI+1,INOD1) = ISEG
             ENDDO

             ! Now Reorder Segments, do tests:
             SEG_FACE2(NOD1:NOD3,1:IBM_MAXCEELEM_FACE) = IBM_UNDEFINED  ! [INOD1 INOD2 ICF]
             SEG_FLAG(1:IBM_MAXCEELEM_FACE) = .TRUE.

             ICF  = 1
             ISEG = 1
             NEWSEG = ISEG
             COUNT= 1
             CTSTART=COUNT
             SEG_FACE2(NOD1:NOD3,COUNT) = (/ SEG_FACE(NOD1,NEWSEG), SEG_FACE(NOD2,NEWSEG), ICF /)
             SEG_FLAG(ISEG) = .FALSE.
             NSEG_LEFT      = NSEG - 1

             ! Infamous infinite loop:
             INF_LOOP : DO

                FOUNDSEG = .FALSE.
                N2COUNT  = SEG_FACE2(NOD2,COUNT) ! Node 2 of segment COUNT.
                ANGCOUNT = ANGSEG(NEWSEG)

                ! Find Segment starting on Node 2 with smaller ANGSEG respect to COUNT.
                DANG = -1._EB / GEOMEPS
                DO ISS=2,NODEDG_FACE(1,N2COUNT)+1
                   ISEG = NODEDG_FACE(ISS,N2COUNT)
                   IF ( SEG_FLAG(ISEG) ) THEN ! This seg hasn't been added to SEG_FACE2
                                             ! Drop if seg is the opposite of count seg:
                      IF ( SEG_FACE2(NOD1,COUNT) == SEG_FACE(NOD2,ISEG) ) CYCLE
                      DANGI = ANGSEG(ISEG) - ANGCOUNT
                      IF ( DANGI < 0._EB ) DANGI = DANGI + 2._EB * PI

                      IF ( DANGI > DANG ) THEN
                         NEWSEG   =  ISEG
                         DANG     = DANGI
                         FOUNDSEG = .TRUE.
                      ENDIF
                   ENDIF
                ENDDO

                ! Found a seg add to SEG_FACE2:
                IF ( FOUNDSEG ) THEN
                   COUNT          = COUNT + 1
                   SEG_FACE2(NOD1:NOD3,COUNT) = (/ SEG_FACE(NOD1,NEWSEG), SEG_FACE(NOD2,NEWSEG), ICF /)
                   SEG_FLAG(NEWSEG) = .FALSE.
                   NSEG_LEFT      = NSEG_LEFT - 1
                ENDIF

                ! Test if line has closed on point shared any other cutface:
                IF ( SEG_FACE2(NOD2,COUNT) == SEG_FACE2(NOD1,CTSTART) ) THEN
                   ! Go for new cut-face on this Cartesian face.
                ELSEIF ( FOUNDSEG ) THEN
                   CYCLE
                ENDIF

                ! Break loop:
                IF ( NSEG_LEFT == 0 ) EXIT

                ! Start a new cut-face on this Cartesian face:
                ICF = ICF + 1
                DO ISEG=1,NSEG
                   IF ( SEG_FLAG(ISEG) ) THEN
                      COUNT  = COUNT + 1
                      CTSTART= COUNT
                      SEG_FACE2(NOD1:NOD3,COUNT) = (/ SEG_FACE(NOD1,ISEG), SEG_FACE(NOD2,ISEG), ICF /)
                      SEG_FLAG(ISEG) = .FALSE.
                      NSEG_LEFT      = NSEG_LEFT - 1
                      EXIT
                   ENDIF
                ENDDO

             ENDDO INF_LOOP

             ! Load ordered nodes to CFELEM:
             NFACE = ICF
             DO ICF=1,NFACE
                NP = 0
                DO ISEG=1,NSEG
                   IF ( SEG_FACE2(NOD3,ISEG) == ICF ) THEN
                      NP = NP + 1
                      CFELEM(1,ICF)    = NP
                      CFELEM(NP+1,ICF) = SEG_FACE2(NOD1,ISEG)
                   ENDIF
                ENDDO
             ENDDO

             ! Compute area and Centroid, in local x1, x2, x3 coords:
             AREAV(1:NFACE)                 = 0._EB
             XYZCEN(IAXIS:KAXIS,1:NFACE)    = 0._EB
             INXAREA(IAXIS:KAXIS,1:NFACE)   = 0._EB
             INXSQAREA(IAXIS:KAXIS,1:NFACE) = 0._EB
             DO ICF=1,NFACE
                NP    = CFELEM(1,ICF)
                DO IPT=2,NP+1
                   ICF_PT = CFELEM(IPT,ICF)
                   ! Define closed Polygon:
                   XY(IAXIS:JAXIS,IPT-1) = (/ XYZVERT(X2AXIS,ICF_PT), XYZVERT(X3AXIS,ICF_PT) /)
                ENDDO
                ICF_PT = CFELEM(2,ICF)
                XY(IAXIS:JAXIS,NP+1) = (/ XYZVERT(X2AXIS,ICF_PT), XYZVERT(X3AXIS,ICF_PT) /) ! Close Polygon.

                ! Get Area and Centroid properties of Cut-face:
                AREA = 0._EB
                DO II2=1,NP
                   AREA = AREA + ( XY(IAXIS,II2) * XY(JAXIS,II2+1) - &
                                   XY(JAXIS,II2) * XY(IAXIS,II2+1) )
                ENDDO
                AREA = AREA / 2._EB
                ! Now Centroids:
                ! In x2:
                CX2 = 0._EB
                DO II2=1,NP
                   CX2 = CX2 + ( XY(IAXIS,II2)+XY(IAXIS,II2+1)) * &
                               ( XY(IAXIS,II2)*XY(JAXIS,II2+1)  - &
                                 XY(JAXIS,II2)*XY(IAXIS,II2+1) )
                ENDDO
                CX2 = CX2 / (6._EB * AREA)
                ! In x3:
                CX3 = 0._EB
                DO II2=1,NP
                   CX3 = CX3 + ( XY(JAXIS,II2)+XY(JAXIS,II2+1)) * &
                               ( XY(IAXIS,II2)*XY(JAXIS,II2+1)  - &
                                 XY(JAXIS,II2)*XY(IAXIS,II2+1) )
                ENDDO
                CX3 = CX3 / (6._EB * AREA)

                ! Add to cut-face:
                AREAV(ICF) = AREA
                XYZCEN(IAXIS:KAXIS,ICF) = (/  X1FACE(II), CX2, CX3 /)

                ! Fields for cut-cell volume/centroid computation:
                ! dot(e1,nc)*int(x1)dA, where x=x1face(ii) constant and nc=e1:
                INXAREA(IAXIS,ICF) = 1._EB * X1FACE(II) * AREA
                INXAREA(JAXIS,ICF) = 0._EB
                INXAREA(KAXIS,ICF) = 0._EB
                ! dot(e1,nc)*int(x1^2)dA, where x=x1face(ii) constant and nc=e1:
                INXSQAREA(IAXIS,ICF) = 1._EB * X1FACE(II)**2._EB * AREA
                ! dot(e2,nc)*int(x2^2)dA, where nc=e1 => dot(e2,nc)=0:
                INXSQAREA(JAXIS,ICF) = 0._EB
                ! dot(e3,nc)*int(x3^2)dA, where nc=e1 => dot(e3,nc)=0:
                INXSQAREA(KAXIS,ICF) = 0._EB

             ENDDO

             ! Figure out if a cut-face is completely inside any of the
             ! others (that is, it is a hole on the GASPHASE):
             FINFACE =      0
             NFACE2  =  NFACE
             DO ICF1=1,NFACE2
                ! Test that ICF1 has a negative area (case of holes)
                AREA1 = AREAV(ICF1)
                IF ( AREA1 < -GEOMEPS ) THEN
                   DO ICF2=1,NFACE2
                      ! Drop if same face:
                      IF ( ICF1 == ICF2 ) CYCLE

                      ! Centroid node for ICF1:
                      XYC1(1:2) = XYZCEN( (/ JAXIS, KAXIS /) , ICF1 ) ! [x2axis x3axis]

                      ! Polygon nodes for ICF2:
                      NP2 = CFELEM(1,ICF2)
                      DO IPT=2,NP2+1
                         ICF_PT = CFELEM(IPT,ICF2)
                         ! Define closed Polygon:
                         XY(IAXIS:JAXIS,IPT-1) = (/ XYZVERT(X2AXIS,ICF_PT), XYZVERT(X3AXIS,ICF_PT) /)
                      ENDDO

                      CALL TEST_PT_INPOLY(NP2,XY,XYC1,PTSFLAG)

                      IF ( PTSFLAG ) THEN ! Centroid of face 1 inside Face 2.

                         FINFACE(ICF1) = ICF2
                         NFACE = NFACE - 1

                         ! Redefine areas in case of faces with holes:
                         AREA2 = AREAV(ICF2)

                         ! Area with hole, AREA1 has negative sign:
                         AREAH = AREA2 + AREA1

                         ! Centroid with hole:
                         XYC2(1:2) = XYZCEN( (/ JAXIS, KAXIS /) , ICF2 )  ! [x2axis x3axis]
                         XYH(1:2)  = (AREA1 * XYC1(1:2) + AREA2 * XYC2(1:2)) / AREAH

                         ! So ICF2 has the area with hole properties:
                         AREAV(ICF2) = AREAH
                         XYZCEN(JAXIS,ICF2) = XYH(IAXIS)
                         XYZCEN(KAXIS,ICF2) = XYH(JAXIS)

                         ! Other geom variables:
                         INXAREA(IAXIS:KAXIS,ICF2)  =  INXAREA(IAXIS:KAXIS,ICF2)+  INXAREA(IAXIS:KAXIS,ICF1)
                         INXSQAREA(IAXIS:KAXIS,ICF2)=INXSQAREA(IAXIS:KAXIS,ICF2)+INXSQAREA(IAXIS:KAXIS,ICF1)

                         EXIT
                      ENDIF
                   ENDDO
                ENDIF
             ENDDO

             ! Now enhance CFELEM for faces with holes nodes:
             DO ICF1=1,NFACE2
                ICF2 = FINFACE(ICF1)
                IF ( ICF2 > 0 ) THEN ! Allows for up to one hole per IBM_GASPHASE cut-face.
                   ! Load points
                   NP1    = CFELEM(1,ICF1)
                   NP2    = CFELEM(1,ICF2)
                   NP     = (NP1+1) + (NP2+1)
                   CFE(1) = NP

                   DO II2=2,NP1+1
                      CFE(II2) = CFELEM(II2,ICF1)
                   ENDDO
                   II2 = (NP1+1) + 1
                   CFE(II2) = CFELEM(2,ICF1)

                   ! Load last point location:
                   ILOC = 2
                   DIST12 = 1._EB / GEOMEPS
                   XYC1(1:2) = (/ XYZVERT(X2AXIS,CFE(II2)), XYZVERT(X3AXIS,CFE(II2)) /)
                   DO COUNT=2,NP2+1
                      XYC2(1:2) = (/ XYZVERT(X2AXIS,CFELEM(COUNT,ICF2)), XYZVERT(X3AXIS,CFELEM(COUNT,ICF2)) /)
                      D12 = SQRT( (XYC1(1)-XYC2(1))**2._EB + (XYC1(2)-XYC2(2))**2._EB )
                      IF( D12 < DIST12 ) THEN
                         DIST12 = D12
                         ILOC = COUNT
                      ENDIF
                   ENDDO
                   IF (ILOC > 2) THEN
                      ! Rebuild CFELEM(:,ICF2) such that the first point is ILOC:
                      CFEL(2:2+(NP2+1)-ILOC)    = CFELEM(ILOC:NP2+1,ICF2)
                      CFEL(3+(NP2+1)-ILOC:NP2+1)= CFELEM(2:ILOC-1 ,ICF2)
                      CFELEM(2:NP2+1 ,ICF2)     = CFEL(2:NP2+1)
                   ENDIF

                   COUNT = 1
                   DO II2=(NP1+1)+2,(NP1+1)+1+NP2
                      COUNT    = COUNT + 1
                      CFE(II2) = CFELEM(COUNT,ICF2)
                   ENDDO
                   II2 = NP + 1
                   CFE(II2) = CFELEM(2,ICF2)

                   ! Copy CFE into CFELEM(1:np+1,icf2):
                   CFELEM(1:NP+1,ICF2) = CFE(1:NP+1)

                ENDIF
             ENDDO

             NVERTFACE = MAXVAL(CFELEM(1,1:NFACE)) + 1

             ! This is a cut-face, allocate space:
             NCUTFACE = MESHES(NM)%N_CUTFACE_MESH + MESHES(NM)%N_GCCUTFACE_MESH + 1
             IF (BNDINT_FLAG) THEN
                MESHES(NM)%N_CUTFACE_MESH = NCUTFACE
             ELSE
                MESHES(NM)%N_GCCUTFACE_MESH = MESHES(NM)%N_GCCUTFACE_MESH + 1
             ENDIF
             MESHES(NM)%FCVAR(INDI,INDJ,INDK,IBM_IDCF,X1AXIS) = NCUTFACE
             MESHES(NM)%CUT_FACE(NCUTFACE)%NVERT  = NVERT
             MESHES(NM)%CUT_FACE(NCUTFACE)%NFACE  = NFACE
             MESHES(NM)%CUT_FACE(NCUTFACE)%IJK(1:MAX_DIM+1) = (/ INDI, INDJ, INDK, X1AXIS /)
             MESHES(NM)%CUT_FACE(NCUTFACE)%STATUS = IBM_GASPHASE
             CALL NEW_FACE_ALLOC(NM,NCUTFACE,NVERT,NFACE,NVERTFACE)
             MESHES(NM)%CUT_FACE(NCUTFACE)%XYZVERT(IAXIS:KAXIS,1:NVERT) = XYZVERT(IAXIS:KAXIS,1:NVERT)

             ! Load Ordered nodes to CFELEM and geom properties:
             COUNT = 0
             DO ICF=1,NFACE2
                IF ( FINFACE(ICF) > 0 ) CYCLE ! icf is a hole on another cut-face.
                COUNT = COUNT + 1
                ! Connectivity:
                MESHES(NM)%CUT_FACE(NCUTFACE)%CFELEM(1:NVERTFACE,COUNT) = &
                                                  CFELEM(1:NVERTFACE, ICF)
                ! Geom Properties:
                MESHES(NM)%CUT_FACE(NCUTFACE)%AREA(COUNT) = AREAV(ICF)
                MESHES(NM)%CUT_FACE(NCUTFACE)%XYZCEN(IAXIS:KAXIS,COUNT) = &
                                                  XYZCEN( (/ XIAXIS, XJAXIS, XKAXIS /) ,ICF)

                ! Fields for cut-cell volume/centroid computation:
                ! dot(i,nc)*int(x)dA, where nc=j => dot(i,nc)=0:
                MESHES(NM)%CUT_FACE(NCUTFACE)%INXAREA(COUNT)   =   INXAREA(XIAXIS,ICF)
                ! dot(i,nc)*int(x^2)dA, where nc=j => dot(i,nc)=0:
                MESHES(NM)%CUT_FACE(NCUTFACE)%INXSQAREA(COUNT) = INXSQAREA(XIAXIS,ICF)
                ! dot(j,nc)*int(y^2)dA, where y=yface(J) constant nc=j:
                MESHES(NM)%CUT_FACE(NCUTFACE)%JNYSQAREA(COUNT) = INXSQAREA(XJAXIS,ICF)
                ! dot(k,nc)*int(z^2)dA, where nc=j => dot(k,nc)=0:
                MESHES(NM)%CUT_FACE(NCUTFACE)%KNZSQAREA(COUNT) = INXSQAREA(XKAXIS,ICF)
             ENDDO
             ! Final number of cut-faces in the gas region of the face:
             NFACE = COUNT
             MESHES(NM)%CUT_FACE(NCUTFACE)%NFACE  = NFACE


             ! Here we load Cartesian cut faces that belong to the solid region, for SLICE plotting
             ! purposes:
             SOLID_FACE_IF : IF (GET_SOLID_CUTFACES) THEN
             ! Build segment list:
             NSSEG      = 0
             NSVERT     = 0
             NSFACE     = 0

             SEG_FACE (NOD1:NOD2,1:IBM_MAXCEELEM_FACE)             = IBM_UNDEFINED
             XYZVERT(IAXIS:KAXIS,1:IBM_MAXVERTS_FACE)              = 0._EB
             CFELEM(1:IBM_MAXVERT_CUTFACE,1:IBM_MAXCFELEM_FACE)    = IBM_UNDEFINED
             ANGSEG(1:IBM_MAXCEELEM_FACE)                          = 0._EB

             ! First Add to vertex list INBOUNDARY vertices and SOLID Cartesian vertices:
             CEI = MESHES(NM)%FCVAR(INDI,INDJ,INDK,IBM_IDCE,X1AXIS)
             IF ( CEI > 0 ) THEN ! There are inboundary cut-edges
                NEDGE = MESHES(NM)%CUT_EDGE(CEI)%NEDGE
                DO IEDGE=1,NEDGE
                   SEG(NOD1:NOD2) = MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,IEDGE)

                   ! Here we use the SOLID orientation NOD1:NOD2 for right hand rule (inverse of GASPHASE cut-faces)
                   ! x,y,z of node 1:
                   XYZV(IAXIS:KAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,SEG(NOD1))
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NSVERT,INOD1,XYZVERT)

                   ! x,y,z of node 2:
                   XYZV(IAXIS:KAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,SEG(NOD2))
                   CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NSVERT,INOD2,XYZVERT)

                   ! ADD segment:
                   NSSEG = NSSEG + 1
                   SEG_FACE(NOD1:NOD2,NSSEG) = (/ INOD1, INOD2 /)
                   DX3 = XYZVERT(X3AXIS,INOD2)-XYZVERT(X3AXIS,INOD1)
                   DX2 = XYZVERT(X2AXIS,INOD2)-XYZVERT(X2AXIS,INOD1)
                   ANGSEG(NSSEG) = ATAN2(DX3,DX2)

                ENDDO
             ENDIF

             ! Now add IBM_SOLID Type vertices:
             ! Vertex at index JJ-FCELL,KK-FCELL:
             INDXI1(IAXIS:KAXIS) = (/ II, JJ-FCELL  , KK-FCELL   /) ! Local x1,x2,x3
             INDI1 = INDXI1(XIAXIS)
             INDJ1 = INDXI1(XJAXIS)
             INDK1 = INDXI1(XKAXIS)
             ! Vertex at index JJ-FCELL+1,KK-FCELL:
             INDXI2(IAXIS:KAXIS) = (/ II, JJ-FCELL+1, KK-FCELL   /) ! Local x1,x2,x3
             INDI2 = INDXI2(XIAXIS)
             INDJ2 = INDXI2(XJAXIS)
             INDK2 = INDXI2(XKAXIS)
             ! Vertex at index JJ-FCELL+1,KK-FCELL+1:
             INDXI3(IAXIS:KAXIS) = (/ II, JJ-FCELL+1, KK-FCELL+1 /) ! Local x1,x2,x3
             INDI3 = INDXI3(XIAXIS)
             INDJ3 = INDXI3(XJAXIS)
             INDK3 = INDXI3(XKAXIS)
             ! Vertex at index JJ-FCELL,KK-FCELL+1:
             INDXI4(IAXIS:KAXIS) = (/ II, JJ-FCELL  , KK-FCELL+1 /) ! Local x1,x2,x3
             INDI4 = INDXI4(XIAXIS)
             INDJ4 = INDXI4(XJAXIS)
             INDK4 = INDXI4(XKAXIS)

             IF(MESHES(NM)%VERTVAR(INDI1,INDJ1,INDK1,IBM_VGSC) == IBM_SOLID ) THEN
                XYZLC(IAXIS:KAXIS) = (/ X1FACE(INDXI1(IAXIS)), X2FACE(INDXI1(JAXIS)), X3FACE(INDXI1(KAXIS)) /)
                X1 = XYZLC(XIAXIS); X2 = XYZLC(XJAXIS); X3 = XYZLC(XKAXIS)
                XYZV(IAXIS:KAXIS) = (/ X1, X2, X3 /)
                CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NSVERT,INOD1,XYZVERT)
             ENDIF

             IF(MESHES(NM)%VERTVAR(INDI2,INDJ2,INDK2,IBM_VGSC) == IBM_SOLID ) THEN
                XYZLC(IAXIS:KAXIS) = (/ X1FACE(INDXI2(IAXIS)), X2FACE(INDXI2(JAXIS)), X3FACE(INDXI2(KAXIS)) /)
                X1 = XYZLC(XIAXIS); X2 = XYZLC(XJAXIS); X3 = XYZLC(XKAXIS)
                XYZV(IAXIS:KAXIS) = (/ X1, X2, X3 /)
                CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NSVERT,INOD1,XYZVERT)
             ENDIF

             IF(MESHES(NM)%VERTVAR(INDI3,INDJ3,INDK3,IBM_VGSC) == IBM_SOLID ) THEN
                XYZLC(IAXIS:KAXIS) = (/ X1FACE(INDXI3(IAXIS)), X2FACE(INDXI3(JAXIS)), X3FACE(INDXI3(KAXIS)) /)
                X1 = XYZLC(XIAXIS); X2 = XYZLC(XJAXIS); X3 = XYZLC(XKAXIS)
                XYZV(IAXIS:KAXIS) = (/ X1, X2, X3 /)
                CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NSVERT,INOD1,XYZVERT)
             ENDIF

             IF(MESHES(NM)%VERTVAR(INDI4,INDJ4,INDK4,IBM_VGSC) == IBM_SOLID ) THEN
                XYZLC(IAXIS:KAXIS) = (/ X1FACE(INDXI4(IAXIS)), X2FACE(INDXI4(JAXIS)), X3FACE(INDXI4(KAXIS)) /)
                X1 = XYZLC(XIAXIS); X2 = XYZLC(XJAXIS); X3 = XYZLC(XKAXIS)
                XYZV(IAXIS:KAXIS) = (/ X1, X2, X3 /)
                CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZV,NSVERT,INOD1,XYZVERT)
             ENDIF

             ! Make List of HIGH X2 vertices, in ascending X3 order. Add segments:
             ASCDESC=.TRUE.
             XVERT1(1:NSVERT) = XYZVERT(X2AXIS,1:NSVERT)
             XVERT2(1:NSVERT) = XYZVERT(X3AXIS,1:NSVERT)
             CALL SORT_VERTS(IBM_MAXVERTS_FACE,NSVERT,XVERT1,XVERT2,X2FACE(JJ-FCELL+1),ASCDESC,NV,V)
             DO IV=1,NV-1
                NSSEG=NSSEG + 1
                SEG_FACE(NOD1:NOD2,NSSEG) = (/ V(IV), V(IV+1) /)
                ANGSEG(NSSEG) = PI / 2._EB
             ENDDO

             ! Make list of HIGH X3 vertices, in descending X2 order. Add segments:
             ASCDESC=.FALSE.
             XVERT1(1:NSVERT) = XYZVERT(X3AXIS,1:NSVERT)
             XVERT2(1:NSVERT) = XYZVERT(X2AXIS,1:NSVERT)
             CALL SORT_VERTS(IBM_MAXVERTS_FACE,NSVERT,XVERT1,XVERT2,X3FACE(KK-FCELL+1),ASCDESC,NV,V)
             DO IV=1,NV-1
                NSSEG=NSSEG + 1
                SEG_FACE(NOD1:NOD2,NSSEG) = (/ V(IV), V(IV+1) /)
                ANGSEG(NSSEG) = PI
             ENDDO

             ! Make list of LOW X2 vertices, in descending X3 order. Add segments:
             ASCDESC=.FALSE.
             XVERT1(1:NSVERT) = XYZVERT(X2AXIS,1:NSVERT)
             XVERT2(1:NSVERT) = XYZVERT(X3AXIS,1:NSVERT)
             CALL SORT_VERTS(IBM_MAXVERTS_FACE,NSVERT,XVERT1,XVERT2,X2FACE(JJ-FCELL),ASCDESC,NV,V)
             DO IV=1,NV-1
                NSSEG=NSSEG + 1
                SEG_FACE(NOD1:NOD2,NSSEG) = (/ V(IV), V(IV+1) /)
                ANGSEG(NSSEG) = - PI / 2._EB
             ENDDO

             ! Make list of LOW X3 vertices, in ascending X2 order. Add segments:
             ASCDESC=.TRUE.
             XVERT1(1:NSVERT) = XYZVERT(X3AXIS,1:NSVERT)
             XVERT2(1:NSVERT) = XYZVERT(X2AXIS,1:NSVERT)
             CALL SORT_VERTS(IBM_MAXVERTS_FACE,NSVERT,XVERT1,XVERT2,X3FACE(KK-FCELL),ASCDESC,NV,V)
             DO IV=1,NV-1
                NSSEG=NSSEG + 1
                SEG_FACE(NOD1:NOD2,NSSEG) = (/ V(IV), V(IV+1) /)
                ANGSEG(NSSEG) = 0._EB
             ENDDO

             ! Use list of segments on gasphase region from CUT_EDGE:
             ! These are to discard from SEGS computed before:
             COUNT=0
             SEG_FACEAUX(NOD1:NOD2,1:NSSEG) = SEG_FACE(NOD1:NOD2,1:NSSEG)
             ANGSEGAUX(1:NSSEG)=ANGSEG(1:NSSEG)
             SEG_FLAG(1:NSSEG) = .FALSE.
             OUTER : DO ISEG=1,NSSEG
                ! Test against GASPHASE segments:
                INNER1 : DO ISEG2=1,NSEG_CART
                   SNOD1(NOD1:NOD2)= SEG_FACEAUX(NOD1:NOD2,ISEG)
                   SNOD2(NOD1:NOD2)= SEG_FACE_CART(NOD1:NOD2,ISEG2)
                   XYZ_SEG1(IAXIS:KAXIS,NOD1:NOD2) = XYZVERT(IAXIS:KAXIS,SNOD1(NOD1:NOD2))
                   XYZ_SEG2(IAXIS:KAXIS,NOD1:NOD2) = XYZVERT_CART(IAXIS:KAXIS,SNOD2(NOD1:NOD2))
                   ! Test for possible node combination:
                   DO INOD=1,4
                      INOD1=NODC1(INOD) ! [ 1 2 1 2 ]
                      INOD2=NODC2(INOD) ! [ 1 2 2 1]
                      DIFF(INOD) = SQRT((XYZ_SEG1(IAXIS,INOD1)-XYZ_SEG2(IAXIS,INOD2))**2._EB + &
                                        (XYZ_SEG1(JAXIS,INOD1)-XYZ_SEG2(JAXIS,INOD2))**2._EB + &
                                        (XYZ_SEG1(KAXIS,INOD1)-XYZ_SEG2(KAXIS,INOD2))**2._EB ) < GEOMEPS
                   ENDDO
                   IF(DIFF(1) .AND. DIFF(2)) SEG_FLAG(ISEG)=.TRUE. ! Nodes of two segs coincide, its a GASPHASE segment.
                   IF(DIFF(3) .AND. DIFF(4)) SEG_FLAG(ISEG)=.TRUE. ! Nodes of two segs coincide, its a GASPHASE segment.
                ENDDO INNER1
                ! Test against itself:
                INNER2 : DO ISEG2=1,NSSEG
                   IF (ISEG==ISEG2) CYCLE
                   SNOD1(NOD1:NOD2)= SEG_FACEAUX(NOD1:NOD2,ISEG)
                   SNOD2(NOD1:NOD2)= SEG_FACEAUX(NOD1:NOD2,ISEG2)
                   IF(SNOD1(NOD1)==SNOD2(NOD2) .AND. SNOD1(NOD2)==SNOD2(NOD1)) SEG_FLAG(ISEG)=.TRUE.
                ENDDO INNER2
             ENDDO OUTER
             DO ISEG=1,NSSEG
                IF(SEG_FLAG(ISEG)) CYCLE
                COUNT=COUNT+1
                SEG_FACE(NOD1:NOD2,COUNT)=SEG_FACEAUX(NOD1:NOD2,ISEG)
                ANGSEG(COUNT) = ANGSEGAUX(ISEG)
             ENDDO

             NSSEG=COUNT

             ! Build Solid side faces:
             NOTDONE = .TRUE.
             DO WHILE(NOTDONE)
                NOTDONE = .FALSE.
                ! Counts edges that reach nodes:
                NUMEDG_NODE(1:IBM_MAXVERTS_FACE) = 0
                DO ISEG=1,NSSEG
                   DO II2=NOD1,NOD2
                      INOD = SEG_FACE(II2,ISEG)
                      NUMEDG_NODE(INOD) = NUMEDG_NODE(INOD) + 1
                   ENDDO
                ENDDO

                ! Drop segments with NUMEDG_NODE(INOD)=1:
                ! The assumption here is that they are IBM_SS IBM_INBOUNDCF
                ! segments with one node inside the Cartface i.e. case Fig
                ! 9(a) in the CompGeom3D notes):
                COUNT = 0
                SEG_FACEAUX (NOD1:NOD2,1:IBM_MAXCEELEM_FACE)             = IBM_UNDEFINED
                ANGSEGAUX(1:IBM_MAXCEELEM_FACE)                          = 0._EB
                DO ISEG=1,NSSEG
                   NUMNOD1 = NUMEDG_NODE(SEG_FACE(NOD1,ISEG))
                   NUMNOD2 = NUMEDG_NODE(SEG_FACE(NOD2,ISEG))
                   IF ((NUMNOD1 > 1) .AND. (NUMNOD2 > 1)) THEN
                      COUNT = COUNT + 1
                      SEG_FACEAUX(NOD1:NOD2,COUNT) = SEG_FACE(NOD1:NOD2,ISEG)
                      ANGSEGAUX(COUNT) = ANGSEG(ISEG)
                   ELSE
                      NOTDONE = .TRUE.
                   ENDIF
                ENDDO
                NSSEG = COUNT
                SEG_FACE = SEG_FACEAUX
                ANGSEG   = ANGSEGAUX
             ENDDO

             ! Discard face with less than 3 edges (triangle):
             IF ( NSSEG < 3 ) CYCLE

             ! Add segments which have both ends attached to more than two segs:
             count = 0
             DO ISEG=1,NSSEG
                NUMNOD1 = NUMEDG_NODE(SEG_FACE(NOD1,ISEG))
                NUMNOD2 = NUMEDG_NODE(SEG_FACE(NOD2,ISEG))
                IF ((NUMNOD1 > 2) .AND. (NUMNOD2 > 2)) THEN
                   COUNT = COUNT + 1
                   SEG_FACE(NOD1:NOD2,NSSEG+COUNT) = SEG_FACE( (/ NOD2, NOD1 /) ,ISEG)
                   IF (ANGSEG(ISEG) >= 0._EB) THEN
                      ANGSEG(NSSEG+COUNT) = ANGSEG(ISEG) - PI
                   ELSE
                      ANGSEG(NSSEG+COUNT) = ANGSEG(ISEG) + PI
                   ENDIF
                ENDIF
             ENDDO
             NSSEG = NSSEG + COUNT

             ! Fill NODEDG_FACE(IEDGE,INOD), where iedge are edges
             ! that contain inod as first node. This assumes edges are
             ! ordered using the right hand rule on x2-x3 plane.
             ! Also compute the edges angles in x2-x3 plane
             NODEDG_FACE(1:MAX_EDG_PER_NODE,1:IBM_MAXVERTS_FACE) = 0
             DO ISEG=1,NSSEG
               INOD1 = SEG_FACE(NOD1,ISEG)
               NEDI  = NODEDG_FACE(1,INOD1) + 1 ! Increase number of edges connected to node by 1.
               NODEDG_FACE(     1,INOD1) = NEDI
               NODEDG_FACE(NEDI+1,INOD1) = ISEG
             ENDDO

             ! Now Reorder Segments, do tests:
             SEG_FACE2(NOD1:NOD3,1:IBM_MAXCEELEM_FACE) = IBM_UNDEFINED  ! [INOD1 INOD2 ICF]
             SEG_FLAG(1:IBM_MAXCEELEM_FACE) = .TRUE.

             ICF  = 1
             ISEG = 1
             NEWSEG = ISEG
             COUNT= 1
             CTSTART=COUNT
             SEG_FACE2(NOD1:NOD3,COUNT) = (/ SEG_FACE(NOD1,NEWSEG), SEG_FACE(NOD2,NEWSEG), ICF /)
             SEG_FLAG(ISEG) = .FALSE.
             NSEG_LEFT      = NSSEG - 1

             ! Infamous infinite loop:
             INF_LOOP2 : DO

                FOUNDSEG = .FALSE.
                N2COUNT  = SEG_FACE2(NOD2,COUNT) ! Node 2 of segment COUNT.
                ANGCOUNT = ANGSEG(NEWSEG)

                ! Find Segment starting on Node 2 with smaller ANGSEG respect to COUNT.
                DANG = -1._EB / GEOMEPS
                DO ISS=2,NODEDG_FACE(1,N2COUNT)+1
                   ISEG = NODEDG_FACE(ISS,N2COUNT)
                   IF ( SEG_FLAG(ISEG) ) THEN ! This seg hasn't been added to SEG_FACE2
                                             ! Drop if seg is the opposite of count seg:
                      IF ( SEG_FACE2(NOD1,COUNT) == SEG_FACE(NOD2,ISEG) ) CYCLE
                      DANGI = ANGSEG(ISEG) - ANGCOUNT
                      IF ( DANGI < 0._EB ) DANGI = DANGI + 2._EB * PI

                      IF ( DANGI > DANG ) THEN
                         NEWSEG   =  ISEG
                         DANG     = DANGI
                         FOUNDSEG = .TRUE.
                      ENDIF
                   ENDIF
                ENDDO

                ! Found a seg add to SEG_FACE2:
                IF ( FOUNDSEG ) THEN
                   COUNT          = COUNT + 1
                   SEG_FACE2(NOD1:NOD3,COUNT) = (/ SEG_FACE(NOD1,NEWSEG), SEG_FACE(NOD2,NEWSEG), ICF /)
                   SEG_FLAG(NEWSEG) = .FALSE.
                   NSEG_LEFT      = NSEG_LEFT - 1
                ENDIF

                ! Test if line has closed on point shared any other cutface:
                IF ( SEG_FACE2(NOD2,COUNT) == SEG_FACE2(NOD1,CTSTART) ) THEN
                   ! Go for new cut-face on this Cartesian face.
                ELSEIF ( FOUNDSEG ) THEN
                   CYCLE
                ENDIF

                ! Break loop:
                IF ( NSEG_LEFT == 0 ) EXIT

                ! Start a new cut-face on this Cartesian face:
                ICF = ICF + 1
                DO ISEG=1,NSSEG
                   IF ( SEG_FLAG(ISEG) ) THEN
                      COUNT  = COUNT + 1
                      CTSTART= COUNT
                      SEG_FACE2(NOD1:NOD3,COUNT) = (/ SEG_FACE(NOD1,ISEG), SEG_FACE(NOD2,ISEG), ICF /)
                      SEG_FLAG(ISEG) = .FALSE.
                      NSEG_LEFT      = NSEG_LEFT - 1
                      EXIT
                   ENDIF
                ENDDO

             ENDDO INF_LOOP2

             ! Load ordered nodes to CFELEM:
             NSFACE = ICF
             COUNT  = 0
             DO ICF=1,NSFACE
                NP = 0
                DO ISEG=1,NSSEG
                   IF ( SEG_FACE2(NOD3,ISEG) == ICF ) NP = NP + 1
                ENDDO
                IF (NP < 3) CYCLE ! Drop face if it has less than 2 3 vertices
                COUNT=COUNT+1
                NP = 0
                DO ISEG=1,NSSEG
                   IF ( SEG_FACE2(NOD3,ISEG) == ICF ) THEN
                      NP = NP + 1
                      CFELEM(1,COUNT)    = NP
                      CFELEM(NP+1,COUNT) = SEG_FACE2(NOD1,ISEG)
                   ENDIF
                ENDDO
                ! Does Face Have zero Area? If so drop, rewind:
                DO IPT=2,NP+1
                   ICF_PT = CFELEM(IPT,COUNT)
                   ! Define closed Polygon:
                   XY(IAXIS:JAXIS,IPT-1) = (/ XYZVERT(X2AXIS,ICF_PT), XYZVERT(X3AXIS,ICF_PT) /)
                ENDDO
                ICF_PT = CFELEM(2,COUNT)
                XY(IAXIS:JAXIS,NP+1) = (/ XYZVERT(X2AXIS,ICF_PT), XYZVERT(X3AXIS,ICF_PT) /) ! Close Polygon.
                AREA = 0._EB
                DO II2=1,NP
                   AREA = AREA + ( XY(IAXIS,II2) * XY(JAXIS,II2+1) - &
                                   XY(JAXIS,II2) * XY(IAXIS,II2+1) )
                ENDDO
                IF (ABS(AREA) < GEOMEPS**2._EB) THEN
                   CFELEM(1:IBM_MAXVERT_CUTFACE,COUNT) = IBM_UNDEFINED
                   COUNT = COUNT - 1
                ENDIF
             ENDDO
             NSFACE = COUNT; IF(NSFACE==0) CYCLE

             ! Compute area and Centroid, in local x1, x2, x3 coords:
             AREAV(1:NSFACE)                 = 0._EB
             XYZCEN(IAXIS:KAXIS,1:NSFACE)    = 0._EB
             DO ICF=1,NSFACE
                NP    = CFELEM(1,ICF)
                DO IPT=2,NP+1
                   ICF_PT = CFELEM(IPT,ICF)
                   ! Define closed Polygon:
                   XY(IAXIS:JAXIS,IPT-1) = (/ XYZVERT(X2AXIS,ICF_PT), XYZVERT(X3AXIS,ICF_PT) /)
                ENDDO
                ICF_PT = CFELEM(2,ICF)
                XY(IAXIS:JAXIS,NP+1) = (/ XYZVERT(X2AXIS,ICF_PT), XYZVERT(X3AXIS,ICF_PT) /) ! Close Polygon.

                ! Get Area and Centroid properties of Cut-face:
                AREA = 0._EB
                DO II2=1,NP
                   AREA = AREA + ( XY(IAXIS,II2) * XY(JAXIS,II2+1) - &
                                   XY(JAXIS,II2) * XY(IAXIS,II2+1) )
                ENDDO
                AREA = AREA / 2._EB
                ! Now Centroids:
                ! In x2:
                CX2 = 0._EB
                DO II2=1,NP
                   CX2 = CX2 + ( XY(IAXIS,II2)+XY(IAXIS,II2+1)) * &
                               ( XY(IAXIS,II2)*XY(JAXIS,II2+1)  - &
                                 XY(JAXIS,II2)*XY(IAXIS,II2+1) )
                ENDDO

                CX2 = CX2 / (6._EB * AREA)
                ! In x3:
                CX3 = 0._EB
                DO II2=1,NP
                   CX3 = CX3 + ( XY(JAXIS,II2)+XY(JAXIS,II2+1)) * &
                               ( XY(IAXIS,II2)*XY(JAXIS,II2+1)  - &
                                 XY(JAXIS,II2)*XY(IAXIS,II2+1) )
                ENDDO
                CX3 = CX3 / (6._EB * AREA)

                ! Add to cut-face:
                AREAV(ICF) = AREA
                XYZCEN(IAXIS:KAXIS,ICF) = (/  X1FACE(II), CX2, CX3 /)

             ENDDO

             ! Figure out if a cut-face is completely inside any of the
             ! others (that is, it is a hole on the GASPHASE):
             FINFACE =      0
             NSFACE2  =  NSFACE
             DO ICF1=1,NSFACE2
                ! Test that ICF1 has a negative area (case of holes)
                AREA1 = AREAV(ICF1)
                IF ( AREA1 < -GEOMEPS ) THEN
                   DO ICF2=1,NSFACE2
                      ! Drop if same face:
                      IF ( ICF1 == ICF2 ) CYCLE

                      ! Centroid node for ICF1:
                      XYC1(1:2) = XYZCEN( (/ JAXIS, KAXIS /) , ICF1 ) ! [x2axis x3axis]

                      ! Polygon nodes for ICF2:
                      NP2 = CFELEM(1,ICF2)
                      DO IPT=2,NP2+1
                         ICF_PT = CFELEM(IPT,ICF2)
                         ! Define closed Polygon:
                         XY(IAXIS:JAXIS,IPT-1) = (/ XYZVERT(X2AXIS,ICF_PT), XYZVERT(X3AXIS,ICF_PT) /)
                      ENDDO

                      CALL TEST_PT_INPOLY(NP2,XY,XYC1,PTSFLAG)

                      IF ( PTSFLAG ) THEN ! Centroid of face 1 inside Face 2.

                         FINFACE(ICF1) = ICF2
                         NSFACE = NSFACE - 1

                         ! Redefine areas in case of faces with holes:
                         AREA2 = AREAV(ICF2)

                         ! Area with hole, AREA1 has negative sign:
                         AREAH = AREA2 + AREA1

                         ! Centroid with hole:
                         XYC2(1:2) = XYZCEN( (/ JAXIS, KAXIS /) , ICF2 )  ! [x2axis x3axis]
                         XYH(1:2)  = (AREA1 * XYC1(1:2) + AREA2 * XYC2(1:2)) / AREAH

                         ! So ICF2 has the area with hole properties:
                         AREAV(ICF2) = AREAH
                         XYZCEN(JAXIS,ICF2) = XYH(IAXIS)
                         XYZCEN(KAXIS,ICF2) = XYH(JAXIS)
                         EXIT
                      ENDIF
                   ENDDO
                ENDIF
             ENDDO

             ! Now enhance CFELEM for faces with holes nodes:
             DO ICF1=1,NSFACE2
                ICF2 = FINFACE(ICF1)
                IF ( ICF2 > 0 ) THEN ! Allows for up to one hole per IBM_GASPHASE cut-face.
                   ! Load points
                   NP1    = CFELEM(1,ICF1)
                   NP2    = CFELEM(1,ICF2)
                   NP     = (NP1+1) + (NP2+1)
                   CFE(1) = NP

                   DO II2=2,np1+1
                      CFE(II2) = CFELEM(II2,icf1)
                   ENDDO
                   II2 = (np1+1) + 1
                   CFE(II2) = CFELEM(2,icf1)

                   COUNT = 1
                   DO II2=(NP1+1)+2,(NP1+1)+1+NP2
                      COUNT    = COUNT + 1
                      CFE(II2) = CFELEM(COUNT,ICF2)
                   ENDDO
                   II2 = NP + 1
                   CFE(II2) = CFELEM(2,ICF2)

                   ! Copy CFE into CFELEM(1:np+1,icf2):
                   CFELEM(1:NP+1,ICF2) = CFE(1:NP+1)

                ENDIF
             ENDDO

             NVERTFACE = MAXVAL(CFELEM(1,1:NSFACE)) + 1

             ! Up to this point we have all SOLID side cut-faces in CFELEM, SOLID_SIDE nodes in XYZVERT and
             ! Area properties: Add these to Existing CUT_FACE info:
             MESHES(NM)%CUT_FACE(NCUTFACE)%NSVERT  = NSVERT
             MESHES(NM)%CUT_FACE(NCUTFACE)%NSFACE  = NSFACE
             CALL FACE_REALLOC(NM,NCUTFACE,NVERT,NFACE,NSVERT,NSFACE,NVERTFACE)
             MESHES(NM)%CUT_FACE(NCUTFACE)%XYZVERT(IAXIS:KAXIS,NVERT+1:NVERT+NSVERT)=XYZVERT(IAXIS:KAXIS,1:NSVERT)

             ! Load Ordered nodes to CFELEM and geom properties:
             COUNT = NFACE
             DO ICF=1,NSFACE2
                IF ( FINFACE(ICF) > 0 ) CYCLE ! icf is a hole on another cut-face.
                COUNT = COUNT + 1
                ! Connectivity:
                NV=CFELEM(1, ICF)
                CFELEM(2:NV+1,ICF)=CFELEM(2:NV+1,ICF) + NVERT ! Re-index to total number of vertices.
                MESHES(NM)%CUT_FACE(NCUTFACE)%CFELEM(1:NVERTFACE,COUNT) = &
                                                  CFELEM(1:NVERTFACE, ICF)
                ! Geom Properties SOLID:
                MESHES(NM)%CUT_FACE(NCUTFACE)%AREA(COUNT) = AREAV(ICF)
                MESHES(NM)%CUT_FACE(NCUTFACE)%XYZCEN(IAXIS:KAXIS,COUNT) = &
                                                  XYZCEN( (/ XIAXIS, XJAXIS, XKAXIS /) ,ICF)

             ENDDO
             ! Final number of cut-faces in the solid region of the face:
             MESHES(NM)%CUT_FACE(NCUTFACE)%NSFACE  = COUNT-NFACE

             ENDIF SOLID_FACE_IF

            ENDDO ! JJ
         ENDDO ! KK
      ENDDO ! II

      DEALLOCATE(X1FACE,X2FACE,X3FACE)

   ENDDO XIAXIS_LOOP

ENDDO IBNDINT_LOOP

IF (BNDINT_FLAG) THEN
   ! Here we mark faces on the guard-cell region for the computaiton of grid aligned INBOUNDARY faces
   ! on CARTCELL_CUTFACES to work correctly:
   XIAXIS_LOOP_2 : DO X1AXIS=IAXIS,KAXIS

      SELECT CASE(X1AXIS)
      case(IAXIS)

         X2AXIS = JAXIS
         X3AXIS = KAXIS

         ! IAXIS gasphase cut-faces:
         ILO = ILO_FACE-CCGUARD; IHI = IHI_FACE+CCGUARD
         JLO = JLO_CELL-CCGUARD; JHI = JHI_CELL+CCGUARD
         KLO = KLO_CELL-CCGUARD; KHI = KHI_CELL+CCGUARD

         ! location in I,J,K od x2,x2,x3 axes:
         XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS

         ! Local indexing in x1, x2, x3:
         X1LO = ILO; X1HI = IHI
         X2LO = JLO; X2HI = JHI
         X3LO = KLO; X3HI = KHI

      CASE(JAXIS)

         X2AXIS = KAXIS
         X3AXIS = IAXIS

         ! JAXIS gasphase cut-faces:
         JLO = JLO_FACE-CCGUARD; JHI = JHI_FACE+CCGUARD
         ILO = ILO_CELL-CCGUARD; IHI = IHI_CELL+CCGUARD
         KLO = KLO_CELL-CCGUARD; KHI = KHI_CELL+CCGUARD

         ! location in I,J,K od x2,x2,x3 axes:
         XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS

         ! Local indexing in x1, x2, x3:
         X1LO = JLO; X1HI = JHI
         X2LO = KLO; X2HI = KHI
         X3LO = ILO; X3HI = IHI

      CASE(KAXIS)

         X2AXIS = IAXIS
         X3AXIS = JAXIS

         ! KAXIS gasphase cut-faces:
         KLO = KLO_FACE-CCGUARD; KHI = KHI_FACE+CCGUARD
         ILO = ILO_CELL-CCGUARD; IHI = IHI_CELL+CCGUARD
         JLO = JLO_CELL-CCGUARD; JHI = JHI_CELL+CCGUARD

         ! location in I,J,K od x2,x2,x3 axes:
         XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS

         ! Local indexing in x1, x2, x3:
         X1LO = KLO; X1HI = KHI
         X2LO = ILO; X2HI = IHI
         X3LO = JLO; X3HI = JHI

      END SELECT

      ! Loop on Cartesian faces, local x1, x2, x3 indexes:
      DO II=X1LO,X1HI
         DO KK=X3LO,X3HI
            DO JJ=X2LO,X2HI

             ! Face indexes:
             INDXI(IAXIS:KAXIS) = (/ II, JJ, KK /) ! Local x1,x2,x3
             INDI = INDXI(XIAXIS)
             INDJ = INDXI(XJAXIS)
             INDK = INDXI(XKAXIS)

             ! Drop if cut-face has already been counted:
             IF( IJK_COUNTED(INDI,INDJ,INDK,X1AXIS) ) CYCLE

             ! Drop if face not cut-face:
             ! Test for FACE Cartesian edges being cut:
             ! If outface1 is true -> All regular edges for this face:
             ! Edge at index KK-FCELL:
             INDXI1(IAXIS:KAXIS) = (/ II, JJ, KK-FCELL /) ! Local x1,x2,x3
             INDI1 = INDXI1(XIAXIS)
             INDJ1 = INDXI1(XJAXIS)
             INDK1 = INDXI1(XKAXIS)
             ! Edge at index KK-FCELL+1:
             INDXI2(IAXIS:KAXIS) = (/ II, JJ, KK-FCELL+1 /) ! Local x1,x2,x3
             INDI2 = INDXI2(XIAXIS)
             INDJ2 = INDXI2(XJAXIS)
             INDK2 = INDXI2(XKAXIS)
             ! Edge at index JJ-FCELL:
             INDXI3(IAXIS:KAXIS) = (/ II, JJ-FCELL, KK /) ! Local x1,x2,x3
             INDI3 = INDXI3(XIAXIS)
             INDJ3 = INDXI3(XJAXIS)
             INDK3 = INDXI3(XKAXIS)
             ! Edge at index jj-FCELL+1:
             INDXI4(IAXIS:KAXIS) = (/ II, JJ-FCELL+1, KK /) ! Local x1,x2,x3
             INDI4 = INDXI4(XIAXIS)
             INDJ4 = INDXI4(XJAXIS)
             INDK4 = INDXI4(XKAXIS)

             OUTFACE1 = (MESHES(NM)%ECVAR(INDI1,INDJ1,INDK1,IBM_EGSC,X2AXIS) /= IBM_CUTCFE) .AND. &
                        (MESHES(NM)%ECVAR(INDI2,INDJ2,INDK2,IBM_EGSC,X2AXIS) /= IBM_CUTCFE) .AND. &
                        (MESHES(NM)%ECVAR(INDI3,INDJ3,INDK3,IBM_EGSC,X3AXIS) /= IBM_CUTCFE) .AND. &
                        (MESHES(NM)%ECVAR(INDI4,INDJ4,INDK4,IBM_EGSC,X3AXIS) /= IBM_CUTCFE)

             ! Test for face with INB edges:
             ! If outface2 is true -> no INB Edges associated with this face:
             OUTFACE2 = (MESHES(NM)%FCVAR(INDI,INDJ,INDK,IBM_IDCE,X1AXIS) <= 0)

             ! Drop if outface1 & outface2
             IF (OUTFACE1 .AND. OUTFACE2) THEN
                ! Test if IBM_FSID is SOLID:
                IF ((MESHES(NM)%ECVAR(INDI1,INDJ1,INDK1,IBM_EGSC,X2AXIS) == IBM_SOLID) .AND. &
                   (MESHES(NM)%ECVAR(INDI2,INDJ2,INDK2,IBM_EGSC,X2AXIS) == IBM_SOLID) .AND. &
                   (MESHES(NM)%ECVAR(INDI3,INDJ3,INDK3,IBM_EGSC,X3AXIS) == IBM_SOLID) .AND. &
                   (MESHES(NM)%ECVAR(INDI4,INDJ4,INDK4,IBM_EGSC,X3AXIS) == IBM_SOLID) ) THEN
                   MESHES(NM)%FCVAR(INDI,INDJ,INDK,IBM_FGSC,X1AXIS) = IBM_SOLID
                ENDIF
                CYCLE
             ENDIF

            ENDDO ! JJ
         ENDDO ! KK
      ENDDO ! II

   ENDDO XIAXIS_LOOP_2

ELSE
   DEALLOCATE(IJK_COUNTED)
ENDIF

T_CC_USED(GET_CARTFACE_CUTFACES_TIME_INDEX) = T_CC_USED(GET_CARTFACE_CUTFACES_TIME_INDEX) + CURRENT_TIME() - TNOW

RETURN
END SUBROUTINE GET_CARTFACE_CUTFACES

! ---------------------------- SORT_VERTS ---------------------------------------

SUBROUTINE SORT_VERTS(MAXVERTS,NVERTS,VERTS1,VERTS2,XV,ASCDESC,NV,V)

INTEGER, INTENT(IN) :: MAXVERTS, NVERTS
REAL(EB),INTENT(IN) :: VERTS1(MAXVERTS),VERTS2(MAXVERTS),XV
LOGICAL, INTENT(IN) :: ASCDESC
INTEGER, INTENT(OUT):: NV,V(MAXVERTS)

! Local Variables:
INTEGER :: IV, IIV, JJV
INTEGER :: V2(MAXVERTS)
LOGICAL :: FOUND

V(:) = 0
NV   = 0
DO IV=1,NVERTS
   IF (ABS(VERTS1(IV)-XV) < GEOMEPS) THEN
      IF (NV==0) THEN
         NV=1; V(NV)=IV
      ELSE
         ! Insert add IV, using ascending X3:
         FOUND=.FALSE.
         DO IIV=1,NV
            IF ( (VERTS2(IV)-VERTS2(V(IIV))) < 0._EB ) THEN
                  FOUND=.TRUE.
                  EXIT
            ENDIF
         ENDDO
         IF (FOUND) THEN
            DO JJV=NV+1,IIV+1,-1
               V(JJV) = V(JJV-1)
            ENDDO
            V(IIV) = IV
         ELSE
            V(IIV) = IV ! Here IIV = NV+1, as loop leaves it to that value.
         ENDIF
         NV=NV+1
      ENDIF
   ENDIF
ENDDO
IF (.NOT.ASCDESC) THEN
    V2(1:NV) = V(1:NV)
    DO IV=1,NV; V(NV+1-IV)=V2(IV); ENDDO
ENDIF

RETURN
END SUBROUTINE SORT_VERTS

! ----------------------------- FACE_REALLOC -------------------------------------

SUBROUTINE FACE_REALLOC(NM,ICF,NVERT,NFACE,NSVERT,NSFACE,NVERTFACE_NEW)

INTEGER, INTENT(IN)    :: NM,ICF,NVERT,NFACE,NSVERT,NSFACE
INTEGER, INTENT(INOUT) :: NVERTFACE_NEW

! Local Variables:
INTEGER :: NVERTFACE
REAL(EB), DIMENSION(IAXIS:KAXIS,1:IBM_MAXVERTS_FACE)           :: XYZVERT  ! Locations of vertices.
INTEGER,  DIMENSION(IBM_MAXVERT_CUTFACE,IBM_MAXCFELEM_FACE)    ::  CFELEM  ! Cut-faces connectivities.
REAL(EB), DIMENSION(IBM_MAXCFELEM_FACE)                        ::    AREA  ! Cut-faces areas.
REAL(EB), DIMENSION(IAXIS:KAXIS,1:IBM_MAXCFELEM_FACE)          ::  XYZCEN  ! Cut-faces centroid locations.
!INTEGER,  DIMENSION(IBM_MAXCFELEM_FACE)                        ::  CFACE_INDEX

NVERTFACE=SIZE(MESHES(NM)%CUT_FACE(ICF)%CFELEM,DIM=1)
NVERTFACE_NEW = MAX(NVERTFACE_NEW,NVERTFACE)

! Allocate and initialize NVERT related fields:
XYZVERT(IAXIS:KAXIS,1:NVERT)=MESHES(NM)%CUT_FACE(ICF)%XYZVERT(IAXIS:KAXIS,1:NVERT)
DEALLOCATE(MESHES(NM)%CUT_FACE(ICF)%XYZVERT)
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%XYZVERT(IAXIS:KAXIS,1:NVERT+NSVERT)); MESHES(NM)%CUT_FACE(ICF)%XYZVERT = 0._EB
MESHES(NM)%CUT_FACE(ICF)%XYZVERT(IAXIS:KAXIS,1:NVERT)=XYZVERT(IAXIS:KAXIS,1:NVERT)

! Allocate and initialize NFACE, NVERTFACE related fields:
CFELEM(1:NVERTFACE,1:NFACE)=MESHES(NM)%CUT_FACE(ICF)%CFELEM(1:NVERTFACE,1:NFACE)
DEALLOCATE(MESHES(NM)%CUT_FACE(ICF)%CFELEM)
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%CFELEM(1:NVERTFACE_NEW,1:NFACE+NSFACE));
MESHES(NM)%CUT_FACE(ICF)%CFELEM = IBM_UNDEFINED
MESHES(NM)%CUT_FACE(ICF)%CFELEM(1:NVERTFACE,1:NFACE)=CFELEM(1:NVERTFACE,1:NFACE)

AREA(1:NFACE)=MESHES(NM)%CUT_FACE(ICF)%AREA(1:NFACE)
XYZCEN(IAXIS:KAXIS,1:NFACE)=MESHES(NM)%CUT_FACE(ICF)%XYZCEN(IAXIS:KAXIS,1:NFACE)
DEALLOCATE(MESHES(NM)%CUT_FACE(ICF)%AREA, MESHES(NM)%CUT_FACE(ICF)%XYZCEN)
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%AREA(1:NFACE+NSFACE)); MESHES(NM)%CUT_FACE(ICF)%AREA = 0._EB
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%XYZCEN(IAXIS:KAXIS,1:NFACE+NSFACE)); MESHES(NM)%CUT_FACE(ICF)%XYZCEN = 0._EB
MESHES(NM)%CUT_FACE(ICF)%AREA(1:NFACE)=AREA(1:NFACE)
MESHES(NM)%CUT_FACE(ICF)%XYZCEN(IAXIS:KAXIS,1:NFACE)=XYZCEN(IAXIS:KAXIS,1:NFACE)

! ! No need to do this for now. All reallocated faces are of type IBM_GASPHASE.
! IF (MESHES(NM)%CUT_FACE(ICF)%STATUS /= IBM_INBOUNDARY) RETURN
! ! This is to keep the size of CFACE_INDEX consistent on .
! CFACE_INDEX(1:NFACE)=MESHES(NM)%CUT_FACE(ICF)%CFACE_INDEX(1:NFACE)
! DEALLOCATE(MESHES(NM)%CUT_FACE(ICF)%CFACE_INDEX)
! ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%CFACE_INDEX(1:NFACE+NSFACE))
! MESHES(NM)%CUT_FACE(ICF)%CFACE_INDEX = IBM_UNDEFINED
! MESHES(NM)%CUT_FACE(ICF)%CFACE_INDEX(1:NFACE)=CFACE_INDEX(1:NFACE)

RETURN

END SUBROUTINE FACE_REALLOC

! -------------------------- NEW_FACE_ALLOC -------------------------------------

SUBROUTINE NEW_FACE_ALLOC(NM,ICF,NVERT,NFACE,NVERTFACE)

INTEGER, INTENT(IN) :: NM,ICF,NVERT,NFACE,NVERTFACE

! Local Variables:


! Allocate and initialize NVERT related fields:
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%XYZVERT(IAXIS:KAXIS,1:NVERT)); MESHES(NM)%CUT_FACE(ICF)%XYZVERT = 0._EB

! Allocate and initialize NFACE, NVERTFACE related fields:
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%CFELEM(1:NVERTFACE,1:NFACE)); MESHES(NM)%CUT_FACE(ICF)%CFELEM = IBM_UNDEFINED
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%AREA(1:NFACE)); MESHES(NM)%CUT_FACE(ICF)%AREA = 0._EB
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%XYZCEN(IAXIS:KAXIS,1:NFACE)); MESHES(NM)%CUT_FACE(ICF)%XYZCEN = 0._EB

!Integrals to be used in cut-cell volume and centroid computations.
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%INXAREA(1:NFACE));   MESHES(NM)%CUT_FACE(ICF)%INXAREA   = 0._EB
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%INXSQAREA(1:NFACE)); MESHES(NM)%CUT_FACE(ICF)%INXSQAREA = 0._EB
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%JNYSQAREA(1:NFACE)); MESHES(NM)%CUT_FACE(ICF)%JNYSQAREA = 0._EB
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%KNZSQAREA(1:NFACE)); MESHES(NM)%CUT_FACE(ICF)%KNZSQAREA = 0._EB

ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%BODTRI(1:2,1:NFACE));MESHES(NM)%CUT_FACE(ICF)%BODTRI = IBM_UNDEFINED

ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%UNKH(LOW_IND:HIGH_IND,1:NFACE));MESHES(NM)%CUT_FACE(ICF)%UNKH = IBM_UNDEFINED
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%UNKZ(LOW_IND:HIGH_IND,1:NFACE));MESHES(NM)%CUT_FACE(ICF)%UNKZ = IBM_UNDEFINED

ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%XCENLOW(IAXIS:KAXIS,1:NFACE)); MESHES(NM)%CUT_FACE(ICF)%XCENLOW  = 0._EB
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%XCENHIGH(IAXIS:KAXIS,1:NFACE));MESHES(NM)%CUT_FACE(ICF)%XCENHIGH = 0._EB

ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%RHO(LOW_IND:HIGH_IND,1:NFACE));MESHES(NM)%CUT_FACE(ICF)%RHO = 0._EB
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%DIFF_FACE(1:MAX_SPECIES,1:NFACE));MESHES(NM)%CUT_FACE(ICF)%DIFF_FACE = 0._EB
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%RHO_D(1:MAX_SPECIES,1:NFACE));    MESHES(NM)%CUT_FACE(ICF)%RHO_D     = 0._EB
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%VELD(1:MAX_SPECIES,1:NFACE));     MESHES(NM)%CUT_FACE(ICF)%VELD      = 0._EB
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%RHO_D_DZDN(1:MAX_SPECIES,LOW_IND:HIGH_IND,1:NFACE))
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%H_RHO_D_DZDN(1:MAX_SPECIES,1:NFACE))
MESHES(NM)%CUT_FACE(ICF)%RHO_D_DZDN   = 0._EB
MESHES(NM)%CUT_FACE(ICF)%H_RHO_D_DZDN = 0._EB

ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%ZZ_FACE(1:MAX_SPECIES,1:NFACE)); MESHES(NM)%CUT_FACE(ICF)%ZZ_FACE = 0._EB
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%TMP_FACE(1:NFACE)); MESHES(NM)%CUT_FACE(ICF)%TMP_FACE = 0._EB

ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%VEL(1:NFACE),    MESHES(NM)%CUT_FACE(ICF)%VELS(1:NFACE), &
         MESHES(NM)%CUT_FACE(ICF)%DHDX(1:NFACE),   MESHES(NM)%CUT_FACE(ICF)%FN(1:NFACE),   &
         MESHES(NM)%CUT_FACE(ICF)%VELNP1(1:NFACE), MESHES(NM)%CUT_FACE(ICF)%VELINT(1:NFACE))
MESHES(NM)%CUT_FACE(ICF)%VEL    = 0._EB; MESHES(NM)%CUT_FACE(ICF)%VELS   = 0._EB
MESHES(NM)%CUT_FACE(ICF)%DHDX   = 0._EB; MESHES(NM)%CUT_FACE(ICF)%FN     = 0._EB
MESHES(NM)%CUT_FACE(ICF)%VELNP1 = 0._EB; MESHES(NM)%CUT_FACE(ICF)%VELINT = 0._EB

ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%JDZ(1:2,1:2,1:NFACE),MESHES(NM)%CUT_FACE(ICF)%JDH(1:2,1:2,1:NFACE))
MESHES(NM)%CUT_FACE(ICF)%JDZ = IBM_UNDEFINED; MESHES(NM)%CUT_FACE(ICF)%JDH = IBM_UNDEFINED

ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%CELL_LIST(MAX_DIM+1,LOW_IND:HIGH_IND,1:NFACE))
MESHES(NM)%CUT_FACE(ICF)%CELL_LIST = IBM_UNDEFINED

ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%IJK_CFCEN(MAX_DIM,MAX_INTERP_POINTS_PLANE,1:NFACE))
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%INBFC_CFCEN(3,1:NFACE))
MESHES(NM)%CUT_FACE(ICF)%IJK_CFCEN = IBM_UNDEFINED; MESHES(NM)%CUT_FACE(ICF)%INBFC_CFCEN = IBM_UNDEFINED

ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%XYZ_BP_CFCEN(MAX_DIM,1:NFACE));MESHES(NM)%CUT_FACE(ICF)%XYZ_BP_CFCEN = 0._EB
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%INTCOEF_CFCEN(MAX_INTERP_POINTS_PLANE+1,1:NFACE))
MESHES(NM)%CUT_FACE(ICF)%INTCOEF_CFCEN = 0._EB

ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%VEL_CFCEN(  MAX_INTERP_POINTS_PLANE+1,1:NFACE), &
         MESHES(NM)%CUT_FACE(ICF)%VELS_CFCEN( MAX_INTERP_POINTS_PLANE+1,1:NFACE), &
         MESHES(NM)%CUT_FACE(ICF)%FV_CFCEN(   MAX_INTERP_POINTS_PLANE+1,1:NFACE), &
         MESHES(NM)%CUT_FACE(ICF)%DHDX1_CFCEN(MAX_INTERP_POINTS_PLANE+1,1:NFACE))
MESHES(NM)%CUT_FACE(ICF)%VEL_CFCEN  = 0._EB
MESHES(NM)%CUT_FACE(ICF)%VELS_CFCEN = 0._EB
MESHES(NM)%CUT_FACE(ICF)%FV_CFCEN   = 0._EB
MESHES(NM)%CUT_FACE(ICF)%DHDX1_CFCEN= 0._EB

ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%NOMIND_CFCEN(LOW_IND:HIGH_IND,1:MAX_INTERP_POINTS_PLANE,1:NFACE))
MESHES(NM)%CUT_FACE(ICF)%NOMIND_CFCEN = IBM_UNDEFINED

ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%RHOPVN(-1:0,1:NFACE)); MESHES(NM)%CUT_FACE(ICF)%RHOPVN = 0._EB

IF (MESHES(NM)%CUT_FACE(ICF)%STATUS /= IBM_INBOUNDARY) RETURN

ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%CFACE_INDEX(1:NFACE)); MESHES(NM)%CUT_FACE(ICF)%CFACE_INDEX = IBM_UNDEFINED
ALLOCATE(MESHES(NM)%CUT_FACE(ICF)%SURF_INDEX(1:NFACE));  MESHES(NM)%CUT_FACE(ICF)%SURF_INDEX  = IBM_UNDEFINED

RETURN
END SUBROUTINE NEW_FACE_ALLOC

! -------------------------- TEST_PT_INPOLY -------------------------------------

SUBROUTINE TEST_PT_INPOLY(NP,XY,XY1,PTSFLAG)

INTEGER,  INTENT(IN) :: NP
REAL(EB), INTENT(INOUT) :: XY(IAXIS:JAXIS,1:IBM_MAXVERTS_FACE)
REAL(EB), INTENT(IN) :: XY1(IAXIS:JAXIS)
LOGICAL,  INTENT(OUT) :: PTSFLAG

! Local Variables:
INTEGER :: RCROSS, LCROSS, IP
REAL(EB):: XPT
LOGICAL :: RS, LS

PTSFLAG = .FALSE.
RCROSS  = 0
LCROSS  = 0

! ADD first point location at the end of XY (assumes IBM_MAXVERTS_FACE > NP):
XY(IAXIS:JAXIS,NP+1) = XY(IAXIS:JAXIS,1)

! Shift origin to XY1:
DO IP=1,NP+1
    XY(IAXIS:JAXIS,IP) = XY(IAXIS:JAXIS,IP) - XY1(IAXIS:JAXIS)
enddo

! For each edge test against rays x=0, y=0:
DO IP=1,NP
   ! Check if edges first point is vertex:
   IF ( (ABS(XY(IAXIS,IP)) < GEOMEPS) .AND. &
        (ABS(XY(JAXIS,IP)) < GEOMEPS) ) THEN
      PTSFLAG = .TRUE.
      RETURN
   ENDIF
   ! Check if edge crosses x axis:
   RS = (XY(JAXIS,IP) > 0._EB) .NEQV. (XY(JAXIS,IP+1) > 0._EB)
   LS = (XY(JAXIS,IP) < 0._EB) .NEQV. (XY(JAXIS,IP+1) < 0._EB)

   IF ( RS .OR. LS ) THEN
      ! Intersection:
      XPT = (XY(IAXIS,IP  )*XY(JAXIS,IP+1) - XY(JAXIS,IP  )*XY(IAXIS,IP+1)) / (XY(JAXIS,IP+1)-XY(JAXIS,IP))

      IF (RS .AND. (XPT > 0._EB)) RCROSS = RCROSS + 1
      IF (LS .AND. (XPT < 0._EB)) LCROSS = LCROSS + 1
   ENDIF
ENDDO

IF ( MOD(RCROSS,2) /= MOD(LCROSS,2) ) THEN ! Point on edge
       PTSFLAG = .TRUE.
       RETURN
ENDIF

IF ( MOD(RCROSS,2) == 1) THEN ! Point inside
       PTSFLAG = .TRUE.
       RETURN
ENDIF

RETURN
END SUBROUTINE TEST_PT_INPOLY


! ---------------------- GET_CARTCELL_CUTEDGES ----------------------------------

SUBROUTINE GET_CARTCELL_CUTEDGES(NM,ISTR,IEND,JSTR,JEND,KSTR,KEND)

USE COMP_FUNCTIONS, ONLY: CURRENT_TIME

INTEGER, INTENT(IN) :: NM
INTEGER, INTENT(IN) :: ISTR, IEND, JSTR, JEND, KSTR, KEND

! Local Variables:
INTEGER :: II2, JJ2, KK2, IG, IWSEDG, SEG(NOD1:NOD2),X1AXIS, X1LO, X1HI, IPLN, LSTR, LEND
REAL(EB):: XYZ1(IAXIS:KAXIS), XYZ2(IAXIS:KAXIS), PLNORMAL(IAXIS:KAXIS), X1PLN, MINX, MAXX
LOGICAL :: DROPSEG, OUTPLANE, SAMEINT
REAL(EB):: DOT1, DOT2, DENOM, PLANEEQ, SVARI, XYZV1(IAXIS:KAXIS), XYZV2(IAXIS:KAXIS), SLEN, STANI(IAXIS:KAXIS)
INTEGER :: NWCROSS, IBCR, IDUM, INOD1, INOD2, NVERT, NEDGE, IEDGE, CEI
REAL(EB):: SVAR1, SVAR2, SVAR12, XPOS, DV(IAXIS:KAXIS)
REAL(EB) :: TNOW

TNOW=CURRENT_TIME()

! BODINT_CELL allocation size:
IBM_MAX_NWCROSS = 2 * IBM_MAX_NBCROSS ! Large size.

GEOM_LOOP : DO IG=1,N_GEOMETRY

   ! The IG wet surface edges will be used to obtain intersections with grid planes on
   ! increasing svar order.
   ! Allocate BODINT_CELL:
   BODINT_CELL%NWSEGS = GEOMETRY(IG)%N_EDGES
   ALLOCATE(BODINT_CELL%NWCROSS(1:BODINT_CELL%NWSEGS))
   ALLOCATE(BODINT_CELL%SVAR(1:IBM_MAX_NWCROSS,1:BODINT_CELL%NWSEGS))

   IWSEDG_LOOP : DO IWSEDG=1,BODINT_CELL%NWSEGS

      ! Seg Nodes location:
      SEG(NOD1:NOD2) = GEOMETRY(IG)%EDGES(NOD1:NOD2,IWSEDG)

      XYZ1(IAXIS:KAXIS) = GEOMETRY(IG)%VERTS(MAX_DIM*(SEG(NOD1)-1)+1:MAX_DIM*SEG(NOD1))
      XYZ2(IAXIS:KAXIS) = GEOMETRY(IG)%VERTS(MAX_DIM*(SEG(NOD2)-1)+1:MAX_DIM*SEG(NOD2))

      ! Test if Segment lays on plane, If so drop, it was taken care of
      ! previously: This is expensive think of switching to pointer X1FACEP.
      DROPSEG = .FALSE.
      X1AXIS_LOOP : DO X1AXIS=IAXIS,KAXIS
         SELECT CASE(X1AXIS)
           CASE(IAXIS)
              PLNORMAL(IAXIS:KAXIS) = (/ 1._EB,  0._EB, 0._EB /)
              ALLOCATE(X1FACE(ISTR:IEND));   X1FACE =  XFACE
              ALLOCATE(DX1FACE(ISTR:IEND)); DX1FACE = DXFACE
              X1LO   = ILO_FACE-CCGUARD; X1HI   = IHI_FACE+CCGUARD
           CASE(JAXIS)
              PLNORMAL(IAXIS:KAXIS) = (/ 0._EB,  1._EB, 0._EB /)
              ALLOCATE(X1FACE(JSTR:JEND));   X1FACE =  YFACE
              ALLOCATE(DX1FACE(JSTR:JEND)); DX1FACE = DYFACE
              X1LO   = JLO_FACE-CCGUARD; X1HI   = JHI_FACE+CCGUARD
           CASE(KAXIS)
              PLNORMAL(IAXIS:KAXIS) = (/ 0._EB,  0._EB, 1._EB /)
              ALLOCATE(X1FACE(KSTR:KEND));   X1FACE = ZFACE
              ALLOCATE(DX1FACE(KSTR:KEND)); DX1FACE = DZFACE
              X1LO   = KLO_FACE-CCGUARD; X1HI   = KHI_FACE+CCGUARD
         END SELECT

         ! Optimized for UG:
         MINX = MIN(XYZ1(X1AXIS),XYZ2(X1AXIS))
         MAXX = MAX(XYZ1(X1AXIS),XYZ2(X1AXIS))

         IF (MAXX-MINX < GEOMEPS) THEN ! SEGMENT ALIGNED WITH PLANE.
            LSTR = MAX(X1LO,  FLOOR((MINX-GEOMEPS-X1FACE(X1LO))/DX1FACE(X1LO)) + X1LO)
            LEND = MIN(X1HI,CEILING((MAXX+GEOMEPS-X1FACE(X1LO))/DX1FACE(X1LO)) + X1LO)
            DO IPLN=LSTR,LEND
               X1PLN = X1FACE(IPLN)
               DROPSEG=(    ABS(X1PLN-MAXX) < GEOMEPS) .OR. &
                       ((X1FACE(X1LO)-MAXX) > GEOMEPS) .OR. &
                       ((MAXX-X1FACE(X1HI)) > GEOMEPS)
               IF (DROPSEG) EXIT
            ENDDO
         ENDIF
         IF (DROPSEG) THEN
            DEALLOCATE(X1FACE,DX1FACE)
            EXIT ! EXIT X1AXIS=IAXIS:KAXIS LOOP
         ENDIF
         DEALLOCATE(X1FACE,DX1FACE)
      ENDDO X1AXIS_LOOP
      IF (DROPSEG) CYCLE

      ! Edge length and tangent unit vector:
      DV(IAXIS:KAXIS) = XYZ2(IAXIS:KAXIS) - XYZ1(IAXIS:KAXIS)
      SLEN = SQRT( DV(IAXIS)**2._EB + DV(JAXIS)**2._EB + DV(KAXIS)**2._EB ) ! Segment length.
      STANI(IAXIS:KAXIS) = DV(IAXIS:KAXIS) * SLEN**(-1._EB)                 ! Segment tangent versor.

      ! Add segment ends as intersections:
      BODINT_CELL%NWCROSS(IWSEDG)  =    2 ! Nodes 1,2 of segment are considered intersection.
      BODINT_CELL%SVAR(1,IWSEDG)   =    0 ! Coordinate along stani of Node 1.
      BODINT_CELL%SVAR(2,IWSEDG)   = SLEN ! Coordinate along stani of Node 2.


      ! Now find intersections:
      X1AXIS_LOOP2 : DO X1AXIS=IAXIS,KAXIS
         SELECT CASE(X1AXIS)
           CASE(IAXIS)
              PLNORMAL(IAXIS:KAXIS) = (/ 1._EB,  0._EB, 0._EB /)
              ALLOCATE(X1FACE(ISTR:IEND));   X1FACE =  XFACE
              ALLOCATE(DX1FACE(ISTR:IEND)); DX1FACE = DXFACE
              X1LO   = ILO_FACE-CCGUARD; X1HI   = IHI_FACE+CCGUARD
           CASE(JAXIS)
              PLNORMAL(IAXIS:KAXIS) = (/ 0._EB,  1._EB, 0._EB /)
              ALLOCATE(X1FACE(JSTR:JEND));   X1FACE =  YFACE
              ALLOCATE(DX1FACE(JSTR:JEND)); DX1FACE = DYFACE
              X1LO   = JLO_FACE-CCGUARD; X1HI   = JHI_FACE+CCGUARD
           CASE(KAXIS)
              PLNORMAL(IAXIS:KAXIS) = (/ 0._EB,  0._EB, 1._EB /)
              ALLOCATE(X1FACE(KSTR:KEND));   X1FACE = ZFACE
              ALLOCATE(DX1FACE(KSTR:KEND)); DX1FACE = DZFACE
              X1LO   = KLO_FACE-CCGUARD; X1HI   = KHI_FACE+CCGUARD
         END SELECT

         ! Optimized for UG:
         MINX = MIN(XYZ1(X1AXIS),XYZ2(X1AXIS))
         MAXX = MAX(XYZ1(X1AXIS),XYZ2(X1AXIS))
         LSTR = MAX(X1LO,  FLOOR((MINX-GEOMEPS-X1FACE(X1LO))/DX1FACE(X1LO)) + X1LO)
         LEND = MIN(X1HI,CEILING((MAXX+GEOMEPS-X1FACE(X1LO))/DX1FACE(X1LO)) + X1LO)

         DO IPLN=LSTR,LEND
            X1PLN = X1FACE(IPLN);
            OUTPLANE = ((X1PLN-MAXX) > GEOMEPS) .OR. ((MINX-X1PLN) > GEOMEPS)
            IF (OUTPLANE) CYCLE ! Make sure to drop jstr, jend if out of segment length.

            ! Drop intersections in segment nodes:
            ! Compute: dot(plnormal, xyzv - xypl):
            DOT1 = XYZ1(X1AXIS) - X1PLN
            DOT2 = XYZ2(X1AXIS) - X1PLN
            IF (ABS(DOT1) <= GEOMEPS) CYCLE
            IF (ABS(DOT2) <= GEOMEPS) CYCLE

            ! Now regular case: Find svar and insert in BODINT_CELL%SVAR(:,IWSEDG):
            DENOM  = STANI(X1AXIS) ! dot(stani,plnormal)
            PLANEEQ= DOT1          ! dot(xyz1(IAXIS:KAXIS),plnormal) - x1pln
            SVARI  = - PLANEEQ / DENOM

            ! Insertion sort, discard repeated intersections:
            NWCROSS = BODINT_CELL%NWCROSS(IWSEDG) + 1
            BODINT_CELL%SVAR(NWCROSS,IWSEDG) = 1._EB / GEOMEPS

            SAMEINT = .FALSE.
            DO IBCR=1,NWCROSS
               IF (ABS(SVARI - BODINT_CELL%SVAR(IBCR,IWSEDG)) < GEOMEPS) THEN
                  SAMEINT = .TRUE.
                  EXIT
               ENDIF
               IF ( SVARI  < BODINT_CELL%SVAR(IBCR,IWSEDG) ) EXIT
            ENDDO
            IF (SAMEINT) CYCLE

            ! Here copy from the back (updated nbcross) to the ibcr location:
            DO IDUM = NWCROSS,IBCR+1,-1
               BODINT_CELL%SVAR(IDUM,IWSEDG) = BODINT_CELL%SVAR(IDUM-1,IWSEDG)
            ENDDO
            BODINT_CELL%SVAR(IBCR,IWSEDG) =   SVARI
            BODINT_CELL%NWCROSS(IWSEDG)   = NWCROSS
         ENDDO
         DEALLOCATE(X1FACE,DX1FACE)
      ENDDO X1AXIS_LOOP2

      ! 3. The increasing svar intersections are used to define the INBOUNDCC type
      ! cut-edges and Cartesian Cells containing them. Add to CUT_EDGE, define the
      ! CUT_EDGE entry in CCVAR(i,j,k,IBM_IDCE):
      DO IEDGE=1,BODINT_CELL%NWCROSS(IWSEDG)-1

         ! Location along Segment:
         SVAR1 = BODINT_CELL%SVAR(IEDGE  ,IWSEDG)
         SVAR2 = BODINT_CELL%SVAR(IEDGE+1,IWSEDG)

         ! Location of midpoint of cut-edge:
         SVAR12 = 0.5_EB * (SVAR1+SVAR2)

         ! Define Cartesian cell this cut-edge belongs:
         XPOS = XYZ1(IAXIS) + SVAR12*STANI(IAXIS)
         II2  = FLOOR( (XPOS-XFACE(ILO_FACE))/DXFACE(ILO_FACE) ) + ILO_CELL
         XPOS = XYZ1(JAXIS) + SVAR12*STANI(JAXIS)
         JJ2  = FLOOR( (XPOS-YFACE(JLO_FACE))/DYFACE(JLO_FACE) ) + JLO_CELL
         XPOS = XYZ1(KAXIS) + SVAR12*STANI(KAXIS)
         KK2  = FLOOR( (XPOS-ZFACE(KLO_FACE))/DZFACE(KLO_FACE) ) + KLO_CELL

         ! Discard cut-edges on faces laying on x2hi and x3hi.
         IF ( (II2 < ILO_CELL-CCGUARD) .OR. (II2 > IHI_CELL+CCGUARD) ) CYCLE
         IF ( (JJ2 < JLO_CELL-CCGUARD) .OR. (JJ2 > JHI_CELL+CCGUARD) ) CYCLE
         IF ( (KK2 < KLO_CELL-CCGUARD) .OR. (KK2 > KHI_CELL+CCGUARD) ) CYCLE

         ! CCVAR edge number:
         IF ( MESHES(NM)%CCVAR(II2,JJ2,KK2,IBM_IDCE) > 0 ) THEN ! There is already
                                                                ! an entry in CUT_EDGE.
            CEI = MESHES(NM)%CCVAR(II2,JJ2,KK2,IBM_IDCE)
         ELSE ! We need a new entry in CUT_EDGE
            CEI = MESHES(NM)%N_CUTEDGE_MESH + 1
            MESHES(NM)%N_CUTEDGE_MESH           = CEI
            MESHES(NM)%CCVAR(II2,JJ2,KK2,IBM_IDCE) = CEI
            MESHES(NM)%CUT_EDGE(CEI)%NVERT  = 0
            CALL NEW_EDGE_ALLOC(NM,CEI,IBM_ALLOC_DVERT,IBM_ALLOC_DELEM)
            MESHES(NM)%CUT_EDGE(CEI)%NEDGE  = 0
            MESHES(NM)%CUT_EDGE(CEI)%IJK(1:MAX_DIM+2) = (/ II2, JJ2, KK2, 0, IBM_GS /)
            MESHES(NM)%CUT_EDGE(CEI)%STATUS = IBM_INBOUNDCC
         ENDIF

         ! Add vertices, non repeated vertex entries at this point.
         NVERT = MESHES(NM)%CUT_EDGE(CEI)%NVERT
         ! Define vertices for this segment:
         !               xv1                 yv1                 zv1
         XYZV1(IAXIS:KAXIS) = (/ XYZ1(IAXIS)+SVAR1*STANI(IAXIS), &
                                 XYZ1(JAXIS)+SVAR1*STANI(JAXIS), &
                                 XYZ1(KAXIS)+SVAR1*STANI(KAXIS) /)
         CALL INSERT_FACE_VERT(XYZV1,NM,CEI,NVERT,INOD1)
         !               xv2                 yv2                 zv2
         XYZV2(IAXIS:KAXIS) = (/ XYZ1(IAXIS)+SVAR2*STANI(IAXIS), &
                                 XYZ1(JAXIS)+SVAR2*STANI(JAXIS), &
                                 XYZ1(KAXIS)+SVAR2*STANI(KAXIS) /)
         CALL INSERT_FACE_VERT(XYZV2,NM,CEI,NVERT,INOD2)

         NEDGE = MESHES(NM)%CUT_EDGE(CEI)%NEDGE + 1
         CALL REALLOCATE_EDGE_ELEM(NM,CEI,NEDGE)
         MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,NEDGE) = (/ INOD1, INOD2 /)

         MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,NEDGE) = (/ INOD1, INOD2 /)
         MESHES(NM)%CUT_EDGE(CEI)%INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,NEDGE) = &
                                         (/ GEOMETRY(IG)%EDGE_FACES(1,IWSEDG), &
                                            GEOMETRY(IG)%EDGE_FACES(2,IWSEDG), &
                                            GEOMETRY(IG)%EDGE_FACES(4,IWSEDG), IG /)
         MESHES(NM)%CUT_EDGE(CEI)%NVERT = NVERT
         MESHES(NM)%CUT_EDGE(CEI)%NEDGE = NEDGE
      ENDDO

   ENDDO IWSEDG_LOOP

   ! Deallocate BODINT_CELL:
   DEALLOCATE(BODINT_CELL%NWCROSS,BODINT_CELL%SVAR)

ENDDO GEOM_LOOP

T_CC_USED(GET_CARTCELL_CUTEDGES_TIME_INDEX) = T_CC_USED(GET_CARTCELL_CUTEDGES_TIME_INDEX ) + CURRENT_TIME() - TNOW

RETURN
END SUBROUTINE GET_CARTCELL_CUTEDGES

! ---------------------- GET_CARTCELL_CUTFACES ----------------------------------

SUBROUTINE GET_CARTCELL_CUTFACES(NM,ISTR,IEND,JSTR,JEND,KSTR,KEND,BNDINT_FLAG)

USE COMP_FUNCTIONS, ONLY: CURRENT_TIME

INTEGER, INTENT(IN) :: NM
INTEGER, INTENT(IN) :: ISTR, IEND, JSTR, JEND, KSTR, KEND
LOGICAL, INTENT(IN) :: BNDINT_FLAG

 ! Local Variables:
INTEGER :: ILO,IHI,JLO,JHI,KLO,KHI
INTEGER :: I,J,K, JJ, KK
INTEGER, DIMENSION(LOW_IND:HIGH_IND,IAXIS:KAXIS) :: FSID_XYZ, CEIB_XYZ
LOGICAL :: OUTCELL1, OUTCELL2
INTEGER :: X1AXIS, X2AXIS, X3AXIS
INTEGER :: XIAXIS, XJAXIS, XKAXIS
INTEGER :: X2LO, X2HI, X3LO, X3HI
INTEGER :: X2LO_CELL, X2HI_CELL, X3LO_CELL, X3HI_CELL
REAL(EB), DIMENSION(MAX_DIM) :: PLNORMAL
INTEGER,  DIMENSION(MAX_DIM) :: IJK
REAL(EB) :: X1PLN
REAL(EB) :: DX2_MIN, DX3_MIN
LOGICAL  :: TRI_ONPLANE_ONLY
INTEGER  :: NVERT, NEDGE, NFACE, NSEG, NCF, FNVERT, FNEDGE, CEI, NSEG_FACE
REAL(EB) :: FVERT(IAXIS:JAXIS,NOD1:NOD4)
LOGICAL  :: INB_FLG
INTEGER  :: CEELEM(NOD1:NOD2,1:IBM_MAXCEELEM_FACE)
INTEGER  :: INDSEG(IBM_MAX_WSTRIANG_SEG+2,IBM_MAXCEELEM_FACE)
REAL(EB) :: XYVERT(IAXIS:JAXIS,1:IBM_MAXVERTS_FACE)
INTEGER  :: TRIS(NOD1:NOD3), ITRI
REAL(EB) :: XYEL(IAXIS:JAXIS,NOD1:NOD3), VAL, DUMMY(IAXIS:JAXIS)
REAL(EB) :: A_COEF, B_COEF, C_COEF, D_COEF, DENOM
INTEGER  :: INDXI(IAXIS:KAXIS), INDIF, INDJF, INDKF
REAL(EB), DIMENSION(IAXIS:KAXIS,1:IBM_MAXVERTS_FACE) :: XYZVERT, XYZVERTF
INTEGER,  DIMENSION(1:NOD2+IBM_MAX_WSTRIANG_SEG+2,1:IBM_MAXCEELEM_CELL) :: SEG_CELL
INTEGER,  DIMENSION(NOD1:NOD2,1:IBM_MAXCEELEM_FACE) :: SEG_FACE, SEG_FACE2
INTEGER,  DIMENSION(1:2,1:IBM_MAXCFELEM_FACE) ::  BOD_TRI
LOGICAL  :: SEG_FLAG(1:IBM_MAXCEELEM_FACE), INLIST, EQUAL1, EQUAL2, RH_ORIENTED
INTEGER  :: COUNTR, CTR, CTSTART, FAXIS, ILH, IEDGE, SEG(NOD1:NOD2), STRI(1:IBM_MAX_WSTRIANG_SEG+2), ISEG
INTEGER  :: INOD1, INOD2, VEC(1:NOD2+IBM_MAX_WSTRIANG_SEG+2), IDUM, IEQ1, IEQ2, NBODTRI
REAL(EB), DIMENSION(IAXIS:KAXIS) :: XYZ, NORMTRI, XCENI, XCEN, X1, X2, XC1, XC2, X12, VC1, V12, CROSSV
INTEGER, PARAMETER :: INDVERTBOD(1:3)  = (/ 1, 2, 6 /)
INTEGER, PARAMETER :: INDVERTBOD2(1:3) = (/ 2, 1, 6 /)
INTEGER  :: NCUTFACE, ICF, NSEG_LEFT, ISEG_FACE, IBOD, NP, IX, IBODTRI
REAL(EB) :: AREAI, AREA, INXAREA, INT2
REAL(EB), DIMENSION(IAXIS:KAXIS) :: ACEN, SQAREA

LOGICAL, ALLOCATABLE, SAVE, DIMENSION(:,:,:) :: IJK_COUNTED

INTEGER :: NVERT_AUX, NEDGE_OLD, IVERT, COUNT, IEOLD, INOD
LOGICAL :: FOUND
REAL(EB):: XYZV(IAXIS:KAXIS)

REAL(EB) :: TNOW

TNOW=CURRENT_TIME()

! Define which cells are cut-cell, and which are solid:
IF (BNDINT_FLAG) THEN
   ALLOCATE( IJK_COUNTED(ISTR:IEND,JSTR:JEND,KSTR:KEND) ); IJK_COUNTED=.FALSE.
   ILO = ILO_CELL; IHI = IHI_CELL
   JLO = JLO_CELL; JHI = JHI_CELL
   KLO = KLO_CELL; KHI = KHI_CELL
ELSE
   ILO = ILO_CELL-CCGUARD; IHI = IHI_CELL+CCGUARD
   JLO = JLO_CELL-CCGUARD; JHI = JHI_CELL+CCGUARD
   KLO = KLO_CELL-CCGUARD; KHI = KHI_CELL+CCGUARD
ENDIF

! Loop on Cartesian cells, define cut cells and solid cells ISSO:
DO K=KLO,KHI
   DO J=JLO,JHI
      DO I=ILO,IHI

         IF(IJK_COUNTED(I,J,K)) CYCLE

         ! Face type of bounding Cartesian faces:
         FSID_XYZ(LOW_IND ,IAXIS) = MESHES(NM)%FCVAR(I-FCELL  ,J,K,IBM_FGSC,IAXIS)
         FSID_XYZ(HIGH_IND,IAXIS) = MESHES(NM)%FCVAR(I-FCELL+1,J,K,IBM_FGSC,IAXIS)
         FSID_XYZ(LOW_IND ,JAXIS) = MESHES(NM)%FCVAR(I,J-FCELL  ,K,IBM_FGSC,JAXIS)
         FSID_XYZ(HIGH_IND,JAXIS) = MESHES(NM)%FCVAR(I,J-FCELL+1,K,IBM_FGSC,JAXIS)
         FSID_XYZ(LOW_IND ,KAXIS) = MESHES(NM)%FCVAR(I,J,K-FCELL  ,IBM_FGSC,KAXIS)
         FSID_XYZ(HIGH_IND,KAXIS) = MESHES(NM)%FCVAR(I,J,K-FCELL+1,IBM_FGSC,KAXIS)

         ! For this cell check if no Cartesian boundary faces are IBM_CUTCFE:
         ! If outcell1 is true -> All regular faces for this face:
         OUTCELL1 = (FSID_XYZ(LOW_IND ,IAXIS) /= IBM_CUTCFE) .AND. &
                    (FSID_XYZ(HIGH_IND,IAXIS) /= IBM_CUTCFE) .AND. &
                    (FSID_XYZ(LOW_IND ,JAXIS) /= IBM_CUTCFE) .AND. &
                    (FSID_XYZ(HIGH_IND,JAXIS) /= IBM_CUTCFE) .AND. &
                    (FSID_XYZ(LOW_IND ,KAXIS) /= IBM_CUTCFE) .AND. &
                    (FSID_XYZ(HIGH_IND,KAXIS) /= IBM_CUTCFE)

         ! Test for cell with INB edges:
         ! If outcell2 is true -> no INB Edges associated with this cell:
         OUTCELL2 = (MESHES(NM)%CCVAR(I,J,K,IBM_IDCE) <= 0)

         ! Drop if outcell1 & outcell2
         IF (OUTCELL1 .AND. OUTCELL2) THEN
            IF ( (FSID_XYZ(LOW_IND ,IAXIS) == IBM_SOLID) .AND. &
                 (FSID_XYZ(HIGH_IND,IAXIS) == IBM_SOLID) .AND. &
                 (FSID_XYZ(LOW_IND ,JAXIS) == IBM_SOLID) .AND. &
                 (FSID_XYZ(HIGH_IND,JAXIS) == IBM_SOLID) .AND. &
                 (FSID_XYZ(LOW_IND ,KAXIS) == IBM_SOLID) .AND. &
                 (FSID_XYZ(HIGH_IND,KAXIS) == IBM_SOLID) ) THEN
               MESHES(NM)%CCVAR(I,J,K,IBM_CGSC) = IBM_SOLID
            ENDIF
            CYCLE
         ENDIF

         MESHES(NM)%CCVAR(I,J,K,IBM_CGSC) = IBM_CUTCFE

      ENDDO
   ENDDO
ENDDO


! First add edges stemming from triangles laying on gridline planes:
! Dump triangle aligned segments as cut-cell cut-edges, on face cases:
! BNDINT_COND : IF (BNDINT_FLAG) THEN
   ! Do Loop for different x1 planes:
   X1AXIS_LOOP : DO X1AXIS=IAXIS,KAXIS

      SELECT CASE(X1AXIS)
       CASE(IAXIS)

          PLNORMAL = (/ 1._EB, 0._EB, 0._EB/)
          ILO = ILO_FACE-CCGUARD;  IHI = IHI_FACE+CCGUARD
          JLO = JLO_FACE;  JHI = JLO_FACE
          KLO = KLO_FACE;  KHI = KLO_FACE

          ! x2, x3 axes parameters:
          X2AXIS = JAXIS; X2LO = JLO_FACE-CCGUARD; X2HI = JHI_FACE+CCGUARD
          X3AXIS = KAXIS; X3LO = KLO_FACE-CCGUARD; X3HI = KHI_FACE+CCGUARD

          ! location in I,J,K of x2,x2,x3 axes:
          XIAXIS = IAXIS; XJAXIS = JAXIS; XKAXIS = KAXIS

          ! Face coordinates in x1,x2,x3 axes:
          ALLOCATE(X1FACE(ISTR:IEND),DX1FACE(ISTR:IEND))
          X1FACE = XFACE; DX1FACE = DXFACE
          ALLOCATE(X2FACE(JSTR:JEND),DX2FACE(JSTR:JEND))
          X2FACE = YFACE; DX2FACE = DYFACE
          ALLOCATE(X3FACE(KSTR:KEND),DX3FACE(KSTR:KEND))
          X3FACE = ZFACE; DX3FACE = DZFACE

          ! x2 cell center parameters:
          X2LO_CELL = JLO_CELL-CCGUARD; X2HI_CELL = JHI_CELL+CCGUARD
          ALLOCATE(X2CELL(JSTR:JEND),DX2CELL(JSTR:JEND))
          X2CELL = YCELL; DX2CELL = DYCELL

          ! x3 cell center parameters:
          X3LO_CELL = KLO_CELL-CCGUARD; X3HI_CELL = KHI_CELL+CCGUARD
          ALLOCATE(X3CELL(KSTR:KEND),DX3CELL(KSTR:KEND))
          X3CELL = ZCELL; DX3CELL = DZCELL

       CASE(JAXIS)

          PLNORMAL = (/ 0._EB, 1._EB, 0._EB/)
          ILO = ILO_FACE;  IHI = ILO_FACE
          JLO = JLO_FACE-CCGUARD;  JHI = JHI_FACE+CCGUARD
          KLO = KLO_FACE;  KHI = KLO_FACE

          ! x2, x3 axes parameters:
          X2AXIS = KAXIS; X2LO = KLO_FACE-CCGUARD; X2HI = KHI_FACE+CCGUARD
          X3AXIS = IAXIS; X3LO = ILO_FACE-CCGUARD; X3HI = IHI_FACE+CCGUARD

          ! location in I,J,K of x2,x2,x3 axes:
          XIAXIS = KAXIS; XJAXIS = IAXIS; XKAXIS = JAXIS

          ! Face coordinates in x1,x2,x3 axes:
          ALLOCATE(X1FACE(JSTR:JEND),DX1FACE(JSTR:JEND))
          X1FACE = YFACE; DX1FACE = DYFACE
          ALLOCATE(X2FACE(KSTR:KEND),DX2FACE(KSTR:KEND))
          X2FACE = ZFACE; DX2FACE = DZFACE
          ALLOCATE(X3FACE(ISTR:IEND),DX3FACE(ISTR:IEND))
          X3FACE = XFACE; DX3FACE = DXFACE

          ! x2 cell center parameters:
          X2LO_CELL = KLO_CELL-CCGUARD; X2HI_CELL = KHI_CELL+CCGUARD
          ALLOCATE(X2CELL(KSTR:KEND),DX2CELL(KSTR:KEND))
          X2CELL = ZCELL; DX2CELL = DZCELL

          ! x3 cell center parameters:
          X3LO_CELL = ILO_CELL-CCGUARD; X3HI_CELL = IHI_CELL+CCGUARD
          ALLOCATE(X3CELL(ISTR:IEND),DX3CELL(ISTR:IEND))
          X3CELL = XCELL; DX3CELL = DXCELL

       CASE(KAXIS)

          PLNORMAL = (/ 0._EB, 0._EB, 1._EB/)
          ILO = ILO_FACE;  IHI = ILO_FACE
          JLO = JLO_FACE;  JHI = JLO_FACE
          KLO = KLO_FACE-CCGUARD;  KHI = KHI_FACE+CCGUARD

          ! x2, x3 axes parameters:
          X2AXIS = IAXIS; X2LO = ILO_FACE-CCGUARD; X2HI = IHI_FACE+CCGUARD
          X3AXIS = JAXIS; X3LO = JLO_FACE-CCGUARD; X3HI = JHI_FACE+CCGUARD

          ! location in I,J,K of x2,x2,x3 axes:
          XIAXIS = JAXIS; XJAXIS = KAXIS; XKAXIS = IAXIS

          ! Face coordinates in x1,x2,x3 axes:
          ALLOCATE(X1FACE(KSTR:KEND),DX1FACE(KSTR:KEND))
          X1FACE = ZFACE; DX1FACE = DZFACE
          ALLOCATE(X2FACE(ISTR:IEND),DX2FACE(ISTR:IEND))
          X2FACE = XFACE; DX2FACE = DXFACE
          ALLOCATE(X3FACE(JSTR:JEND),DX3FACE(JSTR:JEND))
          X3FACE = YFACE; DX3FACE = DYFACE

          ! x2 cell center parameters:
          X2LO_CELL = ILO_CELL-CCGUARD; X2HI_CELL = IHI_CELL+CCGUARD
          ALLOCATE(X2CELL(ISTR:IEND),DX2CELL(ISTR:IEND))
          X2CELL = XCELL; DX2CELL = DXCELL

          ! x3 cell center parameters:
          X3LO_CELL = JLO_CELL-CCGUARD; X3HI_CELL = JHI_CELL+CCGUARD
          ALLOCATE(X3CELL(JSTR:JEND),DX3CELL(JSTR:JEND))
          X3CELL = YCELL; DX3CELL = DYCELL

      END SELECT

      ! Loop Slices:
      DO K=KLO,KHI
         DO J=JLO,JHI
            DO I=ILO,IHI

               IJK(IAXIS:KAXIS) = (/ I, J, K /)

               ! Plane:
               X1PLN = X1FACE(IJK(X1AXIS))

               ! Get intersection of body on plane defined by X1PLN, normal to X1AXIS:
               DX2_MIN = MINVAL(DX2CELL(X2LO_CELL:X2HI_CELL))
               DX3_MIN = MINVAL(DX3CELL(X3LO_CELL:X3HI_CELL))
               TRI_ONPLANE_ONLY = .TRUE.
               CALL GET_BODINT_PLANE(X1AXIS,X1PLN,PLNORMAL,X2AXIS,X3AXIS,DX2_MIN,DX3_MIN,TRI_ONPLANE_ONLY)

               ! Test that there is an intersection:
               IF ((BODINT_PLANE%NTRIS) == 0) CYCLE

               ! Drop if node locations outside block plane area:
               IF ((X2FACE(X2LO)-MAXVAL(BODINT_PLANE%XYZ(X2AXIS,1:BODINT_PLANE%NNODS))) > GEOMEPS) CYCLE
               IF ((MINVAL(BODINT_PLANE%XYZ(X2AXIS,1:BODINT_PLANE%NNODS))-X2FACE(X2HI)) > GEOMEPS) CYCLE
               IF ((X3FACE(X3LO)-MAXVAL(BODINT_PLANE%XYZ(X3AXIS,1:BODINT_PLANE%NNODS))) > GEOMEPS) CYCLE
               IF ((MINVAL(BODINT_PLANE%XYZ(X3AXIS,1:BODINT_PLANE%NNODS))-X3FACE(X3HI)) > GEOMEPS) CYCLE

               ! Allocate triangles variables:
               ALLOCATE(BODINT_PLANE%X1NVEC(1:BODINT_PLANE%NTRIS),     &
                        BODINT_PLANE%AINV(1:2,1:2,1:BODINT_PLANE%NTRIS))

               ! Triangles inverses:
               DO ITRI=1,BODINT_PLANE%NTRIS

                  TRIS(NOD1:NOD3) = BODINT_PLANE%TRIS(NOD1:NOD3,ITRI)

                  ! This is local IAXIS:JAXIS
                  XYEL(IAXIS:JAXIS,NOD1) = (/ BODINT_PLANE%XYZ(X2AXIS,TRIS(NOD1)), &
                                              BODINT_PLANE%XYZ(X3AXIS,TRIS(NOD1))  /)
                  XYEL(IAXIS:JAXIS,NOD2) = (/ BODINT_PLANE%XYZ(X2AXIS,TRIS(NOD2)), &
                                              BODINT_PLANE%XYZ(X3AXIS,TRIS(NOD2))  /)
                  XYEL(IAXIS:JAXIS,NOD3) = (/ BODINT_PLANE%XYZ(X2AXIS,TRIS(NOD3)), &
                                              BODINT_PLANE%XYZ(X3AXIS,TRIS(NOD3))  /)

                  ! Test that x1-x2-x3 obeys right hand rule:
                  VAL = (XYEL(IAXIS,NOD2)-XYEL(IAXIS,NOD1)) * (XYEL(JAXIS,NOD3)-XYEL(JAXIS,NOD1))- &
                        (XYEL(JAXIS,NOD2)-XYEL(JAXIS,NOD1)) * (XYEL(IAXIS,NOD3)-XYEL(IAXIS,NOD1))
                  BODINT_PLANE%X1NVEC(ITRI) = SIGN(1._EB,VAL)

                  ! Transformation Matrix for this triangle in x2x3 plane:
                  IF (BODINT_PLANE%X1NVEC(ITRI) < 0._EB) THEN ! Rotate node 2 and 3 locations
                     DUMMY(IAXIS:JAXIS)     = XYEL(IAXIS:JAXIS,NOD2)
                     XYEL(IAXIS:JAXIS,NOD2) = XYEL(IAXIS:JAXIS,NOD3)
                     XYEL(IAXIS:JAXIS,NOD3) = DUMMY(IAXIS:JAXIS)
                  ENDIF

                  ! Inverse of Master to physical triangle transform matrix:
                  A_COEF = XYEL(IAXIS,NOD1) - XYEL(IAXIS,NOD3)
                  B_COEF = XYEL(IAXIS,NOD2) - XYEL(IAXIS,NOD3)
                  C_COEF = XYEL(JAXIS,NOD1) - XYEL(JAXIS,NOD3)
                  D_COEF = XYEL(JAXIS,NOD2) - XYEL(JAXIS,NOD3)
                  DENOM  = A_COEF * D_COEF - B_COEF * C_COEF
                  BODINT_PLANE%AINV(1,1,ITRI) =  D_COEF / DENOM
                  BODINT_PLANE%AINV(2,1,ITRI) = -C_COEF / DENOM
                  BODINT_PLANE%AINV(1,2,ITRI) = -B_COEF / DENOM
                  BODINT_PLANE%AINV(2,2,ITRI) =  A_COEF / DENOM

               ENDDO

               ! There are triangles aligned with this x1pln:
               ! Run by Face:
               ! First solid Faces: x1 Faces, Check where they lay:
               DO KK=X3LO_CELL,X3HI_CELL
                  DO JJ=X2LO_CELL,X2HI_CELL

                     ! Face indexes:
                     INDXI(IAXIS:KAXIS) = (/ IJK(X1AXIS), JJ, KK /) ! Local x1,x2,x3
                     INDIF = INDXI(XIAXIS)
                     INDJF = INDXI(XJAXIS)
                     INDKF = INDXI(XKAXIS)

                     IF (MESHES(NM)%FCVAR(INDIF,INDJF,INDKF,IBM_FGSC,X1AXIS) /= IBM_GASPHASE ) THEN

                        FVERT(IAXIS:JAXIS,NOD1) = (/ X2FACE(JJ-FCELL  ), X3FACE(KK-FCELL  ) /)
                        FVERT(IAXIS:JAXIS,NOD2) = (/ X2FACE(JJ-FCELL+1), X3FACE(KK-FCELL  ) /)
                        FVERT(IAXIS:JAXIS,NOD3) = (/ X2FACE(JJ-FCELL+1), X3FACE(KK-FCELL+1) /)
                        FVERT(IAXIS:JAXIS,NOD4) = (/ X2FACE(JJ-FCELL  ), X3FACE(KK-FCELL+1) /)

                        ! Get triangle face intersection:
                        CEI = MESHES(NM)%FCVAR(INDIF,INDJF,INDKF,IBM_IDCE,X1AXIS)

                        ! Triangle - face intersection vertices and edges:
                        CALL GET_TRIANG_FACE_INT(X2AXIS,X3AXIS,FVERT,CEI,NM, &
                                                 INB_FLG,FNVERT,XYVERT,FNEDGE,CEELEM,INDSEG)

                        ! XYvert to XYZvert:
                        IF ( INB_FLG ) THEN
                           XYZVERTF = 0._EB
                           XYZVERTF(X1AXIS,1:FNVERT) = X1PLN
                           XYZVERTF(X2AXIS,1:FNVERT) = XYVERT(IAXIS,1:FNVERT)
                           XYZVERTF(X3AXIS,1:FNVERT) = XYVERT(JAXIS,1:FNVERT)

                           ! Here ADD nodes and vertices to what is already
                           ! there:
                           IF (CEI == 0) THEN ! We need a new entry in CUT_EDGE
                              CEI      = MESHES(NM)%N_CUTEDGE_MESH + 1
                              MESHES(NM)%N_CUTEDGE_MESH = CEI
                              MESHES(NM)%FCVAR(INDIF,INDJF,INDKF,IBM_IDCE,X1AXIS) = CEI
                              MESHES(NM)%CUT_EDGE(CEI)%NVERT  = FNVERT
                              MESHES(NM)%CUT_EDGE(CEI)%NEDGE  = FNEDGE
                              CALL NEW_EDGE_ALLOC(NM,CEI,FNVERT,FNEDGE)
                              MESHES(NM)%CUT_EDGE(CEI)%IJK(1:MAX_DIM+2) = &
                                                   (/ INDIF, INDJF, INDKF, X1AXIS, IBM_GS /)
                              MESHES(NM)%CUT_EDGE(CEI)%STATUS = IBM_INBOUNDCF
                              MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,1:FNVERT) = &
                                                           XYZVERTF(IAXIS:KAXIS,1:FNVERT)
                              MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,1:FNEDGE)    = &
                                                           CEELEM(NOD1:NOD2,1:FNEDGE)
                              MESHES(NM)%CUT_EDGE(CEI)%INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,1:FNEDGE) = &
                                                           INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,1:FNEDGE)
                           ELSE

                              NVERT_AUX=MESHES(NM)%CUT_EDGE(CEI)%NVERT
                              NEDGE_OLD=MESHES(NM)%CUT_EDGE(CEI)%NEDGE
                              DO IVERT=1,FNVERT
                                 XYZV(IAXIS:KAXIS) = XYZVERTF(IAXIS:KAXIS,IVERT)
                                 CALL INSERT_FACE_VERT(XYZV,NM,CEI,NVERT_AUX,INOD)
                                 DO IEDGE=1,FNEDGE
                                    IF(CEELEM(NOD1,IEDGE)==IVERT) CEELEM(NOD1,IEDGE)=INOD
                                    IF(CEELEM(NOD2,IEDGE)==IVERT) CEELEM(NOD2,IEDGE)=INOD
                                 ENDDO
                              ENDDO
                              CALL REALLOCATE_EDGE_ELEM(NM,CEI,NEDGE_OLD+FNEDGE)
                              COUNT = NEDGE_OLD
                              OUTER :DO IEDGE=1,FNEDGE
                                 FOUND=.FALSE.
                                 INNER1 : DO IEOLD=1,NEDGE_OLD
                                 IF(MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1,IEOLD) /= CEELEM(NOD1,IEDGE)) CYCLE INNER1
                                 IF(MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD2,IEOLD) /= CEELEM(NOD2,IEDGE)) CYCLE INNER1
                                 FOUND=.TRUE.
                                 ENDDO INNER1
                                 INNER2 : DO IEOLD=1,NEDGE_OLD
                                 IF(MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD2,IEOLD) /= CEELEM(NOD1,IEDGE)) CYCLE INNER2
                                 IF(MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1,IEOLD) /= CEELEM(NOD2,IEDGE)) CYCLE INNER2
                                 FOUND=.TRUE.
                                 ENDDO INNER2
                                 IF(FOUND) CYCLE OUTER
                                 COUNT=COUNT+1
                                 MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,COUNT) = CEELEM(NOD1:NOD2,IEDGE)
                                 MESHES(NM)%CUT_EDGE(CEI)%INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,COUNT)=&
                                                              INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,IEDGE)
                              ENDDO OUTER
                              MESHES(NM)%CUT_EDGE(CEI)%NVERT = NVERT_AUX
                              MESHES(NM)%CUT_EDGE(CEI)%NEDGE = COUNT

                           ENDIF

                           ! MESHES(NM)%CUT_EDGE(CEI)%NVERT  =    FNVERT
                           ! MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,1:FNVERT) = &
                           !                              XYZVERTF(IAXIS:KAXIS,1:FNVERT)
                           ! MESHES(NM)%CUT_EDGE(CEI)%NEDGE  =    FNEDGE
                           ! WRITE(LU_ERR,*) 'CUT_EDGE=',CEI,SIZE(MESHES(NM)%CUT_EDGE(CEI)%CEELEM,DIM=2),FNEDGE
                           ! WRITE(LU_ERR,*) 'CEELEM=',SIZE(CEELEM,DIM=2)
                           ! MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,1:FNEDGE)    = &
                           !                              CEELEM(NOD1,IEDGE)) CYCLE:NOD2,1:FNEDGE)
                           ! MESHES(NM)%CUT_EDGE(CEI)%INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,1:FNEDGE) = &
                           !                              INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,1:FNEDGE)

                        ENDIF

                     ENDIF
                  ENDDO
               ENDDO

               DEALLOCATE(BODINT_PLANE%X1NVEC,BODINT_PLANE%AINV)
            ENDDO ! I
         ENDDO ! J
      ENDDO ! K

      ! Deallocate local plane arrays:
      DEALLOCATE(X1FACE,X2FACE,X3FACE,X2CELL,X3CELL)
      DEALLOCATE(DX1FACE,DX2FACE,DX3FACE,DX2CELL,DX3CELL)

   ENDDO X1AXIS_LOOP
! ENDIF BNDINT_COND

! Second: Loop over cut-cells: For cut-cell i,j,k,lb
! - From cut-cell Cartesian faces, figure out INBOUNDCF segments (CUT_EDGE)
! and the wet surface triangles related to them.
! - From CCVAR(I,J,K,IBM_IDCE), firgure out INBOUNDCC segments in CUT_EDGE
! and triangles they belong to.
! - Working by triangle -> reorient segments using triangle normal outside
! of body (no disjoint areas are expected)
! - Load into CUT_FACE <=> CCVAR(I,J,K,IBM_IDCF).
IF (BNDINT_FLAG) THEN
   ILO = ILO_CELL; IHI = IHI_CELL
   JLO = JLO_CELL; JHI = JHI_CELL
   KLO = KLO_CELL; KHI = KHI_CELL
ELSE
   ILO = ILO_CELL-CCGUARD; IHI = IHI_CELL+CCGUARD
   JLO = JLO_CELL-CCGUARD; JHI = JHI_CELL+CCGUARD
   KLO = KLO_CELL-CCGUARD; KHI = KHI_CELL+CCGUARD
ENDIF
! Loop on Cartesian cells, define cut cells and solid cells IBM_CGSC:
DO K=KLO,KHI
   DO J=JLO,JHI
      DO I=ILO,IHI

         IF ( MESHES(NM)%CCVAR(I,J,K,IBM_CGSC) /= IBM_CUTCFE ) CYCLE

         IF(IJK_COUNTED(I,J,K)) CYCLE; IJK_COUNTED(I,J,K)=.TRUE.

         ! Face type of bounding Cartesian faces:
         FSID_XYZ(LOW_IND ,IAXIS) = MESHES(NM)%FCVAR(I-FCELL  ,J,K,IBM_FGSC,IAXIS)
         FSID_XYZ(HIGH_IND,IAXIS) = MESHES(NM)%FCVAR(I-FCELL+1,J,K,IBM_FGSC,IAXIS)
         FSID_XYZ(LOW_IND ,JAXIS) = MESHES(NM)%FCVAR(I,J-FCELL  ,K,IBM_FGSC,JAXIS)
         FSID_XYZ(HIGH_IND,JAXIS) = MESHES(NM)%FCVAR(I,J-FCELL+1,K,IBM_FGSC,JAXIS)
         FSID_XYZ(LOW_IND ,KAXIS) = MESHES(NM)%FCVAR(I,J,K-FCELL  ,IBM_FGSC,KAXIS)
         FSID_XYZ(HIGH_IND,KAXIS) = MESHES(NM)%FCVAR(I,J,K-FCELL+1,IBM_FGSC,KAXIS)

         ! Start cut-cell INB cut-faces computation:
         ! Loop local arrays to cell:
         NSEG      = 0
         SEG_CELL  = IBM_UNDEFINED

         NVERT     = 0
         NFACE     = 0
         XYZVERT   = 0._EB

         ! CUT_EDGE index of bounding Cartesian faces:
         CEIB_XYZ(LOW_IND ,IAXIS) = MESHES(NM)%FCVAR(I-FCELL  ,J,K,IBM_IDCE,IAXIS)
         CEIB_XYZ(HIGH_IND,IAXIS) = MESHES(NM)%FCVAR(I-FCELL+1,J,K,IBM_IDCE,IAXIS)
         CEIB_XYZ(LOW_IND ,JAXIS) = MESHES(NM)%FCVAR(I,J-FCELL  ,K,IBM_IDCE,JAXIS)
         CEIB_XYZ(HIGH_IND,JAXIS) = MESHES(NM)%FCVAR(I,J-FCELL+1,K,IBM_IDCE,JAXIS)
         CEIB_XYZ(LOW_IND ,KAXIS) = MESHES(NM)%FCVAR(I,J,K-FCELL  ,IBM_IDCE,KAXIS)
         CEIB_XYZ(HIGH_IND,KAXIS) = MESHES(NM)%FCVAR(I,J,K-FCELL+1,IBM_IDCE,KAXIS)

         ! Cartesian Faces INBOUNDARY segments:
         DO FAXIS=IAXIS,KAXIS
            DO ILH=LOW_IND,HIGH_IND
               ! By segment: Add Vertices/Segments to local arrays:
               CEI = CEIB_XYZ(ILH,FAXIS)
               IF ( CEI > 0 ) THEN ! There are inboundary cut-edges
                  NEDGE = MESHES(NM)%CUT_EDGE(CEI)%NEDGE
                  DO IEDGE=1,NEDGE

                     SEG(NOD1:NOD2) = MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,IEDGE)
                     STRI(1:IBM_MAX_WSTRIANG_SEG+2) = &
                     MESHES(NM)%CUT_EDGE(CEI)%INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,IEDGE)

                     ! x,y,z of node 1:
                     XYZ(IAXIS:KAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,SEG(NOD1))
                     CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZ,NVERT,INOD1,XYZVERT)
                     ! x,y,z of node 2:
                     XYZ(IAXIS:KAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,SEG(NOD2))
                     CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZ,NVERT,INOD2,XYZVERT)

                     VEC(NOD1:NOD2) = (/ INOD1, INOD2 /)
                     VEC(NOD2+1:NOD2+IBM_MAX_WSTRIANG_SEG+2) = STRI(1:IBM_MAX_WSTRIANG_SEG+2)
                     ! Insertion ADD segment:
                     INLIST = .FALSE.
                     DO IDUM = 1,NSEG
                        DO IEQ1=1,3
                           EQUAL1 = SEG_CELL(INDVERTBOD(IEQ1),IDUM) == VEC(INDVERTBOD(IEQ1))
                           IF (.NOT.EQUAL1) EXIT
                        ENDDO
                        DO IEQ2=1,3
                           EQUAL2 = SEG_CELL(INDVERTBOD(IEQ2),IDUM) == VEC(INDVERTBOD2(IEQ2))
                           IF (.NOT.EQUAL2) EXIT
                        ENDDO
                        IF ( EQUAL1 .OR. EQUAL2 ) THEN
                           IF ( SEG_CELL(3,IDUM) > VEC(3) ) THEN
                              ! DO NOTHING:
                           ELSEIF (SEG_CELL(3,IDUM) < VEC(3)) THEN
                              SEG_CELL(1:NOD2+IBM_MAX_WSTRIANG_SEG+2,IDUM) = VEC(1:NOD2+IBM_MAX_WSTRIANG_SEG+2)
                           ELSEIF (SEG_CELL(4,IDUM) /= VEC(4)) THEN
                              SEG_CELL(3,IDUM) = SEG_CELL(3,IDUM) + 1
                              SEG_CELL(5,IDUM) = VEC(4)
                           ENDIF
                           INLIST = .TRUE.
                           EXIT
                        ENDIF
                     ENDDO
                     IF (.NOT.INLIST) THEN
                         NSEG = NSEG + 1
                         SEG_CELL(1:NOD2+IBM_MAX_WSTRIANG_SEG+2,NSEG) = VEC(1:NOD2+IBM_MAX_WSTRIANG_SEG+2)
                     ENDIF
                  ENDDO
               ENDIF
            ENDDO
         ENDDO

         ! Cells INBOUNDARY segments:
         CEI = MESHES(NM)%CCVAR(I,J,K,IBM_IDCE)
         IF ( CEI > 0 ) THEN ! There are inboundary cut-edges
            NEDGE = MESHES(NM)%CUT_EDGE(CEI)%NEDGE
            DO IEDGE=1,NEDGE

               SEG(NOD1:NOD2) = MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,IEDGE)
               STRI(1:IBM_MAX_WSTRIANG_SEG+2) = &
               MESHES(NM)%CUT_EDGE(CEI)%INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,IEDGE)

               ! x,y,z of node 1:
               XYZ(IAXIS:KAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,SEG(NOD1))
               CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZ,NVERT,INOD1,XYZVERT)
               ! x,y,z of node 2:
               XYZ(IAXIS:KAXIS) = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(IAXIS:KAXIS,SEG(NOD2))
               CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_FACE,XYZ,NVERT,INOD2,XYZVERT)

               IF (INOD1 == INOD2) CYCLE

               VEC(NOD1:NOD2) = (/ INOD1, INOD2 /)
               VEC(NOD2+1:NOD2+IBM_MAX_WSTRIANG_SEG+2) = STRI(1:IBM_MAX_WSTRIANG_SEG+2)
               ! Insertion ADD segment:
               INLIST = .FALSE.
               DO IDUM = 1,NSEG
                  DO IEQ1=1,3
                     EQUAL1 = SEG_CELL(INDVERTBOD(IEQ1),IDUM) == VEC(INDVERTBOD(IEQ1))
                     IF (.NOT.EQUAL1) EXIT
                  ENDDO
                  IF ( EQUAL1 ) THEN
                     IF ( SEG_CELL(3,IDUM) > VEC(3) ) THEN
                        ! DO NOTHING:
                     ELSEIF (SEG_CELL(3,IDUM) < VEC(3)) THEN
                        SEG_CELL(1:NOD2+IBM_MAX_WSTRIANG_SEG+2,IDUM) = VEC(1:NOD2+IBM_MAX_WSTRIANG_SEG+2)
                     ELSEIF (SEG_CELL(4,IDUM) /= VEC(4)) THEN
                        SEG_CELL(3,IDUM) = SEG_CELL(3,IDUM) + 1
                        SEG_CELL(5,IDUM) = VEC(4)
                     ENDIF
                     INLIST = .TRUE.
                     EXIT
                  ENDIF
               ENDDO
               IF (.NOT.INLIST) THEN
                   NSEG = NSEG + 1
                   SEG_CELL(1:NOD2+IBM_MAX_WSTRIANG_SEG+2,NSEG) = VEC(1:NOD2+IBM_MAX_WSTRIANG_SEG+2)
               ENDIF
            ENDDO
         ENDIF

         ! Now obtain body-triangle combinations present:
         BOD_TRI = IBM_UNDEFINED
         NBODTRI = 0
         DO ISEG=1,NSEG

            ! First triangle location (Assume one body and at
            ! most two triangs per seg).
            INLIST = .FALSE.
            DO IBODTRI=1,NBODTRI
               IF ( (BOD_TRI(1,IBODTRI) == SEG_CELL(6,ISEG)) .AND. &
                    (BOD_TRI(2,IBODTRI) == SEG_CELL(4,ISEG)) ) THEN
                  ! Body/triang already on list.
                  INLIST = .TRUE.
                  CYCLE
               ENDIF
            enddo
            IF (.NOT.INLIST) THEN
               ! Add first triang to list:
               NBODTRI = NBODTRI + 1
               BOD_TRI(1:2,NBODTRI) = SEG_CELL( (/ 6, 4 /) , ISEG)
            ENDIF

            ! No second triangle associated:
            IF ( SEG_CELL(3,ISEG) < 2 ) CYCLE

            ! Second triangle location
            INLIST = .FALSE.
            DO IBODTRI=1,NBODTRI
               IF ( (BOD_TRI(1,IBODTRI) == SEG_CELL(6,ISEG)) .AND. &
                    (BOD_TRI(2,IBODTRI) == SEG_CELL(5,ISEG)) ) THEN
                  ! Body/triang already on list.
                  INLIST = .TRUE.
                  CYCLE
               ENDIF
            ENDDO
            IF (.NOT.INLIST) THEN
               ! Add first triang to list:
               NBODTRI = NBODTRI + 1
               BOD_TRI(1:2,NBODTRI) = SEG_CELL( (/ 6, 5 /) , ISEG)
            ENDIF
         ENDDO ! ISEG.

         ! This is a cut-face, allocate space:
         NCUTFACE = MESHES(NM)%N_CUTFACE_MESH + MESHES(NM)%N_GCCUTFACE_MESH + 1
         IF (BNDINT_FLAG) THEN
            MESHES(NM)%N_CUTFACE_MESH = NCUTFACE
         ELSE
            MESHES(NM)%N_GCCUTFACE_MESH = MESHES(NM)%N_GCCUTFACE_MESH + 1
         ENDIF
         MESHES(NM)%CCVAR(I,J,K,IBM_IDCF) = NCUTFACE
         MESHES(NM)%CUT_FACE(NCUTFACE)%NVERT  = NVERT
         MESHES(NM)%CUT_FACE(NCUTFACE)%NFACE  = 0
         MESHES(NM)%CUT_FACE(NCUTFACE)%IJK(1:MAX_DIM+1) = (/ I, J, K, 0 /) ! No axis = 0
         MESHES(NM)%CUT_FACE(NCUTFACE)%STATUS = IBM_INBOUNDARY
         CALL NEW_FACE_ALLOC(NM,NCUTFACE,NVERT,NBODTRI,IBM_MAXVERT_CUTFACE)
         MESHES(NM)%CUT_FACE(NCUTFACE)%XYZVERT(IAXIS:KAXIS,1:NVERT) = XYZVERT(IAXIS:KAXIS,1:NVERT)

         ! Running by body-triangle combination, define list of
         ! segments that belong to each pair.
         ICF_LOOP : DO ICF=1,NBODTRI

            IBOD = BOD_TRI(1,ICF)
            ITRI = BOD_TRI(2,ICF)

            SEG_FACE  = IBM_UNDEFINED
            NSEG_FACE = 0
            DO ISEG=1,NSEG
               IF ((SEG_CELL(6,ISEG) == IBOD) .AND. &
                  ((SEG_CELL(4,ISEG) == ITRI) .OR. (SEG_CELL(5,ISEG) == ITRI)) ) THEN
                  NSEG_FACE = NSEG_FACE + 1
                  SEG_FACE(NOD1:NOD2,NSEG_FACE) = SEG_CELL(NOD1:NOD2,ISEG)
               ENDIF
            ENDDO

            ! If only one or two seg => continue:
            IF ( NSEG_FACE <= 2 ) CYCLE

            ! Now build sequential list of segments:
            SEG_FACE2 = IBM_UNDEFINED !zeros(nseg_face,2); %[nod1 nod2]
            SEG_FLAG  = .TRUE.        !ones(1,nseg_face);
            ISEG_FACE = 1
            COUNTR    = 1
            CTSTART   = COUNTR
            SEG_FACE2(NOD1:NOD2,COUNTR) = SEG_FACE(NOD1:NOD2,ISEG_FACE)
            SEG_FLAG(ISEG_FACE) = .FALSE.
            NSEG_LEFT = NSEG_FACE - 1
            CTR = 0
            ! Infinite Loop:
            INF_LOOP : DO
               DO ISEG_FACE=1,NSEG_FACE

                  IF (SEG_FLAG(ISEG_FACE)) THEN ! This seg hasn't been added to seg_face2
                     ! Test for common node:
                     IF ( SEG_FACE2(NOD2,COUNTR) == SEG_FACE(NOD1,ISEG_FACE) ) THEN
                        COUNTR = COUNTR + 1
                        SEG_FACE2(NOD1:NOD2,COUNTR) = SEG_FACE(NOD1:NOD2,ISEG_FACE)
                        SEG_FLAG(ISEG_FACE) = .FALSE.
                        NSEG_LEFT = NSEG_LEFT - 1
                        EXIT
                     ELSEIF ( SEG_FACE2(NOD2,COUNTR) == SEG_FACE(NOD2,ISEG_FACE) ) THEN

                        IF ( SEG_FACE2(NOD1,COUNTR) == SEG_FACE(NOD1,ISEG_FACE) ) &
                        PRINT*, "Building INBOUND faces, repeated index."
                        COUNTR = COUNTR + 1
                        SEG_FACE2(NOD1:NOD2,COUNTR) = SEG_FACE( (/ NOD2, NOD1 /) ,ISEG_FACE)
                        SEG_FLAG(ISEG_FACE) = .FALSE.
                        NSEG_LEFT = NSEG_LEFT - 1
                        EXIT
                     ENDIF
                  endif
               enddo
               ! Break loop:
               IF ( NSEG_LEFT == 0 ) EXIT
               CTR = CTR + 1

               ! Plot cell and cut-faces if there is no convergence:
               IF ( CTR > NSEG_FACE**3 ) THEN
                      WRITE(LU_ERR,*) "Error GET_CARTCELL_CUTFACES: ctr > nseg_face^3 ,",BNDINT_FLAG,I,J,K,NCUTFACE,&
                      MESHES(NM)%CUT_FACE(NCUTFACE)%NFACE
#ifdef DEBUG_SET_CUTCELLS
                      WRITE(LU_ERR,*) 'Cartesian CELL:',BNDINT_FLAG,MESHES(NM)%CCVAR(I,J,K,IBM_CGSC),IBM_CUTCFE,I,J,K
                      OPEN(UNIT=33,FILE="./Cartcell_cutfaces.dat", STATUS='REPLACE')
                      ! Info pertaining to the Cartesian Cell:
                      WRITE(33,*) 'I,J,K:'
                      WRITE(33,*) I,J,K
                      WRITE(33,*) 'XC(I),DX(I),YC(J),DY(J),ZC(K),DZ(K):'
                      WRITE(33,*) MESHES(NM)%XC(I),MESHES(NM)%DX(I)
                      WRITE(33,*) MESHES(NM)%YC(J),MESHES(NM)%DY(J)
                      WRITE(33,*) MESHES(NM)%ZC(K),MESHES(NM)%DZ(K)
                      WRITE(33,*) 'NVERT,NSEG,NSEG_FACE,COUNTR,NSEG_LEFT:'
                      WRITE(33,*) NVERT,NSEG,NSEG_FACE,COUNTR,NSEG_LEFT
                      WRITE(33,*) 'XYZVERT(IAXIS:KAXIS,1:NVERT):'
                      DO IDUM=1,NVERT
                         WRITE(33,*) IDUM,XYZVERT(IAXIS:KAXIS,IDUM)
                      ENDDO
                      WRITE(33,*) 'SEG_CELL(NOD1:NOD2,1:NSEG),SEG_CELL(3:6,1:NSEG):'
                      DO IDUM=1,NSEG
                         WRITE(33,*) IDUM,SEG_CELL(NOD1:NOD2,IDUM),SEG_CELL(3:6,IDUM)
                      ENDDO
                      WRITE(33,*) 'SEG_FACE(NOD1:NOD2,1:NSEG_FACE):'
                      DO IDUM=1,NSEG_FACE
                         WRITE(33,*) IDUM,SEG_FACE(NOD1:NOD2,IDUM)
                      ENDDO
                      WRITE(33,*) 'SEG_FACE2(NOD1:NOD21:COUNTR):'
                      DO IDUM=1,COUNTR
                         WRITE(33,*) IDUM,SEG_FACE2(NOD1:NOD2,IDUM)
                      ENDDO
                      WRITE(33,*) 'ICF,BOD_TRI:'
                      WRITE(33,*) ICF,NBODTRI
                      DO IDUM=1,NBODTRI
                         WRITE(33,*) BOD_TRI(1:2,IDUM)
                      ENDDO
                      CLOSE(33)
                      PAUSE
#endif
               ENDIF

            enddo INF_LOOP
            IF ( COUNTR /= NSEG_FACE) &
                    PRINT*, "Building INBOUND faces: ~isequal(countr,nseg)"

            ! Using triangles normal, reorder nodes as in right hand rule.
            NORMTRI(IAXIS:KAXIS) = GEOMETRY(IBOD)%FACES_NORMAL(IAXIS:KAXIS,ITRI)

            ! First test if INB face is on Cartesian face and pointing
            ! outside of Cartesian cell. If so drop:
            XYZ(IAXIS:KAXIS) = XYZVERT(IAXIS:KAXIS,SEG_FACE2(1,1))
            ! IAXIS:
            IF ( (ABS(NORMTRI(IAXIS)+1._EB) < GEOMEPS) .AND. &
                 (ABS(XFACE(I-FCELL  )-XYZ(IAXIS)) < GEOMEPS) ) CYCLE ! Low Face
            IF ( (ABS(NORMTRI(IAXIS)-1._EB) < GEOMEPS) .AND. &
                 (ABS(XFACE(I-FCELL+1)-XYZ(IAXIS)) < GEOMEPS) ) CYCLE ! High Face
            ! JAXIS:
            IF ( (ABS(NORMTRI(JAXIS)+1._EB) < GEOMEPS) .AND. &
                 (ABS(YFACE(J-FCELL  )-XYZ(JAXIS)) < GEOMEPS) ) CYCLE ! Low Face
            IF ( (ABS(NORMTRI(JAXIS)-1._EB) < GEOMEPS) .AND. &
                 (ABS(YFACE(J-FCELL+1)-XYZ(JAXIS)) < GEOMEPS) ) CYCLE ! High Face
            ! KAXIS:
            IF ( (ABS(NORMTRI(KAXIS)+1._EB) < GEOMEPS) .AND. &
                 (ABS(ZFACE(K-FCELL  )-XYZ(KAXIS)) < GEOMEPS) ) CYCLE ! Low Face
            IF ( (ABS(NORMTRI(KAXIS)-1._EB) < GEOMEPS) .AND. &
                 (ABS(ZFACE(K-FCELL+1)-XYZ(KAXIS)) < GEOMEPS) ) CYCLE ! High Face

            ! Face Vertices average location:
            XCEN(IAXIS:KAXIS) = 0._EB
            DO ISEG_FACE=1,NSEG_FACE
                XCEN(IAXIS:KAXIS) = XCEN(IAXIS:KAXIS) + XYZVERT(IAXIS:KAXIS,SEG_FACE2(NOD1,ISEG_FACE))
            ENDDO
            XCEN(IAXIS:KAXIS) = XCEN(IAXIS:KAXIS) / REAL(NSEG_FACE,EB)

            ISEG_FACE = 1
            VC1(IAXIS:KAXIS) = XYZVERT(IAXIS:KAXIS,SEG_FACE2(NOD1,ISEG_FACE  )) - XCEN(IAXIS:KAXIS)
            V12(IAXIS:KAXIS) = XYZVERT(IAXIS:KAXIS,SEG_FACE2(NOD1,ISEG_FACE+1)) - &
                               XYZVERT(IAXIS:KAXIS,SEG_FACE2(NOD1,ISEG_FACE  ))

            CROSSV(IAXIS) = VC1(JAXIS)*V12(KAXIS) - VC1(KAXIS)*V12(JAXIS)
            CROSSV(JAXIS) = VC1(KAXIS)*V12(IAXIS) - VC1(IAXIS)*V12(KAXIS)
            CROSSV(KAXIS) = VC1(IAXIS)*V12(JAXIS) - VC1(JAXIS)*V12(IAXIS)

            RH_ORIENTED = ( NORMTRI(IAXIS)*CROSSV(IAXIS) + &
                            NORMTRI(JAXIS)*CROSSV(JAXIS) + &
                            NORMTRI(KAXIS)*CROSSV(KAXIS) ) > 0._EB

            NP  = NSEG_FACE
            NCF = MESHES(NM)%CUT_FACE(NCUTFACE)%NFACE + 1
            MESHES(NM)%CUT_FACE(NCUTFACE)%CFELEM(1,NCF) = NP
            IF (RH_ORIENTED) THEN
                DO IDUM=1,NP
                   MESHES(NM)%CUT_FACE(NCUTFACE)%CFELEM(IDUM+1,NCF) = SEG_FACE2(NOD1,IDUM)
                ENDDO
            ELSE
                DO IDUM=1,NP
                   MESHES(NM)%CUT_FACE(NCUTFACE)%CFELEM(IDUM+1,NCF) = SEG_FACE2(NOD1,NP+1-IDUM)
                ENDDO
            ENDIF
            MESHES(NM)%CUT_FACE(NCUTFACE)%NFACE  = NCF

            ! Compute Sections area and centroid:
            AREA                = 0._EB
            ACEN(IAXIS:KAXIS)   = 0._EB
            INXAREA             = 0._EB
            SQAREA(IAXIS:KAXIS) = 0._EB
            DO ISEG_FACE=1,NSEG_FACE-1

               IDUM = MESHES(NM)%CUT_FACE(NCUTFACE)%CFELEM(1+ISEG_FACE,NCF)
               X1(IAXIS:KAXIS)  = XYZVERT(IAXIS:KAXIS,IDUM)
               IDUM = MESHES(NM)%CUT_FACE(NCUTFACE)%CFELEM(2+ISEG_FACE,NCF)
               X2(IAXIS:KAXIS)  = XYZVERT(IAXIS:KAXIS,IDUM)
               VC1(IAXIS:KAXIS) = X1(IAXIS:KAXIS) - XCEN(IAXIS:KAXIS)
               V12(IAXIS:KAXIS) = X2(IAXIS:KAXIS) - X1(IAXIS:KAXIS)
               XCENI(IAXIS:KAXIS) = (XCEN(IAXIS:KAXIS) + X1(IAXIS:KAXIS) + X2(IAXIS:KAXIS)) / 3._EB

               CROSSV(IAXIS) = VC1(JAXIS)*V12(KAXIS) - VC1(KAXIS)*V12(JAXIS)
               CROSSV(JAXIS) = VC1(KAXIS)*V12(IAXIS) - VC1(IAXIS)*V12(KAXIS)
               CROSSV(KAXIS) = VC1(IAXIS)*V12(JAXIS) - VC1(JAXIS)*V12(IAXIS)

               AREAI = 0.5_EB * SQRT( CROSSV(IAXIS)**2._EB + CROSSV(JAXIS)**2._EB + CROSSV(KAXIS)**2._EB )
               AREA  = AREA + AREAI
               ACEN(IAXIS:KAXIS)  = ACEN(IAXIS:KAXIS) + AREAI * XCENI(IAXIS:KAXIS)
               ! volume computation variables:
               XC1(IAXIS:KAXIS) = 0.5_EB*(XCEN(IAXIS:KAXIS) + X1(IAXIS:KAXIS))
               XC2(IAXIS:KAXIS) = 0.5_EB*(XCEN(IAXIS:KAXIS) + X2(IAXIS:KAXIS))
               X12(IAXIS:KAXIS) = 0.5_EB*(  X1(IAXIS:KAXIS) + X2(IAXIS:KAXIS))
               ! dot(i,nc) int(x)dA
               INXAREA = INXAREA + NORMTRI(IAXIS)*XCENI(IAXIS)*AREAI ! Single Gauss pt integration.
               ! dot(i,nc) int(x^2)dA, dot(j,nc) int(y^2)dA, dot(k,nc) int(z^2)dA
               DO IX=IAXIS,KAXIS
                  INT2 = (XC1(IX)**2._EB + XC2(IX)**2._EB + X12(IX)**2._EB) / 3._EB
                  SQAREA(IX) = SQAREA(IX) + NORMTRI(IX)*INT2*AREAI  ! Midpoint rule.
               ENDDO
            ENDDO
            ! Final seg:
            IDUM = MESHES(NM)%CUT_FACE(NCUTFACE)%CFELEM(1+NSEG_FACE,NCF)
            x1(IAXIS:KAXIS) = XYZvert(IAXIS:KAXIS,IDUM)
            IDUM = MESHES(NM)%CUT_FACE(NCUTFACE)%CFELEM(1+1        ,NCF)
            x2(IAXIS:KAXIS) = XYZvert(IAXIS:KAXIS,IDUM)

            VC1(IAXIS:KAXIS) = X1(IAXIS:KAXIS) - XCEN(IAXIS:KAXIS)
            V12(IAXIS:KAXIS) = X2(IAXIS:KAXIS) - X1(IAXIS:KAXIS)
            XCENI(IAXIS:KAXIS) = (XCEN(IAXIS:KAXIS) + X1(IAXIS:KAXIS) + X2(IAXIS:KAXIS)) / 3._EB

            CROSSV(IAXIS) = VC1(JAXIS)*V12(KAXIS) - VC1(KAXIS)*V12(JAXIS)
            CROSSV(JAXIS) = VC1(KAXIS)*V12(IAXIS) - VC1(IAXIS)*V12(KAXIS)
            CROSSV(KAXIS) = VC1(IAXIS)*V12(JAXIS) - VC1(JAXIS)*V12(IAXIS)

            AREAI = 0.5_EB * SQRT( CROSSV(IAXIS)**2._EB + CROSSV(JAXIS)**2._EB + CROSSV(KAXIS)**2._EB )
            AREA  = AREA + AREAI
            ACEN(IAXIS:KAXIS)  = (ACEN(IAXIS:KAXIS) + AREAI * XCENI(IAXIS:KAXIS))/AREA
            ! volume computation variables:
            XC1(IAXIS:KAXIS) = 0.5_EB*(XCEN(IAXIS:KAXIS) + X1(IAXIS:KAXIS))
            XC2(IAXIS:KAXIS) = 0.5_EB*(XCEN(IAXIS:KAXIS) + X2(IAXIS:KAXIS))
            X12(IAXIS:KAXIS) = 0.5_EB*(  X1(IAXIS:KAXIS) + X2(IAXIS:KAXIS))
            ! dot(i,nc) int(x)dA
            INXAREA = INXAREA + NORMTRI(IAXIS)*XCENI(IAXIS)*AREAI ! Single Gauss pt integration.
            ! dot(i,nc) int(x^2)dA, dot(j,nc) int(y^2)dA, dot(k,nc) int(z^2)dA
            DO IX=IAXIS,KAXIS
               INT2 = (XC1(IX)**2._EB + XC2(IX)**2._EB + X12(IX)**2._EB) / 3._EB
               SQAREA(IX) = SQAREA(IX) + NORMTRI(IX)*INT2*AREAI  ! Midpoint rule.
            ENDDO

            MESHES(NM)%CUT_FACE(NCUTFACE)%AREA(NCF) = AREA
            MESHES(NM)%CUT_FACE(NCUTFACE)%XYZCEN(IAXIS:KAXIS,NCF) = ACEN(IAXIS:KAXIS)

            ! Fields for cut-cell volume/centroid computation:
            ! dot(i,nc)*int(x)dA:
            MESHES(NM)%CUT_FACE(NCUTFACE)%INXAREA(NCF)   = INXAREA
            ! dot(i,nc)*int(x^2)dA:
            MESHES(NM)%CUT_FACE(NCUTFACE)%INXSQAREA(NCF) = SQAREA(IAXIS)
            ! dot(j,nc)*int(y^2)dA:
            MESHES(NM)%CUT_FACE(NCUTFACE)%JNYSQAREA(NCF) = SQAREA(JAXIS)
            ! dot(k,nc)*int(z^2)dA:
            MESHES(NM)%CUT_FACE(NCUTFACE)%KNZSQAREA(NCF) = SQAREA(KAXIS)

            ! Define Body-triangle reference:
            MESHES(NM)%CUT_FACE(NCUTFACE)%BODTRI(1:2,NCF)= (/ IBOD, ITRI /)

            ! Assign surf-index: Depending on GEOMETRY:
            MESHES(NM)%CUT_FACE(NCUTFACE)%SURF_INDEX(NCF) = GEOMETRY(IBOD)%SURFS(ITRI)

         ENDDO ICF_LOOP
      ENDDO ! I
   ENDDO ! J
ENDDO ! K

IF (.NOT.BNDINT_FLAG) DEALLOCATE(IJK_COUNTED)

T_CC_USED(GET_CARTCELL_CUTFACES_TIME_INDEX) = T_CC_USED(GET_CARTCELL_CUTFACES_TIME_INDEX) + CURRENT_TIME() - TNOW

RETURN
END SUBROUTINE GET_CARTCELL_CUTFACES

! ----------------------- GET_CARTCELL_CUTCELLS ---------------------------------

SUBROUTINE GET_CARTCELL_CUTCELLS(NM)

USE COMP_FUNCTIONS, ONLY: CURRENT_TIME

INTEGER, INTENT(IN) :: NM

! Local Variables:
INTEGER  :: I, II, J, JJ, K, ILO, IHI, JLO, JHI, KLO, KHI
INTEGER, DIMENSION(LOW_IND:HIGH_IND,IAXIS:KAXIS) :: FSID_XYZ, IDCF_XYZ
INTEGER  :: NVERT_CELL, NSEG_CELL, NFACE_CELL, NCELL
INTEGER  :: IED, JED, KED, MYAXIS, SIDE
REAL(EB), DIMENSION(IAXIS:KAXIS,NOD1:NOD4,LOW_IND:HIGH_IND) :: XYZLH
REAL(EB) :: AREAI, AREAVARSI(1:MAX_DIM+1,LOW_IND:HIGH_IND), FCT, XYZ(IAXIS:KAXIS)
REAL(EB) :: AREAVARS(1:MAX_DIM+1,1:IBM_MAXCFELEM_CELL)
INTEGER  :: CEI_AXIS(LOW_IND:HIGH_IND)
INTEGER  :: IP, NP, ICF, CEI, INOD, FNOD
INTEGER,  DIMENSION(1:IBM_MAXCFACE_CUTCELL+2,IBM_MAXCCELEM_CELL)::    CCELEM
INTEGER,  DIMENSION(1:IBM_NPARAM_CCFACE,1:IBM_MAXCFELEM_CELL)   :: FACE_LIST ! List of faces, cut-faces.
REAL(EB), DIMENSION(IBM_MAXCCELEM_CELL)                         ::       VOL ! Cut-cell volumes.
REAL(EB), DIMENSION(IAXIS:KAXIS,1:IBM_MAXCCELEM_CELL)           ::    XYZCEN
REAL(EB), DIMENSION(IAXIS:KAXIS,1:IBM_MAXVERTS_CELL)            ::   XYZVERT
INTEGER,  DIMENSION(NOD1:NOD2,1:IBM_MAXCEELEM_CELL)             ::  SEG_CELL
INTEGER,  DIMENSION(1:IBM_MAXCFELEM_CELL,1:IBM_MAXCEELEM_CELL)  :: EDGFAC_CELL
INTEGER,  DIMENSION(1:IBM_MAXCEELEM_CELL,1:IBM_MAXCFELEM_CELL)  :: FACEDG_CELL
INTEGER,  DIMENSION(1:IBM_MAXVERTS_CELL,1:IBM_MAXCFELEM_CELL)   :: FACE_CELL ! Large array.
INTEGER,  DIMENSION(1:IBM_MAXVERTS_CELL)                        :: FACE_CELL_DUM
INTEGER,  DIMENSION(1:IBM_MAXCFELEM_CELL)                       :: FACECELL_NUM
INTEGER :: IFACE, IEDGE, ISEG, SEG(NOD1:NOD2), IPTS(1:IBM_MAXVERTS_CELL+1), ICELL, NFACEI
LOGICAL :: INLIST, TEST1, TEST2, NEWFACE
INTEGER :: NIEDGE, NEF, LOCSEG, JFACE, KFACE, NFACEK, NUM_FACE, NCUTCELL, NCFACE_CUTCELL

INTEGER :: IBNDINT
LOGICAL, ALLOCATABLE, SAVE, DIMENSION(:,:,:) :: IJK_COUNT
REAL(EB) :: TNOW

TNOW=CURRENT_TIME()

! Definition of cut-cells:
! For each cartesian cell being cut into one or several cut-cells (NCELL), fill
! entries on a MESHES(NM)%CUT_CELL struct. On each local entry ICC:
! - Add number of faces that are boundary of cut-cell.
!    MESHES(NM)%CUT_CELL(ICELL)%CCELEM(1:NFACE_CELL+1,ICC), ICC=1,...,MESHES(NM)%CUT_CELL(ICELL)%NCELL
! - Add list of corresponding regular faces, or cut-faces in CUT_FACE:
!    + 5 Indexes:
!    MESHES(NM)%CUT_CELL(ICELL)%FACES_LIST = [ FACE_TYPE      LOW/HIGH      AXIS       cei      icf   ]
!                                                  where in MESHES(NM)%CUT_FACE(CEI), which icf.
! - Compute Volume properties for each disjoint volume, add an unknown
!   number for scalars, pressure, etc.

IBNDINT_LOOP : DO IBNDINT=LOW_IND,HIGH_IND    ! 1 refers to blocks internal cells, 2 refers to block guard cells.

SELECT CASE(IBNDINT)
CASE(LOW_IND)
   ALLOCATE(IJK_COUNT(ILO_CELL-NGUARD:IHI_CELL+NGUARD,JLO_CELL-NGUARD:JHI_CELL+NGUARD,KLO_CELL-NGUARD:KHI_CELL+NGUARD))
   IJK_COUNT = .FALSE.
   ILO = ILO_CELL; IHI = IHI_CELL
   JLO = JLO_CELL; JHI = JHI_CELL
   KLO = KLO_CELL; KHI = KHI_CELL
CASE(HIGH_IND)
   ILO = ILO_CELL-CCGUARD; IHI = IHI_CELL+CCGUARD
   JLO = JLO_CELL-CCGUARD; JHI = JHI_CELL+CCGUARD
   KLO = KLO_CELL-CCGUARD; KHI = KHI_CELL+CCGUARD
END SELECT

! Loop on Cartesian cells, define cut cells and solid cells IBM_CGSC:
DO K=KLO,KHI
   DO J=JLO,JHI
      DO I=ILO,IHI

         IF( MESHES(NM)%CCVAR(I,J,K,IBM_CGSC) /= IBM_CUTCFE ) CYCLE

         IF( IJK_COUNT(I,J,K) ) CYCLE; IJK_COUNT(I,J,K) = .TRUE.


         ! Start with Cartesian Faces:
         ! Face type of bounding Cartesian faces:
         FSID_XYZ(LOW_IND ,IAXIS) = MESHES(NM)%FCVAR(I-FCELL  ,J,K,IBM_FGSC,IAXIS)
         FSID_XYZ(HIGH_IND,IAXIS) = MESHES(NM)%FCVAR(I-FCELL+1,J,K,IBM_FGSC,IAXIS)
         FSID_XYZ(LOW_IND ,JAXIS) = MESHES(NM)%FCVAR(I,J-FCELL  ,K,IBM_FGSC,JAXIS)
         FSID_XYZ(HIGH_IND,JAXIS) = MESHES(NM)%FCVAR(I,J-FCELL+1,K,IBM_FGSC,JAXIS)
         FSID_XYZ(LOW_IND ,KAXIS) = MESHES(NM)%FCVAR(I,J,K-FCELL  ,IBM_FGSC,KAXIS)
         FSID_XYZ(HIGH_IND,KAXIS) = MESHES(NM)%FCVAR(I,J,K-FCELL+1,IBM_FGSC,KAXIS)

         ! Cut-face number of bounding Cartesian faces:
         IDCF_XYZ(LOW_IND ,IAXIS) = MESHES(NM)%FCVAR(I-FCELL  ,J,K,IBM_IDCF,IAXIS)
         IDCF_XYZ(HIGH_IND,IAXIS) = MESHES(NM)%FCVAR(I-FCELL+1,J,K,IBM_IDCF,IAXIS)
         IDCF_XYZ(LOW_IND ,JAXIS) = MESHES(NM)%FCVAR(I,J-FCELL  ,K,IBM_IDCF,JAXIS)
         IDCF_XYZ(HIGH_IND,JAXIS) = MESHES(NM)%FCVAR(I,J-FCELL+1,K,IBM_IDCF,JAXIS)
         IDCF_XYZ(LOW_IND ,KAXIS) = MESHES(NM)%FCVAR(I,J,K-FCELL  ,IBM_IDCF,KAXIS)
         IDCF_XYZ(HIGH_IND,KAXIS) = MESHES(NM)%FCVAR(I,J,K-FCELL+1,IBM_IDCF,KAXIS)

         ! Local variables:
         ! Geometric entities related to the Cartesian cell:
         NVERT_CELL = 0
         NSEG_CELL  = 0
         NFACE_CELL = 0
         SEG_CELL   = IBM_UNDEFINED
         FACE_CELL  = IBM_UNDEFINED
         FACE_LIST  = IBM_UNDEFINED
         XYZVERT    = 0._EB
         AREAVARS   = 0._EB

         ! Add Cartesian Regular faces + GASPHASE cut-faces + vertices:
         IED = I-FCELL; JED = J-FCELL; KED = K-FCELL
         MYAXIS_LOOP : DO MYAXIS=IAXIS,KAXIS
            SELECT CASE(MYAXIS)
            CASE(IAXIS)

               XYZLH(IAXIS:KAXIS,NOD1,LOW_IND) = (/ XFACE(IED  ), YFACE(JED  ), ZFACE(KED  ) /)
               XYZLH(IAXIS:KAXIS,NOD2,LOW_IND) = (/ XFACE(IED  ), YFACE(JED  ), ZFACE(KED+1) /)
               XYZLH(IAXIS:KAXIS,NOD3,LOW_IND) = (/ XFACE(IED  ), YFACE(JED+1), ZFACE(KED+1) /)
               XYZLH(IAXIS:KAXIS,NOD4,LOW_IND) = (/ XFACE(IED  ), YFACE(JED+1), ZFACE(KED  ) /)

               XYZLH(IAXIS:KAXIS,NOD1,HIGH_IND)= (/ XFACE(IED+1), YFACE(JED  ), ZFACE(KED  ) /)
               XYZLH(IAXIS:KAXIS,NOD2,HIGH_IND)= (/ XFACE(IED+1), YFACE(JED+1), ZFACE(KED  ) /)
               XYZLH(IAXIS:KAXIS,NOD3,HIGH_IND)= (/ XFACE(IED+1), YFACE(JED+1), ZFACE(KED+1) /)
               XYZLH(IAXIS:KAXIS,NOD4,HIGH_IND)= (/ XFACE(IED+1), YFACE(JED  ), ZFACE(KED+1) /)

               AREAI    = DYCELL(J) * DZCELL(K)
               AREAVARSI(1:MAX_DIM+1,LOW_IND) =(/-XFACE(IED  )*AREAI, -XFACE(IED  )**2._EB*AREAI, 0._EB, 0._EB /)
               AREAVARSI(1:MAX_DIM+1,HIGH_IND)=(/ XFACE(IED+1)*AREAI,  XFACE(IED+1)**2._EB*AREAI, 0._EB, 0._EB /)
            CASE(JAXIS)

               XYZLH(IAXIS:KAXIS,NOD1,LOW_IND) = (/ XFACE(IED  ), YFACE(JED  ), ZFACE(KED  ) /)
               XYZLH(IAXIS:KAXIS,NOD2,LOW_IND) = (/ XFACE(IED+1), YFACE(JED  ), ZFACE(KED  ) /)
               XYZLH(IAXIS:KAXIS,NOD3,LOW_IND) = (/ XFACE(IED+1), YFACE(JED  ), ZFACE(KED+1) /)
               XYZLH(IAXIS:KAXIS,NOD4,LOW_IND) = (/ XFACE(IED  ), YFACE(JED  ), ZFACE(KED+1) /)

               XYZLH(IAXIS:KAXIS,NOD1,HIGH_IND)= (/ XFACE(IED  ), YFACE(JED+1), ZFACE(KED  ) /)
               XYZLH(IAXIS:KAXIS,NOD2,HIGH_IND)= (/ XFACE(IED  ), YFACE(JED+1), ZFACE(KED+1) /)
               XYZLH(IAXIS:KAXIS,NOD3,HIGH_IND)= (/ XFACE(IED+1), YFACE(JED+1), ZFACE(KED+1) /)
               XYZLH(IAXIS:KAXIS,NOD4,HIGH_IND)= (/ XFACE(IED+1), YFACE(JED+1), ZFACE(KED  ) /)

               AREAI    = DXCELL(I) * DZCELL(K)
               AREAVARSI(1:MAX_DIM+1,LOW_IND) =(/ 0._EB, 0._EB, -YFACE(JED  )**2._EB*AREAI, 0._EB /)
               AREAVARSI(1:MAX_DIM+1,HIGH_IND)=(/ 0._EB, 0._EB,  YFACE(JED+1)**2._EB*AREAI, 0._EB /)
            CASE(KAXIS)

               XYZLH(IAXIS:KAXIS,NOD1,LOW_IND) = (/ XFACE(IED  ), YFACE(JED  ), ZFACE(KED  ) /)
               XYZLH(IAXIS:KAXIS,NOD2,LOW_IND) = (/ XFACE(IED  ), YFACE(JED+1), ZFACE(KED  ) /)
               XYZLH(IAXIS:KAXIS,NOD3,LOW_IND) = (/ XFACE(IED+1), YFACE(JED+1), ZFACE(KED  ) /)
               XYZLH(IAXIS:KAXIS,NOD4,LOW_IND) = (/ XFACE(IED+1), YFACE(JED  ), ZFACE(KED  ) /)

               XYZLH(IAXIS:KAXIS,NOD1,HIGH_IND)= (/ XFACE(IED  ), YFACE(JED  ), ZFACE(KED+1) /)
               XYZLH(IAXIS:KAXIS,NOD2,HIGH_IND)= (/ XFACE(IED+1), YFACE(JED  ), ZFACE(KED+1) /)
               XYZLH(IAXIS:KAXIS,NOD3,HIGH_IND)= (/ XFACE(IED+1), YFACE(JED+1), ZFACE(KED+1) /)
               XYZLH(IAXIS:KAXIS,NOD4,HIGH_IND)= (/ XFACE(IED  ), YFACE(JED+1), ZFACE(KED+1) /)

               AREAI    = DXCELL(I) * DYCELL(J)
               AREAVARSI(1:MAX_DIM+1,LOW_IND) =(/ 0._EB, 0._EB, 0._EB, -ZFACE(KED  )**2._EB*AREAI /)
               AREAVARSI(1:MAX_DIM+1,HIGH_IND)=(/ 0._EB, 0._EB, 0._EB,  ZFACE(KED+1)**2._EB*AREAI /)
            END SELECT

            CEI_AXIS(LOW_IND:HIGH_IND) = IDCF_XYZ(LOW_IND:HIGH_IND,MYAXIS)

            DO SIDE=LOW_IND,HIGH_IND
               ! Low High face:
               IF ( FSID_XYZ(SIDE,MYAXIS) == IBM_GASPHASE ) THEN

                  ! Regular Face, build 4 vertices + face:
                  NP = 0
                  NFACE_CELL = NFACE_CELL + 1
                  FACE_LIST(1:IBM_NPARAM_CCFACE,NFACE_CELL) = (/ IBM_FTYPE_RGGAS, SIDE, MYAXIS, 0, 0 /)
                  ! IBM_FTYPE_RGGAS=0, regular face.
                  AREAVARS(1:MAX_DIM+1,NFACE_CELL) = AREAVARSI(1:MAX_DIM+1,SIDE)

                  ! Vertices arranged normal out of cartesian cell:
                  DO IP=NOD1,NOD4
                     ! xl,yl,zl
                     XYZ(IAXIS:KAXIS) = XYZLH(IAXIS:KAXIS,IP,SIDE)
                     CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_CELL,XYZ,NVERT_CELL,INOD,XYZVERT)

                     NP = NP + 1
                     FACE_CELL(1,NFACE_CELL)    =   NP
                     FACE_CELL(NP+1,NFACE_CELL) = INOD
                  ENDDO

               ELSEIF (FSID_XYZ(SIDE,MYAXIS) == IBM_CUTCFE ) THEN

                  FCT = REAL(2*SIDE-3,EB) !2*(side-3/2);
                  ! GasPhase CUT_FACE, add all cut-faces on these Cartesian cell + nodes:
                  CEI = CEI_AXIS(SIDE)
                  DO ICF=1,MESHES(NM)%CUT_FACE(CEI)%NFACE
                     NFACE_CELL = NFACE_CELL + 1
                     FACE_LIST(1:IBM_NPARAM_CCFACE,NFACE_CELL) = (/ IBM_FTYPE_CFGAS, SIDE, MYAXIS, CEI, ICF /)
                     ! IBM_FTYPE_CFGAS=1
                     AREAVARS(1:MAX_DIM+1,NFACE_CELL) =(/ MESHES(NM)%CUT_FACE(CEI)%INXAREA(ICF),   &
                                                          MESHES(NM)%CUT_FACE(CEI)%INXSQAREA(ICF), &
                                                          MESHES(NM)%CUT_FACE(CEI)%JNYSQAREA(ICF), &
                                                          MESHES(NM)%CUT_FACE(CEI)%KNZSQAREA(ICF) /)*FCT
                                                          ! FCT considers Normal out.
                     NP = MESHES(NM)%CUT_FACE(CEI)%CFELEM(1,ICF)
                     FACE_CELL(1,NFACE_CELL) = NP
                     DO IP=2,NP+1
                        FNOD             = MESHES(NM)%CUT_FACE(CEI)%CFELEM(IP,ICF)
                        XYZ(IAXIS:KAXIS) = MESHES(NM)%CUT_FACE(CEI)%XYZVERT(IAXIS:KAXIS,FNOD)
                        CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_CELL,XYZ,NVERT_CELL,INOD,XYZVERT)
                        FACE_CELL(IP,NFACE_CELL) = INOD
                     ENDDO
                  ENDDO
               ENDIF
            ENDDO
         ENDDO MYAXIS_LOOP

         ! Now add INBOUNDARY faces of the cell:
         CEI = MESHES(NM)%CCVAR(I,J,K,IBM_IDCF)
         IF ( CEI > 0 ) THEN
            FCT = -1._EB
            DO ICF=1,MESHES(NM)%CUT_FACE(CEI)%NFACE
               NFACE_CELL = NFACE_CELL + 1
               FACE_LIST(1:IBM_NPARAM_CCFACE,NFACE_CELL) = (/ IBM_FTYPE_CFINB, 0, 0, CEI, ICF /)
               ! IBM_FTYPE_CFINB in Cart-cell.
               AREAVARS(1:MAX_DIM+1,NFACE_CELL) = (/ MESHES(NM)%CUT_FACE(CEI)%INXAREA(ICF),   &
                                                     MESHES(NM)%CUT_FACE(CEI)%INXSQAREA(ICF), &
                                                     MESHES(NM)%CUT_FACE(CEI)%JNYSQAREA(ICF), &
                                                     MESHES(NM)%CUT_FACE(CEI)%KNZSQAREA(ICF) /)*FCT
                                                     ! Normal out of cut-cell.
               NP = MESHES(NM)%CUT_FACE(CEI)%CFELEM(1,ICF)
               FACE_CELL(1,NFACE_CELL) = NP
               DO IP=2,NP+1
                  FNOD             = MESHES(NM)%CUT_FACE(CEI)%CFELEM(IP,ICF)
                  XYZ(IAXIS:KAXIS) = MESHES(NM)%CUT_FACE(CEI)%XYZVERT(IAXIS:KAXIS,FNOD)
                  CALL INSERT_FACE_VERT_LOC(IBM_MAXVERTS_CELL,XYZ,NVERT_CELL,INOD,XYZVERT)
                  FACE_CELL(IP,NFACE_CELL) = INOD
               ENDDO
               ! At this point the face in face cell is ordered
               ! throught the normal outside the body. Reorganize
               ! to normal outside cut-cell (inside body).
               FACE_CELL_DUM(1:NP+1) = FACE_CELL(1:NP+1,NFACE_CELL)
               DO IP=2,NP+1
                  FACE_CELL(IP,NFACE_CELL) = FACE_CELL_DUM( (NP+1)+2-IP )
               ENDDO
            ENDDO
         ENDIF


         ! Here we have in XYZvert all the vertices that define the
         ! cut-cells within Cartesian cell I,J,K. We have the faces,
         ! boundary of said cut-cells in face_cell.
         ! We have in face_list the list of cut-cell boundary faces
         ! and if they are regular or cut-face.
         ! We want to reorder face list, such that we have the
         ! subgroups of faces that make cut-cells.

         ! Make list of edges:
         EDGFAC_CELL = IBM_UNDEFINED
         FACEDG_CELL = IBM_UNDEFINED
         DO IFACE=1,NFACE_CELL
            NIEDGE = FACE_CELL(1,IFACE)
            IPTS(1:NIEDGE) = FACE_CELL(2:NIEDGE+1,IFACE); IPTS(NIEDGE+1) = FACE_CELL(2,IFACE)

            DO IEDGE=1,NIEDGE
               SEG(NOD1:NOD2)= (/ IPTS(IEDGE), IPTS(IEDGE+1) /)
               INLIST = .FALSE.
               DO ISEG=1,NSEG_CELL
                  TEST1 = (SEG_CELL(NOD1,ISEG) == SEG(NOD1)) .AND. (SEG_CELL(NOD2,ISEG) == SEG(NOD2))
                  TEST2 = (SEG_CELL(NOD2,ISEG) == SEG(NOD1)) .AND. (SEG_CELL(NOD1,ISEG) == SEG(NOD2))

                  IF ( TEST1 .OR. TEST2 ) THEN
                     INLIST = .TRUE.
                     EXIT
                  ENDIF
               enddo
               IF (.NOT.INLIST) THEN
                  NSEG_CELL = NSEG_CELL + 1
                  SEG_CELL(NOD1:NOD2,NSEG_CELL) = SEG(NOD1:NOD2)
                  NEF = 1
                  EDGFAC_CELL(1,NSEG_CELL)    =       NEF
                  EDGFAC_CELL(NEF+1,NSEG_CELL)=     IFACE
                  FACEDG_CELL(IEDGE,IFACE)    = NSEG_CELL
               ELSE
                  NEF = EDGFAC_CELL(1,ISEG) + 1
                  EDGFAC_CELL(1,ISEG)         =   NEF
                  EDGFAC_CELL(NEF+1,ISEG)     = IFACE
                  FACEDG_CELL(IEDGE,IFACE)    =  ISEG
               ENDIF
            ENDDO
         ENDDO

         ! Then  loop is on faces that have all regular edges,
         ! that is, edges shared with only one another face:
         FACECELL_NUM = 0
         ICELL        = 1
         IFACE        = 1
         NUM_FACE     = NFACE_CELL

         ! Now double infinite loops:
         INF_LOOP1 : DO
            INF_LOOP2 : DO

               NEWFACE = .FALSE.
               NFACEI  = FACE_CELL(1,IFACE)

               ! Now loop to find new face:
               DO ISEG=1,NFACEI
                  LOCSEG = FACEDG_CELL(ISEG,IFACE)
                  IF ( EDGFAC_CELL(1,LOCSEG) == 2 ) THEN ! Found a regular edge
                     DO JJ=2,EDGFAC_CELL(1,LOCSEG)+1
                        JFACE = EDGFAC_CELL(JJ,LOCSEG)
                        ! Drop for same face:
                        IF ( IFACE == JFACE ) CYCLE
                        ! Drop if face already counted:
                        IF ( FACECELL_NUM(JFACE) > 0 ) CYCLE

                        ! New face, not counted:
                        FACECELL_NUM(JFACE) =  ICELL
                        NEWFACE             = .TRUE.
                        NUM_FACE            = NUM_FACE-1
                        EXIT
                     ENDDO
                  ENDIF
                  IF (NEWFACE) THEN
                     IFACE = JFACE
                     EXIT
                  ENDIF
               ENDDO

               ! Test for all faces that have regular edges with faces that belong to icell:
               IF (.NOT.NEWFACE) THEN
                  KFACE_LOOP : DO KFACE=1,NFACE_CELL
                     IF ( FACECELL_NUM(KFACE) == 0 ) THEN ! Not associated yet
                        NFACEK = FACE_CELL(1,KFACE)
                        DO ISEG=1,NFACEK
                           LOCSEG = FACEDG_CELL(ISEG,KFACE)
                           IF ( EDGFAC_CELL(1,LOCSEG) == 2) THEN ! Found a regular edge
                              DO JJ=2,EDGFAC_CELL(1,LOCSEG)+1
                                 JFACE = EDGFAC_CELL(JJ,LOCSEG)
                                 IF ( KFACE == JFACE ) CYCLE
                                 IF ( FACECELL_NUM(JFACE) /= ICELL) CYCLE
                                 ! New face, not counted:
                                 FACECELL_NUM(KFACE) = FACECELL_NUM(JFACE)
                                 NEWFACE             = .TRUE.
                                 IFACE               = KFACE
                                 NUM_FACE            = NUM_FACE-1
                                 EXIT KFACE_LOOP
                              ENDDO
                           ENDIF
                        ENDDO
                     ENDIF
                  ENDDO KFACE_LOOP
               ENDIF

               ! Haven't found new face, either num_face=0, or we need a new icell:
               IF (.NOT.NEWFACE) EXIT

            ENDDO INF_LOOP2
            ! Test if there are any faces left:
            IF ( NUM_FACE <= 0 ) THEN
               EXIT
            ELSE ! New cell, find new face set iface
               DO IFACE=1,NFACE_CELL
                  IF (FACECELL_NUM(IFACE) == 0) THEN ! NOT COUNTED YET.
                       ! ASSUMES IT HAS AT LEAST ONE REGULAR EDGE.
                       ICELL = ICELL + 1
                       EXIT
                   ENDIF
               ENDDO
               IF(IFACE > NFACE_CELL) EXIT ! Case all faces associated.
            ENDIF
         ENDDO INF_LOOP1

         ! Create CCELEM array:
         NCELL = MAXVAL(FACECELL_NUM(:))
         CCELEM= IBM_UNDEFINED
         DO ICELL=1,NCELL
            NP = 0
            DO IFACE=1,NFACE_CELL
               IF ( FACECELL_NUM(IFACE) == ICELL ) THEN
                  NP = NP + 1
                  CCELEM(1,ICELL)    =    NP
                  CCELEM(NP+1,ICELL) = IFACE
               ENDIF
            ENDDO
         ENDDO

         ! Compute volumes and centroids for the found cut-cells:
         VOL(1:NCELL) = 0._EB
         XYZCEN(IAXIS:KAXIS,1:NCELL) = 0._EB
         DO ICELL=1,NCELL
            NP = CCELEM(1,ICELL)
            DO II=2,NP+1
               IFACE = CCELEM(II,ICELL)

               ! Volume:
               VOL(ICELL) = VOL(ICELL) + AREAVARS(1,IFACE)

               ! xyzcen:
               XYZCEN(IAXIS:KAXIS,ICELL) = XYZCEN(IAXIS:KAXIS,ICELL)+AREAVARS(2:4,IFACE)
            ENDDO
            ! divide xyzcen by 2*vol:
            XYZCEN(IAXIS:KAXIS,ICELL) = XYZCEN(IAXIS:KAXIS,ICELL) / (2._EB*VOL(ICELL))
         ENDDO

         ! Load into CUT_CELL data structure
         NCUTCELL = MESHES(NM)%N_CUTCELL_MESH + MESHES(NM)%N_GCCUTCELL_MESH + 1
         IF (IBNDINT==LOW_IND) THEN
            MESHES(NM)%N_CUTCELL_MESH   = NCUTCELL
         ELSE
            MESHES(NM)%N_GCCUTCELL_MESH = MESHES(NM)%N_GCCUTCELL_MESH + 1
         ENDIF
         MESHES(NM)%CCVAR(I,J,K,IBM_IDCC)            = NCUTCELL
         MESHES(NM)%CUT_CELL(NCUTCELL)%IJK(IAXIS:KAXIS) = (/ I, J, K /)
         MESHES(NM)%CUT_CELL(NCUTCELL)%NCELL     = NCELL
         MESHES(NM)%CUT_CELL(NCUTCELL)%NFACE_CELL= NFACE_CELL
         NCFACE_CUTCELL = MAXVAL(CCELEM(1,1:NCELL)) + 1
         CALL NEW_CELL_ALLOC(NM,NCUTCELL,NCELL,NFACE_CELL,NCFACE_CUTCELL)
         MESHES(NM)%CUT_CELL(NCUTCELL)%CCELEM(1:NCFACE_CUTCELL,1:NCELL) = CCELEM(1:NCFACE_CUTCELL,1:NCELL)
         MESHES(NM)%CUT_CELL(NCUTCELL)%FACE_LIST(1:IBM_NPARAM_CCFACE,1:NFACE_CELL) = &
         FACE_LIST(1:IBM_NPARAM_CCFACE,1:NFACE_CELL)
         MESHES(NM)%CUT_CELL(NCUTCELL)%VOLUME(1:NCELL)                  = VOL(1:NCELL)
         MESHES(NM)%CUT_CELL(NCUTCELL)%XYZCEN(IAXIS:KAXIS,1:NCELL)      = XYZCEN(IAXIS:KAXIS,1:NCELL)

      ENDDO ! I
   ENDDO ! J
ENDDO ! K

ENDDO IBNDINT_LOOP

DEALLOCATE(IJK_COUNT)

T_CC_USED(GET_CARTCELL_CUTCELLS_TIME_INDEX) = T_CC_USED(GET_CARTCELL_CUTCELLS_TIME_INDEX) + CURRENT_TIME() - TNOW

RETURN
END SUBROUTINE GET_CARTCELL_CUTCELLS

! -------------------------- NEW_CELL_ALLOC -------------------------------------

SUBROUTINE NEW_CELL_ALLOC(NM,ICC,NCELL,NFACE_CELL,NCFACE_CUTCELL)

INTEGER, INTENT(IN) :: NM,ICC,NCELL,NFACE_CELL,NCFACE_CUTCELL

! Local Variables:

ALLOCATE(MESHES(NM)%CUT_CELL(ICC)%CCELEM(1:NCFACE_CUTCELL,1:NCELL))
ALLOCATE(MESHES(NM)%CUT_CELL(ICC)%FACE_LIST(1:IBM_NPARAM_CCFACE,1:NFACE_CELL))
MESHES(NM)%CUT_CELL(ICC)%CCELEM    = IBM_UNDEFINED
MESHES(NM)%CUT_CELL(ICC)%FACE_LIST = IBM_UNDEFINED

ALLOCATE(MESHES(NM)%CUT_CELL(ICC)%VOLUME(1:NCELL),   MESHES(NM)%CUT_CELL(ICC)%RHO(1:NCELL),      &
         MESHES(NM)%CUT_CELL(ICC)%RHOS(1:NCELL),     MESHES(NM)%CUT_CELL(ICC)%RSUM(1:NCELL),     &
         MESHES(NM)%CUT_CELL(ICC)%TMP(1:NCELL),      MESHES(NM)%CUT_CELL(ICC)%D(1:NCELL),        &
         MESHES(NM)%CUT_CELL(ICC)%DS(1:NCELL),       MESHES(NM)%CUT_CELL(ICC)%Q(1:NCELL),        &
         MESHES(NM)%CUT_CELL(ICC)%QR(1:NCELL),       MESHES(NM)%CUT_CELL(ICC)%D_SOURCE(1:NCELL), &
         MESHES(NM)%CUT_CELL(ICC)%CHI_R(1:NCELL),    MESHES(NM)%CUT_CELL(ICC)%AIT(1:NCELL),      &
         MESHES(NM)%CUT_CELL(ICC)%MIX_TIME(1:NCELL), MESHES(NM)%CUT_CELL(ICC)%H(1:NCELL),        &
         MESHES(NM)%CUT_CELL(ICC)%HS(1:NCELL),       MESHES(NM)%CUT_CELL(ICC)%RTRM(1:NCELL),     &
         MESHES(NM)%CUT_CELL(ICC)%R_H_G(1:NCELL),    MESHES(NM)%CUT_CELL(ICC)%RHO_0(1:NCELL),    &
         MESHES(NM)%CUT_CELL(ICC)%WVEL(1:NCELL))

MESHES(NM)%CUT_CELL(ICC)%VOLUME   = 0._EB
MESHES(NM)%CUT_CELL(ICC)%RHO      = 0._EB
MESHES(NM)%CUT_CELL(ICC)%RHOS     = 0._EB
MESHES(NM)%CUT_CELL(ICC)%RSUM     = 0._EB
MESHES(NM)%CUT_CELL(ICC)%TMP      = 0._EB
MESHES(NM)%CUT_CELL(ICC)%D        = 0._EB
MESHES(NM)%CUT_CELL(ICC)%DS       = 0._EB
MESHES(NM)%CUT_CELL(ICC)%Q        = 0._EB
MESHES(NM)%CUT_CELL(ICC)%QR       = 0._EB
MESHES(NM)%CUT_CELL(ICC)%D_SOURCE = 0._EB
MESHES(NM)%CUT_CELL(ICC)%CHI_R    = 0._EB
MESHES(NM)%CUT_CELL(ICC)%AIT      = 0._EB
MESHES(NM)%CUT_CELL(ICC)%MIX_TIME = 0._EB
MESHES(NM)%CUT_CELL(ICC)%H        = 0._EB
MESHES(NM)%CUT_CELL(ICC)%HS       = 0._EB
MESHES(NM)%CUT_CELL(ICC)%RTRM     = 0._EB
MESHES(NM)%CUT_CELL(ICC)%R_H_G    = 0._EB
MESHES(NM)%CUT_CELL(ICC)%RHO_0    = 0._EB
MESHES(NM)%CUT_CELL(ICC)%WVEL     = 0._EB

ALLOCATE(MESHES(NM)%CUT_CELL(ICC)%XYZCEN(IAXIS:KAXIS,1:NCELL))
MESHES(NM)%CUT_CELL(ICC)%XYZCEN = 0._EB

ALLOCATE(MESHES(NM)%CUT_CELL(ICC)%Q_REAC(1:MAX_REACTIONS,1:NCELL))
MESHES(NM)%CUT_CELL(ICC)%Q_REAC = 0._EB

ALLOCATE(MESHES(NM)%CUT_CELL(ICC)%REAC_SOURCE_TERM(1:MAX_SPECIES,1:NCELL), &
         MESHES(NM)%CUT_CELL(ICC)%ZZ(1:MAX_SPECIES,1:NCELL),               &
         MESHES(NM)%CUT_CELL(ICC)%ZZS(1:MAX_SPECIES,1:NCELL),              &
         MESHES(NM)%CUT_CELL(ICC)%M_DOT_PPP(1:MAX_SPECIES,1:NCELL))
MESHES(NM)%CUT_CELL(ICC)%REAC_SOURCE_TERM = 0._EB
MESHES(NM)%CUT_CELL(ICC)%ZZ               = 0._EB
MESHES(NM)%CUT_CELL(ICC)%ZZS              = 0._EB
MESHES(NM)%CUT_CELL(ICC)%M_DOT_PPP        = 0._EB

ALLOCATE(MESHES(NM)%CUT_CELL(ICC)%UNKH(1:NCELL),MESHES(NM)%CUT_CELL(ICC)%UNKZ(1:NCELL))
MESHES(NM)%CUT_CELL(ICC)%UNKH = IBM_UNDEFINED
MESHES(NM)%CUT_CELL(ICC)%UNKZ = IBM_UNDEFINED

ALLOCATE(MESHES(NM)%CUT_CELL(ICC)%IJK_CCCEN(MAX_DIM,MAX_INTERP_POINTS_PLANE,1:NCELL))
MESHES(NM)%CUT_CELL(ICC)%IJK_CCCEN = IBM_UNDEFINED

ALLOCATE(MESHES(NM)%CUT_CELL(ICC)%XYZ_BP_CCCEN(MAX_DIM,1:NCELL))
MESHES(NM)%CUT_CELL(ICC)%XYZ_BP_CCCEN = 0._EB

ALLOCATE(MESHES(NM)%CUT_CELL(ICC)%INBFC_CCCEN(3,1:NCELL))
MESHES(NM)%CUT_CELL(ICC)%INBFC_CCCEN = IBM_UNDEFINED

ALLOCATE(MESHES(NM)%CUT_CELL(ICC)%INTCOEF_CCCEN(MAX_INTERP_POINTS_PLANE+1,1:NCELL))
MESHES(NM)%CUT_CELL(ICC)%INTCOEF_CCCEN = 0._EB

ALLOCATE(MESHES(NM)%CUT_CELL(ICC)%H_CCCEN(    MAX_INTERP_POINTS_PLANE+1,1:NCELL), &
         MESHES(NM)%CUT_CELL(ICC)%RHO_0_CCCEN(MAX_INTERP_POINTS_PLANE+1,1:NCELL), &
         MESHES(NM)%CUT_CELL(ICC)%W_CCCEN(    MAX_INTERP_POINTS_PLANE+1,1:NCELL))
MESHES(NM)%CUT_CELL(ICC)%H_CCCEN    = 0._EB
MESHES(NM)%CUT_CELL(ICC)%RHO_0_CCCEN= 0._EB
MESHES(NM)%CUT_CELL(ICC)%W_CCCEN    = 0._EB

ALLOCATE(MESHES(NM)%CUT_CELL(ICC)%NOMIND_CCCEN(LOW_IND:HIGH_IND,MAX_INTERP_POINTS_PLANE,1:NCELL))
MESHES(NM)%CUT_CELL(ICC)%NOMIND_CCCEN = IBM_UNDEFINED

ALLOCATE(MESHES(NM)%CUT_CELL(ICC)%DEL_RHO_D_DEL_Z(1:MAX_SPECIES,1:NCELL), &
         MESHES(NM)%CUT_CELL(ICC)%U_DOT_DEL_RHO_Z(1:MAX_SPECIES,1:NCELL))
MESHES(NM)%CUT_CELL(ICC)%DEL_RHO_D_DEL_Z = 0._EB
MESHES(NM)%CUT_CELL(ICC)%U_DOT_DEL_RHO_Z = 0._EB

RETURN

END SUBROUTINE NEW_CELL_ALLOC

! ------------------------ GET_TRIANG_FACE_INT ----------------------------------

SUBROUTINE GET_TRIANG_FACE_INT(X2AXIS,X3AXIS,FVERT,CEI,NM, &
                               INB_FLG,NVERT,XYVERT,NEDGE,CEELEM,INDSEG)

INTEGER,  INTENT(IN) :: X2AXIS, X3AXIS, CEI, NM
REAL(EB), INTENT(IN) :: FVERT(IAXIS:JAXIS,NOD1:NOD4)
LOGICAL,  INTENT(OUT):: INB_FLG
INTEGER,  INTENT(OUT):: NVERT,NEDGE,CEELEM(NOD1:NOD2,1:IBM_MAXCEELEM_FACE)
INTEGER,  INTENT(OUT):: INDSEG(IBM_MAX_WSTRIANG_SEG+2,IBM_MAXCEELEM_FACE)
REAL(EB), INTENT(OUT):: XYVERT(IAXIS:JAXIS,1:IBM_MAXVERTS_FACE)

! Local Variables:
REAL(EB) :: X2X3VERT(IAXIS:JAXIS,1:IBM_MAXVERTS_FACE)
REAL(EB) :: X2FMIN, X2FMAX, X3FMIN, X3FMAX, DUMMY(IAXIS:JAXIS)
INTEGER  :: TRI(NOD1:NOD3), ITRI, INOD
LOGICAL  :: INTEST, OUTX2, OUTX3, OUTFACE, TRUETHAT, XIALIGNED, OUTSEG, SEG_IN_SIDE
INTEGER  :: TSEGS(NOD1:NOD2,EDG1:EDG3)
INTEGER, ALLOCATABLE, DIMENSION(:,:) :: FVERT_IN_TRIANG, TRIVERT_IN_FACE
INTEGER  :: NFVERT, NTVERT, NINTP
INTEGER  :: TRINODS(IBM_MAXVERTS_FACE)
REAL(EB) :: ATANTRI(1:IBM_MAXVERTS_FACE+1), ATTRI
INTEGER  :: II(1:IBM_MAXVERTS_FACE+1), INTP, IINS, IDUM, INP, NINTP_TRI, IPT, JPL, IEDGE, IPF, ISEG
INTEGER  :: LOCTRI, LOCBOD, EDGETRI(NOD1:NOD2,1:IBM_MAXCEELEM_FACE), VEC3(1:3)
REAL(EB) :: XY1(IAXIS:JAXIS), XY2(IAXIS:JAXIS), XP1(IAXIS:JAXIS), XP2(IAXIS:JAXIS)
REAL(EB) :: XP(IAXIS:JAXIS), FD(1:2), VEC(IAXIS:JAXIS)
INTEGER  :: MYAXIS, XIAXIS, XJAXIS
REAL(EB) :: XIPLNS(LOW_IND:HIGH_IND), XJPLNS(LOW_IND:HIGH_IND), DOT1, DOT2
REAL(EB) :: MINXI, MAXXI, MINXJ, MAXXJ, DS, SVARI, XJPLN, XCEN(IAXIS:JAXIS)
REAL(EB) :: VECS(IAXIS:JAXIS), VECP1(IAXIS:JAXIS), VECP2(IAXIS:JAXIS), CROSSP1, CROSSP2
REAL(EB) :: XYEL(IAXIS:JAXIS,NOD1:NOD3)
LOGICAL  :: INLIST, OUTPLANE1, OUTPLANE2
INTEGER  :: EDGE_TRI

! Default return values:
INB_FLG = .FALSE.
NVERT = 0
NEDGE = 0
X2X3VERT = 0._EB
CEELEM   = IBM_UNDEFINED
INDSEG   = IBM_UNDEFINED
IF ( CEI /= 0 ) THEN
   NVERT = MESHES(NM)%CUT_EDGE(CEI)%NVERT
   NEDGE = MESHES(NM)%CUT_EDGE(CEI)%NEDGE

   X2X3VERT(IAXIS,1:NVERT)   = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(X2AXIS,1:NVERT)
   X2X3VERT(JAXIS,1:NVERT)   = MESHES(NM)%CUT_EDGE(CEI)%XYZVERT(X3AXIS,1:NVERT)

   CEELEM(NOD1:NOD2,1:NEDGE) = MESHES(NM)%CUT_EDGE(CEI)%CEELEM(NOD1:NOD2,1:NEDGE)
   INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,1:NEDGE) = &
   MESHES(NM)%CUT_EDGE(CEI)%INDSEG(1:IBM_MAX_WSTRIANG_SEG+2,1:NEDGE)
ENDIF
XYVERT = X2X3VERT

! Quick discard test:
X2FMIN = MINVAL(FVERT(IAXIS,NOD1:NOD4)); X2FMAX = MAXVAL(FVERT(IAXIS,NOD1:NOD4))
X3FMIN = MINVAL(FVERT(JAXIS,NOD1:NOD4)); X3FMAX = MAXVAL(FVERT(JAXIS,NOD1:NOD4))

! Loop in-plane Surface Elements:
INTEST = .FALSE.
DO ITRI=1,BODINT_PLANE%NTRIS
    ! Elements nodes location, in x2-x3 coordinates:
    TRI(NOD1:NOD3) = BODINT_PLANE%TRIS(NOD1:NOD3,ITRI)
    DO INOD=NOD1,NOD3
       XYEL(IAXIS:JAXIS,INOD) = BODINT_PLANE%XYZ( (/ X2AXIS, X3AXIS /) ,TRI(INOD))
    ENDDO
    OUTX2= ((X2FMIN-MAXVAL(XYEL(IAXIS,NOD1:NOD3))) > GEOMEPS) .OR. &
           ((MINVAL(XYEL(IAXIS,NOD1:NOD3))-X2FMAX) > GEOMEPS) ! Triang out of Face in x2 dir
    OUTX3= ((X3FMIN-MAXVAL(XYEL(JAXIS,NOD1:NOD3))) > GEOMEPS) .OR. &
           ((MINVAL(XYEL(JAXIS,NOD1:NOD3))-X3FMAX) > GEOMEPS) ! Triang out of Face in x3 dir
    OUTFACE = OUTX2 .OR. OUTX3
    IF (.NOT.OUTFACE) THEN
        INTEST = .TRUE.
        EXIT
    ENDIF
ENDDO
IF (.NOT.INTEST) RETURN

! Now if intest is true figure out if there are triangles-face intersection
! Polygons:
NFVERT = 4
NTVERT = 3

! First Vertices:
ALLOCATE(FVERT_IN_TRIANG(1:NFVERT,BODINT_PLANE%NTRIS)); FVERT_IN_TRIANG = 0
ALLOCATE(TRIVERT_IN_FACE(1:NTVERT,BODINT_PLANE%NTRIS)); TRIVERT_IN_FACE = 0

NINTP = NVERT

! Loop in-plane Surface Elements:
DO ITRI=1,BODINT_PLANE%NTRIS

   NINTP_TRI =             0
   TRINODS   = IBM_UNDEFINED

   ! Elements nodes location, in x2-x3 coordinates:
   TRI(NOD1:NOD3) = BODINT_PLANE%TRIS(NOD1:NOD3,ITRI)
   DO INOD=NOD1,NOD3
      XYEL(IAXIS:JAXIS,INOD) = BODINT_PLANE%XYZ( (/ X2AXIS, X3AXIS /) ,TRI(INOD))
   ENDDO

   IF (BODINT_PLANE%X1NVEC(ITRI) < 0) THEN ! ROTATE NODE 2 AND 3 LOCATIONS
      DUMMY(IAXIS:JAXIS)     = XYEL(IAXIS:JAXIS,NOD2)
      XYEL(IAXIS:JAXIS,NOD2) = XYEL(IAXIS:JAXIS,NOD3)
      XYEL(IAXIS:JAXIS,NOD3) = DUMMY(IAXIS:JAXIS)

      TSEGS(NOD1:NOD2,EDG1) = BODINT_PLANE%TRIS( (/ 2, 1 /) ,ITRI)
      TSEGS(NOD1:NOD2,EDG2) = BODINT_PLANE%TRIS( (/ 3, 2 /) ,ITRI)
      TSEGS(NOD1:NOD2,EDG3) = BODINT_PLANE%TRIS( (/ 1, 3 /) ,ITRI)
   ELSE
      TSEGS(NOD1:NOD2,EDG1) = BODINT_PLANE%TRIS( (/ 1, 2 /) ,ITRI)
      TSEGS(NOD1:NOD2,EDG2) = BODINT_PLANE%TRIS( (/ 2, 3 /) ,ITRI)
      TSEGS(NOD1:NOD2,EDG3) = BODINT_PLANE%TRIS( (/ 3, 1 /) ,ITRI)
   ENDIF

   ! a. Test if Triangles vertices Lay on Faces area, including face boundary:
   DO IPT=1,NTVERT
      OUTX2= ((X2FMIN-XYEL(IAXIS,IPT)) > GEOMEPS) .OR. &
             ((XYEL(IAXIS,IPT)-X2FMAX) > GEOMEPS)  ! Triang out of Face in x2 dir
      OUTX3= ((X3FMIN-XYEL(JAXIS,IPT)) > GEOMEPS) .OR. &
             ((XYEL(JAXIS,IPT)-X3FMAX) > GEOMEPS)  ! Triang out of Face in x3 dir
      OUTFACE = OUTX2 .OR. OUTX3

      IF ( OUTFACE ) CYCLE

      ! Insertion add point to intersection list:
      XP(IAXIS:JAXIS) = XYEL(IAXIS:JAXIS,IPT)
      CALL INSERT_POINT_2D(XP,NINTP,X2X3VERT,INOD)

      ! Insert sort node to triangles local list
      TRUETHAT = .TRUE.
      DO INP=1,NINTP_TRI
         IF (TRINODS(INP) == INOD) THEN
            TRUETHAT = .FALSE.
            EXIT
         ENDIF
      ENDDO
      IF ( TRUETHAT ) THEN ! new inod entry on list
         NINTP_TRI = NINTP_TRI + 1
         TRINODS(NINTP_TRI) = INOD
      ENDIF

      TRIVERT_IN_FACE(IPT,ITRI) = 1

   ENDDO

   ! b. Test if Face vertices lay on triangle, including triangle edges:
   DO IPF=1,NFVERT
      ! Transform back to master Element coordinates
      ! location of point i,j in x2-x3 coordinates:
      FD(1:2) = (/ FVERT(IAXIS,IPF)-XYEL(IAXIS,NOD3), FVERT(JAXIS,IPF)-XYEL(JAXIS,NOD3) /)
      ! Here xi in vec(1) and eta in vec(2)
      VEC(IAXIS) = BODINT_PLANE%AINV(1,1,ITRI)*FD(1) + BODINT_PLANE%AINV(1,2,ITRI)*FD(2)
      VEC(JAXIS) = BODINT_PLANE%AINV(2,1,ITRI)*FD(1) + BODINT_PLANE%AINV(2,2,ITRI)*FD(2)

      ! Test for vertex point within triangle, considers Triangle Edges:
      IF ( (VEC(IAXIS) >= (0._EB-GEOMEPS)) .AND. &
           (VEC(JAXIS) >= (0._EB-GEOMEPS)) .AND. &
           (1._EB-VEC(IAXIS)-VEC(JAXIS) >= (0._EB-GEOMEPS)) ) THEN

         ! Insertion add point to intersection list:
         XP(IAXIS:JAXIS) = FVERT(IAXIS:JAXIS,IPF)
         CALL INSERT_POINT_2D(XP,NINTP,X2X3VERT,INOD)

         ! Insert sort node to triangles local list
         TRUETHAT = .TRUE.
         DO INP=1,NINTP_TRI
            IF (TRINODS(INP) == INOD) THEN
               TRUETHAT = .FALSE.
               EXIT
            ENDIF
         ENDDO
         IF ( TRUETHAT ) THEN ! new inod entry on list
            NINTP_TRI = NINTP_TRI + 1
            TRINODS(NINTP_TRI) = INOD
         ENDIF

         FVERT_IN_TRIANG(IPF,ITRI) = 1

      ENDIF
   ENDDO

   ! Now add face edge - triangle edge intersection points:
   ! x2 segments:
   DO MYAXIS=IAXIS,JAXIS
      SELECT CASE(MYAXIS)
         CASE(IAXIS)
            XIAXIS = IAXIS
            XJAXIS = JAXIS
            XIPLNS(LOW_IND:HIGH_IND) = (/ X2FMIN, X2FMAX /)
            XJPLNS(LOW_IND:HIGH_IND) = (/ X3FMIN, X3FMAX /)
         CASE(JAXIS)
            XIAXIS = JAXIS
            XJAXIS = IAXIS
            XIPLNS(LOW_IND:HIGH_IND) = (/ X3FMIN, X3FMAX /)
            XJPLNS(LOW_IND:HIGH_IND) = (/ X2FMIN, X2FMAX /)
      END SELECT

      DO JPL=LOW_IND,HIGH_IND

         XJPLN = XJPLNS(JPL)

         DO IPT=1,NTVERT

            XY1(IAXIS:JAXIS) = BODINT_PLANE%XYZ( (/ X2AXIS, X3AXIS /) , TSEGS(NOD1,IPT) )
            XY2(IAXIS:JAXIS) = BODINT_PLANE%XYZ( (/ X2AXIS, X3AXIS /) , TSEGS(NOD2,IPT) )

            ! Drop if Triangle edge on one side of segment ray:
            MAXXJ = MAX(XY1(XJAXIS),XY2(XJAXIS))
            MINXJ = MIN(XY1(XJAXIS),XY2(XJAXIS))
            OUTPLANE1 = ((XJPLN-MAXXJ) > GEOMEPS) .OR. ((MINXJ-XJPLN) > GEOMEPS)
            IF ( OUTPLANE1 ) CYCLE

            ! Also drop if Triangle edge ouside of face edge limits:
            MAXXI = MAX(XY1(XIAXIS),XY2(XIAXIS))
            MINXI = MIN(XY1(XIAXIS),XY2(XIAXIS))
            OUTPLANE2 = ((XIPLNS(LOW_IND)-MAXXI) > GEOMEPS) .OR. ((MINXI-XIPLNS(HIGH_IND)) > GEOMEPS)
            IF ( OUTPLANE2 ) CYCLE

            ! Test if segment aligned with xi
            XIALIGNED = ((MAXXJ-MINXJ) < GEOMEPS)
            IF ( XIALIGNED ) CYCLE ! Aligned and on top of xjpln: Intersection points already added.

            ! Drop intersections in triangle segment nodes: already added.
            ! Compute: dot(plnormal, xyzv - xypl):
            DOT1 = XY1(XJAXIS) - XJPLN
            DOT2 = XY2(XJAXIS) - XJPLN

            IF ( ABS(DOT1) <= GEOMEPS ) CYCLE
            IF ( ABS(DOT2) <= GEOMEPS ) CYCLE

            ! Finally regular case:
            ! Points 1 on one side of x2 segment, point 2 on the other:
            !IF ((DOT1 > 0._EB & DOT2 < 0._EB) .OR. (DOT1 < 0._EB & DOT2 > 0._EB))
            IF ( DOT1*DOT2 < 0._EB ) THEN

               ! Intersection Point along segment:
               DS    = (XJPLN-XY1(XJAXIS))/(XY2(XJAXIS)-XY1(XJAXIS))
               SVARI = XY1(XIAXIS) + DS*(XY2(XIAXIS)-XY1(XIAXIS))

               OUTSEG= ((XIPLNS(LOW_IND)-SVARI) > -GEOMEPS) .OR. ((SVARI-XIPLNS(HIGH_IND)) > -GEOMEPS)
               IF ( OUTSEG ) CYCLE

               ! Insertion add point to intersection list:
               XP(XIAXIS) = SVARI
               XP(XJAXIS) = XJPLN
               CALL INSERT_POINT_2D(XP,NINTP,X2X3VERT,INOD)

               ! Insert sort node to triangles local list
               TRUETHAT = .TRUE.
               DO INP=1,NINTP_TRI
                  IF (TRINODS(INP) == INOD) THEN
                     TRUETHAT = .FALSE.
                     EXIT
                  ENDIF
               ENDDO
               IF (TRUETHAT) THEN ! new inod entry on list
                  NINTP_TRI = NINTP_TRI + 1
                  TRINODS(NINTP_TRI) = INOD
               ENDIF
               CYCLE
            ENDIF
         ENDDO
      ENDDO
   ENDDO

   IF ( NINTP_TRI == 0 ) CYCLE

   ! Reorder points given normal on x1 direction:
   ! Centroid:
   XCEN(IAXIS:JAXIS) = 0._EB
   DO INTP=1,NINTP_TRI
      XCEN(IAXIS:JAXIS) = XCEN(IAXIS:JAXIS) + X2X3VERT(IAXIS:JAXIS,TRINODS(INTP))
   ENDDO
   XCEN(IAXIS:JAXIS)= XCEN(IAXIS:JAXIS) * REAL(NINTP_TRI,EB)**(-1._EB)

   ATANTRI(1:IBM_MAXVERTS_FACE+1) = 1._EB / GEOMEPS
   II(1:IBM_MAXVERTS_FACE+1) = IBM_UNDEFINED
   DO INTP=1,NINTP_TRI
      ATTRI = ATAN2(X2X3VERT(JAXIS,TRINODS(INTP))-XCEN(JAXIS), &
                    X2X3VERT(IAXIS,TRINODS(INTP))-XCEN(IAXIS)) + PI
      ! Insertion sort:
      DO IINS=1,INTP+1
         IF (ATTRI < ATANTRI(IINS)) EXIT
      ENDDO
      ! copy from the back:
      DO IDUM=INTP+1,IINS+1,-1
         ATANTRI(IDUM) = ATANTRI(IDUM-1)
         II(IDUM)      = II(IDUM-1)
      ENDDO
      ATANTRI(IINS) = ATTRI
      II(IINS)      = INTP
   ENDDO

   ! Reorder nodes:
   TRINODS(1:NINTP_TRI) = TRINODS(II(1:NINTP_TRI))

   ! Define and Insertion add segments to CFELEM, indseg
   EDGETRI = IBM_UNDEFINED
   DO IEDGE=1,NINTP_TRI-1
        EDGETRI(NOD1:NOD2,IEDGE) = (/ TRINODS(IEDGE), TRINODS(IEDGE+1) /)
   ENDDO
   EDGETRI(NOD1:NOD2,NINTP_TRI) = (/ TRINODS(NINTP_TRI), TRINODS(1) /)

   LOCTRI = BODINT_PLANE%INDTRI(1,ITRI)
   LOCBOD = BODINT_PLANE%INDTRI(2,ITRI)

   DO IEDGE=1,NINTP_TRI

      IF ( EDGETRI(NOD1,IEDGE) == EDGETRI(NOD2,IEDGE) ) CYCLE

      ! Test if Edge already on list:
      INLIST = .FALSE.
      DO ISEG=1,NEDGE

         IF ( (EDGETRI(NOD1,IEDGE) == CEELEM(NOD1,ISEG)) .AND. & ! same inod1
             (EDGETRI(NOD2,IEDGE) == CEELEM(NOD2,ISEG)) .AND. & ! same inod2
             (LOCBOD              == INDSEG(4,ISEG)) ) THEN     ! same ibod

            SELECT CASE(INDSEG(1,ISEG))
               ! Only one triangle in list:
               CASE(1)
                  IF ( LOCTRI /= INDSEG(2,ISEG) ) THEN
                     INDSEG(1,ISEG) = 2
                     INDSEG(3,ISEG) = LOCTRI ! add triangle 2nd.
                  ENDIF
                  INLIST = .TRUE.
                  EXIT
               ! Two triangles in list:
               CASE(2)
                  IF ( (LOCTRI == INDSEG(2,ISEG)) .OR. &
                      (LOCTRI == INDSEG(3,ISEG)) ) THEN
                     INLIST = .TRUE.
                     EXIT
                  ELSE
                     PRINT*, "Error in GET_TRIANG_FACE_INT: Triangle not on 2 WS triang list INDSEG."
                  ENDIF
            END SELECT
         ENDIF
      ENDDO

      IF ( .NOT.INLIST ) THEN ! Edge not in list.
         NEDGE = NEDGE + 1
         CEELEM(NOD1:NOD2,NEDGE) =  EDGETRI(NOD1:NOD2,IEDGE)

         ! Here we have to figure out if segment belongs to a triangles side:
         SEG_IN_SIDE = .FALSE.
         DO IPT=1,NTVERT

            ! Triangle side nodes:
            XY1(IAXIS:JAXIS) = BODINT_PLANE%XYZ( (/ X2AXIS, X3AXIS /) , TSEGS(NOD1,IPT) )
            XY2(IAXIS:JAXIS) = BODINT_PLANE%XYZ( (/ X2AXIS, X3AXIS /) , TSEGS(NOD2,IPT) )

            ! Segment points:
            XP1(IAXIS:JAXIS) = X2X3VERT(IAXIS:JAXIS,CEELEM(NOD1,NEDGE))
            XP2(IAXIS:JAXIS) = X2X3VERT(IAXIS:JAXIS,CEELEM(NOD2,NEDGE))

            VECS(IAXIS:JAXIS)  = XY2(IAXIS:JAXIS) - XY1(IAXIS:JAXIS)
            VECP1(IAXIS:JAXIS) = XP1(IAXIS:JAXIS) - XY1(IAXIS:JAXIS)
            VECP2(IAXIS:JAXIS) = XP2(IAXIS:JAXIS) - XY1(IAXIS:JAXIS)

            CROSSP1 = ABS(VECS(IAXIS)*VECP1(JAXIS)-VECS(JAXIS)*VECP1(IAXIS))
            CROSSP2 = ABS(VECS(IAXIS)*VECP2(JAXIS)-VECS(JAXIS)*VECP2(IAXIS))

            IF ( (CROSSP1+CROSSP2) < GEOMEPS ) THEN
               SEG_IN_SIDE = .TRUE.
               EXIT
            ENDIF
         ENDDO
         IF ( SEG_IN_SIDE ) THEN
            EDGE_TRI = GEOMETRY(LOCBOD)%FACE_EDGES(IPT,LOCTRI) ! WSTRIED
            VEC3(1)  = GEOMETRY(LOCBOD)%EDGE_FACES(1,EDGE_TRI) ! WSEDTRI
            VEC3(2)  = GEOMETRY(LOCBOD)%EDGE_FACES(2,EDGE_TRI)
            VEC3(3)  = GEOMETRY(LOCBOD)%EDGE_FACES(4,EDGE_TRI)
            INDSEG(1:4,NEDGE) = (/ VEC3(1), VEC3(2), VEC3(3), LOCBOD /)
         ELSE
            INDSEG(1:4,NEDGE) = (/ 1, LOCTRI, 0, LOCBOD /)
         ENDIF
      ENDIF
   ENDDO

ENDDO

! Populate XYVERT points array:
XYVERT(IAXIS:JAXIS,1:IBM_MAXVERTS_FACE) = X2X3VERT(IAXIS:JAXIS,1:IBM_MAXVERTS_FACE)
NVERT = NINTP
IF (NVERT > 0) INB_FLG = .TRUE.

DEALLOCATE(FVERT_IN_TRIANG, TRIVERT_IN_FACE)

RETURN
END SUBROUTINE GET_TRIANG_FACE_INT

! ------------------------- INSERT_POINT_2D -------------------------------------

SUBROUTINE INSERT_POINT_2D(XP,NVERT,XYVERT,INOD)

REAL(EB), INTENT(IN)    :: XP(IAXIS:JAXIS)
INTEGER,  INTENT(INOUT) :: NVERT
REAL(EB), INTENT(INOUT) :: XYVERT(IAXIS:JAXIS,1:IBM_MAXVERTS_FACE)
INTEGER,  INTENT(OUT)   :: INOD

! Local Variables:
LOGICAL :: INLIST
REAL(EB):: DV(IAXIS:JAXIS), DVNORM

INLIST = .FALSE.
DO INOD=1,NVERT
   DV(IAXIS:JAXIS) = XP(IAXIS:JAXIS) - XYVERT(IAXIS:JAXIS,INOD)
   DVNORM = SQRT( DV(IAXIS)**2._EB + DV(JAXIS)**2._EB )
   IF ( DVNORM < GEOMEPS ) THEN
      INLIST = .TRUE.
      EXIT
   ENDIF
ENDDO
IF ( .NOT.INLIST ) THEN
   NVERT = NVERT + 1
   INOD  = NVERT
   XYVERT(IAXIS:JAXIS,INOD) = XP(IAXIS:JAXIS)
ENDIF

RETURN
END SUBROUTINE INSERT_POINT_2D


! -------------------------------------------------------------------------------
! ---------------------------- READ_GEOM ----------------------------------------

SUBROUTINE READ_GEOM
USE BOXTETRA_ROUTINES, ONLY: TETRAHEDRON_VOLUME, REMOVE_DUPLICATE_VERTS
USE MATH_FUNCTIONS, ONLY: CROSS_PRODUCT

! input &GEOM lines

CHARACTER(LABEL_LENGTH) :: ID, MATL_ID
CHARACTER(LABEL_LENGTH) :: BNDC_FILENAME, GEOC_FILENAME
CHARACTER(LABEL_LENGTH) :: TEXTURE_MAPPING
CHARACTER(MESSAGE_LENGTH) :: MESSAGE, BUFFER

INTEGER :: MAX_IDS=0
CHARACTER(LABEL_LENGTH),  ALLOCATABLE, DIMENSION(:) :: GEOM_IDS
REAL(EB), ALLOCATABLE, DIMENSION(:) :: DAZIM, DELEV
REAL(EB), ALLOCATABLE, DIMENSION(:,:) :: DSCALE, DXYZ0, DXYZ

INTEGER :: MAX_SURF_IDS=0
CHARACTER(LABEL_LENGTH),  ALLOCATABLE, DIMENSION(:) :: SURF_ID
INTEGER, ALLOCATABLE, DIMENSION(:) :: SURF_ID_IND

INTEGER :: MAX_ZVALS=0
REAL(EB), ALLOCATABLE, DIMENSION(:) :: ZVALS

INTEGER :: MAX_VERTS=0
REAL(EB), ALLOCATABLE, TARGET, DIMENSION(:) :: VERTS
LOGICAL, ALLOCATABLE, DIMENSION(:) :: IS_EXTERNAL

INTEGER :: MAX_FACES=0, MAX_VOLUS=0
INTEGER, ALLOCATABLE, TARGET, DIMENSION(:) :: FACES, VOLUS, OFACES, SURFS
REAL(EB), ALLOCATABLE, DIMENSION(:) :: TFACES

REAL(EB) :: AZIM, ELEV, SCALE(3), XYZ0(3), XYZ(3)
REAL(EB) :: AZIM_DOT, ELEV_DOT, SCALE_DOT(3), XYZ_DOT(3)
REAL(EB) :: GROTATE, GROTATE_DOT, GAXIS(3)
REAL(EB), PARAMETER :: MAX_VAL=1.0E20_EB
REAL(EB) :: SPHERE_ORIGIN(3), SPHERE_RADIUS
REAL(EB) :: TEXTURE_ORIGIN(3), TEXTURE_SCALE(2)
LOGICAL :: AUTO_TEXTURE
REAL(EB) :: XB(6), DX
INTEGER :: N_VERTS, N_FACES, N_FACES_TEMP, N_VOLUS, N_ZVALS, N_SURF_ID
INTEGER :: MATL_INDEX
INTEGER :: IOS,IZERO,N, I, J, K, IJ, NSUB_GEOMS, GEOM_INDEX
INTEGER :: I1, I2, I3, I4, I5, I6, I7, I8
INTEGER :: GEOM_TYPE, NXB, IJK(3)
REAL(EB), POINTER, DIMENSION(:) :: VNEW, VOLD

INTEGER :: N_LEVELS, N_LAT, N_LONG, SPHERE_TYPE
TYPE (MESH_TYPE), POINTER :: M=>NULL()
INTEGER, POINTER, DIMENSION(:) :: FACEI, FACEJ, FACE_FROM, FACE_TO
REAL(EB) :: BOX_XYZ(3)
INTEGER :: BOXVERTLIST(8), NI, NIJ
REAL(EB) :: ZERO3(3)=(/0.0_EB,0.0_EB,0.0_EB/)
REAL(EB) :: ZMIN
INTEGER, POINTER, DIMENSION(:) :: VOL
INTEGER :: IVOL
REAL(EB) :: VOLUME
REAL(EB), POINTER, DIMENSION(:) :: V1, V2, V3, V4
LOGICAL :: HAVE_SURF, HAVE_MATL, IN_LIST
INTEGER :: SORT_FACES
INTEGER :: FIRST_FACE_INDEX
REAL(EB) :: TXMIN, TXMAX, TYMIN, TYMAX, TX, TY

LOGICAL COMPONENT_ONLY
LOGICAL, ALLOCATABLE, DIMENSION(:) :: DEFAULT_COMPONENT_ONLY
TYPE(GEOMETRY_TYPE), POINTER :: G=>NULL(), GSUB=>NULL()

LOGICAL :: SURF_INDEX_PER_FACE

INTEGER :: II,II1,II2,II3
REAL(EB):: DV1(MAX_DIM),DV2(MAX_DIM),NVECI(MAX_DIM),DXCEN(MAX_DIM),DOTI

INTEGER  :: WSELEM(NOD1:NOD3),X1AXIS
REAL(EB) :: X1V(NOD1:NOD3)

NAMELIST /GEOM/ AUTO_TEXTURE, AZIM, AZIM_DOT, COMPONENT_ONLY, CUTCELLS, DAZIM, DELEV, DSCALE, DT_BNDC, DT_GEOC, DXYZ0, DXYZ, &
                ELEV, ELEV_DOT, FACES, GAXIS, GEOM_IDS, GROTATE, GROTATE_DOT, ID, IJK, &
                MATL_ID, N_LAT, N_LEVELS, N_LONG, SCALE, SCALE_DOT, &
                SPHERE_ORIGIN, SPHERE_RADIUS, SPHERE_TYPE, SURF_ID,  &
                TEXTURE_MAPPING, TEXTURE_ORIGIN, TEXTURE_SCALE, &
                VERTS, VOLUS, XB, XYZ0, XYZ, XYZ_DOT, ZMIN, ZVALS, &
                BNDC_FILENAME, GEOC_FILENAME

! first pass - determine max number of ZVALS, VERTS, FACES, VOLUS and IDS over all &GEOMs

N_GEOMETRY=0
REWIND(LU_INPUT) ; INPUT_FILE_LINE_NUMBER = 0
COUNT_GEOM_LOOP: DO
   CALL CHECKREAD('GEOM',LU_INPUT,IOS)
   IF (IOS==1) EXIT COUNT_GEOM_LOOP
   READ(LU_INPUT,'(A)')BUFFER
   N_GEOMETRY=N_GEOMETRY+1
   CALL GET_GEOM_INFO(MAX_ZVALS,MAX_VERTS,MAX_FACES,MAX_VOLUS,MAX_IDS,MAX_SURF_IDS) ! LU_INPUT not currently used.
ENDDO COUNT_GEOM_LOOP
REWIND(LU_INPUT) ; INPUT_FILE_LINE_NUMBER = 0
IF (N_GEOMETRY==0) RETURN

! allocate temporary buffers used when reading &GEOM namelists

CALL ALLOCATE_BUFFERS

! second pass - count and check &GEOM lines

N_GEOMETRY=0

REWIND(LU_INPUT) ; INPUT_FILE_LINE_NUMBER = 0
COUNT_GEOM_LOOP2: DO
   CALL CHECKREAD('GEOM',LU_INPUT,IOS)
   IF (IOS==1) EXIT COUNT_GEOM_LOOP2
   READ(LU_INPUT,NML=GEOM,END=21,ERR=22,IOSTAT=IOS)
   N_GEOMETRY=N_GEOMETRY+1
   22 IF (IOS>0) CALL SHUTDOWN('ERROR: problem with GEOM line')
ENDDO COUNT_GEOM_LOOP2
21 REWIND(LU_INPUT) ; INPUT_FILE_LINE_NUMBER = 0
IF (N_GEOMETRY==0) RETURN

! Allocate GEOMETRY array

ALLOCATE(GEOMETRY(0:N_GEOMETRY),STAT=IZERO)
CALL ChkMemErr('READ_GEOM','GEOMETRY',IZERO)

ALLOCATE(DEFAULT_COMPONENT_ONLY(N_GEOMETRY),STAT=IZERO)
CALL ChkMemErr('READ_GEOM','DEFAULT_COMPONENT_ONLY',IZERO)

! third pass - check for groups

! set default for COMPONENT_ONLY
!   if an object is in a GEOM_IDS list then COMPONENT_ONLY for this object is initially
!       set to .TRUE. (is only drawn as part of a larger group)
!   if an object is not in any GEOM_IDS list then COMPONENT_ONLY for this object is initially
!       set to .FALSE. (is drawn by default)
READ_GEOM_LOOP0: DO N=1,N_GEOMETRY
   G=>GEOMETRY(N)

   CALL CHECKREAD('GEOM',LU_INPUT,IOS)
   IF (IOS==1) EXIT READ_GEOM_LOOP0

   ! Set defaults
   GEOM_IDS = ''
   BNDC_FILENAME = 'null'
   GEOC_FILENAME = 'null'

   ! Read the GEOM line

   READ(LU_INPUT,GEOM,END=25)

   DEFAULT_COMPONENT_ONLY(N) = .FALSE.
   DO I = 1, MAX_IDS
      IF (GEOM_IDS(I)=='') EXIT
      IF (N>1) THEN
         GEOM_INDEX = GET_GEOM_ID(GEOM_IDS(I),N-1)
         IF (GEOM_INDEX>=1 .AND. GEOM_INDEX<=N-1) THEN
            DEFAULT_COMPONENT_ONLY(GEOM_INDEX) = .TRUE.
         ENDIF
      ENDIF
   ENDDO

ENDDO READ_GEOM_LOOP0
25 REWIND(LU_INPUT) ; INPUT_FILE_LINE_NUMBER = 0

! fourth pass - read GEOM data

READ_GEOM_LOOP: DO N=1,N_GEOMETRY
   G=>GEOMETRY(N)

   CALL CHECKREAD('GEOM',LU_INPUT,IOS)
   IF (IOS==1) EXIT READ_GEOM_LOOP

   CALL SET_GEOM_DEFAULTS
   READ(LU_INPUT,GEOM,END=35)

   ! count VERTS

   N_VERTS=0
   DO I = 1, MAX_VERTS
      IF (ANY(VERTS(3*I-2:3*I)>=MAX_VAL)) EXIT
      N_VERTS = N_VERTS+1
   ENDDO

   ! count FACES

   N_FACES=0
   DO I = 1, MAX_FACES
      IF (ANY(FACES(4*(I-1)+1:4*(I-1)+3)==0)) EXIT
      N_FACES = N_FACES+1
   ENDDO
   ! Now split FACES array into FACES (connectivity), and SURFS, i.e. local surf ID:
   IF(N_FACES > 0) THEN
      IF(ALLOCATED(SURFS)) DEALLOCATE(SURFS); ALLOCATE(SURFS(N_FACES))
      DO I = 1, N_FACES
         FACES(3*(I-1)+1:3*(I-1)+3) = FACES(4*(I-1)+1:4*(I-1)+3)
         SURFS(I)                   = FACES(4*(I-1)+4)
      ENDDO
   ENDIF
   TFACES(1:6*MAX_FACES) = -1.0_EB

   ! count VOLUS

   N_VOLUS=0
   DO I = 1, MAX_VOLUS
      IF (ANY(VOLUS(4*I-3:4*I)==0)) EXIT
      N_VOLUS = N_VOLUS+1
   ENDDO

   ! count ZVALS

   N_ZVALS=0
   DO I = 1, MAX_ZVALS
      IF (ZVALS(I)>MAX_VAL) EXIT
      N_ZVALS=N_ZVALS+1
   ENDDO

   !--- setup a 2D surface (terrain) object (ZVALS keyword )

   ZVALS_IF: IF (N_ZVALS>0) THEN
      GEOM_TYPE = 3
      CALL CHECK_XB(XB)
      IF (N_ZVALS/=IJK(1)*IJK(2) ) THEN
         WRITE(MESSAGE,'(A,I4,A,I4)') 'ERROR: Expected ',IJK(1)*IJK(2),' Z values, found ',N_ZVALS
         CALL SHUTDOWN(MESSAGE)
      ENDIF
      IF (IJK(1)<2 .OR. IJK(2)<2) THEN
         CALL SHUTDOWN('ERROR: IJK(1) and IJK(2) on &GEOM line  needs to be at least 2')
      ENDIF
      NXB=0
      DO I = 1, 4 ! first 4 XB values must be set, don't care about 5th and 6th
        IF (XB(I)<MAX_VAL) NXB=NXB+1
      ENDDO
      IF (NXB<4) THEN
         CALL SHUTDOWN('ERROR: At least 4 XB values (xmin, xmax, ymin, ymax) required when using ZVALS')
      ENDIF
      ALLOCATE(G%ZVALS(N_ZVALS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','G%ZVALS',IZERO)
      N_FACES=2*(IJK(1)-1)*(IJK(2)-1)
      N_VERTS=IJK(1)*IJK(2)

      ! define terrain vertices

      IJ = 1
      DO J = 1, IJK(2)
         DO I = 1, IJK(1)
            VERTS(3*IJ-2) = (XB(1)*REAL(IJK(1)-I,EB) + XB(2)*REAL(I-1,EB))/REAL(IJK(1)-1,EB)
            VERTS(3*IJ-1) = (XB(3)*REAL(IJK(2)-J,EB) + XB(4)*REAL(J-1,EB))/REAL(IJK(2)-1,EB)
            VERTS(3*IJ) = ZVALS(IJ)
            IJ = IJ + 1
         ENDDO
      ENDDO

! define terrain faces
!        8 ---- 7
!       /|     /|
!     5 ----- 6 |
!     |  |    | |
!     |  |    | |
!     |  |    | |
!     |  4 ---- 3
!     | /     |/
!     1 ----  2


      IJ = 1
      DO J = 1, IJK(2) - 1
         DO I = 1, IJK(1) - 1
            I1 = (J-1)*IJK(1) + I
            I2 = I1 + 1
            I3 = I2 + IJK(1)
            I4 = I3 - 1

            FACES(3*IJ-2) = I1
            FACES(3*IJ-1) = I2
            FACES(3*IJ) = I3
            IJ = IJ + 1

            FACES(3*IJ-2) = I1
            FACES(3*IJ-1) = I3
            FACES(3*IJ) = I4
            IJ = IJ + 1
         ENDDO
      ENDDO
      N_FACES = IJ - 1

      DO I = 1, N_VERTS
         VNEW=>VERTS(3*N_VERTS+3*I-2:3*N_VERTS+3*I)
         VOLD=>VERTS(3*I-2:3*I)
         VNEW(1:3)=(/VOLD(1:2),ZMIN/)
      ENDDO
      N_VERTS=2*N_VERTS


      IJ = 1
      DO J = 1, IJK(2) - 1
         DO I = 1, IJK(1) - 1
            I1 = (J-1)*IJK(1) + I
            I2 = I1 + 1
            I3 = I2 + IJK(1)
            I4 = I3 - 1

            I5 = I1 + N_VERTS/2
            I6 = I2 + N_VERTS/2
            I7 = I3 + N_VERTS/2
            I8 = I4 + N_VERTS/2

!     8-------7
!   / .     / |
! 5-------6   |
! |   .   |   |
! |   .   |   |
! |   4-------3
! | /     | /
! 1-------2

! split box into 6 tetrahedra using: https://www.ics.uci.edu/~eppstein/projects/tetra/

            VOLUS(4*IJ-3) = I1
            VOLUS(4*IJ-2) = I2
            VOLUS(4*IJ-1) = I6
            VOLUS(4*IJ-0) = I7
            IJ = IJ + 1

            VOLUS(4*IJ-3) = I1
            VOLUS(4*IJ-2) = I3
            VOLUS(4*IJ-1) = I2
            VOLUS(4*IJ-0) = I7
            IJ = IJ + 1

            VOLUS(4*IJ-3) = I1
            VOLUS(4*IJ-2) = I6
            VOLUS(4*IJ-1) = I5
            VOLUS(4*IJ-0) = I7
            IJ = IJ + 1

            VOLUS(4*IJ-3) = I1
            VOLUS(4*IJ-2) = I4
            VOLUS(4*IJ-1) = I3
            VOLUS(4*IJ-0) = I7
            IJ = IJ + 1

            VOLUS(4*IJ-3) = I1
            VOLUS(4*IJ-2) = I7
            VOLUS(4*IJ-1) = I5
            VOLUS(4*IJ-0) = I8
            IJ = IJ + 1

            VOLUS(4*IJ-3) = I1
            VOLUS(4*IJ-2) = I7
            VOLUS(4*IJ-1) = I8
            VOLUS(4*IJ-0) = I4
            IJ = IJ + 1
         ENDDO
      ENDDO
      N_VOLUS=IJ - 1
      N_FACES=0
   ENDIF ZVALS_IF

   !--- setup a block object (XB keyword )

   NXB=0
   DO I = 1, 6
      IF (XB(I)<MAX_VAL) NXB=NXB+1
   ENDDO
   IF (NXB==6 .AND. N_ZVALS==0) THEN
      GEOM_TYPE = 1
      CALL CHECK_XB(XB)
      G%XB=XB

      ! make IJK(1), IJK(2), IJK(3) consistent with grid resolution (if not specified on &GEOM line)

      M => MESHES(1)
      DX = MIN(M%DXMIN,M%DYMIN,M%DZMIN)
      IF (IJK(1)<2) IJK(1) = MAX(2,INT((XB(2)-XB(1)/DX)+1))
      IF (IJK(2)<2) IJK(2) = MAX(2,INT((XB(4)-XB(3)/DX)+1))
      IF (IJK(3)<2) IJK(3) = MAX(2,INT((XB(6)-XB(5)/DX)+1))

! define verts in box

      N_VERTS = 0
      DO K = 0, IJK(3)-1
         BOX_XYZ(3) = (REAL(IJK(3)-1-K,EB)*XB(5) + REAL(K,EB)*XB(6))/REAL(IJK(3)-1,EB)
         DO J = 0, IJK(2)-1
            BOX_XYZ(2) = (REAL(IJK(2)-1-J,EB)*XB(3) + REAL(J,EB)*XB(4))/REAL(IJK(2)-1,EB)
            DO I = 0, IJK(1)-1
               BOX_XYZ(1) = (REAL(IJK(1)-1-I,EB)*XB(1) + REAL(I,EB)*XB(2))/REAL(IJK(1)-1,EB)
               VERTS(3*N_VERTS+1:3*N_VERTS+3) =  BOX_XYZ(1:3)
               N_VERTS = N_VERTS + 1
            ENDDO
         ENDDO
      ENDDO

! define tetrahedrons in box

      N_VOLUS = 0
      NI = IJK(1)
      NIJ = IJK(1)*IJK(2)
      DO K = 0, IJK(3)-2
         DO J = 0, IJK(2)-2
            DO I = 0, IJK(1)-2

!     8-------7
!   / .     / |
! 5-------6   |
! |   .   |   |
! |   .   |   |
! |   4-------3
! | /     | /
! 1-------2
               BOXVERTLIST(1) = K*NIJ + J*NI + I + 1
               BOXVERTLIST(2) = BOXVERTLIST(1) + 1
               BOXVERTLIST(3) = BOXVERTLIST(2) + NI
               BOXVERTLIST(4) = BOXVERTLIST(3) - 1
               BOXVERTLIST(5) = BOXVERTLIST(1) + NIJ
               BOXVERTLIST(6) = BOXVERTLIST(2) + NIJ
               BOXVERTLIST(7) = BOXVERTLIST(3) + NIJ
               BOXVERTLIST(8) = BOXVERTLIST(4) + NIJ
               CALL BOX2TETRA(BOXVERTLIST,VOLUS(4*N_VOLUS+1:4*N_VOLUS+20))
               N_VOLUS = N_VOLUS + 5
            ENDDO
         ENDDO
      ENDDO
      N_FACES=0
   ENDIF

   ! setup a sphere object (SPHERE_RADIUS and SPHERE_ORIGIN keywords)

   IF (SPHERE_RADIUS<MAX_VAL .AND. &
      SPHERE_ORIGIN(1)<MAX_VAL .AND. SPHERE_ORIGIN(2)<MAX_VAL .AND. SPHERE_ORIGIN(3)<MAX_VAL) THEN
      GEOM_TYPE = 2

      M => MESHES(1)
      DX = M%DXMIN

      ! 2*PI*R/(5*2^N_LEVELS) ~= DX,   solve for N_LEVELS

      IF (SPHERE_RADIUS<100.0_EB*TWO_EPSILON_EB) SPHERE_RADIUS = 100.0_EB*TWO_EPSILON_EB

      IF (SPHERE_TYPE/=2) SPHERE_TYPE = 1
      IF (N_LEVELS<0 .AND. N_LAT>0 .AND. N_LONG>0) SPHERE_TYPE = 2
      IF (SPHERE_TYPE==1) THEN
         IF (N_LEVELS==-1) N_LEVELS = INT(LOG(2.0_EB*PI*SPHERE_RADIUS/(5.0_EB*DX))/LOG(2.0_EB))
         N_LEVELS = MIN(7,MAX(0,N_LEVELS))
      ELSE
         IF (N_LONG<6) N_LONG = MAX(6,INT(2.0_EB*PI*SPHERE_RADIUS/DX)+1)
         IF (N_LAT<3)  N_LAT = MAX(3,INT(PI*SPHERE_RADIUS/DX)+1)
      ENDIF

      IF (SPHERE_TYPE==1) THEN
         CALL INIT_SPHERE(N_LEVELS,N_VERTS,N_FACES,MAX_VERTS,MAX_FACES,VERTS,FACES)
      ELSE
         CALL INIT_SPHERE2(N_VERTS,N_FACES,N_LAT,N_LONG,VERTS,FACES)
      ENDIF
      CALL EXTRUDE_SPHERE(ZERO3,VERTS,MAX_VERTS,N_VERTS,FACES,N_FACES,VOLUS,MAX_VOLUS, N_VOLUS)
      N_FACES=0;

      DO I = 0, N_VERTS-1
         VERTS(3*I+1:3*I+3) = SPHERE_ORIGIN(1:3) + SPHERE_RADIUS*VERTS(3*I+1:3*I+3)
      ENDDO
   ENDIF

   G%N_LEVELS = N_LEVELS
   G%SPHERE_ORIGIN = SPHERE_ORIGIN
   G%SPHERE_RADIUS = SPHERE_RADIUS
   G%IJK = IJK
   G%COMPONENT_ONLY = COMPONENT_ONLY
   G%GEOM_TYPE = GEOM_TYPE
   G%BNDC_FILENAME = BNDC_FILENAME
   G%GEOC_FILENAME = GEOC_FILENAME

   IF (GEOC_FILENAME/='null' .AND. N_GEOMETRY > 1 ) THEN
      CALL SHUTDOWN('ERROR: only one &GEOM line permitted when defining coupled geometries (the GEOC_FILENAME keyword)')
   ENDIF

   !--- setup groups

   NSUB_GEOMS = 0
   DO I = 1, MAX_IDS
      IF (GEOM_IDS(I)=='') EXIT
      NSUB_GEOMS = NSUB_GEOMS+1
   ENDDO
   IF (NSUB_GEOMS>0) THEN
      ALLOCATE(G%SUB_GEOMS(NSUB_GEOMS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','G%SUB_GEOMS',IZERO)

      ALLOCATE(G%DSCALE(3,NSUB_GEOMS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','G%DSCALE',IZERO)

      ALLOCATE(G%DAZIM(NSUB_GEOMS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','G%DAZIM',IZERO)

      ALLOCATE(G%DELEV(NSUB_GEOMS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','G%DELEV',IZERO)

      ALLOCATE(G%DXYZ0(3,NSUB_GEOMS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','G%DXYZ0',IZERO)

      ALLOCATE(G%DXYZ(3,NSUB_GEOMS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','G%DXYZ',IZERO)

      N_FACES = 0 ! ignore vertex and face entries if there are any GEOM_IDS
      N_VERTS = 0
      N_VOLUS = 0
   ENDIF
   G%NSUB_GEOMS=NSUB_GEOMS

   ! remove duplicate vertices

   FIRST_FACE_INDEX=1
   CALL REMOVE_DUPLICATE_VERTS(N_VERTS,N_FACES,N_VOLUS,MAX_VERTS,MAX_FACES,MAX_VOLUS,FIRST_FACE_INDEX,VERTS,FACES,VOLUS)

   ! wrap up

   G%ID = ID
   G%N_VOLUS_BASE = N_VOLUS
   G%N_FACES_BASE = N_FACES
   G%N_VERTS_BASE = N_VERTS

   ! Check if SURF_ID(1) has been defined:
   N_SURF_ID = 0
   IF (TRIM(SURF_ID(1))=='null') THEN
      SURF_INDEX_PER_FACE = .FALSE.
      HAVE_SURF = .FALSE.
      ALLOCATE(G%SURF_ID(1)); G%SURF_ID(1) = 'null'
   ELSE
      SURF_INDEX_PER_FACE = .TRUE.
      ! Check that elements of the list of SURF_IDs are in list of SURFS:
      ! How many SURF_ID entries are different than Null, where in SURFACE they belong:
      DO I = 1, MAX_SURF_IDS
         IF( SURF_ID(I)=='null' ) EXIT ! First 'null'
         N_SURF_ID = N_SURF_ID + 1
      ENDDO
      ALLOCATE(G%SURF_ID(1:N_SURF_ID)); G%SURF_ID(1:N_SURF_ID) = SURF_ID(1:N_SURF_ID)

      ! Now find correspondence with SURFACE(N)%ID:
      IF (ALLOCATED(SURF_ID_IND)) DEALLOCATE(SURF_ID_IND); ALLOCATE(SURF_ID_IND(N_SURF_ID))
      DO I = 1, N_SURF_ID
          ! Get Surf Index:
          IN_LIST = .FALSE.
          DO J = 0, N_SURF
             IF (TRIM(SURF_ID(I))/=TRIM(SURFACE(J)%ID)) CYCLE
             SURF_ID_IND(I)=J
             IN_LIST = .TRUE.
             EXIT
          ENDDO
          IF(.NOT.IN_LIST) THEN
             WRITE(MESSAGE,'(A,I4,3A)') &
             'ERROR: problem with GEOM, the surface IDV(',I,') =',TRIM(SURF_ID(I)),' is not defined.'
             CALL SHUTDOWN(MESSAGE)
          ENDIF
      ENDDO
   ENDIF
   G%HAVE_SURF = HAVE_SURF

   IF (MATL_ID=='null') THEN
      HAVE_MATL = .FALSE.
   ENDIF
   G%MATL_ID = MATL_ID
   G%HAVE_MATL = HAVE_MATL

   IF (.NOT.AUTO_TEXTURE .AND. N_VERTS>0) THEN

      TXMIN = VERTS(1)
      TXMAX = TXMIN
      TYMIN = VERTS(2)
      TYMAX = TYMIN
      DO I = 1, N_VERTS
         TX = VERTS(3*I-2)
         TY = VERTS(3*I-1)
         IF (TX<TXMIN)TXMIN=TX
         IF (TX>TXMAX)TXMAX=TX
         IF (TY<TYMIN)TYMIN=TY
         IF (TY>TYMAX)TYMAX=TY
      ENDDO
      TEXTURE_ORIGIN(1)=TXMIN
      TEXTURE_ORIGIN(2)=TYMIN
      TEXTURE_SCALE(1)=TXMAX-TXMIN
      TEXTURE_SCALE(2)=TYMAX-TYMIN
   ENDIF

   G%TEXTURE_ORIGIN = TEXTURE_ORIGIN
   G%TEXTURE_SCALE = TEXTURE_SCALE
   G%AUTO_TEXTURE = AUTO_TEXTURE
   IF ( TRIM(TEXTURE_MAPPING)/='SPHERICAL' .AND. TRIM(TEXTURE_MAPPING)/='RECTANGULAR') TEXTURE_MAPPING = 'RECTANGULAR'
   G%TEXTURE_MAPPING = TEXTURE_MAPPING

   ! setup volumes

   IF (N_VOLUS>0) THEN
      ALLOCATE(G%VOLUS(4*N_VOLUS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','G%VOLUS',IZERO)
      DO I = 0, N_VOLUS-1
         VOL(1:4)=> VOLUS(4*I+1:4*I+4)
         V1(1:3) => VERTS(3*VOL(1)-2:3*VOL(1))
         V2(1:3) => VERTS(3*VOL(2)-2:3*VOL(2))
         V3(1:3) => VERTS(3*VOL(3)-2:3*VOL(3))
         V4(1:3) => VERTS(3*VOL(4)-2:3*VOL(4))
         VOLUME = TETRAHEDRON_VOLUME(V3,V4,V2,V1)
         IF ( VOLUME<0.0_EB ) THEN ! reorder vertices if tetrahedron volume is negative
            IVOL=VOL(3)
            VOL(3)=VOL(4)
            VOL(4)=IVOL
         ENDIF
      ENDDO
      G%VOLUS(1: 4*N_VOLUS) = VOLUS(1:4*N_VOLUS)
      IF (ANY(VOLUS(1:4*N_VOLUS)<1 .OR. VOLUS(1:4*N_VOLUS)>N_VERTS)) THEN
         CALL SHUTDOWN('ERROR: problem with GEOM, vertex index out of bounds')
      ENDIF

      ALLOCATE(G%MATLS(N_VOLUS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','G%MATLS',IZERO)
      MATL_INDEX = GET_MATL_INDEX(MATL_ID)
      IF (MATL_INDEX==0) THEN
         IF (TRIM(MATL_ID)=='null') THEN
           WRITE(MESSAGE,'(A)') 'ERROR: problem with GEOM, the material keyword, MATL_ID, is not defined.'
         ELSE
           WRITE(MESSAGE,'(3A)') 'ERROR: problem with GEOM, the material ',TRIM(MATL_ID),' is not defined.'
         ENDIF
         CALL SHUTDOWN(MESSAGE)
      ENDIF
      G%MATLS(1:N_VOLUS) = MATL_INDEX

      ! construct an array of external faces

      ! determine which tetrahedron faces are external

      IF (N_FACES==0) THEN
         N_FACES = 4*N_VOLUS
         IF(ALLOCATED(IS_EXTERNAL)) DEALLOCATE(IS_EXTERNAL)
         ALLOCATE(IS_EXTERNAL(0:N_FACES-1),STAT=IZERO)
         CALL ChkMemErr('READ_GEOM','IS_EXTERNAL',IZERO)

         IS_EXTERNAL(0:N_FACES-1)=.TRUE.  ! start off by assuming all faces are external

! reorder face indices so the the first index is always the smallest


!              1
!             /|\                       .
!            / | \                      .
!           /  |  \                     .
!          /   |   \                    .
!         /    |    \                   .
!        /     4     \                  .
!       /     . .     \                 .
!      /     .    .    \                .
!     /    .        .   \               .
!    /   .            .  \              .
!   /  .               .  \             .
!  / .                    .\            .
! 2-------------------------3

         DO I = 0, N_VOLUS-1
            FACES(12*I+1) = VOLUS(4*I+1)
            FACES(12*I+2) = VOLUS(4*I+2)
            FACES(12*I+3) = VOLUS(4*I+3)
            CALL REORDER_VERTS(FACES(12*I+1:12*I+3))

            FACES(12*I+4) = VOLUS(4*I+1)
            FACES(12*I+5) = VOLUS(4*I+3)
            FACES(12*I+6) = VOLUS(4*I+4)
            CALL REORDER_VERTS(FACES(12*I+4:12*I+6))

            FACES(12*I+7) = VOLUS(4*I+1)
            FACES(12*I+8) = VOLUS(4*I+4)
            FACES(12*I+9) = VOLUS(4*I+2)
            CALL REORDER_VERTS(FACES(12*I+7:12*I+9))

            FACES(12*I+10) = VOLUS(4*I+2)
            FACES(12*I+11) = VOLUS(4*I+4)
            FACES(12*I+12) = VOLUS(4*I+3)
            CALL REORDER_VERTS(FACES(12*I+10:12*I+12))
         ENDDO

         ! find faces that match

         SORT_FACES=2
         IF (GEOM_TYPE == 2) SORT_FACES = 3 ! Case of sphere.

         IF (SORT_FACES==1 ) THEN  ! o(n*log(n)) algorithm for determining external faces
            ALLOCATE(OFACES(N_FACES),STAT=IZERO)
            CALL ChkMemErr('READ_GEOM','OFACES',IZERO)
            CALL ORDER_FACES(OFACES,N_FACES)
            DO I = 1, N_FACES-1
               FACEI=>FACES(3*OFACES(I)-2:3*OFACES(I))
               FACEJ=>FACES(3*OFACES(I)+1:3*OFACES(I)+3)
               IF (FACEI(1)==FACEJ(1) .AND. &
                  MIN(FACEI(2),FACEI(3))==MIN(FACEJ(2),FACEJ(3)) .AND. &
                  MAX(FACEI(2),FACEI(3))==MAX(FACEJ(2),FACEJ(3))) THEN
                  IS_EXTERNAL(OFACES(I))=.FALSE.
                  IS_EXTERNAL(OFACES(I-1))=.FALSE.
                  IF (FACEI(2)==FACEJ(2) .AND. FACEI(3)==FACEJ(3)) THEN
                     WRITE(LU_ERR,*) 'WARNING: duplicate faces found:', FACEI(1),FACEI(2),FACEI(3)
                  ENDIF
               ENDIF
            ENDDO
            DEALLOCATE(OFACES)
         ELSEIF(SORT_FACES==2 ) THEN
            DO I = 0, N_FACES-1  ! o(n^2) algorithm for determining external faces
               FACEI=>FACES(3*I+1:3*I+3)
               DO J = 0, N_FACES-1
                  IF (I==J) CYCLE
                  FACEJ=>FACES(3*J+1:3*J+3)
                  IF (FACEI(1)/=FACEJ(1)) CYCLE
                  IF ((FACEI(2)==FACEJ(2) .AND. FACEI(3)==FACEJ(3)) .OR. &
                     (FACEI(2)==FACEJ(3) .AND. FACEI(3)==FACEJ(2))) THEN
                     IS_EXTERNAL(I) = .FALSE.
                     IS_EXTERNAL(J) = .FALSE.
                  ENDIF
               ENDDO
            ENDDO
         ELSEIF(SORT_FACES==3 ) THEN
            DO I = 0,N_FACES-1
               ! Check that no verts are at the spheres center:
               DO II=1,3
                  II1=FACES(3*I+II)
                  IF ( SQRT((VERTS(3*II1-2)-SPHERE_ORIGIN(IAXIS))**2 + &
                            (VERTS(3*II1-1)-SPHERE_ORIGIN(JAXIS))**2 + &
                            (VERTS(3*II1  )-SPHERE_ORIGIN(KAXIS))**2) < GEOMEPS) &
                       IS_EXTERNAL(I) = .FALSE.
               ENDDO
            ENDDO
         ENDIF

         ! create new FACES index array keeping only external faces

         N_FACES_TEMP = N_FACES
         N_FACES=0
         DO I = 0, N_FACES_TEMP-1
            FACE_FROM=>FACES(3*I+1:3*I+3)
            ! Drop triangles with zero area:
            IF ( (FACE_FROM(1)==FACE_FROM(2)).OR.(FACE_FROM(1)==FACE_FROM(3)).OR.(FACE_FROM(2)==FACE_FROM(3)) ) CYCLE
            IF (IS_EXTERNAL(I)) THEN
               FACE_TO=>FACES(3*N_FACES+1:3*N_FACES+3)
               FACE_TO(1:3) = FACE_FROM(1:3)
               N_FACES=N_FACES+1
            ENDIF
         ENDDO
         G%N_FACES_BASE = N_FACES

         IF (GEOM_TYPE == 2) THEN
            DO I = 0,N_FACES-1
               ! Check that no verts are at the spheres center:
               DO II=1,3
                  II1=FACES(3*I+II)
                  IF ( SQRT((VERTS(3*II1-2)-SPHERE_ORIGIN(IAXIS))**2 + &
                            (VERTS(3*II1-1)-SPHERE_ORIGIN(JAXIS))**2 + &
                            (VERTS(3*II1  )-SPHERE_ORIGIN(KAXIS))**2) < GEOMEPS) &
                     WRITE(LU_ERR,*) 'On External Faces, face/vertex ',I,II,II1,' located at center.'
               ENDDO
               II1=FACES(3*I+1)
               II2=FACES(3*I+2)
               II3=FACES(3*I+3)
               DV1(IAXIS:KAXIS)= VERTS(3*II2-2:3*II2) - VERTS(3*II1-2:3*II1)
               DV2(IAXIS:KAXIS)= VERTS(3*II3-2:3*II3) - VERTS(3*II1-2:3*II1)
               CALL CROSS_PRODUCT(NVECI,DV1,DV2)
               DXCEN= 1._EB/3._EB*(VERTS(3*II1-2:3*II1)+VERTS(3*II2-2:3*II2)+VERTS(3*II3-2:3*II3)) - &
                                   SPHERE_ORIGIN(IAXIS:KAXIS)
               DOTI = NVECI(IAXIS)*DXCEN(IAXIS) + NVECI(JAXIS)*DXCEN(JAXIS) + NVECI(KAXIS)*DXCEN(KAXIS)

               IF (SIGN(1._EB,DOTI) < 0._EB) THEN
                  WRITE(LU_ERR,*) I,' has (-) sign normal.'
                  FACES(3*I+2) = II3
                  FACES(3*I+3) = II2
               ENDIF
            ENDDO
         ENDIF
         CALL COMPUTE_TEXTURES(VERTS,FACES,TFACES,MAX_VERTS,MAX_FACES,N_FACES)

         ! Surf IDs for generated GEOM:
         IF(ALLOCATED(SURFS)) DEALLOCATE(SURFS); ALLOCATE(SURFS(N_FACES))
         IF(SURF_INDEX_PER_FACE) THEN
            SURFS(:) = 1 ! All external faces point to only entry SURF_ID(1).
         ELSE
            SURFS(:) = 0 ! All external faces point to default surf ID.
         ENDIF
      ENDIF
   ENDIF

   IF (N_FACES>0) THEN
      ALLOCATE(G%FACES(3*N_FACES),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','G%FACES',IZERO)
      G%FACES(1:3*N_FACES) = FACES(1:3*N_FACES)

      IF ( ANY(FACES(1:3*N_FACES)<1 .OR. FACES(1:3*N_FACES)>N_VERTS) ) THEN
         CALL SHUTDOWN('ERROR: problem with GEOM, vertex index out of bounds')
      ENDIF

      ALLOCATE(G%TFACES(6*N_FACES),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','G%TFACES',IZERO)
      G%TFACES(1:6*N_FACES) = TFACES(1:6*N_FACES)

      ALLOCATE(G%SURFS(N_FACES),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','G%SURFS',IZERO)

      IF (SURF_INDEX_PER_FACE) THEN
         DO I=1,N_FACES
            IF ( SURFS(I) <= 0 ) THEN
               G%SURFS(I) = DEFAULT_SURF_INDEX    ! If local SURF ID index <= 0, use default surf ID.
            ELSE
               G%SURFS(I) = SURF_ID_IND(SURFS(I))
            ENDIF
         ENDDO
         DEALLOCATE(SURF_ID_IND)
      ELSE
         !If any of surfs is greater than zero throw an error:
         DO I=1,N_FACES
            IF ( SURFS(I) <= 0 ) CYCLE
            WRITE(MESSAGE,'(A,I4,3A)') &
            'ERROR: problem with GEOM, surface ID not defined, but surf ID index of FACE ',I,' is > 0.'
            CALL SHUTDOWN(MESSAGE)
            EXIT
         ENDDO
         G%SURFS(1:N_FACES) = DEFAULT_SURF_INDEX
      ENDIF
   ENDIF

   IF (N_VERTS>0) THEN
      ALLOCATE(G%VERTS_BASE(3*N_VERTS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','G%VERTS_BASE',IZERO)
      G%VERTS_BASE(1:3*N_VERTS) = VERTS(1:3*N_VERTS)

      ALLOCATE(G%VERTS(3*N_VERTS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','G%VERTS',IZERO)
   ENDIF

   DO I = 1, NSUB_GEOMS
      GEOM_INDEX = GET_GEOM_ID(GEOM_IDS(I),N-1)
      IF (GEOM_INDEX>=1 .AND. GEOM_INDEX<=N-1) THEN
         G%SUB_GEOMS(I) = GEOM_INDEX
      ELSE
         CALL SHUTDOWN('ERROR: problem with GEOM '//TRIM(G%ID)//' line, '//TRIM(GEOM_IDS(I))//' not yet defined.')
      ENDIF
   ENDDO

   ! use GROTATE/GAXIS or AZIM/ELEV but not both

   IF (ANY(GAXIS(1:3)<MAX_VAL) .OR. GROTATE<MAX_VAL .OR. GROTATE_DOT<MAX_VAL) THEN
      IF (GAXIS(1)>MAX_VAL) GAXIS(1) = 0.0_EB
      IF (GAXIS(2)>MAX_VAL) GAXIS(2) = 0.0_EB
      IF (GAXIS(3)>MAX_VAL) GAXIS(3) = 0.0_EB
      AZIM = 0.0_EB
      ELEV = 0.0_EB
      AZIM_DOT = 0.0_EB
      ELEV_DOT = 0.0_EB

      IF (GROTATE>MAX_VAL) GROTATE = 0.0_EB
      IF (GROTATE_DOT>MAX_VAL) GROTATE_DOT = 0.0_EB

      IF (ALL(ABS(GAXIS(1:3))<TWO_EPSILON_EB)) THEN
         GAXIS(1:3) = (/0.0_EB,0.0_EB,1.0_EB/)
      ELSE
         GAXIS = GAXIS/SQRT(DOT_PRODUCT(GAXIS,GAXIS))
      ENDIF
   ELSE
      GAXIS(1:3) = (/0.0_EB,0.0_EB,1.0_EB/)
      GROTATE = 0.0_EB
      GROTATE_DOT = 0.0_EB
   ENDIF

   G%XYZ0(1:3) = XYZ0(1:3)

   G%GAXIS = GAXIS
   G%GROTATE = GROTATE
   G%GROTATE_BASE = GROTATE
   G%GROTATE_DOT = GROTATE_DOT

   G%AZIM_BASE = AZIM
   G%AZIM_DOT = AZIM_DOT

   G%ELEV_BASE = ELEV
   G%ELEV_DOT = ELEV_DOT

   G%SCALE_BASE = SCALE
   G%SCALE_DOT(1:3) = SCALE_DOT(1:3)

   G%XYZ_BASE(1:3) = XYZ(1:3)
   G%XYZ_DOT(1:3) = XYZ_DOT(1:3)

   IF (ABS(AZIM_DOT)>TWO_EPSILON_EB .OR. ABS(ELEV_DOT)>TWO_EPSILON_EB .OR. &
       ANY(ABS(SCALE_DOT(1:3))>TWO_EPSILON_EB) .OR. ANY(ABS(XYZ_DOT(1:3) )>TWO_EPSILON_EB) .OR. GEOC_FILENAME/='null' ) THEN
      G%IS_DYNAMIC = .TRUE.
      IS_GEOMETRY_DYNAMIC = .TRUE.
   ELSE
      G%IS_DYNAMIC = .FALSE.
   ENDIF

   NSUB_GEOMS_IF: IF (NSUB_GEOMS>0) THEN

      ! if any component of a group is time dependent then the whole group is time dependent

      DO I = 1, NSUB_GEOMS
         GSUB=>GEOMETRY(G%SUB_GEOMS(I))

         IF (GSUB%IS_DYNAMIC) THEN
            G%IS_DYNAMIC = .TRUE.
            IS_GEOMETRY_DYNAMIC = .TRUE.
            EXIT
         ENDIF
      ENDDO

      G%DXYZ0(1:3,1:NSUB_GEOMS) = DXYZ0(1:3,1:NSUB_GEOMS)

      G%DAZIM(1:NSUB_GEOMS) = DAZIM(1:NSUB_GEOMS)
      G%DELEV(1:NSUB_GEOMS) = DELEV(1:NSUB_GEOMS)
      G%DSCALE(1:3,1:NSUB_GEOMS) = DSCALE(1:3,1:NSUB_GEOMS)
      G%DXYZ(1:3,1:NSUB_GEOMS) = DXYZ(1:3,1:NSUB_GEOMS)

      ! allocate memory for vertex and face arrays for GEOMs that contain groups (entres in GEOM_IDs )

      DO I = 1, NSUB_GEOMS
         GSUB=>GEOMETRY(G%SUB_GEOMS(I))
         G%N_VOLUS_BASE = G%N_VOLUS_BASE + GSUB%N_VOLUS_BASE
         G%N_FACES_BASE = G%N_FACES_BASE + GSUB%N_FACES_BASE
         G%N_VERTS_BASE = G%N_VERTS_BASE + GSUB%N_VERTS_BASE
      ENDDO

      IF (G%N_VOLUS_BASE>0) THEN
         ALLOCATE(G%VOLUS(4*G%N_VOLUS_BASE),STAT=IZERO)
         CALL ChkMemErr('READ_GEOM','VOLUS',IZERO)

         ALLOCATE(G%MATLS(G%N_VOLUS_BASE),STAT=IZERO)
         CALL ChkMemErr('READ_GEOM','G%MATLS',IZERO)
      ENDIF

      IF (G%N_FACES_BASE>0) THEN
         ALLOCATE(G%FACES(3*G%N_FACES_BASE),STAT=IZERO)
         CALL ChkMemErr('READ_GEOM','G%FACES',IZERO)

         ALLOCATE(G%SURFS(G%N_FACES_BASE),STAT=IZERO)
         CALL ChkMemErr('READ_GEOM','G%SURFS',IZERO)

         ALLOCATE(G%TFACES(6*G%N_FACES_BASE),STAT=IZERO)
         CALL ChkMemErr('READ_GEOM','G%TFACES',IZERO)
      ENDIF

      IF (G%N_VERTS_BASE>0) THEN
         ALLOCATE(G%VERTS_BASE(3*G%N_VERTS_BASE),STAT=IZERO)
         CALL ChkMemErr('READ_GEOM','G%VERTS',IZERO)

         ALLOCATE(G%VERTS(3*G%N_VERTS_BASE),STAT=IZERO)
         CALL ChkMemErr('READ_GEOM','G%VERTS',IZERO)
      ENDIF

   ENDIF NSUB_GEOMS_IF
ENDDO READ_GEOM_LOOP
35 REWIND(LU_INPUT) ; INPUT_FILE_LINE_NUMBER = 0

GEOMETRY_CHANGE_STATE = 0
DO I = 1, N_GEOMETRY
   G=>GEOMETRY(I)
   IF (G%GEOC_FILENAME/='null') THEN
      GEOMETRY_CHANGE_STATE = 2
      EXIT
   ENDIF
   IF (G%IS_DYNAMIC) GEOMETRY_CHANGE_STATE=1
ENDDO

CALL CONVERTGEOM(T_BEGIN)

IF (CC_IBM) CALL GET_GEOM_TRIBIN


CONTAINS

! --------------------------- GET_GEOM_TRIBIN --------------------------------------

SUBROUTINE GET_GEOM_TRIBIN

! This routine separates lists of triangles for each GEOMETRY in interval
! bins in each direction. They are used in SET_CUTCELLS_3D/GET_BODINT_PLANE to optimize
! cut-cell generation.

! Local Variables:
INTEGER :: IG, IWSEL, IEDGE, IVERT, NTL, SZE, IBIN, ILO_BIN, IHI_BIN, INOD, IWSELDUM
REAL(EB):: LEDGE, DXYZE(MAX_DIM), LX1, DELBIN, X1V_LO, X1V_HI
REAL(EB), PARAMETER :: GAMMA_MULT = 1._EB
INTEGER,  PARAMETER :: DELTA_TBIN = 1000
INTEGER, ALLOCATABLE, DIMENSION(:) :: TRI_LIST

! Loop geometries:
LOOP_GEOM : DO IG = 1, N_GEOMETRY

   G=>GEOMETRY(IG)

   ! Define Geometry containing box:
   DO X1AXIS=IAXIS,KAXIS
      G%GEOM_BOX( LOW_IND,X1AXIS) = 1._EB/GEOMEPS ! Initialize min location in X1AXIS dir to large (+) number.
      G%GEOM_BOX(HIGH_IND,X1AXIS) =-1._EB/GEOMEPS ! Initialize max location in X1AXIS dir to large (-) number.
      DO IVERT=1,G%N_VERTS
         G%GEOM_BOX( LOW_IND,X1AXIS) = MIN(G%GEOM_BOX( LOW_IND,X1AXIS),G%VERTS(MAX_DIM*(IVERT-1)+X1AXIS))
         G%GEOM_BOX(HIGH_IND,X1AXIS) = MAX(G%GEOM_BOX(HIGH_IND,X1AXIS),G%VERTS(MAX_DIM*(IVERT-1)+X1AXIS))
      ENDDO
      ! WRITE(LU_ERR,*) 'GEOM_BOX=',X1AXIS,G%GEOM_BOX( LOW_IND,X1AXIS),G%GEOM_BOX(HIGH_IND,X1AXIS)
   ENDDO

   ! Define EDGE sizes and FACE cointaining boxes:
   G%MAX_LEDGE = GEOMEPS       ! Initialize to a small number.
   G%MIN_LEDGE = 1._EB/GEOMEPS ! Initialize to a large number.
   G%MEAN_LEDGE= 0._EB         ! Initialize to 0.
   ! Allocate bounding cube for triangles: We might end up getting rid of this eventually.
   ALLOCATE(G%FACECUBE(LOW_IND:HIGH_IND,IAXIS:KAXIS,G%N_FACES))

   ! Loop Faces:
   DO IWSEL = 0,G%N_FACES-1
      WSELEM(NOD1:NOD3) = G%FACES(3*IWSEL+1:3*IWSEL+3)

      ! Define FACECUBE for triangle IWSEL:
      DO X1AXIS=IAXIS,KAXIS
         X1V(NOD1:NOD3) = G%VERTS(MAX_DIM*(WSELEM(NOD1:NOD3)-1)+X1AXIS)
         G%FACECUBE( LOW_IND,X1AXIS,IWSEL+1) = MINVAL(X1V(NOD1:NOD3))
         G%FACECUBE(HIGH_IND,X1AXIS,IWSEL+1) = MAXVAL(X1V(NOD1:NOD3))
      ENDDO

      ! Obtain edges length, test against MAX_LEDGE:
      DO IEDGE=1,3
         ! DX = XYZ2 - XYZ1:
         DXYZE(IAXIS:KAXIS) = G%VERTS(MAX_DIM*(WSELEM(NOD2)-1)+1:MAX_DIM*WSELEM(NOD2)) - &
                              G%VERTS(MAX_DIM*(WSELEM(NOD1)-1)+1:MAX_DIM*WSELEM(NOD1))
         LEDGE = sqrt( DXYZE(IAXIS)**2._EB + DXYZE(JAXIS)**2._EB + DXYZE(KAXIS)**2._EB )

         G%MAX_LEDGE = MAX(G%MAX_LEDGE,LEDGE)
         G%MIN_LEDGE = MIN(G%MIN_LEDGE,LEDGE)
         G%MEAN_LEDGE= G%MEAN_LEDGE + LEDGE

         WSELEM=CSHIFT(WSELEM,1)  ! Shift cyclically array by 1 entry. This rotates nodes connectivities.
                                  ! i.e: initially WSELEM=(/1,2,3/), 1st call gives WSELEM=(/2,3,1/), 2nd
                                  ! call gives WSELEM=(/3,1,2/).
      ENDDO

   ENDDO
   ! Mean length of Edge:
   G%MEAN_LEDGE = G%MEAN_LEDGE / REAL(G%N_FACES*EDGS_WSEL,EB) !Num EDGES summed in NUM_FACES * NUM edges on a face.

   ! Now define Bin sizes to distribute Faces subsets:
   DO X1AXIS=IAXIS,KAXIS
      LX1 = G%GEOM_BOX(HIGH_IND,X1AXIS) - G%GEOM_BOX( LOW_IND,X1AXIS)
      ! Define number of bins in direction X1AXIS:
      G%TBAXIS(X1AXIS)%N_BINS = CEILING(LX1/(GAMMA_MULT*G%MEAN_LEDGE))

      ! Allocate TRIBIN field:
      IF(ALLOCATED(G%TBAXIS(X1AXIS)%TRIBIN)) DEALLOCATE(G%TBAXIS(X1AXIS)%TRIBIN)
      ALLOCATE(G%TBAXIS(X1AXIS)%TRIBIN(1:G%TBAXIS(X1AXIS)%N_BINS))

      ! Set BIN boundaries and make initial allocation of TRI_LIST for each bin:
      DELBIN = LX1 / REAL(G%TBAXIS(X1AXIS)%N_BINS,EB)
      G%TBAXIS(X1AXIS)%DELBIN = DELBIN
      DO IBIN=1,G%TBAXIS(X1AXIS)%N_BINS
         G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%X1_LOW  = G%GEOM_BOX( LOW_IND,X1AXIS) + REAL(IBIN-1,EB)*DELBIN
         G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%X1_HIGH = G%GEOM_BOX( LOW_IND,X1AXIS) + REAL(IBIN  ,EB)*DELBIN
         G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%NTL = 0
         ALLOCATE(G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%TRI_LIST(DELTA_TBIN))
      ENDDO

      ! Finally, populate TRI_LIST for X1AXIS bins:
      DO IWSEL = 0,G%N_FACES-1
         WSELEM(NOD1:NOD3) = G%FACES(3*IWSEL+1:3*IWSEL+3)
         X1V(NOD1:NOD3) = G%VERTS(MAX_DIM*(WSELEM(NOD1:NOD3)-1)+X1AXIS)
         X1V_LO = MINVAL(X1V(NOD1:NOD3));
         X1V_HI = MAXVAL(X1V(NOD1:NOD3));

         ! DO IBIN=1,G%TBAXIS(X1AXIS)%N_BINS
         !    IF(X1V_HI < G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%X1_LOW-GEOMEPS)  CYCLE
         !    IF(X1V_LO > G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%X1_HIGH+GEOMEPS) CYCLE
         !    NTL = G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%NTL + 1
         !    SZE = SIZE(G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%TRI_LIST,DIM=1)
         !    IF (NTL > SZE) THEN
         !       ! Reallocate:
         !       ALLOCATE(TRI_LIST(1:SZE)); TRI_LIST(1:SZE)=G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%TRI_LIST(1:SZE)
         !       DEALLOCATE(G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%TRI_LIST)
         !       ALLOCATE(G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%TRI_LIST(1:SZE+DELTA_TBIN))
         !       G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%TRI_LIST(1:SZE) = TRI_LIST(1:SZE)
         !       DEALLOCATE(TRI_LIST)
         !    ENDIF
         !    ! Add Triangle index to BINs TRI_LIST
         !    G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%NTL = NTL
         !    G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%TRI_LIST(NTL) = IWSEL+1
         ! ENDDO

         ILO_BIN = MAX(1,CEILING((X1V_LO-GEOMEPS-G%GEOM_BOX( LOW_IND,X1AXIS))/DELBIN))
         IHI_BIN = MIN(G%TBAXIS(X1AXIS)%N_BINS,CEILING((X1V_HI+GEOMEPS-G%GEOM_BOX( LOW_IND,X1AXIS))/DELBIN))
         DO IBIN=ILO_BIN,IHI_BIN
            NTL = G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%NTL + 1
            SZE = SIZE(G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%TRI_LIST,DIM=1)
            IF (NTL > SZE) THEN
               ! Reallocate:
               ALLOCATE(TRI_LIST(1:SZE)); TRI_LIST(1:SZE)=G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%TRI_LIST(1:SZE)
               DEALLOCATE(G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%TRI_LIST)
               ALLOCATE(G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%TRI_LIST(1:SZE+DELTA_TBIN))
               G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%TRI_LIST(1:SZE) = TRI_LIST(1:SZE)
               DEALLOCATE(TRI_LIST)
            ENDIF
            ! Add Triangle index to BINs TRI_LIST
            G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%NTL = NTL
            G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%TRI_LIST(NTL) = IWSEL+1

         ENDDO
      ENDDO

      DO IBIN=1,G%TBAXIS(X1AXIS)%N_BINS
         NTL = G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%NTL
         ALLOCATE(G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%XYZV(IAXIS:KAXIS,NOD1:NOD3,NTL))
         ALLOCATE(G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%FACECUBE(LOW_IND:HIGH_IND,NTL))
         DO IWSELDUM=1,NTL
            IWSEL=G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%TRI_LIST(IWSELDUM)
            WSELEM(NOD1:NOD3) = G%FACES(MAX_DIM*(IWSEL-1)+1:MAX_DIM*IWSEL)
            ! Triangles NODES coordinates:
            DO INOD=NOD1,NOD3
               G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%XYZV(IAXIS:KAXIS,INOD,IWSELDUM) = &
               GEOMETRY(IG)%VERTS(MAX_DIM*(WSELEM(INOD)-1)+1:MAX_DIM*WSELEM(INOD))
            ENDDO
            G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%FACECUBE(LOW_IND:HIGH_IND,IWSELDUM) = &
            G%FACECUBE(LOW_IND:HIGH_IND,X1AXIS,IWSEL)
         ENDDO
      ENDDO

   END DO

   DEALLOCATE(G%FACECUBE)

   ! WRITE(LU_ERR,*) 'GEOMETRY=',IG,'NBINS=',G%TBAXIS(IAXIS)%N_BINS,G%TBAXIS(JAXIS)%N_BINS,G%TBAXIS(KAXIS)%N_BINS
   ! DO X1AXIS=IAXIS,KAXIS
   !    DO IBIN=1,G%TBAXIS(X1AXIS)%N_BINS
   !       WRITE(LU_ERR,*) X1AXIS,'IBIN, NTL=',IBIN,G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%NTL, &
   !       G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%X1_LOW,G%TBAXIS(X1AXIS)%TRIBIN(IBIN)%X1_HIGH
   !    END DO
   ! END DO

ENDDO LOOP_GEOM

RETURN
END SUBROUTINE GET_GEOM_TRIBIN

! ---------------------------- GET_GEOM_INFO ----------------------------------------

SUBROUTINE GET_GEOM_INFO(MAX_ZVALS,MAX_VERTS,MAX_FACES,MAX_VOLUS,MAX_IDS,MAX_SURF_IDS) ! LU_INPUT not used for now.

! count number of various geometry types on the current &GEOM line
! for now assume a maximum value
! INTEGER, INTENT(IN) :: LU_INPUT

INTEGER, INTENT(INOUT) :: MAX_ZVALS,MAX_VERTS,MAX_FACES,MAX_VOLUS,MAX_IDS,MAX_SURF_IDS

MAX_ZVALS=MAX(MAX_ZVALS,100000)
MAX_VOLUS=MAX(MAX_VOLUS,3*MAX_ZVALS,350000)
MAX_FACES=MAX(MAX_FACES,4*MAX_VOLUS,100000)
MAX_VERTS=MAX(MAX_VERTS,4*MAX_VOLUS,3*MAX_FACES,100000)
MAX_IDS=MAX(MAX_IDS,1000)
MAX_SURF_IDS=MAX(MAX_SURF_IDS,100)

END SUBROUTINE GET_GEOM_INFO

! ---------------------------- ALLOCATE_BUFFERS ----------------------------------------

SUBROUTINE ALLOCATE_BUFFERS

ALLOCATE(DSCALE(3,MAX_IDS),STAT=IZERO)
CALL ChkMemErr('ALLOCATE_BUFFERS','DSCALE',IZERO)

ALLOCATE(DXYZ0(3,MAX_IDS),STAT=IZERO)
CALL ChkMemErr('ALLOCATE_BUFFERS','DXYZ0',IZERO)

ALLOCATE(DXYZ(3,MAX_IDS),STAT=IZERO)
CALL ChkMemErr('ALLOCATE_BUFFERS','DXYZ',IZERO)

ALLOCATE(GEOM_IDS(MAX_IDS),STAT=IZERO)
CALL ChkMemErr('ALLOCATE_BUFFERS','GEOM_IDS',IZERO)

ALLOCATE(DAZIM(MAX_IDS),STAT=IZERO)
CALL ChkMemErr('ALLOCATE_BUFFERS','DAZIM',IZERO)

ALLOCATE(DELEV(MAX_IDS),STAT=IZERO)
CALL ChkMemErr('ALLOCATE_BUFFERS','DELEV',IZERO)

ALLOCATE(SURF_ID(MAX_SURF_IDS),STAT=IZERO)
CALL ChkMemErr('ALLOCATE_BUFFERS','SURF_IDV',IZERO)

ALLOCATE(ZVALS(MAX_ZVALS),STAT=IZERO)
CALL ChkMemErr('ALLOCATE_BUFFERS','ZVALS',IZERO)

ALLOCATE(VERTS(3*MAX_VERTS),STAT=IZERO)
CALL ChkMemErr('ALLOCATE_BUFFERS','VERTS',IZERO)

ALLOCATE(TFACES(6*MAX_FACES),STAT=IZERO)
CALL ChkMemErr('ALLOCATE_BUFFERS','TFACES',IZERO)

ALLOCATE(FACES(4*MAX_FACES),STAT=IZERO)
CALL ChkMemErr('ALLOCATE_BUFFERS','FACES',IZERO)

ALLOCATE(VOLUS(4*MAX_VOLUS),STAT=IZERO)
CALL ChkMemErr('ALLOCATE_BUFFERS','VOLUS',IZERO)

END SUBROUTINE ALLOCATE_BUFFERS

! ---------------------------- SET_GEOM_DEFAULTS ----------------------------------------

SUBROUTINE SET_GEOM_DEFAULTS

   ! Set defaults

   CUTCELLS=.FALSE.
   ZMIN=ZS_MIN
   COMPONENT_ONLY=DEFAULT_COMPONENT_ONLY(N)
   ID = 'geom'
   SURF_ID(:)= 'null'
   MATL_ID = 'null'
   HAVE_SURF = .TRUE.
   HAVE_MATL = .TRUE.
   TEXTURE_ORIGIN = 0.0_EB
   TEXTURE_MAPPING = 'RECTANGULAR'
   TEXTURE_SCALE = 1.0_EB
   AUTO_TEXTURE = .FALSE.
   VERTS=1.001_EB*MAX_VAL
   ZVALS=1.001_EB*MAX_VAL
   XB=1.001_EB*MAX_VAL
   FACES=0
   VOLUS=0
   GEOM_IDS = ''
   IJK = 0
   IS_GEOMETRY_DYNAMIC = .FALSE.

   AZIM = 0.0_EB
   ELEV = 0.0_EB
   SCALE = 1.0_EB
   XYZ0 = 0.0_EB
   XYZ = 0.0_EB

   AZIM_DOT = 0.0_EB
   ELEV_DOT = 0.0_EB
   SCALE_DOT = 0.0_EB
   XYZ_DOT = 0.0_EB

   DAZIM = 0.0_EB
   DELEV = 0.0_EB
   DSCALE = 1.0_EB
   DXYZ0 = 0.0_EB
   DXYZ = 0.0_EB

   GAXIS(1:3) = 1.001_EB*MAX_VAL
   GROTATE = 1.001_EB*MAX_VAL
   GROTATE_DOT = 1.001_EB*MAX_VAL

   SPHERE_ORIGIN = 1.001_EB*MAX_VAL
   SPHERE_RADIUS = 1.001_EB*MAX_VAL
   N_LEVELS=-1
   N_LAT=-1
   N_LONG=-1
   SPHERE_TYPE=-1
   GEOM_TYPE = 0
END SUBROUTINE SET_GEOM_DEFAULTS

! ---------------------------- EXTRUDE_SPHERE ----------------------------------------

SUBROUTINE EXTRUDE_SPHERE(ZCENTER,VERTS,MAXVERTS,NVERTS,FACES,NFACES,VOLS,MAXVOLS, NVOLS)

! convert a closed surface defined by VERTS and FACES into a solid

INTEGER, INTENT(IN) :: NFACES, MAXVERTS,MAXVOLS
INTEGER, INTENT(INOUT) :: NVERTS
REAL(EB), INTENT(INOUT), TARGET :: VERTS(3*MAXVERTS)
INTEGER, INTENT(IN) :: FACES(3*NFACES)
INTEGER, INTENT(OUT) :: NVOLS
INTEGER, INTENT(OUT) :: VOLS(4*MAXVOLS)
REAL(EB), INTENT(IN) :: ZCENTER(3)

INTEGER :: I

! define a new vertex at ZCENTER
VERTS(3*NVERTS+1:3*NVERTS+3)=ZCENTER(1:3)

! form a tetrahedron using each face and the vertex ZCENTER
DO I = 1, NFACES
   VOLS(4*I-3:4*I)=(/FACES(3*I-2:3*I),NVERTS+1/)
ENDDO
NVERTS=NVERTS+1
NVOLS=NFACES

END SUBROUTINE EXTRUDE_SPHERE

! ! ---------------------------- EXTRUDE_SURFACE ----------------------------------------
!
! SUBROUTINE EXTRUDE_SURFACE(ZMIN,VERTS,MAXVERTS,NVERTS,FACES,NFACES,VOLS,MAXVOLS, NVOLS)
!
! ! extend a 2D surface defined by VERTS and FACES to a plane defined by ZMIN
!
! INTEGER, INTENT(IN) :: NFACES, MAXVERTS,MAXVOLS
! INTEGER, INTENT(INOUT) :: NVERTS
! REAL(EB), INTENT(INOUT), TARGET :: VERTS(3*MAXVERTS)
! INTEGER, INTENT(IN) :: FACES(3*NFACES)
! INTEGER, INTENT(OUT) :: NVOLS
! INTEGER, INTENT(OUT) :: VOLS(4*MAXVOLS)
! REAL(EB), INTENT(IN) :: ZMIN
! INTEGER :: PRISM(6)
!
! INTEGER :: I
! REAL(EB), POINTER, DIMENSION(:) :: VNEW, VOLD
!
! ! define a new vertex on the plane z=ZMIN for each vertex in original list
! DO I = 1, NVERTS
!    VNEW=>VERTS(3*NVERTS+3*I-2:3*NVERTS+3*I)
!    VOLD=>VERTS(3*I-2:3*I)
!    VNEW(1:3)=(/VOLD(1:2),ZMIN/)
! ENDDO
! ! construct 3 tetrahedrons for each prism (solid between original face and face on plane z=zplane)
! DO I = 1, NFACES
!    PRISM(1:3)=FACES(3*I-2:3*I)
!    PRISM(4:6)=FACES(3*I-2:3*I)+NVERTS
!    CALL PRISM2TETRA(PRISM,VOLS(12*I-11:12*I))
! ENDDO
! NVOLS=3*NFACES
! NVERTS=2*NVERTS
!
! END SUBROUTINE EXTRUDE_SURFACE

! ---------------------------- BOX2TETRA ----------------------------------------

SUBROUTINE BOX2TETRA(BOX,TETRAS)

! split a box defined by a list of 8 vertices (not necessarily cubic) into 5 tetrahedrons

!     8-------7
!   / .     / |
! 5-------6   |
! |   .   |   |
! |   .   |   |
! |   4-------3
! | /     | /
! 1-------2


INTEGER, INTENT(IN) :: BOX(8)
INTEGER, INTENT(OUT) :: TETRAS(1:20)

TETRAS(1:4)   = (/BOX(1),BOX(2),BOX(4),BOX(5)/)
TETRAS(5:8)   = (/BOX(2),BOX(6),BOX(7),BOX(5)/)
TETRAS(9:12)  = (/BOX(4),BOX(8),BOX(5),BOX(7)/)
TETRAS(13:16) = (/BOX(3),BOX(4),BOX(2),BOX(7)/)
TETRAS(17:20) = (/BOX(4),BOX(5),BOX(2),BOX(7)/)

END SUBROUTINE BOX2TETRA

! ! ---------------------------- PRISM2TETRA ----------------------------------------
!
! SUBROUTINE PRISM2TETRA(PRISM,TETRAS)
!
! ! split a prism defined by a list of 6 vertices into 3 tetrahedrons
!
! !       6
! !      /.\                      .
! !    /  .  \                    .
! !  /    .    \                  .
! ! 4-----------5
! ! |     .     |
! ! |     .     |
! ! |     3     |
! ! |    / \    |
! ! |  /     \  |
! ! |/         \|
! ! 1-----------2
! INTEGER, INTENT(IN) :: PRISM(6)
! INTEGER, INTENT(OUT) :: TETRAS(1:12)
!
! TETRAS(1:4)   = (/PRISM(1),PRISM(6),PRISM(4),PRISM(5)/)
! TETRAS(5:8)   = (/PRISM(1),PRISM(3),PRISM(6),PRISM(5)/)
! TETRAS(9:12)  = (/PRISM(1),PRISM(2),PRISM(3),PRISM(5)/)
!
! END SUBROUTINE PRISM2TETRA

! ! ---------------------------- SPLIT_TETRA ----------------------------------------
!
! SUBROUTINE SPLIT_TETRA(VERTS,MAXVERTS,NVERTS,TETRAS)
! ! split a tetrahedron defined by a list of 4 vertices into 4 tetrahedrons
!
! !        1
! !        |
! !       .|.
! !       .|.
! !      . | .
! !     .  7 .
! !     .  |  .
! !    .   4  .
! !    5  / \  6
! !   .  /   \ .
! !   . /     \ .
! !  . /       \ .
! !  ./         \.
! !  /           \.
! ! 2-------------3
!
! INTEGER, INTENT(IN) :: MAXVERTS
! INTEGER, INTENT(INOUT) :: NVERTS
! REAL(EB), INTENT(INOUT), TARGET :: VERTS(3*MAXVERTS)
! INTEGER, INTENT(INOUT) :: TETRAS(16)
!
! REAL(EB), POINTER, DIMENSION(:) :: VERT1, VERT2, VERT3, VERT4, VERT5, VERT6, VERT7
! INTEGER :: TETRANEW(16)
!
! VERT1=>VERTS(3*TETRAS(1)-2:3*TETRAS(1))
! VERT2=>VERTS(3*TETRAS(2)-2:3*TETRAS(2))
! VERT3=>VERTS(3*TETRAS(3)-2:3*TETRAS(3))
! VERT4=>VERTS(3*TETRAS(4)-2:3*TETRAS(4))
! VERT5=>VERTS(3*NVERTS+1:3*NVERTS+3)
! VERT6=>VERTS(3*NVERTS+4:3*NVERTS+6)
! VERT7=>VERTS(3*NVERTS+7:3*NVERTS+9)
!
! ! add 3 vertices
! VERT5(1:3) = ( VERT1(1:3)+VERT2(1:3) )/2.0_EB
! VERT6(1:3) = ( VERT1(1:3)+VERT3(1:3) )/2.0_EB
! VERT7(1:3) = ( VERT1(1:3)+VERT4(1:3) )/2.0_EB
! TETRAS(5)=NVERTS+1
! TETRAS(6)=NVERTS+2
! TETRAS(7)=NVERTS+3
! NVERTS=NVERTS+3
!
! TETRANEW(1:4)=(/TETRAS(1),TETRAS(5),TETRAS(6),TETRAS(7)/)
! CALL PRISM2TETRA(TETRAS(2:7),TETRANEW(5:16))
! TETRAS(1:16)=TETRANEW(1:16)
!
! END SUBROUTINE SPLIT_TETRA

! ---------------------------- ORDER_FACES ----------------------------------------

SUBROUTINE ORDER_FACES(ORDER,N) !
INTEGER, INTENT(IN) :: N
INTEGER, INTENT(OUT) :: ORDER(1:N)

INTEGER, ALLOCATABLE, DIMENSION(:) :: WORK
INTEGER :: I, IZERO

DO I = 1, N
   ORDER(I) = I
ENDDO
ALLOCATE(WORK(N),STAT=IZERO)
CALL ChkMemErr('ORDER_FACES','WORK',IZERO)
CALL ORDER_FACES1(ORDER,WORK,1,N,N)
END SUBROUTINE ORDER_FACES

! ---------------------------- ORDER_FACES1 ----------------------------------------

RECURSIVE SUBROUTINE ORDER_FACES1(ORDER,WORK,LEFT,RIGHT,N)
INTEGER, INTENT(IN) :: N, LEFT, RIGHT
INTEGER, INTENT(INOUT) :: ORDER(1:N)
INTEGER :: TEMP
INTEGER :: I1, I2
INTEGER, INTENT(OUT) :: WORK(N)
INTEGER :: ICOUNT

INTEGER :: NMID

IF (RIGHT-LEFT>1) THEN
   NMID = (LEFT+RIGHT)/2
   CALL ORDER_FACES1(ORDER,WORK,LEFT,NMID,N)
   CALL ORDER_FACES1(ORDER,WORK,NMID+1,RIGHT,N)
   I1=LEFT
   I2=NMID+1
   ICOUNT=LEFT
   DO WHILE (I1<=NMID .OR. I2<=RIGHT)
      IF (I1<=NMID .AND. I2<=RIGHT) THEN
        IF (COMPARE_FACES(ORDER(I1),ORDER(I2))==-1) THEN
           WORK(ICOUNT)=ORDER(I1)
           I1=I1+1
        ELSE
           WORK(ICOUNT)=ORDER(I2)
           I2=I2+1
        ENDIF
      ELSE IF (I1<=NMID .AND. I2>RIGHT) THEN
         WORK(ICOUNT)=ORDER(I1)
         I1=I1+1
      ELSE IF (I1>NMID .AND. I2<=RIGHT) THEN
         WORK(ICOUNT)=ORDER(I2)
         I2=I2+1
      ENDIF
      ICOUNT=ICOUNT+1
   ENDDO
   ORDER(LEFT:RIGHT)=WORK(LEFT:RIGHT)
ELSE IF (RIGHT-LEFT==1) THEN
   IF (COMPARE_FACES(ORDER(LEFT),ORDER(RIGHT))==1) RETURN
   TEMP=ORDER(LEFT)
   ORDER(LEFT) = ORDER(RIGHT)
   ORDER(RIGHT) = TEMP
ENDIF
END SUBROUTINE ORDER_FACES1

! ---------------------------- COMPARE_FACES ----------------------------------------

INTEGER FUNCTION COMPARE_FACES(INDEX1,INDEX2)
INTEGER, INTENT(IN) :: INDEX1, INDEX2
INTEGER, POINTER, DIMENSION(:) :: FACE1, FACE2
INTEGER :: F1(3), F2(3)

FACE1=>FACES(3*INDEX1-2:3*INDEX1)
FACE2=>FACES(3*INDEX2-2:3*INDEX2)
F1(1:3) = (/FACE1(1),MIN(FACE1(2),FACE1(3)),MAX(FACE1(2),FACE1(3))/)
F2(1:3) = (/FACE2(1),MIN(FACE2(2),FACE2(3)),MAX(FACE2(2),FACE2(3))/)

COMPARE_FACES=0
IF (F1(1)<F2(1)) THEN
   COMPARE_FACES=1
ELSE IF (F1(1)>F2(1)) THEN
   COMPARE_FACES=-1
ENDIF
IF (COMPARE_FACES/=0) RETURN

IF (F1(2)<F2(2)) THEN
   COMPARE_FACES=1
ELSE IF (F1(2)>F2(2)) THEN
   COMPARE_FACES=-1
ENDIF
IF (COMPARE_FACES/=0) RETURN

IF (F1(3)<F2(3)) THEN
   COMPARE_FACES=1
ELSE IF (F1(3)>F2(3)) THEN
   COMPARE_FACES=-1
ENDIF
END FUNCTION COMPARE_FACES

END SUBROUTINE READ_GEOM


! ---------------------------- INIT_SPHERE ----------------------------------------

SUBROUTINE INIT_SPHERE(N_LEVELS,N_VERTS,N_FACES,MAX_VERTS,MAX_FACES,SPHERE_VERTS,SPHERE_FACES)

INTEGER, INTENT(IN) :: N_LEVELS
INTEGER, INTENT(OUT) :: N_VERTS, N_FACES
INTEGER, INTENT(IN) :: MAX_VERTS, MAX_FACES
REAL(EB), TARGET, INTENT(OUT) :: SPHERE_VERTS(3*MAX_VERTS)
INTEGER, TARGET, INTENT(OUT) :: SPHERE_FACES(3*MAX_FACES)

REAL(EB) :: ARG
REAL(EB), DIMENSION(3) :: VERT
INTEGER :: I,IFACE
INTEGER, DIMENSION(60) :: FACE_LIST
REAL(EB), PARAMETER :: ONETHIRD=1.0_EB/3.0_EB, TWOTHIRDS=2.0_EB/3.0_EB

DATA (FACE_LIST(I),I=1,60) / &
   1, 2, 3,  1, 3, 4,  1, 4, 5,  1, 5, 6,  1, 6,2, &
   2, 7, 3,  3, 7, 8,  3, 8, 4,  4, 8, 9,  4, 9,5, &
   5, 9,10,  5,10, 6,  6,10,11,  6,11, 2,  2,11,7, &
   12, 8,7,  12, 9,8,  12,10,9, 12,11,10, 12,7,11  &
   /

N_VERTS = 12
N_FACES = 20

SPHERE_VERTS(1:3) = (/0.0,0.0,1.0/) ! 1
DO I=2, 6
   ARG = REAL(I-2,EB)*72.0_EB
   ARG = 2.0_EB*PI*ARG/360.0_EB
   VERT = (/COS(ARG),SIN(ARG),1.0_EB/SQRT(5.0_EB)/)
   SPHERE_VERTS(3*I-2:3*I) = VERT/NORM2(VERT)  ! 2-6
ENDDO
DO I=7, 11
   ARG = 36.0_EB+REAL(I-7,EB)*72.0_EB
   ARG = 2.0_EB*PI*ARG/360.0_EB
   VERT = (/COS(ARG),SIN(ARG),-1.0_EB/SQRT(5.0_EB)/)
   SPHERE_VERTS(3*I-2:3*I) = VERT/NORM2(VERT)  ! 7-11
ENDDO
SPHERE_VERTS(34:36) = (/0.0,0.0,-1.0/) ! 12

SPHERE_FACES(1:60) = FACE_LIST(1:60)

! refine each triangle of the icosahedron recursively until the
! refined triangle sides are the same size as the grid mesh

DO IFACE = 1, 20 ! can't use N_FACES since N_FACES is altered by each call to REFINE_FACE
   CALL REFINE_FACE(N_LEVELS,IFACE,N_VERTS,N_FACES,MAX_VERTS,MAX_FACES,SPHERE_VERTS,SPHERE_FACES)
ENDDO
END SUBROUTINE INIT_SPHERE

! ---------------------------- COMPUTE_TEXTURES ----------------------------------------

SUBROUTINE COMPUTE_TEXTURES(SPHERE_VERTS,SPHERE_FACES,SPHERE_TFACES,MAX_VERTS,MAX_FACES,N_FACES)
INTEGER, INTENT(IN) :: N_FACES,MAX_VERTS,MAX_FACES
REAL(EB), TARGET, INTENT(IN) :: SPHERE_VERTS(3*MAX_VERTS)
REAL(EB), INTENT(OUT), TARGET :: SPHERE_TFACES(6*MAX_FACES)
INTEGER, TARGET, INTENT(IN) :: SPHERE_FACES(3*MAX_FACES)

INTEGER :: IFACE
REAL(EB) :: EPS_TEXTURE
REAL(EB), POINTER, DIMENSION(:) :: TFACE, VERTPTR
INTEGER, POINTER, DIMENSION(:) :: FACEPTR

EPS_TEXTURE=0.25_EB
IFACE_LOOP: DO IFACE=0, N_FACES-1

   FACEPTR=>SPHERE_FACES(3*IFACE+1:3*IFACE+3)
   TFACE=>SPHERE_TFACES(6*IFACE+1:6*IFACE+6)

   VERTPTR=>SPHERE_VERTS(3*FACEPTR(1)-2:3*FACEPTR(1))
   CALL COMPUTE_TEXTURE(VERTPTR(1:3),TFACE(1:2))

   VERTPTR=>SPHERE_VERTS(3*FACEPTR(2)-2:3*FACEPTR(2))
   CALL COMPUTE_TEXTURE(VERTPTR(1:3),TFACE(3:4))

   VERTPTR=>SPHERE_VERTS(3*FACEPTR(3)-2:3*FACEPTR(3))
   CALL COMPUTE_TEXTURE(VERTPTR(1:3),TFACE(5:6))

   ! adjust texture coordinates when a triangle crosses the "prime meridian"

   IF (TFACE(1)>1.0_EB-EPS_TEXTURE .AND. TFACE(3)<EPS_TEXTURE) THEN
      TFACE(3)=TFACE(3)+1.0_EB
   ENDIF
   IF (TFACE(1)>1.0_EB-EPS_TEXTURE .AND. TFACE(5)<EPS_TEXTURE) THEN
      TFACE(5)=TFACE(5)+1.0_EB
   ENDIF

   IF (TFACE(3)>1.0_EB-EPS_TEXTURE .AND. TFACE(1)<EPS_TEXTURE) THEN
      TFACE(1)=TFACE(1)+1.0_EB
   ENDIF
   IF (TFACE(3)>1.0_EB-EPS_TEXTURE .AND. TFACE(5)<EPS_TEXTURE) THEN
      TFACE(5)=TFACE(5)+1.0_EB
   ENDIF

   IF (TFACE(5)>1.0_EB-EPS_TEXTURE .AND. TFACE(1)<EPS_TEXTURE) THEN
      TFACE(1)=TFACE(1)+1.0_EB
   ENDIF
   IF (TFACE(5)>1.0_EB-EPS_TEXTURE .AND. TFACE(3)<EPS_TEXTURE) THEN
      TFACE(3)=TFACE(3)+1.0_EB
   ENDIF

   ! make adjustments when face is at a pole

   IF (ABS(TFACE(2)-1.0_EB)<0.001_EB) THEN
      TFACE(1) = (TFACE(3)+TFACE(5))/2.0_EB
   ENDIF
   IF (ABS(TFACE(4)-1.0_EB)<0.001_EB) THEN
      TFACE(3) = (TFACE(1)+TFACE(5))/2.0_EB
   ENDIF
   IF (ABS(TFACE(6)-1.0_EB)<0.001_EB) THEN
      TFACE(5) = (TFACE(1)+TFACE(3))/2.0_EB
   ENDIF

   IF (ABS(TFACE(2))<0.001_EB) THEN
      TFACE(1) = (TFACE(3)+TFACE(5))/2.0_EB
   ENDIF
   IF (ABS(TFACE(4))<0.001_EB) THEN
      TFACE(3) = (TFACE(1)+TFACE(5))/2.0_EB
   ENDIF
   IF (ABS(TFACE(6))<0.001_EB) THEN
      TFACE(5) = (TFACE(1)+TFACE(3))/2.0_EB
   ENDIF

ENDDO IFACE_LOOP
END SUBROUTINE COMPUTE_TEXTURES

! ---------------------------- INIT_SPHERE2 ----------------------------------------

SUBROUTINE INIT_SPHERE2(N_VERTS, N_FACES, NLAT,NLONG,SPHERE_VERTS,SPHERE_FACES)
INTEGER, INTENT(IN) :: NLAT, NLONG
REAL(EB), INTENT(OUT), TARGET, DIMENSION(3*(NLONG*(NLAT-2) + 2)) :: SPHERE_VERTS
INTEGER, INTENT(OUT), TARGET, DIMENSION(3*(NLAT-1)*NLONG*2*2) :: SPHERE_FACES
INTEGER, INTENT(OUT) :: N_VERTS, N_FACES
REAL(EB) :: LAT, LONG
INTEGER :: ILONG, ILAT
REAL(EB) :: COSLAT(NLAT), SINLAT(NLAT)
REAL(EB) :: COSLONG(NLONG), SINLONG(NLONG)

INTEGER :: I , J, IJ, I11, I12, I21, I22

N_VERTS = NLONG*(NLAT-2) + 2
N_FACES = (NLAT-2)*NLONG*2

IJ = 0
DO I = 1, NLAT
   LAT = PI/2.0_EB - PI*REAL(I-1,EB)/REAL(NLAT-1,EB)
   COSLAT(I) = COS(LAT)
   SINLAT(I) = SIN(LAT)
ENDDO
DO I = 1, NLONG
   LONG = -PI + 2.0_EB*PI*REAL(I-1,EB)/REAL(NLONG,EB)
   COSLONG(I) = COS(LONG)
   SINLONG(I) = SIN(LONG)
ENDDO

! define vertices

! north pole

SPHERE_VERTS(1:3)  = (/0.0_EB,0.0_EB,1.0_EB/)

! middle latitudes

IJ = 4
DO I = 2, NLAT-1
   DO J = 1, NLONG
      SPHERE_VERTS(IJ:IJ+2)   = (/COSLONG(J)*COSLAT(I),SINLONG(J)*COSLAT(I),SINLAT(I)/)
      IJ = IJ + 3
   ENDDO
ENDDO

! south pole

SPHERE_VERTS(IJ:IJ+2)  = (/0.0_EB,0.0_EB,-1.0_EB/)

! define faces

! faces connected to north pole
IJ=1
DO ILONG = 1, NLONG
   I11 = ILONG+1
   I12 = ILONG+2
   I22 = 1
   IF (ILONG==NLONG)I12=2
   SPHERE_FACES(IJ:IJ+2)   = (/I22, I11,I12/)
   IJ = IJ + 3
ENDDO

DO ILAT = 2, NLAT - 2
   DO ILONG = 1, NLONG

      I11 = 1+ILONG+NLONG*(ILAT+1-2)
      I21 = I11 + 1
      I12 = 1+ILONG+NLONG*(ILAT-2)
      I22 = I12 + 1
      IF ( ILONG==NLONG) THEN
         I21 = 1+1+NLONG*(ILAT+1-2)
         I22 = 1+1+NLONG*(ILAT-2)
      ENDIF

      SPHERE_FACES(IJ:IJ+2)   = (/I12,I11,I22/)
      SPHERE_FACES(IJ+3:IJ+5) = (/I22,I11,I21/)
      IJ = IJ + 6
   ENDDO
ENDDO

! faces connected to south pole

DO ILONG = 1, NLONG
   I11 = ILONG+1 + NLONG*(NLAT-3)
   I12 = I11 + 1
   I22 = NLONG*(NLAT-2)+2
   IF (ILONG==NLONG) I12=2+NLONG*(NLAT-3)
   SPHERE_FACES(IJ:IJ+2)   = (/I11,I22,I12/)
   IJ = IJ + 3
ENDDO
END SUBROUTINE INIT_SPHERE2

! ---------------------------- REFINE_FACE ----------------------------------------

RECURSIVE SUBROUTINE REFINE_FACE(N_LEVELS,IFACE,N_VERTS,N_FACES,MAX_VERTS,MAX_FACES,SPHERE_VERTS,SPHERE_FACES)

INTEGER, INTENT(IN) :: N_LEVELS
INTEGER, INTENT(IN) :: IFACE
INTEGER, INTENT(INOUT) :: N_VERTS, N_FACES
INTEGER, INTENT(IN) :: MAX_VERTS, MAX_FACES
REAL(EB), INTENT(INOUT), TARGET :: SPHERE_VERTS(3*MAX_VERTS)
INTEGER, INTENT(INOUT), TARGET :: SPHERE_FACES(3*MAX_FACES)

INTEGER, POINTER, DIMENSION(:) :: FACE1, FACE2, FACE3, FACE4
REAL(EB), POINTER, DIMENSION(:) :: V1, V2, V3
REAL(EB), POINTER, DIMENSION(:) :: V12, V13, V23
INTEGER :: N1, N2, N3, N4

IF (N_LEVELS==0 .OR. N_FACES+3>MAX_FACES .OR. N_VERTS+3>MAX_VERTS) RETURN ! prevent memory overwrites

FACE1(1:3)=>SPHERE_FACES(3*IFACE-2:3*IFACE) ! original face and 1st new face
FACE2(1:3)=>SPHERE_FACES(3*N_FACES+1:3*N_FACES+3) ! 2nd new face
FACE3(1:3)=>SPHERE_FACES(3*N_FACES+4:3*N_FACES+6) ! 3rd new face
FACE4(1:3)=>SPHERE_FACES(3*N_FACES+7:3*N_FACES+9) ! 4th new face

V1(1:3)=>SPHERE_VERTS(3*FACE1(1)-2:3*FACE1(1)) ! FACE1(1)
V2(1:3)=>SPHERE_VERTS(3*FACE1(2)-2:3*FACE1(2)) ! FACE1(2)
V3(1:3)=>SPHERE_VERTS(3*FACE1(3)-2:3*FACE1(3)) ! FACE1(3)

V12(1:3)=>SPHERE_VERTS(3*N_VERTS+1:3*N_VERTS+3)
V13(1:3)=>SPHERE_VERTS(3*N_VERTS+4:3*N_VERTS+6)
V23(1:3)=>SPHERE_VERTS(3*N_VERTS+7:3*N_VERTS+9)

V12 = (V1+V2)/2.0_EB
V13 = (V1+V3)/2.0_EB
V23 = (V2+V3)/2.0_EB
V12 = V12/NORM2(V12) ! N_VERTS + 1
V13 = V13/NORM2(V13) ! N_VERTS + 2
V23 = V23/NORM2(V23) ! N_VERTS + 3

! split triangle 123 into 4 triangles

!         1
!       /F1\                          .
!     12----13
!    /F2\F3/F4\                       i.
!  2 --- 23----3

FACE2(1:3) = (/N_VERTS+1,FACE1(2),N_VERTS+3/)
FACE3(1:3) = (/N_VERTS+1,N_VERTS+3,N_VERTS+2/)
FACE4(1:3) = (/N_VERTS+2,N_VERTS+3,FACE1(3)/)
FACE1(1:3) = (/ FACE1(1),N_VERTS+1,N_VERTS+2/)

N1 = IFACE
N2 = N_FACES+1
N3 = N_FACES+2
N4 = N_FACES+3

N_FACES = N_FACES + 3
N_VERTS = N_VERTS + 3
IF (N_LEVELS==1) RETURN  ! stop recursion

CALL REFINE_FACE(N_LEVELS-1,N1,N_VERTS,N_FACES,MAX_VERTS,MAX_FACES,SPHERE_VERTS,SPHERE_FACES)
CALL REFINE_FACE(N_LEVELS-1,N2,N_VERTS,N_FACES,MAX_VERTS,MAX_FACES,SPHERE_VERTS,SPHERE_FACES)
CALL REFINE_FACE(N_LEVELS-1,N3,N_VERTS,N_FACES,MAX_VERTS,MAX_FACES,SPHERE_VERTS,SPHERE_FACES)
CALL REFINE_FACE(N_LEVELS-1,N4,N_VERTS,N_FACES,MAX_VERTS,MAX_FACES,SPHERE_VERTS,SPHERE_FACES)

END SUBROUTINE REFINE_FACE

! ---------------------------- COMPUTE_TEXTURE ----------------------------------------

SUBROUTINE COMPUTE_TEXTURE(XYZ,TEXT_COORDS)
REAL(EB), INTENT(IN), DIMENSION(3) :: XYZ
REAL(EB), INTENT(OUT), DIMENSION(2) :: TEXT_COORDS
REAL(EB), DIMENSION(2) :: ANGLES
REAL(EB) :: NORM2_XYZ, Z_ANGLE

NORM2_XYZ = NORM2(XYZ)
IF (NORM2_XYZ < TWO_EPSILON_EB) THEN
   Z_ANGLE = 0.0_EB
ELSE
   Z_ANGLE = ASIN(XYZ(3)/NORM2_XYZ)
ENDIF
ANGLES = (/ATAN2(XYZ(2),XYZ(1)),Z_ANGLE/)

!convert back to texture coordinates
TEXT_COORDS = (/ 0.5_EB + 0.5_EB*ANGLES(1)/PI,0.5_EB + ANGLES(2)/PI /)
END SUBROUTINE COMPUTE_TEXTURE

! ---------------------------- GET_GEOM_ID ----------------------------------------

INTEGER FUNCTION GET_GEOM_ID(ID,N_LAST)

! return the index of the geometry array with label ID

CHARACTER(30), INTENT(IN) :: ID
INTEGER, INTENT(IN) :: N_LAST

INTEGER :: N
TYPE(GEOMETRY_TYPE), POINTER :: G=>NULL()

GET_GEOM_ID = 0
DO N=1,N_LAST
   G=>GEOMETRY(N)
   IF (TRIM(G%ID)==TRIM(ID)) THEN
      GET_GEOM_ID = N
      RETURN
   ENDIF
ENDDO
END FUNCTION GET_GEOM_ID

! ---------------------------- GET_MATL_INDEX ----------------------------------------

INTEGER FUNCTION GET_MATL_INDEX(ID)
CHARACTER(30), INTENT(IN) :: ID
INTEGER :: N

DO N = 1, N_MATL
   IF (TRIM(MATERIAL(N)%ID)/=TRIM(ID)) CYCLE
   GET_MATL_INDEX = N
   RETURN
ENDDO
GET_MATL_INDEX = 0
END FUNCTION GET_MATL_INDEX

! ---------------------------- GET_SURF_INDEX ----------------------------------------

INTEGER FUNCTION GET_SURF_INDEX(ID)
CHARACTER(30), INTENT(IN) :: ID
INTEGER :: N

DO N = 1, N_SURF
   IF (TRIM(SURFACE(N)%ID)/=TRIM(ID)) CYCLE
   GET_SURF_INDEX = N
   RETURN
ENDDO
GET_SURF_INDEX = 0
END FUNCTION GET_SURF_INDEX

! ---------------------------- SETUP_TRANSFORM ----------------------------------------

SUBROUTINE SETUP_TRANSFORM(SCALE,AZ,ELEV,GAXIS,GROTATE,M)

! construct a rotation matrix M that rotates a vector by
! AZ degrees around the Z axis then ELEV degrees around
! the (cos AZ, sin AZ, 0) axis

REAL(EB), INTENT(IN) :: SCALE(3), AZ, ELEV, GAXIS(3), GROTATE
REAL(EB), DIMENSION(3,3), INTENT(OUT) :: M

REAL(EB) :: AXIS(3), M0(3,3), M1(3,3), M2(3,3), M3(3,3), MTEMP(3,3), MTEMP2(3,3)

M0 = RESHAPE ((/&
               SCALE(1),  0.0_EB, 0.0_EB,&
                 0.0_EB,SCALE(2), 0.0_EB,&
                 0.0_EB,  0.0_EB,SCALE(3) &
               /),(/3,3/))

AXIS = (/0.0_EB, 0.0_EB, 1.0_EB/)
CALL SETUP_ROTATE(AZ,AXIS,M1)

AXIS = (/COS(DEG2RAD*AZ), SIN(DEG2RAD*AZ), 0.0_EB/)
CALL SETUP_ROTATE(ELEV,AXIS,M2)

CALL SETUP_ROTATE(GROTATE,GAXIS,M3)

MTEMP = MATMUL(M1,M0)
MTEMP2 = MATMUL(M2,MTEMP)
M = MATMUL(M3,MTEMP2)

END SUBROUTINE SETUP_TRANSFORM

! ---------------------------- SETUP_ROTATE ----------------------------------------

SUBROUTINE SETUP_ROTATE(ALPHA,U,M)

! construct a rotation matrix M that rotates a vector by
! ALPHA degrees about an axis U

REAL(EB), INTENT(IN) :: ALPHA, U(3)
REAL(EB), INTENT(OUT) :: M(3,3)

REAL(EB) :: UP(3,1), S(3,3), UUT(3,3), IDENTITY(3,3)

UP = RESHAPE(U/SQRT(DOT_PRODUCT(U,U)),(/3,1/))
S =   RESHAPE( (/&
                   0.0_EB, -UP(3,1),  UP(2,1),&
                  UP(3,1),   0.0_EB, -UP(1,1),&
                 -UP(2,1),  UP(1,1),  0.0_EB  &
                 /),(/3,3/))
UUT = MATMUL(UP,TRANSPOSE(UP))
IDENTITY = RESHAPE ((/&
               1.0_EB,0.0_EB,0.0_EB,&
               0.0_EB,1.0_EB,0.0_EB,&
               0.0_EB,0.0_EB,1.0_EB &
               /),(/3,3/))
M = UUT + COS(ALPHA*DEG2RAD)*(IDENTITY - UUT) + SIN(ALPHA*DEG2RAD)*S

END SUBROUTINE SETUP_ROTATE

! ! ---------------------------- `TRANSLATE_VEC` ----------------------------------------
!
! SUBROUTINE TRANSLATE_VEC(XYZ,N,XIN,XOUT)
!
! ! translate a geometry by the vector XYZ
!
! INTEGER, INTENT(IN) :: N
! REAL(EB), INTENT(IN) :: XYZ(3), XIN(3*N)
! REAL(EB), INTENT(OUT) :: XOUT(3*N)
!
! REAL(EB) :: VEC(3)
! INTEGER :: I
!
! DO I = 1, N
!    VEC(1:3) = XYZ(1:3) + XIN(3*I-2:3*I) ! copy into a temp array so XIN and XOUT can point to same space
!    XOUT(3*I-2:3*I) = VEC(1:3)
! ENDDO
!
! END SUBROUTINE TRANSLATE_VEC

! ---------------------------- `TRANSLATE_VEC_INPLACE` ----------------------------------------

SUBROUTINE TRANSLATE_VEC_INPLACE(XYZ,N,XINOUT)

! translate a geometry by the vector XYZ

INTEGER, INTENT(IN) :: N
REAL(EB), INTENT(IN) :: XYZ(3)
REAL(EB), INTENT(INOUT) :: XINOUT(3*N)

REAL(EB) :: VEC(3)
INTEGER :: I

DO I = 1, N
   VEC(1:3) = XYZ(1:3) + XINOUT(3*I-2:3*I) ! copy into a temp array so XIN and XOUT can point to same space
   XINOUT(3*I-2:3*I) = VEC(1:3)
ENDDO

END SUBROUTINE TRANSLATE_VEC_INPLACE

! ---------------------------- ROTATE_VEC ----------------------------------------

SUBROUTINE ROTATE_VEC(M,N,XYZ0,XIN,XOUT)

! rotate the vector XIN about the origin XYZ0

INTEGER, INTENT(IN) :: N
REAL(EB), INTENT(IN) :: M(3,3), XIN(3*N), XYZ0(3)
REAL(EB), INTENT(OUT) :: XOUT(3*N)

REAL(EB) :: VEC(3)
INTEGER :: I

DO I = 1, N
   VEC(1:3) = MATMUL(M,XIN(3*I-2:3*I)-XYZ0(1:3))  ! copy into a temp array so XIN and XOUT can point to same space
   XOUT(3*I-2:3*I) = VEC(1:3) + XYZ0(1:3)
ENDDO
END SUBROUTINE ROTATE_VEC

! ---------------------------- PROCESS_GEOM ----------------------------------------

SUBROUTINE PROCESS_GEOM(IS_DYNAMIC,TIME, N_VERTS, N_FACES, N_VOLUS)

! transform (scale, rotate and translate) vectors found on each &GEOM line

   LOGICAL, INTENT(IN) :: IS_DYNAMIC
   REAL(EB), INTENT(IN) :: TIME
   INTEGER, INTENT(OUT) :: N_VERTS, N_FACES, N_VOLUS

   INTEGER :: I
   TYPE(GEOMETRY_TYPE), POINTER :: G=>NULL()
   REAL(EB) :: M(3,3), DELTA_T

   IF (IS_DYNAMIC) THEN
      DELTA_T = TIME - T_BEGIN
   ELSE
      DELTA_T = 0.0_EB
   ENDIF

   DO I = 1, N_GEOMETRY
      G=>GEOMETRY(I)

      G%SCALE = G%SCALE_BASE + DELTA_T*G%SCALE_DOT
      G%AZIM = G%AZIM_BASE + DELTA_T*G%AZIM_DOT
      G%ELEV = G%ELEV_BASE + DELTA_T*G%ELEV_DOT
      G%XYZ = G%XYZ_BASE + DELTA_T*G%XYZ_DOT
      G%GROTATE = G%GROTATE_BASE + DELTA_T*G%GROTATE_DOT

      IF (IS_DYNAMIC .AND. G%IS_DYNAMIC .OR. .NOT.IS_DYNAMIC .AND. .NOT.G%IS_DYNAMIC) THEN
         G%N_VERTS = G%N_VERTS_BASE
         G%N_FACES = G%N_FACES_BASE
         G%N_VOLUS = G%N_VOLUS_BASE
      ENDIF
   ENDDO

   DO I = 1, N_GEOMETRY
      G=>GEOMETRY(I)

      IF (G%NSUB_GEOMS>0) CALL EXPAND_GROUPS(I) ! create vertex and face list from geometries specified in GEOM_IDS list
      IF (G%IS_DYNAMIC .AND. .NOT.IS_DYNAMIC) CYCLE
      IF (.NOT.G%IS_DYNAMIC .AND. IS_DYNAMIC) CYCLE
      IF (TRIM(G%GEOC_FILENAME)=='null' .OR. ABS(TIME-T_BEGIN)<TWO_EPSILON_EB) THEN
         CALL SETUP_TRANSFORM(G%SCALE,G%AZIM,G%ELEV,G%GAXIS,G%GROTATE,M)
         CALL ROTATE_VEC(M,G%N_VERTS,G%XYZ0,G%VERTS_BASE,G%VERTS)
         CALL TRANSLATE_VEC_INPLACE(G%XYZ,G%N_VERTS,G%VERTS)
      ENDIF
   ENDDO
   CALL GEOM2TEXTURE

   N_VERTS = 0
   N_FACES = 0
   N_VOLUS = 0
   DO I = 1, N_GEOMETRY ! count vertices and faces
      G=>GEOMETRY(I)

      IF (G%COMPONENT_ONLY) CYCLE
      IF (G%IS_DYNAMIC .AND. .NOT.IS_DYNAMIC) CYCLE
      IF (.NOT.G%IS_DYNAMIC .AND. IS_DYNAMIC) CYCLE
      N_VERTS = N_VERTS + G%N_VERTS
      N_FACES = N_FACES + G%N_FACES
      N_VOLUS = N_VOLUS + G%N_VOLUS
   ENDDO


END SUBROUTINE PROCESS_GEOM

! ---------------------------- GEOM2TEXTURE ----------------------------------------

SUBROUTINE GEOM2TEXTURE
   INTEGER :: I,J,K,JJ
   TYPE(GEOMETRY_TYPE), POINTER :: G
   REAL(EB), POINTER, DIMENSION(:) :: XYZ, TFACES
   INTEGER, POINTER, DIMENSION(:) :: FACES
   INTEGER :: SURF_INDEX
   TYPE(SURFACE_TYPE), POINTER :: SF=>NULL()

   DO I = 1, N_GEOMETRY
      G=>GEOMETRY(I)

      IF (G%NSUB_GEOMS/=0 .OR. G%TEXTURE_MAPPING/='RECTANGULAR') CYCLE
      DO J = 0, G%N_FACES-1
         SURF_INDEX = G%SURFS(1+J)
         SF=>SURFACE(SURF_INDEX)
         IF (TRIM(SF%TEXTURE_MAP)=='null') CYCLE
         FACES(1:3)=>G%FACES(1+3*J:3+3*J)
         TFACES(1:6)=>G%TFACES(1+6*J:6+6*J)
         DO K = 0, 2
            JJ = FACES(1+K)

            XYZ(1:3) => G%VERTS(3*JJ-2:3*JJ)
            TFACES(1+2*K:2+2*K) = (XYZ(1:2) - G%TEXTURE_ORIGIN(1:2))/G%TEXTURE_SCALE(1:2)
         ENDDO
      ENDDO
   ENDDO
END SUBROUTINE GEOM2TEXTURE

! ---------------------------- MERGE_GEOMS ----------------------------------------

SUBROUTINE MERGE_GEOMS(VERTS,N_VERTS,FACES,TFACES,SURF_IDS,N_FACES,VOLUS,MATL_IDS,N_VOLUS,IS_DYNAMIC)

! combine vectors and faces found on all &GEOM lines into one set of VECTOR and FACE arrays

INTEGER, INTENT(IN) :: N_VERTS, N_FACES, N_VOLUS
LOGICAL, INTENT(IN) :: IS_DYNAMIC
REAL(EB), DIMENSION(:), INTENT(OUT) :: VERTS(3*N_VERTS), TFACES(6*N_FACES)
INTEGER, DIMENSION(:), INTENT(OUT) :: FACES(3*N_FACES), VOLUS(4*N_VOLUS), MATL_IDS(N_VOLUS), SURF_IDS(N_FACES)

INTEGER :: I
TYPE(GEOMETRY_TYPE), POINTER :: G=>NULL()
INTEGER :: IVERT, ITFACE, IFACE, IVOLUS, IMATL, ISURF, OFFSET

IVERT = 0
ITFACE = 0
IFACE = 0
IVOLUS = 0
ISURF = 0
IMATL = 0
OFFSET = 0
DO I = 1, N_GEOMETRY
   G=>GEOMETRY(I)

   IF (G%IS_DYNAMIC .AND. .NOT.IS_DYNAMIC) CYCLE
   IF (.NOT.G%IS_DYNAMIC .AND. IS_DYNAMIC) CYCLE

   IF (G%COMPONENT_ONLY) CYCLE

   IF (G%N_VERTS>0) THEN
      VERTS(1+IVERT:3*G%N_VERTS+IVERT) = G%VERTS(1:3*G%N_VERTS)
      IVERT = IVERT + 3*G%N_VERTS
   ENDIF
   IF (G%N_FACES>0) THEN
      FACES(1+IFACE:3*G%N_FACES + IFACE) = G%FACES(1:3*G%N_FACES)+OFFSET
      IFACE = IFACE + 3*G%N_FACES

      TFACES(1+ITFACE:6*G%N_FACES + ITFACE) = G%TFACES(1:6*G%N_FACES)
      ITFACE = ITFACE + 6*G%N_FACES

      SURF_IDS(1+ISURF:G%N_FACES+ISURF) = G%SURFS(1:G%N_FACES)
      ISURF = ISURF +   G%N_FACES
   ENDIF
   IF (G%N_VOLUS>0) THEN
      VOLUS(1+IVOLUS:4*G%N_VOLUS + IVOLUS) = G%VOLUS(1:4*G%N_VOLUS)+OFFSET
      IVOLUS = IVOLUS + 4*G%N_VOLUS

      MATL_IDS(1+IMATL:G%N_VOLUS+IMATL) = G%MATLS(1:G%N_VOLUS)
      IMATL = IMATL + G%N_VOLUS
   ENDIF
   OFFSET = OFFSET + G%N_VERTS
ENDDO

END SUBROUTINE MERGE_GEOMS

! ---------------------------- EXPAND_GROUPS ----------------------------------------

SUBROUTINE EXPAND_GROUPS(IGEOM)

! for each geometry specifed in a &GEOM line, merge geometries referenced
! by GEOM_IDS after scaling, rotating and translating

INTEGER, INTENT(IN) :: IGEOM

INTEGER :: IVERT, IFACE, IVOLUS, J, NSUB_VERTS, NSUB_FACES, NSUB_VOLUS
INTEGER, POINTER, DIMENSION(:) :: FIN,FOUT, SURFIN, SURFOUT, MATLIN, MATLOUT
REAL(EB) :: M(3,3)
REAL(EB), POINTER, DIMENSION(:) :: XIN, XOUT, TFIN, TFOUT
REAL(EB), DIMENSION(:), POINTER :: DSCALEPTR, DXYZ0PTR, DXYZPTR
TYPE(GEOMETRY_TYPE), POINTER :: G, GSUB=>NULL()
REAL(EB), DIMENSION(3,3) :: GIDENTITY
REAL(EB) :: GZERO=0.0_EB


IF (IGEOM<=1) RETURN
G=>GEOMETRY(IGEOM)

IF (G%NSUB_GEOMS==0) RETURN

IF (G%N_VERTS_BASE==0.OR.(G%N_FACES_BASE==0 .AND. G%N_VOLUS_BASE==0)) RETURN ! nothing to do if GEOM_IDS geometries are empty

GIDENTITY = RESHAPE ((/&
               1.0_EB,0.0_EB,0.0_EB,&
               0.0_EB,1.0_EB,0.0_EB,&
               0.0_EB,0.0_EB,1.0_EB &
               /),(/3,3/))

IVERT = 0
IFACE = 0
IVOLUS = 0
DO J = 1, G%NSUB_GEOMS
   GSUB=>GEOMETRY(G%SUB_GEOMS(J))
   NSUB_VERTS = GSUB%N_VERTS_BASE
   NSUB_FACES = GSUB%N_FACES_BASE
   NSUB_VOLUS = GSUB%N_VOLUS_BASE

   IF (NSUB_VERTS==0 .OR. (NSUB_FACES==0 .AND. NSUB_VOLUS==0)) CYCLE

   DSCALEPTR(1:3) => G%DSCALE(1:3,J)
   CALL SETUP_TRANSFORM(DSCALEPTR,G%DAZIM(J),G%DELEV(J),GIDENTITY,GZERO,M)

   XIN(1:3*NSUB_VERTS) => GSUB%VERTS(1:3*NSUB_VERTS)
   XOUT(1:3*NSUB_VERTS) => G%VERTS_BASE(1+3*IVERT:3*(IVERT+NSUB_VERTS))

   DXYZ0PTR(1:3) => G%DXYZ0(1:3,J)
   DXYZPTR(1:3) => G%DXYZ(1:3,J)
   CALL ROTATE_VEC(M,NSUB_VERTS,DXYZ0PTR,XIN,XOUT)
   CALL TRANSLATE_VEC_INPLACE(DXYZPTR,NSUB_VERTS,XOUT)

   ! copy and offset face indices

   IF (NSUB_FACES>0) THEN
       FIN(1:3*NSUB_FACES) => GSUB%FACES(1        :3*NSUB_FACES        )
      FOUT(1:3*NSUB_FACES) =>    G%FACES(1+3*IFACE:3*NSUB_FACES+3*IFACE)

      FOUT = FIN + IVERT

       TFIN(1:6*NSUB_FACES) => GSUB%TFACES(1        :6*NSUB_FACES        )
      TFOUT(1:6*NSUB_FACES) =>    G%TFACES(1+6*IFACE:6*NSUB_FACES+6*IFACE)

      TFOUT = TFIN

      ! copy surface indices

      SURFIN(1:NSUB_FACES) => GSUB%SURFS(1:NSUB_FACES)
      SURFOUT(1:NSUB_FACES) => G%SURFS(1+IFACE:IFACE+NSUB_FACES)
      SURFOUT = SURFIN
   ENDIF

   ! copy and offset volu indices

   IF (NSUB_VOLUS>0) THEN
      FIN(1:4*NSUB_VOLUS) => GSUB%VOLUS(1:4*NSUB_VOLUS)
      FOUT(1:4*NSUB_VOLUS) => G%VOLUS(1+4*IVOLUS:3*(IVOLUS+NSUB_VOLUS))

      FOUT = FIN + IVERT

      ! copy matl indices

      MATLIN(1:NSUB_VOLUS) => GSUB%MATLS(1:NSUB_VOLUS)
      MATLOUT(1:NSUB_VOLUS) => G%MATLS(IVOLUS+1:IVOLUS+NSUB_VOLUS)
      MATLOUT = MATLIN
   ENDIF

   IVERT = IVERT + NSUB_VERTS
   IFACE = IFACE + NSUB_FACES
   IVOLUS = IVOLUS + NSUB_VOLUS
ENDDO
G%N_VERTS = IVERT
G%N_FACES = IFACE
G%N_VOLUS = IVOLUS
IF (IFACE>0 .AND. G%HAVE_SURF) G%SURFS(1:G%N_FACES) = GET_SURF_INDEX(G%SURF_ID(1))
IF (IVOLUS>0 .AND. G%HAVE_MATL) G%MATLS(1:G%N_VOLUS) = GET_MATL_INDEX(G%MATL_ID)
IF (IVERT>0) G%VERTS(1:3*G%N_VERTS) = G%VERTS_BASE(1:3*G%N_VERTS)

END SUBROUTINE EXPAND_GROUPS

! ---------------------------- CONVERTGEOM ----------------------------------------

SUBROUTINE CONVERTGEOM(TIME)

REAL(EB), INTENT(IN) :: TIME

INTEGER :: N_VERTS, N_FACES, N_VOLUS
INTEGER :: N_VERTS_S, N_FACES_S, N_VOLUS_S
INTEGER :: N_VERTS_D, N_FACES_D, N_VOLUS_D
INTEGER, ALLOCATABLE, DIMENSION(:) :: VOLUS, FACES, MATL_IDS, SURF_IDS
REAL(EB), ALLOCATABLE, DIMENSION(:) :: VERTS, TFACES
INTEGER :: IZERO

CALL PROCESS_GEOM(.FALSE.,TIME, N_VERTS_S, N_FACES_S, N_VOLUS_S)  ! scale, rotate, translate static GEOM vertices
CALL PROCESS_GEOM( .TRUE.,TIME, N_VERTS_D, N_FACES_D, N_VOLUS_D)  ! scale, rotate, translate dynamic GEOM vertices

N_VERTS = N_VERTS_S + N_VERTS_D
N_FACES = N_FACES_S + N_FACES_D
N_VOLUS = N_VOLUS_S + N_VOLUS_D

ALLOCATE(VERTS(MAX(1,3*N_VERTS)),STAT=IZERO)   ! create arrays to contain all vertices and faces
CALL ChkMemErr('CONVERTGEOM','VERTS',IZERO)

ALLOCATE(TFACES(MAX(1,6*N_FACES)),STAT=IZERO)   ! create arrays to contain all vertices and faces
CALL ChkMemErr('CONVERTGEOM','TVERTS',IZERO)

ALLOCATE(FACES(MAX(1,3*N_FACES)),STAT=IZERO)
CALL ChkMemErr('CONVERTGEOM','FACES',IZERO)

ALLOCATE(SURF_IDS(MAX(1,N_FACES)),STAT=IZERO)
CALL ChkMemErr('CONVERTGEOM','SURF_IDS',IZERO)

ALLOCATE(VOLUS(MAX(1,4*N_VOLUS)),STAT=IZERO)
CALL ChkMemErr('CONVERTGEOM','VOLUS',IZERO)

ALLOCATE(MATL_IDS(MAX(1,N_VOLUS)),STAT=IZERO)
CALL ChkMemErr('CONVERTGEOM','MATL_IDS',IZERO)

IF (N_VERTS_S>0 .AND. (N_FACES_S>0 .OR. N_VOLUS_S>0)) THEN ! merge static geometry
   CALL MERGE_GEOMS(VERTS(1:3*N_VERTS_S),N_VERTS_S,&
      FACES(1:3*N_FACES_S),TFACES(1:3*N_FACES_S),SURF_IDS(1:N_FACES_S),N_FACES_S,&
      VOLUS(1:3*N_VOLUS_S),MATL_IDS(1:N_VOLUS_S),N_VOLUS_S,.FALSE.)
ENDIF
IF (N_VERTS_D>0 .AND. (N_FACES_D>0 .OR. N_VOLUS_D>0)) THEN ! merge dynamic geometry
   CALL MERGE_GEOMS(VERTS(3*N_VERTS_S+1:3*N_VERTS),N_VERTS_D,&
      FACES(3*N_FACES_S+1:3*N_FACES),TFACES(3*N_FACES_S+1:3*N_FACES),SURF_IDS(N_FACES_S+1:N_FACES),N_FACES_D,&
      VOLUS(3*N_VOLUS_S+1:3*N_VOLUS),MATL_IDS(N_VOLUS_S+1:N_VOLUS),N_VOLUS_D,.TRUE.)
ENDIF

RETURN
END SUBROUTINE CONVERTGEOM

! ---------------------------- REORDER_FACE ----------------------------------------

SUBROUTINE REORDER_VERTS(VERTS)
! the VERTS triplet V1, V2, V3 defines a face
! reorder V1,V2,V3 so that V1 has the smallest index
INTEGER, INTENT(INOUT) :: VERTS(3)

INTEGER :: VERTS_TEMP(5)

IF ( VERTS(1)<MIN(VERTS(2),VERTS(3))) RETURN ! already in correct order

VERTS_TEMP(1:3) = VERTS(1:3)
VERTS_TEMP(4:5) = VERTS(1:2)

IF (VERTS(2)<MIN(VERTS(1),VERTS(3))) THEN
   VERTS(1:3) = VERTS_TEMP(2:4)
ELSE
   VERTS(1:3) = VERTS_TEMP(3:5)
ENDIF
END SUBROUTINE REORDER_VERTS

! ---------------------------- OUTGEOM ----------------------------------------

SUBROUTINE OUTGEOM(LUNIT,IS_DYNAMIC,TIME)
   INTEGER, INTENT(IN) :: LUNIT
   REAL(EB), INTENT(IN) :: TIME
   LOGICAL, INTENT(IN) :: IS_DYNAMIC
   INTEGER :: N_VERTS, N_FACES, N_VOLUS
   INTEGER :: I
   INTEGER, ALLOCATABLE, DIMENSION(:) :: FACES, VOLUS, MATL_IDS, SURF_IDS
   REAL(EB), ALLOCATABLE, DIMENSION(:) :: VERTS, TFACES
   INTEGER :: IZERO

   CALL PROCESS_GEOM(IS_DYNAMIC,TIME,N_VERTS, N_FACES, N_VOLUS)  ! scale, rotate, translate GEOM vertices

   ALLOCATE(VERTS(MAX(1,3*N_VERTS)),STAT=IZERO)   ! create arrays to contain all vertices and faces
   CALL ChkMemErr('OUTGEOM','VERTS',IZERO)

   ALLOCATE(TFACES(MAX(1,6*N_FACES)),STAT=IZERO)
   CALL ChkMemErr('OUTGEOM','VERTS',IZERO)

   ALLOCATE(FACES(MAX(1,3*N_FACES)),STAT=IZERO)
   CALL ChkMemErr('OUTGEOM','FACES',IZERO)

   ALLOCATE(SURF_IDS(MAX(1,N_FACES)),STAT=IZERO)
   CALL ChkMemErr('OUTGEOM','SURF_IDS',IZERO)

   ALLOCATE(VOLUS(MAX(1,4*N_VOLUS)),STAT=IZERO)
   CALL ChkMemErr('OUTGEOM','VOLUS',IZERO)

   ALLOCATE(MATL_IDS(MAX(1,N_VOLUS)),STAT=IZERO)
   CALL ChkMemErr('OUTGEOM','MATL_IDS',IZERO)

   IF (N_VERTS>0 .AND. (N_FACES>0 .OR. N_VOLUS>0)) THEN
      CALL MERGE_GEOMS(VERTS,N_VERTS,FACES,TFACES,SURF_IDS,N_FACES,VOLUS,MATL_IDS,N_VOLUS,IS_DYNAMIC)
   ENDIF

   WRITE(LUNIT) REAL(TIME,FB)
   WRITE(LUNIT) N_VERTS, N_FACES, N_VOLUS
   IF (N_VERTS>0) WRITE(LUNIT) (REAL(VERTS(I),FB), I=1,3*N_VERTS)
   IF (N_FACES>0) THEN
      WRITE(LUNIT) (FACES(I), I=1,3*N_FACES)
      WRITE(LUNIT) (SURF_IDS(I), I=1,N_FACES)
      WRITE(LUNIT) (REAL(TFACES(I),FB), I=1,6*N_FACES)
   ENDIF
   IF (N_VOLUS>0) THEN
      WRITE(LUNIT) (VOLUS(I), I=1,4*N_VOLUS)
      WRITE(LUNIT) (MATL_IDS(I), I=1,N_VOLUS)
   ENDIF

END SUBROUTINE OUTGEOM

! ---------------------------- WRITE_GEOM_ALL ------------------------------------

SUBROUTINE WRITE_GEOM_ALL
INTEGER :: I
REAL(EB) :: STIME

CALL WRITE_GEOM(T_BEGIN) ! write out both static and dynamic data at t=T_BEGIN
DO I = 1, NFRAMES
   STIME = (T_BEGIN*REAL(NFRAMES-I,EB) + T_END_GEOM*REAL(I,EB))/REAL(NFRAMES,EB)
   CALL WRITE_GEOM(STIME) ! write out just dynamic data at t=STIME
ENDDO
END SUBROUTINE WRITE_GEOM_ALL

! ---------------------------- WRITE_GEOM ----------------------------------------

SUBROUTINE WRITE_GEOM(TIME)

! output geometries to a .ge file

   REAL(EB), INTENT(IN) :: TIME
   INTEGER :: ONE=1, ZERO=0, VERSION=2

   IF (N_GEOMETRY<=0) RETURN

!   IF (ABS(TIME-T_BEGIN)<TWO_EPSILON_EB) THEN
   IF (WRITE_GEOM_FIRST) THEN
      WRITE_GEOM_FIRST = .FALSE.
      OPEN(LU_GEOM(1),FILE=TRIM(FN_GEOM(1)),FORM='UNFORMATTED',STATUS='REPLACE')
      WRITE(LU_GEOM(1)) ONE
      WRITE(LU_GEOM(1)) VERSION
      WRITE(LU_GEOM(1)) ZERO, ZERO, ONE ! n floats, n ints, first frame static
      CALL OUTGEOM(LU_GEOM(1),.FALSE.,TIME) ! write out static data
   ELSE
      OPEN(LU_GEOM(1),FILE=FN_GEOM(1),FORM='UNFORMATTED',STATUS='OLD',POSITION='APPEND')
   ENDIF
   CALL OUTGEOM(LU_GEOM(1),.TRUE.,TIME) ! write out dynamic data
   CLOSE(LU_GEOM(1))

END SUBROUTINE WRITE_GEOM

! ---------------------------- WRITE_GEOM_DATA-----------------------------------

SUBROUTINE WRITE_GEOM_DATA(VERTS, NVERTS, TRIANGLES, NTRIANGLES, VERTDATA, NVERTDATA, TRIDATA, NTRIDATA)
   INTEGER, INTENT(IN) :: NVERTS, NTRIANGLES, NVERTDATA, NTRIDATA
   REAL(FB), INTENT(IN) :: VERTS(3*NVERTS), VERTDATA(NVERTDATA), TRIDATA(NTRIDATA)
   INTEGER, INTENT(IN) :: TRIANGLES(3*NTRIANGLES)

   INTEGER :: ONE=1, VERSION=2
   INTEGER :: N_FLOATS=0, N_INTS=0, FIRST_FRAME_STATIC=1
   INTEGER :: NVOLS=0, HAS_VERT_ID=0,NVOLDATA=0
   REAL(FB) :: STIME=0.0_FB
   INTEGER :: I

   IF (NVERTS.EQ.0.OR.NTRIANGLES.EQ.0) RETURN
   OPEN(LU_GEOM_DIAG(1),FILE=TRIM(FN_GEOM_DIAG(1)),FORM='UNFORMATTED',STATUS='REPLACE')
   WRITE(LU_GEOM_DIAG(1)) ONE
   WRITE(LU_GEOM_DIAG(1)) VERSION
   WRITE(LU_GEOM_DIAG(1)) N_FLOATS, N_INTS, FIRST_FRAME_STATIC

   WRITE(LU_GEOM_DIAG(1)) STIME
   WRITE(LU_GEOM_DIAG(1)) NVERTS, NTRIANGLES, NVOLS
   IF (NVERTS>0) WRITE(LU_GEOM_DIAG(1))(VERTS(I),I=1,3*NVERTS)
   IF (NTRIANGLES>0) THEN
      WRITE(LU_GEOM_DIAG(1)) (TRIANGLES(I),I=1,3*NTRIANGLES)
      WRITE(LU_GEOM_DIAG(1)) (-1,I=1,NTRIANGLES)
      WRITE(LU_GEOM_DIAG(1)) (-1.0_FB,-1.0_FB,I=1,3*NTRIANGLES)
   ENDIF
   CLOSE(LU_GEOM_DIAG(1))

   OPEN(LU_GEOM_DIAG(2),FILE=TRIM(FN_GEOM_DIAG(2)),FORM='UNFORMATTED',STATUS='REPLACE')
   WRITE(LU_GEOM_DIAG(2)) ONE
   WRITE(LU_GEOM_DIAG(2)) VERSION
   WRITE(LU_GEOM_DIAG(2)) N_FLOATS
   WRITE(LU_GEOM_DIAG(2)) N_INTS

   WRITE(LU_GEOM_DIAG(2)) STIME
   WRITE(LU_GEOM_DIAG(1)) NVERTDATA, NTRIDATA, NVOLDATA
   WRITE(LU_GEOM_DIAG(2)) HAS_VERT_ID
   IF (NVERTDATA>0)WRITE(LU_GEOM_DIAG(2))(VERTDATA(I),I=1,NVERTDATA)
   IF (NTRIDATA>0) WRITE(LU_GEOM_DIAG(2))(TRIDATA(I),I=1,NTRIDATA)
   CLOSE(LU_GEOM_DIAG(2))

END SUBROUTINE WRITE_GEOM_DATA

! ! ---------------------------- TRIANGLE_BOX_INTERSECT ----------------------------------------
!
! SUBROUTINE TRIANGLE_BOX_INTERSECT(IERR,V1,V2,V3,BB)
! IMPLICIT NONE
!
! INTEGER, INTENT(OUT) :: IERR
! REAL(EB), INTENT(IN) :: V1(3),V2(3),V3(3),BB(6)
! REAL(EB) :: PLANE(4),P0(3),P1(3)
!
! IERR=0
!
! !! Filter small triangles
! !
! !A_TRI = TRIANGLE_AREA(V1,V2,V3)
! !A_BB  = MIN( (BB(2)-BB(1))*(BB(4)-BB(3)), (BB(2)-BB(1))*(BB(6)-BB(5)), (BB(4)-BB(3))*(BB(6)-BB(5)) )
! !IF (A_TRI < 0.01*A_BB) RETURN
!
! ! Are vertices outside of bounding planes?
!
! IF (MAX(V1(1),V2(1),V3(1))<BB(1)) RETURN
! IF (MIN(V1(1),V2(1),V3(1))>BB(2)) RETURN
! IF (MAX(V1(2),V2(2),V3(2))<BB(3)) RETURN
! IF (MIN(V1(2),V2(2),V3(2))>BB(4)) RETURN
! IF (MAX(V1(3),V2(3),V3(3))<BB(5)) RETURN
! IF (MIN(V1(3),V2(3),V3(3))>BB(6)) RETURN
!
! ! Any vertices inside bounding box?
!
! IF ( V1(1)>=BB(1) .AND. V1(1)<=BB(2) .AND. &
!      V1(2)>=BB(3) .AND. V1(2)<=BB(4) .AND. &
!      V1(3)>=BB(5) .AND. V1(3)<=BB(6) ) THEN
!    IERR=1
!    RETURN
! ENDIF
! IF ( V2(1)>=BB(1) .AND. V2(1)<=BB(2) .AND. &
!      V2(2)>=BB(3) .AND. V2(2)<=BB(4) .AND. &
!      V2(3)>=BB(5) .AND. V2(3)<=BB(6) ) THEN
!    IERR=1
!    RETURN
! ENDIF
! IF ( V3(1)>=BB(1) .AND. V3(1)<=BB(2) .AND. &
!      V3(2)>=BB(3) .AND. V3(2)<=BB(4) .AND. &
!      V3(3)>=BB(5) .AND. V3(3)<=BB(6) ) THEN
!    IERR=1
!    RETURN
! ENDIF
!
! ! There are a couple other trivial rejection tests we could employ.
! ! But for now we jump straight to line segment--plane intersection.
!
! ! Test edge V1,V2 for intersection with each face of box
! PLANE = (/-1._EB,0._EB,0._EB, BB(1)/); CALL LINE_PLANE_INTERSECT(IERR,V1,V2,PLANE,BB,-1); IF (IERR==1) RETURN
! PLANE = (/ 1._EB,0._EB,0._EB,-BB(2)/); CALL LINE_PLANE_INTERSECT(IERR,V1,V2,PLANE,BB, 1); IF (IERR==1) RETURN
! PLANE = (/0._EB,-1._EB,0._EB, BB(3)/); CALL LINE_PLANE_INTERSECT(IERR,V1,V2,PLANE,BB,-2); IF (IERR==1) RETURN
! PLANE = (/0._EB, 1._EB,0._EB,-BB(4)/); CALL LINE_PLANE_INTERSECT(IERR,V1,V2,PLANE,BB, 2); IF (IERR==1) RETURN
! PLANE = (/0._EB,0._EB,-1._EB, BB(5)/); CALL LINE_PLANE_INTERSECT(IERR,V1,V2,PLANE,BB,-3); IF (IERR==1) RETURN
! PLANE = (/0._EB,0._EB, 1._EB,-BB(6)/); CALL LINE_PLANE_INTERSECT(IERR,V1,V2,PLANE,BB, 3); IF (IERR==1) RETURN
!
! ! Test edge V2,V3 for intersection with each face of box
! PLANE = (/-1._EB,0._EB,0._EB, BB(1)/); CALL LINE_PLANE_INTERSECT(IERR,V2,V3,PLANE,BB,-1); IF (IERR==1) RETURN
! PLANE = (/ 1._EB,0._EB,0._EB,-BB(2)/); CALL LINE_PLANE_INTERSECT(IERR,V2,V3,PLANE,BB, 1); IF (IERR==1) RETURN
! PLANE = (/0._EB,-1._EB,0._EB, BB(3)/); CALL LINE_PLANE_INTERSECT(IERR,V2,V3,PLANE,BB,-2); IF (IERR==1) RETURN
! PLANE = (/0._EB, 1._EB,0._EB,-BB(4)/); CALL LINE_PLANE_INTERSECT(IERR,V2,V3,PLANE,BB, 2); IF (IERR==1) RETURN
! PLANE = (/0._EB,0._EB,-1._EB, BB(5)/); CALL LINE_PLANE_INTERSECT(IERR,V2,V3,PLANE,BB,-3); IF (IERR==1) RETURN
! PLANE = (/0._EB,0._EB, 1._EB,-BB(6)/); CALL LINE_PLANE_INTERSECT(IERR,V2,V3,PLANE,BB, 3); IF (IERR==1) RETURN
!
! ! Test edge V3,V1 for intersection with each face of box
! PLANE = (/-1._EB,0._EB,0._EB, BB(1)/); CALL LINE_PLANE_INTERSECT(IERR,V3,V1,PLANE,BB,-1); IF (IERR==1) RETURN
! PLANE = (/ 1._EB,0._EB,0._EB,-BB(2)/); CALL LINE_PLANE_INTERSECT(IERR,V3,V1,PLANE,BB, 1); IF (IERR==1) RETURN
! PLANE = (/0._EB,-1._EB,0._EB, BB(3)/); CALL LINE_PLANE_INTERSECT(IERR,V3,V1,PLANE,BB,-2); IF (IERR==1) RETURN
! PLANE = (/0._EB, 1._EB,0._EB,-BB(4)/); CALL LINE_PLANE_INTERSECT(IERR,V3,V1,PLANE,BB, 2); IF (IERR==1) RETURN
! PLANE = (/0._EB,0._EB,-1._EB, BB(5)/); CALL LINE_PLANE_INTERSECT(IERR,V3,V1,PLANE,BB,-3); IF (IERR==1) RETURN
! PLANE = (/0._EB,0._EB, 1._EB,-BB(6)/); CALL LINE_PLANE_INTERSECT(IERR,V3,V1,PLANE,BB, 3); IF (IERR==1) RETURN
!
! ! The remaining possibility for tri-box intersection is that the corner of the box pokes through
! ! the triangle such that neither the vertices nor the edges of tri intersect any of the box faces.
! ! In this case the diagonal of the box corner intersects the plane formed by the tri.  The diagonal
! ! is defined as the line segment from point P0 to P1, formed from the corners of the bounding box.
!
! ! Test the four box diagonals:
!
! P0 = (/BB(1),BB(3),BB(5)/)
! P1 = (/BB(2),BB(4),BB(6)/)
! CALL LINE_SEGMENT_TRIANGLE_INTERSECT(IERR,V1,V2,V3,P0,P1); IF (IERR==1) RETURN
!
! P0 = (/BB(2),BB(3),BB(5)/)
! P1 = (/BB(1),BB(4),BB(6)/)
! CALL LINE_SEGMENT_TRIANGLE_INTERSECT(IERR,V1,V2,V3,P0,P1); IF (IERR==1) RETURN
!
! P0 = (/BB(1),BB(3),BB(6)/)
! P1 = (/BB(2),BB(4),BB(5)/)
! CALL LINE_SEGMENT_TRIANGLE_INTERSECT(IERR,V1,V2,V3,P0,P1); IF (IERR==1) RETURN
!
! P0 = (/BB(1),BB(4),BB(5)/)
! P1 = (/BB(2),BB(3),BB(6)/)
! CALL LINE_SEGMENT_TRIANGLE_INTERSECT(IERR,V1,V2,V3,P0,P1); IF (IERR==1) RETURN
!
! ! test commit from Charles Luo
!
! END SUBROUTINE TRIANGLE_BOX_INTERSECT

! ---------------------------- TRIANGLE_AREA ----------------------------------------

REAL(EB) FUNCTION TRIANGLE_AREA(V1,V2,V3)
USE MATH_FUNCTIONS, ONLY: CROSS_PRODUCT
IMPLICIT NONE

REAL(EB), INTENT(IN) :: V1(3),V2(3),V3(3)
REAL(EB) :: N(3),R1(3),R2(3)

R1 = V2-V1
R2 = V3-V1
CALL CROSS_PRODUCT(N,R1,R2)

TRIANGLE_AREA = 0.5_EB*NORM2(N)

END FUNCTION TRIANGLE_AREA

! ! ---------------------------- LINE_SEGMENT_TRIANGLE_INTERSECT ----------------------------------------
!
! SUBROUTINE LINE_SEGMENT_TRIANGLE_INTERSECT(IERR,V1,V2,V3,P0,P1)
! USE MATH_FUNCTIONS, ONLY: CROSS_PRODUCT
! IMPLICIT NONE
!
! INTEGER, INTENT(OUT) :: IERR
! REAL(EB), INTENT(IN) :: V1(3),V2(3),V3(3),P0(3),P1(3)
! REAL(EB) :: E1(3),E2(3),S(3),Q(3),U,V,TMP,T,D(3),P(3)
! REAL(EB), PARAMETER :: EPS=1.E-10_EB
!
! IERR=0
!
! ! Schneider and Eberly, Section 11.1
!
! D = P1-P0
!
! E1 = V2-V1
! E2 = V3-V1
!
! CALL CROSS_PRODUCT(P,D,E2)
!
! TMP = DOT_PRODUCT(P,E1)
!
! IF ( ABS(TMP)<EPS ) RETURN
!
! TMP = 1._EB/TMP
! S = P0-V1
!
! U = TMP*DOT_PRODUCT(S,P)
! IF (U<0._EB .OR. U>1._EB) RETURN
!
! CALL CROSS_PRODUCT(Q,S,E1)
! V = TMP*DOT_PRODUCT(D,Q)
! IF (V<0._EB .OR. (U+V)>1._EB) RETURN
!
! T = TMP*DOT_PRODUCT(E2,Q)
! !XI = P0 + T*D ! the intersection point
!
! IF (T>=0._EB .AND. T<=1._EB) IERR=1
!
! END SUBROUTINE LINE_SEGMENT_TRIANGLE_INTERSECT

! ! ---------------------------- LINE_PLANE_INTERSECT ----------------------------------------
!
! SUBROUTINE LINE_PLANE_INTERSECT(IERR,P0,P1,PP,BB,IOR)
! IMPLICIT NONE
!
! INTEGER, INTENT(OUT) :: IERR
! REAL(EB), INTENT(IN) :: P0(3),P1(3),PP(4),BB(6)
! INTEGER, INTENT(IN) :: IOR
! REAL(EB) :: D(3),T,DENOM, Q0(3)
! REAL(EB), PARAMETER :: EPS=1.E-10_EB
!
! IERR=0
! Q0=-999._EB
! T=0._EB
!
! D = P1-P0
! DENOM = DOT_PRODUCT(PP(1:3),D)
!
! IF (ABS(DENOM)>EPS) THEN
!    T = -( DOT_PRODUCT(PP(1:3),P0)+PP(4) )/DENOM
!    IF (T>=0._EB .AND. T<=1._EB) THEN
!       Q0 = P0 + T*D ! instersection point
!       IF (POINT_IN_BOX_2D(Q0,BB,IOR)) IERR=1
!    ENDIF
! ENDIF
!
! END SUBROUTINE LINE_PLANE_INTERSECT

! ---------------------------- POINT_IN_BOX_2D ----------------------------------------

LOGICAL FUNCTION POINT_IN_BOX_2D(P,BB,IOR)
IMPLICIT NONE

REAL(EB), INTENT(IN) :: P(3),BB(6)
INTEGER, INTENT(IN) :: IOR

POINT_IN_BOX_2D=.FALSE.

SELECT CASE(ABS(IOR))
   CASE(1) ! YZ plane
      IF ( P(2)>=BB(3) .AND. P(2)<=BB(4) .AND. &
           P(3)>=BB(5) .AND. P(3)<=BB(6) ) POINT_IN_BOX_2D=.TRUE.
   CASE(2) ! XZ plane
      IF ( P(1)>=BB(1) .AND. P(1)<=BB(2) .AND. &
           P(3)>=BB(5) .AND. P(3)<=BB(6) ) POINT_IN_BOX_2D=.TRUE.
   CASE(3) ! XY plane
      IF ( P(1)>=BB(1) .AND. P(1)<=BB(2) .AND. &
           P(2)>=BB(3) .AND. P(2)<=BB(4) ) POINT_IN_BOX_2D=.TRUE.
END SELECT

END FUNCTION POINT_IN_BOX_2D

! ---------------------------- POINT_IN_TETRAHEDRON ----------------------------------------

LOGICAL FUNCTION POINT_IN_TETRAHEDRON(XP,V1,V2,V3,V4,BB)
USE MATH_FUNCTIONS, ONLY: CROSS_PRODUCT
IMPLICIT NONE

REAL(EB), INTENT(IN) :: XP(3),V1(3),V2(3),V3(3),V4(3),BB(6)
REAL(EB) :: U_VEC(3),V_VEC(3),N_VEC(3),Q_VEC(3),R_VEC(3)
INTEGER :: I

! In this routine, we test all four faces of the tet volume defined by the points X(i),Y(i),Z(i); i=1:4.
! If the point is on the negative side of all the faces, it is inside the volume.

POINT_IN_TETRAHEDRON=.FALSE.

! first test bounding box

IF (XP(1)<BB(1)) RETURN
IF (XP(1)>BB(2)) RETURN
IF (XP(2)<BB(3)) RETURN
IF (XP(2)>BB(4)) RETURN
IF (XP(3)<BB(5)) RETURN
IF (XP(3)>BB(6)) RETURN

POINT_IN_TETRAHEDRON=.TRUE.

FACE_LOOP: DO I=1,4

   SELECT CASE(I)
      CASE(1)
         ! vertex ordering = 1,2,3,4
         Q_VEC = XP-(/V1(1),V1(2),V1(3)/) ! form a vector from a point on the triangular surface to the point XP
         R_VEC = (/V4(1),V4(2),V4(3)/)-(/V1(1),V1(2),V1(3)/) ! vector from the tri to other point of volume defining inside
         U_VEC = (/V2(1)-V1(1),V2(2)-V1(2),V2(3)-V1(3)/) ! vectors forming the sides of the triangle
         V_VEC = (/V3(1)-V1(1),V3(2)-V1(2),V3(3)-V1(3)/)
      CASE(2)
         ! vertex ordering = 1,3,4,2
         Q_VEC = XP-(/V1(1),V1(2),V1(3)/)
         R_VEC = (/V2(1),V2(2),V2(3)/)-(/V1(1),V1(2),V1(3)/)
         U_VEC = (/V3(1)-V1(1),V3(2)-V1(2),V3(3)-V1(3)/)
         V_VEC = (/V4(1)-V1(1),V4(2)-V1(2),V4(3)-V1(3)/)
      CASE(3)
         ! vertex ordering = 1,4,2,3
         Q_VEC = XP-(/V1(1),V1(2),V1(3)/)
         R_VEC = (/V2(1),V2(2),V2(3)/)-(/V1(1),V1(2),V1(3)/)
         U_VEC = (/V4(1)-V1(1),V4(2)-V1(2),V4(3)-V1(3)/)
         V_VEC = (/V2(1)-V1(1),V2(2)-V1(2),V2(3)-V1(3)/)
      CASE(4)
         ! vertex ordering = 2,4,3,1
         Q_VEC = XP-(/V2(1),V2(2),V2(3)/)
         R_VEC = (/V1(1),V1(2),V1(3)/)-(/V2(1),V2(2),V2(3)/)
         U_VEC = (/V4(1)-V2(1),V4(2)-V2(2),V4(3)-V2(3)/)
         V_VEC = (/V3(1)-V2(1),V3(2)-V2(2),V3(3)-V2(3)/)
   END SELECT

   ! if the sign of the dot products are equal, the point is inside, else it is outside and we return

   IF ( ABS( SIGN(1._EB,DOT_PRODUCT(Q_VEC,N_VEC))-SIGN(1._EB,DOT_PRODUCT(R_VEC,N_VEC)) )>TWO_EPSILON_EB ) THEN
      POINT_IN_TETRAHEDRON=.FALSE.
      RETURN
   ENDIF

ENDDO FACE_LOOP

END FUNCTION POINT_IN_TETRAHEDRON

! ! ---------------------------- POINT_IN_POLYHEDRON ----------------------------------------
!
! LOGICAL FUNCTION POINT_IN_POLYHEDRON(XP,BB)
! IMPLICIT NONE
!
! REAL(EB) :: XP(3),BB(6),XX(3),YY(3),ZZ(3),RAY_DIRECTION(3)
! INTEGER :: I,J,N_INTERSECTIONS,IRAY
! REAL(EB), PARAMETER :: EPS=1.E-6_EB
!
! ! Schneider and Eberly, Geometric Tools for Computer Graphics, Morgan Kaufmann, 2003. Section 13.4
!
! POINT_IN_POLYHEDRON=.FALSE.
!
! ! test global bounding box
!
! IF ( XP(1)<BB(1) .OR. XP(1)>BB(2) ) RETURN
! IF ( XP(2)<BB(3) .OR. XP(2)>BB(4) ) RETURN
! IF ( XP(3)<BB(5) .OR. XP(3)>BB(6) ) RETURN
!
! N_INTERSECTIONS=0
!
! RAY_DIRECTION = (/0._EB,0._EB,1._EB/)
!
! FACE_LOOP: DO I=1,N_FACE
!
!    ! test bounding box
!    XX(1) = VERTEX(FACET(I)%VERTEX(1))%X
!    XX(2) = VERTEX(FACET(I)%VERTEX(2))%X
!    XX(3) = VERTEX(FACET(I)%VERTEX(3))%X
!
!    IF (XP(1)<MINVAL(XX)) CYCLE FACE_LOOP
!    IF (XP(1)>MAXVAL(XX)) CYCLE FACE_LOOP
!
!    YY(1) = VERTEX(FACET(I)%VERTEX(1))%Y
!    YY(2) = VERTEX(FACET(I)%VERTEX(2))%Y
!    YY(3) = VERTEX(FACET(I)%VERTEX(3))%Y
!
!    IF (XP(2)<MINVAL(YY)) CYCLE FACE_LOOP
!    IF (XP(2)>MAXVAL(YY)) CYCLE FACE_LOOP
!
!    ZZ(1) = VERTEX(FACET(I)%VERTEX(1))%Z
!    ZZ(2) = VERTEX(FACET(I)%VERTEX(2))%Z
!    ZZ(3) = VERTEX(FACET(I)%VERTEX(3))%Z
!
!    IF (XP(3)>MAXVAL(ZZ)) CYCLE FACE_LOOP
!
!    RAY_TEST_LOOP: DO J=1,3
!       IRAY = RAY_TRIANGLE_INTERSECT(I,XP,RAY_DIRECTION)
!       SELECT CASE(IRAY)
!          CASE(0)
!             ! does not intersect
!             EXIT RAY_TEST_LOOP
!          CASE(1)
!             ! ray intersects triangle
!             N_INTERSECTIONS=N_INTERSECTIONS+1
!             EXIT RAY_TEST_LOOP
!          CASE(2)
!             ! ray intersects edge, try new ray (shift origin)
!             IF (J==1) XP=XP+(/EPS,0._EB,0._EB/) ! shift in x direction
!             IF (J==2) XP=XP+(/0._EB,EPS,0._EB/) ! shift in y direction
!             IF (J==3) WRITE(LU_ERR,*) 'WARNING: ray test failed'
!       END SELECT
!    ENDDO RAY_TEST_LOOP
!
! ENDDO FACE_LOOP
!
! IF ( MOD(N_INTERSECTIONS,2)/=0 ) POINT_IN_POLYHEDRON=.TRUE.
!
! END FUNCTION POINT_IN_POLYHEDRON
!
! ---------------------------- VALID_TRIANGLE ----------------------------------------

LOGICAL FUNCTION VALID_TRIANGLE(DIR, VERTS, NVERTS, IV1, IV2, IV3,VERT_FLAG)

IMPLICIT NONE
INTEGER, INTENT(IN) :: DIR, NVERTS, IV1, IV2, IV3, VERT_FLAG(0:300)
REAL(FB), INTENT(IN), TARGET :: VERTS(3*NVERTS)

REAL(FB), PARAMETER :: EPS_FB = 1.E-7_FB
REAL(FB), POINTER, DIMENSION(:) :: V, V1, V2, V3
REAL(FB) :: U1(3), U2(3), U1XU2, D123

INTEGER :: I

VALID_TRIANGLE = .FALSE.

V1(1:3)=>VERTS(3*IV1-2:3*IV1)
V2(1:3)=>VERTS(3*IV2-2:3*IV2)
V3(1:3)=>VERTS(3*IV3-2:3*IV3)

U1 = V2 - V1;
U2 = V3 - V2;

! triangle is invalid if angle at V2 is > 180 deg

IF(DIR==1) THEN
   U1(1) = U1(2)
   U1(2) = U1(3)
   U2(1) = U2(2)
   U2(2) = U2(3)
ELSE IF(DIR==2) THEN
   U1(2) = U1(1)
   U1(1) = U1(3)
   U2(2) = U2(1)
   U2(1) = U2(3)
ELSE
   U1(1) = U1(1)
   U1(2) = U1(2)
   U2(1) = U2(1)
   U2(2) = U2(2)
ENDIF
U1(1:2) = U1(1:2) / SQRT(U1(1)**2._FB+U1(2)**2._FB) ! Normalize
U2(1:2) = U2(1:2) / SQRT(U2(1)**2._FB+U2(2)**2._FB) ! Normalize
U1XU2 = U1(1)*U2(2)-U1(2)*U2(1) ! U1 x U2
IF (U1XU2 < EPS_FB) RETURN

DO I = 1, NVERTS
  IF (VERT_FLAG(I) == 0) CYCLE
  IF (I == IV1 .OR. I == IV2 .OR.I == IV3 ) CYCLE
  V(1:3)=>VERTS(3*I-2:3*I)
  ! These CYCLE tests are done to treat holes properly:
  D123=SQRT( (V(1)-V1(1))**2._FB + (V(2)-V1(2))**2._FB + (V(3)-V1(3))**2._FB )
  IF (D123 < EPS_FB) CYCLE
  D123=SQRT( (V(1)-V2(1))**2._FB + (V(2)-V2(2))**2._FB + (V(3)-V2(3))**2._FB )
  IF (D123 < EPS_FB) CYCLE
  D123=SQRT( (V(1)-V3(1))**2._FB + (V(2)-V3(2))**2._FB + (V(3)-V3(3))**2._FB )
  IF (D123 < EPS_FB) CYCLE
  IF (POINT_IN_TRIANGLE_FB(V, V1, V2, V3)) RETURN
ENDDO

VALID_TRIANGLE = .TRUE.
END FUNCTION VALID_TRIANGLE

! ------------------------- PT_LINE_DISTANCE_2D ------------------------------------

! REAL(FB) FUNCTION PT_LINE_DISTANCE_2D(X0,Y0,X1,Y1,X2,Y2)
!
! REAL(FB), INTENT(IN) :: X0,Y0,X1,Y1,X2,Y2
!
! ! Local Variables:
! REAL(FB), PARAMETER :: EPS_FB = 1.E-7_FB
! REAL(FB) :: X3,Y3
! REAL(FB) :: DX01,DY01,DX21,DY21,DSQ
! REAL(FB) :: DPRM = -1._FB
!
! DX01 = X0 - X1
! DY01 = Y0 - Y1
! DX21 = X2 - X1
! DY21 = Y2 - Y1
! DSQ  = DX21**2._FB + DY21**2._FB
! IF (DSQ > EPS_FB**2) DPRM=(DX01*DX21+DY01*DY21)/DSQ
! IF (DPRM < EPS_FB) THEN
!    X3=X1; Y3=Y1
! ELSE IF (DPRM > (1._FB+EPS_FB)) THEN
!    X3=X2; Y3=Y2
! ELSE
!    X3 = X1 + DPRM*DX21
!    Y3 = Y1 + DPRM*DY21
! ENDIF
!
! PT_LINE_DISTANCE_2D = SQRT( (X0-X3)**2._FB + (Y0-Y3)**2._FB )
!
! END FUNCTION PT_LINE_DISTANCE_2D


! ----------------------------- DIFF_ANGLE -----------------------------------------

LOGICAL FUNCTION DIFF_ANGLE(DIR, VERTS, NVERTS, IV1, IV2, IV3, ABS_FLG)

IMPLICIT NONE
INTEGER, INTENT(IN) :: DIR, NVERTS, IV1, IV2, IV3
REAL(FB), INTENT(IN), TARGET :: VERTS(3*NVERTS)
LOGICAL, INTENT(IN) :: ABS_FLG

REAL(FB), PARAMETER :: EPS_FB = 1.E-7_FB
REAL(FB), PARAMETER :: EPS_MID= 1.E-4_FB
REAL(FB), POINTER, DIMENSION(:) :: V1, V2, V3
REAL(FB) :: U1(3), U2(3), CRPD(3)
LOGICAL :: TEST_FLAG=.FALSE.

DIFF_ANGLE = .FALSE.

V1(1:3)=>VERTS(3*IV1-2:3*IV1)
V2(1:3)=>VERTS(3*IV2-2:3*IV2)
V3(1:3)=>VERTS(3*IV3-2:3*IV3)

U1 = V2 - V1;
U2 = V3 - V2;

! triangle is invalid if angle at V2 is > 180 deg
SELECT CASE(DIR)
CASE(IAXIS)
   U1(1) = U1(2)
   U1(2) = U1(3)
   U2(1) = U2(2)
   U2(2) = U2(3)
CASE(JAXIS)
   U1(2) = U1(1)
   U1(1) = U1(3)
   U2(2) = U2(1)
   U2(1) = U2(3)
CASE(KAXIS)
   U1(1) = U1(1)
   U1(2) = U1(2)
   U2(1) = U2(1)
   U2(2) = U2(2)
CASE(0) ! 3D Cross for Inboundary faces:
   U1(1:3) = U1(1:3) / SQRT(U1(1)**2._FB+U1(2)**2._FB+U1(3)**2._FB) ! Normalize
   U2(1:3) = U2(1:3) / SQRT(U2(1)**2._FB+U2(2)**2._FB+U2(3)**2._FB) ! Normalize
   CRPD(1) = U1(2)*U2(3)-U1(3)*U2(2)
   CRPD(2) = U1(3)*U2(1)-U1(1)*U2(3)
   CRPD(3) = U1(1)*U2(2)-U1(2)*U2(1)
   ! ABS_FLG always .TRUE. in the 3D case:
   IF (SQRT(CRPD(1)**2._FB+CRPD(2)**2._FB+CRPD(3)**2._FB) < EPS_FB) DIFF_ANGLE = .TRUE.
   RETURN
END SELECT

U1(1:2) = U1(1:2) / SQRT(U1(1)**2._FB+U1(2)**2._FB) ! Normalize
U2(1:2) = U2(1:2) / SQRT(U2(1)**2._FB+U2(2)**2._FB) ! Normalize
IF (ABS_FLG) THEN
   TEST_FLAG=ABS(U1(1)*U2(2)-U1(2)*U2(1)) < EPS_MID
ELSE
   TEST_FLAG=    U1(1)*U2(2)-U1(2)*U2(1)  < EPS_FB
ENDIF
IF (TEST_FLAG) DIFF_ANGLE = .TRUE.

RETURN

END FUNCTION DIFF_ANGLE

! ---------------------------- POINT_IN_TRIANGLE_FB ----------------------------------------

LOGICAL FUNCTION POINT_IN_TRIANGLE_FB(P_FB,V1_FB,V2_FB,V3_FB)
IMPLICIT NONE

REAL(FB), INTENT(IN) :: P_FB(3),V1_FB(3),V2_FB(3),V3_FB(3)
REAL(EB)             :: P_EB(3),V1_EB(3),V2_EB(3),V3_EB(3)

 P_EB = REAL( P_FB,EB)
V1_EB = REAL(V1_FB,EB)
V2_EB = REAL(V2_FB,EB)
V3_EB = REAL(V3_FB,EB)
POINT_IN_TRIANGLE_FB = POINT_IN_TRIANGLE(P_EB,V1_EB,V2_EB,V3_EB)

END FUNCTION POINT_IN_TRIANGLE_FB

! ---------------------------- POINT_IN_TRIANGLE ----------------------------------------

LOGICAL FUNCTION POINT_IN_TRIANGLE(P,V1,V2,V3)
USE MATH_FUNCTIONS, ONLY: CROSS_PRODUCT
IMPLICIT NONE

REAL(EB), INTENT(IN) :: P(3),V1(3),V2(3),V3(3)
REAL(EB) :: E(3),E1(3),E2(3),N(3),R(3),Q(3)
INTEGER :: I
REAL(EB), PARAMETER :: EPS=1.E-16_EB

! This routine tests whether the projection of P, in the plane normal
! direction, onto to the plane defined by the triangle (V1,V2,V3) is
! inside the triangle.

POINT_IN_TRIANGLE=.TRUE. ! start by assuming the point is inside

! compute face normal
E1 = V2-V1
E2 = V3-V1
CALL CROSS_PRODUCT(N,E1,E2)

EDGE_LOOP: DO I=1,3
   SELECT CASE(I)
      CASE(1)
         E = V2-V1
         R = P-V1
      CASE(2)
         E = V3-V2
         R = P-V2
      CASE(3)
         E = V1-V3
         R = P-V3
   END SELECT
   CALL CROSS_PRODUCT(Q,E,R)
   IF ( DOT_PRODUCT(Q,N) < -EPS ) THEN
      POINT_IN_TRIANGLE=.FALSE.
      RETURN
   ENDIF
ENDDO EDGE_LOOP

END FUNCTION POINT_IN_TRIANGLE

! ---------------------------- TRIANGULATE ----------------------------------------

SUBROUTINE TRIANGULATE(DIR,VERTS,NVERTS,VERT_OFFSET,FACES,LOCTYPE)

INTEGER, INTENT(IN) :: DIR, NVERTS, VERT_OFFSET
REAL(FB), INTENT(IN), TARGET :: VERTS(3*NVERTS)
INTEGER, INTENT(OUT) :: FACES(3*(NVERTS-2))
INTEGER, INTENT(OUT) :: LOCTYPE(NVERTS-2)

INTEGER :: IFACE, NLIST, NLIST_OLD
INTEGER :: VERT_LIST(0:300), VERT_FLAG(0:300), EDGE_LIST(2,1:300)
LOGICAL :: NODE_EXISTS(300)
INTEGER :: IM1, I, IP1, V0, V1, V2, IVERT, IEDGE
LOGICAL HAVE_TRIANGLE
REAL(FB), POINTER, DIMENSION(:) :: VV1, VV2, VV3
REAL(FB) :: U1(3), U2(3), U1XU2
REAL(FB), PARAMETER :: EPS_FB = 1.E-7_FB
INTEGER :: NBIG_ANGLES, VERT_START
LOGICAL :: VERT_DROPPED, FLAG

INTEGER :: HIDEDGE(3), EDGEI(1:2), NVERTS2, NEDGES, COUNT
INTEGER, PARAMETER :: SHFT_NODE(1:4) = (/ 2, 1, 0, 2 /)

FLAG = .TRUE.

! Drop vertices contained whithin lines of the polygon:
VERT_FLAG(1:NVERTS)=1
DO I = 1, NVERTS
   IM1 = I - 1
   IF (I==1     )IM1 = NVERTS
   IP1 = I + 1
   IF (I==NVERTS)IP1 = 1
   IF ( DIFF_ANGLE(DIR,VERTS,NVERTS,IM1,I,IP1,.TRUE.) ) VERT_FLAG(I)=0 ! Vertex located in line joining neighbors.
ENDDO

NLIST  = SUM(VERT_FLAG(1:NVERTS))
NVERTS2= NLIST
NEDGES = NLIST
COUNT = 0
DO I = 1, NVERTS
   IF(VERT_FLAG(I)==0) CYCLE
   COUNT= COUNT + 1
   VERT_LIST(COUNT) = I
ENDDO
VERT_LIST(0) = VERT_LIST(NLIST)
VERT_LIST(NLIST+1) = VERT_LIST(1)
NODE_EXISTS(1:NLIST+1) = .TRUE.
DO I = 1, NLIST-1
   EDGE_LIST(1:2,I) = (/ VERT_LIST(I),     VERT_LIST(I+1) /)
ENDDO
EDGE_LIST(1:2,NLIST) = (/ VERT_LIST(NEDGES), VERT_LIST(1) /)
FACES(1:3*(NVERTS-2)) = VERT_OFFSET+VERT_LIST(NLIST)

IF (DIR == 0) THEN ! INBOUNDARY cut-face, always convex polygon.
   VERT_START = VERT_LIST(1)
   IFACE = 0
   DO I = 1, NVERTS2
      IP1 = I + 1
      IF (I==NVERTS2) IP1=1
      IF (I==VERT_START .OR. IP1==VERT_START) CYCLE
      FACES(3*IFACE+1) = VERT_OFFSET+VERT_LIST(VERT_START)
      FACES(3*IFACE+2) = VERT_OFFSET+VERT_LIST(I)
      FACES(3*IFACE+3) = VERT_OFFSET+VERT_LIST(IP1)
      IFACE = IFACE + 1
   ENDDO
   ! Here test edges to define LOCTYPE:
   LOCTYPE(:) = 4+8+16
   DO IFACE=1,NVERTS2-2
      HIDEDGE(1:3) = 1 ! Initialize to hidden all edges.
      DO IEDGE=1,3
         ! Nodes i,i+1:
         EDGEI(1:2) = (/ FACES(3*IFACE-SHFT_NODE(IEDGE))-VERT_OFFSET, FACES(3*IFACE-SHFT_NODE(IEDGE+1))-VERT_OFFSET /)
         DO I=1,NEDGES
            IF(EDGE_LIST(1,I)==EDGEI(1) .AND. EDGE_LIST(2,I)==EDGEI(2)) THEN
               HIDEDGE(IEDGE) = 0 ! Edge belongs to polygon, set to plot.
               EXIT
            ENDIF
         ENDDO
      ENDDO
      LOCTYPE(IFACE) = 4 * HIDEDGE(1) + 8 * HIDEDGE(2) + 16 * HIDEDGE(3)
   ENDDO
   RETURN
ENDIF

IF (FLAG) THEN ! find number of angles > 180 deg
   NBIG_ANGLES = 0
   VERT_START = VERT_LIST(1)
   DO I = 1, NVERTS2
      IM1 = I - 1
      IF (I==1)IM1 = NVERTS2
      IP1 = I + 1
      IF (I==NVERTS2)IP1 = 1
      IF ( DIFF_ANGLE(DIR,VERTS,NVERTS,VERT_LIST(IM1),VERT_LIST(I),VERT_LIST(IP1),.FALSE.) ) THEN
         NBIG_ANGLES = NBIG_ANGLES + 1
         VERT_START = I
      ENDIF
   END DO

   ! if 0 angles (convex) or 1 angle (simple concave) then triangulate using a fan
   IF ( NBIG_ANGLES <= 1 ) THEN
      IFACE = 0
      DO I = 1, NVERTS2
         IP1 = I + 1
         IF (I==NVERTS2) IP1=1
         IF (I==VERT_START .OR. IP1==VERT_START) CYCLE
         FACES(3*IFACE+1) = VERT_OFFSET+VERT_LIST(VERT_START)
         FACES(3*IFACE+2) = VERT_OFFSET+VERT_LIST(I)
         FACES(3*IFACE+3) = VERT_OFFSET+VERT_LIST(IP1)
         IFACE = IFACE + 1
      ENDDO
      ! Here test edges to define LOCTYPE:
      LOCTYPE(:) = 4+8+16
      DO IFACE=1,NVERTS2-2
         HIDEDGE(1:3) = 1 ! Initialize to hidden all edges.
         DO IEDGE=1,3
            ! Nodes i,i+1:
            EDGEI(1:2) = (/ FACES(3*IFACE-SHFT_NODE(IEDGE))-VERT_OFFSET, FACES(3*IFACE-SHFT_NODE(IEDGE+1))-VERT_OFFSET /)
            DO I=1,NEDGES
               IF(EDGE_LIST(1,I)==EDGEI(1) .AND. EDGE_LIST(2,I)==EDGEI(2)) THEN
                  HIDEDGE(IEDGE) = 0 ! Edge belongs to polygon, set to plot.
                  EXIT
               ENDIF
            ENDDO
         ENDDO
         LOCTYPE(IFACE) = 4 * HIDEDGE(1) + 8 * HIDEDGE(2) + 16 * HIDEDGE(3)
      ENDDO
      RETURN
   ENDIF
ENDIF

! more than 1 angles in polygon > 180 deg
IFACE = 1
OUTER: DO WHILE (NLIST>=3)
   IVERT = 1
   HAVE_TRIANGLE = .FALSE.
   INNER: DO WHILE (IVERT<=NLIST)
      V0 = VERT_LIST(IVERT-1)
      V1 = VERT_LIST(IVERT)
      V2 = VERT_LIST(IVERT+1)
      IF(.NOT.NODE_EXISTS(IVERT+1))EXIT INNER
      IF(NLIST==3.OR.VALID_TRIANGLE(DIR,VERTS,NVERTS,V0,V1,V2,VERT_FLAG)) THEN
         FACES(IFACE  ) = VERT_OFFSET+V0
         FACES(IFACE+1) = VERT_OFFSET+V1
         FACES(IFACE+2) = VERT_OFFSET+V2
         IF (NLIST == 3) EXIT OUTER
         IFACE = IFACE + 3
         NODE_EXISTS(IVERT) = .FALSE.
         IF(IVERT==1) NODE_EXISTS(NLIST+1) = .FALSE.
         HAVE_TRIANGLE = .TRUE.
         IVERT = IVERT + 2
      ELSE
         IVERT = IVERT + 1
      ENDIF
   ENDDO INNER
   NLIST_OLD = NLIST
   NLIST = 0
   DO I = 1, NLIST_OLD
      IF(NODE_EXISTS(I))THEN
         NLIST = NLIST + 1
         VERT_LIST(NLIST) = VERT_LIST(I)
      ENDIF
   ENDDO
   VERT_LIST(0) = VERT_LIST(NLIST)
   VERT_LIST(NLIST+1) = VERT_LIST(1)
   NODE_EXISTS(1:NLIST+1) = .TRUE.

   ! Test for nodes connecting parallel edges, if found drop them:
   VERT_DROPPED=.FALSE.
   DO I=1,NLIST
      V0=VERT_LIST(I-1); V1=VERT_LIST(I); V2=VERT_LIST(I+1);
      VV1(1:3)=>VERTS(3*V0-2:3*V0)
      VV2(1:3)=>VERTS(3*V1-2:3*V1)
      VV3(1:3)=>VERTS(3*V2-2:3*V2)
      U1 = VV2 - VV1;
      U2 = VV3 - VV2;
      SELECT CASE(DIR)
      CASE(IAXIS)
          U1(1) = U1(2); U1(2) = U1(3)
          U2(1) = U2(2); U2(2) = U2(3)
      CASE(JAXIS)
          U1(2) = U1(1); U1(1) = U1(3)
          U2(2) = U2(1); U2(1) = U2(3)
      CASE(KAXIS)
          U1(1) = U1(1); U1(2) = U1(2)
          U2(1) = U2(1); U2(2) = U2(2)
      END SELECT
      U1(1:2) = U1(1:2) / SQRT(U1(1)**2._FB+U1(2)**2._FB) ! Normalize
      U2(1:2) = U2(1:2) / SQRT(U2(1)**2._FB+U2(2)**2._FB) ! Normalize
      IF (U1(1)*U2(1)+U1(2)*U2(2) > -EPS_FB) CYCLE
      U1XU2  = U1(1)*U2(2)-U1(2)*U2(1) ! U1 x U2
      IF (ABS(U1XU2) < EPS_FB) THEN ! Triple product less than EPS
         VERT_DROPPED=.TRUE.; NODE_EXISTS(I)=.FALSE.
         IF (IFACE < 3*(NVERTS2-2)) THEN
            FACES(IFACE  ) = VERT_OFFSET+V0
            FACES(IFACE+1) = VERT_OFFSET+V1
            FACES(IFACE+2) = VERT_OFFSET+V2
            IFACE = IFACE + 3
         ENDIF
         IF (NLIST == 3) EXIT OUTER
      ENDIF
   ENDDO
   IF (VERT_DROPPED) THEN
      ! Repeat List generation:
      NLIST_OLD = NLIST
      NLIST = 0
      DO I = 1, NLIST_OLD
         IF(NODE_EXISTS(I))THEN
            NLIST = NLIST + 1
            VERT_LIST(NLIST) = VERT_LIST(I)
         ENDIF
      ENDDO
      VERT_LIST(0) = VERT_LIST(NLIST)
      VERT_LIST(NLIST+1) = VERT_LIST(1)
      NODE_EXISTS(1:NLIST+1) = .TRUE.
   ENDIF
ENDDO OUTER

! Here test edges to define LOCTYPE:
LOCTYPE(:) = 4+8+16
DO IFACE=1,NVERTS2-2
   HIDEDGE(1:3) = 1 ! Initialize to hidden all edges.
   DO IEDGE=1,3
      ! Nodes i,i+1:
      EDGEI(1:2) = (/ FACES(3*IFACE-SHFT_NODE(IEDGE))-VERT_OFFSET, FACES(3*IFACE-SHFT_NODE(IEDGE+1))-VERT_OFFSET /)
      DO I=1,NEDGES
         IF(EDGE_LIST(1,I)==EDGEI(1) .AND. EDGE_LIST(2,I)==EDGEI(2)) THEN
            HIDEDGE(IEDGE) = 0 ! Edge belongs to polygon, set to plot.
            EXIT
         ENDIF
      ENDDO
   ENDDO
   LOCTYPE(IFACE) = 4 * HIDEDGE(1) + 8 * HIDEDGE(2) + 16 * HIDEDGE(3)
ENDDO

RETURN
END SUBROUTINE TRIANGULATE

! ! ---------------------------- TRIANGULATE2 ----------------------------------------
!
! SUBROUTINE TRIANGULATE2(DIR, VERTS,NVERTS,VERT_OFFSET,FACES)
!   INTEGER, INTENT(IN) :: DIR, NVERTS, VERT_OFFSET
!   REAL(FB), INTENT(IN) :: VERTS(3*NVERTS)
!   INTEGER, INTENT(OUT) :: FACES(3*(NVERTS-2))
!   INTEGER :: IVERT
!
!
!   IF (VERTS(1)*VERTS(1)<0.0 .OR. DIR==4) THEN
!   ! a dummy checks to prevent compiler warnings for unused variables
!   ! (we need VERTS eventually  but don't need VERTS now)
!      RETURN
!   ENDIF
!   DO IVERT = 1, NVERTS - 2 ! for now assume face is convex
!   ! vertex indices 1, 2, ..., NVF
!   ! faces (1,2,3), (1,3,4), ..., (1,NVF-1,NVF)
!     FACES(3*IVERT-2) = VERT_OFFSET+1
!     FACES(3*IVERT-1) = VERT_OFFSET+1+IVERT
!     FACES(3*IVERT)   = VERT_OFFSET+2+IVERT
!   ENDDO
! END SUBROUTINE TRIANGULATE2

! ! ---------------------------- RAY_TRIANGLE_INTERSECT ----------------------------------------
!
! INTEGER FUNCTION RAY_TRIANGLE_INTERSECT(TRI,XP,D)
! USE MATH_FUNCTIONS, ONLY: CROSS_PRODUCT
! IMPLICIT NONE
!
! INTEGER, INTENT(IN) :: TRI
! REAL(EB), INTENT(IN) :: XP(3),D(3)
! REAL(EB) :: E1(3),E2(3),P(3),S(3),Q(3),U,V,TMP,V1(3),V2(3),V3(3),T !,XI(3)
! REAL(EB), PARAMETER :: EPS=1.E-10_EB
!
! ! Schneider and Eberly, Section 11.1
!
! V1(1) = VERTEX(FACET(TRI)%VERTEX(1))%X
! V1(2) = VERTEX(FACET(TRI)%VERTEX(1))%Y
! V1(3) = VERTEX(FACET(TRI)%VERTEX(1))%Z
!
! V2(1) = VERTEX(FACET(TRI)%VERTEX(2))%X
! V2(2) = VERTEX(FACET(TRI)%VERTEX(2))%Y
! V2(3) = VERTEX(FACET(TRI)%VERTEX(2))%Z
!
! V3(1) = VERTEX(FACET(TRI)%VERTEX(3))%X
! V3(2) = VERTEX(FACET(TRI)%VERTEX(3))%Y
! V3(3) = VERTEX(FACET(TRI)%VERTEX(3))%Z
!
! E1 = V2-V1
! E2 = V3-V1
!
! CALL CROSS_PRODUCT(P,D,E2)
!
! TMP = DOT_PRODUCT(P,E1)
!
! IF ( ABS(TMP)<EPS ) THEN
!    RAY_TRIANGLE_INTERSECT=0
!    RETURN
! ENDIF
!
! TMP = 1._EB/TMP
! S = XP-V1
!
! U = TMP*DOT_PRODUCT(S,P)
! IF (U<-EPS .OR. U>(1._EB+EPS)) THEN
!    ! ray does not intersect triangle
!    RAY_TRIANGLE_INTERSECT=0
!    RETURN
! ENDIF
!
! IF (U<EPS .OR. U>(1._EB-EPS)) THEN
!    ! ray intersects edge
!    RAY_TRIANGLE_INTERSECT=2
!    RETURN
! ENDIF
!
! CALL CROSS_PRODUCT(Q,S,E1)
! V = TMP*DOT_PRODUCT(D,Q)
! IF (V<-EPS .OR. (U+V)>(1._EB+EPS)) THEN
!    ! ray does not intersect triangle
!    RAY_TRIANGLE_INTERSECT=0
!    RETURN
! ENDIF
!
! IF (V<EPS .OR. (U+V)>(1._EB-EPS)) THEN
!    ! ray intersects edge
!    RAY_TRIANGLE_INTERSECT=2
!    RETURN
! ENDIF
!
! T = TMP*DOT_PRODUCT(E2,Q)
! !XI = XP + T*D ! the intersection point
!
! IF (T>0._EB) THEN
!    RAY_TRIANGLE_INTERSECT=1
! ELSE
!    RAY_TRIANGLE_INTERSECT=0
! ENDIF
! RETURN
!
! END FUNCTION RAY_TRIANGLE_INTERSECT
!
! ---------------------------- TRILINEAR ----------------------------------------

REAL(EB) FUNCTION TRILINEAR(UU,DXI,LL)
IMPLICIT NONE

REAL(EB), INTENT(IN) :: UU(0:1,0:1,0:1),DXI(3),LL(3)
REAL(EB) :: XX,YY,ZZ

! Comments:
!
! see http://local.wasp.uwa.edu.au/~pbourke/miscellaneous/interpolation/index.html
! with appropriate scaling. LL is length of side.
!
!                       UU(1,1,1)
!        z /----------/
!        ^/          / |
!        ------------  |    Particle position
!        |          |  |
!  LL(3) |   o<-----|------- DXI = [DXI(1),DXI(2),DXI(3)]
!        |          | /
!        |          |/      Particle property at XX = TRILINEAR
!        ------------> x
!        ^
!        |
!   X0 = [0,0,0]
!
!    UU(0,0,0)
!
!===========================================================

XX = DXI(1)/LL(1)
YY = DXI(2)/LL(2)
ZZ = DXI(3)/LL(3)

TRILINEAR = UU(0,0,0)*(1._EB-XX)*(1._EB-YY)*(1._EB-ZZ) + &
            UU(1,0,0)*XX*(1._EB-YY)*(1._EB-ZZ) +         &
            UU(0,1,0)*(1._EB-XX)*YY*(1._EB-ZZ) +         &
            UU(0,0,1)*(1._EB-XX)*(1._EB-YY)*ZZ +         &
            UU(1,0,1)*XX*(1._EB-YY)*ZZ +                 &
            UU(0,1,1)*(1._EB-XX)*YY*ZZ +                 &
            UU(1,1,0)*XX*YY*(1._EB-ZZ) +                 &
            UU(1,1,1)*XX*YY*ZZ

END FUNCTION TRILINEAR

! ---------------------------- GETU ----------------------------------------

SUBROUTINE GETU(U_DATA,DXI,XI_IN,I_VEL,NM)
IMPLICIT NONE

REAL(EB), INTENT(OUT) :: U_DATA(0:1,0:1,0:1),DXI(3)
REAL(EB), INTENT(IN) :: XI_IN(3)
INTEGER, INTENT(IN) :: I_VEL,NM
TYPE(MESH_TYPE), POINTER :: M
REAL(EB), POINTER, DIMENSION(:,:,:) :: UU,VV,WW
INTEGER :: II,JJ,KK
REAL(EB) :: XI(3)

M=>MESHES(NM)
IF (PREDICTOR) THEN
   UU => M%U
   VV => M%V
   WW => M%W
ELSE
   UU => M%US
   VV => M%VS
   WW => M%WS
ENDIF

!II = INDU(1)
!JJ = INDU(2)
!KK = INDU(3)
!
!IF (XI(1)<XU(1)) THEN
!   N=CEILING((XU(1)-XI(1))/M%DX(II))
!   II=MAX(0,II-N)
!   DXI(1)=XI(1)-(XU(1)-REAL(N,EB)*M%DX(II))
!ELSE
!   N=FLOOR((XI(1)-XU(1))/M%DX(II))
!   II=MIN(IBP1,II+N)
!   DXI(1)=XI(1)-(XU(1)+REAL(N,EB)*M%DX(II))
!ENDIF
!
!IF (XI(2)<XU(2)) THEN
!   N=CEILING((XU(2)-XI(2))/M%DY(JJ))
!   JJ=MAX(0,JJ-N)
!   DXI(2)=XI(2)-(XU(2)-REAL(N,EB)*M%DY(JJ))
!ELSE
!   N=FLOOR((XI(2)-XU(2))/M%DY(JJ))
!   JJ=MIN(JBP1,JJ+N)
!   DXI(2)=XI(2)-(XU(2)+REAL(N,EB)*M%DY(JJ))
!ENDIF
!
!IF (XI(3)<XU(3)) THEN
!   N=CEILING((XU(3)-XI(3))/M%DZ(KK))
!   KK=MAX(0,KK-N)
!   DXI(3)=XI(3)-(XU(3)-REAL(N,EB)*M%DZ(KK))
!ELSE
!   N=FLOOR((XI(3)-XU(3))/M%DZ(KK))
!   KK=MIN(KBP1,KK+N)
!   DXI(3)=XI(3)-(XU(3)+REAL(N,EB)*M%DZ(KK))
!ENDIF

XI(1) = MAX(M%XS,MIN(M%XF,XI_IN(1)))
XI(2) = MAX(M%YS,MIN(M%YF,XI_IN(2)))
XI(3) = MAX(M%ZS,MIN(M%ZF,XI_IN(3)))

SELECT CASE(I_VEL)
   CASE(1)
      II = FLOOR((XI(1)-M%XS)/M%DX(1))
      JJ = FLOOR((XI(2)-M%YS)/M%DY(1)+0.5_EB)
      KK = FLOOR((XI(3)-M%ZS)/M%DZ(1)+0.5_EB)
      DXI(1) = XI(1) - M%X(II)
      DXI(2) = XI(2) - M%YC(JJ)
      DXI(3) = XI(3) - M%ZC(KK)
   CASE(2)
      II = FLOOR((XI(1)-M%XS)/M%DX(1)+0.5_EB)
      JJ = FLOOR((XI(2)-M%YS)/M%DY(1))
      KK = FLOOR((XI(3)-M%ZS)/M%DZ(1)+0.5_EB)
      DXI(1) = XI(1) - M%XC(II)
      DXI(2) = XI(2) - M%Y(JJ)
      DXI(3) = XI(3) - M%ZC(KK)
   CASE(3)
      II = FLOOR((XI(1)-M%XS)/M%DX(1)+0.5_EB)
      JJ = FLOOR((XI(2)-M%YS)/M%DY(1)+0.5_EB)
      KK = FLOOR((XI(3)-M%ZS)/M%DZ(1))
      DXI(1) = XI(1) - M%XC(II)
      DXI(2) = XI(2) - M%YC(JJ)
      DXI(3) = XI(3) - M%Z(KK)
   CASE(4)
      II = FLOOR((XI(1)-M%XS)/M%DX(1)+0.5_EB)
      JJ = FLOOR((XI(2)-M%YS)/M%DY(1)+0.5_EB)
      KK = FLOOR((XI(3)-M%ZS)/M%DZ(1)+0.5_EB)
      DXI(1) = XI(1) - M%XC(II)
      DXI(2) = XI(2) - M%YC(JJ)
      DXI(3) = XI(3) - M%ZC(KK)
END SELECT

DXI = MAX(0._EB,DXI)

SELECT CASE(I_VEL)
   CASE(1)
      U_DATA(0,0,0) = UU(II,JJ,KK)
      U_DATA(1,0,0) = UU(II+1,JJ,KK)
      U_DATA(0,1,0) = UU(II,JJ+1,KK)
      U_DATA(0,0,1) = UU(II,JJ,KK+1)
      U_DATA(1,0,1) = UU(II+1,JJ,KK+1)
      U_DATA(0,1,1) = UU(II,JJ+1,KK+1)
      U_DATA(1,1,0) = UU(II+1,JJ+1,KK)
      U_DATA(1,1,1) = UU(II+1,JJ+1,KK+1)
   CASE(2)
      U_DATA(0,0,0) = VV(II,JJ,KK)
      U_DATA(1,0,0) = VV(II+1,JJ,KK)
      U_DATA(0,1,0) = VV(II,JJ+1,KK)
      U_DATA(0,0,1) = VV(II,JJ,KK+1)
      U_DATA(1,0,1) = VV(II+1,JJ,KK+1)
      U_DATA(0,1,1) = VV(II,JJ+1,KK+1)
      U_DATA(1,1,0) = VV(II+1,JJ+1,KK)
      U_DATA(1,1,1) = VV(II+1,JJ+1,KK+1)
   CASE(3)
      U_DATA(0,0,0) = WW(II,JJ,KK)
      U_DATA(1,0,0) = WW(II+1,JJ,KK)
      U_DATA(0,1,0) = WW(II,JJ+1,KK)
      U_DATA(0,0,1) = WW(II,JJ,KK+1)
      U_DATA(1,0,1) = WW(II+1,JJ,KK+1)
      U_DATA(0,1,1) = WW(II,JJ+1,KK+1)
      U_DATA(1,1,0) = WW(II+1,JJ+1,KK)
      U_DATA(1,1,1) = WW(II+1,JJ+1,KK+1)
   CASE(4) ! viscosity
      U_DATA(0,0,0) = M%MU(II,JJ,KK)
      U_DATA(1,0,0) = M%MU(II+1,JJ,KK)
      U_DATA(0,1,0) = M%MU(II,JJ+1,KK)
      U_DATA(0,0,1) = M%MU(II,JJ,KK+1)
      U_DATA(1,0,1) = M%MU(II+1,JJ,KK+1)
      U_DATA(0,1,1) = M%MU(II,JJ+1,KK+1)
      U_DATA(1,1,0) = M%MU(II+1,JJ+1,KK)
      U_DATA(1,1,1) = M%MU(II+1,JJ+1,KK+1)
END SELECT

END SUBROUTINE GETU

! ---------------------------- GETGRAD ----------------------------------------

SUBROUTINE GETGRAD(G_DATA,DXI,XI,XU,INDU,COMP_I,COMP_J,NM)
IMPLICIT NONE

REAL(EB), INTENT(OUT) :: G_DATA(0:1,0:1,0:1),DXI(3)
REAL(EB), INTENT(IN) :: XI(3),XU(3)
INTEGER, INTENT(IN) :: INDU(3),COMP_I,COMP_J,NM
TYPE(MESH_TYPE), POINTER :: M
REAL(EB), POINTER, DIMENSION(:,:,:) :: DUDX
INTEGER :: II,JJ,KK,N
CHARACTER(MESSAGE_LENGTH) :: MESSAGE

M=>MESHES(NM)

IF (COMP_I==1 .AND. COMP_J==1) DUDX => M%WORK5
IF (COMP_I==1 .AND. COMP_J==2) DUDX => M%IBM_SAVE1
IF (COMP_I==1 .AND. COMP_J==3) DUDX => M%IBM_SAVE2
IF (COMP_I==2 .AND. COMP_J==1) DUDX => M%IBM_SAVE3
IF (COMP_I==2 .AND. COMP_J==2) DUDX => M%WORK6
IF (COMP_I==2 .AND. COMP_J==3) DUDX => M%IBM_SAVE4
IF (COMP_I==3 .AND. COMP_J==1) DUDX => M%IBM_SAVE5
IF (COMP_I==3 .AND. COMP_J==2) DUDX => M%IBM_SAVE6
IF (COMP_I==3 .AND. COMP_J==3) DUDX => M%WORK7

II = INDU(1)
JJ = INDU(2)
KK = INDU(3)

IF (XI(1)<XU(1)) THEN
   N=CEILING((XU(1)-XI(1))/M%DX(II))
   II=MAX(0,II-N)
   DXI(1)=XI(1)-(XU(1)-REAL(N,EB)*M%DX(II))
ELSE
   N=FLOOR((XI(1)-XU(1))/M%DX(II))
   II=MIN(IBP1,II+N)
   DXI(1)=XI(1)-(XU(1)+REAL(N,EB)*M%DX(II))
ENDIF

IF (XI(2)<XU(2)) THEN
   N=CEILING((XU(2)-XI(2))/M%DY(JJ))
   JJ=MAX(0,JJ-N)
   DXI(2)=XI(2)-(XU(2)-REAL(N,EB)*M%DY(JJ))
ELSE
   N=FLOOR((XI(2)-XU(2))/M%DY(JJ))
   JJ=MIN(JBP1,JJ+N)
   DXI(2)=XI(2)-(XU(2)+REAL(N,EB)*M%DY(JJ))
ENDIF

IF (XI(3)<XU(3)) THEN
   N=CEILING((XU(3)-XI(3))/M%DZ(KK))
   KK=MAX(0,KK-N)
   DXI(3)=XI(3)-(XU(3)-REAL(N,EB)*M%DZ(KK))
ELSE
   N=FLOOR((XI(3)-XU(3))/M%DZ(KK))
   KK=MIN(KBP1,KK+N)
   DXI(3)=XI(3)-(XU(3)+REAL(N,EB)*M%DZ(KK))
ENDIF

IF (ANY(DXI<0._EB)) THEN
   WRITE(MESSAGE,'(A)') 'ERROR: DXI<0 in GETGRAD'
   CALL SHUTDOWN(MESSAGE)
ENDIF
IF (DXI(1)>M%DX(II) .OR. DXI(2)>M%DY(JJ) .OR. DXI(3)>M%DZ(KK)) THEN
   WRITE(MESSAGE,'(A)') 'ERROR: DXI>DX in GETGRAD'
   CALL SHUTDOWN(MESSAGE)
ENDIF

G_DATA(0,0,0) = DUDX(II,JJ,KK)
G_DATA(1,0,0) = DUDX(II+1,JJ,KK)
G_DATA(0,1,0) = DUDX(II,JJ+1,KK)
G_DATA(0,0,1) = DUDX(II,JJ,KK+1)
G_DATA(1,0,1) = DUDX(II+1,JJ,KK+1)
G_DATA(0,1,1) = DUDX(II,JJ+1,KK+1)
G_DATA(1,1,0) = DUDX(II+1,JJ+1,KK)
G_DATA(1,1,1) = DUDX(II+1,JJ+1,KK+1)

END SUBROUTINE GETGRAD


! ! ---------------------------- TRI_PLANE_BOX_INTERSECT ----------------------------------------
!
! SUBROUTINE TRI_PLANE_BOX_INTERSECT(NP,PC,V1,V2,V3,BB)
! USE MATH_FUNCTIONS
! IMPLICIT NONE
! ! get the intersection points (cooridnates) of the BB's 12 edges and the plane of the trianlge
! ! regular intersection polygons with 0, 3, 4, 5, or 6 corners
! ! irregular intersection case (corner, edge, or face intersection) should also be ok.
!
! INTEGER, INTENT(OUT) :: NP
! REAL(EB), INTENT(OUT) :: PC(18) ! max 6 points but maybe repeated at the vertices
! REAL(EB), INTENT(IN) :: V1(3),V2(3),V3(3),BB(6)
! REAL(EB) :: P0(3),P1(3),Q(3),PC_TMP(60)
! INTEGER :: I,J,IERR,IERR2
!
! NP = 0
! EDGE_LOOP: DO I=1,12
!    SELECT CASE(I)
!       CASE(1)
!          P0(1)=BB(1)
!          P0(2)=BB(3)
!          P0(3)=BB(5)
!          P1(1)=BB(2)
!          P1(2)=BB(3)
!          P1(3)=BB(5)
!       CASE(2)
!          P0(1)=BB(2)
!          P0(2)=BB(3)
!          P0(3)=BB(5)
!          P1(1)=BB(2)
!          P1(2)=BB(4)
!          P1(3)=BB(5)
!       CASE(3)
!          P0(1)=BB(2)
!          P0(2)=BB(4)
!          P0(3)=BB(5)
!          P1(1)=BB(1)
!          P1(2)=BB(4)
!          P1(3)=BB(5)
!       CASE(4)
!          P0(1)=BB(1)
!          P0(2)=BB(4)
!          P0(3)=BB(5)
!          P1(1)=BB(1)
!          P1(2)=BB(3)
!          P1(3)=BB(5)
!       CASE(5)
!          P0(1)=BB(1)
!          P0(2)=BB(3)
!          P0(3)=BB(6)
!          P1(1)=BB(2)
!          P1(2)=BB(3)
!          P1(3)=BB(6)
!       CASE(6)
!          P0(1)=BB(2)
!          P0(2)=BB(3)
!          P0(3)=BB(6)
!          P1(1)=BB(2)
!          P1(2)=BB(4)
!          P1(3)=BB(6)
!       CASE(7)
!          P0(1)=BB(2)
!          P0(2)=BB(4)
!          P0(3)=BB(6)
!          P1(1)=BB(1)
!          P1(2)=BB(4)
!          P1(3)=BB(6)
!       CASE(8)
!          P0(1)=BB(1)
!          P0(2)=BB(4)
!          P0(3)=BB(6)
!          P1(1)=BB(1)
!          P1(2)=BB(3)
!          P1(3)=BB(6)
!       CASE(9)
!          P0(1)=BB(1)
!          P0(2)=BB(3)
!          P0(3)=BB(5)
!          P1(1)=BB(1)
!          P1(2)=BB(3)
!          P1(3)=BB(6)
!       CASE(10)
!          P0(1)=BB(2)
!          P0(2)=BB(3)
!          P0(3)=BB(5)
!          P1(1)=BB(2)
!          P1(2)=BB(3)
!          P1(3)=BB(6)
!       CASE(11)
!          P0(1)=BB(2)
!          P0(2)=BB(4)
!          P0(3)=BB(5)
!          P1(1)=BB(2)
!          P1(2)=BB(4)
!          P1(3)=BB(6)
!       CASE(12)
!          P0(1)=BB(1)
!          P0(2)=BB(4)
!          P0(3)=BB(5)
!          P1(1)=BB(1)
!          P1(2)=BB(4)
!          P1(3)=BB(6)
!    END SELECT
!    CALL LINE_SEG_TRI_PLANE_INTERSECT(IERR,IERR2,Q,V1,V2,V3,P0,P1)
!
!    IF (IERR==1) THEN
!       NP=NP+1
!       DO J=1,3
!          PC_TMP((NP-1)*3+J)=Q(J)
!       ENDDO
!    ENDIF
! ENDDO EDGE_LOOP
!
! ! For more than 3 intersection points
! ! they have to be sorted in order to create a convex polygon
! CALL ELIMATE_REPEATED_POINTS(NP,PC_TMP)
! IF ( NP > 6) THEN
!    WRITE(LU_OUTPUT,*)"*** Triangle box intersections"
!    DO I = 1, NP
!       WRITE(LU_OUTPUT,*)I,PC_TMP(3*I-2),PC_TMP(3*I-1),PC_TMP(3*I)
!    ENDDO
!    CALL SHUTDOWN("ERROR: more than 6 triangle box intersections")
! ENDIF
! IF (NP > 3) THEN
!    CALL SORT_POLYGON_CORNERS(NP,V1,V2,V3,PC_TMP)
! ENDIF
! DO I=1,NP*3
!    PC(I) = PC_TMP(I)
! ENDDO
!
! RETURN
! END SUBROUTINE TRI_PLANE_BOX_INTERSECT

! ! ---------------------------- SORT_POLYGON_CORNERS ----------------------------------------
!
! SUBROUTINE SORT_POLYGON_CORNERS(NP,V1,V2,V3,PC)
! USE MATH_FUNCTIONS, ONLY: CROSS_PRODUCT
! IMPLICIT NONE
! ! Sort all the corners of a polygon
! ! Ref: Gernot Hoffmann, Cube Plane Intersection.
!
! INTEGER, INTENT(IN) :: NP
! REAL(EB), INTENT(INOUT) :: PC(60)
! REAL(EB), INTENT(IN) :: V1(3),V2(3),V3(3)
! REAL(EB) :: MEAN_VALUE(3),POLY_NORM(3),R1,R2,TMP(3),U(3),W(3)
! INTEGER :: I,J,K,IOR,NA,NB
!
! IF (NP <=3 ) RETURN
!
! U = V2-V1
! W = V3-V1
! CALL CROSS_PRODUCT(POLY_NORM,U,W)
!
! DO I=1,3
!    MEAN_VALUE(I) = 0._EB
!    DO J=1,NP
!       MEAN_VALUE(I) = MEAN_VALUE(I) + PC((J-1)*3+I)/REAL(NP)
!    ENDDO
! ENDDO
!
! !get normal of ploygan
! IF (ABS(POLY_NORM(1)) >= ABS(POLY_NORM(2)) .AND. ABS(POLY_NORM(1)) >= ABS(POLY_NORM(3)) ) THEN
!    IOR = 1
!    NA = 2
!    NB = 3
! ELSE IF (ABS(POLY_NORM(2)) >= ABS(POLY_NORM(3)) ) THEN
!    IOR = 2
!    NA = 1
!    NB = 3
! ELSE
!    IOR = 3
!    NA = 1
!    NB = 2
! ENDIF
!
! DO I=1,NP-1
!    R1 = ATAN2(PC((I-1)*3+NB)-MEAN_VALUE(NB), PC((I-1)*3+NA)-MEAN_VALUE(NA))
!    DO J=I+1, NP
!       R2 = ATAN2(PC((J-1)*3+NB)-MEAN_VALUE(NB), PC((J-1)*3+NA)-MEAN_VALUE(NA))
!       IF (R2 < R1) THEN
!          DO K=1,3
!             TMP(K) = PC((J-1)*3+K)
!             PC((J-1)*3+K) = PC((I-1)*3+K)
!             PC((I-1)*3+K) = TMP(K)
!             R1 = R2
!          ENDDO
!       ENDIF
!    ENDDO
! ENDDO
!
! RETURN
! END SUBROUTINE SORT_POLYGON_CORNERS

! ! ---------------------------- TRIANGLE_POLYGON_POINTS ----------------------------------------
!
! SUBROUTINE TRIANGLE_POLYGON_POINTS(IERR,NXP,XPC,V1,V2,V3,NP,PC,BB)
! IMPLICIT NONE
! ! Calculate the intersection points of a triangle and a polygon, if intersected.
! ! http://softsurfer.com/Archive/algorithm_0106/algorithm_0106.htm
!
! INTEGER, INTENT(IN) :: NP
! INTEGER, INTENT(OUT) :: NXP,IERR
! REAL(EB), INTENT(OUT) :: XPC(60)
! REAL(EB), INTENT(IN) :: V1(3),V2(3),V3(3),PC(18),BB(6)
! INTEGER :: I,J,K
! REAL(EB) :: U(3),V(3),W(3),S1P0(3),XC(3)
! REAL(EB) :: A,B,C,D,E,DD,SC,TC
! REAL(EB), PARAMETER :: EPS=1.E-20_EB,TOL=1.E-12_EB
! !LOGICAL :: POINT_IN_BB, POINT_IN_TRIANGLE
!
! IERR = 0
! SC = 0._EB
! TC = 0._EB
! NXP = 0
! TRIANGLE_LOOP: DO I=1,3
!    SELECT CASE(I)
!       CASE(1)
!          U = V2-V1
!          S1P0 = V1
!       CASE(2)
!          U = V3-V2
!          S1P0 = V2
!       CASE(3)
!          U = V1-V3
!          S1P0 = V3
!    END SELECT
!
!    POLYGON_LOOP: DO J=1,NP
!       IF (J < NP) THEN
!          DO K=1,3
!             V(K) = PC(J*3+K)-PC((J-1)*3+K)
!          ENDDO
!       ELSE
!          DO K=1,3
!             V(K) = PC(K)-PC((J-1)*3+K)
!          ENDDO
!       ENDIF
!
!       DO K=1,3
!          W(K) = S1P0(K)-PC((J-1)*3+K)
!       ENDDO
!
!       A = DOT_PRODUCT(U,U)
!       B = DOT_PRODUCT(U,V)
!       C = DOT_PRODUCT(V,V)
!       D = DOT_PRODUCT(U,W)
!       E = DOT_PRODUCT(V,W)
!       DD = A*C-B*B
!
!       IF (DD < EPS) THEN ! almost parallel
!          IERR = 0
!          CYCLE
!       ELSE
!          SC = (B*E-C*D)/DD
!          TC = (A*E-B*D)/DD
!          IF (SC>-TOL .AND. SC<1._EB+TOL .AND. TC>-TOL .AND. TC<1._EB+TOL ) THEN
!             NXP = NXP+1
!             XC = S1P0+SC*U
!             DO K=1,3
!                XPC((NXP-1)*3+K) = XC(K)
!             ENDDO
!          ENDIF
!       ENDIF
!
!    ENDDO POLYGON_LOOP
! ENDDO TRIANGLE_LOOP
!
! !WRITE(LU_ERR,*) 'A', NXP
! ! add triangle vertices in polygon
! DO I=1,3
!    SELECT CASE(I)
!       CASE(1)
!          V = V1
!       CASE(2)
!          V = V2
!       CASE(3)
!          V = V3
!    END SELECT
!
!    IF (POINT_IN_BB(V,BB)) THEN
!       NXP = NXP+1
!       DO K=1,3
!          XPC((NXP-1)*3+K) = V(K)
!       ENDDO
!    ENDIF
! ENDDO
!
! !WRITE(LU_ERR,*) 'B', NXP
! ! add polygon vertices in triangle
! DO I=1,NP
!    DO J=1,3
!       V(J) = PC((I-1)*3+J)
!    ENDDO
!    IF (POINT_IN_TRIANGLE(V,V1,V2,V3)) THEN
!       NXP = NXP+1
!       DO J=1,3
!          XPC((NXP-1)*3+J) = V(J)
!       ENDDO
!    ENDIF
! ENDDO
!
! !WRITE(LU_ERR,*) 'C', NXP
!
! CALL ELIMATE_REPEATED_POINTS(NXP,XPC)
!
! !WRITE(LU_ERR,*) 'D', NXP
!
! IF (NXP > 3) THEN
!    CALL SORT_POLYGON_CORNERS(NXP,V1,V2,V3,XPC)
! ENDIF
!
! !WRITE(LU_ERR,*) 'E', NXP
!
! IF (NXP >= 1) THEN
!    IERR = 1 ! index for intersecting
! ELSE
!    IERR = 0
! ENDIF
!
! RETURN
! END SUBROUTINE TRIANGLE_POLYGON_POINTS

! ! ---------------------------- ELIMATE_REPEATED_POINTS ----------------------------------------
!
! SUBROUTINE ELIMATE_REPEATED_POINTS(NP,PC)
! IMPLICIT NONE
!
! INTEGER, INTENT(INOUT):: NP
! REAL(EB), INTENT(INOUT) :: PC(60)
! INTEGER :: NP2,I,J,K
! REAL(EB) :: U(3),V(3),W(3)
! REAL(EB), PARAMETER :: EPS_DIFF=1.0E-8_EB
!
! I = 1
! DO WHILE (I <= NP-1)
!    DO K=1,3
!       U(K) = PC(3*(I-1)+K)
!    ENDDO
!
!    J = I+1
!    NP2 = NP
!    DO WHILE (J <= NP2)
!       DO K=1,3
!          V(K) = PC(3*(J-1)+K)
!       ENDDO
!       W = U-V
!       ! use hybrid comparison test
!       !    absolute for small values
!       !    relative for large values
!       IF (NORM2(W) <= MAX(1.0_EB,NORM2(U),NORM2(V))*EPS_DIFF) THEN
!          DO K=3*J+1,3*NP
!             PC(K-3) = PC(K)
!          ENDDO
!          NP = NP-1
!          J = J-1
!       ENDIF
!       J = J+1
!       IF (J > NP) EXIT
!    ENDDO
!    I = I+1
! ENDDO
!
! RETURN
! END SUBROUTINE ELIMATE_REPEATED_POINTS

! ---------------------------- POINT_IN_BB ----------------------------------------

LOGICAL FUNCTION POINT_IN_BB(V1,BB)
IMPLICIT NONE

REAL(EB), INTENT(IN) :: V1(3),BB(6)

POINT_IN_BB=.FALSE.
IF ( V1(1)>=BB(1) .AND. V1(1)<=BB(2) .AND. &
     V1(2)>=BB(3) .AND. V1(2)<=BB(4) .AND. &
     V1(3)>=BB(5) .AND. V1(3)<=BB(6) ) THEN
   POINT_IN_BB=.TRUE.
   RETURN
ENDIF

RETURN
END FUNCTION POINT_IN_BB

! ! ---------------------------- LINE_SEG_TRI_PLANE_INTERSECT ----------------------------------------
!
! SUBROUTINE LINE_SEG_TRI_PLANE_INTERSECT(IERR,IERR2,Q,V1,V2,V3,P0,P1)
! USE MATH_FUNCTIONS, ONLY:CROSS_PRODUCT
! IMPLICIT NONE
!
! INTEGER, INTENT(OUT) :: IERR
! REAL(EB), INTENT(OUT) :: Q(3)
! REAL(EB), INTENT(IN) :: V1(3),V2(3),V3(3),P0(3),P1(3)
! REAL(EB) :: E1(3),E2(3),S(3),U,V,TMP,T,D(3),P(3)
! REAL(EB), PARAMETER :: EPS=1.E-10_EB,TOL=1.E-15
! INTEGER :: IERR2
!
! IERR  = 0
! IERR2 = 1
! ! IERR=1:  line segment intersect with the plane
! ! IERR2=1: the intersection point is in the triangle
!
! ! Schneider and Eberly, Section 11.1
!
! D = P1-P0
! E1 = V2-V1
! E2 = V3-V1
!
! CALL CROSS_PRODUCT(P,D,E2)
!
! TMP = DOT_PRODUCT(P,E1)
!
! IF ( ABS(TMP)<EPS ) RETURN
!
! TMP = 1._EB/TMP
! S = P0-V1
!
! U = TMP*DOT_PRODUCT(S,P)
! IF (U<0._EB .OR. U>1._EB) IERR2=0
!
! CALL CROSS_PRODUCT(Q,S,E1)
! V = TMP*DOT_PRODUCT(D,Q)
! IF (V<0._EB .OR. (U+V)>1._EB) IERR2=0
!
! T = TMP*DOT_PRODUCT(E2,Q)
! Q = P0 + T*D ! the intersection point
!
! IF (T>=0._EB-TOL .AND. T<=1._EB+TOL) IERR=1
!
! RETURN
! END SUBROUTINE LINE_SEG_TRI_PLANE_INTERSECT

! ---------------------------- POLYGON_AREA ----------------------------------------

REAL(EB) FUNCTION POLYGON_AREA(NP,PC)
IMPLICIT NONE
! Calculate the area of a polygon

INTEGER, INTENT(IN) :: NP
REAL(EB), INTENT(IN) :: PC(60)
INTEGER :: I,K
REAL(EB) :: V1(3),V2(3),V3(3)

POLYGON_AREA = 0._EB
V3 = POLYGON_CENTROID(NP,PC)

DO I=1,NP
   IF (I < NP) THEN
      DO K=1,3
         V1(K) = PC((I-1)*3+K)
         V2(K) = PC(I*3+K)
      ENDDO
   ELSE
      DO K=1,3
         V1(K) = PC((I-1)*3+K)
         V2(K) = PC(K)
      ENDDO
   ENDIF
   POLYGON_AREA = POLYGON_AREA+TRIANGLE_AREA(V1,V2,V3)
ENDDO

RETURN
END FUNCTION POLYGON_AREA

! ---------------------------- POLYGON_CENTROID ----------------------------------------

REAL(EB) FUNCTION POLYGON_CENTROID(NP,PC)
IMPLICIT NONE
! Calculate the centroid of polygon vertices

DIMENSION :: POLYGON_CENTROID(3)
INTEGER, INTENT(IN) :: NP
REAL(EB), INTENT(IN) :: PC(60)
INTEGER :: I,K

POLYGON_CENTROID = 0._EB
DO I=1,NP
   DO K=1,3
      POLYGON_CENTROID(K) = POLYGON_CENTROID(K)+PC((I-1)*3+K)/NP
   ENDDO
ENDDO

RETURN
END FUNCTION POLYGON_CENTROID

! ---------------------------- INTERSECT_SPHERE_AABB ----------------------------------------

! Algorithm from Schneider and Eberly, p. 644
! Intersection of Sphere and Axis-Aligned Bounding Box

LOGICAL FUNCTION INTERSECT_SPHERE_AABB(X0,RADIUS,XB)
IMPLICIT NONE

REAL(EB), INTENT(IN) :: X0(3),RADIUS,XB(6)
REAL(EB) :: DIST_SQUARED

INTERSECT_SPHERE_AABB=.TRUE.

! Compute distance in each direction, summing as we go
DIST_SQUARED = 0._EB
IF (X0(1)<XB(1)) THEN
   DIST_SQUARED = DIST_SQUARED + (X0(1)-XB(1))**2
ELSEIF (X0(1)>XB(2)) THEN
   DIST_SQUARED = DIST_SQUARED + (X0(1)-XB(2))**2
ENDIF
IF (X0(2)<XB(3)) THEN
   DIST_SQUARED = DIST_SQUARED + (X0(2)-XB(3))**2
ELSEIF (X0(2)>XB(4)) THEN
   DIST_SQUARED = DIST_SQUARED + (X0(2)-XB(4))**2
ENDIF
IF (X0(3)<XB(5)) THEN
   DIST_SQUARED = DIST_SQUARED + (X0(3)-XB(5))**2
ELSEIF (X0(3)>XB(6)) THEN
   DIST_SQUARED = DIST_SQUARED + (X0(3)-XB(6))**2
ENDIF

! Compare squared distance to radius squared
IF (DIST_SQUARED > (RADIUS*RADIUS-TWO_EPSILON_EB)) INTERSECT_SPHERE_AABB=.FALSE.

RETURN
END FUNCTION INTERSECT_SPHERE_AABB

! ---------------------------- INTERSECT_CYLINDER_AABB ----------------------------------------

! Intersection of Cylinder and Axis-Aligned Bounding Box
!
! Cylinder is represented by:
!   X_IN   = bottom-center of cylinder (X,Y,Z) in grid reference frame
!   H      = length of cylinder
!   RADIUS = radius of cylinder
!   AX_VEC = unit vector pointing along cylinder axis (which leads to ROT_MAT using ROTATION_MATRIX)
!
! The basic algorithm is:
!   1. rotate the cylinder into a frame where the axis points in the vertical direction (+zbar in new frame)
!   2. find the vertex point locations of AABB in this new frame
!   3. test each vertex location against the end caps of cylinder
!   4. test each vertex against radius of cylinder

LOGICAL FUNCTION INTERSECT_CYLINDER_AABB(X_IN,H,RADIUS,ROTMAT,XB)
IMPLICIT NONE

REAL(EB), INTENT(IN) :: X_IN(3),H,RADIUS,ROTMAT(3,3),XB(6)
REAL(EB) :: X(3),U(3),V(3),DUX(2),Z0,ZH,R2,DIST_SQUARED
INTEGER :: II,JJ,KK

INTERSECT_CYLINDER_AABB=.FALSE.

X  = MATMUL(ROTMAT,X_IN) ! transform center
Z0 = X(3)                ! lower cap in new reference frame
ZH = X(3) + H            ! upper cap in new reference frame

! transform vertices and test against end caps, then radius
R2 = RADIUS*RADIUS
DO KK=5,6
   DO JJ=3,4
      DO II=1,2
         V = (/XB(II),XB(JJ),XB(KK)/)
         U = MATMUL(ROTMAT,V)
         IF (U(3)>=Z0 .AND. U(3)<=ZH) THEN
            ! vertex is within end-cap range, now test against radius
            ! in new frame the distance from vertex to cylinder axis only requires the 1st and 2nd vector components
            DUX = U(1:2) - X(1:2)
            DIST_SQUARED = DOT_PRODUCT(DUX,DUX)
            IF (DIST_SQUARED < R2+TWO_EPSILON_EB) THEN
               INTERSECT_CYLINDER_AABB = .TRUE.
               RETURN
            ENDIF
         ENDIF
      ENDDO
   ENDDO
ENDDO

RETURN
END FUNCTION INTERSECT_CYLINDER_AABB

! ---------------------------- ROTATION_MATRIX ----------------------------------------

SUBROUTINE ROTATION_MATRIX(R_OUT,A_IN,THETA)
USE MATH_FUNCTIONS, ONLY: CROSS_PRODUCT
IMPLICIT NONE

REAL(EB), INTENT(OUT) :: R_OUT(3,3)
REAL(EB), INTENT(IN) :: A_IN(3),THETA
REAL(EB) :: A(3),C,DENOM,V(3),A1(3),A2(3),A3(3),B1(3),B2(3),B3(3),R_THETA(3,3)

! initialize 2D rotation matrix
! this is a counterclockwise rotation
R_THETA = 0._EB
R_THETA(1,1) = COS(THETA*PI/180._EB);  R_THETA(1,2) = SIN(THETA*PI/180._EB)
R_THETA(2,1) = -SIN(THETA*PI/180._EB); R_THETA(2,2) = COS(THETA*PI/180._EB)
R_THETA(3,3) = 1._EB

! initialize R_OUT as 2D rotation matrix
R_OUT = R_THETA

! normalize input vector
DENOM = SQRT(DOT_PRODUCT(A_IN,A_IN))
IF (DENOM<TWO_EPSILON_EB) RETURN
A = A_IN/DENOM

! orthonormal basis in new system
B1 = (/1._EB,0._EB,0._EB/)
B2 = (/0._EB,1._EB,0._EB/)
B3 = (/0._EB,0._EB,1._EB/)

CALL CROSS_PRODUCT(V,A,B3)
C = DOT_PRODUCT(A,B3)

IF (DOT_PRODUCT(V,V)<TWO_EPSILON_EB) THEN
   ! if cross product has zero length, there are two possibilities:
   !   1. vectors are aligned in same direction, no rotation required
   !   2. vectors are aligned in opposite direction, 180 degree rotation
   IF (C>0._EB) THEN
      RETURN
   ELSE
      R_OUT = -R_OUT
      RETURN
   ENDIF
ENDIF

! find orthnormal basis for A=A3 in old system

A3 = A
CALL CROSS_PRODUCT(A2,B3,A3)
CALL CROSS_PRODUCT(A1,A2,A3)

! rotation matrix (direction cosines), Pope (2000), Eq. (A.11)

R_OUT(1,1) = DOT_PRODUCT(A1,B1); R_OUT(1,2) = DOT_PRODUCT(A1,B2); R_OUT(1,3) = DOT_PRODUCT(A1,B3)
R_OUT(2,1) = DOT_PRODUCT(A2,B1); R_OUT(2,2) = DOT_PRODUCT(A2,B2); R_OUT(2,3) = DOT_PRODUCT(A2,B3)
R_OUT(3,1) = DOT_PRODUCT(A3,B1); R_OUT(3,2) = DOT_PRODUCT(A3,B2); R_OUT(3,3) = DOT_PRODUCT(A3,B3)

R_OUT = MATMUL(R_OUT,R_THETA)

! ! test
! print *,R_OUT(1,:)
! print *,R_OUT(2,:)
! print *,R_OUT(3,:)
! print *,MATMUL(R_OUT,A) ! result should be B3
! stop

END SUBROUTINE ROTATION_MATRIX

! ---------------------------- INTERSECT_CONE_AABB ----------------------------------------

! This routine basically follows the INTERSECT_CYLINDER_AABB algorithm, with radius = R(Z)

LOGICAL FUNCTION INTERSECT_CONE_AABB(X_IN,H,RADIUS,ROTMAT,XB)
IMPLICIT NONE

REAL(EB), INTENT(IN) :: X_IN(3),H,RADIUS,ROTMAT(3,3),XB(6)
REAL(EB) :: X(3),U(3),V(3),DUX(2),Z0,ZH,DIST_SQUARED,R_Z
INTEGER :: II,JJ,KK

INTERSECT_CONE_AABB=.FALSE.

X  = MATMUL(ROTMAT,X_IN) ! transform center
Z0 = X(3)                ! lower cap in new reference frame
ZH = X(3) + H            ! upper cap in new reference frame

! transform vertices and test against end caps, then radius
DO KK=5,6
   DO JJ=3,4
      DO II=1,2
         V = (/XB(II),XB(JJ),XB(KK)/)
         U = MATMUL(ROTMAT,V)
         IF (U(3)>=Z0 .AND. U(3)<=ZH) THEN
            ! vertex is within end-cap range, now test against radius
            ! in new frame the distance from vertex to CONE axis only requires the 1st and 2nd vector components
            DUX = U(1:2) - X(1:2)
            DIST_SQUARED = DOT_PRODUCT(DUX,DUX)
            R_Z = RADIUS*(1._EB-(U(3)-Z0)/H)
            IF (DIST_SQUARED < R_Z*R_Z+TWO_EPSILON_EB) THEN
               INTERSECT_CONE_AABB = .TRUE.
               RETURN
            ENDIF
         ENDIF
      ENDDO
   ENDDO
ENDDO

RETURN
END FUNCTION INTERSECT_CONE_AABB

! ---------------------------- INTERSECT_OBB_AABB ----------------------------------------

! Intersect an Oriented Bounding Box (OBB) with an Axis-Aligned Bounding Box (AABB)
! First, rotate AABB into OBB frame.
! Then test each vertex.

LOGICAL FUNCTION INTERSECT_OBB_AABB(X_IN,L,W,H,ROTMAT,XB)
IMPLICIT NONE

REAL(EB), INTENT(IN) :: X_IN(3),L,W,H,ROTMAT(3,3),XB(6)
REAL(EB) :: X(3),U(3),V(3),X0,XL,Y0,YW,Z0,ZH
INTEGER :: II,JJ,KK

INTERSECT_OBB_AABB=.FALSE.

X  = MATMUL(ROTMAT,X_IN) ! transform center
X0 = X(1) - 0.5_EB*L - TWO_EPSILON_EB
XL = X(1) + 0.5_EB*L + TWO_EPSILON_EB
Y0 = X(2) - 0.5_EB*W - TWO_EPSILON_EB
YW = X(2) + 0.5_EB*W + TWO_EPSILON_EB
Z0 = X(3) - 0.5_EB*H - TWO_EPSILON_EB
ZH = X(3) + 0.5_EB*H + TWO_EPSILON_EB

! transform and test vertices (probably a more efficient way, but just to get going...)
DO KK=5,6
   DO JJ=3,4
      DO II=1,2
         V = (/XB(II),XB(JJ),XB(KK)/)
         U = MATMUL(ROTMAT,V)
         IF (U(1)>X0 .AND. U(1)<XL .AND. U(2)>Y0 .AND. U(2)<YW .AND. U(3)>Z0 .AND. U(3)<ZH) THEN
            INTERSECT_OBB_AABB=.TRUE.
            RETURN
         ENDIF
      ENDDO
   ENDDO
ENDDO

RETURN
END FUNCTION INTERSECT_OBB_AABB

! ! ---------------------------- TRIANGLE_ON_CELL_SURF ----------------------------------------
!
! SUBROUTINE TRIANGLE_ON_CELL_SURF(IERR1,N_VEC,V,XC,YC,ZC,DX,DY,DZ)
! IMPLICIT NONE
!
! INTEGER, INTENT(OUT) :: IERR1
! REAL(EB), INTENT(IN) :: N_VEC(3),V(3),XC,YC,ZC,DX,DY,DZ
! REAL(EB) :: DIST(3),TOL=1.E-15_EB
!
! IERR1 = 1
! DIST = 0._EB
! !IF (NORM2(N_VEC)>1._EB) N_VEC = N_VEC/NORM2(N_VEC)
!
! IF (N_VEC(1)==1._EB .OR. N_VEC(1)==-1._EB) THEN
!    DIST(1) = XC-V(1)
!    IF ( ABS(ABS(DIST(1))-DX*0.5_EB)<TOL .AND. DOT_PRODUCT(DIST,N_VEC)<0._EB) THEN
!       IERR1 = -1
!    ENDIF
!    RETURN
! ENDIF
!
! IF (N_VEC(2)==1._EB .OR. N_VEC(2)==-1._EB) THEN
!    DIST(2) = YC-V(2)
!    IF ( ABS(ABS(DIST(2))-DY*0.5_EB)<TOL .AND. DOT_PRODUCT(DIST,N_VEC)<0._EB) THEN
!       IERR1 = -1
!    ENDIF
!    RETURN
! ENDIF
!
! IF (N_VEC(3)==1._EB .OR. N_VEC(3)==-1._EB) THEN
!    DIST(3) = ZC-V(3)
!    IF ( ABS(ABS(DIST(3))-DZ*0.5_EB)<TOL .AND. DOT_PRODUCT(DIST,N_VEC)<0._EB) THEN
!       IERR1 = -1
!    ENDIF
!    RETURN
! ENDIF
!
! RETURN
! END SUBROUTINE TRIANGLE_ON_CELL_SURF

! ! ---------------------------- POLYGON_CLOSE_TO_EDGE ----------------------------------------
!
! SUBROUTINE POLYGON_CLOSE_TO_EDGE(IOR,N_VEC,V,XC,YC,ZC,DX,DY,DZ)
! IMPLICIT NONE
! INTEGER, INTENT(OUT) :: IOR
! REAL(EB), INTENT(IN) :: N_VEC(3),V(3),XC,YC,ZC,DX,DY,DZ
! REAL(EB) :: DIST(3),DMAX
! REAL(EB), PARAMETER :: TOLERANCE=0.01_EB
!
! IOR = 0
! DIST(1) = XC-V(1)
! DIST(2) = YC-V(2)
! DIST(3) = ZC-V(3)
!
! IF (ABS(DIST(1)/DX) >= ABS(DIST(2)/DY) .AND. ABS(DIST(1)/DX) >= ABS(DIST(3)/DZ)) THEN
!    DMAX = ABS(DIST(1)/DX*2._EB)
!    IF (DMAX < (1._EB-TOLERANCE) .OR. DOT_PRODUCT(DIST,N_VEC) > 0._EB) RETURN
!    IF (DIST(1) < 0._EB) THEN
!       IOR = 1
!    ELSE
!       IOR = -1
!    ENDIF
! ELSEIF (ABS(DIST(2)/DY) >= ABS(DIST(3)/DZ)) THEN
!    DMAX = ABS(DIST(2)/DY*2._EB)
!    IF (DMAX < (1._EB-TOLERANCE) .OR. DOT_PRODUCT(DIST,N_VEC) > 0._EB) RETURN
!    IF (DIST(2) < 0._EB) THEN
!       IOR = 2
!    ELSE
!       IOR = -2
!    ENDIF
! ELSE
!    DMAX = ABS(DIST(3)/DZ*2._EB)
!    IF (DMAX < (1._EB-TOLERANCE) .OR. DOT_PRODUCT(DIST,N_VEC) > 0._EB) RETURN
!    IF (DIST(3) < 0._EB) THEN
!       IOR = 3
!    ELSE
!       IOR = -3
!    ENDIF
! ENDIF
!
! END SUBROUTINE POLYGON_CLOSE_TO_EDGE

END MODULE COMPLEX_GEOMETRY
