MODULE WALL_ROUTINES
 
! Compute the wall boundary conditions
 
USE PRECISION_PARAMETERS
USE GLOBAL_CONSTANTS
USE MESH_POINTERS
 
IMPLICIT NONE
PRIVATE
CHARACTER(255), PARAMETER :: wallid='$Id$'
CHARACTER(255), PARAMETER :: wallrev='$Revision$'
CHARACTER(255), PARAMETER :: walldate='$Date$'

PUBLIC WALL_BC,GET_REV_wall
 

CONTAINS


SUBROUTINE WALL_BC(T,NM)

! This is the main control routine for this module

USE COMP_FUNCTIONS, ONLY: SECOND
REAL(EB) :: TNOW
REAL(EB), INTENT(IN) :: T
INTEGER, INTENT(IN) :: NM

IF (EVACUATION_ONLY(NM)) RETURN

TNOW=SECOND()

CALL POINT_TO_MESH(NM)

CALL DIFFUSIVITY_BC
CALL THERMAL_BC(T)
IF (ANY(SPECIES_MIXTURE%DEPOSITING)) CALL CALC_DEPOSITION(NM)
CALL SPECIES_BC(T,NM)
CALL DENSITY_BC
IF (HVAC_SOLVE) CALL HVAC_BC
IF (N_FACE>0)   CALL GEOM_BC(NM)

TUSED(6,NM)=TUSED(6,NM)+SECOND()-TNOW
END SUBROUTINE WALL_BC


SUBROUTINE DIFFUSIVITY_BC

! Calculate the term RHODW=RHO*D at the wall

INTEGER :: IW,N,ITMP,IIG,JJG,KKG
REAL(EB), POINTER, DIMENSION(:,:,:) :: RHOP
TYPE(WALL_TYPE), POINTER :: WC=>NULL()

IF (N_TRACKED_SPECIES==0) RETURN

IF (PREDICTOR) RHOP => RHOS
IF (CORRECTOR) RHOP => RHO

WALL_LOOP: DO IW=1,N_EXTERNAL_WALL_CELLS+N_INTERNAL_WALL_CELLS
   WC=>WALL(IW)
   IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY .OR. &
       WC%BOUNDARY_TYPE==OPEN_BOUNDARY .OR. WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) CYCLE WALL_LOOP
   DO N=1,N_TRACKED_SPECIES
      IF (LES) THEN
         IIG = WC%ONE_D%IIG
         JJG = WC%ONE_D%JJG
         KKG = WC%ONE_D%KKG
         WC%RHODW(N) = MU(IIG,JJG,KKG)*RSC*WC%RHO_F/RHOP(IIG,JJG,KKG)
      ELSE
         ITMP = MIN(4999,NINT(WC%ONE_D%TMP_F))
         WC%RHODW(N) = WC%RHO_F*D_Z(ITMP,N)
      ENDIF
   ENDDO
ENDDO WALL_LOOP

END SUBROUTINE DIFFUSIVITY_BC


SUBROUTINE THERMAL_BC(T)

! Thermal boundary conditions for adiabatic, fixed temperature, fixed flux and interpolated boundaries.
! One dimensional heat transfer and pyrolysis is done in PYROLYSIS, which is called at the end of this routine.

USE MATH_FUNCTIONS, ONLY: EVALUATE_RAMP 
USE PHYSICAL_FUNCTIONS, ONLY : GET_SPECIFIC_GAS_CONSTANT,GET_SPECIFIC_HEAT
USE OUTPUT_DATA, ONLY: Q_DOT
REAL(EB) :: DT_BC,T,DTMP
INTEGER  :: SURF_INDEX,IW,II
REAL(EB), POINTER, DIMENSION(:,:) :: PBAR_P
REAL(EB), POINTER, DIMENSION(:,:,:) :: UU=>NULL(),VV=>NULL(),WW=>NULL(),RHOP=>NULL(),OM_RHOP=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: ZZP=>NULL()
TYPE(WALL_TYPE), POINTER :: WC=>NULL()
TYPE(LAGRANGIAN_PARTICLE_TYPE), POINTER :: LP=>NULL()

IF (VEG_LEVEL_SET) RETURN

IF (PREDICTOR) THEN
   UU => US
   VV => VS
   WW => WS
   RHOP => RHOS
   ZZP  => ZZS
   PBAR_P => PBAR_S
ELSE
   UU => U
   VV => V
   WW => W
   RHOP => RHO
   ZZP  => ZZ   
   PBAR_P => PBAR
ENDIF
 
! For thermally-thick boundary conditions, set the flag to call the routine PYROLYSIS

CALL_PYROLYSIS = .FALSE. 
IF (CORRECTOR) THEN
   WALL_COUNTER = WALL_COUNTER + 1
   IF (WALL_COUNTER==WALL_INCREMENT) THEN
      DT_BC    = T - BC_CLOCK
      BC_CLOCK = T
      CALL_PYROLYSIS = .TRUE.
      WALL_COUNTER = 0
   ENDIF
ENDIF
 
! Loop through all boundary cells and apply heat transfer method, except for thermally-thick cells
 
WALL_CELL_LOOP: DO IW=1,N_EXTERNAL_WALL_CELLS+N_INTERNAL_WALL_CELLS

   WC=>WALL(IW)
   IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY) CYCLE WALL_CELL_LOOP

   SURF_INDEX = WC%SURF_INDEX

   ! Consider special boundary conditions

   IF (WC%BOUNDARY_TYPE/=SOLID_BOUNDARY) THEN
      IF (WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) SURF_INDEX = INTERPOLATED_SURF_INDEX
      IF (WC%BOUNDARY_TYPE==OPEN_BOUNDARY)         SURF_INDEX = OPEN_SURF_INDEX
      IF (WC%BOUNDARY_TYPE==MIRROR_BOUNDARY)       SURF_INDEX = MIRROR_SURF_INDEX
   ENDIF

   CALL HEAT_TRANSFER_BC(WC%ONE_D%TMP_F,WALL_INDEX=IW) 

   WC=>WALL(IW)
   IF (SURFACE(SURF_INDEX)%THERMALLY_THICK) THEN
      IF (WC%ONE_D%BURNAWAY) THEN
         WC%ONE_D%MASSFLUX(0:N_TRACKED_SPECIES)=0
      ELSE
         IF (CALL_PYROLYSIS) CALL PYROLYSIS(T,DT_BC,WALL_INDEX=IW)         
      ENDIF
   ENDIF     
   
END DO WALL_CELL_LOOP

IF (VIRTUAL_PARTICLES) THEN      
   DO II = 1, NLP         
      LP => LAGRANGIAN_PARTICLE(II)
      SURF_INDEX = LAGRANGIAN_PARTICLE_CLASS(LP%CLASS_INDEX)%SURF_INDEX 
      IF (SURF_INDEX/=DROPLET_SURF_INDEX .AND. SURF_INDEX/=MASSLESS_PARTICLE_SURF_INDEX) THEN
         CALL HEAT_TRANSFER_BC(LP%ONE_D%TMP_F,PARTICLE_INDEX=II)
         IF (SURFACE(SURF_INDEX)%THERMALLY_THICK .AND. CALL_PYROLYSIS) CALL PYROLYSIS(T,DT_BC,PARTICLE_INDEX=II)         
      ENDIF
   ENDDO
ENDIF

CONTAINS

SUBROUTINE HEAT_TRANSFER_BC(TMP_F,WALL_INDEX,PARTICLE_INDEX)

USE MASS, ONLY: SCALAR_FACE_VALUE

INTEGER, INTENT(IN), OPTIONAL :: WALL_INDEX,PARTICLE_INDEX
REAL(EB), INTENT(INOUT) :: TMP_F
REAL(EB) :: AREA_ADJUST,ARO,FDERIV,QEXTRA,QNET,RAMP_FACTOR,RHO_G,RHO_G_2,RSUM_W,TMP_G,TMP_OTHER,TSI,UN, &
            ZZ_G_ALL(MAX_SPECIES),RHO_ZZ_F(MAX_SPECIES),ZZ_GET(0:N_TRACKED_SPECIES),TW,DUMMY, &
            ZZZ(1:4),RHO_OTHER,RHO_OTHER_2,RHO_ZZ_OTHER(1:N_TRACKED_SPECIES),RHO_ZZ_OTHER_2,RHO_ZZ_G,RHO_ZZ_G_2
            
LOGICAL :: INFLOW
INTEGER II,JJ,KK,IIG,JJG,KKG,IOR,IIO,JJO,KKO,N
TYPE(WALL_TYPE), POINTER :: WC=>NULL()
TYPE(LAGRANGIAN_PARTICLE_TYPE), POINTER :: LP=>NULL()
TYPE(ONE_D_M_AND_E_XFER_TYPE), POINTER :: ONE_D=>NULL()
TYPE (SURFACE_TYPE), POINTER :: SF=>NULL()
TYPE (VENTS_TYPE), POINTER :: VT=>NULL()
TYPE (OMESH_TYPE), POINTER :: OM=>NULL()
TYPE (MESH_TYPE), POINTER :: MM=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: OM_ZZP=>NULL()

SF  => SURFACE(SURF_INDEX)

IF (PRESENT(WALL_INDEX)) THEN
   WC=>WALL(WALL_INDEX)
   ONE_D => WC%ONE_D
   AREA_ADJUST = ONE_D%AREA_ADJUST
   II  = ONE_D%II
   JJ  = ONE_D%JJ
   KK  = ONE_D%KK
   IIG = ONE_D%IIG
   JJG = ONE_D%JJG
   KKG = ONE_D%KKG
   IOR = ONE_D%IOR   
   TW  = ONE_D%T
ELSEIF (PRESENT(PARTICLE_INDEX)) THEN
   LP=>LAGRANGIAN_PARTICLE(PARTICLE_INDEX)
   ONE_D => LP%ONE_D
   AREA_ADJUST = 1._EB
   II  = ONE_D%IIG
   JJ  = ONE_D%JJG
   KK  = ONE_D%KKG
   IIG = ONE_D%IIG
   JJG = ONE_D%JJG
   KKG = ONE_D%KKG
   IOR = ONE_D%IOR  
   TW  = ONE_D%T
ELSE
   RETURN
ENDIF

! Compute surface temperature, TMP_F, and convective heat flux, QCONF, for various boundary conditions

METHOD_OF_HEAT_TRANSFER: SELECT CASE(SF%THERMAL_BC_INDEX)

   CASE (NO_CONVECTION) METHOD_OF_HEAT_TRANSFER

      TMP_F  = TMP(IIG,JJG,KKG)

   CASE (INFLOW_OUTFLOW) METHOD_OF_HEAT_TRANSFER ! Only for wall cells

      ! Base inflow/outflow decision on velocity component with same predictor/corrector attribute
    
      INFLOW = .FALSE.
      SELECT CASE(IOR)
         CASE( 1) 
            UN = UU(II,JJ,KK) 
         CASE(-1)
            UN = -UU(II-1,JJ,KK) 
         CASE( 2) 
            UN = VV(II,JJ,KK)
         CASE(-2) 
            UN = -VV(II,JJ-1,KK)
         CASE( 3) 
            UN = WW(II,JJ,KK)
         CASE(-3) 
            UN = -WW(II,JJ,KK-1)
      END SELECT
      IF (UN>ZERO_P) INFLOW = .TRUE.

      IF (INFLOW) THEN
         TMP_F = TMP_0(KK)
         IF (WC%VENT_INDEX>0) THEN
            VT => VENTS(WC%VENT_INDEX)
            IF (VT%TMP_EXTERIOR>0._EB) &
               TMP_F = TMP_0(KK) + EVALUATE_RAMP(TSI,DUMMY,VT%TMP_EXTERIOR_RAMP_INDEX)*(VT%TMP_EXTERIOR-TMP_0(KK))
         ENDIF
         IF (N_TRACKED_SPECIES>0) WC%ZZ_F(1:N_TRACKED_SPECIES)=SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
      ELSE
         TMP_F = TMP(IIG,JJG,KKG)
         IF (N_TRACKED_SPECIES>0) WC%ZZ_F(1:N_TRACKED_SPECIES)=ZZP(IIG,JJG,KKG,1:N_TRACKED_SPECIES)
      ENDIF

      TMP(II,JJ,KK) = TMP_F
      IF (N_TRACKED_SPECIES>0) ZZP(II,JJ,KK,1:N_TRACKED_SPECIES) = WC%ZZ_F(1:N_TRACKED_SPECIES)

      ONE_D%QCONF = 2._EB*WC%KW*(TMP(IIG,JJG,KKG)-TMP_F)*WC%RDN
    
   CASE (SPECIFIED_TEMPERATURE) METHOD_OF_HEAT_TRANSFER

      TMP_G = TMP(IIG,JJG,KKG)

      IF (ABS(TW-T_BEGIN) <= SPACING(TW) .AND. SF%RAMP_INDEX(TIME_TEMP)>=1) THEN
         TSI = T
      ELSE
         TSI = T - TW
      ENDIF

      IF (ONE_D%UW<=0._EB) THEN
         IF (SF%TMP_FRONT>0._EB) THEN
            TMP_F = TMP_0(KK) + EVALUATE_RAMP(TSI,SF%TAU(TIME_TEMP),SF%RAMP_INDEX(TIME_TEMP))*(SF%TMP_FRONT-TMP_0(KK))
         ELSE
            TMP_F = TMP_0(KK) 
         ENDIF
      ELSE
         TMP_F = TMP_G ! If gas is being drawn from the domain, set the boundary temperature to the gas temperature
      ENDIF

      DTMP = TMP_G - TMP_F
      IF (PRESENT(WALL_INDEX)) THEN
         ONE_D%HEAT_TRANS_COEF = HEAT_TRANSFER_COEFFICIENT(DTMP,SF%H_FIXED,SF%GEOMETRY,SF%CONV_LENGTH,SF%HEAT_TRANSFER_MODEL,&
                                                           WALL_INDEX=WALL_INDEX)
      ELSE
         ONE_D%HEAT_TRANS_COEF = HEAT_TRANSFER_COEFFICIENT(DTMP,SF%H_FIXED,SF%GEOMETRY,SF%CONV_LENGTH,SF%HEAT_TRANSFER_MODEL,&
                                                           PARTICLE_INDEX=PARTICLE_INDEX)
      ENDIF
      ONE_D%QCONF = ONE_D%HEAT_TRANS_COEF*DTMP
            
   CASE (NET_FLUX_BC) METHOD_OF_HEAT_TRANSFER
            
      IF (ABS(TW-T_BEGIN)<= SPACING(TW ) .AND. SF%RAMP_INDEX(TIME_HEAT)>=1) THEN
         TSI = T
      ELSE
         TSI = T - TW
      ENDIF
      TMP_G = TMP(IIG,JJG,KKG)
      TMP_OTHER = TMP_F
      RAMP_FACTOR = EVALUATE_RAMP(TSI,SF%TAU(TIME_HEAT),SF%RAMP_INDEX(TIME_HEAT))
      QNET = -RAMP_FACTOR*SF%NET_HEAT_FLUX*AREA_ADJUST
      ADLOOP: DO
         DTMP = TMP_G - TMP_OTHER
         IF (ABS(QNET) > 0._EB .AND. ABS(DTMP) <ZERO_P) DTMP=1._EB        
         IF (PRESENT(WALL_INDEX)) THEN
            ONE_D%HEAT_TRANS_COEF = HEAT_TRANSFER_COEFFICIENT(DTMP,SF%H_FIXED,SF%GEOMETRY,SF%CONV_LENGTH,SF%HEAT_TRANSFER_MODEL,&
                                                              WALL_INDEX=WALL_INDEX)
         ELSE
            ONE_D%HEAT_TRANS_COEF = HEAT_TRANSFER_COEFFICIENT(DTMP,SF%H_FIXED,SF%GEOMETRY,SF%CONV_LENGTH,SF%HEAT_TRANSFER_MODEL,&
                                                              PARTICLE_INDEX=PARTICLE_INDEX)      
         ENDIF      
         IF (RADIATION) THEN
            QEXTRA = ONE_D%HEAT_TRANS_COEF*DTMP + ONE_D%QRADIN - ONE_D%EMISSIVITY * SIGMA * TMP_OTHER ** 4 - QNET
            FDERIV = -ONE_D%HEAT_TRANS_COEF -  4._EB * ONE_D%EMISSIVITY * SIGMA * TMP_OTHER ** 3
         ELSE
            QEXTRA = ONE_D%HEAT_TRANS_COEF*DTMP  - QNET
            FDERIV = -ONE_D%HEAT_TRANS_COEF
         ENDIF
         IF (ABS(FDERIV) > ZERO_P) TMP_OTHER = TMP_OTHER - QEXTRA / FDERIV
         IF (ABS(TMP_OTHER - TMP_F) / TMP_F < 0.0001) THEN
            TMP_F = TMP_OTHER
            EXIT ADLOOP
         ELSE
            TMP_F = TMP_OTHER 
            CYCLE ADLOOP
         ENDIF           
      ENDDO ADLOOP
      DTMP = TMP_G - WC%ONE_D%TMP_F
      IF (PRESENT(WALL_INDEX)) THEN
         ONE_D%HEAT_TRANS_COEF = HEAT_TRANSFER_COEFFICIENT(DTMP,SF%H_FIXED,SF%GEOMETRY,SF%CONV_LENGTH,SF%HEAT_TRANSFER_MODEL,&
                                                           WALL_INDEX=WALL_INDEX)
      ELSE
         ONE_D%HEAT_TRANS_COEF = HEAT_TRANSFER_COEFFICIENT(DTMP,SF%H_FIXED,SF%GEOMETRY,SF%CONV_LENGTH,SF%HEAT_TRANSFER_MODEL,&
                                                           PARTICLE_INDEX=PARTICLE_INDEX)      
      ENDIF      
      ONE_D%QCONF = ONE_D%HEAT_TRANS_COEF*DTMP

   CASE (CONVECTIVE_FLUX_BC) METHOD_OF_HEAT_TRANSFER
         
      IF (ABS(TW-T_BEGIN) <= SPACING(TW) .AND. SF%RAMP_INDEX(TIME_HEAT)>=1) THEN
         TSI = T
      ELSE
         TSI = T - TW
      ENDIF
      RAMP_FACTOR = EVALUATE_RAMP(TSI,SF%TAU(TIME_HEAT),SF%RAMP_INDEX(TIME_HEAT))
      IF (SF%TMP_FRONT>0._EB) THEN
         TMP_F =  TMPA + RAMP_FACTOR*(SF%TMP_FRONT-TMPA)
      ELSE
         TMP_F =  TMP_0(KK)
      ENDIF
      ONE_D%QCONF = -RAMP_FACTOR*SF%CONVECTIVE_HEAT_FLUX*AREA_ADJUST
    
   CASE (INTERPOLATED_BC) METHOD_OF_HEAT_TRANSFER
    
      OM   => OMESH(WC%NOM)
      IF (PREDICTOR) THEN
         OM_RHOP => OM%RHOS
         IF (N_TRACKED_SPECIES>0) OM_ZZP => OM%ZZS
      ELSE
         OM_RHOP => OM%RHO
         IF (N_TRACKED_SPECIES>0) OM_ZZP => OM%ZZ
      ENDIF
      MM    => MESHES(WC%NOM)

      ! Gather data from other mesh

      RHO_OTHER=0._EB
      RHO_ZZ_OTHER=0._EB

      DO KKO=WC%NOM_IB(3),WC%NOM_IB(6)
         DO JJO=WC%NOM_IB(2),WC%NOM_IB(5)
            DO IIO=WC%NOM_IB(1),WC%NOM_IB(4)
               SELECT CASE(IOR)
                  CASE( 1)
                     ARO = MIN(1._EB , (MM%DY(JJO)*MM%DZ(KKO))/(DY(JJ)*DZ(KK)) )
                  CASE(-1)
                     ARO = MIN(1._EB , (MM%DY(JJO)*MM%DZ(KKO))/(DY(JJ)*DZ(KK)) )
                  CASE( 2)
                     ARO = MIN(1._EB , (MM%DX(IIO)*MM%DZ(KKO))/(DX(II)*DZ(KK)) )
                  CASE(-2)
                     ARO = MIN(1._EB , (MM%DX(IIO)*MM%DZ(KKO))/(DX(II)*DZ(KK)) )
                  CASE( 3)
                     ARO = MIN(1._EB , (MM%DX(IIO)*MM%DY(JJO))/(DX(II)*DY(JJ)) )
                  CASE(-3)
                     ARO = MIN(1._EB , (MM%DX(IIO)*MM%DY(JJO))/(DX(II)*DY(JJ)) )
               END SELECT
               RHO_OTHER = RHO_OTHER + ARO*OM_RHOP(IIO,JJO,KKO)
               IF (N_TRACKED_SPECIES>0) RHO_ZZ_OTHER(1:N_TRACKED_SPECIES) = RHO_ZZ_OTHER(1:N_TRACKED_SPECIES) &
                  + ARO*OM_RHOP(IIO,JJO,KKO)*OM_ZZP(IIO,JJO,KKO,1:N_TRACKED_SPECIES)
            ENDDO
         ENDDO
      ENDDO

      ! Density

      RHO_G = RHOP(IIG,JJG,KKG)
      RHO_G_2 = RHO_G   
      RHO_OTHER_2 = RHO_OTHER ! first order extrapolation of scalar data
      RHOP(II,JJ,KK) = RHO_OTHER   
      SELECT CASE(IOR)
         CASE( 1) 
            ZZZ(1:4) = (/RHO_OTHER_2,RHO_OTHER,RHO_G,RHO_G_2/)
            WC%RHO_F = SCALAR_FACE_VALUE(UU(II,JJ,KK),ZZZ,FLUX_LIMITER)
         CASE(-1)
            ZZZ(1:4) = (/RHO_G_2,RHO_G,RHO_OTHER,RHO_OTHER_2/)
            WC%RHO_F = SCALAR_FACE_VALUE(UU(II-1,JJ,KK),ZZZ,FLUX_LIMITER)
         CASE( 2) 
            ZZZ(1:4) = (/RHO_OTHER_2,RHO_OTHER,RHO_G,RHO_G_2/)
            WC%RHO_F = SCALAR_FACE_VALUE(VV(II,JJ,KK),ZZZ,FLUX_LIMITER)
         CASE(-2) 
            ZZZ(1:4) = (/RHO_G_2,RHO_G,RHO_OTHER,RHO_OTHER_2/)
            WC%RHO_F = SCALAR_FACE_VALUE(VV(II,JJ-1,KK),ZZZ,FLUX_LIMITER)
         CASE( 3) 
            ZZZ(1:4) = (/RHO_OTHER_2,RHO_OTHER,RHO_G,RHO_G_2/)
            WC%RHO_F = SCALAR_FACE_VALUE(WW(II,JJ,KK),ZZZ,FLUX_LIMITER)
         CASE(-3) 
            ZZZ(1:4) = (/RHO_G_2,RHO_G,RHO_OTHER,RHO_OTHER_2/)
            WC%RHO_F = SCALAR_FACE_VALUE(WW(II,JJ,KK-1),ZZZ,FLUX_LIMITER)
      END SELECT
      
      ! Species

      IF (N_TRACKED_SPECIES==0) THEN
         TMP(II,JJ,KK) = PBAR_P(KK,WC%PRESSURE_ZONE)/(SPECIES_MIXTURE(0)%RCON*RHOP(II,JJ,KK))
         TMP_F = PBAR_P(KK,WC%PRESSURE_ZONE)/(SPECIES_MIXTURE(0)%RCON*WC%RHO_F)
      ELSE

         SPECIES_LOOP: DO N=1,N_TRACKED_SPECIES

            RHO_ZZ_G = RHO_G*ZZP(IIG,JJG,KKG,N)
            RHO_ZZ_G_2 = RHO_ZZ_G         
            RHO_ZZ_OTHER_2 = RHO_ZZ_OTHER(N)
            SELECT CASE(IOR)
               CASE( 1) 
                  ZZZ(1:4) = (/RHO_ZZ_OTHER_2,RHO_ZZ_OTHER(N),RHO_ZZ_G,RHO_ZZ_G_2/)
                  RHO_ZZ_F(N) = SCALAR_FACE_VALUE(UU(II,JJ,KK),ZZZ,FLUX_LIMITER)
               CASE(-1)
                  ZZZ(1:4) = (/RHO_ZZ_G_2,RHO_ZZ_G,RHO_ZZ_OTHER(N),RHO_ZZ_OTHER_2/)
                  RHO_ZZ_F(N) = SCALAR_FACE_VALUE(UU(II-1,JJ,KK),ZZZ,FLUX_LIMITER)
               CASE( 2) 
                  ZZZ(1:4) = (/RHO_ZZ_OTHER_2,RHO_ZZ_OTHER(N),RHO_ZZ_G,RHO_ZZ_G_2/)
                  RHO_ZZ_F(N) = SCALAR_FACE_VALUE(VV(II,JJ,KK),ZZZ,FLUX_LIMITER)
               CASE(-2) 
                  ZZZ(1:4) = (/RHO_ZZ_G_2,RHO_ZZ_G,RHO_ZZ_OTHER(N),RHO_ZZ_OTHER_2/)
                  RHO_ZZ_F(N) = SCALAR_FACE_VALUE(VV(II,JJ-1,KK),ZZZ,FLUX_LIMITER)
               CASE( 3) 
                  ZZZ(1:4) = (/RHO_ZZ_OTHER_2,RHO_ZZ_OTHER(N),RHO_ZZ_G,RHO_ZZ_G_2/)
                  RHO_ZZ_F(N) = SCALAR_FACE_VALUE(WW(II,JJ,KK),ZZZ,FLUX_LIMITER)
               CASE(-3) 
                  ZZZ(1:4) = (/RHO_ZZ_G_2,RHO_ZZ_G,RHO_ZZ_OTHER(N),RHO_ZZ_OTHER_2/)
                  RHO_ZZ_F(N) = SCALAR_FACE_VALUE(WW(II,JJ,KK-1),ZZZ,FLUX_LIMITER)
            END SELECT
         ENDDO SPECIES_LOOP

         ! face value of temperature
         WC%ZZ_F(1:N_TRACKED_SPECIES) = MAX(0._EB,MIN(1._EB,RHO_ZZ_F(1:N_TRACKED_SPECIES)/WC%RHO_F))
         ZZ_GET(1:N_TRACKED_SPECIES) = WC%ZZ_F(1:N_TRACKED_SPECIES)
         CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,RSUM_W)
         TMP_F = PBAR_P(KK,WC%PRESSURE_ZONE)/(RSUM_W*WC%RHO_F)

         ! ghost cell value of temperature
         ZZP(II,JJ,KK,1:N_TRACKED_SPECIES) = RHO_ZZ_OTHER(1:N_TRACKED_SPECIES)/RHO_OTHER
         ZZ_GET(1:N_TRACKED_SPECIES) = MAX(0._EB,ZZP(II,JJ,KK,1:N_TRACKED_SPECIES))
         CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,RSUM_W)
         TMP(II,JJ,KK) = PBAR_P(KK,WC%PRESSURE_ZONE)/(RSUM_W*RHOP(II,JJ,KK))

      ENDIF

      ONE_D%QCONF = 0._EB ! no convective heat transfer at interoplated boundary

END SELECT METHOD_OF_HEAT_TRANSFER
      
END SUBROUTINE HEAT_TRANSFER_BC

END SUBROUTINE THERMAL_BC


SUBROUTINE SPECIES_BC(T,NM)

! Compute the species mass fractions at the boundary, ZZ_F

USE PHYSICAL_FUNCTIONS, ONLY: GET_AVERAGE_SPECIFIC_HEAT,GET_SPECIFIC_HEAT,GET_SENSIBLE_ENTHALPY,SURFACE_DENSITY
USE OUTPUT_DATA, ONLY: M_DOT
REAL(EB) :: RADIUS,AREA_SCALING,RVC,RHO_NEW,M_DOT_PPP,CP,CPBAR,MW_RATIO,H_G,DELTA_H_G,ZZ_GET(0:N_TRACKED_SPECIES), &
            CPBAR2
REAL(EB), INTENT(IN) :: T
INTEGER, INTENT(IN) :: NM
INTEGER :: II,JJ,KK,IIG,JJG,KKG,IW,NS,IP
TYPE (SURFACE_TYPE), POINTER :: SF=>NULL()
TYPE (LAGRANGIAN_PARTICLE_CLASS_TYPE), POINTER :: LPC=>NULL()
TYPE (LAGRANGIAN_PARTICLE_TYPE), POINTER :: LP=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:) :: RHOP=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: ZZP=>NULL()
TYPE (WALL_TYPE), POINTER :: WC=>NULL()
TYPE (ONE_D_M_AND_E_XFER_TYPE), POINTER :: ONE_D=>NULL()

IF (VEG_LEVEL_SET) RETURN
 
IF (PREDICTOR) THEN
   RHOP => RHOS
   ZZP => ZZS
ELSE
   RHOP => RHO
   ZZP => ZZ
ENDIF 
 
! Loop through the wall cells, apply mass boundary conditions

WALL_CELL_LOOP: DO IW=1,N_EXTERNAL_WALL_CELLS+N_INTERNAL_WALL_CELLS

   WC => WALL(IW)

   IF (WC%BOUNDARY_TYPE==OPEN_BOUNDARY)         CYCLE WALL_CELL_LOOP
   IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY)         CYCLE WALL_CELL_LOOP
   IF (WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) CYCLE WALL_CELL_LOOP

   ONE_D => WC%ONE_D
   SF => SURFACE(WC%SURF_INDEX)
   II  = ONE_D%II
   JJ  = ONE_D%JJ
   KK  = ONE_D%KK
   IIG = ONE_D%IIG
   JJG = ONE_D%JJG
   KKG = ONE_D%KKG
   
   CALL CALC_SPECIES_BC(WALL_INDEX=IW)

   ! Only set species mass fraction in the ghost cell if it is not solid
    
   IF (IW<=N_EXTERNAL_WALL_CELLS .AND. N_TRACKED_SPECIES > 0 .AND. &
       .NOT.SOLID(CELL_INDEX(II,JJ,KK)) .AND. .NOT.SOLID(CELL_INDEX(IIG,JJG,KKG))) &
      ZZP(II,JJ,KK,1:N_TRACKED_SPECIES) = 2._EB*WC%ZZ_F(1:N_TRACKED_SPECIES) - ZZP(IIG,JJG,KKG,1:N_TRACKED_SPECIES)

ENDDO WALL_CELL_LOOP

! Add evaporating gases from virtual particles to the mesh using a volumetric source term

PARTICLE_LOOP: DO IP=1,NLP

   LP  => LAGRANGIAN_PARTICLE(IP)
   LPC => LAGRANGIAN_PARTICLE_CLASS(LP%CLASS_INDEX)

   IF (LPC%SURF_INDEX==DROPLET_SURF_INDEX .OR. LPC%SURF_INDEX==MASSLESS_PARTICLE_SURF_INDEX) CYCLE PARTICLE_LOOP

   SF => SURFACE(LPC%SURF_INDEX)
   ONE_D => LP%ONE_D
   IIG = ONE_D%IIG
   JJG = ONE_D%JJG
   KKG = ONE_D%KKG
   II  = IIG
   JJ  = JJG
   KK  = KKG

   CALL CALC_SPECIES_BC(PARTICLE_INDEX=IP)

   IF (PREDICTOR) CYCLE PARTICLE_LOOP

   IF (SF%PYROLYSIS_MODEL==PYROLYSIS_MATERIAL) THEN
      RADIUS = SUM(ONE_D%LAYER_THICKNESS(1:SF%N_LAYERS))
   ELSEIF (SF%THERMALLY_THICK) THEN
      RADIUS = SF%THICKNESS
   ELSE
      RADIUS = SF%RADIUS
   ENDIF

   IF (ABS(RADIUS)<ZERO_P) CYCLE PARTICLE_LOOP

   AREA_SCALING = 1._EB
   SELECT CASE(SF%GEOMETRY)
      CASE(SURF_CARTESIAN)
         ONE_D%AREA = SF%LENGTH*SF%WIDTH
      CASE(SURF_CYLINDRICAL)
         ONE_D%AREA  = TWOPI*RADIUS*SF%LENGTH
         IF (SF%THERMAL_BC_INDEX == THERMALLY_THICK) AREA_SCALING = (SF%THICKNESS/RADIUS)
      CASE(SURF_SPHERICAL)
         ONE_D%AREA  = 4._EB*PI*RADIUS**2
         IF (SF%THERMAL_BC_INDEX == THERMALLY_THICK) AREA_SCALING = (SF%THICKNESS/RADIUS)**2
   END SELECT

   ! In PYROLYSIS, all the mass fluxes are normalized by a virtual area based on the INITIAL radius. 
   ! Here, correct the mass flux using the CURRENT radius.

   IF (CALL_PYROLYSIS) THEN
         ONE_D%MASSFLUX(0:N_TRACKED_SPECIES)         = ONE_D%MASSFLUX(0:N_TRACKED_SPECIES)       *AREA_SCALING  
         ONE_D%MASSFLUX_ACTUAL(0:N_TRACKED_SPECIES)  = ONE_D%MASSFLUX_ACTUAL(0:N_TRACKED_SPECIES)*AREA_SCALING
   ENDIF
   
   ! Add evaporated particle species to gas phase and compute resulting contribution to the divergence

   RVC = RDX(IIG)*RRN(IIG)*RDY(JJG)*RDZ(KKG)
   IF (N_TRACKED_SPECIES > 0) ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(IIG,JJG,KKG,1:N_TRACKED_SPECIES)
   
   CALL GET_SPECIFIC_HEAT(ZZ_GET,CP,TMP(IIG,JJG,KKG))
   H_G = CP*TMP(IIG,JJG,KKG)

   DO NS=0,N_TRACKED_SPECIES
      IF (ABS(ONE_D%MASSFLUX(NS))<=ZERO_P) CYCLE
      IF (N_TRACKED_SPECIES>0) THEN
         MW_RATIO = SPECIES_MIXTURE(NS)%RCON/RSUM(IIG,JJG,KKG)         
      ELSE
         MW_RATIO = 1._EB
      ENDIF
      M_DOT_PPP = LP%PWT*ONE_D%MASSFLUX(NS)*ONE_D%AREA*RVC
      ZZ_GET=0._EB
      IF (NS>0) ZZ_GET(NS)=1._EB
      CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CPBAR,TMP(IIG,JJG,KKG))
      CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CPBAR2,LP%ONE_D%TMP_F)
      DELTA_H_G = CPBAR2*LP%ONE_D%TMP_F-CPBAR*TMP(IIG,JJG,KKG)
      D_LAGRANGIAN(IIG,JJG,KKG) =  D_LAGRANGIAN(IIG,JJG,KKG) + M_DOT_PPP*(MW_RATIO + DELTA_H_G/H_G)/RHO(IIG,JJG,KKG)
      RHO_NEW = RHO(IIG,JJG,KKG) + M_DOT_PPP*DT
      IF (N_TRACKED_SPECIES>0) ZZP(IIG,JJG,KKG,1:N_TRACKED_SPECIES) = ZZP(IIG,JJG,KKG,1:N_TRACKED_SPECIES)*RHO(IIG,JJG,KKG)/RHO_NEW
      IF (NS>0) ZZP(IIG,JJG,KKG,NS) = ZZP(IIG,JJG,KKG,NS) + M_DOT_PPP*DT/RHO_NEW
      RHO(IIG,JJG,KKG) = RHO_NEW
   ENDDO

   ! Calculate contribution to divergence term due to convective heat transfer from particle

   D_LAGRANGIAN(IIG,JJG,KKG) =  D_LAGRANGIAN(IIG,JJG,KKG) - ONE_D%QCONF*ONE_D%AREA*RVC/(RHO(IIG,JJG,KKG)*H_G) * LP%PWT

   ! Calculate the mass flux of fuel gas from particles

   IF (N_REACTIONS>0) THEN
      IF (ONE_D%MASSFLUX(REACTION(1)%FUEL_SMIX_INDEX)>0._EB .AND. CORRECTOR) &
         M_DOT(2,NM) = M_DOT(2,NM) + ONE_D%MASSFLUX(REACTION(1)%FUEL_SMIX_INDEX)*ONE_D%AREA*LP%PWT
   ENDIF   

   ! Calculate particle mass
   
   CALC_LP_MASS:IF (SF%THERMALLY_THICK) THEN
      SELECT CASE (SF%GEOMETRY)
         CASE (SURF_CARTESIAN)               
            LP%MASS = SF%LENGTH*SF%WIDTH*SF%THICKNESS*SURFACE_DENSITY(NM,1,LAGRANGIAN_PARTICLE_INDEX=IP)
          CASE (SURF_CYLINDRICAL)
            LP%MASS = SF%LENGTH*PI*SF%THICKNESS**2*SURFACE_DENSITY(NM,1,LAGRANGIAN_PARTICLE_INDEX=IP)
         CASE (SURF_SPHERICAL)
            LP%MASS = FOTHPI*SF%THICKNESS**3*SURFACE_DENSITY(NM,1,LAGRANGIAN_PARTICLE_INDEX=IP)
      END SELECT
   ENDIF CALC_LP_MASS  

ENDDO PARTICLE_LOOP

CONTAINS

SUBROUTINE CALC_SPECIES_BC(WALL_INDEX,PARTICLE_INDEX)

USE PHYSICAL_FUNCTIONS, ONLY: GET_SPECIFIC_GAS_CONSTANT
USE MATH_FUNCTIONS, ONLY : EVALUATE_RAMP
REAL(EB) :: ZZ_G,UN,DD,MFT,TSI,ZZ_GET(0:N_TRACKED_SPECIES),RSUM_F,MPUA_SUM,TW,AREA_ADJUST
INTEGER :: N,ITER
INTEGER, INTENT(IN), OPTIONAL :: WALL_INDEX,PARTICLE_INDEX

! Special cases
    
IF (N_TRACKED_SPECIES==0 .AND. .NOT. SF%SPECIES_BC_INDEX==SPECIFIED_MASS_FLUX)                              RETURN
IF (N_TRACKED_SPECIES==0 .AND. SF%SPECIES_BC_INDEX==SPECIFIED_MASS_FLUX .AND. ABS(SF%MASS_FLUX(0))<=ZERO_P) RETURN

! Set a few common parameters

TW  = ONE_D%T
AREA_ADJUST = ONE_D%AREA_ADJUST

! Check if suppression by water is to be applied and sum water on surface

IF (PRESENT(WALL_INDEX) .AND. CORRECTOR .AND. SF%E_COEFFICIENT>0._EB .AND. I_WATER>0) THEN
   IF (SPECIES_MIXTURE(I_WATER)%EVAPORATING) THEN
      MPUA_SUM = 0._EB
      DO N=1,N_LAGRANGIAN_CLASSES
         LPC=>LAGRANGIAN_PARTICLE_CLASS(N)
         IF (LPC%Z_INDEX==I_WATER) MPUA_SUM = MPUA_SUM + WC%LP_MPUA(LPC%ARRAY_INDEX)
      ENDDO
      WC%EW = WC%EW + SF%E_COEFFICIENT*MPUA_SUM*DT
   ENDIF
ENDIF

! Apply the different species boundary conditions to non-thermally thick solids

METHOD_OF_MASS_TRANSFER: SELECT CASE(SF%SPECIES_BC_INDEX)

   CASE (INFLOW_OUTFLOW_MASS_FLUX) METHOD_OF_MASS_TRANSFER
   
      ! OPEN boundary species BC is done in THERMAL_BC under INFLOW_OUTFLOW 
    
   CASE (NO_MASS_FLUX) METHOD_OF_MASS_TRANSFER 
   
      IF (.NOT.SOLID(CELL_INDEX(IIG,JJG,KKG)) .AND. PRESENT(WALL_INDEX)) &
         WC%ZZ_F(1:N_TRACKED_SPECIES) = ZZP(IIG,JJG,KKG,1:N_TRACKED_SPECIES)
    
   CASE (SPECIFIED_MASS_FRACTION) METHOD_OF_MASS_TRANSFER
   
      IF (ABS(TW-T_BEGIN)< SPACING(TW) .AND. ANY(SF%RAMP_INDEX>=1)) THEN
         IF (PREDICTOR) TSI = T + DT
         IF (CORRECTOR) TSI = T
      ELSE
         IF (PREDICTOR) TSI = T + DT - TW
         IF (CORRECTOR) TSI = T      - TW
      ENDIF
   
      IF (ONE_D%UWS<0._EB) THEN
         DO N=1,N_TRACKED_SPECIES
            WC%ZZ_F(N) =  SPECIES_MIXTURE(N)%ZZ0 + EVALUATE_RAMP(TSI,SF%TAU(N),SF%RAMP_INDEX(N))* &
                           (SF%MASS_FRACTION(N)-SPECIES_MIXTURE(N)%ZZ0)
         ENDDO
      ELSE
         WC%ZZ_F(1:N_TRACKED_SPECIES) = ZZP(IIG,JJG,KKG,1:N_TRACKED_SPECIES)
      ENDIF
    
   CASE (SPECIFIED_MASS_FLUX) METHOD_OF_MASS_TRANSFER
   
      ! If the current time is before the "activation" time, TW, apply simple BCs and get out
   
      IF (T < TW) THEN
         ONE_D%MASSFLUX(0) = 0._EB
         IF (N_TRACKED_SPECIES > 0)  THEN
            IF (.NOT.SOLID(CELL_INDEX(IIG,JJG,KKG)) .AND. PRESENT(WALL_INDEX)) THEN
               WC%ZZ_F(1:N_TRACKED_SPECIES) = ZZP(IIG,JJG,KKG,1:N_TRACKED_SPECIES)
            ENDIF
            IF (PREDICTOR) ONE_D%UWS = 0._EB
            ONE_D%MASSFLUX(1:N_TRACKED_SPECIES) = 0._EB
            ONE_D%MASSFLUX_ACTUAL(1:N_TRACKED_SPECIES) = 0._EB
         ENDIF
         RETURN
      ENDIF
   
      ! Zero out the running counter of Mass Flux Total (MFT)
   
      MFT = 0._EB
   
      ! If the user has specified the burning rate, evaluate the ramp and other related parameters
   
      SUM_MASSFLUX_LOOP: DO N=0,N_TRACKED_SPECIES
         IF (SF%MASS_FLUX(N) > 0._EB) THEN  ! Use user-specified ramp-up of mass flux
            IF (ABS(TW-T_BEGIN)< SPACING(ONE_D%T) .AND. SF%RAMP_INDEX(N)>=1) THEN
               TSI = T + DT
            ELSE
               TSI = T + DT - TW
            ENDIF
            ONE_D%MASSFLUX(N) = EVALUATE_RAMP(TSI,SF%TAU(N),SF%RAMP_INDEX(N))*SF%MASS_FLUX(N)
            ONE_D%MASSFLUX_ACTUAL(N) = ONE_D%MASSFLUX(N)
            ONE_D%MASSFLUX(N) = SF%ADJUST_BURN_RATE(N)*ONE_D%MASSFLUX(N)
         ENDIF
         ONE_D%MASSFLUX(N) = ONE_D%MASSFLUX(N)*AREA_ADJUST
         MFT = MFT + ONE_D%MASSFLUX(N)
      ENDDO SUM_MASSFLUX_LOOP
   
      ! Convection-diffusion boundary condition at a solid wall cell

      IF (PRESENT(WALL_INDEX)) THEN

         IF (WC%EW>0._EB) ONE_D%MASSFLUX(0:N_TRACKED_SPECIES) = ONE_D%MASSFLUX(0:N_TRACKED_SPECIES)*EXP(-WC%EW)
   
         ! Add total consumed mass to various summing arrays
   
         CONSUME_MASS: IF (CORRECTOR .AND. SF%THERMALLY_THICK) THEN  
            DO N=1,N_TRACKED_SPECIES
               OBSTRUCTION(WC%OBST_INDEX)%MASS = OBSTRUCTION(WC%OBST_INDEX)%MASS - ONE_D%MASSFLUX_ACTUAL(N)*DT*WC%AW
            ENDDO
         ENDIF CONSUME_MASS
   
         ! Compute the cell face value of the species mass fraction to get the right mass flux
    
         DO ITER=1,5
            UN    = MFT/WC%RHO_F
            SPECIES_LOOP: DO N=1,N_TRACKED_SPECIES
               DD = 2.*WC%RHODW(N)*WC%RDN
               ZZ_G  = ZZP(IIG,JJG,KKG,N)
               WC%ZZ_F(N) = ( ONE_D%MASSFLUX(N) + DD*ZZ_G ) / (DD + UN*WC%RHO_F)
            ENDDO SPECIES_LOOP
            ZZ_GET(1:N_TRACKED_SPECIES) = MAX(0._EB,WC%ZZ_F(1:N_TRACKED_SPECIES))
            CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,RSUM_F)
            WC%RHO_F = PBAR_S(KK,WC%PRESSURE_ZONE)/(RSUM_F*WC%ONE_D%TMP_F)
         ENDDO
   
         IF (PREDICTOR) ONE_D%UWS = -UN
         IF (CORRECTOR) ONE_D%UW  = -UN 

      ENDIF
   
END SELECT METHOD_OF_MASS_TRANSFER

END SUBROUTINE CALC_SPECIES_BC

END SUBROUTINE SPECIES_BC

 
SUBROUTINE DENSITY_BC
 
! Compute density at wall from wall temperatures and mass fractions 

USE PHYSICAL_FUNCTIONS, ONLY : GET_SPECIFIC_GAS_CONSTANT
REAL(EB) :: ZZ_GET(0:N_TRACKED_SPECIES),RSUM_F
INTEGER  :: IW,II,JJ,KK
REAL(EB), POINTER, DIMENSION(:,:) :: PBAR_P=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:) :: RHOP=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: ZZP=>NULL()
TYPE (WALL_TYPE), POINTER :: WC=>NULL()

IF (VEG_LEVEL_SET) RETURN
 
IF (PREDICTOR) THEN 
   PBAR_P => PBAR_S
   RHOP => RHOS
   ZZP  => ZZS
ELSE 
   PBAR_P => PBAR
   RHOP => RHO
   ZZP  => ZZ 
ENDIF

WALL_CELL_LOOP: DO IW=1,N_EXTERNAL_WALL_CELLS+N_INTERNAL_WALL_CELLS

   WC => WALL(IW)
   IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY) CYCLE WALL_CELL_LOOP

   II  = WC%ONE_D%II
   JJ  = WC%ONE_D%JJ
   KK  = WC%ONE_D%KK

   ! Determine ghost cell value of RSUM=R0*Sum(Y_i/W_i) 

   IF (N_TRACKED_SPECIES>0) ZZ_GET(1:N_TRACKED_SPECIES) = MAX(0._EB,WC%ZZ_F(1:N_TRACKED_SPECIES))
   CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,RSUM_F)
 
   ! Compute density at boundary cell face

   IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY) WC%RHO_F = PBAR_P(KK,WC%PRESSURE_ZONE)/(RSUM_F*WC%ONE_D%TMP_F)

   ! Set ghost cell values for open and interpolated boundaries

   IF (WC%BOUNDARY_TYPE==OPEN_BOUNDARY .OR. WC%BOUNDARY_TYPE==INTERPOLATED_BOUNDARY) THEN
      IF (N_TRACKED_SPECIES>0) ZZ_GET(1:N_TRACKED_SPECIES) = MAX(0._EB,ZZP(II,JJ,KK,1:N_TRACKED_SPECIES))
      CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,RSUM(II,JJ,KK))
      RHOP(II,JJ,KK) = PBAR_P(KK,WC%PRESSURE_ZONE)/(RSUM(II,JJ,KK)*TMP(II,JJ,KK))
   ENDIF
 
ENDDO WALL_CELL_LOOP

END SUBROUTINE DENSITY_BC
 

SUBROUTINE HVAC_BC

! Compute density at wall from wall temperatures and mass fractions 

USE HVAC_ROUTINES, ONLY : NODE_CP,NODE_TMP,NODE_RHO,DUCT_VF,LEAK_PATH,NODE_ZZ
USE PHYSICAL_FUNCTIONS, ONLY : GET_SPECIFIC_GAS_CONSTANT
REAL(EB) :: ZZ_GET(0:N_TRACKED_SPECIES),ZZ_G(1:N_TRACKED_SPECIES),UN,MFT,DD,RSUM_F
REAL(EB) :: RHO_0,ZZ_0(1:N_TRACKED_SPECIES),UW_0,ZZ_ERR
INTEGER  :: IIG,JJG,KKG,IW,KK,N,SURF_INDEX,COUNTER,DN,DN2,DU,IZ1,IZ2
LOGICAL :: ITER = .FALSE.
REAL(EB), POINTER, DIMENSION(:,:) :: PBAR_P=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:) :: RHOP=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: ZZP=>NULL()
TYPE (SURFACE_TYPE), POINTER :: SF=>NULL()
TYPE (WALL_TYPE),POINTER :: WC=>NULL()

IF (PREDICTOR) THEN 
   RHOP => RHOS
   IF (N_TRACKED_SPECIES > 0) ZZP => ZZS
   PBAR_P => PBAR_S
ELSE 
   RHOP => RHO
   IF (N_TRACKED_SPECIES > 0) ZZP => ZZ
   PBAR_P => PBAR
ENDIF

! Loop over all internal and external wall cells

WALL_CELL_LOOP: DO IW=1,N_EXTERNAL_WALL_CELLS+N_INTERNAL_WALL_CELLS
   WC=>WALL(IW)
   SURF_INDEX = WC%SURF_INDEX
   SF => SURFACE(SURF_INDEX)   
   IF (SF%SPECIES_BC_INDEX/=HVAC_BOUNDARY .AND. SF%THERMAL_BC_INDEX/=HVAC_BOUNDARY .AND. &
       .NOT. ANY(SF%LEAK_PATH>0._EB)) CYCLE WALL_CELL_LOOP
   KK  = WC%ONE_D%KK
   IIG = WC%ONE_D%IIG
   JJG = WC%ONE_D%JJG
   KKG = WC%ONE_D%KKG
   COUNTER = 0

   ! Compute R*Sum(Y_i/W_i) at the wall

   IF (N_TRACKED_SPECIES>0) THEN
      ZZ_G = ZZP(IIG,JJG,KKG,:)
      ZZ_GET(1:N_TRACKED_SPECIES) = MAX(0._EB,WC%ZZ_F(1:N_TRACKED_SPECIES))
      CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,RSUM_F)
   ELSE
      RSUM_F = RSUM0
   ENDIF
   IF (WC%VENT_INDEX > 0 .AND. .NOT. ANY(SF%LEAK_PATH>0._EB)) THEN
      IF (VENTS(WC%VENT_INDEX)%NODE_INDEX > 0) THEN
         DN=VENTS(WC%VENT_INDEX)%NODE_INDEX    
         DU=DUCTNODE(DN)%DUCT_INDEX(1)
         MFT = -DUCTNODE(DN)%DIR(1)*DUCT_VF(DU,1)*NODE_RHO(DN,1)/VENTS(WC%VENT_INDEX)%FDS_AREA
         IF (DUCTNODE(DN)%DIR(1)*DUCT_VF(DU,1) > 0._EB) THEN
            WC%ONE_D%TMP_F = NODE_TMP(DN,1)
         ELSE
            WC%ONE_D%TMP_F = TMP(IIG,JJG,KKG)
         ENDIF
      ENDIF
      WC%ONE_D%HEAT_TRANS_COEF = 0._EB
      WC%ONE_D%QCONF = 0._EB            
   ELSE !leakage
      IF (WC%PRESSURE_ZONE==SF%LEAK_PATH(1)) THEN
         IZ1 = SF%LEAK_PATH(1)
         IZ2 = SF%LEAK_PATH(2)  
      ELSE
         IZ1 = SF%LEAK_PATH(2)
         IZ2 = SF%LEAK_PATH(1)  
      ENDIF
      DU = LEAK_PATH(MIN(IZ1,IZ2),MAX(IZ1,IZ2))
      IF (DUCTNODE(DUCT(DU)%NODE_INDEX(1))%ZONE_INDEX==WC%PRESSURE_ZONE) THEN
         DN2=DUCT(DU)%NODE_INDEX(1)
      ELSE
         DN2=DUCT(DU)%NODE_INDEX(2)
      ENDIF 
      IF(DUCT_VF(DU,1) > 0._EB) THEN
         DN=DUCT(DU)%NODE_INDEX(1)
      ELSE
         DN=DUCT(DU)%NODE_INDEX(2)      
      ENDIF        
      MFT = -DUCTNODE(DN2)%DIR(1)*DUCT_VF(DU,1)*NODE_RHO(DN,1)/FDS_LEAK_AREA(IZ1,IZ2,1)
   ENDIF
   WC%RHO_F = PBAR_P(KK,WC%PRESSURE_ZONE)/(RSUM_F*WC%ONE_D%TMP_F)  
   WC%RHO_F = NODE_RHO(DN,1)
   UN =  -MFT/WC%RHO_F

   ! Iterate to get the appropriate normal velocity and density

   SPECIES_IF_1: IF (N_TRACKED_SPECIES==0) THEN
      WC%ONE_D%MASSFLUX(0) = MFT
   ELSE SPECIES_IF_1
      IF (UN > 0._EB) THEN
         WC%ONE_D%MASSFLUX(1:N_TRACKED_SPECIES) = -NODE_ZZ(DN,1:N_TRACKED_SPECIES,1)*MFT
         WC%ONE_D%MASSFLUX(0) = -MFT - SUM(WC%ONE_D%MASSFLUX(1:N_TRACKED_SPECIES))
      ENDIF
   ENDIF SPECIES_IF_1
   
   ITER = .TRUE.
   DO WHILE (ITER)
      ITER = .FALSE.
      RHO_0 = WC%RHO_F
      ZZ_0  = WC%ZZ_F
      UW_0 = -UN
      UN    = -MFT/WC%RHO_F
      IF (PREDICTOR) WC%ONE_D%UWS = -UN
      IF (CORRECTOR) WC%ONE_D%UW  = -UN
      SPECIES_IF: IF (N_TRACKED_SPECIES==0) THEN
         RSUM_F = RSUM0
      ELSE SPECIES_IF
         ZZ_ERR = 0._EB
         IF (UN <= 0._EB) THEN
            WC%ZZ_F = ZZ_G
         ELSE
            DO N=1,N_TRACKED_SPECIES
               DD = 2._EB*WC%RHODW(N)*WC%RDN
               WC%ZZ_F(N) = ( WC%ONE_D%MASSFLUX(N) + DD*ZZ_G(N) ) / ( DD + UN*WC%RHO_F )
               IF (ZZ_0(N) > 1.E-10_EB) ZZ_ERR = MAX(ZZ_ERR,ABS(WC%ZZ_F(N)-ZZ_0(N))/ZZ_0(N))
            ENDDO
         ENDIF
         IF (COUNTER > 5) WC%ZZ_F(:) = 0.4_EB*WC%ZZ_F(:)+0.6_EB*ZZ_0(:)
         ZZ_GET(1:N_TRACKED_SPECIES) = MAX(0._EB,WC%ZZ_F(1:N_TRACKED_SPECIES))
         CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,RSUM_F)
         IF (ZZ_ERR > 1.E-6_EB) ITER = .TRUE.
      ENDIF SPECIES_IF
      WC%RHO_F = PBAR_P(KK,WC%PRESSURE_ZONE)/(RSUM_F*WC%ONE_D%TMP_F)      

      ! Decide to continue iterating

      IF (ABS(RHO_0 - WC%RHO_F)/RHO_0 > 1.E-6_EB ) ITER = .TRUE.
      IF (ABS(UW_0)>0._EB) THEN
          IF (ABS(UW_0 + UN)/ABS(UW_0) > 1.E-6_EB) ITER = .TRUE.
      ENDIF
      
      COUNTER = COUNTER + 1
      IF (COUNTER > 20) ITER = .FALSE.
      
   ENDDO
   
ENDDO WALL_CELL_LOOP

END SUBROUTINE HVAC_BC


SUBROUTINE GEOM_BC(NM)

! Apply boundary conditions from unstructured geometry (under construction)

USE OUTPUT_DATA, ONLY: Q_DOT
USE PHYSICAL_FUNCTIONS, ONLY: GET_SPECIFIC_HEAT
INTEGER, INTENT(IN) :: NM
INTEGER :: IIG,JJG,KKG,IC,N,NS,ITMP
REAL(EB) :: VC,Q_DOT_GEOM,HTC,ZZ_GET(0:N_TRACKED_SPECIES),CP,DTMP,TMP_G,TMP_F,AREA_RATIO,TMP_OTHER,QNET,QEXTRA,FDERIV,TMP_F_0
REAL(EB), POINTER, DIMENSION(:,:,:) :: RHOP=>NULL()
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: ZZP=>NULL()
TYPE(FACET_TYPE), POINTER :: FC=>NULL()
TYPE(CUTCELL_LINKED_LIST_TYPE), POINTER :: CL=>NULL()
TYPE(SURFACE_TYPE), POINTER :: SF=>NULL()
TYPE(MATERIAL_TYPE), POINTER :: ML=>NULL()

IF (PREDICTOR) THEN
   RHOP => RHOS
   ZZP  => ZZS
ELSE
   RHOP => RHO
   ZZP  => ZZ
ENDIF

D_GEOMETRY  = 0._EB

FACE_LOOP: DO N=1,N_FACE

   FC=>FACET(N)
   CL=>FC%CUTCELL_LIST
   SF=>SURFACE(FC%SURF_INDEX)

   FC%RHO_F = 0._EB
   FC%QCONF = 0._EB
   FC%HEAT_TRANS_COEF = 0._EB
   FC%TMP_G = 0._EB
   TMP_F_0 = FC%TMP_F; FC%TMP_F = 0._EB
   IF (N_TRACKED_SPECIES>0) THEN
      FC%RHODW = 0._EB
      FC%ZZ_F = 0._EB
   ENDIF
   Q_DOT_GEOM = 0._EB

   CUTCELL_LOOP: DO

      IF ( .NOT. ASSOCIATED(CL) ) EXIT CUTCELL_LOOP ! if the next index does not exist, exit the loop

      IC = CL%INDEX
      IIG = I_CUTCELL(IC)
      JJG = J_CUTCELL(IC)
      KKG = K_CUTCELL(IC)
      VC = DX(IIG)*DY(JJG)*DZ(KKG)
      TMP_G = TMP(IIG,JJG,KKG)
      AREA_RATIO = CL%AREA/FC%AW

      ! Diffusivity

      DO NS=1,N_TRACKED_SPECIES
         IF (LES) THEN
            FC%RHODW(NS) = FC%RHODW(NS) + CL%AREA/FC%AW*MU(IIG,JJG,KKG)*RSC*FC%RHO_F/RHOP(IIG,JJG,KKG)
         ELSE
            ITMP = MIN(4999,NINT(FC%TMP_F))
            FC%RHODW(NS) = FC%RHO_F*D_Z(ITMP,NS)
         ENDIF
      ENDDO

      ! Thermal boundary conditions

      METHOD_OF_HEAT_TRANSFER: SELECT CASE(SF%THERMAL_BC_INDEX)

         CASE(NO_CONVECTION)
            TMP_F = TMP_G
            HTC = 0._EB
            Q_DOT_GEOM = 0._EB

         CASE(SPECIFIED_TEMPERATURE)
            IF (SF%TMP_FRONT<0._EB) THEN
               TMP_F = TMP_0(KKG)
            ELSE
               TMP_F = SF%TMP_FRONT
            ENDIF
            DTMP = TMP_G - TMP_F
            HTC = HEAT_TRANSFER_COEFFICIENT(DTMP,SF%H_FIXED,SF%GEOMETRY,SF%CONV_LENGTH,SF%HEAT_TRANSFER_MODEL,&
                                            FACE_INDEX=N,CUTCELL_INDEX=IC)
            Q_DOT_GEOM = -CL%AREA*HTC*DTMP

         CASE(NET_FLUX_BC)

            TMP_OTHER = TMP_G
            TMP_F     = TMP_G
            QNET = -SF%NET_HEAT_FLUX
            ADLOOP: DO
               DTMP = TMP_G - TMP_OTHER
               IF (ABS(QNET) > 0._EB .AND. ABS(DTMP) < ZERO_P) DTMP=1._EB        
               HTC = HEAT_TRANSFER_COEFFICIENT(DTMP,SF%H_FIXED,SF%GEOMETRY,SF%CONV_LENGTH,SF%HEAT_TRANSFER_MODEL,&
                                               FACE_INDEX=N,CUTCELL_INDEX=IC) 
               IF (RADIATION) THEN
                  QEXTRA = HTC*DTMP + FC%QRADIN - SF%EMISSIVITY * SIGMA * TMP_OTHER ** 4 - QNET
                  FDERIV = -HTC - 4._EB * SF%EMISSIVITY * SIGMA * TMP_OTHER ** 3
               ELSE
                  QEXTRA = HTC*DTMP - QNET
                  FDERIV = -HTC
               ENDIF
               IF (ABS(FDERIV) > ZERO_P) TMP_OTHER = TMP_OTHER - QEXTRA / FDERIV
               IF (ABS(TMP_OTHER - TMP_F) / TMP_F < 0.0001) THEN
                  TMP_F = TMP_OTHER
                  EXIT ADLOOP
               ELSE
                  TMP_F = TMP_OTHER 
                  CYCLE ADLOOP
               ENDIF           
            ENDDO ADLOOP
            DTMP = TMP_G - TMP_F
            HTC = HEAT_TRANSFER_COEFFICIENT(DTMP,SF%H_FIXED,SF%GEOMETRY,SF%CONV_LENGTH,SF%HEAT_TRANSFER_MODEL,&
                                            FACE_INDEX=N,CUTCELL_INDEX=IC)
            Q_DOT_GEOM = -CL%AREA*HTC*DTMP

         CASE(CONVECTIVE_FLUX_BC)

            IF (SF%TMP_FRONT<0._EB) THEN
               TMP_F = TMP_0(KKG)
            ELSE
               TMP_F = SF%TMP_FRONT
            ENDIF
            Q_DOT_GEOM = CL%AREA*SF%CONVECTIVE_HEAT_FLUX
            DTMP = TMP_F - TMP_G
            IF (DTMP>ZERO_P) THEN
               HTC = SF%CONVECTIVE_HEAT_FLUX/DTMP
            ELSE
               HTC = 0._EB
            ENDIF

         CASE(THERMALLY_THICK) ! under construction

            DTMP = TMP_G - TMP_F_0
            HTC = HEAT_TRANSFER_COEFFICIENT(DTMP,SF%H_FIXED,SF%GEOMETRY,SF%CONV_LENGTH,SF%HEAT_TRANSFER_MODEL,&
                                            FACE_INDEX=N,CUTCELL_INDEX=IC)
            Q_DOT_GEOM = -CL%AREA*HTC*DTMP
            ML => MATERIAL(SF%MATL_INDEX(1))
            QNET = FC%QRADOUT - FC%QRADIN - HTC*DTMP
            TMP_F = TMP_F_0 - DT*QNET/(ML%RHO_S*ML%C_S)
            TMP_F = MAX(TMPMIN,MIN(TMPMAX,TMP_F))

      END SELECT METHOD_OF_HEAT_TRANSFER

      ! Heat transfer

      FC%QCONF = FC%QCONF - Q_DOT_GEOM/FC%AW
      FC%HEAT_TRANS_COEF = FC%HEAT_TRANS_COEF + AREA_RATIO*HTC
      FC%TMP_G = FC%TMP_G + AREA_RATIO*TMP_G
      FC%TMP_F = FC%TMP_F + AREA_RATIO*TMP_F

      ! Species

      DO NS=1,N_TRACKED_SPECIES
         FC%ZZ_F(NS) = FC%ZZ_F(NS) + AREA_RATIO*ZZP(IIG,JJG,KKG,NS)
      ENDDO

      ! Density

      FC%RHO_F = FC%RHO_F + AREA_RATIO*RHOP(IIG,JJG,KKG)

      ! Divergence contribution

      IF (N_TRACKED_SPECIES>0) ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(IIG,JJG,KKG,1:N_TRACKED_SPECIES)
      CALL GET_SPECIFIC_HEAT(ZZ_GET,CP,TMP_G)
      D_GEOMETRY(IIG,JJG,KKG) = D_GEOMETRY(IIG,JJG,KKG) + Q_DOT_GEOM/VC/(RHOP(IIG,JJG,KKG)*CP*TMP_G)
      Q_DOT(8,NM) = Q_DOT(8,NM) + Q_DOT_GEOM

      CL=>CL%NEXT ! point to the next index in the linked list

   ENDDO CUTCELL_LOOP

ENDDO FACE_LOOP

END SUBROUTINE GEOM_BC

 
SUBROUTINE PYROLYSIS(T,DT_BC,PARTICLE_INDEX,WALL_INDEX)

! Loop through all the boundary cells that require a 1-D heat transfer calc

USE PHYSICAL_FUNCTIONS, ONLY: GET_MOLECULAR_WEIGHT
USE GEOMETRY_FUNCTIONS
USE MATH_FUNCTIONS, ONLY: EVALUATE_RAMP
REAL(EB), INTENT(IN) :: DT_BC,T
INTEGER, INTENT(IN), OPTIONAL:: WALL_INDEX,PARTICLE_INDEX
REAL(EB) :: DTMP,QDXKF,QDXKB,RR,TMP_G,RFACF,RFACB,RFACF2,RFACB2, &
            DXKF,DXKB,REACTION_RATE,QRADINB,RFLUX_UP,RFLUX_DOWN,E_WALLB, &
            MFLUX, MFLUX_S, VOLSUM, &
            DXF, DXB,HTCB,Q_WATER_F,Q_WATER_B,TMP_F_OLD, DX_GRID, RHO_S0,DT2_BC,TOLERANCE,C_S_ADJUST_UNITS,&
            MW_G,H_MASS,X_G,X_W,D_AIR,MU_AIR,U2,V2,W2,RE_L,SC_AIR,SH_FAC_WALL,SHERWOOD,VELCON,RHO_G,TMP_BACK,TMP_WGT,RDN
INTEGER :: IIG,JJG,KKG,IIB,JJB,KKB,IWB,NWP,KK,I,J,NR,NN,NNN,NL,IOR,N,I_OBST,NS,ITMP,N_LAYER_CELLS_NEW(MAX_LAYERS)
REAL(EB) :: SMALLEST_CELL_SIZE(MAX_LAYERS),THICKNESS,ZZ_GET(0:N_TRACKED_SPECIES)
REAL(EB),ALLOCATABLE,DIMENSION(:) :: TMP_W_NEW
REAL(EB),ALLOCATABLE,DIMENSION(:,:) :: INT_WGT
REAL(EB), POINTER, DIMENSION(:,:,:) :: UU=>NULL(),VV=>NULL(),WW=>NULL(),RHOG=>NULL()
REAL(EB), POINTER, DIMENSION(:,:) :: PBARP
REAL(EB), POINTER :: TMP_F,TMP_B,TW
INTEGER  :: NWP_NEW,I_GRAD,STEPCOUNT,SMIX_PTR,IZERO
LOGICAL :: POINT_SHRINK, RECOMPUTE,ITERATE,E_FOUND
TYPE (WALL_TYPE), POINTER :: WC=>NULL()
TYPE (LAGRANGIAN_PARTICLE_TYPE), POINTER :: LP=>NULL()
TYPE (ONE_D_M_AND_E_XFER_TYPE), POINTER :: ONE_D=>NULL()
TYPE (SURFACE_TYPE), POINTER :: SF=>NULL()
TYPE (MATERIAL_TYPE), POINTER :: ML=>NULL()

! Copy commonly used derived type variables into local variables.

UNNPACK_WALL_PARTICLE: IF (PRESENT(WALL_INDEX)) THEN

   WC => WALL(WALL_INDEX)
   SF => SURFACE(WC%SURF_INDEX)
   ONE_D => WC%ONE_D
   IOR = WC%ONE_D%IOR
   IIG = WC%ONE_D%IIG  
   JJG = WC%ONE_D%JJG
   KKG = WC%ONE_D%KKG
   KK  = WC%ONE_D%KK
   TMP_F => ONE_D%TMP_F
   TMP_B => ONE_D%TMP_B
   TW    => ONE_D%T
   I_OBST = WC%OBST_INDEX
   IWB = WC%BACK_INDEX
   RDN = WC%RDN

   ! Compute convective heat flux at the surface

   TMP_G = TMP(IIG,JJG,KKG)
   IF (ASSUMED_GAS_TEMPERATURE > 0._EB) TMP_G = ASSUMED_GAS_TEMPERATURE  ! This is just for diagnostic calcs
   TMP_F_OLD = TMP_F
   DTMP = TMP_G - TMP_F_OLD
   ONE_D%HEAT_TRANS_COEF = HEAT_TRANSFER_COEFFICIENT(DTMP,SF%H_FIXED,SF%GEOMETRY,SF%CONV_LENGTH,SF%HEAT_TRANSFER_MODEL,&
                                                     WALL_INDEX=WALL_INDEX)
   ONE_D%QCONF = ONE_D%HEAT_TRANS_COEF*DTMP
   
   ! Take away energy flux due to water evaporation

   IF (NLP>0) THEN
      Q_WATER_F  = -SUM(WC%LP_CPUA(:))
   ELSE
      Q_WATER_F  = 0._EB
   ENDIF
   
ELSEIF (PRESENT(PARTICLE_INDEX)) THEN UNNPACK_WALL_PARTICLE

   LP => LAGRANGIAN_PARTICLE(PARTICLE_INDEX)
   ONE_D => LP%ONE_D
   SF => SURFACE(LAGRANGIAN_PARTICLE_CLASS(LP%CLASS_INDEX)%SURF_INDEX)
   IIG = LP%ONE_D%IIG  
   JJG = LP%ONE_D%JJG
   KKG = LP%ONE_D%KKG  
   KK  = LP%ONE_D%KKG  
   IOR = LP%ONE_D%IOR
   TMP_F => ONE_D%TMP_F
   TMP_B => ONE_D%TMP_B  
   TW    => LP%ONE_D%T
   I_OBST = 0
   IWB = -1
   IF (IOR==0) THEN
      RDN = (RDX(IIG)*RDY(JJG)*RDZ(KKG))**ONTH
   ELSE
      SELECT CASE (ABS(IOR))
         CASE (1)
            RDN = RDX(IIG)
         CASE (2)
            RDN = RDY(JJG)
         CASE (3)
            RDN = RDZ(KKG)
      END SELECT
   ENDIF
   
   ! Compute convective heat flux at the surface

   TMP_G = TMP(IIG,JJG,KKG)
   IF (ASSUMED_GAS_TEMPERATURE > 0._EB) TMP_G = ASSUMED_GAS_TEMPERATURE  ! This is just for diagnostic calcs
   TMP_F_OLD = TMP_F
   DTMP = TMP_G - TMP_F_OLD
   ONE_D%HEAT_TRANS_COEF = &
      HEAT_TRANSFER_COEFFICIENT(DTMP,SF%H_FIXED,SF%GEOMETRY,SF%CONV_LENGTH,SF%HEAT_TRANSFER_MODEL,PARTICLE_INDEX=PARTICLE_INDEX)
   ONE_D%QCONF = ONE_D%HEAT_TRANS_COEF*DTMP
   Q_WATER_F  = 0._EB   

ENDIF UNNPACK_WALL_PARTICLE

! Set pointers

IF (PREDICTOR) THEN
   UU => U
   VV => V
   WW => W
   RHOG => RHO
   PBARP => PBAR
ELSE
   UU => US
   VV => VS
   WW => WS
   RHOG => RHOS
   PBARP => PBAR_S
ENDIF

! Miscellaneous coefficients

SC_AIR = 0.6_EB     ! NU_AIR/D_AIR (Incropera & DeWitt, Chap 7, External Flow)
SH_FAC_WALL = 0.037_EB*SC_AIR**ONTH
 
! Special adjustment of specific heat for steady state applications

C_S_ADJUST_UNITS = 1000._EB/TIME_SHRINK_FACTOR
 
! Exponents for cylindrical or spherical coordrinates

SELECT CASE(SF%GEOMETRY)
CASE(SURF_CARTESIAN)
   I_GRAD = 1
CASE(SURF_CYLINDRICAL)
   I_GRAD = 2
CASE(SURF_SPHERICAL)
   I_GRAD = 3
END SELECT

! Compute back side emissivity

E_WALLB = SF%EMISSIVITY_BACK
IF (E_WALLB < 0._EB .AND. SF%BACKING /= INSULATED) THEN
   E_WALLB = 0._EB
   VOLSUM = 0._EB
   IF (SF%PYROLYSIS_MODEL==PYROLYSIS_MATERIAL) THEN
      NWP = SUM(ONE_D%N_LAYER_CELLS(1:SF%N_LAYERS))
   ELSE
      NWP = SF%N_CELLS
   ENDIF
   DO N=1,SF%N_MATL
      IF (ONE_D%RHO(NWP,N)<=ZERO_P) CYCLE
      ML  => MATERIAL(SF%MATL_INDEX(N))
      VOLSUM = VOLSUM + ONE_D%RHO(NWP,N)/ML%RHO_S
      E_WALLB = E_WALLB + ONE_D%RHO(NWP,N)*ML%EMISSIVITY/ML%RHO_S
   ENDDO
   IF (VOLSUM > 0._EB) E_WALLB = E_WALLB/VOLSUM
ENDIF

! Get heat losses from convection and radiation out of back of surface

SELECT CASE(SF%BACKING)
   CASE(VOID)  ! Non-insulated backing to an ambient void
      IF (SF%TMP_BACK>0._EB) THEN
         TMP_BACK = SF%TMP_BACK
      ELSE
         TMP_BACK = TMP_0(KK)
      ENDIF
      DTMP = TMP_BACK - TMP_B
      HTCB = HEAT_TRANSFER_COEFFICIENT(DTMP,SF%H_FIXED,SF%GEOMETRY,SF%CONV_LENGTH,HT_MODEL=0,WALL_INDEX=-1)
      QRADINB   =  E_WALLB*SIGMA*TMP_BACK**4
      Q_WATER_B = 0._EB
      
   CASE(INSULATED) 
      HTCB      = 0._EB
      QRADINB   = 0._EB
      E_WALLB   = 0._EB
      Q_WATER_B = 0._EB
      TMP_BACK   = TMPA
               
   CASE(EXPOSED)
      IF (IWB >= 0) THEN  
         Q_WATER_B = 0._EB
         IF (WALL(IWB)%BOUNDARY_TYPE==SOLID_BOUNDARY) THEN
            IIB = WALL(IWB)%ONE_D%IIG
            JJB = WALL(IWB)%ONE_D%JJG
            KKB = WALL(IWB)%ONE_D%KKG
            TMP_BACK  = TMP(IIB,JJB,KKB)
            DTMP = TMP_BACK - TMP_B
            HTCB = HEAT_TRANSFER_COEFFICIENT(DTMP,SF%H_FIXED,SF%GEOMETRY,SF%CONV_LENGTH,HT_MODEL=0,WALL_INDEX=IWB)
            WALL(IWB)%ONE_D%HEAT_TRANS_COEF = HTCB
            QRADINB  = WALL(IWB)%ONE_D%QRADIN
            IF (NLP>0) Q_WATER_B = -SUM(WALL(IWB)%LP_CPUA(:))
         ELSE
            TMP_BACK = TMP_0(KK)
            DTMP = TMP_BACK - TMP_B
            HTCB = HEAT_TRANSFER_COEFFICIENT(DTMP,SF%H_FIXED,SF%GEOMETRY,SF%CONV_LENGTH,HT_MODEL=0,WALL_INDEX=-1)
            QRADINB  =  E_WALLB*SIGMA*TMPA4
         ENDIF
      ELSE !Particle backside is the same gas cell
         TMP_BACK  = TMP(IIG,JJG,KKG)
         DTMP = TMP_BACK - TMP_B
         HTCB = HEAT_TRANSFER_COEFFICIENT(DTMP,SF%H_FIXED,SF%GEOMETRY,SF%CONV_LENGTH,HT_MODEL=0,PARTICLE_INDEX=PARTICLE_INDEX)
         QRADINB  = ONE_D%QRADIN      
      ENDIF
END SELECT

! Compute grid for reacting nodes

COMPUTE_GRID: IF (SF%PYROLYSIS_MODEL==PYROLYSIS_MATERIAL) THEN
   NWP = SUM(ONE_D%N_LAYER_CELLS(1:SF%N_LAYERS))
   CALL GET_WALL_NODE_WEIGHTS(NWP,SF%N_LAYERS,ONE_D%N_LAYER_CELLS(1:SF%N_LAYERS),ONE_D%LAYER_THICKNESS,SF%GEOMETRY, &
      ONE_D%X(0:NWP),SF%LAYER_DIVIDE,DX_S(1:NWP),RDX_S(0:NWP+1),RDXN_S(0:NWP),DX_WGT_S(0:NWP),DXF,DXB,&
      LAYER_INDEX(0:NWP+1),MF_FRAC(1:NWP))
ELSE COMPUTE_GRID
   NWP         = SF%N_CELLS
   DXF         = SF%DXF
   DXB         = SF%DXB
   DX_S(1:NWP)          = SF%DX(1:NWP)
   RDX_S(0:NWP+1)       = SF%RDX(0:NWP+1)
   RDXN_S(0:NWP)        = SF%RDXN(0:NWP)
   DX_WGT_S(0:NWP)      = SF%DX_WGT(0:NWP)
   LAYER_INDEX(0:NWP+1) = SF%LAYER_INDEX(0:NWP+1)
   MF_FRAC(1:NWP)       = SF%MF_FRAC(1:NWP)
ENDIF COMPUTE_GRID

! Get total thickness of solid and compute radius for cylindrical and spherical coordinate systems.

THICKNESS=SUM(ONE_D%LAYER_THICKNESS(1:SF%N_LAYERS))

DO I=0,NWP
   R_S(I) = ONE_D%X(NWP) - ONE_D%X(I)
ENDDO

! Calculate reaction rates based on the solid phase reactions

Q_S = 0._EB

PYROLYSIS_MATERIAL_IF: IF (SF%PYROLYSIS_MODEL==PYROLYSIS_MATERIAL) THEN

   ! Store the mass flux from the previous time step. It may be needed by liquid routine

   IF (N_REACTIONS>0) MFLUX = ONE_D%MASSFLUX_ACTUAL(REACTION(1)%FUEL_SMIX_INDEX)

   ! Set mass fluxes to 0 and SHRINK to false.

   ONE_D%MASSFLUX(0:N_TRACKED_SPECIES)        = 0._EB
   ONE_D%MASSFLUX_ACTUAL(0:N_TRACKED_SPECIES) = 0._EB
   POINT_SHRINK             = .FALSE.
   ONE_D%SHRINKING          = .FALSE.

   POINT_LOOP1: DO I=1,NWP

      RHO_S0 = SF%LAYER_DENSITY(LAYER_INDEX(I))
      SHRINK_FACTOR(I) = 0._EB

      MATERIAL_LOOP1b: DO N=1,SF%N_MATL

         IF (ONE_D%RHO(I,N) <= 0._EB) CYCLE MATERIAL_LOOP1b

         ML  => MATERIAL(SF%MATL_INDEX(N))

         IF (ML%PYROLYSIS_MODEL==PYROLYSIS_LIQUID) THEN
            SHRINK_FACTOR(I) = 1._EB
            CYCLE MATERIAL_LOOP1b
         ENDIF
         REACTION_LOOP: DO J=1,ML%N_REACTIONS
            ! Reaction rate in 1/s
            REACTION_RATE = ML%A(J)*(ONE_D%RHO(I,N)/RHO_S0)**ML%N_S(J)*EXP(-ML%E(J)/(R0*ONE_D%TMP(I)))
            ! power term
            DTMP = ML%THR_SIGN(J)*(ONE_D%TMP(I)-ML%TMP_THR(J))
            IF (ABS(ML%N_T(J))>=ZERO_P) THEN
               IF (DTMP > 0._EB) THEN
                  REACTION_RATE = REACTION_RATE * DTMP**ML%N_T(J)
               ELSE
                  REACTION_RATE = 0._EB
               ENDIF
            ELSE ! threshold
               IF (DTMP < 0._EB) REACTION_RATE = 0._EB
            ENDIF
            ! Phase change reaction?
            IF (ML%PCR(J)) THEN
               REACTION_RATE = REACTION_RATE / ((ABS(ML%H_R(J))/1000._EB) * DT_BC)
            ENDIF
            ! Reaction rate in kg/(m3s)
            REACTION_RATE = RHO_S0 * REACTION_RATE
            ! Limit reaction rate
            REACTION_RATE = MIN(REACTION_RATE , ONE_D%RHO(I,N)/DT_BC)
            ! Compute mdot''_norm
            MFLUX_S = MF_FRAC(I)*REACTION_RATE*(R_S(I-1)**I_GRAD-R_S(I)**I_GRAD)/(I_GRAD*SF%THICKNESS**(I_GRAD-1))
            ! Sum up local mass fluxes
            DO NS = 1,N_TRACKED_SPECIES
               ONE_D%MASSFLUX(NS)        = ONE_D%MASSFLUX(NS)        + ML%ADJUST_BURN_RATE(NS,J)*ML%NU_GAS(NS,J)*MFLUX_S
               ONE_D%MASSFLUX_ACTUAL(NS) = ONE_D%MASSFLUX_ACTUAL(NS) +                           ML%NU_GAS(NS,J)*MFLUX_S
            ENDDO
            Q_S(I) = Q_S(I) - REACTION_RATE * ML%H_R(J)
            ONE_D%RHO(I,N) = MAX( 0._EB , ONE_D%RHO(I,N) - DT_BC*REACTION_RATE )
            DO NN=1,ML%N_RESIDUE(J)
               IF (ML%NU_RESIDUE(NN,J) > 0._EB ) THEN
                  NNN = SF%RESIDUE_INDEX(N,NN,J)
                  ONE_D%RHO(I,NNN) = ONE_D%RHO(I,NNN) + ML%NU_RESIDUE(NN,J)*DT_BC*REACTION_RATE
               ENDIF
            ENDDO
         ENDDO REACTION_LOOP

         SHRINK_FACTOR(I) = SHRINK_FACTOR(I) + ONE_D%RHO(I,N)/ML%RHO_S

      ENDDO MATERIAL_LOOP1b

      ! If there is any non-reacting material, the material matrix will remain, and no shrinking is allowed

      POINT_SHRINK = .TRUE.
      MATERIAL_LOOP1a: DO N=1,SF%N_MATL
         IF (ONE_D%RHO(I,N)<=ZERO_P) CYCLE MATERIAL_LOOP1a
         ML  => MATERIAL(SF%MATL_INDEX(N))
         IF (ML%PYROLYSIS_MODEL==PYROLYSIS_NONE) THEN
            POINT_SHRINK = .FALSE.
            EXIT MATERIAL_LOOP1a
         ENDIF
      ENDDO MATERIAL_LOOP1a

      ! In points that actually shrink, increase the density to account for filled material

      SHRINK_FACTOR(I) = MIN(SHRINK_FACTOR(I),1._EB)
      IF (POINT_SHRINK) THEN
         IF (SHRINK_FACTOR(I)<1.0_EB) THEN
            ONE_D%SHRINKING=.TRUE.
            IF (SHRINK_FACTOR(I)>0.0_EB) THEN
               MATERIAL_LOOP1c: DO N=1,SF%N_MATL
                  ONE_D%RHO(I,N) = ONE_D%RHO(I,N)/SHRINK_FACTOR(I)
               ENDDO MATERIAL_LOOP1c
            ENDIF
         ENDIF
      ELSE
         SHRINK_FACTOR(I) = 1._EB
      ENDIF

   ENDDO POINT_LOOP1

   ! Compute new coordinates if the solid shrinks. Save new coordinates in X_S_NEW.

   R_S_NEW(NWP) = 0._EB
   DO I=NWP-1,0,-1
      R_S_NEW(I) = ( R_S_NEW(I+1)**I_GRAD + (R_S(I)**I_GRAD-R_S(I+1)**I_GRAD)*SHRINK_FACTOR(I+1) )**(1./REAL(I_GRAD))
   ENDDO

   DO I=0,NWP
      X_S_NEW(I) = R_S_NEW(0) - R_S_NEW(I)
   ENDDO

   ! If the fuel or water massflux is non-zero, set the ignition time

   IF (TW>T) THEN
      IF (SUM(ONE_D%MASSFLUX(0:N_TRACKED_SPECIES)) > 0._EB) TW = T
   ENDIF

   ! Special reactions: LIQUID
   ! Liquid evaporation can only take place on the surface (1st cell)

   POINT_SHRINK = .TRUE.
   MATERIAL_LOOP2a: DO N=1,SF%N_MATL
      ML  => MATERIAL(SF%MATL_INDEX(N))
      IF (ML%PYROLYSIS_MODEL/=PYROLYSIS_LIQUID .AND. ONE_D%RHO(1,N)>0._EB) POINT_SHRINK = .FALSE.
   ENDDO MATERIAL_LOOP2a

   ! Estimate the previous value of liquid mass fluxes. The possibility of multiple liquids not taken into account.

   MATERIAL_LOOP2B: DO N=1,SF%N_MATL
      ML  => MATERIAL(SF%MATL_INDEX(N))
      IF (ML%PYROLYSIS_MODEL/=PYROLYSIS_LIQUID) CYCLE MATERIAL_LOOP2B
      IF (ONE_D%RHO(1,N)<=ZERO_P) CYCLE MATERIAL_LOOP2B
      SMIX_PTR = MAXLOC(ML%NU_GAS(:,1),1)
      ZZ_GET(1:N_TRACKED_SPECIES) = MAX(0._EB,ZZ(IIG,JJG,KKG,1:N_TRACKED_SPECIES))
      CALL GET_MOLECULAR_WEIGHT(ZZ_GET,MW_G)
      X_G = ZZ_GET(SMIX_PTR)/SPECIES_MIXTURE(SMIX_PTR)%MW*MW_G
      X_W = MIN(0.9999_EB,EXP(ML%H_R(1)*SPECIES_MIXTURE(SMIX_PTR)%MW/R0*(1./ML%TMP_BOIL-1./ONE_D%TMP(1))))
      IF (DNS) THEN
         ITMP = MIN(4999,INT(TMP(IIG,JJG,KKG)))
         TMP_WGT = TMP(IIG,JJG,KKG) - ITMP
         D_AIR = D_Z(ITMP,SMIX_PTR)+TMP_WGT*(D_Z(ITMP+1,SMIX_PTR)-D_Z(ITMP+1,SMIX_PTR))
         H_MASS = 2._EB*D_AIR*RDN
      ELSE
         MU_AIR = MU_Z(MIN(5000,NINT(TMP_G)),0)*SPECIES_MIXTURE(0)%MW
         ! Calculate tangential velocity near the surface
         RHO_G = RHOG(IIG,JJG,KKG)
         U2 = 0.25_EB*(UU(IIG,JJG,KKG)+UU(IIG-1,JJG,KKG))**2
         V2 = 0.25_EB*(VV(IIG,JJG,KKG)+VV(IIG,JJG-1,KKG))**2
         W2 = 0.25_EB*(WW(IIG,JJG,KKG)+WW(IIG,JJG,KKG-1))**2
         SELECT CASE(ABS(IOR))
            CASE(1)
               U2 = 0._EB
            CASE(2)
               V2 = 0._EB
            CASE(3)
               W2 = 0._EB
         END SELECT 
         VELCON = SQRT(U2+V2+W2)
         RE_L     = MAX(5.E5_EB,RHO_G*VELCON/(SF%CONV_LENGTH*MU_AIR))
         SHERWOOD = SH_FAC_WALL*RE_L**0.8_EB
         H_MASS = SHERWOOD*MU_AIR/(SC*SF%CONV_LENGTH)
      ENDIF
      IF (ABS(X_W-1._EB) < ZERO_P) THEN
         MFLUX = THICKNESS*ML%RHO_S/DT_BC
      ELSE
         MFLUX = MAX(0._EB,SPECIES_MIXTURE(SMIX_PTR)%MW/R0/ONE_D%TMP(1)*H_MASS*LOG((X_G-1._EB)/(X_W-1._EB)))
         MFLUX = MFLUX * PBARP(KKG,PRESSURE_ZONE(IIG,JJG,KKG))
         MFLUX = MIN(MFLUX,THICKNESS*ML%RHO_S/DT_BC)
      ENDIF

      !QNETF = Q_WATER_F + ONE_D%QRADIN - ONE_D%QRADOUT + ONE_D%QCONF
      !MFLUX = MAX(MFLUX,1.02*(QNETF - 2.*(ML%TMP_BOIL-ONE_D%TMP(1))/DXF/K_S(1))/ML%H_R(1))
      
      IF (MFLUX > 0._EB .AND. TW>T) TW = T
      ! CYLINDRICAL and SPHERICAL scaling not implemented
      DO NS = 1,N_TRACKED_SPECIES
         ONE_D%MASSFLUX(NS)        = ONE_D%MASSFLUX(NS)        + ML%ADJUST_BURN_RATE(NS,1)*ML%NU_GAS(NS,1)*MFLUX
         ONE_D%MASSFLUX_ACTUAL(NS) = ONE_D%MASSFLUX_ACTUAL(NS) +                           ML%NU_GAS(NS,1)*MFLUX
      ENDDO
      Q_S(1) = Q_S(1) - MFLUX*ML%H_R(1)/DX_S(1)  ! no improvement (in cone test) if used updated RDX 

      DX_GRID = DT_BC*MFLUX/ML%RHO_S
      IF (POINT_SHRINK) THEN
         X_S_NEW(1:NWP) = MAX(0._EB,X_S_NEW(1:NWP)-DX_GRID)
         IF (DX_GRID > 0._EB) ONE_D%SHRINKING = .TRUE.
      ENDIF
      EXIT MATERIAL_LOOP2B   ! Can handle only one LIQUID fuel at the time
   ENDDO MATERIAL_LOOP2B
   

   ! Re-generate grid for shrinking wall

   N_LAYER_CELLS_NEW = 0
   SMALLEST_CELL_SIZE = 0._EB

   RECOMPUTE_GRID: IF (ONE_D%SHRINKING) THEN
      NWP_NEW = 0
      THICKNESS = 0._EB
      RECOMPUTE = .FALSE.
      I = 0      
      LAYER_LOOP: DO NL=1,SF%N_LAYERS
         ONE_D%LAYER_THICKNESS(NL) = X_S_NEW(I+ONE_D%N_LAYER_CELLS(NL))-X_S_NEW(I)
         ! Remove very thin layers
         IF (ONE_D%LAYER_THICKNESS(NL) < SF%MINIMUM_LAYER_THICKNESS) THEN 
            X_S_NEW(I+ONE_D%N_LAYER_CELLS(NL):NWP) = X_S_NEW(I+ONE_D%N_LAYER_CELLS(NL):NWP)-ONE_D%LAYER_THICKNESS(NL)
            ONE_D%LAYER_THICKNESS(NL) = 0._EB
            N_LAYER_CELLS_NEW(NL)  = 0
         ELSE
            CALL GET_N_LAYER_CELLS(SF%MIN_DIFFUSIVITY(NL),ONE_D%LAYER_THICKNESS(NL), &
               SF%STRETCH_FACTOR(NL),SF%CELL_SIZE_FACTOR,N_LAYER_CELLS_NEW(NL),SMALLEST_CELL_SIZE(NL))
            NWP_NEW = NWP_NEW + N_LAYER_CELLS_NEW(NL)
         ENDIF
         IF ( N_LAYER_CELLS_NEW(NL) /= ONE_D%N_LAYER_CELLS(NL)) RECOMPUTE = .TRUE.
         THICKNESS = THICKNESS + ONE_D%LAYER_THICKNESS(NL)
         I = I + ONE_D%N_LAYER_CELLS(NL)
      ENDDO LAYER_LOOP      

      DO I = 1,NWP
         IF ( (X_S_NEW(I)-X_S_NEW(I-1)) < SF%REGRID_FACTOR*SMALLEST_CELL_SIZE(LAYER_INDEX(I))) RECOMPUTE = .TRUE.
      ENDDO

      ! Shrinking wall has gone to zero thickness.

      IF (THICKNESS <=ZERO_P) THEN
         ONE_D%TMP(0:NWP+1)    = MAX(TMPMIN,TMP_BACK)
         TMP_F            = MIN(TMPMAX,MAX(TMPMIN,TMP_BACK))
         TMP_B            = MIN(TMPMAX,MAX(TMPMIN,TMP_BACK))
         ONE_D%QCONF            = 0._EB
         ONE_D%MASSFLUX(0:N_TRACKED_SPECIES)  = 0._EB
         ONE_D%MASSFLUX_ACTUAL(0:N_TRACKED_SPECIES) = 0._EB
         ONE_D%N_LAYER_CELLS(1:SF%N_LAYERS)     = 0
         ONE_D%BURNAWAY          = .TRUE.
         IF (I_OBST > 0) THEN
            IF (OBSTRUCTION(I_OBST)%CONSUMABLE) OBSTRUCTION(I_OBST)%MASS = -1.
         ENDIF
         RETURN
      ENDIF

      ! Set up new node points following shrinkage

      ONE_D%X(0:NWP) = X_S_NEW(0:NWP)

      X_S_NEW = 0._EB
      IF (RECOMPUTE) THEN
         CALL GET_WALL_NODE_COORDINATES(NWP_NEW,SF%N_LAYERS,N_LAYER_CELLS_NEW, &
            SMALLEST_CELL_SIZE(1:SF%N_LAYERS),SF%STRETCH_FACTOR(1:SF%N_LAYERS),X_S_NEW(0:NWP_NEW))
         CALL GET_WALL_NODE_WEIGHTS(NWP_NEW,SF%N_LAYERS,N_LAYER_CELLS_NEW,ONE_D%LAYER_THICKNESS,SF%GEOMETRY, &
            X_S_NEW(0:NWP_NEW),SF%LAYER_DIVIDE,DX_S(1:NWP_NEW),RDX_S(0:NWP_NEW+1),RDXN_S(0:NWP_NEW),&
            DX_WGT_S(0:NWP_NEW),DXF,DXB,LAYER_INDEX(0:NWP_NEW+1),MF_FRAC(1:NWP_NEW))           
         ! Interpolate densities and temperature from old grid to new grid
         ALLOCATE(INT_WGT(NWP_NEW,NWP),STAT=IZERO)
         CALL GET_INTERPOLATION_WEIGHTS(SF%N_LAYERS,NWP,NWP_NEW,ONE_D%N_LAYER_CELLS,N_LAYER_CELLS_NEW, &
                                    ONE_D%X(0:NWP),X_S_NEW(0:NWP_NEW),INT_WGT)
         CALL INTERPOLATE_WALL_ARRAY(NWP,NWP_NEW,INT_WGT,ONE_D%TMP(1:NWP))
         ONE_D%TMP(NWP_NEW+1) = ONE_D%TMP(NWP+1)
         CALL INTERPOLATE_WALL_ARRAY(NWP,NWP_NEW,INT_WGT,Q_S(1:NWP))
         DO N=1,SF%N_MATL
            ML  => MATERIAL(SF%MATL_INDEX(N))
            CALL INTERPOLATE_WALL_ARRAY(NWP,NWP_NEW,INT_WGT,ONE_D%RHO(1:NWP,N))
         ENDDO
         DEALLOCATE(INT_WGT)
         ONE_D%N_LAYER_CELLS(1:SF%N_LAYERS) = N_LAYER_CELLS_NEW(1:SF%N_LAYERS)
         NWP = NWP_NEW
         ONE_D%X(0:NWP) = X_S_NEW(0:NWP)      ! Note: X(NWP+1...) are not set to zero.
      ELSE      
         CALL GET_WALL_NODE_WEIGHTS(NWP,SF%N_LAYERS,N_LAYER_CELLS_NEW,ONE_D%LAYER_THICKNESS(1:SF%N_LAYERS),SF%GEOMETRY, &
            ONE_D%X(0:NWP),SF%LAYER_DIVIDE,DX_S(1:NWP),RDX_S(0:NWP+1),RDXN_S(0:NWP),DX_WGT_S(0:NWP),DXF,DXB, &
            LAYER_INDEX(0:NWP+1),MF_FRAC(1:NWP))
      ENDIF
      
   ENDIF RECOMPUTE_GRID

ELSEIF (SF%PYROLYSIS_MODEL==PYROLYSIS_SPECIFIED) THEN PYROLYSIS_MATERIAL_IF

   ! Take off energy corresponding to specified burning rate

   Q_S(1) = Q_S(1) - ONE_D%MASSFLUX(REACTION(1)%FUEL_SMIX_INDEX)*SF%H_V/DX_S(1)

ENDIF PYROLYSIS_MATERIAL_IF

! Calculate thermal properties 

K_S     = 0._EB
RHO_S   = 0._EB
RHOCBAR = 0._EB
ONE_D%EMISSIVITY = 0._EB
E_FOUND = .FALSE.

POINT_LOOP3: DO I=1,NWP
   VOLSUM = 0._EB
   MATERIAL_LOOP3: DO N=1,SF%N_MATL
      IF (ONE_D%RHO(I,N)<=ZERO_P) CYCLE MATERIAL_LOOP3
      ML  => MATERIAL(SF%MATL_INDEX(N))
      VOLSUM = VOLSUM + ONE_D%RHO(I,N)/ML%RHO_S
      IF (ML%K_S>0._EB) THEN  
         K_S(I) = K_S(I) + ONE_D%RHO(I,N)*ML%K_S/ML%RHO_S
      ELSE
         NR     = -NINT(ML%K_S)
         K_S(I) = K_S(I) + ONE_D%RHO(I,N)*EVALUATE_RAMP(ONE_D%TMP(I),0._EB,NR)/ML%RHO_S
      ENDIF

      IF (ML%C_S>0._EB) THEN
         RHOCBAR(I) = RHOCBAR(I) + ONE_D%RHO(I,N)*ML%C_S
      ELSE
         NR     = -NINT(ML%C_S)
         RHOCBAR(I) = RHOCBAR(I) + ONE_D%RHO(I,N)*EVALUATE_RAMP(ONE_D%TMP(I),0._EB,NR)*C_S_ADJUST_UNITS
      ENDIF
      IF (.NOT.E_FOUND) ONE_D%EMISSIVITY = ONE_D%EMISSIVITY + ONE_D%RHO(I,N)*ML%EMISSIVITY/ML%RHO_S
      RHO_S(I)   = RHO_S(I) + ONE_D%RHO(I,N)
      
   ENDDO MATERIAL_LOOP3
   
   IF (VOLSUM > 0._EB) THEN
      K_S(I) = K_S(I)/VOLSUM
      IF (.NOT.E_FOUND) ONE_D%EMISSIVITY = ONE_D%EMISSIVITY/VOLSUM
   ENDIF
   IF (ONE_D%EMISSIVITY>0._EB) E_FOUND = .TRUE.

   IF (K_S(I)<=ZERO_P)      K_S(I)      = 10000._EB
   IF (RHOCBAR(I)<=ZERO_P)  RHOCBAR(I)  = 0.001_EB

ENDDO POINT_LOOP3

! Calculate average K_S between at grid cell boundaries. Store result in K_S

K_S(0)     = K_S(1)  
K_S(NWP+1) = K_S(NWP)
DO I=1,NWP-1 
   K_S(I)  = 1.0_EB / ( DX_WGT_S(I)/K_S(I) + (1.-DX_WGT_S(I))/K_S(I+1) )
ENDDO

! Calculate internal radiation
   
IF (SF%INTERNAL_RADIATION) THEN
   KAPPA_S = 0._EB
   DO I=1,NWP
      VOLSUM = 0._EB
      DO N=1,SF%N_MATL
         IF (ONE_D%RHO(I,N)<=ZERO_P) CYCLE
         ML  => MATERIAL(SF%MATL_INDEX(N))
         VOLSUM = VOLSUM + ONE_D%RHO(I,N)/ML%RHO_S
         KAPPA_S(I) = KAPPA_S(I) + ONE_D%RHO(I,N)*ML%KAPPA_S/ML%RHO_S
      ENDDO
      IF (VOLSUM>0._EB) KAPPA_S(I) = 2.*KAPPA_S(I)/(RDX_S(I)*VOLSUM)    ! kappa = 2*dx*kappa or 2*r*dr*kappa
   ENDDO
   DO I=0,NWP
      IF (SF%GEOMETRY==SURF_CYLINDRICAL) THEN
         R_S(I) = SF%THICKNESS-SF%X_S(I)
      ELSE
         R_S(I) = 1._EB
      ENDIF
   ENDDO
   ! solution inwards
   RFLUX_UP = ONE_D%QRADIN + (1.-ONE_D%EMISSIVITY)*ONE_D%QRADOUT/(ONE_D%EMISSIVITY+1.0E-10_EB)
   DO I=1,NWP
      RFLUX_DOWN =  ( R_S(I-1)*RFLUX_UP + KAPPA_S(I)*SIGMA*ONE_D%TMP(I)**4 ) / (R_S(I) + KAPPA_S(I))
      Q_S(I) = Q_S(I) + (R_S(I-1)*RFLUX_UP - R_S(I)*RFLUX_DOWN)*RDX_S(I)
      RFLUX_UP = RFLUX_DOWN
   ENDDO
   IF (SF%BACKING==EXPOSED) THEN
      IF (WALL(IWB)%BOUNDARY_TYPE==SOLID_BOUNDARY) WALL(IWB)%ONE_D%QRADOUT = E_WALLB*RFLUX_UP
   ENDIF
   ! solution outwards
   RFLUX_UP = QRADINB + (1.-E_WALLB)*RFLUX_UP
   DO I=NWP,1,-1
      RFLUX_DOWN =  ( R_S(I)*RFLUX_UP + KAPPA_S(I)*SIGMA*ONE_D%TMP(I)**4 ) / (R_S(I-1) + KAPPA_S(I))
      Q_S(I) = Q_S(I) + (R_S(I)*RFLUX_UP - R_S(I-1)*RFLUX_DOWN)*RDX_S(I)
      RFLUX_UP = RFLUX_DOWN
   ENDDO
   ONE_D%QRADOUT = ONE_D%EMISSIVITY*RFLUX_DOWN
ENDIF

! Update the 1-D heat transfer equation 

DT2_BC = DT_BC
STEPCOUNT = 1
ALLOCATE(TMP_W_NEW(0:NWP+1),STAT=IZERO)
TMP_W_NEW = ONE_D%TMP(0:NWP+1)
WALL_ITERATE: DO 
   ITERATE=.FALSE.
   SUB_TIME: DO N=1,STEPCOUNT
      DXKF   = K_S(0)/DXF
      DXKB   = K_S(NWP)/DXB

      DO I=1,NWP
         BBS(I) = -0.5_EB*DT2_BC*K_S(I-1)*RDXN_S(I-1)*RDX_S(I)/RHOCBAR(I) ! DT_BC->DT2_BC
         AAS(I) = -0.5_EB*DT2_BC*K_S(I)  *RDXN_S(I)  *RDX_S(I)/RHOCBAR(I)
      ENDDO
      DDS(1:NWP) = 1._EB    - AAS(1:NWP) - BBS(1:NWP)
      DO I=1,NWP
         CCS(I) = TMP_W_NEW(I) - AAS(I)*(TMP_W_NEW(I+1)-TMP_W_NEW(I)) + BBS(I)*(TMP_W_NEW(I)-TMP_W_NEW(I-1)) &
                  + DT2_BC*Q_S(I)/RHOCBAR(I)
      ENDDO
      IF (.NOT. RADIATION .OR. SF%INTERNAL_RADIATION) THEN
         RFACF = 0.25_EB*ONE_D%HEAT_TRANS_COEF
         RFACB = 0.25_EB*HTCB
      ELSE
         RFACF = 0.25_EB*ONE_D%HEAT_TRANS_COEF+2._EB*ONE_D%EMISSIVITY*SIGMA*TMP_F**3
         RFACB = 0.25_EB*HTCB               +2._EB*E_WALLB*   SIGMA*TMP_B**3
      ENDIF
      RFACF2 = (DXKF-RFACF)/(DXKF+RFACF)
      RFACB2 = (DXKB-RFACB)/(DXKB+RFACB)
      IF (.NOT. RADIATION .OR. SF%INTERNAL_RADIATION) THEN
         QDXKF = (ONE_D%HEAT_TRANS_COEF*(TMP_G    - 0.5_EB*TMP_F) + Q_WATER_F)/(DXKF+RFACF)
         QDXKB = (HTCB*               (TMP_BACK - 0.5_EB*TMP_B) + Q_WATER_B)/(DXKB+RFACB)
      ELSE
         QDXKF = (ONE_D%HEAT_TRANS_COEF*(TMP_G   - 0.5_EB*TMP_F) + ONE_D%QRADIN + 3.*ONE_D%EMISSIVITY*SIGMA*TMP_F**4 + Q_WATER_F) &
               /(DXKF+RFACF)
         QDXKB = (HTCB*               (TMP_BACK - 0.5_EB*TMP_B) + QRADINB   + 3.*E_WALLB   *SIGMA*TMP_B**4 + Q_WATER_B) &
               /(DXKB+RFACB)
      ENDIF
      CCS(1)   = CCS(1)   - BBS(1)  *QDXKF
      CCS(NWP) = CCS(NWP) - AAS(NWP)*QDXKB
      DDT(1:NWP) = DDS(1:NWP)
      DDT(1)   = DDT(1)   + BBS(1)  *RFACF2
      DDT(NWP) = DDT(NWP) + AAS(NWP)*RFACB2
      TRIDIAGONAL_SOLVER_1: DO I=2,NWP
         RR     = BBS(I)/DDT(I-1)
         DDT(I) = DDT(I) - RR*AAS(I-1)
         CCS(I) = CCS(I) - RR*CCS(I-1)
      ENDDO TRIDIAGONAL_SOLVER_1
      CCS(NWP)  = CCS(NWP)/DDT(NWP)
      TRIDIAGONAL_SOLVER_2: DO I=NWP-1,1,-1
         CCS(I) = (CCS(I) - AAS(I)*CCS(I+1))/DDT(I)
      ENDDO TRIDIAGONAL_SOLVER_2
      TMP_W_NEW(1:NWP) = MAX(TMPMIN,CCS(1:NWP))
      TMP_W_NEW(0)     = MAX(TMPMIN,TMP_W_NEW(1)  *RFACF2+QDXKF)
      TMP_W_NEW(NWP+1) = MAX(TMPMIN,TMP_W_NEW(NWP)*RFACB2+QDXKB)
      IF (STEPCOUNT==1) THEN
         TOLERANCE = MAXVAL(ABS((TMP_W_NEW-ONE_D%TMP(0:NWP+1))/ONE_D%TMP(0:NWP+1)), &
            ONE_D%TMP(0:NWP+1)>0._EB) ! returns a negative number, if all TMP_S == 0.
         IF (TOLERANCE<0.0_EB) &
         TOLERANCE = MAXVAL(ABS((TMP_W_NEW-ONE_D%TMP(0:NWP+1))/TMP_W_NEW), &
            TMP_W_NEW>0._EB) 
         IF (TOLERANCE > 0.2_EB) THEN
            STEPCOUNT = MIN(200,STEPCOUNT * (INT(TOLERANCE/0.2_EB) + 1))
            ITERATE=.TRUE.
            DT2_BC=DT_BC/REAL(STEPCOUNT)
            TMP_W_NEW = ONE_D%TMP(0:NWP+1)
         ENDIF
      ENDIF
      IF (NWP == 1) THEN
         TMP_F = TMP_W_NEW(1)
         TMP_B = TMP_F
      ELSE
         TMP_F  = 0.5_EB*(TMP_W_NEW(0)+TMP_W_NEW(1))
         TMP_B  = 0.5_EB*(TMP_W_NEW(NWP)+TMP_W_NEW(NWP+1))
      ENDIF
      TMP_F  = MIN(TMPMAX,MAX(TMPMIN,TMP_F))
      TMP_B  = MIN(TMPMAX,MAX(TMPMIN,TMP_B))
   ENDDO SUB_TIME
   IF (.NOT. ITERATE) EXIT WALL_ITERATE
ENDDO WALL_ITERATE

ONE_D%TMP(0:NWP+1) = TMP_W_NEW
DEALLOCATE(TMP_W_NEW)

! If the surface temperature exceeds the ignition temperature, burn it

IF (TW > T ) THEN
   IF (TMP_F >= SF%TMP_IGN) TW = T
ENDIF

! Determine convective heat flux at the wall

ONE_D%QCONF = ONE_D%HEAT_TRANS_COEF * (TMP_G - 0.5_EB * (TMP_F + TMP_F_OLD) )

END SUBROUTINE PYROLYSIS


REAL(EB) FUNCTION HEAT_TRANSFER_COEFFICIENT(DELTA_TMP,H_FIXED,GEOMETRY,CONV_LENGTH,HT_MODEL,WALL_INDEX,PARTICLE_INDEX,&
                                            FACE_INDEX,CUTCELL_INDEX)

! Compute the convective heat transfer coefficient

USE PHYSICAL_FUNCTIONS, ONLY: GET_SPECIFIC_HEAT

REAL(EB), INTENT(IN) :: DELTA_TMP,H_FIXED,CONV_LENGTH
INTEGER, INTENT(IN), OPTIONAL :: WALL_INDEX,PARTICLE_INDEX,FACE_INDEX,CUTCELL_INDEX
INTEGER  :: IIG,JJG,KKG,IOR,GEOMETRY,HT_MODEL
REAL(EB) :: RE,U2,V2,W2,H_NATURAL,H_FORCED,NUSSELT,ZZ_GET(0:N_TRACKED_SPECIES),CP,VELCON,FRICTION_VELOCITY
REAL(EB), POINTER, DIMENSION(:,:,:) :: UU,VV,WW,RHOP
REAL(EB), POINTER, DIMENSION(:,:,:,:) :: ZZP
INTEGER, PARAMETER :: I_LOGLAW=1
REAL(EB), PARAMETER :: EPS=1.E-10_EB
TYPE(LAGRANGIAN_PARTICLE_TYPE), POINTER :: LP
TYPE(ONE_D_M_AND_E_XFER_TYPE), POINTER :: ONE_D
TYPE(WALL_TYPE), POINTER :: WC
TYPE(FACET_TYPE), POINTER :: FC

! If the user wants a specified HTC, set it and return

IF (H_FIXED >= 0._EB) THEN
   HEAT_TRANSFER_COEFFICIENT = H_FIXED
   RETURN
ENDIF

! Determine if this is a particle or wall cell

IF (PRESENT(PARTICLE_INDEX)) THEN
   LP    => LAGRANGIAN_PARTICLE(PARTICLE_INDEX)
   ONE_D => LP%ONE_D
   IIG = ONE_D%IIG
   JJG = ONE_D%JJG
   KKG = ONE_D%KKG
   IOR = ONE_D%IOR
ELSEIF (PRESENT(WALL_INDEX)) THEN
   IF (WALL_INDEX<=0) THEN
      HEAT_TRANSFER_COEFFICIENT = HCV*ABS(DELTA_TMP)**ONTH
      RETURN
   ENDIF
   WC    => WALL(WALL_INDEX)
   ONE_D => WALL(WALL_INDEX)%ONE_D
   IIG = ONE_D%IIG
   JJG = ONE_D%JJG
   KKG = ONE_D%KKG
   IOR = ONE_D%IOR
   FRICTION_VELOCITY = WC%U_TAU
ELSEIF (PRESENT(FACE_INDEX).AND.PRESENT(CUTCELL_INDEX)) THEN
   FC => FACET(FACE_INDEX)
   IIG = I_CUTCELL(CUTCELL_INDEX)
   JJG = J_CUTCELL(CUTCELL_INDEX)
   KKG = K_CUTCELL(CUTCELL_INDEX)
   IOR = 0
   FRICTION_VELOCITY = FC%U_TAU
ELSE
   HEAT_TRANSFER_COEFFICIENT = 0._EB
   RETURN
ENDIF

! If this is a DNS calculation at a solid wall, set HTC and return.

IF (DNS .AND. PRESENT(WALL_INDEX)) THEN
   HEAT_TRANSFER_COEFFICIENT = 2._EB*WC%KW*WC%RDN
   RETURN
ENDIF
IF (DNS .AND. PRESENT(FACE_INDEX)) THEN
   HEAT_TRANSFER_COEFFICIENT = 2._EB*FC%KW*FC%RDN
   RETURN
ENDIF

! Get velocities, etc.

IF (PREDICTOR) THEN
   UU => U
   VV => V
   WW => W
   RHOP => RHOS
   ZZP => ZZS
ELSE
   UU => US
   VV => VS
   WW => WS
   RHOP => RHO
   ZZP => ZZ
ENDIF

IF (PRESENT(PARTICLE_INDEX)) THEN
   U2 = 0.25_EB*(UU(IIG,JJG,KKG)+UU(IIG-1,JJG,KKG)-2._EB*LP%U)**2
   V2 = 0.25_EB*(VV(IIG,JJG,KKG)+VV(IIG,JJG-1,KKG)-2._EB*LP%V)**2
   W2 = 0.25_EB*(WW(IIG,JJG,KKG)+WW(IIG,JJG,KKG-1)-2._EB*LP%W)**2
   VELCON = SQRT(U2+V2+W2)
ELSEIF (PRESENT(WALL_INDEX)) THEN  
   U2 = 0.25_EB*(UU(IIG,JJG,KKG)+UU(IIG-1,JJG,KKG))**2
   V2 = 0.25_EB*(VV(IIG,JJG,KKG)+VV(IIG,JJG-1,KKG))**2
   W2 = 0.25_EB*(WW(IIG,JJG,KKG)+WW(IIG,JJG,KKG-1))**2
   VELCON = SQRT(U2+V2+W2)
ELSEIF (PRESENT(FACE_INDEX)) THEN
   VELCON = SQRT(2._EB*KRES(IIG,JJG,KKG))
ENDIF

! Calculate the HTC for natural convection

SELECT CASE(ABS(IOR))
   CASE(0:2)
      H_NATURAL = HCV*ABS(DELTA_TMP)**ONTH
   CASE(3)
      H_NATURAL = HCH*ABS(DELTA_TMP)**ONTH
END SELECT

! Calculate the HTC for forced convection

HTC_MODEL_SELECT: SELECT CASE(HT_MODEL)
   CASE(I_LOGLAW)
      IF (N_TRACKED_SPECIES>0) ZZ_GET(1:N_TRACKED_SPECIES) = ZZP(IIG,JJG,KKG,1:N_TRACKED_SPECIES)
      CALL GET_SPECIFIC_HEAT(ZZ_GET,CP,TMP(IIG,JJG,KKG))
      H_FORCED = RHOP(IIG,JJG,KKG)*CP*RPR*FRICTION_VELOCITY**2/(VELCON+EPS)

   CASE DEFAULT
      RE = RHOP(IIG,JJG,KKG)*VELCON*CONV_LENGTH/MU_AIR_0
      SELECT CASE(GEOMETRY)
         CASE (SURF_CARTESIAN)
            NUSSELT =         C_FORCED         *RE**(0.8_EB)*PR_ONTH 
         CASE (SURF_CYLINDRICAL)
            NUSSELT =         C_FORCED_CYLINDER*RE**(0.5_EB)*PR_ONTH 
         CASE (SURF_SPHERICAL)
            NUSSELT = 2._EB + C_FORCED_SPHERE  *RE**(0.5_EB)*PR_ONTH
      END SELECT
      H_FORCED  = NUSSELT*K_AIR_0/CONV_LENGTH

END SELECT HTC_MODEL_SELECT

HEAT_TRANSFER_COEFFICIENT = MAX(H_FORCED,H_NATURAL)

END FUNCTION HEAT_TRANSFER_COEFFICIENT

 
SUBROUTINE CALC_DEPOSITION(NM)

USE PHYSICAL_FUNCTIONS, ONLY: GET_VISCOSITY,GET_CONDUCTIVITY
USE GLOBAL_CONSTANTS, ONLY: EVACUATION_ONLY,SOLID_PHASE_ONLY,SOLID_BOUNDARY,N_TRACKED_SPECIES
USE TURBULENCE, ONLY: WERNER_WENGLE_WALL_MODEL
INTEGER, INTENT(IN) :: NM
REAL(EB), PARAMETER :: CS=1.17_EB,CT=2.2_EB,CM=1.146_EB,MFP25=0.065E-6_EB,A1=1.257_EB,A2=0.4_EB,A32=1.1_EB,CHI_D=1._EB
REAL(EB), PARAMETER :: CM3=3._EB*CM,CS2=CS*2._EB,CT2=2._EB*CT
REAL(EB) :: U_THERM,U_TURB,TGAS,TWALL,MUGAS,Y_AEROSOL,RHOG,ZZ_GET(0:N_TRACKED_SPECIES),YDEP,K_AIR,TMP_FILM,KN,ALPHA,DTMPDX,&
            KN_EXP,TAU_PLUS,DN,TAU_PLUS_C,VEL_W,U2,V2,W2,U_GRAV,MASS_P
INTEGER  :: IIG,JJG,KKG,IW,IOR,N
TYPE(SPECIES_MIXTURE_TYPE), POINTER :: SM=>NULL()
TYPE(WALL_TYPE), POINTER :: WC=>NULL()

IF (PREDICTOR) RETURN
IF (EVACUATION_ONLY(NM)) RETURN
IF (SOLID_PHASE_ONLY) RETURN

CALL POINT_TO_MESH(NM)

SMIX_LOOP: DO N=1,N_TRACKED_SPECIES
  
   SM=>SPECIES_MIXTURE(N)
   IF (.NOT.SM%DEPOSITING) CYCLE SMIX_LOOP
   U_THERM=0._EB 
   U_TURB=0._EB 
   U_GRAV=0._EB
   IF (GRAVITATIONAL_DEPOSITION) MASS_P = 0.125_EB*FOTHPI*SM%MEAN_DIAMETER**3*SM%DENSITY_SOLID
   IF (TURBULENT_DEPOSITION) TAU_PLUS_C = SM%DENSITY_SOLID*SM%MEAN_DIAMETER**2/18._EB
   WALL_CELL_LOOP: DO IW=1,N_EXTERNAL_WALL_CELLS+N_INTERNAL_WALL_CELLS
      WC=>WALL(IW)
      IF (WC%BOUNDARY_TYPE/=SOLID_BOUNDARY .OR. WC%ONE_D%UW < 0._EB) CYCLE WALL_CELL_LOOP
      IOR = WC%ONE_D%IOR
      IIG = WC%ONE_D%IIG
      JJG = WC%ONE_D%JJG
      KKG = WC%ONE_D%KKG
      ZZ_GET(1:N_TRACKED_SPECIES) = MAX(0._EB,ZZ(IIG,JJG,KKG,1:N_TRACKED_SPECIES))      
      IF (ZZ_GET(N) < 1.E-14_EB) CYCLE WALL_CELL_LOOP
      ZZ_GET(0) = 1 - SUM(ZZ_GET(1:N_TRACKED_SPECIES))
      DN = 1/WC%RDN
      TGAS = TMP(IIG,JJG,KKG)
      KN = 2._EB*MFP25/SM%MEAN_DIAMETER*TGAS/298.15_EB
      KN_EXP = KN*(A1+A2*EXP(-A32/KN))
      TWALL = WC%ONE_D%TMP_F
      TMP_FILM = 0.5_EB*(TGAS+TWALL)
      RHOG=RHO(IIG,JJG,KKG)
      CALL GET_VISCOSITY(ZZ_GET,MUGAS,TMP_FILM)
      CALL GET_CONDUCTIVITY(ZZ_GET,K_AIR,TMP_FILM)
      ALPHA = K_AIR/SM%CONDUCTIVITY_SOLID
      IF (LES) THEN
         DTMPDX = WC%ONE_D%HEAT_TRANS_COEF*(TGAS-TWALL)/K_AIR
      ELSE
         DTMPDX = (TGAS-TWALL)*WC%RDN         
      ENDIF
      IF (THERMOPHORETIC_DEPOSITION) U_THERM = CS2*(ALPHA+CT*KN)*(1._EB+KN_EXP)/((1._EB+CM3*KN)*(1+2*ALPHA+CT2*KN)) * &
                                               MUGAS/(TGAS*RHOG)*DTMPDX
      IF (GRAVITATIONAL_DEPOSITION) THEN
         U_GRAV = -GVEC(ABS(IOR))*SIGN(1,IOR)*MASS_P*(1._EB+1.25_EB*KN+0.41_EB*KN*EXP(-0.88_EB/KN))/ &
                                                     (3._EB*CHI_D*MUGAS*SM%MEAN_DIAMETER)
      ENDIF
      IF (TURBULENT_DEPOSITION) THEN
         U2 = 0.25_EB*(US(IIG,JJG,KKG)+US(IIG-1,JJG,KKG))**2
         V2 = 0.25_EB*(VS(IIG,JJG,KKG)+VS(IIG,JJG-1,KKG))**2
         W2 = 0.25_EB*(WS(IIG,JJG,KKG)+WS(IIG,JJG,KKG-1))**2
         SELECT CASE(ABS(IOR))
            CASE(1)
               U2 = 0._EB
            CASE(2)
               V2 = 0._EB
            CASE(3)
               W2 = 0._EB
         END SELECT 
         VEL_W = SQRT(U2+V2+W2)   
         TAU_PLUS = TAU_PLUS_C/MUGAS**2*WC%U_TAU**2*RHOG
         IF (TAU_PLUS < 0.2_EB) THEN !Diffusion regime            
            U_TURB = WC%U_TAU * 0.086_EB*(MUGAS/RHOG/D_Z( MIN(5000,INT(TGAS)),0))**(-0.7_EB)
         ELSEIF (TAU_PLUS >= 0.2_EB .AND. TAU_PLUS < 22.0398_EB) THEN !Diffusion-impaction regime
            U_TURB = WC%U_TAU * 3.5E-4_EB * TAU_PLUS**2
         ELSE ! Inertia regime
            U_TURB = WC%U_TAU * 0.17_EB
         ENDIF
      ENDIF
      IF (U_THERM+U_TURB+U_GRAV < 0._EB) CYCLE WALL_CELL_LOOP   
      ZZ_GET = ZZ_GET * RHOG  
      Y_AEROSOL = ZZ_GET(N)   
      YDEP =Y_AEROSOL*MIN(1._EB,(U_THERM+U_TURB+U_GRAV)*DT*WC%RDN)
      ZZ_GET(N) = Y_AEROSOL - YDEP      
      IF (SM%AWM_INDEX > 0) WC%AWM_AEROSOL(SM%AWM_INDEX)=WC%AWM_AEROSOL(SM%AWM_INDEX)+YDEP/WC%RDN
      RHO(IIG,JJG,KKG) = RHOG - YDEP
      ZZ(IIG,JJG,KKG,1:N_TRACKED_SPECIES) = ZZ_GET(1:N_TRACKED_SPECIES) / RHO(IIG,JJG,KKG)
   ENDDO WALL_CELL_LOOP

ENDDO SMIX_LOOP

END SUBROUTINE CALC_DEPOSITION


SUBROUTINE GET_REV_wall(MODULE_REV,MODULE_DATE)
INTEGER,INTENT(INOUT) :: MODULE_REV
CHARACTER(255),INTENT(INOUT) :: MODULE_DATE

WRITE(MODULE_DATE,'(A)') wallrev(INDEX(wallrev,':')+2:LEN_TRIM(wallrev)-2)
READ (MODULE_DATE,'(I5)') MODULE_REV
WRITE(MODULE_DATE,'(A)') walldate

END SUBROUTINE GET_REV_wall


END MODULE WALL_ROUTINES
