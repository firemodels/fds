MODULE INIT      
 
! Allocate numerous arrays and perform miscellaneous initializations

USE PRECISION_PARAMETERS
USE MESH_VARIABLES
USE MESH_POINTERS
USE GLOBAL_CONSTANTS
USE TRAN
USE MEMORY_FUNCTIONS, ONLY : CHKMEMERR 
USE COMP_FUNCTIONS, ONLY : SHUTDOWN
USE DEVICE_VARIABLES
IMPLICIT NONE

PRIVATE
INTEGER IZERO
CHARACTER(255), PARAMETER :: initid='$Id$'
CHARACTER(255), PARAMETER :: initrev='$Revision$'
CHARACTER(255), PARAMETER :: initdate='$Date$'

CHARACTER(100) MESSAGE
PUBLIC INITIALIZE_MESH_VARIABLES,INITIALIZE_GLOBAL_VARIABLES, OPEN_AND_CLOSE, GET_REV_init

TYPE (MESH_TYPE), POINTER :: M
TYPE (OBSTRUCTION_TYPE), POINTER :: OB
TYPE (SURFACE_TYPE), POINTER :: SF
TYPE (MATERIAL_TYPE), POINTER :: ML
 
 
CONTAINS
 
 
SUBROUTINE INITIALIZE_MESH_VARIABLES(NM)
USE RADCONS, ONLY: UIIDIM,NSB,NRA
USE CONTROL_VARIABLES
INTEGER :: N,I,J,K,II,JJ,KK,IPTS,JPTS,KPTS,N_EDGES_DIM,IW,IC,IBC,IOR,IOPZ
INTEGER, INTENT(IN) :: NM
REAL(EB) :: MU_N,CELL_SIZE
INTEGER, POINTER :: IBP1, JBP1, KBP1,IBAR, JBAR, KBAR, NDWC, N_EDGES, NWC
REAL(EB),POINTER :: XS,XF,YS,YF,ZS,ZF
TYPE (INITIALIZATION_TYPE), POINTER :: IN
TYPE (P_ZONE_TYPE), POINTER :: PZ
 
M => MESHES(NM)
IBP1 =>M%IBP1
JBP1 =>M%JBP1
KBP1 =>M%KBP1
IBAR =>M%IBAR
JBAR =>M%JBAR
KBAR =>M%KBAR
NDWC =>M%NDWC
NWC =>M%NWC
N_EDGES=>M%N_EDGES
XS=>M%XS 
YS=>M%YS 
ZS=>M%ZS
XF=>M%XF 
YF=>M%YF 
ZF=>M%ZF
ALLOCATE(  M%RHO(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','RHO',IZERO)
ALLOCATE( M%RHOS(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','RHOS',IZERO)
ALLOCATE(  M%TMP(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','TMP',IZERO)
ALLOCATE( M%FRHO(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','FRHO',IZERO)
ALLOCATE( M%U(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','U',IZERO)
ALLOCATE( M%V(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','V',IZERO)
ALLOCATE( M%W(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','W',IZERO)
ALLOCATE(M%US(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','US',IZERO)
ALLOCATE(M%VS(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','VS',IZERO)
ALLOCATE(M%WS(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WS',IZERO)
ALLOCATE(M%FVX(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','FVX',IZERO)
ALLOCATE(M%FVY(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','FVY',IZERO)
ALLOCATE(M%FVZ(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','FVZ',IZERO)
ALLOCATE(   M%H(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','H',IZERO)
ALLOCATE(   M%HP(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','HP',IZERO)
ALLOCATE(M%DDDT(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','DDDT',IZERO)
ALLOCATE(   M%D(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','D',IZERO)
ALLOCATE(  M%DS(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','DS',IZERO)
ALLOCATE( M%MU(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','MU',IZERO)
ALLOCATE(   M%Q(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','Q',IZERO)

! Background pressure, temperature, density as a function of height (Z coordinate)

ALLOCATE(  M%PBAR(0:KBP1,0:N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','PBAR',IZERO)
ALLOCATE(  M%PBAR_S(0:KBP1,0:N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','PBAR_S',IZERO)
ALLOCATE(  M%R_PBAR(0:KBP1,0:N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','R_PBAR',IZERO)
ALLOCATE(  M%D_PBAR_DT(N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','D_PBAR_DT',IZERO)
ALLOCATE(  M%D_PBAR_S_DT(N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','D_PBAR_S_DT',IZERO)
ALLOCATE(M%P_0(0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','P_0',IZERO)
ALLOCATE(M%TMP_0(0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','TMP_0',IZERO)
ALLOCATE(M%RHO_0(0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','RHO_0',IZERO)

! Leaks

ALLOCATE(  M%LEAK_AREA(0:N_ZONE,0:N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','LEAK_AREA',IZERO)
M%LEAK_AREA = 0._EB
ALLOCATE(  M%U_LEAK(0:N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','U_LEAK',IZERO)
M%U_LEAK = 0._EB
ALLOCATE(  M%FDS_LEAK_AREA(0:N_ZONE,0:N_ZONE),STAT=IZERO)
CALL ChkMemErr('INIT','FDS_LEAK_AREA',IZERO)
M%FDS_LEAK_AREA = 0._EB
! Allocate species arrays
 
IF (N_SPECIES>0) THEN
   ALLOCATE( M%YY(0:IBP1,0:JBP1,0:KBP1,N_SPECIES),STAT=IZERO)
   CALL ChkMemErr('INIT','YY',IZERO)
   M%YY = 0._EB
   ALLOCATE(M%YYS(0:IBP1,0:JBP1,0:KBP1,N_SPECIES),STAT=IZERO)
   CALL ChkMemErr('INIT','YYS',IZERO)
   M%YYS = 0._EB   
   ALLOCATE(M%DEL_RHO_D_DEL_Y(0:IBP1,0:JBP1,0:KBP1,N_SPECIES),STAT=IZERO)
   CALL ChkMemErr('INIT','DEL_RHO_D_DEL_Y',IZERO)
   M%DEL_RHO_D_DEL_Y = 0._EB   
   ALLOCATE(M%RSUM(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','RSUM',IZERO)
   M%RSUM = RSUM0
   ALLOCATE(M%Z_SUM(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','Z_SUM',IZERO)
   M%Z_SUM = 0._EB
   ALLOCATE(M%Y_SUM(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','Y_SUM',IZERO)
   M%Y_SUM = 0._EB   
ENDIF

! Allocate water mass arrays if sprinklers are present
 
IF (DROPLET_FILE) PARTICLE_TAG = NM

IF (N_EVAP_INDICIES>0) THEN
   ALLOCATE(M%AVG_DROP_DEN(0:IBP1,0:JBP1,0:KBP1,N_EVAP_INDICIES),STAT=IZERO)
   CALL ChkMemErr('INIT','AVG_DROP_DEN',IZERO) 
   M%AVG_DROP_DEN=0._EB
   ALLOCATE(M%AVG_DROP_TMP(0:IBP1,0:JBP1,0:KBP1,N_EVAP_INDICIES),STAT=IZERO)
   CALL ChkMemErr('INIT','AVG_DROP_TMP',IZERO) 
   M%AVG_DROP_TMP=TMPM
   ALLOCATE(M%AVG_DROP_RAD(0:IBP1,0:JBP1,0:KBP1,N_EVAP_INDICIES),STAT=IZERO)
   CALL ChkMemErr('INIT','AVG_DROP_RAD',IZERO) 
   M%AVG_DROP_RAD=0._EB
   ALLOCATE(M%QR_W(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','QR_W',IZERO) 
   M%QR_W = 0._EB
   ALLOCATE(M%D_VAP(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','D_VAP',IZERO) 
   M%D_VAP = 0._EB
ENDIF
 
! If radiation absorption desired allocate arrays
 
ALLOCATE(M%QR(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','QR',IZERO)
M%QR = 0._EB
ALLOCATE(M%KAPPA(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','KAPPA',IZERO) 
M%KAPPA = 0._EB
ALLOCATE(M%UII(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','UII',IZERO)
M%UII = 0._EB

! Work arrays
ALLOCATE(M%WORK1(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK1',IZERO)
ALLOCATE(M%WORK2(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK2',IZERO)
ALLOCATE(M%WORK3(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK3',IZERO)
ALLOCATE(M%WORK4(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK4',IZERO)
ALLOCATE(M%WORK5(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK5',IZERO)
ALLOCATE(M%WORK6(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK6',IZERO)
ALLOCATE(M%WORK7(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','WORK7',IZERO)

ALLOCATE(M%LOGICAL_WORK(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','LOGICAL_WORK',IZERO)
 
! Boundary file patch counter
 
ALLOCATE(M%INC(-3:3,0:M%N_OBST),STAT=IZERO)
CALL ChkMemErr('INIT','INC',IZERO)

! Initialize background pressure, temperature and density

M%D_PBAR_DT   = 0._EB
M%D_PBAR_S_DT = 0._EB

IF (STRATIFICATION) THEN
   DO K=0,M%KBP1
      M%TMP_0(K) = TMPA + LAPSE_RATE*M%ZC(K)
      IF (LAPSE_RATE /= 0._EB) THEN
         M%P_0(K) = P_INF*(M%TMP_0(K)/TMPA)**(GVEC(3)/RSUM0/LAPSE_RATE)
      ELSE
         M%P_0(K) = P_INF*EXP(GVEC(3)*M%ZC(K)/(RSUM0*TMPA))
      ENDIF
   ENDDO
ELSE
   M%TMP_0(:) = TMPA
   M%P_0(:)   = P_INF
ENDIF
DO K=0,M%KBP1
   M%PBAR(K,:)   = M%P_0(K)
   M%PBAR_S(K,:) = M%P_0(K)
   M%RHO_0(K)    = M%P_0(K)/(M%TMP_0(K)*RSUM0)
ENDDO

! Initialize various time step variables
 
M%DTOLD   = M%DT
M%DTNEXT  = M%DT
M%DTINT   = M%DT

! Initialize major arrays

DO K=0,M%KBP1
   M%RHO(:,:,K) = M%RHO_0(K)
   M%TMP(:,:,K) = M%TMP_0(K)
ENDDO
M%RHOS    = M%RHO
M%RHO_AVG = RHOA
M%FRHO    = 0._EB
M%U       = U0
M%V       = V0
M%W       = W0
M%US      = U0
M%VS      = V0
M%WS      = W0
IF (NOISE) CALL INITIAL_NOISE
M%FVX   = 0._EB
M%FVY   = 0._EB
M%FVZ   = 0._EB
M%H     = H0
M%DDDT  = 0._EB
M%D     = 0._EB
M%DS    = 0._EB
M%Q     = 0._EB
IF (N_SPECIES > 0) M%DEL_RHO_D_DEL_Y = 0._EB
 
! Upper bounds on local HRR per unit volume
 
IF (TWO_D) THEN
   CELL_SIZE = SQRT(M%DXMIN*M%DZMIN)
ELSE
   CELL_SIZE = (M%DXMIN*M%DYMIN*M%DZMIN)**ONTH
ENDIF
M%Q_UPPER = HRRPUA_SHEET*1000._EB*CELL_SIZE**(DIMENSION_SHEET-3._EB)

! Viscosity
 
MU_N = SPECIES(0)%MU(NINT(0.1_EB*TMPA))
M%MU = MU_N
IF (DNS .AND. ISOTHERMAL) THEN
   ALLOCATE(M%RREDX(M%IBAR),STAT=IZERO)
   CALL ChkMemErr('READ','RREDX',IZERO)
   ALLOCATE(M%RREDY(M%JBAR),STAT=IZERO)
   CALL ChkMemErr('READ','RREDY',IZERO)
   ALLOCATE(M%RREDZ(M%KBAR),STAT=IZERO)
   CALL ChkMemErr('READ','RREDZ',IZERO)
   DO I=1,M%IBAR
      M%RREDX(I) = (MU_N/RHOA)*M%RDX(I)
   ENDDO
   DO J=1,M%JBAR
      M%RREDY(J) = (MU_N/RHOA)*M%RDY(J)
   ENDDO
   DO K=1,M%KBAR
      M%RREDZ(K) = (MU_N/RHOA)*M%RDZ(K)
   ENDDO
ENDIF
 
! Initialize mass fraction arrays

IF (N_SPECIES > 0) THEN
   M%RSUM = RSUM0
   DO N=1,N_SPECIES
      M%YY(:,:,:,N)  = SPECIES(N)%YY0
      M%YYS(:,:,:,N) = SPECIES(N)%YY0
      IF (SPECIES(N)%MODE==MIXTURE_FRACTION_SPECIES) M%Z_SUM = M%Z_SUM + SPECIES(N)%YY0   
      IF (SPECIES(N)%MODE==GAS_SPECIES) THEN 
         M%Y_SUM = M%Y_SUM + SPECIES(N)%YY0
         M%RSUM  = M%RSUM + (SPECIES(N)%RCON - SPECIES(0)%RCON)*SPECIES(N)%YY0
      ENDIF
   ENDDO
ENDIF

! Initialize pressure ZONEs
 
ALLOCATE(M%PRESSURE_ZONE(0:IBP1,0:JBP1,0:KBP1),STAT=IZERO)
CALL ChkMemErr('INIT','PRESSURE_ZONE',IZERO)
M%PRESSURE_ZONE = 0
DO N=1,N_ZONE
   PZ => P_ZONE(N)
   DO K=0,KBP1
      DO J=0,JBP1
         DO I=0,IBP1
            IF (M%XC(I) > PZ%X1 .AND. M%XC(I) < PZ%X2 .AND. &
                M%YC(J) > PZ%Y1 .AND. M%YC(J) < PZ%Y2 .AND. &
                M%ZC(K) > PZ%Z1 .AND. M%ZC(K) < PZ%Z2) THEN 
                M%PRESSURE_ZONE(I,J,K) = N
                DO IOPZ=0,N_ZONE
                   IF (PZ%LEAK_AREA(IOPZ) > 0._EB) M%LEAK_AREA(N,IOPZ) = PZ%LEAK_AREA(IOPZ)
                   IF (PZ%LEAK_AREA(IOPZ) > 0._EB) M%LEAK_AREA(IOPZ,N) = PZ%LEAK_AREA(IOPZ)
                ENDDO
            ENDIF
         ENDDO
      ENDDO
   ENDDO
ENDDO

! Over-ride default ambient conditions with user-prescribed INITializations
 
DO N=1,N_INIT
   IN => INITIALIZATION(N)
   DO K=0,KBP1
      DO J=0,JBP1
         DO I=0,IBP1
            IF (M%XC(I) > IN%X1 .AND. M%XC(I) < IN%X2 .AND. &
                M%YC(J) > IN%Y1 .AND. M%YC(J) < IN%Y2 .AND. &
                M%ZC(K) > IN%Z1 .AND. M%ZC(K) < IN%Z2) THEN
               M%TMP(I,J,K)            = IN%TEMPERATURE
               M%RHO(I,J,K)            = IN%DENSITY
               IF (N_SPECIES>0) M%YY(I,J,K,1:N_SPECIES) = IN%MASS_FRACTION(1:N_SPECIES)
               IF (IN%ADJUST_DENSITY)     M%RHO(I,J,K) = M%RHO(I,J,K)*M%P_0(K)/P_INF
               IF (IN%ADJUST_TEMPERATURE) M%TMP(I,J,K) = M%TMP(I,J,K)*M%P_0(K)/P_INF
            ENDIF
         ENDDO
      ENDDO
   ENDDO
ENDDO

M%RHOS    = M%RHO

! Radiation

M%QR    = 0._EB
M%KAPPA = 0._EB
M%UII   = 4._EB*SIGMA*TMPA4
M%WORK1 = 0._EB
M%WORK2 = 0._EB
M%WORK3 = 0._EB
M%WORK4 = 0._EB
M%WORK5 = 0._EB
M%WORK6 = 0._EB
M%WORK7 = 0._EB

! Designate each boundary cell with a reference number for wall BC's
 
NWC  = 0
NDWC = 0
 
! Determine the number of wall cells to allocate
 
OBST_LOOP_1: DO N=1,M%N_OBST
   OB=>M%OBSTRUCTION(N)
   IF (OB%CONSUMABLE) THEN
      NDWC = NDWC + 3*(OB%I2-OB%I1+1)*(OB%J2-OB%J1+1)*(OB%K2-OB%K1+1)
   ELSEIF (OB%DEVC_INDEX>0 .OR. OB%CTRL_INDEX>0 ) THEN
      NDWC = NDWC + 3*(OB%I2-OB%I1+1)*(OB%J2-OB%J1+1)*(OB%K2-OB%K1+1)   
!      IF (.NOT. DEVICE(OB%DEVC_INDEX)%INITIAL_STATE) NDWC = NDWC + 3*(OB%I2-OB%I1+1)*(OB%J2-OB%J1+1)*(OB%K2-OB%K1+1)
!   ELSEIF (OB%CTRL_INDEX/=0) THEN
!      IF (.NOT. CONTROL(OB%CTRL_INDEX)%INITIAL_STATE) NDWC = NDWC + 3*(OB%I2-OB%I1+1)*(OB%J2-OB%J1+1)*(OB%K2-OB%K1+1)
   ELSE
      DO K=OB%K1+1,OB%K2
         DO J=OB%J1+1,OB%J2
            IC = M%CELL_INDEX(OB%I1  ,J,K)
            IF (.NOT.M%SOLID(IC)) NDWC = NDWC + 1
            IC = M%CELL_INDEX(OB%I2+1,J,K)
            IF (.NOT.M%SOLID(IC)) NDWC = NDWC + 1
         ENDDO 
      ENDDO
      DO K=OB%K1+1,OB%K2
         DO I=OB%I1+1,OB%I2
            IC = M%CELL_INDEX(I,OB%J1  ,K)
            IF (.NOT.M%SOLID(IC)) NDWC = NDWC + 1
            IC = M%CELL_INDEX(I,OB%J2+1,K)
            IF (.NOT.M%SOLID(IC)) NDWC = NDWC + 1
         ENDDO 
      ENDDO
      DO J=OB%J1+1,OB%J2
         DO I=OB%I1+1,OB%I2
            IC = M%CELL_INDEX(I,J,OB%K1  )
            IF (.NOT.M%SOLID(IC)) NDWC = NDWC + 1
            IC = M%CELL_INDEX(I,J,OB%K2+1)
            IF (.NOT.M%SOLID(IC)) NDWC = NDWC + 1
         ENDDO 
      ENDDO
   ENDIF
ENDDO OBST_LOOP_1

NDWC = NDWC + M%NEWC
ALLOCATE(M%WALL(1:NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','WALL',IZERO)
 
ALLOCATE(M%TMP_F(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','TMP_F',IZERO) 
M%TMP_F = TMPA
ALLOCATE(M%TMP_B(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','TMP_B',IZERO) 
M%TMP_B = TMPA
ALLOCATE(M%TMP_W(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','TMP_W',IZERO) 
M%TMP_W = TMPA
IF (N_EVAP_INDICIES > 0) THEN
   ALLOCATE(M%RCP_W(NDWC),STAT=IZERO)
   CALL ChkMemErr('INIT','RCP_W',IZERO) 
   M%RCP_W = 0._EB
ENDIF
ALLOCATE(M%RHO_W(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','RHO_W',IZERO) 
M%RHO_W = RHOA
ALLOCATE(M%RSUM_W(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','RSUM_W',IZERO) 
M%RSUM_W = RSUM0
ALLOCATE(M%YY_W(NDWC,N_SPECIES),STAT=IZERO)
CALL ChkMemErr('INIT','YY_W',IZERO)  
DO IW=1,NDWC
   M%YY_W(IW,1:N_SPECIES) = SPECIES(1:N_SPECIES)%YY0
ENDDO
ALLOCATE(M%E_WALL(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','E_WALL',IZERO)
M%E_WALL = 1._EB
ALLOCATE(M%QRADIN(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','QRADIN',IZERO) 
M%QRADIN = SIGMA*TMPA4
ALLOCATE(M%QRADOUT(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','QRADOUT',IZERO) 
M%QRADOUT = SIGMA*TMPA4
ALLOCATE(M%QCONF(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','QCONF',IZERO) 
M%QCONF = 0._EB
ALLOCATE(M%HEAT_TRANS_COEF(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','HEAT_TRANS_COEF',IZERO) 
M%HEAT_TRANS_COEF = 0._EB
ALLOCATE(M%XW(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','XW',IZERO)
ALLOCATE(M%YW(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','YW',IZERO)
ALLOCATE(M%ZW(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','ZW',IZERO)
ALLOCATE(M%TW(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','TW',IZERO)  
M%TW = T_BEGIN
ALLOCATE(M%EW(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','EW',IZERO)  
M%EW = 0._EB
ALLOCATE(M%KW(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','KW',IZERO)  
M%KW = 1._EB
ALLOCATE(M%RHODW(NDWC,N_SPECIES),STAT=IZERO)
CALL ChkMemErr('INIT','RHODW',IZERO) 
M%RHODW = 1._EB
ALLOCATE(M%AREA_ADJUST(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','AREA_ADJUST',IZERO)  
M%AREA_ADJUST = 1._EB
ALLOCATE(M%MASSFLUX(NDWC,0:N_SPECIES),STAT=IZERO)
CALL ChkMemErr('INIT','MASSFLUX',IZERO)  
M%MASSFLUX = 0._EB
ALLOCATE(M%ACTUAL_BURN_RATE(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','ACTUAL_BURN_RATE',IZERO)  
M%ACTUAL_BURN_RATE = 0._EB
ALLOCATE(M%RDN(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','RDN',IZERO)
M%RDN = 1._EB
ALLOCATE(M%AW(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','AW',IZERO)  
M%AW = 0._EB
ALLOCATE(M%RAW(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','RAW',IZERO) 
M%RAW = 0._EB
ALLOCATE(M%NPPCW(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','NPPCW',IZERO) 
M%NPPCW = 1
ALLOCATE(M%UW0(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','UW0',IZERO)    
M%UW0 = 0._EB
ALLOCATE(M%UW(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','UW',IZERO)    
M%UW = 0._EB
ALLOCATE(M%UWS(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','UWS',IZERO)   
M%UWS = 0._EB
ALLOCATE(M%OBST_INDEX_W(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','OBST_INDEX_W',IZERO) 
M%OBST_INDEX_W = 0
ALLOCATE(M%VENT_INDEX(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','VENT_INDEX',IZERO) 
M%VENT_INDEX = 0
ALLOCATE(M%DUWDT(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','DUWDT',IZERO) 
M%DUWDT = 0._EB
ALLOCATE(M%PRESSURE_ZONE_WALL(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','PRESSURE_ZONE_WALL',IZERO) 
M%PRESSURE_ZONE_WALL = 0
ALLOCATE(M%IJKW(15,NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','IJKW',IZERO)  
M%IJKW = 0
ALLOCATE(M%IBC_ORIG(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','IBC_ORIG',IZERO)  
M%IBC_ORIG = 0
ALLOCATE(M%INTERPOLATION_FACTOR(M%NEWC),STAT=IZERO)
CALL ChkMemErr('INIT','INTERPOLATION_FACTOR',IZERO)  
M%INTERPOLATION_FACTOR = 0._EB
ALLOCATE(M%BOUNDARY_TYPE(0:NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','BOUNDARY_TYPE',IZERO) 
M%BOUNDARY_TYPE = NULL_BOUNDARY
ALLOCATE(M%MASS_LOSS(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','MASS_LOSS',IZERO)
M%MASS_LOSS = 0._EB
ALLOCATE(M%WALL_INDEX(0:M%CELL_COUNT,-3:3),STAT=IZERO)
CALL ChkMemErr('INIT','WALL_INDEX',IZERO) 
M%WALL_INDEX = 0
ALLOCATE(M%WALL_INDEX_BACK(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','WALL_INDEX_BACK',IZERO) 
M%WALL_INDEX_BACK = 0
ALLOCATE(M%EDGE_INDEX(0:M%CELL_COUNT,1:12),STAT=IZERO)
CALL ChkMemErr('INIT','EDGE_INDEX',IZERO) 
M%EDGE_INDEX = 0
ALLOCATE(M%UVW_GHOST(0:M%CELL_COUNT,3),STAT=IZERO)
CALL ChkMemErr('INIT','UVW_GHOST',IZERO) 
M%UVW_GHOST = 0
 
! Surface water arrays
 
IF (ACCUMULATE_WATER) THEN
   ALLOCATE(M%AWMPUA(NDWC,N_EVAP_INDICIES),STAT=IZERO)
   CALL ChkMemErr('INIT','AWMPUA',IZERO) 
   M%AWMPUA = 0._EB
ENDIF
ALLOCATE(M%WMPUA(NDWC,MAX(1,N_EVAP_INDICIES)),STAT=IZERO)
CALL ChkMemErr('INIT','WMPUA',IZERO) 
M%WMPUA = 0._EB
ALLOCATE(M%WCPUA(NDWC,MAX(1,N_EVAP_INDICIES)),STAT=IZERO)
CALL ChkMemErr('INIT','WCPUA',IZERO) 
M%WCPUA = 0._EB
 
! Surface work arrays
 
ALLOCATE(M%WALL_WORK1(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','WALL_WORK1',IZERO) 
ALLOCATE(M%WALL_WORK2(NDWC),STAT=IZERO)
CALL ChkMemErr('INIT','WALL_WORK2',IZERO) 
 
! Set up boundary arrays for external boundaries of the current mesh

DO K=1,KBAR
   DO J=1,JBAR
      I   = 0
      IBC = DEFAULT_SURF_INDEX
      IOR = 1
      NWC = NWC + 1
      IW  = NWC
      CALL INIT_WALL_CELL(NM,I,J,K,0,IW,IOR,IBC)
   ENDDO
ENDDO
DO K=1,KBAR
   DO J=1,JBAR
      I   = IBP1
      IBC = DEFAULT_SURF_INDEX
      IOR = -1
      NWC = NWC + 1
      IW  = NWC
      CALL INIT_WALL_CELL(NM,I,J,K,0,IW,IOR,IBC)
   ENDDO
ENDDO
 
DO K=1,KBAR
   DO I=1,IBAR
      J   = 0
      IBC = DEFAULT_SURF_INDEX
      IOR = 2
      NWC = NWC + 1
      IW  = NWC
      CALL INIT_WALL_CELL(NM,I,J,K,0,IW,IOR,IBC)
   ENDDO
ENDDO
DO K=1,KBAR
   DO I=1,IBAR
      J   = JBP1
      IBC = DEFAULT_SURF_INDEX
      IOR = -2
      NWC = NWC + 1
      IW  = NWC
      CALL INIT_WALL_CELL(NM,I,J,K,0,IW,IOR,IBC)
   ENDDO
ENDDO
 
DO J=1,JBAR
   DO I=1,IBAR
      K   = 0
      IBC = DEFAULT_SURF_INDEX
      IOR = 3
      NWC = NWC + 1
      IW  = NWC
      CALL INIT_WALL_CELL(NM,I,J,K,0,IW,IOR,IBC)
   ENDDO
ENDDO
DO J=1,JBAR
   DO I=1,IBAR
      K   = KBP1
      IBC = DEFAULT_SURF_INDEX
      IOR = -3
      NWC = NWC + 1
      IW  = NWC
      CALL INIT_WALL_CELL(NM,I,J,K,0,IW,IOR,IBC)
   ENDDO
ENDDO

! Go through all obstructions and decide which cell faces ought to be given a wall cell index and initialized
 
OBST_LOOP_2: DO N=1,M%N_OBST
   OB=>M%OBSTRUCTION(N)
 
   DO K=OB%K1+1,OB%K2
      DO J=OB%J1+1,OB%J2
         I = OB%I1+1 
         IF (I==1) CYCLE   ! Don't assign wall cell index to obstruction face pointing out of the computational domain
         IC = M%CELL_INDEX(I-1,J,K)
         IF (M%SOLID(IC) .AND. .NOT.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE) CYCLE   ! Permanently covered face
         IOR = -1 
         IBC = OB%IBC(IOR)
         IW  = M%WALL_INDEX(IC,-IOR)
         IF (IW==0) THEN
            NWC = NWC + 1
            IW  = NWC
         ENDIF
         CALL INIT_WALL_CELL(NM,I,J,K,N,IW,IOR,IBC)
      ENDDO
   ENDDO
 
   DO K=OB%K1+1,OB%K2
      DO J=OB%J1+1,OB%J2
         I = OB%I2
         IF (I==M%IBAR) CYCLE  ! Don't assign wall cell index to obstruction face pointing out of the computational domain
         IC = M%CELL_INDEX(I+1,J,K)
         IF (M%SOLID(IC) .AND. .NOT.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE) CYCLE   ! Permanently covered face
         IOR = 1
         IBC = OB%IBC(IOR)
         IW  = M%WALL_INDEX(IC,-IOR)
         IF (IW==0) THEN
            NWC = NWC + 1
            IW  = NWC
         ENDIF
         CALL INIT_WALL_CELL(NM,I,J,K,N,IW,IOR,IBC)
      ENDDO 
   ENDDO
 
   DO K=OB%K1+1,OB%K2
      DO I=OB%I1+1,OB%I2
         J = OB%J1+1
         IF (J==1) CYCLE   ! Don't assign wall cell index to obstruction face pointing out of the computational domain
         IC = M%CELL_INDEX(I,J-1,K)
         IF (M%SOLID(IC) .AND. .NOT.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE) CYCLE   ! Permanently covered face
         IOR = -2
         IBC = OB%IBC(IOR)
         IW  = M%WALL_INDEX(IC,-IOR)
         IF (IW==0) THEN
            NWC = NWC + 1
            IW  = NWC
         ENDIF
         CALL INIT_WALL_CELL(NM,I,J,K,N,IW,IOR,IBC)
      ENDDO
   ENDDO   
 
   DO K=OB%K1+1,OB%K2
      DO I=OB%I1+1,OB%I2
         J = OB%J2
         IF (J==M%JBAR) CYCLE  ! Don't assign wall cell index to obstruction face pointing out of the computational domain
         IC = M%CELL_INDEX(I,J+1,K)
         IF (M%SOLID(IC) .AND. .NOT.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE) CYCLE   ! Permanently covered face
         IOR = 2
         IBC = OB%IBC(IOR)
         IW  = M%WALL_INDEX(IC,-IOR)
         IF (IW==0) THEN
            NWC = NWC + 1
            IW  = NWC
         ENDIF
         CALL INIT_WALL_CELL(NM,I,J,K,N,IW,IOR,IBC)
      ENDDO
   ENDDO   
 
   DO J=OB%J1+1,OB%J2
      DO I=OB%I1+1,OB%I2
         K = OB%K1+1
         IF (K==1) CYCLE   ! Don't assign wall cell index to obstruction face pointing out of the computational domain
         IC = M%CELL_INDEX(I,J,K-1)
         IF (M%SOLID(IC) .AND. .NOT.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE) CYCLE   ! Permanently covered face
         IOR = -3
         IBC = OB%IBC(IOR)
         IW  = M%WALL_INDEX(IC,-IOR)
         IF (IW==0) THEN
            NWC = NWC + 1
            IW  = NWC
         ENDIF
         CALL INIT_WALL_CELL(NM,I,J,K,N,IW,IOR,IBC)
      ENDDO
   ENDDO   
 
   DO J=OB%J1+1,OB%J2
      DO I=OB%I1+1,OB%I2
         K = OB%K2
         IF (K==M%KBAR) CYCLE  ! Don't assign wall cell index to obstruction face pointing out of the computational domain
         IC = M%CELL_INDEX(I,J,K+1)
         IF (M%SOLID(IC) .AND. .NOT.M%OBSTRUCTION(M%OBST_INDEX_C(IC))%REMOVABLE) CYCLE   ! Permanently covered face
         IOR = 3 
         IBC = OB%IBC(IOR)
         IW  = M%WALL_INDEX(IC,-IOR)
         IF (IW==0) THEN
            NWC = NWC + 1
            IW  = NWC
         ENDIF
         CALL INIT_WALL_CELL(NM,I,J,K,N,IW,IOR,IBC)
      ENDDO
   ENDDO   
 
ENDDO OBST_LOOP_2

! Determine back wall index for exposed surfaces

DO IW=M%NEWC+1,M%NWC  
   ! Only assign WALL_INDEX_BACK to wall cells that are not attached to the exterior boundary of the computational domain
   SF=>SURFACE(M%IJKW(5,IW))
   IF (SF%BACKING==EXPOSED) THEN
      II = M%IJKW(1,IW)
      JJ = M%IJKW(2,IW)
      KK = M%IJKW(3,IW)
      IC = M%CELL_INDEX(II,JJ,KK)
      IOR = M%IJKW(4,IW)
      IF (.NOT.M%SOLID(IC)) M%WALL_INDEX_BACK(IW) = M%WALL_INDEX(IC,IOR)
      IF (     M%SOLID(IC)) THEN
         SELECT CASE(IOR)
            CASE(-1)
               II=II+1
            CASE( 1)
               II=II-1
            CASE(-2)
               JJ=JJ+1
            CASE( 2)
               JJ=JJ-1
            CASE(-3)
               KK=KK+1
            CASE( 3)
               KK=KK-1
         END SELECT
         IC = M%CELL_INDEX(II,JJ,KK)
         M%WALL_INDEX_BACK(IW) = M%WALL_INDEX(IC,IOR)
      ENDIF
   ENDIF
ENDDO

! Set clocks and counters related to frequency of solid phase conduction updates

M%BC_CLOCK     = T_BEGIN
M%WALL_COUNTER = 0
 
! Allocate arrays for storing velocity boundary condition info
 
N_EDGES_DIM = 4*(IBP1*JBP1+IBP1*KBP1+JBP1*KBP1)
DO N=1,M%N_OBST
   OB=>M%OBSTRUCTION(N)
   IPTS = OB%I2-OB%I1
   JPTS = OB%J2-OB%J1
   KPTS = OB%K2-OB%K1
   N_EDGES_DIM = N_EDGES_DIM + 4*(IPTS*JPTS+IPTS*KPTS+JPTS*KPTS)
ENDDO

ALLOCATE(M%IJKE(14,N_EDGES_DIM),STAT=IZERO)
CALL ChkMemErr('INIT','IJKE',IZERO)   
M%IJKE  = 0
ALLOCATE(M%OME_E(N_EDGES_DIM),STAT=IZERO)
CALL ChkMemErr('INIT','OME_E',IZERO)  
M%OME_E = 0._EB
ALLOCATE(M%TAU_E(N_EDGES_DIM),STAT=IZERO)
CALL ChkMemErr('INIT','TAU_E',IZERO)  
M%TAU_E = 0._EB
ALLOCATE(M%ACTIVE_EDGE(N_EDGES_DIM),STAT=IZERO)
CALL ChkMemErr('INIT','ACTIVE_EDGE',IZERO)  
M%ACTIVE_EDGE = .TRUE.
ALLOCATE(M%EDGE_INTERPOLATION_FACTOR(N_EDGES_DIM,2),STAT=IZERO)
CALL ChkMemErr('INIT','EDGE_INTERPOLATION_FACTOR',IZERO)  
M%EDGE_INTERPOLATION_FACTOR = 1._EB
 
! Initialize and allocate lagrangian particle/droplet arrays

M%NLP = 0
M%NLPDIM = 1000
IF (DROPLET_FILE) THEN
   ALLOCATE(M%DROPLET(M%NLPDIM),STAT=IZERO)
   CALL ChkMemErr('INIT','DROPLET',IZERO)
ENDIF
 
! Allocate array to hold character strings for Smokeview file
 
M%N_STRINGS     =   0
M%N_STRINGS_MAX = 100
ALLOCATE(M%STRING(M%N_STRINGS_MAX),STAT=IZERO)
CALL ChkMemErr('INIT','STRING',IZERO)
 
! Set up arrays to hold velocity boundary condition info
 
CALL INITIALIZE_EDGES
 
! Initialize Pressure solver
 
CALL INITIALIZE_POISSON_SOLVER
 
! Determine which wall cells to assign for solid phase thermocouples and profiles
 
CALL INITIALIZE_DEVC
CALL INITIALIZE_PROF
 
! Allocate and Initialize Mesh-Dependent Radiation Arrays
 
M%ANGLE_INC_COUNTER = 0
M%RAD_CALL_COUNTER  = 0
IF (RADIATION) THEN
   ALLOCATE(M%UIID(0:M%IBP1,0:M%JBP1,0:M%KBP1,1:UIIDIM),STAT=IZERO)
   M%UIID = 0.
ENDIF
CALL ChkMemErr('INIT','UIID',IZERO)
DO IW=1,M%NDWC
   IF (M%BOUNDARY_TYPE(IW)/=OPEN_BOUNDARY) THEN
      IF (RADIATION) THEN
         ALLOCATE(M%WALL(IW)%ILW(NRA,NSB),STAT=IZERO)
         CALL ChkMemErr('INIT','ILW',IZERO)
         M%WALL(IW)%ILW  = SIGMA*TMPA4*RPI
      ENDIF
      M%QRADIN(IW)  = M%E_WALL(IW)*SIGMA*TMPA4
      M%QRADOUT(IW) = M%E_WALL(IW)*SIGMA*TMPA4
   ENDIF
ENDDO

! Initialize Mesh Exchange
 
CALL INITIALIZE_INTERPOLATION
 
CONTAINS
 
 
SUBROUTINE INITIALIZE_EDGES
 
! Set up edge arrays for velocity boundary conditions
 
INTEGER I,J,K,N
 
CALL POINT_TO_MESH(NM)
 
N_EDGES = 0
 
! Arguments for DEFINE_EDGE(I,J,K,IOR,IEC,NM,I_OBST)
 
DO K=0,KBAR
   DO J=0,JBAR
      IF (J>0) CALL DEFINE_EDGE(   0,J,K, 1,2,NM,0)
      IF (J>0) CALL DEFINE_EDGE(IBAR,J,K,-1,2,NM,0)
      IF (K>0) CALL DEFINE_EDGE(   0,J,K, 1,3,NM,0)
      IF (K>0) CALL DEFINE_EDGE(IBAR,J,K,-1,3,NM,0)
   ENDDO
ENDDO
DO K=0,KBAR
   DO I=0,IBAR
      IF (I>0) CALL DEFINE_EDGE(I,   0,K, 2,1,NM,0)
      IF (I>0) CALL DEFINE_EDGE(I,JBAR,K,-2,1,NM,0)
      IF (K>0) CALL DEFINE_EDGE(I,   0,K, 2,3,NM,0)
      IF (K>0) CALL DEFINE_EDGE(I,JBAR,K,-2,3,NM,0)
   ENDDO
ENDDO
DO J=0,JBAR
   DO I=0,IBAR
      IF (I>0) CALL DEFINE_EDGE(I,J,   0, 3,1,NM,0)
      IF (I>0) CALL DEFINE_EDGE(I,J,KBAR,-3,1,NM,0)
      IF (J>0) CALL DEFINE_EDGE(I,J,   0, 3,2,NM,0)
      IF (J>0) CALL DEFINE_EDGE(I,J,KBAR,-3,2,NM,0)
   ENDDO
ENDDO

OBST_LOOP_3: DO N=1,N_OBST
   OB => OBSTRUCTION(N)
   DO K=OB%K1,OB%K2
      DO J=OB%J1,OB%J2
         IF (J>OB%J1) CALL DEFINE_EDGE(OB%I1,J,K,-1,2,NM,N)
         IF (J>OB%J1) CALL DEFINE_EDGE(OB%I2,J,K, 1,2,NM,N)
         IF (K>OB%K1) CALL DEFINE_EDGE(OB%I1,J,K,-1,3,NM,N)
         IF (K>OB%K1) CALL DEFINE_EDGE(OB%I2,J,K, 1,3,NM,N)
      ENDDO
   ENDDO
   DO K=OB%K1,OB%K2
      DO I=OB%I1,OB%I2
         IF (I>OB%I1) CALL DEFINE_EDGE(I,OB%J1,K,-2,1,NM,N)
         IF (I>OB%I1) CALL DEFINE_EDGE(I,OB%J2,K, 2,1,NM,N)
         IF (K>OB%K1) CALL DEFINE_EDGE(I,OB%J1,K,-2,3,NM,N)
         IF (K>OB%K1) CALL DEFINE_EDGE(I,OB%J2,K, 2,3,NM,N)
      ENDDO
   ENDDO
   DO J=OB%J1,OB%J2
      DO I=OB%I1,OB%I2
         IF (I>OB%I1) CALL DEFINE_EDGE(I,J,OB%K1,-3,1,NM,N)
         IF (I>OB%I1) CALL DEFINE_EDGE(I,J,OB%K2, 3,1,NM,N)
         IF (J>OB%J1) CALL DEFINE_EDGE(I,J,OB%K1,-3,2,NM,N)
         IF (J>OB%J1) CALL DEFINE_EDGE(I,J,OB%K2, 3,2,NM,N)
      ENDDO
   ENDDO
ENDDO OBST_LOOP_3
 
END SUBROUTINE INITIALIZE_EDGES
 
 
SUBROUTINE INITIALIZE_POISSON_SOLVER
USE POIS, ONLY: H3CZIS,H2CZIS,H3CSIS,H2CYIS
REAL(EB) :: XLM,XMU
INTEGER  :: N,IERR
INTEGER, POINTER :: ITRN,JTRN,KTRN,LBC,MBC,NBC
INTEGER, POINTER, DIMENSION(:) :: NOC
TYPE (VENTS_TYPE), POINTER :: VT
 
!Allocate major arrays
 
ITRN =>M%ITRN 
JTRN =>M%JTRN
KTRN =>M%KTRN
LBC =>M%LBC
MBC =>M%MBC
NBC =>M%NBC
NOC=>TRANS(NM)%NOC
IF (NOC(1)==0 .AND. NOC(2)==0 .AND. NOC(3)==0) M%IPS=0
IF (NOC(1)/=0 .AND. NOC(2)==0 .AND. NOC(3)==0) M%IPS=1
IF (NOC(1)==0 .AND. NOC(2)/=0 .AND. NOC(3)==0) M%IPS=2
IF (NOC(1)==0 .AND. NOC(2)==0 .AND. NOC(3)/=0) M%IPS=3
IF (NOC(1)/=0 .AND. NOC(2)/=0 .AND. NOC(3)==0) M%IPS=4
IF (NOC(1)/=0 .AND. NOC(2)==0 .AND. NOC(3)/=0) M%IPS=5
IF (NOC(1)==0 .AND. NOC(2)/=0 .AND. NOC(3)/=0) M%IPS=6
IF (EVACUATION_ONLY(NM)                      ) M%IPS=7
IF (NOC(1)/=0 .AND. NOC(2)/=0 .AND. NOC(3)/=0) CALL SHUTDOWN('ERROR: Stretch at most 2 coordinate directions')
 
IF (M%IPS<=1 .OR. M%IPS==4) THEN
   ITRN = IBP1
   IF (JBAR>1) JTRN = JBP1
   IF (JBAR==1) JTRN = 1
   KTRN = KBP1
ENDIF
 
IF (M%IPS==2) THEN
   ITRN = JBP1
   JTRN = IBP1
   KTRN = KBP1
   ALLOCATE(M%BZST(JBP1,IBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BZST',IZERO)
   ALLOCATE(M%BZFT(JBP1,IBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BZFT',IZERO)
ENDIF
 
IF (M%IPS==3 .OR. M%IPS==6) THEN
   ITRN = KBP1
   IF (JBAR>1) JTRN = JBP1
   IF (JBAR==1) JTRN = 1
   KTRN = IBP1
   ALLOCATE(M%BXST(KBP1,JTRN),STAT=IZERO)
   CALL ChkMemErr('INIT','BXST',IZERO)
   ALLOCATE(M%BXFT(KBP1,JTRN),STAT=IZERO)
   CALL ChkMemErr('INIT','BXFT',IZERO)
   ALLOCATE(M%BYST(KBP1,IBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BYST',IZERO)
   ALLOCATE(M%BYFT(KBP1,IBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BYFT',IZERO)
   ALLOCATE(M%BZST(JTRN,IBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BZST',IZERO)
   ALLOCATE(M%BZFT(JTRN,IBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BZFT',IZERO)
ENDIF
 
IF (M%IPS==5) THEN
   ITRN = IBP1
   JTRN = KBP1
   KTRN = JBP1
   ALLOCATE(M%BXST(KBP1,JBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BXST',IZERO)
   ALLOCATE(M%BXFT(KBP1,JBP1),STAT=IZERO)
   CALL ChkMemErr('INIT','BXFT',IZERO)
ENDIF
 
IF (M%IPS==7) THEN
   ITRN = IBP1
   JTRN = JBP1
   KTRN = 1
ENDIF
 
IF (M%IPS<=3 .OR. M%IPS==7) THEN
   M%LSAVE = (ITRN+1)*JTRN*KTRN+7*ITRN+5*JTRN+6*KTRN+56
   M%LWORK = (ITRN+1)*JTRN*KTRN
ELSE
   N_LOOP: DO N=1,50
      IF ((JTRN+1)<=2**N) EXIT N_LOOP
   ENDDO N_LOOP
   M%LSAVE = KTRN*(6*N*(2**N)+2*N+19)+8*ITRN+7*JTRN+38
   M%LWORK = JTRN*(ITRN*(KTRN+1)+1)
ENDIF
 
ALLOCATE(M%SAVE(-3:M%LSAVE),STAT=IZERO)
CALL ChkMemErr('INIT','SAVE',IZERO)
ALLOCATE(M%SAVE2(-3:M%LSAVE),STAT=IZERO)
CALL ChkMemErr('INIT','SAVE2',IZERO)
ALLOCATE(M%WORK(M%LWORK),STAT=IZERO)
CALL ChkMemErr('INIT','WORK',IZERO)
ALLOCATE(M%PRHS(ITRN,JTRN,KTRN),STAT=IZERO)
CALL ChkMemErr('INIT','PRHS',IZERO)
   IF (KBAR>1) THEN
   IF (JBAR>1) ALLOCATE(M%BXS(JBP1,KBP1),STAT=IZERO)
   IF (JBAR==1) ALLOCATE(M%BXS(1,KBP1)   ,STAT=IZERO)
ELSE
               ALLOCATE(M%BXS(JBP1,1)   ,STAT=IZERO)
ENDIF
CALL ChkMemErr('INIT','BXS',IZERO)
IF (KBAR>1) THEN
   IF (JBAR>1) ALLOCATE(M%BXF(JBP1,KBP1),STAT=IZERO)
   IF (JBAR==1) ALLOCATE(M%BXF(1,KBP1)   ,STAT=IZERO)
ELSE
               ALLOCATE(M%BXF(JBP1,1)   ,STAT=IZERO)
ENDIF
CALL ChkMemErr('INIT','BXF',IZERO)
IF (KBAR>1) THEN
   ALLOCATE(M%BYS(IBP1,KBP1),STAT=IZERO)
ELSE
   ALLOCATE(M%BYS(IBP1,1),STAT=IZERO)
ENDIF
CALL ChkMemErr('INIT','BYS',IZERO)
IF (KBAR>1) THEN
   ALLOCATE(M%BYF(IBP1,KBP1),STAT=IZERO)
ELSE
   ALLOCATE(M%BYF(IBP1,1),STAT=IZERO)
ENDIF
CALL ChkMemErr('INIT','BYF',IZERO)
IF (JBAR>1) ALLOCATE(M%BZS(IBP1,JBP1),STAT=IZERO)
IF (JBAR==1) ALLOCATE(M%BZS(IBP1,1)   ,STAT=IZERO)
CALL ChkMemErr('INIT','BZS',IZERO)
IF (JBAR>1) ALLOCATE(M%BZF(IBP1,JBP1),STAT=IZERO)
IF (JBAR==1) ALLOCATE(M%BZF(IBP1,1)   ,STAT=IZERO)
CALL ChkMemErr('INIT','BZF',IZERO)
 
M%SAVE  = 0._EB
M%WORK  = 0._EB
M%PRHS  = 0._EB
M%BXS   = 0._EB
M%BXF   = 0._EB
M%BYS   = 0._EB
M%BYF   = 0._EB
M%BZS   = 0._EB
M%BZF   = 0._EB
 
! Initialize pressure solver   
 
XLM = 0._EB         ! No Helmholtz equation
XMU = 0._EB         ! No Helmholtz equation
LBC = 3
MBC = 3
NBC = 3
 
VENT_LOOP: DO N=1,M%N_VENT
   VT => M%VENTS(N)
   IF (VT%BOUNDARY_TYPE /= OPEN_BOUNDARY) CYCLE VENT_LOOP
   IF (VT%I1==0 .AND. VT%I2==0) THEN
      IF (LBC==3) LBC = 2
      IF (LBC==4) LBC = 1
   ENDIF
   IF (VT%I1==M%IBAR .AND. VT%I2==M%IBAR) THEN
      IF (LBC==3) LBC = 4
      IF (LBC==2) LBC = 1
   ENDIF
   IF (VT%J1==0 .AND. VT%J2==0) THEN
      IF (MBC==3) MBC = 2
      IF (MBC==4) MBC = 1
   ENDIF
   IF (VT%J1==M%JBAR .AND. VT%J2==M%JBAR) THEN
      IF (MBC==3) MBC = 4
      IF (MBC==2) MBC = 1
   ENDIF
   IF (VT%K1==0 .AND. VT%K2==0) THEN
      IF (NBC==3) NBC = 2
      IF (NBC==4) NBC = 1
   ENDIF
   IF (VT%K1==M%KBAR .AND. VT%K2==M%KBAR) THEN
      IF (NBC==3) NBC = 4
      IF (NBC==2) NBC = 1
   ENDIF
ENDDO VENT_LOOP
 
DO IW=1,M%NEWC
   IF (M%IJKW(9,IW)>0) THEN
      SELECT CASE(M%IJKW(4,IW))
         CASE( 1)
            IF (LBC==3) LBC = 2
            IF (LBC==4) LBC = 1
         CASE(-1)
            IF (LBC==3) LBC = 4
            IF (LBC==2) LBC = 1
         CASE( 2)
            IF (MBC==3) MBC = 2
            IF (MBC==4) MBC = 1
         CASE(-2)
            IF (MBC==3) MBC = 4
            IF (MBC==2) MBC = 1
         CASE( 3)
            IF (NBC==3) NBC = 2
            IF (NBC==4) NBC = 1
         CASE(-3)
            IF (NBC==3) NBC = 4
            IF (NBC==2) NBC = 1
      END SELECT
   ENDIF
ENDDO
 
! User over-rides of Poisson boundary conditions
 
IF (PBC(1,NM)==0 .AND. PBC(2,NM)==0) LBC = 1
IF (PBC(1,NM)==0 .AND. PBC(2,NM)==1) LBC = 2
IF (PBC(1,NM)==1 .AND. PBC(2,NM)==1) LBC = 3
IF (PBC(1,NM)==1 .AND. PBC(2,NM)==0) LBC = 4
IF (PBC(3,NM)==0 .AND. PBC(4,NM)==0) MBC = 1
IF (PBC(3,NM)==0 .AND. PBC(4,NM)==1) MBC = 2
IF (PBC(3,NM)==1 .AND. PBC(4,NM)==1) MBC = 3
IF (PBC(3,NM)==1 .AND. PBC(4,NM)==0) MBC = 4
IF (PBC(5,NM)==0 .AND. PBC(6,NM)==0) NBC = 1
IF (PBC(5,NM)==0 .AND. PBC(6,NM)==1) NBC = 2
IF (PBC(5,NM)==1 .AND. PBC(6,NM)==1) NBC = 3
IF (PBC(5,NM)==1 .AND. PBC(6,NM)==0) NBC = 4
 
! Poisson solver with stretching in the 1st coordinate
 
      SELECT_POISSON_SOLVER: SELECT CASE(M%IPS)
 
         CASE (0:1) SELECT_POISSON_SOLVER
            IF (.NOT.TWO_D) THEN
               CALL H3CZIS(XS,XF,IBAR,LBC,YS,YF,JBAR,MBC,ZS,ZF,KBAR,NBC,M%HX, XLM,ITRN,JTRN,IERR,M%SAVE)
               IF (PRESSURE_CORRECTION) CALL H3CZIS(XS,XF,IBAR,3,YS,YF,JBAR,3,ZS,ZF,KBAR,3,M%HX, XLM,ITRN,JTRN,IERR,M%SAVE2)
            ENDIF
            IF (TWO_D .AND. .NOT.CYLINDRICAL) THEN
               CALL H2CZIS(XS,XF,IBAR,LBC,ZS,ZF,KBAR,NBC,M%HX,XLM, ITRN,IERR,M%SAVE)
               IF (PRESSURE_CORRECTION) CALL H2CZIS(XS,XF,IBAR,3,ZS,ZF,KBAR,3,M%HX,XLM,ITRN,IERR,M%SAVE2)
            ENDIF
            IF (TWO_D .AND. CYLINDRICAL) THEN
               IF (XS==0._EB .AND. LBC==1) LBC = 5
               IF (XS==0._EB .AND. LBC==2) LBC = 6
               IF (XS==0._EB .AND. LBC==3) LBC = 6
               IF (XS==0._EB .AND. LBC==4) LBC = 5
               CALL H2CYIS(XS,XF,IBAR,LBC,ZS,ZF,KBAR,NBC,XLM,XMU,ITRN,IERR,M%SAVE)
            ENDIF
         CASE (2) SELECT_POISSON_SOLVER
            CALL H3CZIS(YS,YF,JBAR,MBC,XS,XF,IBAR,LBC,ZS,ZF,KBAR,NBC,M%HY,XLM,ITRN,JTRN,IERR,M%SAVE)
         CASE (3) SELECT_POISSON_SOLVER
            IF (.NOT.TWO_D) CALL H3CZIS(ZS,ZF,KBAR,NBC,YS,YF,JBAR,MBC,XS,XF,IBAR,LBC,M%HZ,XLM,ITRN,JTRN,IERR,M%SAVE)
            IF (TWO_D) CALL H2CZIS(ZS,ZF,KBAR,NBC,XS,XF,IBAR,LBC,M%HZ,XLM,ITRN,IERR,M%SAVE)
         CASE (4) SELECT_POISSON_SOLVER
            CALL H3CSIS(XS,XF,IBAR,LBC,YS,YF,JBAR,MBC,ZS,ZF,KBAR,NBC,XLM,ITRN,JTRN,IERR,M%SAVE,M%WORK,M%HX,M%HY)
         CASE (5) SELECT_POISSON_SOLVER
            IF (.NOT.TWO_D) CALL H3CSIS(XS,XF,IBAR,LBC,ZS,ZF,KBAR,NBC,YS,YF,JBAR,MBC,XLM,ITRN,JTRN,IERR,M%SAVE,M%WORK,M%HX,M%HZ)
            IF (TWO_D) CALL H2CZIS(ZS,ZF,KBAR,NBC,XS,XF,IBAR,LBC,M%HZ,XLM,ITRN,IERR,M%SAVE)
         CASE (6) SELECT_POISSON_SOLVER
            CALL H3CSIS(ZS,ZF,KBAR,NBC,YS,YF,JBAR,MBC,XS,XF,IBAR,LBC,XLM,ITRN,JTRN,IERR,M%SAVE,M%WORK,M%HZ,M%HY)
         CASE (7) SELECT_POISSON_SOLVER
            CALL H2CZIS(XS,XF,IBAR,LBC,YS,YF,JBAR,MBC,M%HX,XLM,ITRN,IERR,M%SAVE)
 
      END SELECT SELECT_POISSON_SOLVER
 
! Check for errors with Poisson solver initialization
 
IF (IERR/=0) THEN
   WRITE(MESSAGE,'(A,I2,A,I3)') 'ERROR: Poisson initialization error, Number=',IERR, ', Mesh=',NM
   CALL SHUTDOWN(MESSAGE)
ENDIF
 
END SUBROUTINE INITIALIZE_POISSON_SOLVER
 
 
SUBROUTINE INITIAL_NOISE

! Generate random noise at the start of the simulation
 
REAL(EB) :: VFAC,RN
INTEGER  :: I,J,K
 
IF (EVACUATION_ONLY(NM)) RETURN
 
VFAC = 0.005_EB
 
DO K=0,M%KBAR
   DO J=0,M%JBAR
      LOOP_1: DO I=1,M%IBAR
         IF (M%SOLID(M%CELL_INDEX(I,J,K))   .OR. M%SOLID(M%CELL_INDEX(I,J,K+1)) .OR. &
             M%SOLID(M%CELL_INDEX(I,J+1,K)) .OR. M%SOLID(M%CELL_INDEX(I,J+1,K+1)))  CYCLE LOOP_1
         CALL RANDOM_NUMBER(RN)
         RN = VFAC*(-1._EB + 2._EB*RN)*M%DXMIN
         M%W(I,J,K)   = M%W(I,J,K)   - RN*M%RDY(J)
         M%W(I,J+1,K) = M%W(I,J+1,K) + RN*M%RDY(J+1)
         M%V(I,J,K)   = M%V(I,J,K)   + RN*M%RDZ(K)
         M%V(I,J,K+1) = M%V(I,J,K+1) - RN*M%RDZ(K+1)
      ENDDO LOOP_1
   ENDDO
ENDDO
DO K=0,M%KBAR
   DO J=1,M%JBAR
      LOOP_2: DO I=0,M%IBAR
         IF (M%SOLID(M%CELL_INDEX(I,J,K))   .OR. M%SOLID(M%CELL_INDEX(I,J,K+1)) .OR. &
             M%SOLID(M%CELL_INDEX(I+1,J,K)) .OR. M%SOLID(M%CELL_INDEX(I+1,J,K+1)))  CYCLE LOOP_2
         CALL RANDOM_NUMBER(RN)
         RN = VFAC*(-1._EB + 2._EB*RN)*M%DXMIN
         M%W(I,J,K)   = M%W(I,J,K)   - RN*M%RDX(I)*M%R(I)*M%RRN(I)
         M%W(I+1,J,K) = M%W(I+1,J,K) + RN*M%RDX(I+1)*M%R(I)*M%RRN(I+1)
         M%U(I,J,K)   = M%U(I,J,K)   + RN*M%RDZ(K)
         M%U(I,J,K+1) = M%U(I,J,K+1) - RN*M%RDZ(K+1)
      ENDDO LOOP_2
   ENDDO
ENDDO
DO K=1,M%KBAR
   DO J=0,M%JBAR
      LOOP_3: DO I=0,M%IBAR
         IF (M%SOLID(M%CELL_INDEX(I,J,K))   .OR. M%SOLID(M%CELL_INDEX(I,J+1,K)) .OR. &
             M%SOLID(M%CELL_INDEX(I+1,J,K)) .OR. M%SOLID(M%CELL_INDEX(I+1,J+1,K)))  CYCLE LOOP_3
         CALL RANDOM_NUMBER(RN)
         RN = VFAC*(-1._EB + 2._EB*RN)*M%DXMIN
         M%V(I,J,K)   = M%V(I,J,K)   - RN*M%RDX(I)
         M%V(I+1,J,K) = M%V(I+1,J,K) + RN*M%RDX(I+1)
         M%U(I,J,K)   = M%U(I,J,K)   + RN*M%RDY(J)
         M%U(I,J+1,K) = M%U(I,J+1,K) - RN*M%RDY(J+1)
      ENDDO LOOP_3
   ENDDO
ENDDO
 
END SUBROUTINE INITIAL_NOISE
 
 
SUBROUTINE INITIALIZE_DEVC

INTEGER :: III
TYPE (DEVICE_TYPE), POINTER :: DV
 
DEVICE_LOOP: DO N=1,N_DEVC
   DV => DEVICE(N)
   IF (NM/=DV%MESH .OR. DV%OUTPUT_INDEX>0)  CYCLE DEVICE_LOOP
   II  = GINV(DV%X-M%XS,1,NM)*M%RDXI   + 1._EB
   JJ  = GINV(DV%Y-M%YS,2,NM)*M%RDETA  + 1._EB
   KK  = GINV(DV%Z-M%ZS,3,NM)*M%RDZETA + 1._EB
   IOR = DV%IOR
   CALL GET_IW(II,JJ,KK,IOR,IW)
   IF (IW>0) THEN
      DV%IW = IW
      IF (DV%OUTPUT_INDEX==-6) THEN
         IBC = M%IJKW(5,IW)
         IF (SURFACE(IBC)%THERMAL_BC_INDEX /= THERMALLY_THICK) THEN
            WRITE(MESSAGE,'(A,I3,A)') 'DEViCe ',N, ' must be associated with a heat-conducting surface'
            CALL SHUTDOWN(MESSAGE)
         ENDIF
         DV%I_DEPTH = SURFACE(IBC)%N_CELLS
         DO III=SURFACE(IBC)%N_CELLS,1,-1
            IF (DV%DEPTH<=SURFACE(IBC)%X_S(III)) DV%I_DEPTH = III
         ENDDO
      ENDIF
   ELSE
      WRITE(MESSAGE,'(A,I4,A)') 'Reposition DEVC No.',DV%ORDINAL, '. FDS cannot determine which boundary cell to assign'
      CALL SHUTDOWN(MESSAGE)
   ENDIF
ENDDO DEVICE_LOOP
 
END SUBROUTINE INITIALIZE_DEVC
 
 
SUBROUTINE INITIALIZE_PROF

INTEGER :: NN
LOGICAL :: SUCCESS
TYPE (PROFILE_TYPE), POINTER :: PF

PROF_LOOP: DO N=1,N_PROF
   PF => PROFILE(N)
   IF (NM/=PF%MESH) CYCLE PROF_LOOP
   II  = GINV(PF%X-M%XS,1,NM)*M%RDXI   + 1._EB
   JJ  = GINV(PF%Y-M%YS,2,NM)*M%RDETA  + 1._EB
   KK  = GINV(PF%Z-M%ZS,3,NM)*M%RDZETA + 1._EB
   IOR = PF%IOR
   CALL GET_IW(II,JJ,KK,IOR,IW)
   IF (IW>0) THEN
      PF%IW = IW
      SF => SURFACE(IJKW(5,IW))
      IF (.NOT.SF%THERMALLY_THICK) THEN
         WRITE(MESSAGE,'(A,I3,A)') 'PROFile ',N, ' must be associated with a heat-conducting surface'
         CALL SHUTDOWN(MESSAGE)
      ENDIF
      IF (PF%QUANTITY /= 'TEMPERATURE' .AND. PF%QUANTITY /= 'DENSITY') THEN
         SUCCESS = .FALSE.
         DO NN=1,SF%N_MATL
            IF (PF%QUANTITY==SF%MATL_NAME(NN)) SUCCESS = .TRUE.
         ENDDO
         IF (.NOT.SUCCESS) THEN
            WRITE(MESSAGE,'(A,A,A)') 'QUANTITY ',TRIM(PF%QUANTITY), ' is not appropriate for the designated location'
            CALL SHUTDOWN(MESSAGE)
         ENDIF
      ENDIF
   ELSE
      WRITE(MESSAGE,'(A,I4,A)') 'Reposition PROF No.',PF%ORDINAL, '. FDS cannot determine which boundary cell to assign'
      CALL SHUTDOWN(MESSAGE)
   ENDIF
ENDDO PROF_LOOP
 
END SUBROUTINE INITIALIZE_PROF


SUBROUTINE GET_IW(II,JJ,KK,IOR,IW)

INTEGER :: II,JJ,KK,IOR,IW

IC  = M%CELL_INDEX(II,JJ,KK)
 
IF (M%SOLID(IC)) THEN
   SELECT CASE(IOR)
      CASE(-1)
         IF (II>0)      II = II-1
      CASE( 1)
         IF (II<M%IBP1) II = II+1
      CASE(-2)
         IF (JJ>0)      JJ = JJ-1
      CASE( 2)
         IF (JJ<M%JBP1) JJ = JJ+1
      CASE(-3)
         IF (KK>0)      KK = KK-1
      CASE( 3)
         IF (KK<M%KBP1) KK = KK+1
   END SELECT
ENDIF
 
IC  = M%CELL_INDEX(II,JJ,KK)
IW  = M%WALL_INDEX(IC,-IOR)
 
IF (IW<=0) THEN
   SELECT CASE(IOR)
      CASE(-1)
         IF (II>0)      IC = M%CELL_INDEX(II-1,JJ,KK)
      CASE( 1)
         IF (II<M%IBP1) IC = M%CELL_INDEX(II+1,JJ,KK)
      CASE(-2)
         IF (JJ>0)      IC = M%CELL_INDEX(II,JJ-1,KK)
      CASE( 2)
         IF (JJ<M%JBP1) IC = M%CELL_INDEX(II,JJ+1,KK)
      CASE(-3)
         IF (KK>0)      IC = M%CELL_INDEX(II,JJ,KK-1)
      CASE( 3)
         IF (KK<M%KBP1) IC = M%CELL_INDEX(II,JJ,KK+1)
   END SELECT
   IW = M%WALL_INDEX(IC,-IOR)
ENDIF

END SUBROUTINE GET_IW



SUBROUTINE INITIALIZE_INTERPOLATION
 
! Create arrays by which info is to exchanged across meshes
 
INTEGER :: NOM,I,J,K
TYPE (MESH_TYPE), POINTER :: M2
 
IF (NM==1) RETURN
 
ALLOCATE(M%INTERPOLATED_MESH(1:M%IBAR,1:M%JBAR,1:M%KBAR),  STAT=IZERO)
CALL ChkMemErr('INIT','INTERPOLATED_MESH',IZERO)  
M%INTERPOLATED_MESH = 0
 
DO K=1,M%KBAR
   DO J=1,M%JBAR
      DO I=1,M%IBAR
         OTHER_MESH_LOOP: DO NOM=1,NM-1
            M2=>MESHES(NOM)
            IF (M%X(I-1)>=M2%XS .AND. M%X(I)<=M2%XF .AND.  M%Y(J-1)>=M2%YS .AND. M%Y(J)<=M2%YF .AND. &
                M%Z(K-1)>=M2%ZS .AND. M%Z(K)<=M2%ZF) THEN 
               M%INTERPOLATED_MESH(I,J,K) = NOM
               EXIT OTHER_MESH_LOOP
            ENDIF
         ENDDO OTHER_MESH_LOOP
      ENDDO
   ENDDO
ENDDO
 
END SUBROUTINE INITIALIZE_INTERPOLATION
 
END SUBROUTINE INITIALIZE_MESH_VARIABLES
 
 
 
SUBROUTINE INITIALIZE_GLOBAL_VARIABLES
USE CONTROL_VARIABLES, ONLY: N_CTRL
! Initialize time, printout and plot clocks
 
ALLOCATE(PART_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','PART_CLOCK',IZERO) 
ALLOCATE(ISOF_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','ISOF_CLOCK',IZERO) 
ALLOCATE(BNDF_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','BNDF_CLOCK',IZERO) 
ALLOCATE(SLCF_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','SLCF_CLOCK',IZERO) 
ALLOCATE(CORE_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','CORE_CLOCK',IZERO) 
ALLOCATE(PL3D_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','PL3D_CLOCK',IZERO) 
ALLOCATE(PROF_CLOCK(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','PROF_CLOCK',IZERO) 
 
ICYC              = 0
PART_CLOCK        = T_BEGIN
DEVC_CLOCK        = T_BEGIN      
CTRL_CLOCK        = T_BEGIN      
PROF_CLOCK        = T_BEGIN      
PL3D_CLOCK        = T_BEGIN + DT_PL3D
ISOF_CLOCK        = T_BEGIN      
SLCF_CLOCK        = T_BEGIN   
BNDF_CLOCK        = T_BEGIN     
CORE_CLOCK        = T_BEGIN + DT_RESTART
HRR_CLOCK         = T_BEGIN
MINT_CLOCK        = T_BEGIN      

IF (N_DEVC==0) DEVC_CLOCK = 1.E10_EB
IF (N_CTRL==0) CTRL_CLOCK = 1.E10_EB
IF (N_PROF==0) PROF_CLOCK = 1.E10_EB
IF (N_ISOF==0) ISOF_CLOCK = 1.E10_EB
IF (N_BNDF==0) BNDF_CLOCK = 1.E10_EB

ALLOCATE(HRR(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','HRR',IZERO) 
HRR = 0._EB
ALLOCATE(RHRR(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','RHRR',IZERO) 
RHRR = 0._EB
ALLOCATE(CHRR(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','CHRR',IZERO) 
CHRR = 0._EB
ALLOCATE(FHRR(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','FHRR',IZERO) 
FHRR = 0._EB
ALLOCATE(MLR(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','MLR',IZERO) 
MLR = 0._EB
ALLOCATE(FUEL_DROPLET_MLR(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','FUEL_DROPLET_MLR',IZERO) 
FUEL_DROPLET_MLR = 0._EB
ALLOCATE(HRR_SUM(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','HRR_SUM',IZERO)  
HRR_SUM=0._EB
ALLOCATE(RHRR_SUM(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','RHRR_SUM',IZERO) 
RHRR_SUM=0._EB
ALLOCATE(CHRR_SUM(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','CHRR_SUM',IZERO) 
CHRR_SUM=0._EB
ALLOCATE(FHRR_SUM(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','FHRR_SUM',IZERO) 
FHRR_SUM=0._EB
ALLOCATE(MLR_SUM(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','MLR_SUM',IZERO)  
MLR_SUM=0._EB
ALLOCATE(HRR_COUNT(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','MLR_COUNT',IZERO)  
HRR_COUNT=0._EB
ALLOCATE(MINT(0:MAX_SPECIES,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','MINT',IZERO) 
ALLOCATE(MINT_SUM(0:MAX_SPECIES,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','MINT_SUM',IZERO) 
MINT_SUM=0._EB
ALLOCATE(MINT_COUNT(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','MINT_COUNT',IZERO) 
MINT_COUNT=0._EB
ALLOCATE(I_MIN(NMESHES,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','I_MIN',IZERO) 
I_MIN = -10
ALLOCATE(I_MAX(NMESHES,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','I_MAX',IZERO) 
I_MAX = -10
ALLOCATE(J_MIN(NMESHES,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','J_MIN',IZERO) 
J_MIN = -10
ALLOCATE(J_MAX(NMESHES,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','J_MAX',IZERO) 
J_MAX = -10
ALLOCATE(K_MIN(NMESHES,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','K_MIN',IZERO) 
K_MIN = -10
ALLOCATE(K_MAX(NMESHES,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','K_MAX',IZERO) 
K_MAX = -10
ALLOCATE(NIC(NMESHES,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','NIC',IZERO) 
NIC = 0
ALLOCATE(T_PER_STEP(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','T_PER_STEP',IZERO) 
T_PER_STEP = 0._EB
ALLOCATE(T_ACCUM(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','T_ACCUM',IZERO) 
T_ACCUM = 0._EB
ALLOCATE(NTCYC(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','NTCYC',IZERO) 
NTCYC = 0
ALLOCATE(NCYC(NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','NCYC',IZERO) 
NCYC = 0

ALLOCATE(DSUM(N_ZONE,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','DSUM',IZERO) 
DSUM = 0._EB
ALLOCATE(PSUM(N_ZONE,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','PSUM',IZERO) 
PSUM = 0._EB
ALLOCATE(USUM(N_ZONE,NMESHES),STAT=IZERO)
CALL ChkMemErr('INIT','USUM',IZERO) 
USUM = 0._EB
 
END SUBROUTINE INITIALIZE_GLOBAL_VARIABLES
 
 

SUBROUTINE INIT_WALL_CELL(NM,I,J,K,I_OBST,IW,IOR,IBC)

! Initialize wall cell variables at external and obstruction boundaries
 
USE GEOMETRY_FUNCTIONS, ONLY : SEARCH_OTHER_MESHES
INTEGER  :: NM,NOM,ICO,IBC,IOR,ITER,IIO_MIN,IIO_MAX,JJO_MIN,JJO_MAX,KKO_MIN,KKO_MAX
REAL(EB) :: PX,PY,PZ,X1,X2,Y1,Y2,Z1,Z2,T_ACTIVATE,XIN,YIN,ZIN,DIST,XIF,YIF,ZIF
INTEGER  :: II,N,NN,I_OBST,I,J,K,IBCX,IIG,JJG,KKG,IW,IIO,JJO,KKO,ICG,IL,NOM_CHECK(0:1)
LOGICAL :: VENT_FOUND
TYPE (MESH_TYPE), POINTER :: MM
TYPE (WALL_TYPE), POINTER :: WC
TYPE (OBSTRUCTION_TYPE), POINTER :: OBX
TYPE (VENTS_TYPE), POINTER :: VT
 
M=>MESHES(NM)
 
! Compute boundary cell physical coords (XW,YW,ZW) and area (AW)
 
IBCX         = IBC
M%IJKW(1,IW) = I
M%IJKW(2,IW) = J
M%IJKW(3,IW) = K
M%IJKW(4,IW) = IOR
M%IJKW(5,IW) = IBCX
M%OBST_INDEX_W(IW) = I_OBST
 
IF (ABS(IOR)==1) THEN
   IF (IOR== 1) THEN
      M%XW(IW)     = M%X(I)
      M%IJKW(6,IW) = I+1
      M%RDN(IW)    = M%RDXN(I) 
      M%AW(IW)     = M%R(I)*M%DY(J)*M%DZ(K)
      M%UW(IW)     = -U0
   ENDIF
   IF (IOR==-1) THEN
      M%XW(IW)     = M%X(I-1)
      M%IJKW(6,IW) = I-1
      M%RDN(IW)    = M%RDXN(I-1) 
      M%AW(IW)     = M%R(I-1)*M%DY(J)*M%DZ(K)
      M%UW(IW)     = U0
   ENDIF
   M%IJKW(7,IW) = J
   M%IJKW(8,IW) = K
   M%YW(IW) = 0.5_EB*(M%Y(J)+M%Y(J-1))  
   M%ZW(IW) = 0.5_EB*(M%Z(K)+M%Z(K-1))
ENDIF
IF (ABS(IOR)==2) THEN
   IF (IOR== 2) THEN
      M%YW(IW)     = M%Y(J)
      M%IJKW(7,IW) = J+1
      M%RDN(IW)    = M%RDYN(J) 
      M%UW(IW)     = -V0
   ENDIF
   IF (IOR==-2) THEN
      M%YW(IW)     = M%Y(J-1)
      M%IJKW(7,IW) = J-1
      M%RDN(IW)    = M%RDYN(J-1) 
      M%UW(IW)     = V0
   ENDIF
   M%IJKW(6,IW) = I
   M%IJKW(8,IW) = K
   M%XW(IW) = 0.5_EB*(M%X(I)+M%X(I-1))
   M%ZW(IW) = 0.5_EB*(M%Z(K)+M%Z(K-1))
   M%AW(IW) = M%DX(I)*M%DZ(K)
ENDIF
IF (ABS(IOR)==3) THEN
   IF (IOR== 3) THEN
      M%ZW(IW)     = M%Z(K)
      M%IJKW(8,IW) = K+1
      M%RDN(IW)    = M%RDZN(K) 
      M%UW(IW)     = -W0
   ENDIF
   IF (IOR==-3) THEN
      M%ZW(IW)     = M%Z(K-1)
      M%IJKW(8,IW) = K-1
      M%RDN(IW)    = M%RDZN(K-1) 
      M%UW(IW)     = W0
   ENDIF
   M%IJKW(6,IW) = I
   M%IJKW(7,IW) = J
   M%XW(IW) = 0.5_EB*(M%X(I)+M%X(I-1))
   M%YW(IW) = 0.5_EB*(M%Y(J)+M%Y(J-1))
   M%AW(IW) = M%DX(I)*M%RC(I)*M%DY(J)
ENDIF
 
IF (M%AW(IW)>0._EB) M%RAW(IW) = 1._EB/M%AW(IW)

! Gas phase cell abutting boundary cell

IIG = M%IJKW(6,IW)
JJG = M%IJKW(7,IW)
KKG = M%IJKW(8,IW)

! Use IWA to indicate the boundary cell number, IW, at the various faces of a grid cell
 
ICG = M%CELL_INDEX(IIG,JJG,KKG)
M%WALL_INDEX(ICG,-IOR) = IW

! Use BOUNDARY_TYPE to indicate whether the boundary cell is blocked or on an obstruction that is HIDDEN

M%BOUNDARY_TYPE(IW) = SOLID_BOUNDARY
IF (M%SOLID(ICG)) M%BOUNDARY_TYPE(IW) = NULL_BOUNDARY
IF (I_OBST > 0 .AND. M%OBSTRUCTION(I_OBST)%HIDDEN) M%BOUNDARY_TYPE(IW) = NULL_BOUNDARY

IF (SURFACE(IBC)%POROUS .AND. M%BOUNDARY_TYPE(IW)==SOLID_BOUNDARY) M%BOUNDARY_TYPE(IW) = POROUS_BOUNDARY

! Assign the ZONE number to all boundary cells

M%PRESSURE_ZONE_WALL(IW) = M%PRESSURE_ZONE(IIG,JJG,KKG)
 
! Check for neighboring meshes in a multiple mesh calculation
 
CHECK_MESHES: IF (IW<=M%NEWC .AND.  .NOT.EVACUATION_ONLY(NM)) THEN
 
   IIO_MIN =  1000000
   IIO_MAX = -1000000
   JJO_MIN =  1000000
   JJO_MAX = -1000000
   KKO_MIN =  1000000
   KKO_MAX = -1000000
   NOM_CHECK = 0
   DO ITER=0,1
      XIN = M%XW(IW)
      YIN = M%YW(IW)
      ZIN = M%ZW(IW)
      IF (ABS(IOR)/=1) XIN = M%XW(IW) - 0.4_EB*M%DX(I) + ITER*0.8_EB*M%DX(I)
      IF (ABS(IOR)/=2) YIN = M%YW(IW) - 0.4_EB*M%DY(J) + ITER*0.8_EB*M%DY(J)
      IF (ABS(IOR)/=3) ZIN = M%ZW(IW) - 0.4_EB*M%DZ(K) + ITER*0.8_EB*M%DZ(K)
      IF (IOR== 1) XIN = XIN - 0.05*M%DX(0)
      IF (IOR==-1) XIN = XIN + 0.05*M%DX(M%IBP1)
      IF (IOR== 2) YIN = YIN - 0.05*M%DY(0)
      IF (IOR==-2) YIN = YIN + 0.05*M%DY(M%JBP1)
      IF (IOR== 3) ZIN = ZIN - 0.05*M%DZ(0)
      IF (IOR==-3) ZIN = ZIN + 0.05*M%DZ(M%KBP1)
      CALL SEARCH_OTHER_MESHES(NM,XIN,YIN,ZIN,NOM,IIO,JJO,KKO,XIF,YIF,ZIF) 
      NOM_CHECK(ITER) = NOM
      IIO_MIN = MIN(IIO_MIN,IIO)
      IIO_MAX = MAX(IIO_MAX,IIO)
      JJO_MIN = MIN(JJO_MIN,JJO)
      JJO_MAX = MAX(JJO_MAX,JJO)
      KKO_MIN = MIN(KKO_MIN,KKO)
      KKO_MAX = MAX(KKO_MAX,KKO)
   ENDDO

   IF (NOM_CHECK(0)/=NOM_CHECK(1)) THEN
      WRITE(MESSAGE,'(A,I3,A,I3)') 'ERROR: MESH ',NM,' is out of alignment with MESH ',MAXVAL(NOM_CHECK)
      CALL SHUTDOWN(MESSAGE)
   ENDIF

   FOUND_OTHER_MESH: IF (NOM>0) THEN 
      MM=>MESHES(NOM)
      IF (ABS(IOR)==1) M%INTERPOLATION_FACTOR(IW) = XIF
      IF (ABS(IOR)==2) M%INTERPOLATION_FACTOR(IW) = YIF
      IF (ABS(IOR)==3) M%INTERPOLATION_FACTOR(IW) = ZIF
      M%IJKW(9,IW)  = NOM
      M%IJKW(10,IW) = IIO_MIN
      M%IJKW(11,IW) = JJO_MIN
      M%IJKW(12,IW) = KKO_MIN
      M%IJKW(13,IW) = IIO_MAX
      M%IJKW(14,IW) = JJO_MAX
      M%IJKW(15,IW) = KKO_MAX

      IF (I_OBST==0) THEN
         IF (.NOT.M%SOLID(ICG)) M%BOUNDARY_TYPE(IW) = INTERPOLATED_BOUNDARY
         IBCX = INTERPOLATED_SURF_INDEX
         M%IJKW(5,IW) = IBCX
      ENDIF
      ICO = MM%CELL_INDEX(IIO,JJO,KKO)
      IF (.NOT.MM%SOLID(ICO) .AND. .NOT.M%SOLID(ICG))   M%SOLID(M%CELL_INDEX(I,J,K)) = .FALSE.
   ENDIF FOUND_OTHER_MESH
 
ENDIF CHECK_MESHES
 
! Assign internal values of temp, density, and mass fraction
 
IF (N_SPECIES>0) THEN
   M%RSUM_W(IW)= M%RSUM(IIG,JJG,KKG)
   M%RSUM(I,J,K) = M%RSUM(IIG,JJG,KKG)
   M%YY_W(IW,1:N_SPECIES)  = M%YY(IIG,JJG,KKG,1:N_SPECIES)
   M%YY(I,J,K,1:N_SPECIES) = M%YY(IIG,JJG,KKG,1:N_SPECIES)
ENDIF
 
M%RHO_W(IW) = M%RHO(IIG,JJG,KKG)
M%TMP_W(IW) = M%TMP(IIG,JJG,KKG)
 
! Assign various other quantities to the cell
 
IF (I_OBST>0) THEN
   OBX=>M%OBSTRUCTION(I_OBST)
   M%AREA_ADJUST(IW) = OBX%INPUT_AREA(ABS(IOR))/OBX%FDS_AREA(ABS(IOR))
   IF (M%AREA_ADJUST(IW)==0._EB) M%AREA_ADJUST(IW) = 1._EB
   OBX%MASS = SURFACE(IBC)%SURFACE_DENSITY*M%AW(IW)*M%AREA_ADJUST(IW)
ENDIF
 
! Prescribe exit velocity for surface cell
 
IF (SURFACE(IBCX)%VEL/=-999._EB) THEN
   M%UW0(IW) = SURFACE(IBCX)%VEL
ELSE
   M%UW0(IW) = 0._EB
ENDIF
IF (I_OBST>0 .AND. SURFACE(IBCX)%VOLUME_FLUX/=-999._EB) THEN
   OBX=>M%OBSTRUCTION(I_OBST)
   M%UW0(IW) = SURFACE(IBCX)%VOLUME_FLUX/OBX%FDS_AREA(ABS(IOR))
ENDIF
IF (I_OBST>0 .AND. SURFACE(IBCX)%MASS_FLUX_TOTAL/=-999._EB) THEN
   OBX=>M%OBSTRUCTION(I_OBST)
   M%UW0(IW) = SURFACE(IBCX)%MASS_FLUX_TOTAL / RHOA * M%AREA_ADJUST(IW)
ENDIF
 
T_ACTIVATE = -1._EB
VENT_FOUND = .FALSE.
 
! Check if there is a vent embedded in the surface
 
VLOOP: DO N=1,M%N_VENT
 
   VT => M%VENTS(N)
   IF (I_OBST>0) THEN
      IF (VT%BOUNDARY_TYPE==OPEN_BOUNDARY)       CYCLE VLOOP
      IF (.NOT.M%OBSTRUCTION(I_OBST)%ALLOW_VENT) CYCLE VLOOP
   ENDIF
   IF (VT%IOR/=IOR) CYCLE VLOOP
   IF (IBCX==INTERPOLATED_SURF_INDEX) CYCLE VLOOP
   IF ((VT%BOUNDARY_TYPE==OPEN_BOUNDARY .OR. VT%BOUNDARY_TYPE==MIRROR_BOUNDARY) .AND.M%IJKW(9,IW)>0) CYCLE VLOOP
 
   IF (ABS(IOR)==1) THEN
      IF (IOR== 1 .AND. I/=VT%I1  ) CYCLE VLOOP
      IF (IOR==-1 .AND. I/=VT%I1+1) CYCLE VLOOP
      IF (J<VT%J1+1 .OR. J>VT%J2)   CYCLE VLOOP
      IF (K<VT%K1+1 .OR. K>VT%K2)   CYCLE VLOOP
   ENDIF
   IF (ABS(IOR)==2) THEN
      IF (IOR== 2 .AND. J/=VT%J1  ) CYCLE VLOOP
      IF (IOR==-2 .AND. J/=VT%J1+1) CYCLE VLOOP
      IF (I<VT%I1+1 .OR. I>VT%I2)   CYCLE VLOOP
      IF (K<VT%K1+1 .OR. K>VT%K2)   CYCLE VLOOP
   ENDIF
   IF (ABS(IOR)==3) THEN
      IF (IOR== 3 .AND. K/=VT%K1  ) CYCLE VLOOP
      IF (IOR==-3 .AND. K/=VT%K1+1) CYCLE VLOOP
      IF (I<VT%I1+1 .OR. I>VT%I2)   CYCLE VLOOP
      IF (J<VT%J1+1 .OR. J>VT%J2)   CYCLE VLOOP
   ENDIF
 
   ! Check if there are over-lapping VENTs
  
   IF (VENT_FOUND) THEN
      WRITE(MESSAGE,'(A,I0,A,3(I0,1X),A,I0,A)') 'WARNING: Two VENTs overlap in MESH ',NM,', Cell',I,J,K,'. VENT ', &
                                           VT%ORDINAL,' rejected for that cell'
      WRITE(0,'(/A/)') MESSAGE
      EXIT VLOOP
   ENDIF

   VENT_FOUND = .TRUE.

   ! Reassign the SURF index to be that of the VENT

   M%VENT_INDEX(IW) = N
   IBCX = VT%IBC
   M%AREA_ADJUST(IW) = VT%INPUT_AREA/VT%FDS_AREA
   IF (M%AREA_ADJUST(IW)==0._EB) M%AREA_ADJUST(IW) = 1._EB
 
   ! Set the velocity at each surface cell
 
   IF (SURFACE(IBCX)%VEL/=-999._EB) THEN
      M%UW0(IW) = SURFACE(IBCX)%VEL
   ELSE
      M%UW0(IW) = 0._EB
   ENDIF
 
   IF (SURFACE(IBCX)%VOLUME_FLUX    /=-999._EB)   M%UW0(IW) = SURFACE(IBCX)%VOLUME_FLUX/VT%TOTAL_INPUT_AREA
   IF (SURFACE(IBCX)%MASS_FLUX_TOTAL/=-999._EB)   M%UW0(IW) = SURFACE(IBCX)%MASS_FLUX_TOTAL/RHOA*M%AREA_ADJUST(IW)   
 
   ! Special velocity profiles
 
   IF (SURFACE(IBCX)%PROFILE==PARABOLIC) THEN 
      SELECT CASE(ABS(IOR))
         CASE(1)
            Y1 = M%Y(VT%J1)
            Y2 = M%Y(VT%J2)
            Z1 = M%Z(VT%K1)
            Z2 = M%Z(VT%K2)
            PY = 4._EB*(M%YC(J)-Y1)*(Y2-M%YC(J))/(Y2-Y1)**2
            PZ = 4._EB*(M%ZC(K)-Z1)*(Z2-M%ZC(K))/(Z2-Z1)**2
            M%UW0(IW) = M%UW0(IW)*PY*PZ
         CASE(2)
            X1 = M%X(VT%I1)
            X2 = M%X(VT%I2)
            Z1 = M%Z(VT%K1)
            Z2 = M%Z(VT%K2)
            PX = 4._EB*(M%XC(I)-X1)*(X2-M%XC(I))/(X2-X1)**2
            PZ = 4._EB*(M%ZC(K)-Z1)*(Z2-M%ZC(K))/(Z2-Z1)**2
            M%UW0(IW) = M%UW0(IW)*PX*PZ
         CASE(3)
            X1 = M%X(VT%I1)
            X2 = M%X(VT%I2)
            IF (CYLINDRICAL .AND. X1==0._EB) X1 = -X2
            Y1 = M%Y(VT%J1)
            Y2 = M%Y(VT%J2)
            PX = 4._EB*(M%XC(I)-X1)*(X2-M%XC(I))/(X2-X1)**2
            PY = 4._EB*(M%YC(J)-Y1)*(Y2-M%YC(J))/(Y2-Y1)**2
            IF (CYLINDRICAL) THEN
               M%UW0(IW) = M%UW0(IW)*PX
               ELSE
               M%UW0(IW) = M%UW0(IW)*PX*PY
               ENDIF
      END SELECT
   ENDIF
 
   IF (SURFACE(IBCX)%PROFILE==ATMOSPHERIC) THEN
      IF (M%ZC(K)<GROUND_LEVEL) THEN
         WRITE(MESSAGE,'(A,A,A)') 'ERROR: SURF ',TRIM(SURF_NAME(IBCX)),' cannot be applied below GROUND_LEVEL'
         CALL SHUTDOWN(MESSAGE)
      ENDIF
      M%UW0(IW) = M%UW0(IW)*((M%ZC(K)-GROUND_LEVEL)/SURFACE(IBCX)%Z0)**SURFACE(IBCX)%PLE
   ENDIF
 
   IF (SURFACE(IBCX)%PROFILE==ONED_PARABOLIC) THEN 
      SELECT CASE(ABS(IOR))
         CASE(1)
            Y1 = M%Y(VT%J1)
            Y2 = M%Y(VT%J2)
            PY = 4._EB*(M%YC(J)-Y1)*(Y2-M%YC(J))/(Y2-Y1)**2
            M%UW0(IW) = M%UW0(IW)*PY
         CASE(2)
            X1 = M%X(VT%I1)
            X2 = M%X(VT%I2)
            PX = 4._EB*(M%XC(I)-X1)*(X2-M%XC(I))/(X2-X1)**2
            M%UW0(IW) = M%UW0(IW)*PX
         CASE(3)
            X1 = M%X(VT%I1)
            X2 = M%X(VT%I2)
            Y1 = M%Y(VT%J1)
            Y2 = M%Y(VT%J2)
            PX = 4._EB*(M%XC(I)-X1)*(X2-M%XC(I))/(X2-X1)**2
            PY = 4._EB*(M%YC(J)-Y1)*(Y2-M%YC(J))/(Y2-Y1)**2
            M%UW0(IW) = M%UW0(IW)*PX*PY
      END SELECT
   ENDIF
 
   ! Check if fire spreads radially
 
   IF (VT%X0>-900._EB .AND. VT%ACTIVATED) THEN
      DIST = SQRT((M%XW(IW)-VT%X0)**2 +(M%YW(IW)-VT%Y0)**2 +(M%ZW(IW)-VT%Z0)**2)
      T_ACTIVATE = T_BEGIN+DIST/VT%FIRE_SPREAD_RATE
   ENDIF

   ! Miscellaneous settings
 
   IF (VT%BOUNDARY_TYPE==OPEN_BOUNDARY) THEN
      M%BOUNDARY_TYPE(IW) = OPEN_BOUNDARY
      IF (M%PRESSURE_ZONE_WALL(IW)>0) THEN
         WRITE(MESSAGE,'(A,I2,A)') 'ERROR: Pressure ZONE ',M%PRESSURE_ZONE_WALL(IW),' cannot have an OPEN boundary'
         CALL SHUTDOWN(MESSAGE)
      ENDIF
   ENDIF

   IF (VT%BOUNDARY_TYPE==MIRROR_BOUNDARY) M%BOUNDARY_TYPE(IW) = MIRROR_BOUNDARY
   IF (.NOT.VT%ACTIVATED) T_ACTIVATE = 1000000._EB
   M%IJKW(5,IW) = IBCX
 
ENDDO VLOOP
 
! Set ignition time of each boundary cell
 
IF (T_ACTIVATE < T_BEGIN) THEN
   M%TW(IW) = SURFACE(IBCX)%T_IGN
ELSE
   M%TW(IW) = T_ACTIVATE
ENDIF
 
! Initialize solid temperature and densities
 
SF => SURFACE(IBCX)
IF (SF%THERMALLY_THICK) THEN
   WC => M%WALL(IW)
   ALLOCATE(WC%TMP_S(0:SF%N_CELLS+1),STAT=IZERO)
   CALL ChkMemErr('INIT','TMP_S',IZERO)
   WC%TMP_S(:)   = SF%TMP_INNER
   ALLOCATE(WC%RHO_S(0:SF%N_CELLS+1,SF%N_MATL),STAT=IZERO)
   CALL ChkMemErr('INIT','RHO_S',IZERO)
   WC%RHO_S = 0._EB
   DO II=0,SF%N_CELLS+1
      IL = SF%LAYER_INDEX(II)
      DO NN=1,SF%N_LAYER_MATL(IL)
         DO N=1,SF%N_MATL
            IF (SF%LAYER_MATL_INDEX(IL,NN)==SF%MATL_INDEX(N)) &
               WC%RHO_S(II,N) = SF%LAYER_MATL_FRAC(IL,NN)*SF%LAYER_DENSITY(IL)
         ENDDO
      ENDDO
   ENDDO
   IF (SF%SHRINK) THEN
      ALLOCATE(WC%LAYER_THICKNESS(SF%N_LAYERS),STAT=IZERO)
      CALL ChkMemErr('INIT','LAYER_THICKNESS',IZERO)
      WC%LAYER_THICKNESS = SF%LAYER_THICKNESS(1:SF%N_LAYERS)
      ALLOCATE(WC%N_LAYER_CELLS(SF%N_LAYERS),STAT=IZERO)
      CALL ChkMemErr('INIT','N_LAYER_CELLS',IZERO)
      WC%N_LAYER_CELLS = SF%N_LAYER_CELLS
      ALLOCATE(WC%X_S(0:SF%N_CELLS),STAT=IZERO)
      CALL ChkMemErr('INIT','X_S',IZERO)
      WC%X_S = SF%X_S
   ENDIF
   WC%SHRINKING = .FALSE.
   WC%BURNAWAY  = .FALSE.
   M%TMP_F(IW) = SF%TMP_INNER
   M%TMP_B(IW) = SF%TMP_INNER
   M%TMP_W(IW) = SF%TMP_INNER
ENDIF

 
! Misc
 
M%E_WALL(IW) = SF%EMISSIVITY
M%NPPCW(IW) = SF%NPPC      ! Number of particles per cell

! Record original boundary condition index for exterior wall cells that might get covered up

IF (I_OBST==0) M%IBC_ORIG(IW) = IBCX

END SUBROUTINE INIT_WALL_CELL
 
 
SUBROUTINE OPEN_AND_CLOSE(T,NM)

! Check to see if a cell or OBSTruction is to be created or removed, or a VENT activated of deactivated

USE MEMORY_FUNCTIONS, ONLY : RE_ALLOCATE_STRINGS
USE CONTROL_VARIABLES, ONLY : CONTROL
USE DEVICE_VARIABLES, ONLY : DEVICE
REAL(EB) :: T
INTEGER  :: N,II,JJ,KK,IW,IOR
INTEGER, INTENT(IN) :: NM
LOGICAL :: CREATE_OBST,REMOVE_OBST,ACTIVATE_VENT,DEACTIVATE_VENT
CHARACTER(12) :: SV_LABEL
TYPE (VENTS_TYPE), POINTER :: VT
 
CALL POINT_TO_MESH(NM)
 
! Check to see if an obstacle is to be removed or created
OBST_LOOP: DO N=1,N_OBST
   OB=>OBSTRUCTION(N)
   IF (.NOT. OB%REMOVABLE) CYCLE OBST_LOOP
   CREATE_OBST = .FALSE.
   REMOVE_OBST = .FALSE.
   IF (OB%CONSUMABLE .AND. OB%MASS <= 0._EB) REMOVE_OBST = .TRUE.

   IF (OB%DEVC_INDEX > 0) THEN
      IF (DEVICE(OB%DEVC_INDEX)%CURRENT_STATE .EQV. DEVICE(OB%DEVC_INDEX)%PRIOR_STATE) CYCLE OBST_LOOP
      IF (DEVICE(OB%DEVC_INDEX)%CURRENT_STATE) THEN
         CREATE_OBST = .TRUE.
      ELSE
         REMOVE_OBST = .TRUE.      
      ENDIF
   ELSEIF (OB%CTRL_INDEX > 0) THEN
      IF (CONTROL(OB%CTRL_INDEX)%CURRENT_STATE .EQV. CONTROL(OB%CTRL_INDEX)%PRIOR_STATE) CYCLE OBST_LOOP
      IF (CONTROL(OB%CTRL_INDEX)%CURRENT_STATE) THEN
         CREATE_OBST = .TRUE.
      ELSE
         REMOVE_OBST = .TRUE.      
      ENDIF
   ENDIF

  SV_LABEL  = 'null'

  IF (CREATE_OBST .AND. OB%HIDDEN) THEN
     OB%HIDDEN = .FALSE.
     SV_LABEL  = 'SHOW_OBST'
     CALL CREATE_OR_REMOVE_OBST(NM,OB%I1+1,OB%I2,OB%J1+1,OB%J2,OB%K1+1,OB%K2,1,N)
  ENDIF

   IF (REMOVE_OBST .AND. (.NOT. OB%HIDDEN)) THEN
      OB%HIDDEN = .TRUE.
      SV_LABEL  = 'HIDE_OBST'
      CALL CREATE_OR_REMOVE_OBST(NM,OB%I1+1,OB%I2,OB%J1+1,OB%J2,OB%K1+1,OB%K2,0,N)
   ENDIF

   ! Write a message to the Smokeview .smv file that the obstruction has been created or removed

   IF (SV_LABEL /= 'null') THEN
      IF (N_STRINGS+2>N_STRINGS_MAX) THEN
         CALL RE_ALLOCATE_STRINGS(NM)
         STRING => MESHES(NM)%STRING
      ENDIF
      N_STRINGS = N_STRINGS + 1
      WRITE(STRING(N_STRINGS),'(A,I3)') SV_LABEL,NM
      N_STRINGS = N_STRINGS + 1
      WRITE(STRING(N_STRINGS),'(I6,F10.2)') N,T
   ENDIF

ENDDO OBST_LOOP
 
! Check to see if a vent should be activated or deactivated
 
VENT_LOOP: DO N=1,N_VENT
   VT => VENTS(N)

   ACTIVATE_VENT   = .FALSE.
   DEACTIVATE_VENT = .FALSE.

   IF (VT%DEVC_INDEX > 0) THEN
      IF (DEVICE(VT%DEVC_INDEX)%CURRENT_STATE .EQV. DEVICE(VT%DEVC_INDEX)%PRIOR_STATE) CYCLE VENT_LOOP
      IF (DEVICE(VT%DEVC_INDEX)%CURRENT_STATE) THEN
         ACTIVATE_VENT   = .TRUE.
      ELSE
         DEACTIVATE_VENT = .TRUE.
      ENDIF
   ELSEIF (VT%CTRL_INDEX > 0) THEN
      IF (CONTROL(VT%CTRL_INDEX)%CURRENT_STATE .EQV. CONTROL(VT%CTRL_INDEX)%PRIOR_STATE) CYCLE VENT_LOOP
      IF (CONTROL(VT%CTRL_INDEX)%CURRENT_STATE) THEN
         ACTIVATE_VENT   = .TRUE.
      ELSE
         DEACTIVATE_VENT = .TRUE.
      ENDIF
   ENDIF

   IF (.NOT.ACTIVATE_VENT .AND. .NOT.DEACTIVATE_VENT) CYCLE VENT_LOOP

   ! Look through all boundary cells looking for those that conform to the given VENT

   SEARCH: DO IW=1,NWC
      II  = IJKW(1,IW)
      JJ  = IJKW(2,IW)
      KK  = IJKW(3,IW)
      IOR = IJKW(4,IW)
      IF (IOR/=VT%IOR) CYCLE SEARCH
      SELECT CASE(ABS(IOR))
         CASE(1)
            IF (IOR== 1 .AND.  II/=VT%I1)   CYCLE SEARCH
            IF (IOR==-1 .AND.  II/=VT%I1+1) CYCLE SEARCH
            IF (JJ<VT%J1+1 .OR. JJ>VT%J2)   CYCLE SEARCH
            IF (KK<VT%K1+1 .OR. KK>VT%K2)   CYCLE SEARCH
         CASE(2)
            IF (IOR== 2 .AND.  JJ/=VT%J1)   CYCLE SEARCH
            IF (IOR==-2 .AND.  JJ/=VT%J1+1) CYCLE SEARCH
            IF (II<VT%I1+1 .OR. II>VT%I2)   CYCLE SEARCH
            IF (KK<VT%K1+1 .OR. KK>VT%K2)   CYCLE SEARCH
         CASE(3)
            IF (IOR== 3 .AND.  KK/=VT%K1)   CYCLE SEARCH
            IF (IOR==-3 .AND.  KK/=VT%K1+1) CYCLE SEARCH
            IF (II<VT%I1+1 .OR. II>VT%I2)   CYCLE SEARCH
            IF (JJ<VT%J1+1 .OR. JJ>VT%J2)   CYCLE SEARCH
      END SELECT
      IF (ACTIVATE_VENT) THEN
         IF (VT%X0>-900._EB) THEN
            TW(IW) = T + SQRT((M%XW(IW)-VT%X0)**2 +(M%YW(IW)-VT%Y0)**2 +(M%ZW(IW)-VT%Z0)**2)/VT%FIRE_SPREAD_RATE
         ELSE
            TW(IW) = T        
         ENDIF
      ELSE
         TW(IW) = 1000000._EB
      ENDIF
   ENDDO SEARCH

   ! Write message to .smv file

   IF (ACTIVATE_VENT)   SV_LABEL = 'OPEN_VENT'
   IF (DEACTIVATE_VENT) SV_LABEL = 'CLOSE_VENT'

   IF (N_STRINGS+2>N_STRINGS_MAX) THEN
      CALL RE_ALLOCATE_STRINGS(NM)
      STRING => MESHES(NM)%STRING
   ENDIF
   N_STRINGS = N_STRINGS + 1
   WRITE(STRING(N_STRINGS),'(A,I3)') SV_LABEL,NM
   N_STRINGS = N_STRINGS + 1
   WRITE(STRING(N_STRINGS),'(I6,F10.2)') N,T

ENDDO VENT_LOOP
 
END SUBROUTINE OPEN_AND_CLOSE
 
 
SUBROUTINE CREATE_OR_REMOVE_OBST(NM,I1,I2,J1,J2,K1,K2,CR_INDEX,OBST_INDEX)

! Create or remove the obstruction whose CELLS (not nodes) are given by I1, I2, etc.

USE GEOMETRY_FUNCTIONS, ONLY : BLOCK_CELL
INTEGER :: I1,I2,J1,J2,K1,K2,I,J,K,IE,IW,IC,ICG
INTEGER, INTENT(IN) :: NM,CR_INDEX,OBST_INDEX
LOGICAL :: CREATE,REMOVE
 
CALL POINT_TO_MESH(NM)

REMOVE = .FALSE.
CREATE = .FALSE.
IF (CR_INDEX==0) REMOVE = .TRUE.
IF (CR_INDEX==1) CREATE = .TRUE.
 
! Blank or unblank cells that make up the OBSTruction
 
CALL BLOCK_CELL(NM,I1,I2,J1,J2,K1,K2,CR_INDEX,OBST_INDEX)
 
! Process the x boundaries of the OBSTruction

DO K=K1,K2
   DO J=J1,J2

      ! Nullify and/or uncover wall cells on the x=x1 side of the OBSTruction

      IF (I1>1 .AND. I1<IBP1) THEN
         ICG = CELL_INDEX(I1-1,J,K)
         IW  = WALL_INDEX(ICG,1)
         IF (REMOVE) BOUNDARY_TYPE(IW) = NULL_BOUNDARY
         IF (CREATE .AND. .NOT.SOLID(ICG)) CALL GET_BOUNDARY_TYPE( IW , IJKW(5,IW) , BOUNDARY_TYPE(IW) )
      ENDIF
      IC = CELL_INDEX(I1,J,K)
      IW = WALL_INDEX(IC,-1)
      IF (IW > 0 .AND. REMOVE) THEN
         IF (IBC_ORIG(IW)>0) CALL RESTORE_ORIGINAL_BC(IW)
         CALL GET_BOUNDARY_TYPE( IW , IJKW(5,IW) , BOUNDARY_TYPE(IW) )
      ENDIF
      IF (CREATE) BOUNDARY_TYPE(IW) = NULL_BOUNDARY

      ! Nullify and/or uncover wall cells on the x=x2 side of the OBSTruction

      IF (I2<IBAR .AND. I2>0) THEN
         ICG = CELL_INDEX(I2+1,J,K)
         IW  = WALL_INDEX(ICG,-1)
         IF (REMOVE) BOUNDARY_TYPE(IW) = NULL_BOUNDARY
         IF (CREATE .AND. .NOT.SOLID(ICG)) CALL GET_BOUNDARY_TYPE( IW , IJKW(5,IW) , BOUNDARY_TYPE(IW) )
      ENDIF
      IC = CELL_INDEX(I2,J,K)
      IW = WALL_INDEX(IC,1)
      IF (IW > 0 .AND. REMOVE) THEN
         IF (IBC_ORIG(IW)>0) CALL RESTORE_ORIGINAL_BC(IW)
         CALL GET_BOUNDARY_TYPE( IW , IJKW(5,IW) , BOUNDARY_TYPE(IW) )
      ENDIF
      IF (CREATE) BOUNDARY_TYPE(IW) = NULL_BOUNDARY
   ENDDO
ENDDO

! Process the y boundaries of the OBSTruction

DO K=K1,K2
   DO I=I1,I2

      ! Nullify and/or uncover wall cells on the y=y1 side of the OBSTruction

      IF (J1>1 .AND. J1<JBP1) THEN
         ICG = CELL_INDEX(I,J1-1,K)
         IW  = WALL_INDEX(ICG,2)
         IF (REMOVE) BOUNDARY_TYPE(IW) = NULL_BOUNDARY
         IF (CREATE .AND. .NOT.SOLID(ICG)) CALL GET_BOUNDARY_TYPE( IW , IJKW(5,IW) , BOUNDARY_TYPE(IW) )
      ENDIF
      IC = CELL_INDEX(I,J1,K)
      IW = WALL_INDEX(IC,-2)
      IF (IW > 0 .AND. REMOVE) THEN 
         IF (IBC_ORIG(IW)>0) CALL RESTORE_ORIGINAL_BC(IW)
         CALL GET_BOUNDARY_TYPE( IW , IJKW(5,IW) , BOUNDARY_TYPE(IW) )
      ENDIF
      IF (CREATE) BOUNDARY_TYPE(IW) = NULL_BOUNDARY

      ! Nullify and/or uncover wall cells on the y=y2 side of the OBSTruction

      IF (J2<JBAR .AND. J2>0) THEN
         ICG = CELL_INDEX(I,J2+1,K)
         IW  = WALL_INDEX(ICG,-2)
         IF (REMOVE) BOUNDARY_TYPE(IW) = NULL_BOUNDARY
         IF (CREATE .AND. .NOT.SOLID(ICG)) CALL GET_BOUNDARY_TYPE( IW , IJKW(5,IW) , BOUNDARY_TYPE(IW) )
      ENDIF
      IC = CELL_INDEX(I,J2,K)
      IW = WALL_INDEX(IC,2)
      IF (IW > 0 .AND. REMOVE) THEN
         IF (IBC_ORIG(IW)>0) CALL RESTORE_ORIGINAL_BC(IW)
         CALL GET_BOUNDARY_TYPE( IW , IJKW(5,IW) , BOUNDARY_TYPE(IW) )
      ENDIF
      IF (CREATE) BOUNDARY_TYPE(IW) = NULL_BOUNDARY
   ENDDO
ENDDO

! Process the z boundaries of the OBSTruction

DO J=J1,J2
   DO I=I1,I2

      ! Nullify and/or uncover wall cells on the z=z1 side of the OBSTruction

      IF (K1>1 .AND. K1<KBP1) THEN
         ICG = CELL_INDEX(I,J,K1-1)
         IW  = WALL_INDEX(ICG,3)
         IF (REMOVE) BOUNDARY_TYPE(IW) = NULL_BOUNDARY
         IF (CREATE .AND. .NOT.SOLID(ICG)) CALL GET_BOUNDARY_TYPE( IW , IJKW(5,IW) , BOUNDARY_TYPE(IW) )
      ENDIF
      IC = CELL_INDEX(I,J,K1)
      IW = WALL_INDEX(IC,-3)
      IF (IW > 0 .AND. REMOVE) THEN
         IF (IBC_ORIG(IW)>0) CALL RESTORE_ORIGINAL_BC(IW)
         CALL GET_BOUNDARY_TYPE( IW , IJKW(5,IW) , BOUNDARY_TYPE(IW) )
      ENDIF
      IF (CREATE) BOUNDARY_TYPE(IW) = NULL_BOUNDARY

      ! Nullify and/or uncover wall cells on the z=z2 side of the OBSTruction

      IF (K2<KBAR .AND. K2>0) THEN
         ICG = CELL_INDEX(I,J,K2+1)
         IW  = WALL_INDEX(ICG,-3)
         IF (REMOVE) BOUNDARY_TYPE(IW) = NULL_BOUNDARY
         IF (CREATE .AND. .NOT.SOLID(ICG)) CALL GET_BOUNDARY_TYPE( IW , IJKW(5,IW) , BOUNDARY_TYPE(IW) )
      ENDIF
      IC = CELL_INDEX(I,J,K2)
      IW = WALL_INDEX(IC,3)
      IF (IW > 0 .AND. REMOVE) THEN
         IF (IBC_ORIG(IW)>0) CALL RESTORE_ORIGINAL_BC(IW)
         CALL GET_BOUNDARY_TYPE( IW , IJKW(5,IW) , BOUNDARY_TYPE(IW) )
      ENDIF
      IF (CREATE) BOUNDARY_TYPE(IW) = NULL_BOUNDARY
   ENDDO
ENDDO


! Nullify block edges on blockage that is to be removed
 
REMOVE_ONLY: IF (REMOVE) THEN

DO K=K1-1,K2
   DO J=J1-1,J2
      DO I=I1  ,I2
         IE = EDGE_INDEX(CELL_INDEX(I,J,K),4)
         IF (IE>0 .AND. J/=0 .AND. J/=JBAR .AND. K/=0 .AND. K/=KBAR) IJKE(4,IE) = 0
         IF (IE>0) THEN 
            IF (IJKE(7,IE) > 0) IJKE(5,IE) = INTERPOLATED_SURF_INDEX
         ENDIF
      ENDDO
   ENDDO
ENDDO
DO K=K1-1,K2
   DO J=J1  ,J2
      DO I=I1-1,I2
         IE = EDGE_INDEX(CELL_INDEX(I,J,K),8)
         IF (IE>0 .AND. I/=0 .AND. I/=IBAR .AND. K/=0 .AND. K/=KBAR) IJKE(4,IE) = 0
         IF (IE>0) THEN 
            IF (IJKE(7,IE) > 0) IJKE(5,IE) = INTERPOLATED_SURF_INDEX
         ENDIF
      ENDDO
   ENDDO
ENDDO
DO K=K1  ,K2
   DO J=J1-1,J2
      DO I=I1-1,I2
         IE = EDGE_INDEX(CELL_INDEX(I,J,K),12)
         IF (IE>0 .AND. I/=0 .AND. I/=IBAR .AND. J/=0 .AND. J/=JBAR) IJKE(4,IE) = 0
         IF (IE>0) THEN 
            IF (IJKE(7,IE) > 0) IJKE(5,IE) = INTERPOLATED_SURF_INDEX
         ENDIF
      ENDDO
   ENDDO
ENDDO

ENDIF REMOVE_ONLY
 
 
CONTAINS


SUBROUTINE RESTORE_ORIGINAL_BC(IW)
INTEGER, INTENT(IN) :: IW
IJKW(5,IW) = IBC_ORIG(IW)
OBST_INDEX_W(IW) = 0
END SUBROUTINE RESTORE_ORIGINAL_BC

SUBROUTINE GET_BOUNDARY_TYPE( IW , IBC , BOUND_TYPE )

INTEGER :: I_OBST
INTEGER, INTENT(IN) :: IBC,IW
INTEGER, INTENT(OUT) :: BOUND_TYPE

I_OBST = OBST_INDEX_W(IW)
IF (I_OBST>0 .AND. OBSTRUCTION(I_OBST)%HIDDEN) THEN
   BOUND_TYPE = NULL_BOUNDARY
   RETURN
ENDIF

BOUND_TYPE = SOLID_BOUNDARY
IF (IBC==MIRROR_SURF_INDEX)       BOUND_TYPE = MIRROR_BOUNDARY
IF (IBC==OPEN_SURF_INDEX)         BOUND_TYPE = OPEN_BOUNDARY
IF (IBC==INTERPOLATED_SURF_INDEX) BOUND_TYPE = INTERPOLATED_BOUNDARY

END SUBROUTINE GET_BOUNDARY_TYPE

END SUBROUTINE CREATE_OR_REMOVE_OBST


SUBROUTINE DEFINE_EDGE(II,JJ,KK,IOR,IEC,NM,I_OBST)
 
! Set up edge arrays for velocity boundary conditions
 
INTEGER, INTENT(IN) :: II,JJ,KK,IOR,IEC,NM
INTEGER :: NOM,ICMM,ICMP,ICPM,ICPP,IBC,I_OBST,IE,IW,IIO,JJO,KKO,IW1,IW2
REAL(EB) :: XI,YJ,ZK
TYPE (MESH_TYPE), POINTER :: MM
 
IF (I_OBST>0) OB=>OBSTRUCTION(I_OBST)
 
! Find the wall cells on each side of the edge 

IW1 = -1
IW2 = -1
 
COMP: SELECT CASE(IEC)
   CASE(1) COMP
      SELECT CASE(IOR)
         CASE(-2)
            IW1 = WALL_INDEX(CELL_INDEX(II,JJ,KK)  ,2)
            IW2 = WALL_INDEX(CELL_INDEX(II,JJ,KK+1),2)
         CASE( 2)
            IW1 = WALL_INDEX(CELL_INDEX(II,JJ+1,KK)  ,-2)
            IW2 = WALL_INDEX(CELL_INDEX(II,JJ+1,KK+1),-2)
         CASE(-3)
            IW1 = WALL_INDEX(CELL_INDEX(II,JJ  ,KK),3)
            IW2 = WALL_INDEX(CELL_INDEX(II,JJ+1,KK),3)
         CASE( 3)
            IW1 = WALL_INDEX(CELL_INDEX(II,JJ  ,KK+1),-3)
            IW2 = WALL_INDEX(CELL_INDEX(II,JJ+1,KK+1),-3)
      END SELECT
   CASE(2) COMP
      SELECT CASE(IOR)
         CASE(-1)
            IW1 = WALL_INDEX(CELL_INDEX(II,JJ,KK)  ,1)
            IW2 = WALL_INDEX(CELL_INDEX(II,JJ,KK+1),1)
         CASE( 1)
            IW1 = WALL_INDEX(CELL_INDEX(II+1,JJ,KK)  ,-1)
            IW2 = WALL_INDEX(CELL_INDEX(II+1,JJ,KK+1),-1)
         CASE(-3)
            IW1 = WALL_INDEX(CELL_INDEX(II  ,JJ,KK),3)
            IW2 = WALL_INDEX(CELL_INDEX(II+1,JJ,KK),3)
         CASE( 3)
            IW1 = WALL_INDEX(CELL_INDEX(II  ,JJ,KK+1),-3)
            IW2 = WALL_INDEX(CELL_INDEX(II+1,JJ,KK+1),-3)
      END SELECT
   CASE(3) COMP
      SELECT CASE(IOR)
         CASE(-1)
            IW1 = WALL_INDEX(CELL_INDEX(II,JJ  ,KK),1)
            IW2 = WALL_INDEX(CELL_INDEX(II,JJ+1,KK),1)
         CASE( 1)
            IW1 = WALL_INDEX(CELL_INDEX(II+1,JJ  ,KK),-1)
            IW2 = WALL_INDEX(CELL_INDEX(II+1,JJ+1,KK),-1)
         CASE(-2)
            IW1 = WALL_INDEX(CELL_INDEX(II  ,JJ,KK),2)
            IW2 = WALL_INDEX(CELL_INDEX(II+1,JJ,KK),2)
         CASE( 2)
            IW1 = WALL_INDEX(CELL_INDEX(II  ,JJ+1,KK),-2)
            IW2 = WALL_INDEX(CELL_INDEX(II+1,JJ+1,KK),-2)
      END SELECT
END SELECT COMP

! Decide what to do based on whether or not adjacent tiles exist

IF (IW1==-1 .OR. IW2==-1) THEN
   WRITE(MESSAGE,'(A,I2,A,3I3)') 'ERROR: Edge initialization failed; Mesh: ',NM,', Cell: ',II,JJ,KK
   CALL SHUTDOWN(MESSAGE)
ENDIF
IF (IW1==0 .AND. IW2==0) RETURN
IF (IW1> 0 .AND. IW2==0) IW = IW1
IF (IW1==0 .AND. IW2> 0) IW = IW2
IF (IW1> 0 .AND. IW2> 0) IW = IW2  ! Arbitrary decision
 
! Assign the Index of the Edge (IE) and add to the list

ICMM = CELL_INDEX(II,JJ,KK)
SELECT CASE(IEC)
   CASE(1)
      IE = EDGE_INDEX(ICMM,4)
   CASE(2)
      IE = EDGE_INDEX(ICMM,8)
   CASE(3)
      IE = EDGE_INDEX(ICMM,12)
END SELECT
 
IF (IE==0) THEN
   N_EDGES = N_EDGES + 1
   IE = N_EDGES
ENDIF
 
! Determine the wall index of the adjacent wall tile
 
NOM = NM
IIO = 0
JJO = 0
KKO = 0
IBC = IJKW(5,IW)
 
! Look for interpolated boundary cells

IF (IJKW(9,IW)>0 .AND. BOUNDARY_TYPE(IW)==INTERPOLATED_BOUNDARY) THEN
   NOM = IJKW( 9,IW)
   IIO = IJKW(10,IW)
   JJO = IJKW(11,IW)
   KKO = IJKW(12,IW)
ENDIF
 
! Fill up array IJKE with edge parameters
 
IJKE(1,IE) = II
IJKE(2,IE) = JJ
IJKE(3,IE) = KK
IJKE(4,IE) = IEC
IJKE(5,IE) = IBC
IJKE(6,IE) = IOR
 
! Special "free-slip" cases

IF (I_OBST>0) THEN
   IF (.NOT.OB%SAWTOOTH) IJKE(6,IE) = 0
ENDIF

IF (EVACUATION_ONLY(NM)) IJKE(6,IE) = 0

! Fill in EDGE_INDEX and IJKE(7-14,IE)
 
COMPONENT: SELECT CASE(IEC)
 
   CASE (1) COMPONENT
 
      ICPM = CELL_INDEX(II,JJ+1,KK)
      ICPP = CELL_INDEX(II,JJ+1,KK+1)
      ICMP = CELL_INDEX(II,JJ,KK+1)
      EDGE_INDEX(ICPP,1) = IE
      EDGE_INDEX(ICMP,2) = IE
      EDGE_INDEX(ICPM,3) = IE
      EDGE_INDEX(ICMM,4) = IE
      SELECT CASE(ABS(IOR))
         CASE(2)
            IF (IOR>0) IJKE(11,IE) = -NOM
            IF (IOR<0) IJKE(11,IE) =  NOM
            IJKE(12,IE) = IIO
            IJKE(13,IE) = JJO
            MM => MESHES(NOM)
            ZK  = MIN( REAL(MM%KBAR,EB)+0.999_EB , MM%CELLSK(NINT((Z(KK)-MM%ZS)*MM%RDZINT))+1._EB )
            KKO = MAX(1,FLOOR(ZK))
            M%EDGE_INTERPOLATION_FACTOR(IE,2) = ZK-KKO
            IJKE(14,IE) = KKO

         CASE(3)
            IF (IOR>0) IJKE( 7,IE) = -NOM
            IF (IOR<0) IJKE( 7,IE) =  NOM
            IJKE( 8,IE) = IIO
            MM => MESHES(NOM)
            YJ  = MIN( REAL(MM%JBAR,EB)+0.999_EB , MM%CELLSJ(NINT((Y(JJ)-MM%YS)*MM%RDYINT))+1._EB )
            JJO = MAX(1,FLOOR(YJ))
            M%EDGE_INTERPOLATION_FACTOR(IE,1) = YJ-JJO
            IJKE( 9,IE) = JJO
            IJKE(10,IE) = KKO
      END SELECT
 
   CASE (2) COMPONENT
    
      ICPM = CELL_INDEX(II+1,JJ,KK)
      ICPP = CELL_INDEX(II+1,JJ,KK+1)
      ICMP = CELL_INDEX(II,JJ,KK+1)
      EDGE_INDEX(ICPP,5) = IE
      EDGE_INDEX(ICMP,6) = IE
      EDGE_INDEX(ICPM,7) = IE
      EDGE_INDEX(ICMM,8) = IE
      SELECT CASE(ABS(IOR))
         CASE( 1)
            IF (IOR>0) IJKE(11,IE) = -NOM
            IF (IOR<0) IJKE(11,IE) =  NOM
            IJKE(12,IE) = IIO
            IJKE(13,IE) = JJO
            MM => MESHES(NOM)
            ZK  = MIN( REAL(MM%KBAR,EB)+0.999_EB , MM%CELLSK(NINT((Z(KK)-MM%ZS)*MM%RDZINT))+1._EB )
            KKO = MAX(1,FLOOR(ZK))
            M%EDGE_INTERPOLATION_FACTOR(IE,2) = ZK-KKO
            IJKE(14,IE) = KKO
         CASE( 3)
            IF (IOR>0) IJKE( 7,IE) = -NOM
            IF (IOR<0) IJKE( 7,IE) =  NOM
            MM => MESHES(NOM)
            XI  = MIN( REAL(MM%IBAR,EB)+0.999_EB , MM%CELLSI(NINT((X(II)-MM%XS)*MM%RDXINT))+1._EB )
            IIO = MAX(1,FLOOR(XI))
            M%EDGE_INTERPOLATION_FACTOR(IE,1) = XI-IIO
            IJKE( 8,IE) = IIO
            IJKE( 9,IE) = JJO
            IJKE(10,IE) = KKO
      END SELECT 
 
   CASE (3) COMPONENT
 
      ICPM = CELL_INDEX(II+1,JJ,KK)
      ICPP = CELL_INDEX(II+1,JJ+1,KK)
      ICMP = CELL_INDEX(II,JJ+1,KK)
      EDGE_INDEX(ICPP, 9) = IE
      EDGE_INDEX(ICMP,10) = IE
      EDGE_INDEX(ICPM,11) = IE
      EDGE_INDEX(ICMM,12) = IE
      SELECT CASE(ABS(IOR))
         CASE( 1)
            IF (IOR>0) IJKE(11,IE) = -NOM
            IF (IOR<0) IJKE(11,IE) =  NOM
            IJKE(12,IE) = IIO
            MM => MESHES(NOM)
            YJ  = MIN( REAL(MM%JBAR,EB)+0.999_EB , MM%CELLSJ(NINT((Y(JJ)-MM%YS)*MM%RDYINT))+1._EB )
            JJO = MAX(1,FLOOR(YJ))
            M%EDGE_INTERPOLATION_FACTOR(IE,2) = YJ-JJO
            IJKE(13,IE) = JJO
            IJKE(14,IE) = KKO
         CASE( 2)
            IF (IOR>0) IJKE( 7,IE) = -NOM
            IF (IOR<0) IJKE( 7,IE) =  NOM
            MM => MESHES(NOM)
            XI  = MIN( REAL(MM%IBAR,EB)+0.999_EB , MM%CELLSI(NINT((X(II)-MM%XS)*MM%RDXINT))+1._EB )
            IIO = MAX(1,FLOOR(XI))
            M%EDGE_INTERPOLATION_FACTOR(IE,1) = XI-IIO
            IJKE( 8,IE) = IIO
            IJKE( 9,IE) = JJO
            IJKE(10,IE) = KKO
      END SELECT
 
END SELECT COMPONENT

END SUBROUTINE DEFINE_EDGE

SUBROUTINE GET_REV_init(MODULE_REV,MODULE_DATE)
INTEGER,INTENT(INOUT) :: MODULE_REV
CHARACTER(255),INTENT(INOUT) :: MODULE_DATE

WRITE(MODULE_DATE,'(A)') initrev(INDEX(initrev,':')+1:LEN_TRIM(initrev)-2)
READ (MODULE_DATE,'(I5)') MODULE_REV
WRITE(MODULE_DATE,'(A)') initdate

END SUBROUTINE GET_REV_init

 
END MODULE INIT
