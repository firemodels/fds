!> \brief Routines for handling vtk output

MODULE VTK_FDS_INTERFACE

USE MESH_VARIABLES
USE GLOBAL_CONSTANTS
USE MESH_POINTERS
USE OUTPUT_DATA
USE OUTPUT_CLOCKS
#ifdef WITH_HDF5
USE HDF5
#endif
USE MPI_F08
USE COMPLEX_GEOMETRY, ONLY : WRITE_GEOM,WRITE_GEOM_ALL,CC_FGSC,CC_IDCF,CC_IDCC,CC_UNKZ,CC_UNKF,CC_FTYPE_RCGAS,&
                             CC_FTYPE_CFGAS,CC_FTYPE_CFINB,CC_SOLID,CC_CGSC,CC_CUTCFE,TRIANGULATE,&
                             CC_VGSC,CC_GASPHASE,MAKE_UNIQUE_VERT_ARRAY,AVERAGE_FACE_VALUES

IMPLICIT NONE (TYPE,EXTERNAL)
PRIVATE

PUBLIC WRITE_PARAVIEW_STATE_FILE
#ifdef WITH_HDF5
PUBLIC WRITE_VTKHDF_GEOM_FILE,&
       PARALLEL_INIT_F32,PARALLEL_WRITE_F32,CLOSE_VTKHDF,OPEN_VTKHDF,&
       CLOSE_PART_VTKHDF,PARALLEL_INIT_I32,PARALLEL_WRITE_I32,&
       WRITE_VTKHDF_SLICE_CELL_FILE_NOOPEN,WRITE_VTKHDF_SLICE_DATA_FILE_NOOPEN,&
       INITIALIZE_VTKHDF_SLCF_KEEPOPEN,INITIALIZE_VTKHDF_SMOKE3D_KEEPOPEN,&
       ADD_DATA_TO_SMOKE3D_VTKHDF_FILE_NOOPEN,INITIALIZE_VTKHDF_BNDF,&
       CREATE_OPEN_PART_VTKHDF
#endif

CONTAINS



#ifdef WITH_HDF5

SUBROUTINE BUILD_VTK_GAS_PHASE_GEOMETRY2(NM, &
                                        NC, NP, VERTICES, CONNECT, OFFSETS, VTKC_TYPE)

INTEGER :: NX, NY, NZ, NC, NP, I, J, K, IFACT, JFACT, KFACT
REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: VERTICES
INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
INTEGER, INTENT(IN) :: NM

NX = SIZE(MESHES(NM)%X)
NY = SIZE(MESHES(NM)%Y)
NZ = SIZE(MESHES(NM)%Z)

NP = NX*NY*NZ
NC = (NX-1)*(NY-1)*(NZ-1)

! Fill point data
ALLOCATE(VERTICES(3,NP))
IFACT = 1
DO K = 0, NZ-1
   DO J = 0, NY-1
      DO I = 0, NX-1
         VERTICES(1, IFACT)=REAL(MESHES(NM)%X(I),FB)
         VERTICES(2, IFACT)=REAL(MESHES(NM)%Y(J),FB)
         VERTICES(3,IFACT)=REAL(MESHES(NM)%Z(K),FB)
         IFACT = IFACT + 1
      ENDDO
   ENDDO
ENDDO

! Fill cell data
ALLOCATE(CONNECT(NC*8))
DO I = 1, NX-1
   IFACT = (I-1)
   DO J = 1, NY-1
      JFACT = (J-1)*(NX-1)
      DO K = 1, NZ-1
         KFACT = (K - 1)*(NY-1)*(NX-1)
         CONNECT((IFACT+JFACT+KFACT)*8+1) = (K-1)*(NY*NX) + (J-1)*NX + I-1
         CONNECT((IFACT+JFACT+KFACT)*8+2) = (K-1)*(NY*NX) + (J-1)*NX + I
         CONNECT((IFACT+JFACT+KFACT)*8+3) = (K-1)*(NY*NX) + (J)*NX + I-1
         CONNECT((IFACT+JFACT+KFACT)*8+4) = (K-1)*(NY*NX) + (J)*NX + I
         CONNECT((IFACT+JFACT+KFACT)*8+5) = (K)*(NY*NX) + (J-1)*NX + I-1
         CONNECT((IFACT+JFACT+KFACT)*8+6) = (K)*(NY*NX) + (J-1)*NX + I
         CONNECT((IFACT+JFACT+KFACT)*8+7) = (K)*(NY*NX) + (J)*NX + I-1
         CONNECT((IFACT+JFACT+KFACT)*8+8) = (K)*(NY*NX) + (J)*NX + I
      ENDDO
   ENDDO
ENDDO

ALLOCATE(OFFSETS(NC+1))
ALLOCATE(VTKC_TYPE(NC))

OFFSETS(1) = 0
DO I=1,NC
   OFFSETS(I+1) = (I)*8_IB32
   VTKC_TYPE(I) = 11_IB8
ENDDO

ENDSUBROUTINE BUILD_VTK_GAS_PHASE_GEOMETRY2



SUBROUTINE BUILD_VTK_SLICE_GEOMETRY2(NM, SL, NTSL, &
                                        NC, NP, VERTICES, CONNECT, OFFSETS, VTKC_TYPE)

INTEGER :: NX, NY, NZ, NC, NP, I, J, K, IFACT, JFACT, KFACT, KTS
INTEGER :: I1,I2,J1,J2,K1,K2,L1,L2,N1,N2
REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: VERTICES
INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
INTEGER, INTENT(IN) :: NM, NTSL
TYPE(SLICE_TYPE), POINTER, INTENT(IN) :: SL

I1  = SL%I1
I2  = SL%I2
J1  = SL%J1
J2  = SL%J2
K1  = SL%K1
K2  = SL%K2

NX = I2 + 1 - I1
NY = J2 + 1 - J1
NZ = K2 + 1 - K1

NP = NX*NY*NZ
NC = MAX((NX-1),1)*MAX((NY-1),1)*MAX((NZ-1),1)

! Fill point data
ALLOCATE(VERTICES(3,NP))
IF (I2-I1==0 .OR. J2-J1==0 .OR. K2-K1==0) THEN
   IFACT = 1
   IF (I2-I1==0) THEN
      DO K = K1, K2
         DO J = J1, J2
            VERTICES(1,IFACT)=REAL(MESHES(NM)%X(I1),FB)
            VERTICES(2,IFACT)=REAL(MESHES(NM)%Y(J),FB)
            VERTICES(3,IFACT)=REAL(MESHES(NM)%Z(K),FB)
            IFACT = IFACT + 1
         ENDDO
      ENDDO
   ELSEIF (J2-J1==0) THEN
      DO K = K1, K2
         DO I = I1, I2
            VERTICES(1,IFACT)=REAL(MESHES(NM)%X(I),FB)
            VERTICES(2,IFACT)=REAL(MESHES(NM)%Y(J1),FB)
            VERTICES(3,IFACT)=REAL(MESHES(NM)%Z(K),FB)
            IFACT = IFACT + 1
         ENDDO
      ENDDO
   ELSEIF (K2-K1==0) THEN
      DO J = J1, J2
         DO I = I1, I2
            VERTICES(1,IFACT)=REAL(MESHES(NM)%X(I),FB)
            VERTICES(2,IFACT)=REAL(MESHES(NM)%Y(J),FB)
            IF (SL%AGL_SLICE > 0) THEN
               KTS = MESHES(NM)%K_AGL_SLICE(I,J,NTSL)
               VERTICES(3,IFACT)=REAL(MESHES(NM)%Z(KTS),FB)
            ELSE
               VERTICES(3,IFACT)=REAL(MESHES(NM)%Z(K1),FB)
            ENDIF
            IFACT = IFACT + 1
         ENDDO
      ENDDO
   ENDIF
ELSE
   IFACT = 1
   DO K = K1, K2
      DO J = J1, J2
         DO I = I1, I2
            VERTICES(1,IFACT)=REAL(MESHES(NM)%X(I),FB)
            VERTICES(2,IFACT)=REAL(MESHES(NM)%Y(J),FB)
            VERTICES(3,IFACT)=REAL(MESHES(NM)%Z(K),FB)
            IFACT = IFACT + 1
         ENDDO
      ENDDO
   ENDDO
ENDIF

! Fill cell data
ALLOCATE(OFFSETS(NC+1))
ALLOCATE(VTKC_TYPE(NC))
IF (I2-I1==0 .OR. J2-J1==0 .OR. K2-K1==0) THEN
   !2-D slice
   ALLOCATE(CONNECT(NC*4))
   
   IF (I2-I1==0) THEN
      L1=J1 ; L2=J2
      N1=K1 ; N2=K2;
   ELSEIF (J2-J1==0) THEN
      L1=I1 ; L2=I2
      N1=K1 ; N2=K2;
   ELSEIF (K2-K1==0) THEN
      L1=I1 ; L2=I2
      N1=J1 ; N2=J2;
   ENDIF
   
   IFACT = 0
   DO I = 1, (L2-L1)
      DO J = 1, (N2-N1)
         CONNECT((IFACT)*4+1) = (L2-L1+1)*(J-1)+(I-1)
         CONNECT((IFACT)*4+2) = (L2-L1+1)*(J-1)+(I)
         CONNECT((IFACT)*4+3) = (L2-L1+1)*(J)+(I-1)
         CONNECT((IFACT)*4+4) = (L2-L1+1)*(J)+(I)
         IFACT = IFACT+1
      ENDDO
   ENDDO
   OFFSETS(1) = 0
   DO I=1,NC
      OFFSETS(I+1) = (I)*4_IB32
      VTKC_TYPE(I) = 8_IB8
   ENDDO
   
ELSE
   !3-D slice
   ALLOCATE(CONNECT(NC*8))
   DO I = 1, NX-1
      IFACT = (I-1)
      DO J = 1, NY-1
         JFACT = (J-1)*(NX-1)
         DO K = 1, NZ-1
            KFACT = (K - 1)*(NY-1)*(NX-1)
            CONNECT((IFACT+JFACT+KFACT)*8+1) = (K-1)*(NY*NX) + (J-1)*NX + I-1
            CONNECT((IFACT+JFACT+KFACT)*8+2) = (K-1)*(NY*NX) + (J-1)*NX + I
            CONNECT((IFACT+JFACT+KFACT)*8+3) = (K-1)*(NY*NX) + (J)*NX + I-1
            CONNECT((IFACT+JFACT+KFACT)*8+4) = (K-1)*(NY*NX) + (J)*NX + I
            CONNECT((IFACT+JFACT+KFACT)*8+5) = (K)*(NY*NX) + (J-1)*NX + I-1
            CONNECT((IFACT+JFACT+KFACT)*8+6) = (K)*(NY*NX) + (J-1)*NX + I
            CONNECT((IFACT+JFACT+KFACT)*8+7) = (K)*(NY*NX) + (J)*NX + I-1
            CONNECT((IFACT+JFACT+KFACT)*8+8) = (K)*(NY*NX) + (J)*NX + I
         ENDDO
      ENDDO
   ENDDO
   
   OFFSETS(1) = 0
   DO I=1,NC
      OFFSETS(I+1) = (I)*8_IB32
      VTKC_TYPE(I) = 11_IB8
   ENDDO
   
ENDIF
         
ENDSUBROUTINE BUILD_VTK_SLICE_GEOMETRY2


SUBROUTINE BUILD_VTK_SOLID_PHASE_GEOMETRY(NM, PA, &
                                          NCELLS, NPOINTS, X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)

INTEGER :: NX,NY,NZ,NCELLS,NPOINTS,I,J,K,IFACT,L1,L2,N1,N2
REAL(FB), ALLOCATABLE, DIMENSION(:) :: X_PTS, Y_PTS, Z_PTS
INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
INTEGER, INTENT(IN) :: NM
TYPE(PATCH_TYPE), POINTER, INTENT(IN) :: PA

! Fill point data
SELECT CASE(ABS(PA%IOR))
   CASE(1) ; L1=PA%JG1 ; L2=PA%JG2 ; N1=PA%KG1 ; N2=PA%KG2 ; NX=1; NY=(L2-L1); NZ=(N2-N1)
   CASE(2) ; L1=PA%IG1 ; L2=PA%IG2 ; N1=PA%KG1 ; N2=PA%KG2 ; NX=(L2-L1); NY=1; NZ=(N2-N1)
   CASE(3) ; L1=PA%IG1 ; L2=PA%IG2 ; N1=PA%JG1 ; N2=PA%JG2 ; NX=(L2-L1); NY=(N2-N1); NZ=1
END SELECT
NPOINTS = (L2-L1+2)*(N2-N1+2)
NCELLS = (L2-L1+1)*(N2-N1+1)
ALLOCATE(X_PTS(NPOINTS))
ALLOCATE(Y_PTS(NPOINTS))
ALLOCATE(Z_PTS(NPOINTS))
ALLOCATE(CONNECT(NCELLS*4))
ALLOCATE(OFFSETS(NCELLS))
ALLOCATE(VTKC_TYPE(NCELLS))
IFACT = 1
SELECT CASE(ABS(PA%IOR))
   CASE(1)
      DO K = PA%K1,PA%K2
         DO J = PA%J1,PA%J2
            X_PTS(IFACT)=REAL(MESHES(NM)%X(PA%I1),FB)
            Y_PTS(IFACT)=REAL(MESHES(NM)%Y(J),FB)
            Z_PTS(IFACT)=REAL(MESHES(NM)%Z(K),FB)
            IFACT = IFACT + 1
         ENDDO
      ENDDO
   CASE(2)
      DO K = PA%K1,PA%K2
         DO I = PA%I1,PA%I2
            X_PTS(IFACT)=REAL(MESHES(NM)%X(I),FB)
            Y_PTS(IFACT)=REAL(MESHES(NM)%Y(PA%J1),FB)
            Z_PTS(IFACT)=REAL(MESHES(NM)%Z(K),FB)
            IFACT = IFACT + 1
         ENDDO
      ENDDO
   CASE(3)
      DO J = PA%J1,PA%J2
         DO I = PA%I1,PA%I2
            X_PTS(IFACT)=REAL(MESHES(NM)%X(I),FB)
            Y_PTS(IFACT)=REAL(MESHES(NM)%Y(J),FB)
            Z_PTS(IFACT)=REAL(MESHES(NM)%Z(PA%K1),FB)
            IFACT = IFACT + 1
         ENDDO
      ENDDO
END SELECT

! Fill cell data

IFACT = 0
DO I = 1, (L2-L1+1)
   DO J = 1, (N2-N1+1)
      CONNECT((IFACT)*4+1) = (L2-L1+2)*(J-1)+(I-1)
      CONNECT((IFACT)*4+2) = (L2-L1+2)*(J-1)+(I)
      CONNECT((IFACT)*4+3) = (L2-L1+2)*(J)+(I-1)
      CONNECT((IFACT)*4+4) = (L2-L1+2)*(J)+(I)
      IFACT = IFACT+1
   ENDDO
ENDDO

DO I=1,NCELLS
   OFFSETS(I) = (I)*4_IB32
   VTKC_TYPE(I) = 8_IB8
ENDDO

ENDSUBROUTINE BUILD_VTK_SOLID_PHASE_GEOMETRY


SUBROUTINE BUILD_VTK_GEOM_GEOMETRY(VERTS, FACES, NCELLS, NPOINTS,&
                                   X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)

REAL(FB), ALLOCATABLE, DIMENSION(:), INTENT(IN) :: VERTS
INTEGER, ALLOCATABLE, DIMENSION(:), INTENT(IN) :: FACES
REAL(FB), ALLOCATABLE, DIMENSION(:) :: X_PTS, Y_PTS, Z_PTS
INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
INTEGER :: I
INTEGER :: NPOINTS, NCELLS, NFACES

NPOINTS = SIZE(VERTS)/3
NCELLS = SIZE(FACES)/3
NFACES = SIZE(FACES)

ALLOCATE(X_PTS(NPOINTS))
ALLOCATE(Y_PTS(NPOINTS))
ALLOCATE(Z_PTS(NPOINTS))
ALLOCATE(CONNECT(NCELLS*3))
ALLOCATE(OFFSETS(NCELLS))
ALLOCATE(VTKC_TYPE(NCELLS))

DO I=1,NPOINTS
   X_PTS(I) = VERTS((I-1)*3+1)
   Y_PTS(I) = VERTS((I-1)*3+2)
   Z_PTS(I) = VERTS((I-1)*3+3)
ENDDO

DO I=1,NCELLS
   OFFSETS(I) = (I)*3_IB32
   VTKC_TYPE(I) = 5_IB8
   CONNECT(3*(I-1)+1) = FACES(3*(I-1)+1)-1
   CONNECT(3*(I-1)+2) = FACES(3*(I-1)+2)-1
   CONNECT(3*(I-1)+3) = FACES(3*(I-1)+3)-1
ENDDO

ENDSUBROUTINE BUILD_VTK_GEOM_GEOMETRY




SUBROUTINE DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)

REAL(FB), DIMENSION(:), ALLOCATABLE :: X_PTS, Y_PTS, Z_PTS
INTEGER(IB32), DIMENSION(:), ALLOCATABLE :: CONNECT, OFFSETS
INTEGER(IB8), DIMENSION(:), ALLOCATABLE :: VTKC_TYPE

DEALLOCATE(VTKC_TYPE)
DEALLOCATE(OFFSETS)
DEALLOCATE(CONNECT)
DEALLOCATE(X_PTS)
DEALLOCATE(Y_PTS)
DEALLOCATE(Z_PTS)

ENDSUBROUTINE DEALLOCATE_VTK_GAS_PHASE_GEOMETRY


SUBROUTINE CREATE_OPEN_PART_VTKHDF(FILENAME,&
                       FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   CHARACTER(*), INTENT(IN) :: FILENAME
   INTEGER(HID_T), INTENT(OUT) :: FILE_ID, PLIST_ID       ! Identifiers
   INTEGER(HID_T), INTENT(OUT) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER  :: ERROR                    !< IO Error status.
   INTEGER(KIND=MPI_INTEGER_KIND) :: MPI_SIZE, MPI_RANK, MPIERROR
   INTEGER(HID_T) :: DSET_ID, CRP_LIST
   INTEGER(HSIZE_T), DIMENSION(1) :: START1(1), EXTENT1(1)
   INTEGER(HSIZE_T) :: VER(2)
   INTEGER(HSIZE_T), DIMENSION(1) :: DATA_DIMS    ! Attribute dimension
   
   CALL MPI_COMM_SIZE(MPI_COMM_WORLD, MPI_SIZE, MPIERROR)
   CALL MPI_COMM_RANK(MPI_COMM_WORLD, MPI_RANK, MPIERROR)
   
   ! Setup file access property list with parallel I/O access.
   CALL H5PCREATE_F(H5P_FILE_ACCESS_F, PLIST_ID, ERROR)
   CALL H5PSET_FAPL_MPIO_F(PLIST_ID, MPI_COMM_WORLD, MPI_INFO_NULL, ERROR)
   
   ! Create the file collectively.
   CALL H5FCREATE_F(FILENAME, H5F_ACC_TRUNC_F, FILE_ID, ERROR, ACCESS_PRP = PLIST_ID)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
   ! Create VTKHDF groups
   CALL H5GCREATE_F(FILE_ID, "VTKHDF", GROUP_ID1, ERROR)
   GROUP_ID2 = 0
   GROUP_ID3 = 0
   CALL H5GCREATE_F(FILE_ID, "VTKHDF/PointData", GROUP_ID4, ERROR)
   
   ! Create empty groups
   CALL H5GCREATE_F(FILE_ID, "VTKHDF/Vertices", GROUP_ID3, ERROR)
   START1=NMESHES
   EXTENT1=NMESHES
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("NumberOfCells"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("NumberOfConnectivityIds"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("Offsets"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("Connectivity"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL H5GCLOSE_F(GROUP_ID3, ERROR)
   
   CALL H5GCREATE_F(FILE_ID, "VTKHDF/Lines", GROUP_ID3, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("NumberOfCells"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("NumberOfConnectivityIds"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("Offsets"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("Connectivity"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL H5GCLOSE_F(GROUP_ID3, ERROR)
   
   CALL H5GCREATE_F(FILE_ID, "VTKHDF/Polygons", GROUP_ID3, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("NumberOfCells"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("NumberOfConnectivityIds"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("Offsets"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("Connectivity"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL H5GCLOSE_F(GROUP_ID3, ERROR)
   
   CALL H5GCREATE_F(FILE_ID, "VTKHDF/Strips", GROUP_ID3, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("NumberOfCells"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("NumberOfConnectivityIds"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("Offsets"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("Connectivity"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL H5GCLOSE_F(GROUP_ID3, ERROR)
   
   ! Add VTKHDF header information
   VER = 2_HSIZE_T
   DATA_DIMS = 1_HSIZE_T
   CALL ADD_VERSION(GROUP_ID1,VER(1),1,"Version",VER)
   CALL ADD_TYPE(GROUP_ID1,DATA_DIMS,"Type","PolyData",8_SIZE_T)

END SUBROUTINE CREATE_OPEN_PART_VTKHDF


SUBROUTINE CLOSE_PART_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   INTEGER(HID_T), INTENT(IN) :: FILE_ID, GROUP_ID1,GROUP_ID4
   INTEGER(HID_T) :: GROUP_ID2,GROUP_ID3
   INTEGER  :: ERROR                    !< IO Error status.
   CALL H5GCLOSE_F(GROUP_ID4, ERROR)
   CALL H5GCLOSE_F(GROUP_ID1, ERROR)
   GROUP_ID2 = 0
   GROUP_ID3 = 0
   CALL H5FCLOSE_F(FILE_ID, ERROR)
END SUBROUTINE CLOSE_PART_VTKHDF

SUBROUTINE CREATE_OPEN_VTKHDF(FILENAME,&
                       FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   CHARACTER(*), INTENT(IN) :: FILENAME
   INTEGER(HID_T), INTENT(OUT) :: FILE_ID, PLIST_ID       ! Identifiers
   INTEGER(HID_T), INTENT(OUT) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER  :: ERROR                    !< IO Error status.
   INTEGER(KIND=MPI_INTEGER_KIND) :: MPI_SIZE, MPI_RANK, MPIERROR
   INTEGER(HSIZE_T) :: VER(2)
   INTEGER(HSIZE_T), DIMENSION(1) :: DATA_DIMS    ! Attribute dimension
   
   CALL MPI_COMM_SIZE(MPI_COMM_WORLD, MPI_SIZE, MPIERROR)
   CALL MPI_COMM_RANK(MPI_COMM_WORLD, MPI_RANK, MPIERROR)
   
   ! Setup file access property list with parallel I/O access.
   CALL H5PCREATE_F(H5P_FILE_ACCESS_F, PLIST_ID, ERROR)
   CALL H5PSET_FAPL_MPIO_F(PLIST_ID, MPI_COMM_WORLD, MPI_INFO_NULL, ERROR)
   
   ! Create the file collectively.
   CALL H5FCREATE_F(FILENAME, H5F_ACC_TRUNC_F, FILE_ID, ERROR, ACCESS_PRP = PLIST_ID)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
   ! Create VTKHDF groups
   CALL H5GCREATE_F(FILE_ID, "VTKHDF", GROUP_ID1, ERROR)
   CALL H5GCREATE_F(FILE_ID, "VTKHDF/CellData", GROUP_ID2, ERROR)
   CALL H5GCREATE_F(FILE_ID, "VTKHDF/FieldData", GROUP_ID3, ERROR)
   CALL H5GCREATE_F(FILE_ID, "VTKHDF/PointData", GROUP_ID4, ERROR)
   
   ! Add VTKHDF header information
   VER = 2_HSIZE_T
   DATA_DIMS = 1_HSIZE_T
   CALL ADD_VERSION(GROUP_ID1,VER(1),1,"Version",VER)
   CALL ADD_TYPE(GROUP_ID1,DATA_DIMS,"Type","UnstructuredGrid",16_SIZE_T)

END SUBROUTINE CREATE_OPEN_VTKHDF


SUBROUTINE OPEN_VTKHDF(FILENAME,&
                       FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   CHARACTER(*), INTENT(IN) :: FILENAME
   INTEGER(HID_T), INTENT(OUT) :: FILE_ID, PLIST_ID       ! Identifiers
   INTEGER(HID_T), INTENT(OUT) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER  :: ERROR                    !< IO Error status.
   INTEGER(KIND=MPI_INTEGER_KIND) :: MPI_SIZE, MPI_RANK, MPIERROR
   
   CALL MPI_COMM_SIZE(MPI_COMM_WORLD, MPI_SIZE, MPIERROR)
   CALL MPI_COMM_RANK(MPI_COMM_WORLD, MPI_RANK, MPIERROR)
   
   ! Setup file access property list with parallel I/O access.
   CALL H5PCREATE_F(H5P_FILE_ACCESS_F, PLIST_ID, ERROR)
   CALL H5PSET_FAPL_MPIO_F(PLIST_ID, MPI_COMM_WORLD, MPI_INFO_NULL, ERROR)
   
   ! Create the file collectively.
   CALL H5FOPEN_F(FILENAME, H5F_ACC_RDWR_F, FILE_ID, ERROR, ACCESS_PRP = PLIST_ID)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
   ! Create VTKHDF groups
   CALL H5GOPEN_F(FILE_ID, "VTKHDF", GROUP_ID1, ERROR)
   CALL H5GOPEN_F(FILE_ID, "VTKHDF/CellData", GROUP_ID2, ERROR)
   CALL H5GOPEN_F(FILE_ID, "VTKHDF/FieldData", GROUP_ID3, ERROR)
   CALL H5GOPEN_F(FILE_ID, "VTKHDF/PointData", GROUP_ID4, ERROR)

END SUBROUTINE OPEN_VTKHDF


SUBROUTINE CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   INTEGER(HID_T), INTENT(IN) :: FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4
   INTEGER  :: ERROR                    !< IO Error status.
   CALL H5GCLOSE_F(GROUP_ID4, ERROR)
   CALL H5GCLOSE_F(GROUP_ID3, ERROR)
   CALL H5GCLOSE_F(GROUP_ID2, ERROR)
   CALL H5GCLOSE_F(GROUP_ID1, ERROR)
   CALL H5FCLOSE_F(FILE_ID, ERROR)
END SUBROUTINE CLOSE_VTKHDF


SUBROUTINE ADD_DATA_TO_SMOKE3D_VTKHDF_FILE_NOOPEN( DATANAME, DATA, NM_IN,&
   PLIST_ID,GROUP_ID4,FAKE_WRITE)
   CHARACTER(*), INTENT(IN) :: DATANAME
   INTEGER(IB8), DIMENSION(*), INTENT(IN) :: DATA
   INTEGER, INTENT(IN) :: NM_IN
   LOGICAL, INTENT(IN) :: FAKE_WRITE
   INTEGER(HID_T), INTENT(INOUT) :: PLIST_ID ! Group identifier
   INTEGER(HID_T), INTENT(IN) :: GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: DSET_ID    ! Dataset identifiers
   INTEGER :: NPOINTS_TOTAL, NCELLS_TOTAL, NOFFSETS_TOTAL
   INTEGER :: NPOINTS, NCELLS
   INTEGER :: NCONN_TOTAL, NPIECES
   INTEGER :: NOFFSETS_ACCUM, NCONN_ACCUM, NPIECES_ACCUM, NCELLS_ACCUM, NPOINTS_ACCUM !, NFACES
   INTEGER :: NCONN_MAX, NOFFSETS_MAX, NCELLS_MAX, NPOINTS_MAX
   INTEGER :: NM,ERROR
   INTEGER, DIMENSION(1:N_MPI_PROCESSES) :: MESHES_PER_PROCESS
   INTEGER :: N_WRITTEN
   INTEGER(HSIZE_T), DIMENSION(1) :: NPOINTS_MAX_ARRAY(1), NPOINTS_TOTAL_ARRAY(1)
   
   DO NM=1,N_MPI_PROCESSES
      MESHES_PER_PROCESS(NM) = 0
   ENDDO
   
   NPOINTS_TOTAL=0
   NCELLS_TOTAL=0
   NCELLS_ACCUM=0
   NPOINTS_ACCUM=0
   NOFFSETS_TOTAL=0
   NOFFSETS_ACCUM = 0
   NCONN_TOTAL = 0
   NPIECES = 0
   NCONN_ACCUM = 0
   NPIECES_ACCUM = 0
   NCELLS_MAX = 0
   NPOINTS_MAX = 0
   NCONN_MAX = 0
   NOFFSETS_MAX = 0
   N_WRITTEN = 0
   
   MESH_LOOP_HDF_COUNT: DO NM=1,NMESHES
      NCELLS = MESHES(NM)%NC
      NPOINTS = MESHES(NM)%NP
      NPOINTS_TOTAL = NPOINTS_TOTAL + NPOINTS !+ NVERTS*3
      NCELLS_TOTAL = NCELLS_TOTAL + NCELLS !+ NFACES*3
      NOFFSETS_TOTAL = NOFFSETS_TOTAL + NCELLS + 1
      NCONN_TOTAL = NCONN_TOTAL + NCELLS*8
      NPIECES = NPIECES + 1
      NCELLS_MAX = MAX(NCELLS_MAX,NCELLS)
      NPOINTS_MAX = MAX(NPOINTS_MAX,NPOINTS)
      NOFFSETS_MAX = MAX(NOFFSETS_MAX,NCELLS + 1)
      NCONN_MAX = MAX(NCONN_MAX,NCELLS*8)
      MESHES_PER_PROCESS(PROCESS(NM)+1) = MESHES_PER_PROCESS(PROCESS(NM)+1) + 1
   ENDDO MESH_LOOP_HDF_COUNT
   
   ! Data Quantity
   NPOINTS_MAX_ARRAY(1) = INT(NPOINTS_MAX, HSIZE_T)
   NPOINTS_TOTAL_ARRAY(1) = INT(NPOINTS_TOTAL, HSIZE_T)
   CALL PARALLEL_INIT_U8(GROUP_ID4, TRIM(DATANAME), CRP_LIST, 1,&
      NPOINTS_MAX_ARRAY,NPOINTS_TOTAL_ARRAY, DSET_ID, PLIST_ID) ! Color
   
   MESH_LOOP_HDF: DO NM=1,NMESHES
      NCELLS = MESHES(NM)%NC
      NPOINTS = MESHES(NM)%NP
      IF (NM_IN/=NM) THEN
         NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
         NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
         NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS + 1
         NCONN_ACCUM = NCONN_ACCUM + NCELLS*8
         NPIECES_ACCUM = NPIECES_ACCUM+1
         CYCLE MESH_LOOP_HDF
      ENDIF
      
      ! Write data to file
      IF (.NOT.FAKE_WRITE) THEN
         NPOINTS_MAX_ARRAY(1) = INT(NPOINTS_ACCUM, HSIZE_T)
         NPOINTS_TOTAL_ARRAY(1) = INT(NPOINTS, HSIZE_T)
         CALL PARALLEL_WRITE_U8(1, NPOINTS_TOTAL_ARRAY, DSET_ID,&
            PLIST_ID, NPOINTS_MAX_ARRAY, NPOINTS_TOTAL_ARRAY, DATA)
      ELSE
         NPOINTS_MAX_ARRAY(1) = 0_HSIZE_T
         NPOINTS_TOTAL_ARRAY(1) = 0_HSIZE_T
         CALL PARALLEL_WRITE_U8(1, NPOINTS_TOTAL_ARRAY, DSET_ID,&
            PLIST_ID, NPOINTS_MAX_ARRAY, NPOINTS_TOTAL_ARRAY, DATA)
      ENDIF
         
      NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
      NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
      NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS + 1
      NCONN_ACCUM = NCONN_ACCUM + NCELLS*8
      NPIECES_ACCUM = NPIECES_ACCUM+1
   ENDDO MESH_LOOP_HDF
   
   ! Close HDF5 datasets
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
END SUBROUTINE ADD_DATA_TO_SMOKE3D_VTKHDF_FILE_NOOPEN


SUBROUTINE WRITE_VTKHDF_RECT_GAS_FILE_KEEPOPEN(FILENAME,&
   FILE_ID, PLIST_ID,GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   CHARACTER(*), INTENT(IN) :: FILENAME
   INTEGER(HID_T) :: CRP_LIST       ! Identifiers
   INTEGER(HID_T), INTENT(OUT) :: FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: DSET_ID_CON, DSET_ID_NCELLS, DSET_ID_NCON    ! Dataset identifiers
   INTEGER(HID_T) :: DSET_ID_NPTS, DSET_ID_OFF, DSET_ID_PTS, DSET_ID_TYP       ! Dataset identifiers
   INTEGER :: NPOINTS_TOTAL, NCELLS_TOTAL, NOFFSETS_TOTAL
   INTEGER :: NPOINTS, NCELLS
   INTEGER :: NCONN_TOTAL, NPIECES
   INTEGER :: NOFFSETS_ACCUM, NCONN_ACCUM, NPIECES_ACCUM, NCELLS_ACCUM, NPOINTS_ACCUM !, NFACES
   INTEGER :: NCONN_MAX, NOFFSETS_MAX, NCELLS_MAX, NPOINTS_MAX
   INTEGER :: NM, ERROR
   TYPE (MESH_TYPE), POINTER :: M
   REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: VERTICES
   INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
   INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
   INTEGER, DIMENSION(1:N_MPI_PROCESSES) :: MESHES_PER_PROCESS
   INTEGER :: N_WRITTEN
   INTEGER(HSIZE_T), DIMENSION(1) :: START1(1), EXTENT1(1), START2(2), EXTENT2(2)
   INTEGER(IB32), DIMENSION(1) :: IDATA_OUT1(1)
   REAL(FB), DIMENSION(1) :: RDATA_OUT3(3)
   
   DO NM=1,N_MPI_PROCESSES
      MESHES_PER_PROCESS(NM) = 0
   ENDDO
   
   NPOINTS_TOTAL=0
   NCELLS_TOTAL=0
   NCELLS_ACCUM=0
   NPOINTS_ACCUM=0
   NOFFSETS_TOTAL=0
   NOFFSETS_ACCUM = 0
   NCONN_TOTAL = 0
   NPIECES = 0
   NCONN_ACCUM = 0
   NPIECES_ACCUM = 0
   NCELLS_MAX = 0
   NPOINTS_MAX = 0
   NCONN_MAX = 0
   NOFFSETS_MAX = 0
   N_WRITTEN=0
   
   MESH_LOOP_HDF_COUNT: DO NM=1,NMESHES
      NCELLS = MESHES(NM)%NC
      NPOINTS = MESHES(NM)%NP
      NPOINTS_TOTAL = NPOINTS_TOTAL + NPOINTS !+ NVERTS*3
      NCELLS_TOTAL = NCELLS_TOTAL + NCELLS !+ NFACES*3
      NOFFSETS_TOTAL = NOFFSETS_TOTAL + NCELLS + 1
      NCONN_TOTAL = NCONN_TOTAL + NCELLS*8
      NPIECES = NPIECES + 1
      NCELLS_MAX = MAX(NCELLS_MAX,NCELLS)
      NPOINTS_MAX = MAX(NPOINTS_MAX,NPOINTS)
      NOFFSETS_MAX = MAX(NOFFSETS_MAX,NCELLS + 1)
      NCONN_MAX = MAX(NCONN_MAX,NCELLS*8)
      MESHES_PER_PROCESS(PROCESS(NM)+1) = MESHES_PER_PROCESS(PROCESS(NM)+1) + 1
   ENDDO MESH_LOOP_HDF_COUNT
   
   ! Initialize HDF5 datafiles
   CALL CREATE_OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   IF (.NOT.WRITE_VTK_GEOM_PER_TIMESTEP) THEN
      CALL CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
      RETURN
   ENDIF
   START1 = NCONN_MAX
   EXTENT1 = NCONN_TOTAL
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Connectivity"), CRP_LIST, 1, START1, EXTENT1, DSET_ID_CON, PLIST_ID) ! Connectivity
   START1 = NPIECES
   EXTENT1 = NPIECES
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfCells"), CRP_LIST, 1, START1, EXTENT1, DSET_ID_NCELLS, PLIST_ID) ! NumberOfCells
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfPoints"), CRP_LIST, 1, START1, EXTENT1, DSET_ID_NPTS, PLIST_ID) ! NumberOfPoints
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfConnectivityIds"), CRP_LIST, 1, START1, EXTENT1, DSET_ID_NCON,&
      PLIST_ID) ! NumberOfConnectivityIds
   START1 = NOFFSETS_MAX
   EXTENT1 = NOFFSETS_TOTAL
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Offsets"), CRP_LIST, 1, START1, EXTENT1, DSET_ID_OFF, PLIST_ID) ! Offsets
   START2(1:2) = INT((/3, NPOINTS_MAX/),HSIZE_T)
   EXTENT2(1:2) = INT((/3, NPOINTS_TOTAL/),HSIZE_T)
   CALL PARALLEL_INIT_F32(GROUP_ID1, TRIM("Points"), CRP_LIST, 2, START2,EXTENT2, DSET_ID_PTS, PLIST_ID) ! Points
   START1 = NCELLS_MAX
   EXTENT1 = NCELLS_TOTAL
   CALL PARALLEL_INIT_U8(GROUP_ID1, TRIM("Types"), CRP_LIST, 1, START1, EXTENT1, DSET_ID_TYP, PLIST_ID) ! Types

   MESH_LOOP_HDF: DO NM=1,NMESHES
      NCELLS = MESHES(NM)%NC
      NPOINTS = MESHES(NM)%NP
      IF (PROCESS(NM)/=MY_RANK) THEN
         NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
         NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
         NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS + 1
         NCONN_ACCUM = NCONN_ACCUM + NCELLS*8
         NPIECES_ACCUM = NPIECES_ACCUM+1
         CYCLE MESH_LOOP_HDF
      ENDIF
      N_WRITTEN = N_WRITTEN+1
      M => MESHES(NM)
      CALL BUILD_VTK_GAS_PHASE_GEOMETRY2(NM, NCELLS, NPOINTS, VERTICES, CONNECT, OFFSETS, VTKC_TYPE)
      
      ! Write connectivity data to file
      START1 = NCELLS_ACCUM*8
      EXTENT1 = NCELLS*8
      CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_CON, PLIST_ID, START1, EXTENT1, CONNECT)
      
      ! Write number of cells data to file
      START1 = NM-1
      EXTENT1 = 1
      IDATA_OUT1 = NCELLS
      CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NCELLS, PLIST_ID, START1, EXTENT1, IDATA_OUT1)
      
      ! Write number of points data to file
      IDATA_OUT1 = NPOINTS
      CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NPTS, PLIST_ID, START1, EXTENT1, IDATA_OUT1)
      
      ! Write NumberOfConnectivityIds data to file
      IDATA_OUT1 = NCELLS*8
      CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NCON, PLIST_ID, START1, EXTENT1, IDATA_OUT1)
      
      ! Write offsets data to file
      START1 = NOFFSETS_ACCUM
      EXTENT1 = NCELLS+1
      CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_OFF, PLIST_ID, START1, EXTENT1, OFFSETS)
      
      ! Write point data to file
      START2(1:2) = INT((/0, NPOINTS_ACCUM/),HSIZE_T)
      EXTENT2(1:2) = INT((/3, NPOINTS/),HSIZE_T)
      CALL PARALLEL_WRITE_F32(2, EXTENT2, DSET_ID_PTS, PLIST_ID, START2, EXTENT2, VERTICES)
      
      ! Write types data to file
      START1 = NCELLS_ACCUM
      EXTENT1 = NCELLS
      CALL PARALLEL_WRITE_U8(1, EXTENT1, DSET_ID_TYP, PLIST_ID, START1, EXTENT1, VTKC_TYPE)
      
      DEALLOCATE(VERTICES)
      DEALLOCATE(OFFSETS)
      DEALLOCATE(CONNECT)
      DEALLOCATE(VTKC_TYPE)
      NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
      NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
      NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS + 1
      NCONN_ACCUM = NCONN_ACCUM + NCELLS*8
      NPIECES_ACCUM = NPIECES_ACCUM+1
   ENDDO MESH_LOOP_HDF
   
   
   ! Write fake data in processes that have less meshes than max process
   DO NM=1,MAXVAL(MESHES_PER_PROCESS)
      IF (N_WRITTEN < MAXVAL(MESHES_PER_PROCESS)) THEN
         NCELLS = 0
         NPOINTS = 0
         ALLOCATE(CONNECT(NCELLS))
         ALLOCATE(OFFSETS(NCELLS))
         ALLOCATE(VERTICES(3,NCELLS))
         ALLOCATE(VTKC_TYPE(NCELLS))
         ! Write connectivity data to file
         START1 = NCELLS_ACCUM*8
         EXTENT1 = NCELLS*8
         CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_CON, PLIST_ID, START1, EXTENT1, CONNECT)
         
         ! Write number of cells data to file
         START1 = 0
         EXTENT1 = 0
         IDATA_OUT1 = 0
         CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NCELLS, PLIST_ID, START1, EXTENT1, IDATA_OUT1)
         
         ! Write number of points data to file
         CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NPTS, PLIST_ID, START1, EXTENT1, IDATA_OUT1)
         
         ! Write NumberOfConnectivityIds data to file
         CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NCON, PLIST_ID, START1, EXTENT1, IDATA_OUT1)
         
         ! Write offsets data to file
         CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_OFF, PLIST_ID, START1, EXTENT1, OFFSETS)
         
         ! Write point data to file
         START2(1:2) = INT((/0, 0/),HSIZE_T)
         EXTENT2(1:2) = INT((/3, NPOINTS/),HSIZE_T)
         RDATA_OUT3 = 0._FB
         CALL PARALLEL_WRITE_F32(2, EXTENT2, DSET_ID_PTS, PLIST_ID, START2, EXTENT2, RDATA_OUT3)
         
         ! Write types data to file
         CALL PARALLEL_WRITE_U8(1, EXTENT1, DSET_ID_TYP, PLIST_ID, START1, EXTENT1, VTKC_TYPE)
         
         DEALLOCATE(VERTICES)
         DEALLOCATE(OFFSETS)
         DEALLOCATE(CONNECT)
         DEALLOCATE(VTKC_TYPE)
         N_WRITTEN = N_WRITTEN + 1
      ENDIF
   ENDDO
   
   
   ! Close HDF5 datasets
   CALL H5DCLOSE_F(DSET_ID_CON, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCELLS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NPTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCON, ERROR)
   CALL H5DCLOSE_F(DSET_ID_OFF, ERROR)
   CALL H5DCLOSE_F(DSET_ID_PTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_TYP, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
   
END SUBROUTINE WRITE_VTKHDF_RECT_GAS_FILE_KEEPOPEN


SUBROUTINE INITIALIZE_VTKHDF_SMOKE3D_KEEPOPEN(T,&
   FILE_ID, PLIST_ID,GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   REAL(EB), INTENT(IN) :: T
   INTEGER(HID_T), INTENT(OUT) :: FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER :: ITM, ITM1
   CHARACTER(200) :: FILENAME
   REAL(EB) :: TT
   TT   = T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR
   ITM  = INT(TT)
   ITM1 = NINT(ABS(TT-ITM)*100)
   IF (ITM1==100) THEN
      ITM = ITM+1
      ITM1 = 0
   ENDIF
   WRITE(FILENAME,'(A,A,A,I8.8,I2.2,A)') "",TRIM(VTK_DIR)//TRIM(CHID),'_SM3D_',ITM,ITM1,'.vtkhdf'
   CALL WRITE_VTKHDF_RECT_GAS_FILE_KEEPOPEN(FILENAME,&
      FILE_ID, PLIST_ID,GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
END SUBROUTINE INITIALIZE_VTKHDF_SMOKE3D_KEEPOPEN





SUBROUTINE INITIALIZE_VTKHDF_SLCF_KEEPOPEN(T,II,&
   FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   INTEGER, INTENT(IN) :: II
   INTEGER(HID_T) :: CRP_LIST       ! Identifiers
   INTEGER(HID_T), INTENT(OUT) :: FILE_ID,PLIST_ID,GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4       ! Identifiers
   INTEGER(HID_T) :: DSET_ID_NCELLS, DSET_ID_NCON, DSET_ID_NPTS    ! Dataset identifiers
   INTEGER :: NPOINTS, NCELLS, IQ, NQT
   INTEGER :: NM, ERROR, ITM, ITM1, NX, NY, NZ, NCONNECTIONS
   TYPE(SLICE_TYPE), POINTER :: SL
   REAL(EB), INTENT(IN) :: T
   REAL(EB) :: TT
   REAL(FB) :: STIME
   CHARACTER(200) :: FILENAME, SLCFNAME
   INTEGER, DIMENSION(1:N_MPI_PROCESSES) :: MESHES_PER_PROCESS
   INTEGER :: N_WRITTEN
   INTEGER(HSIZE_T), DIMENSION(1) :: START1(1), EXTENT1(1)
   INTEGER(IB32), DIMENSION(1) :: IDATA_OUT_32(1)
   
   DO NM=1,N_MPI_PROCESSES
      MESHES_PER_PROCESS(NM) = 0
   ENDDO
   DO NM=1,NMESHES
      MESHES_PER_PROCESS(PROCESS(NM)+1) = MESHES_PER_PROCESS(PROCESS(NM)+1) + 1
   ENDDO
   
   SLCFNAME = TRIM(MESHES(1)%UNIQUE_SLICE_NAMES(II))
   STIME = REAL(T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR,FB)
   TT   = T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR
   ITM  = INT(TT)
   ITM1 = NINT(ABS(TT-ITM)*100)
   IF (ITM1==100) THEN
      ITM = ITM+1
      ITM1 = 0
   ENDIF
   WRITE(FILENAME,'(A,A,A,A,I8.8,I2.2,A)') TRIM(VTK_DIR)//TRIM(CHID),'_',&
                         TRIM(SLCFNAME),'_',ITM,ITM1,'.vtkhdf'
   ! Initialize file
   CALL CREATE_OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   START1 = NMESHES
   EXTENT1 = NMESHES
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfCells"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID_NCELLS, PLIST_ID) ! NumberOfCells
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfPoints"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID_NPTS, PLIST_ID) ! NumberOfPoints
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfConnectivityIds"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID_NCON, PLIST_ID) ! NumberOfConnectivityIds
   
   NQT = MESHES(1)%N_UNIQUE_SLCF
   ! Fill metadata
   N_WRITTEN=0
   MESH_LOOP: DO NM=1,NMESHES
      CALL POINT_TO_MESH(NM)
      IF (PROCESS(NM)/=MY_RANK) CYCLE MESH_LOOP
      NCELLS = 0
      NPOINTS = 0
      IF (MESHES(NM)%EMPTY_UNIQUE_SLICE(II)) THEN
         NCELLS = 0
         NPOINTS = 0
         NCONNECTIONS = 0
      ELSE
         QUANTITY_LOOP: DO IQ=1,MESHES(1)%N_SLCF_VTK
            SL => SLICE(IQ)
            IF (TRIM(SL%SLCF_NAME).NE.TRIM(SLCFNAME)) CYCLE QUANTITY_LOOP
            NX = SL%I2 + 1 - SL%I1
            NY = SL%J2 + 1 - SL%J1
            NZ = SL%K2 + 1 - SL%K1
            IF (SL%I2-SL%I1==0 .OR. SL%J2-SL%J1==0 .OR. SL%K2-SL%K1==0) THEN
               NCONNECTIONS=4 ! 2-D slice
            ELSEIF (MESHES(1)%UNIQUE_SLCF_AGL(II)>0) THEN
               NCONNECTIONS=4 ! 2-D slice
               NZ=1
            ELSE
               NCONNECTIONS=8 ! 3-D slice
            ENDIF
            NPOINTS = NX*NY*NZ
            NCELLS = MAX((NX-1),1)*MAX((NY-1),1)*MAX((NZ-1),1)
            EXIT
         ENDDO QUANTITY_LOOP
      ENDIF

      ! Write number of cells data to file
      START1 = NM-1
      EXTENT1 = 1
      IDATA_OUT_32 = NCELLS
      CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NCELLS, PLIST_ID, START1, EXTENT1, IDATA_OUT_32)
      
      ! Write number of points data to file
      START1 = NM-1
      EXTENT1 = 1
      IDATA_OUT_32 = NPOINTS
      CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NPTS, PLIST_ID, START1, EXTENT1, IDATA_OUT_32)
      
      ! Write NumberOfConnectivityIds data to file
      START1 = NM-1
      EXTENT1 = 1
      IDATA_OUT_32 = NCELLS*NCONNECTIONS
      CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NCON, PLIST_ID, START1, EXTENT1, IDATA_OUT_32)
      
      N_WRITTEN = N_WRITTEN + 1
   ENDDO MESH_LOOP
   
   ! Write fake data in processes that have less meshes than max process
   DO NM=1,MAXVAL(MESHES_PER_PROCESS)
      IF (N_WRITTEN < MAXVAL(MESHES_PER_PROCESS)) THEN
         NCELLS = 0
         NPOINTS = 0
         START1 = NM-1
         EXTENT1 = 0
         IDATA_OUT_32 = NCELLS
         CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NCELLS, PLIST_ID, START1, EXTENT1, IDATA_OUT_32)
      
         ! Write number of points data to file
         START1 = NM-1
         EXTENT1 = 0
         IDATA_OUT_32 = NPOINTS
         CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NPTS, PLIST_ID, START1, EXTENT1, IDATA_OUT_32)
      
         ! Write NumberOfConnectivityIds data to file
         START1 = NM-1
         EXTENT1 = 0
         IDATA_OUT_32 = NCELLS*NCONNECTIONS
         CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NCON, PLIST_ID, START1, EXTENT1, IDATA_OUT_32)
         N_WRITTEN = N_WRITTEN + 1
      ENDIF
   ENDDO
   
   ! Close VTKHDF interface
   CALL H5DCLOSE_F(DSET_ID_NCELLS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NPTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCON, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
END SUBROUTINE INITIALIZE_VTKHDF_SLCF_KEEPOPEN


SUBROUTINE WRITE_VTKHDF_GEOM_FILE()
   USE MPI_F08
   INTEGER(HID_T) :: FILE_ID, PLIST_ID, CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: DSET_ID_NCELLS, DSET_ID_NCON, DSET_ID_NPTS, DSET_ID    ! Dataset identifiers
   INTEGER(HID_T) :: DSET_ID_CON, DSET_ID_OFF, DSET_ID_PTS, DSET_ID_TYP
   INTEGER :: IP, II, LAST_OFFSET_VALUE
   INTEGER :: NFACES, NFACES_CUTCELLS, NVERTS, NVERTS_CUTCELLS
   INTEGER :: NM, NMNM, NM1, NM2, ERROR, PA_NCELLS, PA_NPOINTS
   CHARACTER(200) :: FILENAME
   INTEGER, DIMENSION(1:N_MPI_PROCESSES) :: MESHES_PER_PROCESS
   INTEGER :: N_WRITTEN, I, IERR, IPROC
   TYPE (MPI_STATUS) :: MPISTATUS
   TYPE(PATCH_TYPE), POINTER :: PA
   INTEGER, ALLOCATABLE, DIMENSION(:) :: LOCATIONS,FACES,SURFIND,GEOMIND
   REAL(FB), ALLOCATABLE, DIMENSION(:) :: VERTS
   REAL(FB), ALLOCATABLE, DIMENSION(:) :: X_PTS, Y_PTS, Z_PTS
   INTEGER :: NCELLS_ACCUM, NCELLS_MAX, NCELLS_TOTAL, NCELLS_START
   INTEGER :: NCONN_ACCUM, NCONN_MAX, NCONN_TOTAL, NCONN_START
   INTEGER :: NOFFSETS_ACCUM, NOFFSETS_MAX, NOFFSETS_TOTAL, NOFFSETS_START
   INTEGER :: NPOINTS_ACCUM, NPOINTS_MAX, NPOINTS_TOTAL, NPOINTS_START
   INTEGER(IB32), DIMENSION(1:2*NMESHES) :: NCELLS, NPOINTS
   INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS, ALL_CONNECT, ALL_OFFSETS
   INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE, ALL_VTKC_TYPE
   REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: VERTICES, ALL_VERTICES, COLORS, ALL_COLORS
   TYPE(MESH_TYPE), POINTER :: M !=>NULL()
   TYPE(OBSTRUCTION_TYPE), POINTER :: OB !=>NULL()
   REAL(FB) :: COLOR(3)
   INTEGER :: NINFO(6)
   INTEGER(HSIZE_T), DIMENSION(1) :: CDIM1(1), DDIM1(1), CDIM2(2), DDIM2(2)
   INTEGER(IB32), DIMENSION(1) :: DATA_OUT(1)
   INTEGER(HSIZE_T), DIMENSION(1) :: START1(1), EXTENT1(1), START2(2), EXTENT2(2)
   REAL(FB), DIMENSION(1) :: DATA_OUT2(2)
   INTEGER(IB8), DIMENSION(1) :: DATA_OUT_U8(1)

   ALLOCATE(NCELLS_VTK(1:2*NMESHES))
   ALLOCATE(NPOINTS_VTK(1:2*NMESHES))
   ALLOCATE(NCONNECTIONS_VTK(1:2*NMESHES))

   DO NM=1,N_MPI_PROCESSES
      MESHES_PER_PROCESS(NM) = 0
   ENDDO
   DO NM=1,NMESHES
      MESHES_PER_PROCESS(PROCESS(NM)+1) = MESHES_PER_PROCESS(PROCESS(NM)+1) + 1
      NM1 = 2*NM-1
      NM2 = 2*NM
      NCELLS_VTK(NM1) = 0
      NCELLS_VTK(NM2) = 0
      NPOINTS_VTK(NM1) = 0
      NPOINTS_VTK(NM2) = 0
      NCONNECTIONS_VTK(NM1) = 0
      NCONNECTIONS_VTK(NM2) = 0
   ENDDO
   
   ! Initialize file
   WRITE(FILENAME,'(A,A,A)') "",TRIM(CHID),'_GEOM.vtkhdf'
   CALL CREATE_OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)

   DDIM1 = 2*NMESHES
   CDIM1 = 2*NMESHES
   ! 2*NMESHES arrays. odds include OBST patches, evens include GEOM patches
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfCells"), CRP_LIST, 1,&
      DDIM1, CDIM1, DSET_ID_NCELLS, PLIST_ID) ! NumberOfCells
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfPoints"), CRP_LIST, 1,&
      DDIM1, CDIM1, DSET_ID_NPTS, PLIST_ID) ! NumberOfPoints
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfConnectivityIds"), CRP_LIST, 1,&
      DDIM1, CDIM1, DSET_ID_NCON, PLIST_ID) ! NumberOfConnectivityIds
      
   ! Fill metadata
   N_WRITTEN=0
   MESH_LOOP: DO NM=1,NMESHES
      CALL POINT_TO_MESH(NM)
      M => MESHES(NM)
      NM1 = 2*NM-1
      NM2 = 2*NM
      IF (PROCESS(NM)/=MY_RANK) THEN
         CYCLE MESH_LOOP
      ENDIF
      NCELLS_ACCUM = 0
      NPOINTS_ACCUM = 0
      NCONN_ACCUM = 0
      ! Count OBST patch info
      IF (MESHES(NM)%N_PATCH>0) THEN
         PATCH_LOOP1: DO IP=1,N_PATCH
            PA => PATCH(IP)
            IF (PA%OBST_INDEX<=0) CYCLE PATCH_LOOP1
            !INTERPOLATED_BOUNDARY
            ! Initialize piece
            CALL BUILD_VTK_SOLID_PHASE_GEOMETRY(NM, PA, NCELLS(NM1), NPOINTS(NM1),&
               X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)
            NCONN_ACCUM = NCONN_ACCUM + NCELLS(NM1)*4
            NCELLS_ACCUM = NCELLS_ACCUM + NCELLS(NM1)
            NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS(NM1)
            CALL DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)
         ENDDO PATCH_LOOP1
      ENDIF
      
      NCELLS_VTK(NM1) = NCELLS_ACCUM
      NPOINTS_VTK(NM1) = NPOINTS_ACCUM
      NCONNECTIONS_VTK(NM1) = NCONN_ACCUM
      DDIM1 = NM1-1
      CDIM1 = 1
      ! Write number of cells data to file
      DATA_OUT = NCELLS_ACCUM
      CALL PARALLEL_WRITE_I32(1, CDIM1, DSET_ID_NCELLS, PLIST_ID, DDIM1, CDIM1, DATA_OUT)
      
      ! Write number of points data to file
      DATA_OUT = NPOINTS_ACCUM
      CALL PARALLEL_WRITE_I32(1, CDIM1, DSET_ID_NPTS, PLIST_ID, DDIM1, CDIM1, DATA_OUT)
      
      ! Write NumberOfConnectivityIds data to file
      DATA_OUT = NCONN_ACCUM
      CALL PARALLEL_WRITE_I32(1, CDIM1, DSET_ID_NCON, PLIST_ID, DDIM1, CDIM1, DATA_OUT)
      
      ! Count GEOM patch info
      NCELLS_ACCUM = 0
      NPOINTS_ACCUM = 0
      NCONN_ACCUM = 0
      IF (MESHES(NM)%N_INTERNAL_CFACE_CELLS>0) THEN
         CALL GET_GEOMSIZES_DUP('INBOUND_FACES',0,0,0,0,0,0,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS)
         IF (NVERTS>0 .AND. NFACES>0) THEN
            ALLOCATE(VERTS(3*NVERTS))
            ALLOCATE(FACES(3*NFACES))
            ALLOCATE(LOCATIONS(NFACES))
            ALLOCATE(SURFIND(NFACES))
            ALLOCATE(GEOMIND(NFACES))
            CALL GET_GEOMINFO_DUP('INBOUND_FACES',0,0,0,0,0,0,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS,&
                              VERTS,FACES,LOCATIONS,SURFIND=SURFIND,GEOMIND=GEOMIND)
            CALL BUILD_VTK_GEOM_GEOMETRY(VERTS, FACES, NCELLS(NM2), NPOINTS(NM2), X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)
            DEALLOCATE(VERTS)
            DEALLOCATE(FACES)
            DEALLOCATE(LOCATIONS)
            DEALLOCATE(SURFIND)
            DEALLOCATE(GEOMIND)
            
            CALL DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)
            
            NCONN_ACCUM = NCONN_ACCUM + NCELLS(NM2)*3
            NCELLS_ACCUM = NCELLS_ACCUM + NCELLS(NM2)
            NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS(NM2)
         ENDIF
      ENDIF
      
      NCELLS_VTK(NM2) = NCELLS_ACCUM
      NPOINTS_VTK(NM2) = NPOINTS_ACCUM
      NCONNECTIONS_VTK(NM2) = NCONN_ACCUM
      DDIM1 = NM2-1
      CDIM1 = 1
      ! Write number of cells data to file
      DATA_OUT = (/NCELLS_ACCUM/)
      CALL PARALLEL_WRITE_I32(1, CDIM1, DSET_ID_NCELLS, PLIST_ID, DDIM1, CDIM1, DATA_OUT)
      
      ! Write number of points data to file
      DATA_OUT = (/NPOINTS_ACCUM/)
      CALL PARALLEL_WRITE_I32(1, CDIM1, DSET_ID_NPTS, PLIST_ID, DDIM1, CDIM1, DATA_OUT)
      
      ! Write NumberOfConnectivityIds data to file
      DATA_OUT = (/NCONN_ACCUM/)
      CALL PARALLEL_WRITE_I32(1, CDIM1, DSET_ID_NCON, PLIST_ID, DDIM1, CDIM1, DATA_OUT)
      
      N_WRITTEN = N_WRITTEN + 1
   ENDDO MESH_LOOP

   ! Write fake data in processes that have less meshes than max process
   DO NM=1,MAXVAL(MESHES_PER_PROCESS)
      IF (N_WRITTEN < MAXVAL(MESHES_PER_PROCESS)) THEN
         DDIM1 = NM1-1
         CDIM1 = 0
         DATA_OUT = 0
         DO I=1,2 ! Loop through 2x to write empty twice per mesh
            CALL PARALLEL_WRITE_I32(1, CDIM1, DSET_ID_NCELLS, PLIST_ID, DDIM1, CDIM1, DATA_OUT)
         
            ! Write number of points data to file
            CALL PARALLEL_WRITE_I32(1, CDIM1, DSET_ID_NPTS, PLIST_ID, DDIM1, CDIM1, DATA_OUT)
         
            ! Write NumberOfConnectivityIds data to file
            CALL PARALLEL_WRITE_I32(1, CDIM1, DSET_ID_NCON, PLIST_ID, DDIM1, CDIM1, DATA_OUT)
         ENDDO
         N_WRITTEN = N_WRITTEN + 1
      ENDIF
   ENDDO

   ! Close VTKHDF interface
   !CALL MPI_BARRIER(MPI_COMM_WORLD, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCELLS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NPTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCON, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
   CALL CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)

   ! Exchange boundary NCELLS, NPOINTS, and NCONNECTIONS
   MESH_LOOP2: DO NM=1,NMESHES
      NM1 = 2*NM-1
      NM2 = 2*NM
      IF (PROCESS(NM)/=MY_RANK) THEN
         CALL MPI_RECV(NINFO,6,MPI_INTEGER,PROCESS(NM),PROCESS(NM),MPI_COMM_WORLD,MPISTATUS,IERR)
         NCELLS_VTK(NM1) = INT(NINFO(1),IB32)
         NPOINTS_VTK(NM1) = INT(NINFO(2),IB32)
         NCONNECTIONS_VTK(NM1) = INT(NINFO(3),IB32)
         NCELLS_VTK(NM2) = INT(NINFO(4),IB32)
         NPOINTS_VTK(NM2) = INT(NINFO(5),IB32)
         NCONNECTIONS_VTK(NM2) = INT(NINFO(6),IB32)
         CYCLE MESH_LOOP2
      ELSE
         NINFO = INT((/NCELLS_VTK(NM1),NPOINTS_VTK(NM1),NCONNECTIONS_VTK(NM1),&
                      NCELLS_VTK(NM2),NPOINTS_VTK(NM2),NCONNECTIONS_VTK(NM2)/))
         DO IPROC=0,N_MPI_PROCESSES-1
            IF (MY_RANK/=IPROC) THEN
               CALL MPI_SEND(NINFO,6,MPI_INTEGER,IPROC,MY_RANK,MPI_COMM_WORLD,IERR)
            ENDIF
         ENDDO
      ENDIF
   ENDDO MESH_LOOP2
   
   ! Reopen VTKHDF INTERFACE
   CALL OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
   NPOINTS_TOTAL=0
   NCELLS_TOTAL=0
   NCELLS_ACCUM=0
   NPOINTS_ACCUM=0
   NOFFSETS_TOTAL=0
   NOFFSETS_ACCUM = 0
   NCONN_TOTAL = 0
   NCONN_ACCUM = 0
   NCELLS_MAX = 1
   NPOINTS_MAX = 1
   NCONN_MAX = 1
   NOFFSETS_MAX = 1
   NPOINTS_START = 0
   
   MESH_LOOP_HDF_COUNT: DO NMNM=1,2*NMESHES
      NPOINTS_TOTAL = NPOINTS_TOTAL + NPOINTS_VTK(NMNM)
      NCELLS_TOTAL = NCELLS_TOTAL + NCELLS_VTK(NMNM)
      NOFFSETS_TOTAL = NOFFSETS_TOTAL + NCELLS_VTK(NMNM) + 1
      NCONN_TOTAL = NCONN_TOTAL + NCONNECTIONS_VTK(NMNM)
      NCELLS_MAX = MAX(NCELLS_MAX,NCELLS_VTK(NMNM))
      NPOINTS_MAX = MAX(NPOINTS_MAX,NPOINTS_VTK(NMNM))
      NOFFSETS_MAX = MAX(NOFFSETS_MAX,NCELLS_VTK(NMNM) + 1)
      NCONN_MAX = MAX(NCONN_MAX,NCONNECTIONS_VTK(NMNM))
   ENDDO MESH_LOOP_HDF_COUNT
   
   DDIM1 = NCONN_MAX
   CDIM1 = NCONN_TOTAL
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Connectivity"), CRP_LIST, 1, DDIM1,CDIM1, DSET_ID_CON, PLIST_ID) ! Connectivity
   DDIM1 = NOFFSETS_MAX
   CDIM1 = NOFFSETS_TOTAL
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Offsets"), CRP_LIST, 1, DDIM1,CDIM1, DSET_ID_OFF, PLIST_ID) ! Offsets
   DDIM2(1:2) = (/3_HSIZE_T, INT(NPOINTS_MAX,HSIZE_T)/)
   CDIM2(1:2) = (/3_HSIZE_T, INT(NPOINTS_TOTAL,HSIZE_T)/)
   CALL PARALLEL_INIT_F32(GROUP_ID1, TRIM("Points"), CRP_LIST, 2, DDIM2,CDIM2, DSET_ID_PTS, PLIST_ID) ! Points
   DDIM1 = NCELLS_MAX
   CDIM1 = NCELLS_TOTAL
   CALL PARALLEL_INIT_U8(GROUP_ID1, TRIM("Types"), CRP_LIST, 1, DDIM1,CDIM1, DSET_ID_TYP, PLIST_ID) ! Types
   
   CALL POINT_TO_MESH(1)
   DDIM2(1:2) = (/3_HSIZE_T, INT(NCELLS_MAX,HSIZE_T)/)
   CDIM2(1:2) = (/3_HSIZE_T, INT(NCELLS_TOTAL,HSIZE_T)/)
   CALL PARALLEL_INIT_F32(GROUP_ID2, "Color", CRP_LIST, 2, DDIM2,CDIM2, DSET_ID, PLIST_ID) ! Data
   
   ! Fill metadata
   N_WRITTEN=0
   MESH_LOOP_HDF: DO NM=1,NMESHES
      NM1 = 2*NM-1
      NM2 = 2*NM
      NPOINTS_START = NPOINTS_ACCUM
      NCELLS_START = NCELLS_ACCUM
      NCONN_START = NCONN_ACCUM
      NOFFSETS_START = NOFFSETS_ACCUM
      LAST_OFFSET_VALUE = 0
      IF (PROCESS(NM)/=MY_RANK) THEN
         NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS_VTK(NM1) + NPOINTS_VTK(NM2)
         NCELLS_ACCUM = NCELLS_ACCUM + NCELLS_VTK(NM1) + NCELLS_VTK(NM2)
         NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS_VTK(NM1)+1
         NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS_VTK(NM2)+1
         NCONN_ACCUM = NCONN_ACCUM + NCONNECTIONS_VTK(NM1) + NCONNECTIONS_VTK(NM2)
         CYCLE MESH_LOOP_HDF
      ENDIF
      CALL POINT_TO_MESH(NM)
      ! Build OBST boundary geometry
      IF (MESHES(NM)%N_PATCH>0) THEN
         ALLOCATE(ALL_VERTICES(3,NPOINTS_VTK(NM1)))
         ALLOCATE(ALL_CONNECT(NCONNECTIONS_VTK(NM1)))
         ALLOCATE(ALL_OFFSETS(NCELLS_VTK(NM1)+1))
         ALLOCATE(ALL_VTKC_TYPE(NCELLS_VTK(NM1)))
         ALLOCATE(ALL_COLORS(3,NCELLS_VTK(NM1)))
         ALL_OFFSETS(NOFFSETS_ACCUM-NOFFSETS_START+1) = 0
         PATCH_LOOP2: DO IP=1,N_PATCH
            PA => PATCH(IP)
            IF (PA%OBST_INDEX<=0) CYCLE PATCH_LOOP2
            M => MESHES(NM)
            IF (PA%OBST_INDEX >= SIZE(M%OBSTRUCTION)) THEN
               COLOR = REAL((/0.5,0.5,0.5/))
            ELSE
               OB=>M%OBSTRUCTION(PA%OBST_INDEX)
               IF (OB%RGB(1)==-1) THEN
                  SELECT CASE(PA%IOR)
                     CASE (-1)
                        COLOR = REAL(SURFACE(OB%SURF_INDEX(-1))%RGB,FB)/255._FB
                     CASE (1)
                        COLOR = REAL(SURFACE(OB%SURF_INDEX(1))%RGB,FB)/255._FB
                     CASE (-2)
                        COLOR = REAL(SURFACE(OB%SURF_INDEX(-2))%RGB,FB)/255._FB
                     CASE (2)
                        COLOR = REAL(SURFACE(OB%SURF_INDEX(2))%RGB,FB)/255._FB
                     CASE (-3)
                        COLOR = REAL(SURFACE(OB%SURF_INDEX(-3))%RGB,FB)/255._FB
                     CASE (3)
                        COLOR = REAL(SURFACE(OB%SURF_INDEX(3))%RGB,FB)/255._FB
                  ENDSELECT
               ELSE
                  COLOR = REAL(OB%RGB,FB)/255._FB
               ENDIF
            ENDIF
               
            ! Initialize piece
            CALL BUILD_VTK_SOLID_PHASE_GEOMETRY(NM, PA, PA_NCELLS, PA_NPOINTS,&
               X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)
            ALLOCATE(VERTICES(3,PA_NPOINTS))
            DO II=1,PA_NPOINTS
               VERTICES(1:3,II) = (/X_PTS(II),Y_PTS(II),Z_PTS(II)/)
            ENDDO
            ALLOCATE(COLORS(3,PA_NCELLS))
            DO II=1,PA_NCELLS
               COLORS(1:3,II) = COLOR
            ENDDO
            ALL_VERTICES(:,NPOINTS_ACCUM-NPOINTS_START+1:NPOINTS_ACCUM-NPOINTS_START+PA_NPOINTS) = VERTICES
            ALL_CONNECT(NCONN_ACCUM-NCONN_START+1:NCONN_ACCUM-NCONN_START+PA_NCELLS*4) = CONNECT + NPOINTS_ACCUM-NPOINTS_START
            OFFSETS = OFFSETS + LAST_OFFSET_VALUE
            LAST_OFFSET_VALUE = OFFSETS(SIZE(OFFSETS))
            ALL_OFFSETS(NOFFSETS_ACCUM-NOFFSETS_START+2:NOFFSETS_ACCUM-NOFFSETS_START+PA_NCELLS+1) = OFFSETS
            ALL_VTKC_TYPE(NCELLS_ACCUM-NCELLS_START+1:NCELLS_ACCUM-NCELLS_START+PA_NCELLS) = VTKC_TYPE
            ALL_COLORS(:,NCELLS_ACCUM-NCELLS_START+1:NCELLS_ACCUM-NCELLS_START+PA_NCELLS) = COLORS
            NCONN_ACCUM = NCONN_ACCUM + PA_NCELLS*4
            NCELLS_ACCUM = NCELLS_ACCUM + PA_NCELLS
            NPOINTS_ACCUM = NPOINTS_ACCUM + PA_NPOINTS
            NOFFSETS_ACCUM = NOFFSETS_ACCUM + PA_NCELLS
            CALL DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)
            DEALLOCATE(VERTICES)
            DEALLOCATE(COLORS)
         ENDDO PATCH_LOOP2
         
         ! Write connectivity data to file
         START1 = INT(NCONN_START,HSIZE_T)
         EXTENT1 = INT(NCONNECTIONS_VTK(NM1),HSIZE_T)
         CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_CON, PLIST_ID, START1, EXTENT1, ALL_CONNECT)
            
         ! Write offsets data to file
         START1 = INT(NOFFSETS_START,HSIZE_T)
         EXTENT1 = INT(NCELLS_VTK(NM1)+1,HSIZE_T)
         CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_OFF, PLIST_ID, START1, EXTENT1, ALL_OFFSETS)
         
         ! Write point data to file
         START2(1:2) = INT((/0,NPOINTS_START/),HSIZE_T)
         EXTENT2(1:2) = INT((/3, NPOINTS_VTK(NM1)/),HSIZE_T)
         CALL PARALLEL_WRITE_F32(2, EXTENT2, DSET_ID_PTS, PLIST_ID, START2, EXTENT2, ALL_VERTICES)
         
         ! Write types data to file
         START1 = INT(NCELLS_START,HSIZE_T)
         EXTENT1 = INT(NCELLS_VTK(NM1),HSIZE_T)
         CALL PARALLEL_WRITE_U8(1, EXTENT1, DSET_ID_TYP, PLIST_ID, START1, EXTENT1, ALL_VTKC_TYPE)
         
         ! Write color data to file
         START2(1:2) = INT((/0,NCELLS_START/),HSIZE_T)
         EXTENT2(1:2) = INT((/3, NCELLS_VTK(NM1)/),HSIZE_T)
         CALL PARALLEL_WRITE_F32(2, EXTENT2, DSET_ID, PLIST_ID, START2, EXTENT2, ALL_COLORS)
         
         DEALLOCATE(ALL_VERTICES)
         DEALLOCATE(ALL_CONNECT)
         DEALLOCATE(ALL_OFFSETS)
         DEALLOCATE(ALL_VTKC_TYPE)
         DEALLOCATE(ALL_COLORS)
         N_WRITTEN = N_WRITTEN + 1
      ENDIF
      ! Build GEOM patch geometry
      IF ((MESHES(NM)%N_INTERNAL_CFACE_CELLS>0).AND.(.TRUE.)) THEN
         NPOINTS_START = NPOINTS_ACCUM
         NCELLS_START = NCELLS_ACCUM
         NCONN_START = NCONN_ACCUM
         NOFFSETS_START = NOFFSETS_ACCUM
         CALL GET_GEOMSIZES_DUP('INBOUND_FACES',0,0,0,0,0,0,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS)
         IF (NVERTS>0 .AND. NFACES>0) THEN
            ALLOCATE(ALL_OFFSETS(NCELLS_VTK(NM2)+1))
            ALLOCATE(VERTS(3*NVERTS))
            ALLOCATE(FACES(3*NFACES))
            ALLOCATE(LOCATIONS(NFACES))
            ALLOCATE(SURFIND(NFACES))
            ALLOCATE(GEOMIND(NFACES))
            CALL GET_GEOMINFO_DUP('INBOUND_FACES',0,0,0,0,0,0,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS,&
                              VERTS,FACES,LOCATIONS,SURFIND=SURFIND,GEOMIND=GEOMIND)
            CALL BUILD_VTK_GEOM_GEOMETRY(VERTS, FACES, PA_NCELLS, PA_NPOINTS, X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)
            ALLOCATE(VERTICES(3,PA_NPOINTS))
            DO II=1,PA_NPOINTS
               VERTICES(1:3,II) = (/X_PTS(II),Y_PTS(II),Z_PTS(II)/)
            ENDDO
            ALLOCATE(COLORS(3,PA_NCELLS))
            DO II=1,PA_NCELLS
               COLOR = REAL(SURFACE(SURFIND(II))%RGB,FB)/255._FB
               COLORS(1:3,II) = COLOR
            ENDDO
            
            ALL_OFFSETS(1) = 0
            ALL_OFFSETS(2:NCELLS_VTK(NM2)+1) = OFFSETS
            NCONN_ACCUM = NCONN_ACCUM + PA_NCELLS*3
            NCELLS_ACCUM = NCELLS_ACCUM + PA_NCELLS
            NPOINTS_ACCUM = NPOINTS_ACCUM + PA_NPOINTS
            NOFFSETS_ACCUM = NOFFSETS_ACCUM + PA_NCELLS + 1
            
            ! Write connectivity data to file
            START1 = INT(NCONN_START,HSIZE_T)
            EXTENT1 = INT(NCONNECTIONS_VTK(NM2),HSIZE_T)
            CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_CON, PLIST_ID, START1, EXTENT1, CONNECT)
               
            ! Write offsets data to file
            START1 = INT(NOFFSETS_START+1,HSIZE_T)
            EXTENT1 = INT(NCELLS_VTK(NM2)+1,HSIZE_T)
            CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_OFF, PLIST_ID, START1, EXTENT1, ALL_OFFSETS)
            
            ! Write point data to file
            START2(1:2) = INT((/0,NPOINTS_START/),HSIZE_T)
            EXTENT2(1:2) = INT((/3, NPOINTS_VTK(NM2)/),HSIZE_T)
            CALL PARALLEL_WRITE_F32(2, EXTENT2, DSET_ID_PTS, PLIST_ID, START2, EXTENT2, VERTICES)
            
            ! Write types data to file
            START1 = INT(NCELLS_START,HSIZE_T)
            EXTENT1 = INT(NCELLS_VTK(NM2),HSIZE_T)
            CALL PARALLEL_WRITE_U8(1, EXTENT1, DSET_ID_TYP, PLIST_ID, START1, EXTENT1, VTKC_TYPE)
            
            ! Write color data to file
            START2(1:2) = INT((/0,NCELLS_START/),HSIZE_T)
            EXTENT2(1:2) = INT((/3, NCELLS_VTK(NM2)/),HSIZE_T)
            CALL PARALLEL_WRITE_F32(2, EXTENT2, DSET_ID, PLIST_ID, START2, EXTENT2, COLORS)
            
            DEALLOCATE(VERTS)
            DEALLOCATE(FACES)
            DEALLOCATE(LOCATIONS)
            DEALLOCATE(SURFIND)
            DEALLOCATE(GEOMIND)
            DEALLOCATE(VERTICES)
            DEALLOCATE(ALL_OFFSETS)
            DEALLOCATE(COLORS)
            CALL DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)
            N_WRITTEN = N_WRITTEN + 1
         ENDIF
      ENDIF
   ENDDO MESH_LOOP_HDF
   
   ! Write fake data in processes that have less meshes than max process
   DO NM=1,MAXVAL(MESHES_PER_PROCESS)*2
      IF (N_WRITTEN < MAXVAL(MESHES_PER_PROCESS)*2) THEN

         ! Write connectivity data to file
         START1 = 0
         EXTENT1 = 0
         DATA_OUT = 0
         CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_CON, PLIST_ID, START1, EXTENT1, DATA_OUT)
            
         ! Write offsets data to file
         CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_OFF, PLIST_ID, START1, EXTENT1, DATA_OUT)
         
         ! Write point data to file
         START2 = 0
         EXTENT2 = 0
         DATA_OUT2 = 0
         CALL PARALLEL_WRITE_F32(2, EXTENT2, DSET_ID_PTS, PLIST_ID, START2, EXTENT2, DATA_OUT2)
         
         ! Write types data to file
         DATA_OUT_U8 = 0
         CALL PARALLEL_WRITE_U8(1, EXTENT1, DSET_ID_TYP, PLIST_ID, START1, EXTENT1, DATA_OUT_U8)
         
         ! Write color data to file
         CALL PARALLEL_WRITE_F32(2, EXTENT1, DSET_ID, PLIST_ID, START2, EXTENT2, DATA_OUT2)
         
         N_WRITTEN = N_WRITTEN + 1
      ENDIF
   ENDDO
   
   ! Close VTKHDF interface
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL H5DCLOSE_F(DSET_ID_CON, ERROR)
   CALL H5DCLOSE_F(DSET_ID_OFF, ERROR)
   CALL H5DCLOSE_F(DSET_ID_PTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_TYP, ERROR)
   CALL CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
END SUBROUTINE WRITE_VTKHDF_GEOM_FILE



SUBROUTINE INITIALIZE_VTKHDF_BNDF(T,&
   FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   INTEGER(HID_T) :: CRP_LIST       ! Identifiers
   INTEGER(HID_T), INTENT(OUT) :: FILE_ID, PLIST_ID,GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: DSET_ID_NCELLS, DSET_ID_NCON, DSET_ID_NPTS    ! Dataset identifiers
   INTEGER(HID_T) :: DSET_ID, DSET_ID_CON, DSET_ID_OFF, DSET_ID_PTS, DSET_ID_TYP       ! Dataset identifiers
   INTEGER :: PA_NPOINTS, PA_NCELLS, II, IP
   INTEGER :: NPOINTS, NCELLS, NPOINTS_ACCUM, NCELLS_ACCUM, NCONNECTIONS_ACCUM
   INTEGER :: NFACES, NFACES_CUTCELLS, NVERTS, NVERTS_CUTCELLS
   INTEGER :: N, NM, NM1, NM2, NMNM, ERROR, ITM, ITM1, NCONNECTIONS
   INTEGER :: NCELLS_MAX, NCELLS_TOTAL, NCELLS_START
   INTEGER :: NCONN_ACCUM, NCONN_MAX, NCONN_TOTAL, NCONN_START
   INTEGER :: NOFFSETS_ACCUM, NOFFSETS_MAX, NOFFSETS_TOTAL, NOFFSETS_START
   INTEGER :: NPOINTS_MAX, NPOINTS_TOTAL, NPOINTS_START
   REAL(EB), INTENT(IN) :: T
   CHARACTER(200) :: FILENAME
   INTEGER, DIMENSION(1:N_MPI_PROCESSES) :: MESHES_PER_PROCESS
   INTEGER :: N_WRITTEN, I, IPROC, IERR
   TYPE(PATCH_TYPE), POINTER :: PA
   INTEGER, ALLOCATABLE, DIMENSION(:) :: LOCATIONS,FACES,SURFIND,GEOMIND
   REAL(FB), ALLOCATABLE, DIMENSION(:) :: VERTS
   REAL(FB), ALLOCATABLE, DIMENSION(:) :: X_PTS, Y_PTS, Z_PTS
   REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: VERTICES, ALL_VERTICES
   INTEGER(IB32) :: LAST_OFFSET_VALUE
   INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS, ALL_CONNECT, ALL_OFFSETS
   INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE, ALL_VTKC_TYPE
   REAL(FB) :: STIME
   INTEGER(HSIZE_T), DIMENSION(1) :: START1(1), EXTENT1(1), START2(2), EXTENT2(2)
   INTEGER(IB32), DIMENSION(1) :: IDATA_OUT1(1)
   INTEGER(IB8), DIMENSION(1) :: DATA_OUT1_U8(1)
   REAL(FB), DIMENSION(1) :: FDATA_OUT3(3)
   INTEGER :: NINFO(6)
   TYPE (MPI_STATUS) :: MPISTATUS
   TYPE (BOUNDARY_FILE_TYPE), POINTER :: BF=>NULL()

   DO NM=1,N_MPI_PROCESSES
      MESHES_PER_PROCESS(NM) = 0
   ENDDO
   DO NM=1,NMESHES
      MESHES_PER_PROCESS(PROCESS(NM)+1) = MESHES_PER_PROCESS(PROCESS(NM)+1) + 1
   ENDDO

   ! Initialize file
   STIME = REAL(T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR,FB)
   ITM  = INT(STIME)
   ITM1 = NINT(ABS(STIME-ITM)*100)
   IF (ITM1==100) THEN
      ITM = ITM+1
      ITM1 = 0
   ENDIF
   WRITE(FILENAME,'(A,A,A,I8.8,I2.2,A)') "",TRIM(VTK_DIR)//TRIM(CHID),'_BNDF_',ITM,ITM1,'.vtkhdf'
   CALL CREATE_OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
   ! 2*NMESHES arrays. odds include OBST patches, evens include GEOM patches
   START1 = 2*NMESHES
   EXTENT1 = 2*NMESHES
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfCells"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID_NCELLS, PLIST_ID) ! NumberOfCells
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfPoints"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID_NPTS, PLIST_ID) ! NumberOfPoints
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfConnectivityIds"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID_NCON, PLIST_ID) ! NumberOfConnectivityIds
   
   ! Fill metadata
   N_WRITTEN=0
   MESH_LOOP: DO NM=1,NMESHES
      CALL POINT_TO_MESH(NM)
      IF (PROCESS(NM)/=MY_RANK) CYCLE MESH_LOOP
      NCELLS = 0
      NPOINTS = 0
      NCELLS_ACCUM = 0
      NPOINTS_ACCUM = 0
      NCONNECTIONS_ACCUM = 0
      ! Count OBST patch info
      IF (MESHES(NM)%N_PATCH>0) THEN
         PATCH_LOOP1: DO IP=1,N_PATCH
            PA => PATCH(IP)
            IF (PA%OBST_INDEX<=0) CYCLE PATCH_LOOP1
            ! Initialize piece
            CALL BUILD_VTK_SOLID_PHASE_GEOMETRY(NM, PA, NCELLS, NPOINTS,&
               X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)
            NCONNECTIONS_ACCUM = NCONNECTIONS_ACCUM + NCELLS*4
            NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
            NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
            CALL DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)
         ENDDO PATCH_LOOP1
      ENDIF
      
      ! Write number of cells data to file
      START1 = 2*(NM-1)
      EXTENT1 = 1
      IDATA_OUT1 = NCELLS_ACCUM
      CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NCELLS, PLIST_ID, START1, EXTENT1, IDATA_OUT1)
      
      ! Write number of points data to file
      START1 = 2*(NM-1)
      EXTENT1 = 1
      IDATA_OUT1 = NPOINTS_ACCUM
      CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NPTS, PLIST_ID, START1, EXTENT1, IDATA_OUT1)
      
      ! Write NumberOfConnectivityIds data to file
      START1 = 2*(NM-1)
      EXTENT1 = 1
      IDATA_OUT1 = NCONNECTIONS_ACCUM
      CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NCON, PLIST_ID, START1, EXTENT1, IDATA_OUT1)
      
      ! Count GEOM patch info
      NCELLS = 0
      NPOINTS = 0
      NCELLS_ACCUM = 0
      NPOINTS_ACCUM = 0
      NCONNECTIONS_ACCUM = 0
      IF (MESHES(NM)%N_INTERNAL_CFACE_CELLS>0) THEN
         CALL GET_GEOMSIZES_DUP('INBOUND_FACES',0,0,0,0,0,0,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS)
         IF (NVERTS>0 .AND. NFACES>0) THEN
            ALLOCATE(VERTS(3*NVERTS))
            ALLOCATE(FACES(3*NFACES))
            ALLOCATE(LOCATIONS(NFACES))
            ALLOCATE(SURFIND(NFACES))
            ALLOCATE(GEOMIND(NFACES))
            CALL GET_GEOMINFO_DUP('INBOUND_FACES',0,0,0,0,0,0,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS,&
                              VERTS,FACES,LOCATIONS,SURFIND=SURFIND,GEOMIND=GEOMIND)
            CALL BUILD_VTK_GEOM_GEOMETRY(VERTS, FACES, NCELLS, NPOINTS, X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)
            DEALLOCATE(VERTS)
            DEALLOCATE(FACES)
            DEALLOCATE(LOCATIONS)
            DEALLOCATE(SURFIND)
            DEALLOCATE(GEOMIND)
            
            CALL DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)
            
            NCONNECTIONS_ACCUM = NCONNECTIONS_ACCUM + NCELLS*3
            NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
            NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
         ENDIF
      ENDIF
      
      ! Write number of cells data to file
      START1 = 2*(NM-1)+1
      EXTENT1 = 1
      IDATA_OUT1 = NCELLS_ACCUM
      CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NCELLS, PLIST_ID, START1, EXTENT1, IDATA_OUT1)
      
      ! Write number of points data to file
      START1 = 2*(NM-1)+1
      EXTENT1 = 1
      IDATA_OUT1 = NPOINTS_ACCUM
      CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NPTS, PLIST_ID, START1, EXTENT1, IDATA_OUT1)
      
      ! Write NumberOfConnectivityIds data to file
      START1 = 2*(NM-1)+1
      EXTENT1 = 1
      IDATA_OUT1 = NCONNECTIONS_ACCUM
      CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NCON, PLIST_ID, START1, EXTENT1, IDATA_OUT1)
      
      N_WRITTEN = N_WRITTEN + 1
   ENDDO MESH_LOOP
   
   ! Write fake data in processes that have less meshes than max process
   DO NM=1,MAXVAL(MESHES_PER_PROCESS)
      IF (N_WRITTEN < MAXVAL(MESHES_PER_PROCESS)) THEN
         NCELLS = 0
         NPOINTS = 0
         NCONNECTIONS = 0
         START1 = NM-1
         EXTENT1 = 0
         IDATA_OUT1 = 0
         DO I=1,2 ! Loop through 2x to write empty twice per mesh
            CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NCELLS, PLIST_ID, START1, EXTENT1, IDATA_OUT1)
         
            ! Write number of points data to file
            CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NPTS, PLIST_ID, START1, EXTENT1, IDATA_OUT1)
         
            ! Write NumberOfConnectivityIds data to file
            CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_NCON, PLIST_ID, START1, EXTENT1, IDATA_OUT1)
         ENDDO
            
         N_WRITTEN = N_WRITTEN + 1
      ENDIF
   ENDDO
   
   ! Close VTKHDF interface
   CALL H5DCLOSE_F(DSET_ID_NCELLS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NPTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCON, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
   ! Exchange boundary NCELLS, NPOINTS, and NCONNECTIONS
   MESH_LOOP2: DO NM=1,NMESHES
      NM1 = 2*NM-1
      NM2 = 2*NM
      IF (PROCESS(NM)/=MY_RANK) THEN
         CALL MPI_RECV(NINFO,6,MPI_INTEGER,PROCESS(NM),PROCESS(NM),MPI_COMM_WORLD,MPISTATUS,IERR)
         NCELLS_VTK(NM1) = INT(NINFO(1),IB32)
         NPOINTS_VTK(NM1) = INT(NINFO(2),IB32)
         NCONNECTIONS_VTK(NM1) = INT(NINFO(3),IB32)
         NCELLS_VTK(NM2) = INT(NINFO(4),IB32)
         NPOINTS_VTK(NM2) = INT(NINFO(5),IB32)
         NCONNECTIONS_VTK(NM2) = INT(NINFO(6),IB32)
         CYCLE MESH_LOOP2
      ELSE
         NINFO = INT((/NCELLS_VTK(NM1),NPOINTS_VTK(NM1),NCONNECTIONS_VTK(NM1),&
                      NCELLS_VTK(NM2),NPOINTS_VTK(NM2),NCONNECTIONS_VTK(NM2)/))
         DO IPROC=0,N_MPI_PROCESSES-1
            IF (MY_RANK/=IPROC) THEN
               CALL MPI_SEND(NINFO,6,MPI_INTEGER,IPROC,MY_RANK,MPI_COMM_WORLD,IERR)
            ENDIF
         ENDDO
      ENDIF
   ENDDO MESH_LOOP2


   NPOINTS_TOTAL=0
   NCELLS_TOTAL=0
   NCELLS_ACCUM=0
   NPOINTS_ACCUM=0
   NOFFSETS_TOTAL=0
   NOFFSETS_ACCUM = 0
   NCONN_TOTAL = 0
   NCONN_ACCUM = 0
   NCELLS_MAX = 1
   NPOINTS_MAX = 1
   NCONN_MAX = 1
   NOFFSETS_MAX = 1
   NPOINTS_START = 0
   
   MESH_LOOP_HDF_COUNT: DO NMNM=1,2*NMESHES
      NPOINTS_TOTAL = NPOINTS_TOTAL + NPOINTS_VTK(NMNM) !+ NVERTS*3
      NCELLS_TOTAL = NCELLS_TOTAL + NCELLS_VTK(NMNM) !+ NFACES*3
      NOFFSETS_TOTAL = NOFFSETS_TOTAL + NCELLS_VTK(NMNM) + 1
      NCONN_TOTAL = NCONN_TOTAL + NCONNECTIONS_VTK(NMNM)
      NCELLS_MAX = MAX(NCELLS_MAX,NCELLS_VTK(NMNM))
      NPOINTS_MAX = MAX(NPOINTS_MAX,NPOINTS_VTK(NMNM))
      NOFFSETS_MAX = MAX(NOFFSETS_MAX,NCELLS_VTK(NMNM) + 1)
      NCONN_MAX = MAX(NCONN_MAX,NCONNECTIONS_VTK(NMNM))
   ENDDO MESH_LOOP_HDF_COUNT
   
   CALL POINT_TO_MESH(1)
   DO N=1,N_BNDF
      BF => BOUNDARY_FILE(N)
      IF (BF%CELL_CENTERED) THEN
         START1 = NCELLS_MAX
         EXTENT1 = NCELLS_TOTAL
         CALL PARALLEL_INIT_F32(GROUP_ID2, BF%SMOKEVIEW_LABEL(1:30), CRP_LIST, 1,&
            START1,EXTENT1, DSET_ID, PLIST_ID) ! Data
      ELSE
         START1 = NPOINTS_MAX
         EXTENT1 = NPOINTS_TOTAL
         CALL PARALLEL_INIT_F32(GROUP_ID4, BF%SMOKEVIEW_LABEL(1:30), CRP_LIST, 1,&
            START1,EXTENT1, DSET_ID, PLIST_ID) ! Data
      ENDIF
      CALL H5DCLOSE_F(DSET_ID, ERROR)
   ENDDO
   
   IF (WRITE_VTK_GEOM_PER_TIMESTEP) THEN
      START1 = NCONN_MAX
      EXTENT1 = NCONN_TOTAL
      CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Connectivity"), CRP_LIST, 1,&
         START1,EXTENT1, DSET_ID_CON, PLIST_ID) ! Connectivity
      START1 = NOFFSETS_MAX
      EXTENT1 = NOFFSETS_TOTAL
      CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Offsets"), CRP_LIST, 1,&
         START1,EXTENT1, DSET_ID_OFF, PLIST_ID) ! Offsets
      START2(1:2) = INT((/3, NPOINTS_MAX/),HSIZE_T)
      EXTENT2(1:2) = INT((/3, NPOINTS_TOTAL/),HSIZE_T)
      CALL PARALLEL_INIT_F32(GROUP_ID1, TRIM("Points"), CRP_LIST, 2,&
         START2,EXTENT2, DSET_ID_PTS, PLIST_ID) ! Points
      START1 = NCELLS_MAX
      EXTENT1 = NCELLS_TOTAL
      CALL PARALLEL_INIT_U8(GROUP_ID1, TRIM("Types"), CRP_LIST, 1,&
         START1,EXTENT1, DSET_ID_TYP, PLIST_ID) ! Types
   
      ! Fill metadata
      N_WRITTEN=0
      MESH_LOOP_HDF: DO NM=1,NMESHES
         NM1 = 2*NM-1
         NM2 = 2*NM
         NPOINTS_START = NPOINTS_ACCUM
         NCELLS_START = NCELLS_ACCUM
         NCONN_START = NCONN_ACCUM
         NOFFSETS_START = NOFFSETS_ACCUM
         LAST_OFFSET_VALUE = 0
         IF (PROCESS(NM)/=MY_RANK) THEN
            NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS_VTK(NM1) + NPOINTS_VTK(NM2)
            NCELLS_ACCUM = NCELLS_ACCUM + NCELLS_VTK(NM1) + NCELLS_VTK(NM2)
            NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS_VTK(NM1)+1
            NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS_VTK(NM2)+1
            NCONN_ACCUM = NCONN_ACCUM + NCONNECTIONS_VTK(NM1) + NCONNECTIONS_VTK(NM2)
            CYCLE MESH_LOOP_HDF
         ENDIF
         CALL POINT_TO_MESH(NM)
      
         ! Build OBST boundary geometry
         IF (MESHES(NM)%N_PATCH>0) THEN
            ALLOCATE(ALL_VERTICES(3,NPOINTS_VTK(NM1)))
            ALLOCATE(ALL_CONNECT(NCONNECTIONS_VTK(NM1)))
            ALLOCATE(ALL_OFFSETS(NCELLS_VTK(NM1)+1))
            ALLOCATE(ALL_VTKC_TYPE(NCELLS_VTK(NM1)))
            ALL_OFFSETS(NOFFSETS_ACCUM-NOFFSETS_START+1) = 0
            PATCH_LOOP2: DO IP=1,N_PATCH
               PA => PATCH(IP)
               IF (PA%OBST_INDEX<=0) CYCLE PATCH_LOOP2
               ! Initialize piece
               CALL BUILD_VTK_SOLID_PHASE_GEOMETRY(NM, PA, PA_NCELLS, PA_NPOINTS,&
                  X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)
               ALLOCATE(VERTICES(3,PA_NPOINTS))
               DO II=1,PA_NPOINTS
                  VERTICES(1:3,II) = (/X_PTS(II),Y_PTS(II),Z_PTS(II)/)
               ENDDO
               ALL_VERTICES(:,NPOINTS_ACCUM-NPOINTS_START+1:NPOINTS_ACCUM-NPOINTS_START+PA_NPOINTS) = VERTICES
               ALL_CONNECT(NCONN_ACCUM-NCONN_START+1:NCONN_ACCUM-NCONN_START+PA_NCELLS*4) = CONNECT + NPOINTS_ACCUM-NPOINTS_START
               OFFSETS = OFFSETS + LAST_OFFSET_VALUE
               LAST_OFFSET_VALUE = OFFSETS(SIZE(OFFSETS))
               ALL_OFFSETS(NOFFSETS_ACCUM-NOFFSETS_START+2:NOFFSETS_ACCUM-NOFFSETS_START+PA_NCELLS+1) = OFFSETS
               ALL_VTKC_TYPE(NCELLS_ACCUM-NCELLS_START+1:NCELLS_ACCUM-NCELLS_START+PA_NCELLS) = VTKC_TYPE
               NCONN_ACCUM = NCONN_ACCUM + PA_NCELLS*4
               NCELLS_ACCUM = NCELLS_ACCUM + PA_NCELLS
               NPOINTS_ACCUM = NPOINTS_ACCUM + PA_NPOINTS
               NOFFSETS_ACCUM = NOFFSETS_ACCUM + PA_NCELLS
               CALL DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)
               DEALLOCATE(VERTICES)
            ENDDO PATCH_LOOP2
         
            ! Write connectivity data to file
            START1 = NCONN_START
            EXTENT1 = NCONNECTIONS_VTK(NM1)
            CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_CON, PLIST_ID, START1, EXTENT1, ALL_CONNECT)
            
            ! Write offsets data to file
            START1 = NOFFSETS_START
            EXTENT1 = NCELLS_VTK(NM1)+1
            CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_OFF, PLIST_ID, START1, EXTENT1, ALL_OFFSETS)
         
            ! Write point data to file
            START2(1:2) = INT((/0, NPOINTS_START/),HSIZE_T)
            EXTENT2(1:2) = INT((/3, NPOINTS_VTK(NM1)/),HSIZE_T)
            CALL PARALLEL_WRITE_F32(2, EXTENT2, DSET_ID_PTS, PLIST_ID, START2, EXTENT2, ALL_VERTICES)
         
            ! Write types data to file
            START1 = NCELLS_START
            EXTENT1 = NCELLS_VTK(NM1)
            CALL PARALLEL_WRITE_U8(1, EXTENT1, DSET_ID_TYP, PLIST_ID, START1, EXTENT1, ALL_VTKC_TYPE)
         
            DEALLOCATE(ALL_VERTICES)
            DEALLOCATE(ALL_CONNECT)
            DEALLOCATE(ALL_OFFSETS)
            DEALLOCATE(ALL_VTKC_TYPE)
            N_WRITTEN = N_WRITTEN + 1
         ENDIF
         ! Build GEOM patch geometry
         IF ((MESHES(NM)%N_INTERNAL_CFACE_CELLS>0).AND.(.TRUE.)) THEN
            NPOINTS_START = NPOINTS_ACCUM
            NCELLS_START = NCELLS_ACCUM
            NCONN_START = NCONN_ACCUM
            NOFFSETS_START = NOFFSETS_ACCUM
            CALL GET_GEOMSIZES_DUP('INBOUND_FACES',0,0,0,0,0,0,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS)
            IF (NVERTS>0 .AND. NFACES>0) THEN
               ALLOCATE(ALL_OFFSETS(NCELLS_VTK(NM2)+1))
               ALLOCATE(VERTS(3*NVERTS))
               ALLOCATE(FACES(3*NFACES))
               ALLOCATE(LOCATIONS(NFACES))
               ALLOCATE(SURFIND(NFACES))
               ALLOCATE(GEOMIND(NFACES))
               CALL GET_GEOMINFO_DUP('INBOUND_FACES',0,0,0,0,0,0,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS,&
                                 VERTS,FACES,LOCATIONS,SURFIND=SURFIND,GEOMIND=GEOMIND)
               CALL BUILD_VTK_GEOM_GEOMETRY(VERTS, FACES, PA_NCELLS, PA_NPOINTS, X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)
               ALLOCATE(VERTICES(3,PA_NPOINTS))
               DO II=1,PA_NPOINTS
                  VERTICES(1:3,II) = (/X_PTS(II),Y_PTS(II),Z_PTS(II)/)
               ENDDO
               ALL_OFFSETS(1) = 0
               ALL_OFFSETS(2:NCELLS_VTK(NM2)+1) = OFFSETS
               NCONN_ACCUM = NCONN_ACCUM + PA_NCELLS*3
               NCELLS_ACCUM = NCELLS_ACCUM + PA_NCELLS
               NPOINTS_ACCUM = NPOINTS_ACCUM + PA_NPOINTS
               NOFFSETS_ACCUM = NOFFSETS_ACCUM + PA_NCELLS + 1
            
               ! Write connectivity data to file
               START1 = NCONN_START
               EXTENT1 = NCONNECTIONS_VTK(NM2)
               CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_CON, PLIST_ID, START1, EXTENT1, CONNECT)
               
               ! Write offsets data to file
               START1 = NOFFSETS_START+1
               EXTENT1 = NCELLS_VTK(NM2)+1
               CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_OFF, PLIST_ID, START1, EXTENT1, ALL_OFFSETS)
            
               ! Write point data to file
               START2(1:2) = INT((/0, NPOINTS_START/),HSIZE_T)
               EXTENT2(1:2) = INT((/3, NPOINTS_VTK(NM2)/),HSIZE_T)
               CALL PARALLEL_WRITE_F32(2, EXTENT2, DSET_ID_PTS, PLIST_ID, START2, EXTENT2, VERTICES)
            
               ! Write types data to file
               START1 = NCELLS_START
               EXTENT1 = NCELLS_VTK(NM2)
               CALL PARALLEL_WRITE_U8(1, EXTENT1, DSET_ID_TYP, PLIST_ID, START1, EXTENT1, VTKC_TYPE)
            
               DEALLOCATE(VERTS)
               DEALLOCATE(FACES)
               DEALLOCATE(LOCATIONS)
               DEALLOCATE(SURFIND)
               DEALLOCATE(GEOMIND)
               DEALLOCATE(VERTICES)
               DEALLOCATE(ALL_OFFSETS)
               CALL DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)
               N_WRITTEN = N_WRITTEN + 1
            ENDIF
         ENDIF
      ENDDO MESH_LOOP_HDF
   
      ! Write fake data in processes that have less meshes than max process
      DO NM=1,MAXVAL(MESHES_PER_PROCESS)*2
         IF (N_WRITTEN < MAXVAL(MESHES_PER_PROCESS)*2) THEN
      
            ! Write connectivity data to file
            START1 = 0
            EXTENT1 = 0
            IDATA_OUT1 = 0
            CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_CON, PLIST_ID, START1, EXTENT1, IDATA_OUT1)
            
            ! Write offsets data to file
            CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_OFF, PLIST_ID, START1, EXTENT1, IDATA_OUT1)
         
            ! Write point data to file
            START2(1:2) = INT((/0, 0/),HSIZE_T)
            EXTENT2(1:2) = INT((/3, 0/),HSIZE_T)
            FDATA_OUT3 = 0
            CALL PARALLEL_WRITE_F32(2, EXTENT2, DSET_ID_PTS, PLIST_ID, START2, EXTENT2, FDATA_OUT3)
         
            ! Write types data to file
            DATA_OUT1_U8 = 0
            CALL PARALLEL_WRITE_U8(1, EXTENT1, DSET_ID_TYP, PLIST_ID, START1, EXTENT1, DATA_OUT1_U8)
            N_WRITTEN = N_WRITTEN + 1
         ENDIF
      ENDDO
      
      ! Close VTKHDF interface
      CALL H5DCLOSE_F(DSET_ID_CON, ERROR)
      CALL H5DCLOSE_F(DSET_ID_OFF, ERROR)
      CALL H5DCLOSE_F(DSET_ID_PTS, ERROR)
      CALL H5DCLOSE_F(DSET_ID_TYP, ERROR)
   ENDIF



END SUBROUTINE INITIALIZE_VTKHDF_BNDF



SUBROUTINE GET_GEOMSIZES_DUP(SLICETYPE,I1,I2,J1,J2,K1,K2,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS)

! determine NVERTS and NFACES for one of the following cases
!
! IGNORE_GEOM  - creates a slice file geometry file that ignores immersed geometric objects .  Triangles inside obstacle
!                regions (a solid) are tagged with a 1, triangles outside of obstacle regions (the gas) are tagged
!                with a 0 . Smokeview uses this information to show/hide these two regions
! INCLUDE_GEOM - creates a slice file geometry file that accounts for immersed geometric objects .  If there are no immersed
!                objects present then this slice type is equivalent to the 'IGNORE_GEOM' case.  Triangles completely inside a
!                solid are tagged with a 1, triangles completely in the gas are tagged with a 0 and triangles in a cutcell are
!                with a tagged 2.  As with the IGNORE_GEOM type, Smokeview uses this information to show/hide these regions

   CHARACTER(*), INTENT(IN) :: SLICETYPE
   INTEGER, INTENT(IN) :: I1,I2,J1,J2,K1,K2
   INTEGER, INTENT(OUT) :: NVERTS, NVERTS_CUTCELLS, NFACES, NFACES_CUTCELLS

   INTEGER :: DIR,SLICE
   INTEGER :: I, J, K
   INTEGER :: ICF, IFACE, NVF, ICC, JCC, ICF2, IFACE2, NFC, ICCF

   CHARACTER(LEN=100) :: SLICETYPE_LOCAL

   SLICETYPE_LOCAL=TRIM(SLICETYPE) ! only generate CUTCELLS slice files if the immersed geometry option is turned on
   IF (SLICETYPE=='INCLUDE_GEOM' .AND. .NOT.CC_IBM) SLICETYPE_LOCAL='IGNORE_GEOM'

   NVERTS=0
   NFACES=0
   NVERTS_CUTCELLS=0
   NFACES_CUTCELLS=0
   IF (SLICETYPE_LOCAL=='IGNORE_GEOM') THEN
      CALL GETSLICEDIR_DUP(I1,I2,J1,J2,K1,K2,DIR,SLICE)
      IF (DIR==1) THEN
        NVERTS = (J2 + 1 - J1)*(K2 + 1 - K1)
        NFACES = 2*(J2 - J1)*(K2 - K1)
      ELSE IF (DIR==2) THEN
        NVERTS = (I2 + 1 - I1)*(K2 + 1 - K1)
        NFACES = 2*(I2 - I1)*(K2 - K1)
      ELSE
        NVERTS = (I2 + 1 - I1)*(J2 + 1 - J1)
        NFACES = 2*(I2 - I1)*(J2 - J1)
      ENDIF
   ELSE IF (SLICETYPE_LOCAL=='INCLUDE_GEOM') THEN
      CALL GETSLICEDIR_DUP(I1,I2,J1,J2,K1,K2,DIR,SLICE)
      IF (DIR==1) THEN
         NVERTS = (J2 + 1 - J1)*(K2 + 1 - K1)
         NFACES = 0
         DO K = K1+1, K2
            DO J = J1+1, J2
               IF (ANY(CELL(CELL_INDEX(SLICE:SLICE+1,J,K))%SOLID)) CYCLE
               IF (FCVAR(SLICE,J,K,CC_FGSC,IAXIS) == CC_CUTCFE) THEN
                  ICF = FCVAR(SLICE,J,K,CC_IDCF,IAXIS) ! a cutcell so count number of faces
                  DO IFACE=1,CUT_FACE(ICF)%NFACE+CUT_FACE(ICF)%NSFACE ! Adds also SOLID side faces.
                     NVF=CUT_FACE(ICF)%CFELEM(1,IFACE)
                     NFACES_CUTCELLS = NFACES_CUTCELLS + NVF - 2
                     NVERTS_CUTCELLS = NVERTS_CUTCELLS + NVF
                  ENDDO
               ELSE
                  NFACES = NFACES + 2 ! a gas or solid cell so add 2 to the number of faces
               ENDIF
            ENDDO
         ENDDO
      ELSE IF (DIR==2) THEN
         NVERTS = (I2 + 1 - I1)*(K2 + 1 - K1)
         DO K = K1+1, K2
            DO I = I1+1, I2
               IF(ANY(CELL(CELL_INDEX(I,SLICE:SLICE+1,K))%SOLID)) CYCLE
               IF (FCVAR(I,SLICE,K,CC_FGSC,JAXIS) == CC_CUTCFE) THEN
                  ICF = FCVAR(I,SLICE,K,CC_IDCF,JAXIS)
                  DO IFACE=1,CUT_FACE(ICF)%NFACE+CUT_FACE(ICF)%NSFACE ! Adds also SOLID side faces.
                     NVF=CUT_FACE(ICF)%CFELEM(1,IFACE)
                     NFACES_CUTCELLS = NFACES_CUTCELLS + NVF - 2
                     NVERTS_CUTCELLS = NVERTS_CUTCELLS + NVF
                  ENDDO
               ELSE
                  NFACES = NFACES + 2
               ENDIF
            ENDDO
         ENDDO
      ELSE
         NVERTS = (I2 + 1 - I1)*(J2 + 1 - J1)
         DO I = I1+1, I2
            DO J = J1+1, J2
               IF(ANY(CELL(CELL_INDEX(I,J,SLICE:SLICE+1))%SOLID)) CYCLE
               IF (FCVAR(I,J,SLICE,CC_FGSC,KAXIS) == CC_CUTCFE) THEN
                  ICF = FCVAR(I,J,SLICE,CC_IDCF,KAXIS)
                  DO IFACE=1,CUT_FACE(ICF)%NFACE+CUT_FACE(ICF)%NSFACE ! Adds also SOLID side faces.
                     NVF=CUT_FACE(ICF)%CFELEM(1,IFACE)
                     NFACES_CUTCELLS = NFACES_CUTCELLS + NVF - 2
                     NVERTS_CUTCELLS = NVERTS_CUTCELLS + NVF
                  ENDDO
               ELSE
                  NFACES = NFACES + 2
               ENDIF
            ENDDO
         ENDDO
      ENDIF
   ELSE IF (SLICETYPE_LOCAL=='INBOUND_FACES') THEN
      DO K = 1, KBAR
         DO J = 1, JBAR
            DO I = 1, IBAR
               IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
               IF (CCVAR(I,J,K,CC_IDCF) > 0) THEN ! There are INBOUNDARY cut-faces on this cell:
                  ICF = CCVAR(I,J,K,CC_IDCF)
                  DO IFACE=1,CUT_FACE(ICF)%NFACE ! Adds also SOLID side faces.
                     NVF=CUT_FACE(ICF)%CFELEM(1,IFACE)
                     NFACES_CUTCELLS = NFACES_CUTCELLS + NVF - 2
                     NVERTS_CUTCELLS = NVERTS_CUTCELLS + NVF
                  ENDDO
               ENDIF
            ENDDO
         ENDDO
      ENDDO
   ELSE IF (SLICETYPE_LOCAL=='CUT_CELLS') THEN
      DO K = 1, KBAR
         DO J = 1, JBAR
            DO I = 1, IBAR
               IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
               IF (CCVAR(I,J,K,CC_IDCC) <= 0) CYCLE
               ICC = CCVAR(I,J,K,CC_IDCC)
               DO JCC=1,CUT_CELL(ICC)%NCELL
                  NFC=CUT_CELL(ICC)%CCELEM(1,JCC)
                  ! Loop on faces corresponding to cut-cell ICC2:
                  DO ICCF=1,NFC
                     IFACE=CUT_CELL(ICC)%CCELEM(ICCF+1,JCC)
                     SELECT CASE(CUT_CELL(ICC)%FACE_LIST(1,IFACE))
                     CASE(CC_FTYPE_RCGAS) ! REGULAR GASPHASE
                        NVF = 4
                        NFACES_CUTCELLS = NFACES_CUTCELLS + NVF - 2
                        NVERTS_CUTCELLS = NVERTS_CUTCELLS + NVF
                     CASE(CC_FTYPE_CFGAS)
                        ICF2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
                        IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
                        NVF=CUT_FACE(ICF2)%CFELEM(1,IFACE2)
                        NFACES_CUTCELLS = NFACES_CUTCELLS + NVF - 2
                        NVERTS_CUTCELLS = NVERTS_CUTCELLS + NVF
                     CASE(CC_FTYPE_CFINB)
                        ICF2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
                        IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
                        NVF=CUT_FACE(ICF2)%CFELEM(1,IFACE2)
                        NFACES_CUTCELLS = NFACES_CUTCELLS + NVF - 2
                        NVERTS_CUTCELLS = NVERTS_CUTCELLS + NVF
                     END SELECT
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO
   ENDIF
   NFACES = NFACES + NFACES_CUTCELLS
   NVERTS = NVERTS + NVERTS_CUTCELLS
END SUBROUTINE GET_GEOMSIZES_DUP


SUBROUTINE GETSLICEDIR_DUP(I1,I2,J1,J2,K1,K2,DIR,SLICE)
INTEGER, INTENT(IN) :: I1, I2, J1, J2, K1, K2
INTEGER, INTENT(OUT) :: DIR, SLICE

IF (ABS(K1-K2)<MIN(ABS(I1-I2),ABS(J1-J2))) THEN
   DIR=3
   SLICE = K1
ELSE IF (ABS(J1-J2)<MIN(ABS(I1-I2),ABS(K1-K2))) THEN
   DIR=2
   SLICE = J1
ELSE
   DIR=1
   SLICE = I1
ENDIF
RETURN

END SUBROUTINE GETSLICEDIR_DUP


INTEGER FUNCTION IJK_DUP(I,J,NI)
INTEGER, INTENT(IN) :: I, J, NI
IJK_DUP = I + (J-1)*NI
END FUNCTION IJK_DUP

SUBROUTINE GET_GEOMINFO_DUP(SLICETYPE,I1,I2,J1,J2,K1,K2,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS,&
                        VERTS,FACES,LOCATIONS,SURFIND,GEOMIND)

! generate VERTS(1:3*NVERTS) and FACES(1:3*NFACES) arrays

   CHARACTER(*), INTENT(IN) :: SLICETYPE
   INTEGER, INTENT(IN) :: I1,I2,J1,J2,K1,K2
   INTEGER, INTENT(IN) :: NVERTS, NVERTS_CUTCELLS, NFACES, NFACES_CUTCELLS
   INTEGER, INTENT(OUT), DIMENSION(3*NFACES), TARGET :: FACES
   INTEGER, INTENT(OUT), DIMENSION(NFACES) :: LOCATIONS
   INTEGER, OPTIONAL, INTENT(OUT), DIMENSION(NFACES) :: SURFIND,GEOMIND
   REAL(FB), INTENT(OUT), DIMENSION(3*NVERTS), TARGET :: VERTS

   INTEGER :: VERT_OFFSET
   INTEGER, POINTER, DIMENSION(:) :: FACEPTR
   REAL(FB), POINTER, DIMENSION(:) :: VERTPTR

   INTEGER :: DIR, SLICE
   INTEGER :: NI, NJ, NK
   INTEGER :: I, J, K
   INTEGER IFACE, IVERT, IVERTCUT, IFACECUT, IVERTCF, IFACECF
   INTEGER VERTBEG, VERTEND, FACEBEG, FACEEND
   LOGICAL IS_SOLID
   INTEGER :: ICF, NVF, IVCF, IADD, JADD, KADD, X1AXIS
   INTEGER :: II, JJ, KK, ICC, JCC, NFC, ICCF, LOWHIGH, ILH, ICF2, IFACE2
   INTEGER, ALLOCATABLE, DIMENSION(:) :: LOCTYPE

   CHARACTER(LEN=100) :: SLICETYPE_LOCAL

   SLICETYPE_LOCAL=TRIM(SLICETYPE) ! only generate CUTCELLS slice files if the immersed geometry option is turned on
   IF (SLICETYPE=='INCLUDE_GEOM' .AND. .NOT.CC_IBM) SLICETYPE_LOCAL='IGNORE_GEOM'

   LOCATIONS = 0 ! initially assume triangles are in gas and tag with 0
   IF (SLICETYPE_LOCAL=='IGNORE_GEOM') THEN
      NI = I2 + 1 - I1
      NJ = J2 + 1 - J1
      NK = K2 + 1 - K1
      CALL GETSLICEDIR_DUP(I1,I2,J1,J2,K1,K2,DIR,SLICE)
      IVERT = 0
      IFACE = 0
      IF (DIR==1) THEN
         DO K=K1,K2
            DO J=J1,J2
               DO I = SLICE,SLICE
                  IVERT = IVERT + 1
                  VERTS(3*IVERT-2) = XPLT(SLICE)
                  VERTS(3*IVERT-1) = YPLT(J)
                  VERTS(3*IVERT)   = ZPLT(K)
               ENDDO
            ENDDO
         ENDDO
         DO K=1,NK-1
            DO J=1,NJ-1
               IS_SOLID = CELL(CELL_INDEX(SLICE,J+J1,K+K1))%SOLID
               IFACE = IFACE + 1
               IF (IS_SOLID) LOCATIONS(IFACE) = 1 + 16 ! triangle is in a solid so tag with 1
               FACES(3*IFACE-2) = IJK_DUP(  J,  K,NJ)
               FACES(3*IFACE-1) = IJK_DUP(J+1,  K,NJ)
               FACES(3*IFACE)   = IJK_DUP(J+1,K+1,NJ)

               IFACE = IFACE + 1
               IF (IS_SOLID) LOCATIONS(IFACE) = 1 + 4 ! triangle is in a solid so tag with 1
               FACES(3*IFACE-2) = IJK_DUP(  J,  K,NJ)
               FACES(3*IFACE-1) = IJK_DUP(J+1,K+1,NJ)
               FACES(3*IFACE)   = IJK_DUP(  J,K+1,NJ)
            ENDDO
         ENDDO
      ELSE IF (DIR==2) THEN
         DO K=K1,K2
            DO J=SLICE,SLICE
               DO I = I1,I2
                  IVERT = IVERT + 1
                  VERTS(3*IVERT-2) = XPLT(I)
                  VERTS(3*IVERT-1) = YPLT(SLICE)
                  VERTS(3*IVERT)   = ZPLT(K)
               ENDDO
            ENDDO
         ENDDO
         DO K=1,NK-1
            DO I=1,NI-1
               IS_SOLID = CELL(CELL_INDEX(I+I1,SLICE,K+K1))%SOLID
               IFACE = IFACE + 1
               IF (IS_SOLID) LOCATIONS(IFACE) = 1 + 16
               FACES(3*IFACE-2) = IJK_DUP(  I,  K,NI)
               FACES(3*IFACE-1) = IJK_DUP(I+1,  K,NI)
               FACES(3*IFACE)   = IJK_DUP(I+1,K+1,NI)

               IFACE = IFACE + 1
               IF (IS_SOLID) LOCATIONS(IFACE) = 1 + 4
               FACES(3*IFACE-2) = IJK_DUP(  I,  K,NI)
               FACES(3*IFACE-1) = IJK_DUP(I+1,K+1,NI)
               FACES(3*IFACE)   = IJK_DUP(  I,K+1,NI)
            ENDDO
         ENDDO
      ELSE
         DO K=SLICE,SLICE
            DO J=J1,J2
               DO I = I1,I2
                  IVERT = IVERT + 1
                  VERTS(3*IVERT-2) = XPLT(I)
                  VERTS(3*IVERT-1) = YPLT(J)
                  VERTS(3*IVERT)   = ZPLT(SLICE)
               ENDDO
            ENDDO
         ENDDO
         DO J=1,NJ-1
            DO I=1,NI-1
               IS_SOLID = CELL(CELL_INDEX(I+I1,J+J1,SLICE))%SOLID
               IFACE = IFACE + 1
               IF (IS_SOLID) LOCATIONS(IFACE) = 1 + 16
               FACES(3*IFACE-2) = IJK_DUP(  I,  J,NI)
               FACES(3*IFACE-1) = IJK_DUP(I+1,  J,NI)
               FACES(3*IFACE)   = IJK_DUP(I+1,J+1,NI)

               IFACE = IFACE + 1
               IF (IS_SOLID) LOCATIONS(IFACE) = 1 + 4
               FACES(3*IFACE-2) = IJK_DUP(  I,  J,NI)
               FACES(3*IFACE-1) = IJK_DUP(I+1,J+1,NI)
               FACES(3*IFACE)   = IJK_DUP(  I,J+1,NI)
            ENDDO
         ENDDO
      ENDIF
   ELSE IF (SLICETYPE_LOCAL=='INCLUDE_GEOM') THEN
      IVERTCUT=NVERTS-NVERTS_CUTCELLS ! start cutcell counters after 'regular' cells
      IFACECUT=NFACES-NFACES_CUTCELLS
      NI = I2 + 1 - I1
      NJ = J2 + 1 - J1
      NK = K2 + 1 - K1
      CALL GETSLICEDIR_DUP(I1,I2,J1,J2,K1,K2,DIR,SLICE)
      IVERT = 0
      IFACE = 0
      IF (DIR==1) THEN
         DO K=K1,K2
            DO J=J1,J2
               DO I = SLICE,SLICE
                  IVERT = IVERT + 1
                  VERTS(3*IVERT-2) = XPLT(SLICE)
                  VERTS(3*IVERT-1) = YPLT(J)
                  VERTS(3*IVERT)   = ZPLT(K)
               ENDDO
            ENDDO
         ENDDO
         DO K=1,NK-1
            DO J=1,NJ-1
               IF (ANY(CELL(CELL_INDEX(SLICE:SLICE+1,J,K))%SOLID)) CYCLE
               IF (FCVAR(SLICE,J,K,CC_FGSC,IAXIS) == CC_CUTCFE) THEN
                  ICF = FCVAR(SLICE,J,K,CC_IDCF,IAXIS) ! store cutcell faces and vertices
                  DO IFACECF=1,CUT_FACE(ICF)%NFACE+CUT_FACE(ICF)%NSFACE
                     NVF=CUT_FACE(ICF)%CFELEM(1,IFACECF)
                     VERTBEG = IVERTCUT + 1
                     VERTBEG = 3*VERTBEG - 2
                     VERTEND = IVERTCUT + NVF
                     VERTEND = 3*VERTEND
                     DO IVCF=1,NVF
                        IVERTCUT = IVERTCUT + 1
                        IVERTCF=CUT_FACE(ICF)%CFELEM(IVCF+1,IFACECF)
                        VERTS(3*IVERTCUT-2:3*IVERTCUT) = REAL(CUT_FACE(ICF)%XYZVERT(1:3,IVERTCF),FB)
                     ENDDO

                     FACEBEG = 3*(IFACECUT+1) - 2
                     FACEEND = FACEBEG + 3*(NVF-2) - 1
                     FACEPTR(1:3*(NVF-2))        =>FACES(FACEBEG:FACEEND)
                     VERTPTR(1:1+VERTEND-VERTBEG)=>VERTS(VERTBEG:VERTEND)
                     VERT_OFFSET = IVERTCUT - NVF
                     ALLOCATE(LOCTYPE(NVF-2))
                     CALL TRIANGULATE(DIR,VERTPTR,NVF,VERT_OFFSET,FACEPTR,LOCTYPE)
                     DO IVCF = 1, NVF-2 ! for now assume face is convex
                        ! vertex indices 1, 2, ..., NVF
                        ! faces (1,2,3), (1,3,4), ..., (1,NVF-1,NVF)
                        IFACECUT = IFACECUT + 1
                        LOCATIONS(IFACECUT) = 2 + LOCTYPE(IVCF)
                        IF(IFACECF > CUT_FACE(ICF)%NFACE) LOCATIONS(IFACECUT) = 1 + LOCTYPE(IVCF) ! Solid side cut-faces.
! after TRIANGULATE is verified remove the following 3 lines of code (and similar lines in 2 locations below)
!                        FACES(3*IFACECUT-2) = (IVERTCUT-NVF)+1
!                        FACES(3*IFACECUT-1) = (IVERTCUT-NVF)+1+IVCF
!                        FACES(3*IFACECUT)   = (IVERTCUT-NVF)+2+IVCF
                     ENDDO
                     DEALLOCATE(LOCTYPE)
                  ENDDO
               ELSE
                  IFACE = IFACE + 1 ! store solid and gas faces and vertices (2 faces per cell)
                  LOCATIONS(IFACE) = 0 + 16
                  IF ( FCVAR(SLICE,J,K,CC_FGSC,IAXIS) == CC_SOLID) LOCATIONS(IFACE)=1 + 16
                  FACES(3*IFACE-2) = IJK_DUP(  J,  K,NJ)
                  FACES(3*IFACE-1) = IJK_DUP(J+1,  K,NJ)
                  FACES(3*IFACE)   = IJK_DUP(J+1,K+1,NJ)

                  IFACE = IFACE + 1
                  LOCATIONS(IFACE) = 0 + 4
                  IF ( FCVAR(SLICE,J,K,CC_FGSC,IAXIS) == CC_SOLID) LOCATIONS(IFACE)=1 + 4
                  FACES(3*IFACE-2) = IJK_DUP(  J,  K,NJ)
                  FACES(3*IFACE-1) = IJK_DUP(J+1,K+1,NJ)
                  FACES(3*IFACE)   = IJK_DUP(  J,K+1,NJ)
               ENDIF
            ENDDO
         ENDDO
      ELSE IF (DIR==2) THEN
         DO K=K1,K2
            DO J=SLICE,SLICE
               DO I = I1,I2
                  IVERT = IVERT + 1
                  VERTS(3*IVERT-2) = XPLT(I)
                  VERTS(3*IVERT-1) = YPLT(SLICE)
                  VERTS(3*IVERT)   = ZPLT(K)
               ENDDO
            ENDDO
         ENDDO
         DO K=1,NK-1
            DO I=1,NI-1
               IF (ANY(CELL(CELL_INDEX(I,SLICE:SLICE+1,K))%SOLID)) CYCLE
               IF (FCVAR(I,SLICE,K,CC_FGSC,JAXIS) == CC_CUTCFE) THEN
                  ICF = FCVAR(I,SLICE,K,CC_IDCF,JAXIS)
                  DO IFACECF=1,CUT_FACE(ICF)%NFACE+CUT_FACE(ICF)%NSFACE
                     NVF=CUT_FACE(ICF)%CFELEM(1,IFACECF)
                     VERTBEG = IVERTCUT + 1
                     VERTBEG = 3*VERTBEG - 2
                     VERTEND = IVERTCUT + NVF
                     VERTEND = 3*VERTEND
                     DO IVCF=1,NVF
                        IVERTCUT = IVERTCUT + 1
                        IVERTCF=CUT_FACE(ICF)%CFELEM(IVCF+1,IFACECF)
                        VERTS(3*IVERTCUT-2:3*IVERTCUT) = REAL(CUT_FACE(ICF)%XYZVERT(1:3,IVERTCF),FB)
                     ENDDO
                     FACEBEG = 3*(IFACECUT+1) - 2
                     FACEEND = FACEBEG + 3*(NVF-2) - 1
                     FACEPTR(1:3*(NVF-2))        =>FACES(FACEBEG:FACEEND)
                     VERTPTR(1:1+VERTEND-VERTBEG)=>VERTS(VERTBEG:VERTEND)
                     VERT_OFFSET = IVERTCUT - NVF
                     ALLOCATE(LOCTYPE(NVF-2))
                     CALL TRIANGULATE(DIR,VERTPTR,NVF,VERT_OFFSET,FACEPTR,LOCTYPE)
                     DO IVCF = 1, NVF-2 ! for now assume face is convex
                        IFACECUT = IFACECUT + 1
                        LOCATIONS(IFACECUT) = 2 + LOCTYPE(IVCF)
                        IF(IFACECF > CUT_FACE(ICF)%NFACE) LOCATIONS(IFACECUT) = 1 + LOCTYPE(IVCF) ! Solid side cut-faces.
!                        FACES(3*IFACECUT-2) = IVERTCUT-NVF+1
!                        FACES(3*IFACECUT-1) = IVERTCUT-NVF+1+IVCF
!                        FACES(3*IFACECUT)   = IVERTCUT-NVF+1+IVCF+1
                     ENDDO
                     DEALLOCATE(LOCTYPE)
                  ENDDO
               ELSE
                  IFACE = IFACE + 1
                  LOCATIONS(IFACE) = 0 + 16
                  IF ( FCVAR(I,SLICE,K,CC_FGSC,JAXIS) == CC_SOLID) LOCATIONS(IFACE)=1 + 16
                  FACES(3*IFACE-2) = IJK_DUP(  I,  K,NI)
                  FACES(3*IFACE-1) = IJK_DUP(I+1,  K,NI)
                  FACES(3*IFACE)   = IJK_DUP(I+1,K+1,NI)

                  IFACE = IFACE + 1
                  LOCATIONS(IFACE) = 0 + 4
                  IF ( FCVAR(I,SLICE,K,CC_FGSC,JAXIS) == CC_SOLID) LOCATIONS(IFACE)=1 + 4
                  FACES(3*IFACE-2) = IJK_DUP(  I,  K,NI)
                  FACES(3*IFACE-1) = IJK_DUP(I+1,K+1,NI)
                  FACES(3*IFACE)   = IJK_DUP(  I,K+1,NI)
               ENDIF
            ENDDO
         ENDDO
      ELSE
         DO K=SLICE,SLICE
            DO J=J1,J2
               DO I = I1,I2
                  IVERT = IVERT + 1
                  VERTS(3*IVERT-2) = XPLT(I)
                  VERTS(3*IVERT-1) = YPLT(J)
                  VERTS(3*IVERT)   = ZPLT(SLICE)
               ENDDO
            ENDDO
         ENDDO
         DO J=1,NJ-1
            DO I=1,NI-1
               IF (ANY(CELL(CELL_INDEX(I,J,SLICE:SLICE+1))%SOLID)) CYCLE
               IF (FCVAR(I,J,SLICE,CC_FGSC,KAXIS) == CC_CUTCFE) THEN
                  ICF = FCVAR(I,J,SLICE,CC_IDCF,KAXIS)
                  DO IFACECF=1,CUT_FACE(ICF)%NFACE+CUT_FACE(ICF)%NSFACE
                     NVF=CUT_FACE(ICF)%CFELEM(1,IFACECF)
                     VERTBEG = IVERTCUT + 1
                     VERTBEG = 3*VERTBEG - 2
                     VERTEND = IVERTCUT + NVF
                     VERTEND = 3*VERTEND
                     DO IVCF=1,NVF
                        IVERTCUT = IVERTCUT + 1
                        IVERTCF=CUT_FACE(ICF)%CFELEM(IVCF+1,IFACECF)
                        VERTS(3*IVERTCUT-2:3*IVERTCUT) = REAL(CUT_FACE(ICF)%XYZVERT(1:3,IVERTCF),FB)
                     ENDDO
                     FACEBEG = 3*(IFACECUT+1) - 2
                     FACEEND = FACEBEG + 3*(NVF-2) - 1
                     FACEPTR(1:3*(NVF-2))        =>FACES(FACEBEG:FACEEND)
                     VERTPTR(1:1+VERTEND-VERTBEG)=>VERTS(VERTBEG:VERTEND)
                     VERT_OFFSET = IVERTCUT - NVF
                     ALLOCATE(LOCTYPE(NVF-2))
                     CALL TRIANGULATE(DIR,VERTPTR,NVF,VERT_OFFSET,FACEPTR,LOCTYPE)
                     DO IVCF = 1, NVF-2 ! for now assume face is convex
                        IFACECUT = IFACECUT + 1
                        LOCATIONS(IFACECUT) = 2 + LOCTYPE(IVCF)
                        IF(IFACECF > CUT_FACE(ICF)%NFACE) LOCATIONS(IFACECUT) = 1 + LOCTYPE(IVCF) ! Solid side cut-faces.
!                        FACES(3*IFACECUT-2) = IVERTCUT-NVF+1
!                        FACES(3*IFACECUT-1) = IVERTCUT-NVF+1+IVCF
!                        FACES(3*IFACECUT)   = IVERTCUT-NVF+1+IVCF+1
                     ENDDO
                     DEALLOCATE(LOCTYPE)
                  ENDDO
               ELSE
                  IFACE = IFACE + 1
                  LOCATIONS(IFACE) = 0 + 16
                  IF ( FCVAR(I,J,SLICE,CC_FGSC,KAXIS) == CC_SOLID) LOCATIONS(IFACE)=1 + 16
                  FACES(3*IFACE-2) = IJK_DUP(  I,  J,NI)
                  FACES(3*IFACE-1) = IJK_DUP(I+1,  J,NI)
                  FACES(3*IFACE)   = IJK_DUP(I+1,J+1,NI)

                  IFACE = IFACE + 1
                  LOCATIONS(IFACE) = 0 + 4
                  IF ( FCVAR(I,J,SLICE,CC_FGSC,KAXIS) == CC_SOLID) LOCATIONS(IFACE)=1 + 4
                  FACES(3*IFACE-2) = IJK_DUP(  I,  J,NI)
                  FACES(3*IFACE-1) = IJK_DUP(I+1,J+1,NI)
                  FACES(3*IFACE)   = IJK_DUP(  I,J+1,NI)
               ENDIF
            ENDDO
         ENDDO
      ENDIF
   ELSE IF (SLICETYPE_LOCAL=='INBOUND_FACES') THEN
      DIR   = 0
      IVERTCUT=NVERTS-NVERTS_CUTCELLS ! start cutcell counters after 'regular' cells
      IFACECUT=NFACES-NFACES_CUTCELLS
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
            IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
            IF (CCVAR(I,J,K,CC_IDCF) > 0) THEN
               ICF = CCVAR(I,J,K,CC_IDCF)
               DO IFACECF=1,CUT_FACE(ICF)%NFACE
                  NVF=CUT_FACE(ICF)%CFELEM(1,IFACECF)
                  VERTBEG = IVERTCUT + 1
                  VERTBEG = 3*VERTBEG - 2
                  VERTEND = IVERTCUT + NVF
                  VERTEND = 3*VERTEND
                  DO IVCF=1,NVF
                     IVERTCUT = IVERTCUT + 1
                     IVERTCF=CUT_FACE(ICF)%CFELEM(IVCF+1,IFACECF)
                     VERTS(3*IVERTCUT-2:3*IVERTCUT) = REAL(CUT_FACE(ICF)%XYZVERT(1:3,IVERTCF),FB)
                  ENDDO
                  IF(PRESENT(SURFIND)) SURFIND(IFACECUT+1:IFACECUT+NVF-2) = CUT_FACE(ICF)%SURF_INDEX(IFACECF)
                  IF(PRESENT(GEOMIND)) GEOMIND(IFACECUT+1:IFACECUT+NVF-2) = CUT_FACE(ICF)%  BODTRI(1,IFACECF)
                  FACEBEG = 3*(IFACECUT+1) - 2
                  FACEEND = FACEBEG + 3*(NVF-2) - 1
                  FACEPTR(1:3*(NVF-2))        =>FACES(FACEBEG:FACEEND)
                  VERTPTR(1:1+VERTEND-VERTBEG)=>VERTS(VERTBEG:VERTEND)
                  VERT_OFFSET = IVERTCUT - NVF
                  ALLOCATE(LOCTYPE(NVF-2))
                  CALL TRIANGULATE(DIR,VERTPTR,NVF,VERT_OFFSET,FACEPTR,LOCTYPE)
                  DO IVCF = 1, NVF-2 ! for now assume face is convex
                     IFACECUT = IFACECUT + 1
                     LOCATIONS(IFACECUT) = 1 + LOCTYPE(IVCF) ! Consider them as SOLID.
                  ENDDO
                  DEALLOCATE(LOCTYPE)
               ENDDO
            ENDIF
            ENDDO
         ENDDO
      ENDDO
   ELSE IF (SLICETYPE_LOCAL=='CUT_CELLS') THEN
      IVERTCUT=NVERTS-NVERTS_CUTCELLS ! start cutcell counters after 'regular' cells
      IFACECUT=NFACES-NFACES_CUTCELLS
      DO KK = 1, KBAR
         DO JJ = 1, JBAR
            DO II = 1, IBAR
               IF (CELL(CELL_INDEX(II,JJ,KK))%SOLID) CYCLE
               IF (CCVAR(II,JJ,KK,CC_IDCC) <= 0) CYCLE
               ICC = CCVAR(II,JJ,KK,CC_IDCC)
               DO JCC=1,CUT_CELL(ICC)%NCELL
                  NFC=CUT_CELL(ICC)%CCELEM(1,JCC)
                  ! Loop on faces corresponding to cut-cell ICC2:
                  DO ICCF=1,NFC
                     IFACE=CUT_CELL(ICC)%CCELEM(ICCF+1,JCC)
                     SELECT CASE(CUT_CELL(ICC)%FACE_LIST(1,IFACE))
                     CASE(CC_FTYPE_RCGAS) ! REGULAR GASPHASE
                        LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
                        X1AXIS  = CUT_CELL(ICC)%FACE_LIST(3,IFACE)
                        ILH     = LOWHIGH - 1
                        I=II; J=JJ; K=KK;
                        SELECT CASE(X1AXIS)
                        CASE(IAXIS)
                           I=II-1+ILH
                           DO KADD=-1,0
                              DO JADD=-1,0
                                 IVERTCUT = IVERTCUT + 1
                                 VERTS(3*IVERTCUT-2) = REAL(X(I     ),FB)
                                 VERTS(3*IVERTCUT-1) = REAL(Y(J+JADD),FB)
                                 VERTS(3*IVERTCUT)   = REAL(Z(K+KADD),FB)
                              ENDDO
                           ENDDO
                        CASE(JAXIS)
                           J=JJ-1+ILH
                           DO IADD=-1,0
                              DO KADD=-1,0
                                 IVERTCUT = IVERTCUT + 1
                                 VERTS(3*IVERTCUT-2) = REAL(X(I+IADD),FB)
                                 VERTS(3*IVERTCUT-1) = REAL(Y(J     ),FB)
                                 VERTS(3*IVERTCUT)   = REAL(Z(K+KADD),FB)
                              ENDDO
                           ENDDO
                        CASE(KAXIS)
                           K=KK-1+ILH
                           DO JADD=-1,0
                              DO IADD=-1,0
                                 IVERTCUT = IVERTCUT + 1
                                 VERTS(3*IVERTCUT-2) = REAL(X(I+IADD),FB)
                                 VERTS(3*IVERTCUT-1) = REAL(Y(J+JADD),FB)
                                 VERTS(3*IVERTCUT)   = REAL(Z(K     ),FB)
                              ENDDO
                           ENDDO
                        END SELECT
                        IFACECUT = IFACECUT + 1
                        LOCATIONS(IFACECUT) = 0 + 16
                        FACES(3*IFACECUT-2:3*IFACECUT) = (/ IVERTCUT-3, IVERTCUT-2, IVERTCUT   /) ! Local Nodes 1, 2, 4

                        IFACECUT = IFACECUT + 1
                        LOCATIONS(IFACECUT) = 0 + 16
                        FACES(3*IFACECUT-2:3*IFACECUT) = (/ IVERTCUT  , IVERTCUT-1, IVERTCUT-3 /) ! Local Nodes 4, 3, 1
                     CASE(CC_FTYPE_CFGAS)
                        ICF2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
                        IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
                        X1AXIS  = CUT_FACE(ICF2)%IJK(KAXIS+1); DIR = X1AXIS
                        NVF     = CUT_FACE(ICF2)%CFELEM(1,IFACE2)
                        VERTBEG = IVERTCUT + 1
                        VERTBEG = 3*VERTBEG - 2
                        VERTEND = IVERTCUT + NVF
                        VERTEND = 3*VERTEND
                        DO IVCF=1,NVF
                           IVERTCUT = IVERTCUT + 1
                           IVERTCF=CUT_FACE(ICF2)%CFELEM(IVCF+1,IFACE2)
                           VERTS(3*IVERTCUT-2:3*IVERTCUT) = REAL(CUT_FACE(ICF2)%XYZVERT(1:3,IVERTCF),FB)
                        ENDDO
                        FACEBEG = 3*(IFACECUT+1) - 2
                        FACEEND = FACEBEG + 3*(NVF-2) - 1
                        FACEPTR(1:3*(NVF-2))        =>FACES(FACEBEG:FACEEND)
                        VERTPTR(1:1+VERTEND-VERTBEG)=>VERTS(VERTBEG:VERTEND)
                        VERT_OFFSET = IVERTCUT - NVF
                        ALLOCATE(LOCTYPE(NVF-2))
                        CALL TRIANGULATE(DIR,VERTPTR,NVF,VERT_OFFSET,FACEPTR,LOCTYPE)
                        DO IVCF = 1, NVF-2 ! for now assume face is convex
                           IFACECUT = IFACECUT + 1
                           LOCATIONS(IFACECUT) = 2 + LOCTYPE(IVCF)
                           IF(IFACE2 > CUT_FACE(ICF2)%NFACE) LOCATIONS(IFACECUT) = 1 + LOCTYPE(IVCF) ! Solid side.
                        ENDDO
                        DEALLOCATE(LOCTYPE)
                     CASE(CC_FTYPE_CFINB)
                        ICF2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
                        IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
                        NVF     = CUT_FACE(ICF2)%CFELEM(1,IFACE2); DIR = 0
                        VERTBEG = IVERTCUT + 1
                        VERTBEG = 3*VERTBEG - 2
                        VERTEND = IVERTCUT + NVF
                        VERTEND = 3*VERTEND
                        DO IVCF=1,NVF
                           IVERTCUT = IVERTCUT + 1
                           IVERTCF=CUT_FACE(ICF2)%CFELEM(IVCF+1,IFACE2)
                           VERTS(3*IVERTCUT-2:3*IVERTCUT) = REAL(CUT_FACE(ICF2)%XYZVERT(1:3,IVERTCF),FB)
                        ENDDO
                        FACEBEG = 3*(IFACECUT+1) - 2
                        FACEEND = FACEBEG + 3*(NVF-2) - 1
                        FACEPTR(1:3*(NVF-2))        =>FACES(FACEBEG:FACEEND)
                        VERTPTR(1:1+VERTEND-VERTBEG)=>VERTS(VERTBEG:VERTEND)
                        VERT_OFFSET = IVERTCUT - NVF
                        ALLOCATE(LOCTYPE(NVF-2))
                        CALL TRIANGULATE(DIR,VERTPTR,NVF,VERT_OFFSET,FACEPTR,LOCTYPE)
                        DO IVCF = 1, NVF-2 ! for now assume face is convex
                           IFACECUT = IFACECUT + 1
                           LOCATIONS(IFACECUT) = 1 + LOCTYPE(IVCF) ! Consider them as SOLID.
                        ENDDO
                        DEALLOCATE(LOCTYPE)
                     END SELECT
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO
   ENDIF
END SUBROUTINE GET_GEOMINFO_DUP


























SUBROUTINE WRITE_VTKHDF_SLICE_DATA_FILE_NOOPEN(DATASET,NM,NCELLS,NPOINTS,DATA,&
   PLIST_ID,GROUP_ID4,FAKE_WRITE)
   CHARACTER(*), INTENT(IN) :: DATASET
   INTEGER, INTENT(IN) :: NM
   INTEGER(IB32), DIMENSION(1:NMESHES), INTENT(IN) :: NCELLS, NPOINTS
   REAL(FB), DIMENSION(*), INTENT(IN) :: DATA
   INTEGER(HID_T), INTENT(IN) :: GROUP_ID4  ! Identifiers
   INTEGER(HID_T), INTENT(INOUT) :: PLIST_ID  ! Identifiers
   LOGICAL, INTENT(IN) :: FAKE_WRITE
   INTEGER(HID_T) :: CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: DSET_ID    ! Dataset identifiers
   INTEGER :: NPOINTS_TOTAL, NCELLS_TOTAL
   INTEGER :: NCELLS_MAX, NPOINTS_MAX
   INTEGER :: ERROR, NMNM
   TYPE (MESH_TYPE), POINTER :: M
   INTEGER(IB32) :: NCELLS_ACCUM, NPOINTS_ACCUM
   INTEGER(HSIZE_T), DIMENSION(1) :: START1(1), EXTENT1(1)
   
   NPOINTS_TOTAL=0
   NCELLS_TOTAL=0
   NCELLS_ACCUM=0
   NPOINTS_ACCUM=0
   NCELLS_MAX = 0
   NPOINTS_MAX = 0
   
   MESH_LOOP_HDF_COUNT: DO NMNM=1,NMESHES
      NPOINTS_TOTAL = NPOINTS_TOTAL + NPOINTS(NMNM) !+ NVERTS*3
      NCELLS_TOTAL = NCELLS_TOTAL + NCELLS(NMNM) !+ NFACES*3
      NCELLS_MAX = MAX(NCELLS_MAX,NCELLS(NMNM))
      NPOINTS_MAX = MAX(NPOINTS_MAX,NPOINTS(NMNM))
   ENDDO MESH_LOOP_HDF_COUNT
   
   START1 = NPOINTS_MAX
   EXTENT1 = NPOINTS_TOTAL
   CALL PARALLEL_INIT_F32(GROUP_ID4, DATASET, CRP_LIST, 1, START1, EXTENT1, DSET_ID, PLIST_ID) ! Data
   IF (FAKE_WRITE) THEN
      START1 = NPOINTS_ACCUM
      EXTENT1 = 0
      CALL PARALLEL_WRITE_F32(1, EXTENT1, DSET_ID, PLIST_ID, START1, EXTENT1, DATA)
   ELSE
      MESH_LOOP_HDF: DO NMNM=1,NMESHES
         IF (NMNM/=NM) THEN
            NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS(NMNM)
            NCELLS_ACCUM = NCELLS_ACCUM + NCELLS(NMNM)
            CYCLE MESH_LOOP_HDF
         ENDIF
         M => MESHES(NM)
      
         ! Write point data to file
         START1 = NPOINTS_ACCUM
         EXTENT1 = NPOINTS(NM)
         CALL PARALLEL_WRITE_F32(1, EXTENT1, DSET_ID, PLIST_ID, START1, EXTENT1, DATA)
      
         NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS(NM)
         NCELLS_ACCUM = NCELLS_ACCUM + NCELLS(NM)
         EXIT
      ENDDO MESH_LOOP_HDF
   ENDIF
   
   ! Close HDF5 datasets
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
   
END SUBROUTINE WRITE_VTKHDF_SLICE_DATA_FILE_NOOPEN













SUBROUTINE WRITE_VTKHDF_SLICE_CELL_FILE_NOOPEN(SLCFNAME,SL3D,NM,NCELLS,NPOINTS,NCONNECTIONS,NTSL,&
   PLIST_ID,GROUP_ID1)
   CHARACTER(*), INTENT(IN) :: SLCFNAME
   INTEGER, INTENT(IN) :: NM, NTSL
   LOGICAL, INTENT(IN) :: SL3D
   INTEGER(HID_T), INTENT(IN) :: GROUP_ID1  ! Identifiers
   INTEGER(HID_T), INTENT(INOUT) :: PLIST_ID  ! Identifiers
   INTEGER(HID_T) :: CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: DSET_ID_CON, DSET_ID_NCELLS    ! Dataset identifiers
   INTEGER(HID_T) :: DSET_ID_NPTS, DSET_ID_OFF, DSET_ID_PTS, DSET_ID_TYP       ! Dataset identifiers
   INTEGER :: NPOINTS_TOTAL, NCELLS_TOTAL, NOFFSETS_TOTAL
   INTEGER :: NCONN_TOTAL, NPIECES
   INTEGER :: NCONN_ACCUM, NPIECES_ACCUM
   INTEGER :: NCONN_MAX, NOFFSETS_MAX, NCELLS_MAX, NPOINTS_MAX
   INTEGER :: NMNM, ERROR, NC, NP, IQ, NQT
   TYPE (MESH_TYPE), POINTER :: M
   REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: VERTICES
   INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
   INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
   INTEGER(IB32), DIMENSION(1:NMESHES), INTENT(OUT) :: NCELLS, NPOINTS
   INTEGER(IB32) :: NCELLS_ACCUM, NPOINTS_ACCUM, NOFFSETS_ACCUM
   TYPE(SLICE_TYPE), POINTER :: SL
   INTEGER, INTENT(OUT) :: NCONNECTIONS
   INTEGER(HSIZE_T), DIMENSION(1) :: START1(1), EXTENT1(1), START2(2), EXTENT2(2)
   INTEGER(HSIZE_T), DIMENSION(1) :: START3(1), EXTENT3(1), START4(1), EXTENT4(4)
   
   ! Read number of cells
   CALL H5DOPEN_F(GROUP_ID1, "NumberOfCells", DSET_ID_NCELLS, ERROR)
   START1 = NMESHES
   CALL H5DREAD_F(DSET_ID_NCELLS, H5T_STD_I32LE, NCELLS, START1, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCELLS, ERROR)

   ! Read number of points
   CALL H5DOPEN_F(GROUP_ID1, "NumberOfPoints", DSET_ID_NPTS, ERROR)
   CALL H5DREAD_F(DSET_ID_NPTS, H5T_STD_I32LE, NPOINTS, START1, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NPTS, ERROR)
   
   IF (.NOT.WRITE_VTK_GEOM_PER_TIMESTEP) THEN
      RETURN
   ENDIF
   
   IF (SL3D) THEN
      NCONNECTIONS=8 ! 3-D slice
   ELSE
      NCONNECTIONS=4 ! 2-D slice
   ENDIF
   
   NPOINTS_TOTAL=0
   NCELLS_TOTAL=0
   NCELLS_ACCUM=0
   NPOINTS_ACCUM=0
   NOFFSETS_TOTAL=0
   NOFFSETS_ACCUM = 0
   NCONN_TOTAL = 0
   NPIECES = 0
   NCONN_ACCUM = 0
   NPIECES_ACCUM = 0
   NCELLS_MAX = 0
   NPOINTS_MAX = 0
   NCONN_MAX = 0
   NOFFSETS_MAX = 0
   
   MESH_LOOP_HDF_COUNT: DO NMNM=1,NMESHES
      NPOINTS_TOTAL = NPOINTS_TOTAL + NPOINTS(NMNM) !+ NVERTS*3
      NCELLS_TOTAL = NCELLS_TOTAL + NCELLS(NMNM) !+ NFACES*3
      NOFFSETS_TOTAL = NOFFSETS_TOTAL + NCELLS(NMNM) + 1
      NCONN_TOTAL = NCONN_TOTAL + NCELLS(NMNM)*NCONNECTIONS
      NPIECES = NPIECES + 1
      NCELLS_MAX = MAX(NCELLS_MAX,NCELLS(NMNM))
      NPOINTS_MAX = MAX(NPOINTS_MAX,NPOINTS(NMNM))
      NOFFSETS_MAX = MAX(NOFFSETS_MAX,NCELLS(NMNM) + 1)
      NCONN_MAX = MAX(NCONN_MAX,NCELLS(NMNM)*NCONNECTIONS)
   ENDDO MESH_LOOP_HDF_COUNT
   
   START1 = NCONN_MAX
   EXTENT1 = NCONN_TOTAL
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Connectivity"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID_CON, PLIST_ID) ! Connectivity
   START1 = NOFFSETS_MAX
   EXTENT1 = NOFFSETS_TOTAL
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Offsets"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID_OFF, PLIST_ID) ! Offsets
   START2(1:2) = INT((/3, NPOINTS_MAX/),HSIZE_T)
   EXTENT2(1:2) = INT((/3, NPOINTS_TOTAL/),HSIZE_T)
   CALL PARALLEL_INIT_F32(GROUP_ID1, TRIM("Points"), CRP_LIST, 2,&
      START2, EXTENT2, DSET_ID_PTS, PLIST_ID) ! Points
   START1 = NCELLS_MAX
   EXTENT1 = NCELLS_TOTAL
   CALL PARALLEL_INIT_U8(GROUP_ID1, TRIM("Types"), CRP_LIST, 1,&
      START1, EXTENT1, DSET_ID_TYP, PLIST_ID) ! Types
   
   CALL POINT_TO_MESH(NM)
   NQT = MESHES(1)%N_SLCF_VTK
   MESH_LOOP_HDF: DO NMNM=1,NMESHES
      IF (NMNM/=NM) THEN
         NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS(NMNM)
         NCELLS_ACCUM = NCELLS_ACCUM + NCELLS(NMNM)
         !IF (NCELLS(NMNM) > 0) NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS(NMNM) + 1
         NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS(NMNM) + 1
         NCONN_ACCUM = NCONN_ACCUM + NCELLS(NMNM)*NCONNECTIONS
         NPIECES_ACCUM = NPIECES_ACCUM+1
         CYCLE MESH_LOOP_HDF
      ENDIF
      M => MESHES(NMNM)
      
      IF (PROCESS(NMNM)/=MY_RANK) THEN
         ALLOCATE(VERTICES(3,0))
         ALLOCATE(OFFSETS(0))
         ALLOCATE(VTKC_TYPE(0))
         ALLOCATE(CONNECT(0))
         START1 = NCONN_ACCUM
         EXTENT1 = 0
         START2(1:2) = INT((/0,NPOINTS_ACCUM/),HSIZE_T)
         EXTENT2(1:2) = INT((/3, 0/),HSIZE_T)
         START3 = NOFFSETS_ACCUM
         EXTENT3 = 0
         START4 = NCELLS_ACCUM
         EXTENT4 = 0
      ELSEIF (NCELLS(NMNM)==0) THEN
         ALLOCATE(VERTICES(3,NCELLS(NMNM)))
         ALLOCATE(OFFSETS(NCELLS(NMNM)))
         ALLOCATE(VTKC_TYPE(NCELLS(NMNM)))
         ALLOCATE(CONNECT(NCELLS(NMNM)*NCONNECTIONS))
         START1 = NCONN_ACCUM
         EXTENT1 = NCELLS(NMNM)*NCONNECTIONS
         START2(1:2) = INT((/0,NPOINTS_ACCUM/),HSIZE_T)
         EXTENT2(1:2) = INT((/3, NPOINTS(NMNM)/),HSIZE_T)
         START3 = NOFFSETS_ACCUM
         EXTENT3 = NCELLS(NMNM)+1
         START4 = NCELLS_ACCUM
         EXTENT4 = NCELLS(NMNM)
      ELSE
         QUANTITY_LOOPB: DO IQ=1,NQT
            SL => SLICE(IQ)
            IF (TRIM(SL%SLCF_NAME)/=TRIM(SLCFNAME)) CYCLE QUANTITY_LOOPB
            CALL BUILD_VTK_SLICE_GEOMETRY2(NMNM, SL, NTSL, NC, NP, VERTICES, CONNECT, OFFSETS, VTKC_TYPE)
            EXIT
         ENDDO QUANTITY_LOOPB
         START1 = NCONN_ACCUM
         EXTENT1 = NCELLS(NMNM)*NCONNECTIONS
         START2(1:2) = INT((/0,NPOINTS_ACCUM/),HSIZE_T)
         EXTENT2(1:2) = INT((/3, NPOINTS(NMNM)/),HSIZE_T)
         START3 = NOFFSETS_ACCUM
         EXTENT3 = NCELLS(NMNM)+1
         START4 = NCELLS_ACCUM
         EXTENT4 = NCELLS(NMNM)
      ENDIF
      
      ! Write connectivity data to file
      CALL PARALLEL_WRITE_I32(1, EXTENT1, DSET_ID_CON, PLIST_ID, START1, EXTENT1, CONNECT)
      
      ! Write point data to file
      CALL PARALLEL_WRITE_F32(2, EXTENT2, DSET_ID_PTS, PLIST_ID, START2, EXTENT2, VERTICES)
      
      ! Write offsets data to file
      CALL PARALLEL_WRITE_I32(1, EXTENT3, DSET_ID_OFF, PLIST_ID, START3, EXTENT3, OFFSETS)
      
      ! Write types data to file
      CALL PARALLEL_WRITE_U8(1, EXTENT4, DSET_ID_TYP, PLIST_ID, START4, EXTENT4, VTKC_TYPE)
      
      DEALLOCATE(VERTICES)
      DEALLOCATE(OFFSETS)
      DEALLOCATE(CONNECT)
      DEALLOCATE(VTKC_TYPE)
      NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS(NMNM)
      NCELLS_ACCUM = NCELLS_ACCUM + NCELLS(NMNM)
      !IF (NCELLS(NM)>0) NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS(NM) + 1
      NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS(NMNM) + 1
      NCONN_ACCUM = NCONN_ACCUM + NCELLS(NMNM)*NCONNECTIONS
      NPIECES_ACCUM = NPIECES_ACCUM+1
   ENDDO MESH_LOOP_HDF
   
   ! Close HDF5 datasets
   CALL H5DCLOSE_F(DSET_ID_CON, ERROR)
   CALL H5DCLOSE_F(DSET_ID_OFF, ERROR)
   CALL H5DCLOSE_F(DSET_ID_PTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_TYP, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
   
END SUBROUTINE WRITE_VTKHDF_SLICE_CELL_FILE_NOOPEN























SUBROUTINE PARALLEL_INIT_F32(GROUP_ID, SNAME, CRP_LIST, RANK, DDIM, CDIM, DSET_ID, PLIST_ID)
   INTEGER(HID_T), INTENT(IN) :: GROUP_ID               ! Memory identifiers
   INTEGER(HID_T), INTENT(INOUT) :: CRP_LIST, PLIST_ID  ! Memory identifiers
   INTEGER, INTENT(IN)     ::   RANK    ! Dataset rank
   INTEGER(HSIZE_T), DIMENSION(*), INTENT(IN) :: CDIM, DDIM
   CHARACTER(LEN=*), INTENT(IN) :: SNAME
   INTEGER(HID_T), INTENT(OUT) :: DSET_ID  ! Memory identifiers
   INTEGER(HID_T) :: DATASPACE
   INTEGER     ::   ERROR ! Error flag
   LOGICAL :: LINK_EXISTS
   CALL H5LEXISTS_F(GROUP_ID, SNAME, LINK_EXISTS, ERROR)
   IF (.NOT.LINK_EXISTS) THEN
      CALL H5SCREATE_SIMPLE_F(RANK, CDIM, DATASPACE, ERROR, CDIM)
      CALL H5PCREATE_F(H5P_DATASET_CREATE_F, CRP_LIST, ERROR)
      CALL H5PSET_DEFLATE_F(CRP_LIST, 9, ERROR)
      CALL H5PSET_CHUNK_F(CRP_LIST, RANK, DDIM, ERROR)
      CALL H5DCREATE_F(GROUP_ID, SNAME, H5T_IEEE_F32LE, DATASPACE, DSET_ID, ERROR, CRP_LIST)
      CALL H5PCREATE_F(H5P_DATASET_XFER_F, PLIST_ID, ERROR)
      CALL H5PSET_DXPL_MPIO_F(PLIST_ID, H5FD_MPIO_COLLECTIVE_F, ERROR)
      CALL H5SCLOSE_F(DATASPACE, ERROR)
   ELSE
      CALL H5DOPEN_F(GROUP_ID, SNAME, DSET_ID, ERROR)
      CALL H5PCREATE_F(H5P_DATASET_XFER_F, PLIST_ID, ERROR)
      CALL H5PSET_DXPL_MPIO_F(PLIST_ID, H5FD_MPIO_COLLECTIVE_F, ERROR)
   ENDIF
END SUBROUTINE PARALLEL_INIT_F32

SUBROUTINE PARALLEL_INIT_I32(GROUP_ID, SNAME, CRP_LIST, RANK, DDIM, CDIM, DSET_ID, PLIST_ID)
   INTEGER(HID_T), INTENT(IN) :: GROUP_ID               ! Memory identifiers
   INTEGER(HID_T), INTENT(INOUT) :: CRP_LIST, PLIST_ID  ! Memory identifiers
   INTEGER, INTENT(IN)     ::   RANK    ! Dataset rank
   INTEGER(HSIZE_T), DIMENSION(*), INTENT(IN) :: CDIM, DDIM
   CHARACTER(LEN=*), INTENT(IN) :: SNAME
   INTEGER(HID_T), INTENT(OUT) :: DSET_ID  ! Memory identifiers
   INTEGER(HID_T) :: DATASPACE
   INTEGER     ::   ERROR ! Error flag
   LOGICAL :: LINK_EXISTS
   CALL H5LEXISTS_F(GROUP_ID, SNAME, LINK_EXISTS, ERROR)
   IF (.NOT.LINK_EXISTS) THEN
      CALL H5SCREATE_SIMPLE_F(RANK, CDIM, DATASPACE, ERROR, CDIM)
      CALL H5PCREATE_F(H5P_DATASET_CREATE_F, CRP_LIST, ERROR)
      CALL H5PSET_DEFLATE_F(CRP_LIST, 9, ERROR)
      CALL H5PSET_CHUNK_F(CRP_LIST, RANK, DDIM, ERROR)
      CALL H5DCREATE_F(GROUP_ID, SNAME, H5T_STD_I32LE, DATASPACE, DSET_ID, ERROR, CRP_LIST)
      CALL H5PCREATE_F(H5P_DATASET_XFER_F, PLIST_ID, ERROR)
      CALL H5PSET_DXPL_MPIO_F(PLIST_ID, H5FD_MPIO_COLLECTIVE_F, ERROR)
      CALL H5SCLOSE_F(DATASPACE, ERROR)
   ELSE
      CALL H5DOPEN_F(GROUP_ID, SNAME, DSET_ID, ERROR)
      CALL H5PCREATE_F(H5P_DATASET_XFER_F, PLIST_ID, ERROR)
      CALL H5PSET_DXPL_MPIO_F(PLIST_ID, H5FD_MPIO_COLLECTIVE_F, ERROR)
   ENDIF
END SUBROUTINE PARALLEL_INIT_I32

SUBROUTINE PARALLEL_INIT_U8(GROUP_ID, SNAME, CRP_LIST, RANK, DDIM, CDIM, DSET_ID, PLIST_ID)
   INTEGER(HID_T), INTENT(IN) :: GROUP_ID               ! Memory identifiers
   INTEGER(HID_T), INTENT(INOUT) :: CRP_LIST, PLIST_ID  ! Memory identifiers
   INTEGER, INTENT(IN)     ::   RANK    ! Dataset rank
   INTEGER(HSIZE_T), DIMENSION(*), INTENT(IN) :: CDIM, DDIM
   CHARACTER(LEN=*), INTENT(IN) :: SNAME
   INTEGER(HID_T), INTENT(OUT) :: DSET_ID  ! Memory identifiers
   INTEGER(HID_T) :: DATASPACE
   INTEGER     ::   ERROR ! Error flag
   LOGICAL :: LINK_EXISTS
   CALL H5LEXISTS_F(GROUP_ID, SNAME, LINK_EXISTS, ERROR)
   IF (.NOT.LINK_EXISTS) THEN
      CALL H5SCREATE_SIMPLE_F(RANK, CDIM, DATASPACE, ERROR, CDIM)
      CALL H5PCREATE_F(H5P_DATASET_CREATE_F, CRP_LIST, ERROR)
      CALL H5PSET_DEFLATE_F(CRP_LIST, 9, ERROR)
      CALL H5PSET_CHUNK_F(CRP_LIST, RANK, DDIM, ERROR)
      CALL H5DCREATE_F(GROUP_ID, SNAME, H5T_STD_U8LE, DATASPACE, DSET_ID, ERROR, CRP_LIST)
      CALL H5PCREATE_F(H5P_DATASET_XFER_F, PLIST_ID, ERROR)
      CALL H5PSET_DXPL_MPIO_F(PLIST_ID, H5FD_MPIO_COLLECTIVE_F, ERROR)
      CALL H5SCLOSE_F(DATASPACE, ERROR)
   ELSE 
      CALL H5DOPEN_F(GROUP_ID, SNAME, DSET_ID, ERROR)
      CALL H5PCREATE_F(H5P_DATASET_XFER_F, PLIST_ID, ERROR)
      CALL H5PSET_DXPL_MPIO_F(PLIST_ID, H5FD_MPIO_COLLECTIVE_F, ERROR)
   ENDIF
END SUBROUTINE PARALLEL_INIT_U8

SUBROUTINE PARALLEL_WRITE_F32(RANK, CDIM, DSET_ID,&
   PLIST_ID, OFFSET, COUNT, DATA)
   INTEGER(HID_T), INTENT(IN) :: DSET_ID, PLIST_ID  ! Memory identifiers
   INTEGER, INTENT(IN)     ::   RANK    ! Dataset rank
   INTEGER(HSIZE_T), DIMENSION(*), INTENT(IN) :: CDIM, OFFSET, COUNT ! Attribute dimension
   REAL(FB), DIMENSION(*), INTENT(IN) :: DATA
   INTEGER     ::   ERROR ! Error flag
   INTEGER(HID_T) :: MEMSPACE, DATASPACE
   
   CALL H5SCREATE_SIMPLE_F (RANK, CDIM, MEMSPACE, ERROR)
   CALL H5DGET_SPACE_F(DSET_ID, DATASPACE, ERROR)
   CALL H5SSELECT_HYPERSLAB_F(DATASPACE, H5S_SELECT_SET_F, OFFSET, COUNT, ERROR)
   CALL H5DWRITE_F(DSET_ID, H5T_IEEE_F32LE, DATA, CDIM, ERROR, &
        MEM_SPACE_ID = MEMSPACE, FILE_SPACE_ID = DATASPACE, XFER_PRP = PLIST_ID)
   CALL H5SCLOSE_F(MEMSPACE, ERROR)
   CALL H5SCLOSE_F(DATASPACE, ERROR)
END SUBROUTINE PARALLEL_WRITE_F32

SUBROUTINE PARALLEL_WRITE_I32(RANK, CDIM, DSET_ID,&
   PLIST_ID, OFFSET, COUNT, DATA)
   INTEGER(HID_T), INTENT(IN) :: DSET_ID, PLIST_ID  ! Memory identifiers
   INTEGER, INTENT(IN)     ::   RANK    ! Dataset rank
   INTEGER(HSIZE_T), DIMENSION(*), INTENT(IN) :: CDIM, OFFSET, COUNT ! Attribute dimension
   INTEGER(IB32), DIMENSION(*), INTENT(IN) :: DATA
   INTEGER     ::   ERROR ! Error flag
   INTEGER(HID_T) :: MEMSPACE, DATASPACE
   
   CALL H5SCREATE_SIMPLE_F (RANK, CDIM, MEMSPACE, ERROR)
   CALL H5DGET_SPACE_F(DSET_ID, DATASPACE, ERROR)
   CALL H5SSELECT_HYPERSLAB_F(DATASPACE, H5S_SELECT_SET_F, OFFSET, COUNT, ERROR)
   CALL H5DWRITE_F(DSET_ID, H5T_STD_I32LE, DATA, CDIM, ERROR, &
        MEM_SPACE_ID = MEMSPACE, FILE_SPACE_ID = DATASPACE, XFER_PRP = PLIST_ID)
   CALL H5SCLOSE_F(MEMSPACE, ERROR)
   CALL H5SCLOSE_F(DATASPACE, ERROR)
END SUBROUTINE PARALLEL_WRITE_I32

SUBROUTINE PARALLEL_WRITE_U8(RANK, CDIM, DSET_ID,&
   PLIST_ID, OFFSET, COUNT, DATA)
   INTEGER(HID_T), INTENT(IN) :: DSET_ID, PLIST_ID  ! Memory identifiers
   INTEGER, INTENT(IN)     ::   RANK    ! Dataset rank
   INTEGER(HSIZE_T), DIMENSION(*), INTENT(IN) :: CDIM, OFFSET, COUNT ! Attribute dimension
   INTEGER(IB8), DIMENSION(*), INTENT(IN) :: DATA
   INTEGER     ::   ERROR ! Error flag
   INTEGER(HID_T) :: MEMSPACE, DATASPACE
   
   CALL H5SCREATE_SIMPLE_F (RANK, CDIM, MEMSPACE, ERROR)
   CALL H5DGET_SPACE_F(DSET_ID, DATASPACE, ERROR)
   CALL H5SSELECT_HYPERSLAB_F(DATASPACE, H5S_SELECT_SET_F, OFFSET, COUNT, ERROR)
   CALL H5DWRITE_F(DSET_ID, H5T_STD_U8LE, DATA, CDIM, ERROR, &
        MEM_SPACE_ID = MEMSPACE, FILE_SPACE_ID = DATASPACE, XFER_PRP = PLIST_ID)
   CALL H5SCLOSE_F(MEMSPACE, ERROR)
   CALL H5SCLOSE_F(DATASPACE, ERROR)
END SUBROUTINE PARALLEL_WRITE_U8

SUBROUTINE ADD_VERSION(GROUP_ID,ADIMS,ARANK,ANAME,ATTR_DATA)
   INTEGER(HID_T) :: ATTR_ID, ASPACE_ID, GROUP_ID             ! Identifiers
   INTEGER(HSIZE_T), DIMENSION(1), INTENT(IN) :: ADIMS        ! Attribute dimension
   INTEGER, INTENT(IN)     ::   ARANK                         ! Attribute rank
   INTEGER :: ERROR                                           ! Error flag
   CHARACTER(LEN=*), INTENT(IN) :: ANAME                      ! Attribute name
   INTEGER(HSIZE_T), DIMENSION(:), INTENT(IN) :: ATTR_DATA(:) ! Attribute data
   
   CALL H5SCREATE_SIMPLE_F(ARANK, ADIMS, ASPACE_ID, ERROR)
   CALL H5ACREATE_F(GROUP_ID, TRIM(ANAME), H5T_STD_I32LE, ASPACE_ID, ATTR_ID, ERROR)
   CALL H5AWRITE_F(ATTR_ID, H5T_STD_I32LE, ATTR_DATA, ADIMS, ERROR)
   CALL H5ACLOSE_F(ATTR_ID, ERROR)
   CALL H5SCLOSE_F(ASPACE_ID, ERROR)
END SUBROUTINE ADD_VERSION

SUBROUTINE ADD_TYPE(GROUP_ID,DATA_DIMS,ANAME,ATTR_DATA,ALEN)
   INTEGER(HID_T) :: ATTR_ID, ASPACE_ID, GROUP_ID, ATYPE_ID   ! Identifiers
   INTEGER(HSIZE_T), DIMENSION(1), INTENT(IN) :: DATA_DIMS    ! Attribute dimension
   INTEGER(SIZE_T), INTENT(IN) :: ALEN     ! Length of the attribute string
   INTEGER     ::   ERROR                                     ! Error flag
   CHARACTER(LEN=*), INTENT(IN) :: ANAME
   CHARACTER(LEN=*), INTENT(IN) :: ATTR_DATA
   
   CALL H5SCREATE_F(H5S_SCALAR_F, ASPACE_ID, ERROR)
   CALL H5TCOPY_F(H5T_NATIVE_CHARACTER, ATYPE_ID, ERROR)
   CALL H5TSET_SIZE_F(ATYPE_ID, ALEN, ERROR)
   CALL H5TSET_STRPAD_F(ATYPE_ID, H5T_STR_NULLPAD_F, ERROR)
   CALL H5ACREATE_F(GROUP_ID, TRIM(ANAME), ATYPE_ID, ASPACE_ID, ATTR_ID, ERROR)
   CALL H5AWRITE_F(ATTR_ID, ATYPE_ID, ATTR_DATA, DATA_DIMS, ERROR)
   CALL H5ACLOSE_F(ATTR_ID, ERROR)
   CALL H5TCLOSE_F(ATYPE_ID, ERROR)
   CALL H5SCLOSE_F(ASPACE_ID, ERROR)
END SUBROUTINE ADD_TYPE

#endif


SUBROUTINE WRITE_PARAVIEW_STATE_FILE(NMESHES)
USE OUTPUT_CLOCKS

INTEGER, INTENT(IN) :: NMESHES
TYPE (MESH_TYPE), POINTER :: M
REAL(EB) :: CX,CY,CZ,XMN,XMX,YMN,YMX,ZMN,ZMX
INTEGER :: NM

XMX = -HUGE(EB)
YMX = -HUGE(EB)
ZMX = -HUGE(EB)
XMN = HUGE(EB)
YMN = HUGE(EB)
ZMN = HUGE(EB)
DO NM=1,NMESHES
   CALL POINT_TO_MESH(NM)
   M => MESHES(NM)
   XMX = MAX(XMX, M%XF)
   XMN = MIN(XMN, M%XS)
   YMX = MAX(YMX, M%YF)
   YMN = MIN(YMN, M%YS)
   ZMX = MAX(ZMX, M%ZF)
   ZMN = MIN(ZMN, M%ZS)
ENDDO

CX = (XMX+XMN)/2
CY = (YMX+YMN)/2
CZ = (ZMX+ZMN)/2

OPEN(LU_PARAVIEW,FILE=FN_PARAVIEW,FORM='FORMATTED', STATUS='REPLACE',ACTION='WRITE')
WRITE(LU_PARAVIEW,'(A)') '#Script to import FDS generated data for visualization in Paraview'
WRITE(LU_PARAVIEW,'(A)') 'import os'
WRITE(LU_PARAVIEW,'(A)') 'import glob'
WRITE(LU_PARAVIEW,'(A)') "def writeSeries(files, times, outfile):"
WRITE(LU_PARAVIEW,'(A)') "    with open(outfile, 'w') as f:"
WRITE(LU_PARAVIEW,'(A,A,A,A,A)') '        f.write(',"'",&
                             '{\n  "file-series-version" : "1.0",\n  "files" : [',"'",')'
WRITE(LU_PARAVIEW,'(A)') "        for time, file in zip(times, files):"
WRITE(LU_PARAVIEW,'(A,A,A,A,A)') '            f.write(',"'",'    { "name" : "%s", "time" : %0.2f },\n',&
                              "'",'%(file, time))'
WRITE(LU_PARAVIEW,'(A)') "        f.write('    ]\n  }\n')"
WRITE(LU_PARAVIEW,'(A)') "def parseTimes(files, ext):"
WRITE(LU_PARAVIEW,'(A)') "    times = [float(file.split('_')[-1].split(ext)[0])/100 for file in files]"
WRITE(LU_PARAVIEW,'(A)') "    return times"

WRITE(LU_PARAVIEW,'(A,A,A)') "chid = '",TRIM(CHID),"'"
WRITE(LU_PARAVIEW,'(A)') 'T_Begin = 0.0'
IF (DT_VTK_SPECIFIED > 0) THEN
   WRITE(LU_PARAVIEW,'(A,F15.3)') 'T_End = ',(T_END-T_BEGIN)/DT_VTK_SPECIFIED
ELSE
   WRITE(LU_PARAVIEW,'(A,F15.3)') 'T_End = ',REAL(NFRAMES,FB)
ENDIF

WRITE(LU_PARAVIEW,'(A,F15.3,A,F15.3,A,F15.3,A)') 'CenterOfRotation = [',CX,',',CY,',',CZ,']'
WRITE(LU_PARAVIEW,'(A,F15.3,A,F15.3,A,F15.3,A)') 'CameraFocalPoint = [',CX,',',CY,',',CZ,']'
WRITE(LU_PARAVIEW,'(A)') 'CameraFocalPoint = [x+0.01 if (abs(x) < 0.01) else x for x in CameraFocalPoint]'
WRITE(LU_PARAVIEW,'(A)') 'import paraview'
WRITE(LU_PARAVIEW,'(A)') 'from paraview.simple import *'
WRITE(LU_PARAVIEW,'(A)') 'paraview.simple._DisableFirstRenderCameraReset()'
WRITE(LU_PARAVIEW,'(A)') 'version = paraview.simple.GetParaViewVersion()'
WRITE(LU_PARAVIEW,'(A)') 'version_num = version.major + version.minor/100'
WRITE(LU_PARAVIEW,'(A)') 'if version_num <= 5.11:'
WRITE(LU_PARAVIEW,'(A)') "    piecewisefunction = 'PiecewiseFunction'"
WRITE(LU_PARAVIEW,'(A)') "    axesactor = 'GridAxes3DActor'"
WRITE(LU_PARAVIEW,'(A)') "    gridaxesrep = 'GridAxesRepresentation'"
WRITE(LU_PARAVIEW,'(A)') "    polaraxesrep = 'PolarAxesRepresentation'"
WRITE(LU_PARAVIEW,'(A)') 'else:'
WRITE(LU_PARAVIEW,'(A)') "    piecewisefunction = 'Piecewise Function'"
WRITE(LU_PARAVIEW,'(A)') "    axesactor = 'Grid Axes 3D Actor'"
WRITE(LU_PARAVIEW,'(A)') "    gridaxesrep = 'Grid Axes Representation'"
WRITE(LU_PARAVIEW,'(A)') "    polaraxesrep = 'Polar Axes Representation'"
WRITE(LU_PARAVIEW,'(A)') 'materialLibrary1 = GetMaterialLibrary()'

WRITE(LU_PARAVIEW,'(A)') "renderView1 = CreateView('RenderView')"
WRITE(LU_PARAVIEW,'(A)') "renderView1.AxesGrid = axesactor"
WRITE(LU_PARAVIEW,'(A)') "renderView1.CenterOfRotation = CenterOfRotation"
WRITE(LU_PARAVIEW,'(A)') "renderView1.StereoType = 'Crystal Eyes'"
WRITE(LU_PARAVIEW,'(A)') "renderView1.CameraFocalPoint = CameraFocalPoint"
WRITE(LU_PARAVIEW,'(A)') "renderView1.CameraViewUp = [0.0, 0.0, 1.0]"
WRITE(LU_PARAVIEW,'(A)') "paraview.simple.LoadPalette('WhiteBackground')"
WRITE(LU_PARAVIEW,'(A)') "renderView1.BackEnd = 'OSPRay raycaster'"
WRITE(LU_PARAVIEW,'(A)') "renderView1.OSPRayMaterialLibrary = materialLibrary1"
WRITE(LU_PARAVIEW,'(A)') "SetActiveView(None)"
WRITE(LU_PARAVIEW,'(A)') "layout1 = CreateLayout(name='Layout #1')"
WRITE(LU_PARAVIEW,'(A)') "layout1.AssignView(0, renderView1)"
WRITE(LU_PARAVIEW,'(A)') "SetActiveView(renderView1)"
WRITE(LU_PARAVIEW,'(A)') "# ----------------------------------------------------------------"
WRITE(LU_PARAVIEW,'(A)') "# setup the data processing pipelines"
WRITE(LU_PARAVIEW,'(A)') "# ----------------------------------------------------------------"
WRITE(LU_PARAVIEW,'(A)') "remoteConnection = servermanager.ActiveConnection.IsRemote()"
WRITE(LU_PARAVIEW,'(A)') "if remoteConnection:"
WRITE(LU_PARAVIEW,'(A)') "    indir = r'"//TRIM(WORKING_DIR)//"'"
WRITE(LU_PARAVIEW,'(A)') "    sep = '/'"
WRITE(LU_PARAVIEW,'(A)') "    uri = servermanager.ActiveConnection.GetURI()"
WRITE(LU_PARAVIEW,'(A)') "else:"
WRITE(LU_PARAVIEW,'(A)') "    indir = os.path.dirname(os.path.realpath(__file__))"
WRITE(LU_PARAVIEW,'(A)') "    sep = os.sep"
WRITE(LU_PARAVIEW,'(A)') "    uri = None"
WRITE(LU_PARAVIEW,'(A)') "rdir = r'"//TRIM(VTK_DIR)//"'"
WRITE(LU_PARAVIEW,'(A)') "if rdir == '':"
WRITE(LU_PARAVIEW,'(A)') "    namespace=indir+sep+chid"
WRITE(LU_PARAVIEW,'(A)') "else:"
WRITE(LU_PARAVIEW,'(A)') "    namespace=indir+sep+rdir+sep+chid"
WRITE(LU_PARAVIEW,'(A)') "pxm = servermanager.ProxyManager()"
WRITE(LU_PARAVIEW,'(A)') "directory_proxy = pxm.NewProxy('misc', 'ListDirectory')"
WRITE(LU_PARAVIEW,'(A)') "directory_proxy.List(indir+sep+rdir)"
WRITE(LU_PARAVIEW,'(A)') 'if version_num < 5.12:'
WRITE(LU_PARAVIEW,'(A)') "    directory_proxy.UpdatePropertyINFOrmation()"
WRITE(LU_PARAVIEW,'(A)') 'else:'
WRITE(LU_PARAVIEW,'(A)') "    directory_proxy.UpdatePropertyInformation()"
WRITE(LU_PARAVIEW,'(A,A)') "fileList = sorted(servermanager.VectorProperty(",&
                               "directory_proxy,directory_proxy.GetProperty('FileList')))"
WRITE(LU_PARAVIEW,'(A,A)') "directoryList = servermanager.VectorProperty(",&
                               "directory_proxy,directory_proxy.GetProperty('DirectoryList'))"
WRITE(LU_PARAVIEW,'(A)') "directory_proxy_root = pxm.NewProxy('misc', 'ListDirectory')"
WRITE(LU_PARAVIEW,'(A)') "directory_proxy_root.List(indir+sep)"
WRITE(LU_PARAVIEW,'(A)') 'if version_num < 5.12:'
WRITE(LU_PARAVIEW,'(A)') "    directory_proxy_root.UpdatePropertyINFOrmation()"
WRITE(LU_PARAVIEW,'(A)') 'else:'
WRITE(LU_PARAVIEW,'(A)') "    directory_proxy_root.UpdatePropertyInformation()"
WRITE(LU_PARAVIEW,'(A,A)') "fileList_root = sorted(servermanager.VectorProperty(",&
                               "directory_proxy_root,directory_proxy_root.GetProperty('FileList')))"
WRITE(LU_PARAVIEW,'(A,A)') "directoryList_root = servermanager.VectorProperty(",&
                               "directory_proxy_root,directory_proxy_root.GetProperty('DirectoryList'))"

WRITE(LU_PARAVIEW,'(A)') "# add geometry data"
WRITE(LU_PARAVIEW,'(A)') "if chid + '_GEOM.vtkhdf' in fileList_root:"
WRITE(LU_PARAVIEW,'(A,A)') "    geom = VTKHDFReader(registrationName='Geometry',",&
                      "FileName=[indir + sep + chid + '_GEOM.vtkhdf'])"
WRITE(LU_PARAVIEW,'(A)') "    geomDisplay = Show(geom, renderView1, 'UnstructuredGridRepresentation')"
WRITE(LU_PARAVIEW,'(A)') "    geomDisplay.MapScalars = 0"
WRITE(LU_PARAVIEW,'(A)') "    geomDisplay.Representation = 'Surface'"
WRITE(LU_PARAVIEW,'(A)') "    gcOLORTF2D = GetTransferFunction2D('Color')"
WRITE(LU_PARAVIEW,'(A)') "    geomColor = GetColorTransferFunction('Color')"
WRITE(LU_PARAVIEW,'(A)') "    geomColor.TransferFunction2D = gcOLORTF2D"
WRITE(LU_PARAVIEW,'(A)') "    geomColor.RGBPoints = [1.13, 0.23, 0.30, 0.75, 1.13, 0.87, 0.87, 0.87, 1.13, 0.71, 0.02, 0.15]"
WRITE(LU_PARAVIEW,'(A)') "    geomColor.ScalarRangeInitialized = 1.0"
WRITE(LU_PARAVIEW,'(A)') "    geomDisplay.ColorArrayName = ['CELLS', 'Color']"
WRITE(LU_PARAVIEW,'(A)') "    geomDisplay.LookupTable = geomColor"

WRITE(LU_PARAVIEW,'(A)') "# create a new 'STL Reader'"
WRITE(LU_PARAVIEW,'(A)') "if chid + '.stl' in fileList_root:"
WRITE(LU_PARAVIEW,'(A)') "    casestl = STLReader(registrationName='GeometrySTL', FileNames=[indir+sep+chid+'.stl'])"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay = Show(casestl, renderView1, 'GeometryRepresentation')"
WRITE(LU_PARAVIEW,'(A)') "    # trace defaults for the display properties."
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.Representation = 'Surface'"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.ColorArrayName = [None, '']"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.SelectTCoordArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.SelectNormalArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.SelectTangentArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.OSPRayScaleFunction = piecewisefunction"
!WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.Assembly = ''"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.SelectOrientationVectors = 'None'"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.ScaleFactor = 1.5493113040924074"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.SelectScaleArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.GlyphType = 'Arrow'"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.GlyphTableIndexArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.GaussianRadius = 0.07746556520462036"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.SetScaleArray = [None, '']"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.ScaleTransferFunction = piecewisefunction"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.OpacityArray = [None, '']"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.OpacityTransferFunction = piecewisefunction"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.DataAxesGrid = gridaxesrep"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.PolarAxes = polaraxesrep"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.SelectInputVectors = [None, '']"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.WriteLog = ''"
WRITE(LU_PARAVIEW,'(A)') "# Load data files"
WRITE(LU_PARAVIEW,'(A,A)') "sm3dFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                            "if ('_SM3D_' in x) and ('.vtkhdf' in x)]"
WRITE(LU_PARAVIEW,'(A,A)') "sl2dxFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                            "if ('_X_' in x) and ('.vtkhdf' in x)]"
WRITE(LU_PARAVIEW,'(A,A)') "sl2dyFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                            "if ('_Y_' in x) and ('.vtkhdf' in x)]"
WRITE(LU_PARAVIEW,'(A,A)') "sl2dzFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                            "if ('_Z_' in x) and ('.vtkhdf' in x)]"
WRITE(LU_PARAVIEW,'(A,A)') "sl2daFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                            "if ('_AGL_' in x) and ('.vtkhdf' in x)]"
WRITE(LU_PARAVIEW,'(A,A)') "sl3dFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                            "if ('_SL3D_' in x) and ('.vtkhdf' in x)]"
WRITE(LU_PARAVIEW,'(A,A)') "bndfFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                            "if ('_BNDF_' in x) and ('.vtkhdf' in x)]"
WRITE(LU_PARAVIEW,'(A,A)') "partFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                               "if ('_PART_' in x) and ('.vtkhdf' in x)]"
!WRITE(LU_PARAVIEW,'(A)') "bndfFiles = sorted(glob.glob(namespace+'_BNDF_*.pvtu'))"
!WRITE(LU_PARAVIEW,'(A)') "sm3dFiles = sorted(glob.glob(namespace+'_SM3D_*.pvtu'))"
!WRITE(LU_PARAVIEW,'(A)') "sl2dxFiles = sorted(glob.glob(namespace+'_X_*.pvtu'))"
!WRITE(LU_PARAVIEW,'(A)') "sl2dyFiles = sorted(glob.glob(namespace+'_Y_*.pvtu'))"
!WRITE(LU_PARAVIEW,'(A)') "sl2dzFiles = sorted(glob.glob(namespace+'_Z_*.pvtu'))"
!WRITE(LU_PARAVIEW,'(A)') "sl3dFiles = sorted(glob.glob(namespace+'_SL3D_*.pvtu'))"
!WRITE(LU_PARAVIEW,'(A)') "partFiles = sorted(glob.glob(namespace+'_PART_*.pvtp'))"

WRITE(LU_PARAVIEW,'(A)') "# Add boundary data"
WRITE(LU_PARAVIEW,'(A)') "if len(bndfFiles) > 0:"
WRITE(LU_PARAVIEW,'(A)') "    if remoteConnection:"
WRITE(LU_PARAVIEW,'(A,A)') "        BoundaryData = VTKHDFReader(",&
                                        "registrationName='Boundary', FileName=bndfFiles)"
WRITE(LU_PARAVIEW,'(A)') "    else:"
WRITE(LU_PARAVIEW,'(A)') "        bndfFiles = [rdir + x.split(sep)[-1] for x in bndfFiles]"
WRITE(LU_PARAVIEW,'(A)') "        times = parseTimes(bndfFiles, '.vtkhdf')"
WRITE(LU_PARAVIEW,'(A)') "        outname = indir+sep+'bndf.vtkhdf.series'"
WRITE(LU_PARAVIEW,'(A)') "        writeSeries(bndfFiles, times, outname)"
WRITE(LU_PARAVIEW,'(A,A)') "        BoundaryData = VTKHDFReader(",&
                                        "registrationName='Boundary', FileName=[outname])"
WRITE(LU_PARAVIEW,'(A)') "# Add smoke 3d data"
WRITE(LU_PARAVIEW,'(A)') "if len(sm3dFiles) > 0:"
WRITE(LU_PARAVIEW,'(A)') "    if remoteConnection:"
WRITE(LU_PARAVIEW,'(A,A)') "        sm3dData = VTKHDFReader(",&
                                     "registrationName='Raw Smoke 3D', FileName=sm3dFiles)"
WRITE(LU_PARAVIEW,'(A)') "    else:"
WRITE(LU_PARAVIEW,'(A)') "        sm3dFiles = [rdir + x.split(sep)[-1] for x in sm3dFiles]"
WRITE(LU_PARAVIEW,'(A)') "        times = parseTimes(sm3dFiles, '.vtkhdf')"
WRITE(LU_PARAVIEW,'(A)') "        outname = indir+sep+'sm3d.vtkhdf.series'"
WRITE(LU_PARAVIEW,'(A)') "        writeSeries(sm3dFiles, times, outname)"
WRITE(LU_PARAVIEW,'(A,A)') "        sm3dData = VTKHDFReader(",&
                                     "registrationName='Raw Smoke 3D', FileName=[outname])"
WRITE(LU_PARAVIEW,'(A)') "    smokeName = None"
WRITE(LU_PARAVIEW,'(A)') "    fireName = None"
WRITE(LU_PARAVIEW,'(A)') "    for s in sm3dData.PointArrayStatus:"
WRITE(LU_PARAVIEW,'(A)') "        if ('smoke' in s.lower() or 'soot' in s.lower()):"
WRITE(LU_PARAVIEW,'(A)') "            smokeName = s"
WRITE(LU_PARAVIEW,'(A)') "        if ('hrrpuv' in s.lower()):"
WRITE(LU_PARAVIEW,'(A)') "            fireName = s"
WRITE(LU_PARAVIEW,'(A)') "# Add 3d slice data"
WRITE(LU_PARAVIEW,'(A)') "if len(sl3dFiles) > 0:"
WRITE(LU_PARAVIEW,'(A)') "    if remoteConnection:"
WRITE(LU_PARAVIEW,'(A,A)') "        sl3dData = VTKHDFReader(",&
                                        "registrationName='Raw 3D Slice', FileName=sl3dFiles)"
WRITE(LU_PARAVIEW,'(A)') "    else:"
WRITE(LU_PARAVIEW,'(A)') "        sl3dFiles = [rdir + x.split(sep)[-1] for x in sl3dFiles]"
WRITE(LU_PARAVIEW,'(A)') "        times = parseTimes(sl3dFiles, '.vtkhdf')"
WRITE(LU_PARAVIEW,'(A)') "        outname = indir+sep+'sl3d.vtkhdf.series'"
WRITE(LU_PARAVIEW,'(A)') "        writeSeries(sl3dFiles, times, outname)"
WRITE(LU_PARAVIEW,'(A,A)') "        sl3dData = VTKHDFReader(",&
                                     "registrationName='Raw 3D Slice', FileName=[outname])"
WRITE(LU_PARAVIEW,'(A,A)') "    sl3dImage = ResampleToImage(",&
                                    "registrationName='Sampled 3D Slice', Input=sl3dData)"
WRITE(LU_PARAVIEW,'(A,A)') "    sl3dSlice = Slice(",&
                                    "registrationName='3D Slice Extraction', Input=sl3dImage)"
WRITE(LU_PARAVIEW,'(A)') "    sl3dSlice.SliceType = 'Plane'"
WRITE(LU_PARAVIEW,'(A)') "    sl3dSlice.HyperTreeGridSlicer = 'Plane'"
WRITE(LU_PARAVIEW,'(A)') "    sl3dSlice.SliceOffsetValues = [0.0]"
!WRITE(LU_PARAVIEW,'(A)') "    sl3dSlice.PointMergeMethod = 'Uniform Binning'"
WRITE(LU_PARAVIEW,'(A)') "    sl3dSlice.SliceType.Origin = CenterOfRotation"
WRITE(LU_PARAVIEW,'(A)') "    sl3dSlice.HyperTreeGridSlicer.Origin = CenterOfRotation"

WRITE(LU_PARAVIEW,'(A)') "# Add 2d slice data"
WRITE(LU_PARAVIEW,'(A,A)') "for sl2dFiles, axis_name in zip([sl2dxFiles,sl2dyFiles,sl2dzFiles,sl2daFiles],",&
                           "    ['X','Y','Z','AGL']):"
WRITE(LU_PARAVIEW,'(A)') "    if len(sl2dFiles) > 0:"
WRITE(LU_PARAVIEW,'(A)') "        slcfTypes = [x.split(chid+'_'+axis_name+'_')[1] for x in sl2dFiles]"
WRITE(LU_PARAVIEW,'(A,A)') "        slcfTypes = [('_'.join(x.split('_')[:-1])).replace('neg_','-')",&
                                        ".replace('pos_','') for x in slcfTypes]"
WRITE(LU_PARAVIEW,'(A)') "        uniqueSlcfTypes = sorted(list(set(slcfTypes)))"
WRITE(LU_PARAVIEW,'(A)') "        for slcfType in uniqueSlcfTypes:"
WRITE(LU_PARAVIEW,'(A)') "            axis=float(slcfType)/100"
WRITE(LU_PARAVIEW,'(A)') "            if remoteConnection:"
WRITE(LU_PARAVIEW,'(A,A)') "                slcf_files = sorted([x for x,y in zip(sl2dFiles, slcfTypes)",&
                                                "if y == slcfType])"
WRITE(LU_PARAVIEW,'(A,A)') "                sl2dData = VTKHDFReader(",&
                                                "registrationName='%s=%0.4f'%(axis_name,axis), FileName=slcf_files)"
WRITE(LU_PARAVIEW,'(A)') "            else:"
WRITE(LU_PARAVIEW,'(A,A)') "                slcf_files = sorted([rdir + x.split(sep)[-1] for x,y in ",&
                                                "zip(sl2dFiles, slcfTypes) if y == slcfType])"
WRITE(LU_PARAVIEW,'(A)') "                times = parseTimes(slcf_files, '.vtkhdf')"
WRITE(LU_PARAVIEW,'(A)') "                outname = indir+sep+'sl2d-'+slcfType.replace(' ','-')+'.vtkhdf.series'"
WRITE(LU_PARAVIEW,'(A)') "                writeSeries(slcf_files, times, outname)"
WRITE(LU_PARAVIEW,'(A,A)') "                sl2dData = VTKHDFReader(",&
                                                "registrationName='%s=%0.4f'%(axis_name,axis), FileName=[outname])"
WRITE(LU_PARAVIEW,'(A)') "# Add particle data"
WRITE(LU_PARAVIEW,'(A)') "if len(partFiles) > 0:"
WRITE(LU_PARAVIEW,'(A)') "    partTypes = [x.split('_PART_')[1] for x in partFiles]"
WRITE(LU_PARAVIEW,'(A)') "    partTypes = ['_'.join(x.split('_')[:-1]) for x in partTypes]"
WRITE(LU_PARAVIEW,'(A)') "    uniquePartTypes = sorted(list(set(partTypes)))"
WRITE(LU_PARAVIEW,'(A)') "    for partType in uniquePartTypes:"
WRITE(LU_PARAVIEW,'(A)') "        partTypeFiles = sorted([x for x,y in zip(partFiles, partTypes) if y == partType])"
WRITE(LU_PARAVIEW,'(A)') "        if remoteConnection:"
WRITE(LU_PARAVIEW,'(A)') "            partTypeFiles = sorted([x for x,y in zip(partFiles, partTypes) if y == partType])"
WRITE(LU_PARAVIEW,'(A,A)') "            partData = VTKHDFReader(",&
                                            "registrationName='Particle: '+partType, FileName=partTypeFiles)"
WRITE(LU_PARAVIEW,'(A)') "        else:"
WRITE(LU_PARAVIEW,'(A)') "            partTypeFiles = [rdir + x.split(sep)[-1] for x in partTypeFiles]"
WRITE(LU_PARAVIEW,'(A)') "            times = parseTimes(partTypeFiles, '.vtkhdf')"
WRITE(LU_PARAVIEW,'(A)') "            outname = indir+sep+'particles-'+partType.replace(' ','-')+'.vtkhdf.series'"
WRITE(LU_PARAVIEW,'(A)') "            outname = os.path.abspath(outname)"
WRITE(LU_PARAVIEW,'(A)') "            writeSeries(partTypeFiles, times, outname)"
WRITE(LU_PARAVIEW,'(A,A)') "            partData = VTKHDFReader(",&
                                            "registrationName='Particle: '+partType, FileName=[outname])"
WRITE(LU_PARAVIEW,'(A)') "        cOLORTF2D = GetTransferFunction2D('COLOR')"
WRITE(LU_PARAVIEW,'(A)') "        partColor = GetColorTransferFunction('COLOR')"
WRITE(LU_PARAVIEW,'(A)') "        partColor.TransferFunction2D = cOLORTF2D"
WRITE(LU_PARAVIEW,'(A,A)') "        partColor.RGBPoints = [1.13, 0.23, 0.30, 0.75, 1.13, 0.87,",&
                                        " 0.87, 0.87, 1.13, 0.71, 0.02, 0.15]"
WRITE(LU_PARAVIEW,'(A)') "        partColor.ScalarRangeInitialized = 1.0"
WRITE(LU_PARAVIEW,'(A)') "        partDisplay = Show(partData, renderView1, 'GeometryRepresentation')"
WRITE(LU_PARAVIEW,'(A)') "        partDisplay.Representation = 'Point Gaussian'"
WRITE(LU_PARAVIEW,'(A)') "        partDisplay.ColorArrayName = ['POINTS', 'COLOR']"
WRITE(LU_PARAVIEW,'(A)') "        partDisplay.LookupTable = partColor"
WRITE(LU_PARAVIEW,'(A)') "        partDisplay.MapScalars = 0"
WRITE(LU_PARAVIEW,'(A)') "        partDisplay.GaussianRadius = 0.05"
WRITE(LU_PARAVIEW,'(A)') "        partDisplay.ShaderPreset = 'Plain circle'"

WRITE(LU_PARAVIEW,'(A)') "if len(sm3dFiles) > 0:"
WRITE(LU_PARAVIEW,'(A)') "    # ----------------------------------------------------------------"
WRITE(LU_PARAVIEW,'(A)') "    # setup filter for fire 3d data"
WRITE(LU_PARAVIEW,'(A)') "    # ----------------------------------------------------------------"
WRITE(LU_PARAVIEW,'(A)') "    if fireName is not None:"
WRITE(LU_PARAVIEW,'(A)') "        fireImage = ResampleToImage(registrationName='Fire', Input=sm3dData)"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay = Show(fireImage, renderView1, 'UniformGridRepresentation')"
WRITE(LU_PARAVIEW,'(A)') "        # get 2D transfer function for 'HRRPUV'"
WRITE(LU_PARAVIEW,'(A)') "        hRRPUVTF2D = GetTransferFunction2D(fireName, separate=True)"
WRITE(LU_PARAVIEW,'(A)') "        # get color transfer function/color map for 'HRRPUV'"
WRITE(LU_PARAVIEW,'(A)') "        hRRPUVLUT = GetColorTransferFunction(fireName, separate=True)"
WRITE(LU_PARAVIEW,'(A)') "        hRRPUVLUT.TransferFunction2D = hRRPUVTF2D"
WRITE(LU_PARAVIEW,'(A,A)') "        hRRPUVLUT.RGBPoints = [0.0, 0.0, 0.0, 0.0, -25.4, 0.9, 0.0, 0.0, 76.2, ",&
                                  "0.9, 0.9, 0.0, 254.0, 1.0, 1.0, 1.0]"
WRITE(LU_PARAVIEW,'(A)') "        hRRPUVLUT.ColorSpace = 'RGB'"
WRITE(LU_PARAVIEW,'(A)') "        hRRPUVLUT.NanColor = [0.0, 0.5, 1.0]"
WRITE(LU_PARAVIEW,'(A)') "        hRRPUVLUT.ScalarRangeInitialized = 1.0"
WRITE(LU_PARAVIEW,'(A)') "        # get opacity transfer function/opacity map for 'HRRPUV'"
WRITE(LU_PARAVIEW,'(A)') "        hRRPUVPWF = GetOpacityTransferFunction(fireName, separate=True)"
WRITE(LU_PARAVIEW,'(A)') "        hRRPUVPWF.Points = [0.0, 0.0, 0.5, 0.0, 254.0, 1.0, 0.5, 0.0]"
WRITE(LU_PARAVIEW,'(A)') "        hRRPUVPWF.ScalarRangeInitialized = 1"
WRITE(LU_PARAVIEW,'(A)') "        # trace defaults for the display properties."
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.Representation = 'Volume'"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.ColorArrayName = ['POINTS', fireName]"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.LookupTable = hRRPUVLUT"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.SelectTCoordArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.SelectNormalArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.SelectTangentArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.OSPRayScaleArray = fireName"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.OSPRayScaleFunction = piecewisefunction"
!WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.Assembly = ''"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.SelectOrientationVectors = 'None'"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.ScaleFactor = 3.0"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.SelectScaleArray = fireName"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.GlyphType = 'Arrow'"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.GlyphTableIndexArray = fireName"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.GaussianRadius = 0.15"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.SetScaleArray = ['POINTS', fireName]"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.ScaleTransferFunction = piecewisefunction"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.OpacityArray = ['POINTS', fireName]"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.OpacityTransferFunction = piecewisefunction"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.DataAxesGrid = gridaxesrep"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.PolarAxes = polaraxesrep"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.ScalarOpacityUnitDistance = 0.44"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.ScalarOpacityFunction = hRRPUVPWF"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.TransferFunction2D = hRRPUVTF2D"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.OpacityArrayName = ['POINTS', fireName]"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.ColorArray2Name = ['POINTS', fireName]"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.SliceFunction = 'Plane'"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.Slice = 49"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.SelectInputVectors = ['POINTS', '']"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.WriteLog = ''"
WRITE(LU_PARAVIEW,'(A)') "        # init the piecewisefunction selected for 'ScaleTransferFunction'"
WRITE(LU_PARAVIEW,'(A,A)') "        fireImageDisplay.ScaleTransferFunction.Points = [0.0, 0.0, 0.5, 0.0, 0.0, ",&
                                  "1.0, 0.5, 0.0]"
WRITE(LU_PARAVIEW,'(A)') "        # init the piecewisefunction selected for 'OpacityTransferFunction'"
WRITE(LU_PARAVIEW,'(A,A)') "        fireImageDisplay.OpacityTransferFunction.Points = [0.0, 0.0, 0.5, 0.0, 0.0, ",&
                                  "1.0, 0.5, 0.0]"
WRITE(LU_PARAVIEW,'(A)') "        # init the 'Plane' selected for 'SliceFunction'"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.SliceFunction.Origin = CenterOfRotation"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.UseSeparateColorMap = True"
WRITE(LU_PARAVIEW,'(A)') "    # ----------------------------------------------------------------"
WRITE(LU_PARAVIEW,'(A)') "    # setup filter for smoke 3d data"
WRITE(LU_PARAVIEW,'(A)') "    # ----------------------------------------------------------------"
WRITE(LU_PARAVIEW,'(A)') "    if smokeName is not None:"
WRITE(LU_PARAVIEW,'(A)') "        smokeImage = ResampleToImage(registrationName='Smoke', Input=sm3dData)"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay = Show(smokeImage, renderView1, 'UniformGridRepresentation')"
WRITE(LU_PARAVIEW,'(A)') "        # get 2D transfer function for 'SOOTDENSITY'"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYTF2D = GetTransferFunction2D(smokeName)"
WRITE(LU_PARAVIEW,'(A)') "        # get color transfer function/color map for 'SOOTDENSITY'"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYLUT = GetColorTransferFunction(smokeName)"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYLUT.TransferFunction2D = sOOTDENSITYTF2D"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYLUT.RGBPoints = [0.0, 0.0, 0.0, 0.0, 254.0, 0.0, 0.0, 0.0]"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYLUT.ColorSpace = 'RGB'"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYLUT.NanColor = [1.0, 0.0, 0.0]"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYLUT.ScalarRangeInitialized = 1.0"
WRITE(LU_PARAVIEW,'(A)') "        # get opacity transfer function/opacity map for 'SOOTDENSITY'"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYPWF = GetOpacityTransferFunction(smokeName)"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYPWF.Points = [0.0, 0.0, 0.5, 0.0, 1.0, 0.25, 0.5, 0.0, 254.0, 1.0, 0.5, 0.0]"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYPWF.ScalarRangeInitialized = 1"
WRITE(LU_PARAVIEW,'(A)') "        # trace defaults for the display properties."
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.Representation = 'Volume'"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.ColorArrayName = ['POINTS', smokeName]"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.LookupTable = sOOTDENSITYLUT"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.SelectTCoordArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.SelectNormalArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.SelectTangentArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.OSPRayScaleArray = smokeName"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.OSPRayScaleFunction = piecewisefunction"
!WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.Assembly = ''"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.SelectOrientationVectors = 'None'"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.ScaleFactor = 3.0"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.SelectScaleArray = smokeName"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.GlyphType = 'Arrow'"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.GlyphTableIndexArray = smokeName"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.GaussianRadius = 0.15"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.SetScaleArray = ['POINTS', smokeName]"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.ScaleTransferFunction = piecewisefunction"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.OpacityArray = ['POINTS', smokeName]"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.OpacityTransferFunction = piecewisefunction"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.DataAxesGrid = gridaxesrep"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.PolarAxes = polaraxesrep"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.ScalarOpacityFunction = sOOTDENSITYPWF"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.ScalarOpacityUnitDistance = 1.2957383373220388"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.OpacityArrayName = ['POINTS', smokeName]"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.SelectInputVectors = [None, '']"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.WriteLog = ''"
WRITE(LU_PARAVIEW,'(A)') "        # init the piecewisefunction selected for 'ScaleTransferFunction'"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.ScaleTransferFunction.Points =[0.0, 0.0, 0.5, 0.0, 1.0, 1.0, 0.5, 0.0]"
WRITE(LU_PARAVIEW,'(A)') "        # init the piecewisefunction selected for 'OpacityTransferFunction'"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.OpacityTransferFunction.Points =[0.0, 0.0, 0.5, 0.0, 1.0, 1.0, 0.5, 0.0]"

WRITE(LU_PARAVIEW,'(A)') "# ----------------------------------------------------------------"
WRITE(LU_PARAVIEW,'(A)') "# setup animation scene, tracks and keyframes"
WRITE(LU_PARAVIEW,'(A)') "# note: the Get..() functions create a new object, if needed"
WRITE(LU_PARAVIEW,'(A)') "# ----------------------------------------------------------------"

WRITE(LU_PARAVIEW,'(A)') "# get time animation track"
WRITE(LU_PARAVIEW,'(A)') "timeAnimationCue1 = GetTimeTrack()"

WRITE(LU_PARAVIEW,'(A)') "# initialize the animation scene"

WRITE(LU_PARAVIEW,'(A)') "# get the time-keeper"
WRITE(LU_PARAVIEW,'(A)') "timeKeeper1 = GetTimeKeeper()"
WRITE(LU_PARAVIEW,'(A)') "# initialize the timekeeper"
WRITE(LU_PARAVIEW,'(A)') "# initialize the animation track"
WRITE(LU_PARAVIEW,'(A)') "# get animation scene"
WRITE(LU_PARAVIEW,'(A)') "animationScene1 = GetAnimationScene()"

WRITE(LU_PARAVIEW,'(A)') "# initialize the animation scene"
WRITE(LU_PARAVIEW,'(A)') "animationScene1.ViewModules = renderView1"
WRITE(LU_PARAVIEW,'(A)') "animationScene1.Cues = timeAnimationCue1"
WRITE(LU_PARAVIEW,'(A)') "animationScene1.AnimationTime = T_Begin"
!WRITE(LU_PARAVIEW,'(A)') "animationScene1.EndTime = T_End"
WRITE(LU_PARAVIEW,'(A)') "animationScene1.PlayMode = 'Snap To TimeSteps'"

WRITE(LU_PARAVIEW,'(A)') "# ----------------------------------------------------------------"
WRITE(LU_PARAVIEW,'(A)') "# restore active source"
WRITE(LU_PARAVIEW,'(A)') "if len(sm3dFiles) > 0:"
WRITE(LU_PARAVIEW,'(A)') "    SetActiveSource(sm3dData)"
WRITE(LU_PARAVIEW,'(A)') "# ----------------------------------------------------------------"

CLOSE(LU_PARAVIEW)


END SUBROUTINE WRITE_PARAVIEW_STATE_FILE




END MODULE VTK_FDS_INTERFACE



