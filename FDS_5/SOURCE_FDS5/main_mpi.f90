PROGRAM FDS  

! Fire Dynamics Simulator, Main Program, Multiple CPU version.

USE PRECISION_PARAMETERS
USE MESH_VARIABLES
USE GLOBAL_CONSTANTS
USE TRAN
USE DUMP
USE READ_INPUT
USE INIT
USE DIVG
USE PRES
USE MASS
USE PART
USE VELO
USE RAD
USE MEMORY_FUNCTIONS
USE COMP_FUNCTIONS, ONLY : SECOND, WALL_CLOCK_TIME, SHUTDOWN, FLUSH_BUFFER
USE MATH_FUNCTIONS, ONLY : GAUSSJ
USE DEVICE_VARIABLES
USE WALL_ROUTINES
USE FIRE
USE RADCONS
USE CONTROL_FUNCTIONS
!EVAC:USE EVAC

IMPLICIT NONE

! Miscellaneous declarations

CHARACTER(255), PARAMETER :: mainmpiid='$Id$'
LOGICAL  :: EX,DIAGNOSTICS,EXCHANGE_RADIATION=.TRUE.
INTEGER  :: LO10,NM,IZERO,DATE_TIME(8),NN
CHARACTER(10) :: BIG_BEN(3)
REAL(EB) :: T_MAX,T_MIN
REAL(EB), ALLOCATABLE, DIMENSION(:) ::  T,TC_GLB,TC_LOC,DT_SYNC, DTNEXT_SYNC,DSUM_ALL,PSUM_ALL,USUM_ALL
INTEGER, ALLOCATABLE, DIMENSION(:) ::  MESH_STOP_STATUS,COUNT_GLB,COUNT_LOC
LOGICAL, ALLOCATABLE, DIMENSION(:) ::  ACTIVE_MESH,STATE_GLB,STATE_LOC
INTEGER NOM,IWW,IW
INTEGER, PARAMETER :: N_DROP_ADOPT_MAX=10000
TYPE (MESH_TYPE), POINTER :: M,M4
TYPE (OMESH_TYPE), POINTER :: M2,M3
 
! MPI stuff

! INCLUDE '/usr/local/include/mpif.h'  ! Uncomment this line only if the compiler needs help finding mpif.h
INCLUDE 'mpif.h'
INTEGER :: N,MYID=0,NUMPROCS=1,I,IERR,STATUS(MPI_STATUS_SIZE)
INTEGER :: RNODE,BUFFER_SIZE,TAG,PNAMELEN
INTEGER, ALLOCATABLE, DIMENSION(:,:,:) :: TAGS
INTEGER, ALLOCATABLE, DIMENSION(:) :: REQ,PREQ
INTEGER, ALLOCATABLE, DIMENSION(:,:) :: ARRAY_OF_STATUSES
INTEGER, ALLOCATABLE, DIMENSION(:,:) :: ARRAY_OF_STATUSES2
INTEGER :: N_REQ,N_PREQ
CHARACTER(MPI_MAX_PROCESSOR_NAME) PNAME
 
! Initialize MPI (First executable lines of code)
 
CALL MPI_INIT(IERR)
CALL MPI_COMM_RANK(MPI_COMM_WORLD, MYID, IERR)
CALL MPI_COMM_SIZE(MPI_COMM_WORLD, NUMPROCS, IERR)
CALL MPI_GET_PROCESSOR_NAME(PNAME, PNAMELEN, IERR)
 
WRITE(LU_ERR,'(A,I2,A,I2,A,A)') 'Mesh ',MYID+1,' of ', NUMPROCS,' is alive on ',PNAME(1:PNAMELEN)

! Start wall clock timing

WALL_CLOCK_START = WALL_CLOCK_TIME()
 
! Assign a compilation date (All Nodes)
 
COMPILE_DATE   = 'August 3, 2007'
VERSION_STRING = '5_RC6+_MPI'
VERSION_NUMBER = 5.0
PARALLEL       = .TRUE.
 
! Read input from CHID.data file (All Nodes)
 
CALL READ_DATA(MYID)
 
IF (NMESHES/=NUMPROCS) CALL SHUTDOWN('ERROR: Number of meshes not equal to '// 'number of threads')
 
! Read input for EVACUATION routine
 
! IF (ANY(EVACUATION_GRID)) CALL READ_EVAC
 
! Open and write to Smokeview file (Master Node Only)
 
CALL ASSIGN_FILE_NAMES
IF (MYID==0) CALL WRITE_SMOKEVIEW_FILE
 
! Stop all the processes if this is just a set-up run
 
IF (SET_UP) CALL SHUTDOWN('Stop FDS, Set-up only')
 
! Set up Time arrays (All Nodes)
 
ALLOCATE(ACTIVE_MESH(NMESHES),STAT=IZERO)
CALL ChkMemErr('MAIN','ACTIVE_MESH',IZERO)
ALLOCATE(T(NMESHES),STAT=IZERO)
CALL ChkMemErr('MAIN','T',IZERO)
ALLOCATE(DT_SYNC(NMESHES),STAT=IZERO)
CALL ChkMemErr('MAIN','DT_SYNC',IZERO)
ALLOCATE(DTNEXT_SYNC(NMESHES),STAT=IZERO)
CALL ChkMemErr('MAIN','DTNEXT_SYNC',IZERO)
ALLOCATE(MESH_STOP_STATUS(NMESHES),STAT=IZERO)
CALL ChkMemErr('MAIN','MESH_STOP_STATUS',IZERO)

! Set up dummy arrays to hold various arrays that must be exchanged among meshes

ALLOCATE(COUNT_LOC(N_DEVC),STAT=IZERO)
CALL ChkMemErr('MAIN','COUNT_LOC',IZERO) 
ALLOCATE(COUNT_GLB(N_DEVC),STAT=IZERO)
CALL ChkMemErr('MAIN','COUNT_GLB',IZERO) 
ALLOCATE(STATE_GLB(N_DEVC),STAT=IZERO)
CALL ChkMemErr('MAIN','STATE_GLB',IZERO) 
ALLOCATE(STATE_LOC(N_DEVC),STAT=IZERO)
CALL ChkMemErr('MAIN','STATE_LOC',IZERO) 
ALLOCATE(TC_GLB(N_DEVC),STAT=IZERO)
CALL ChkMemErr('MAIN','TC_GLB',IZERO)
ALLOCATE(TC_LOC(N_DEVC),STAT=IZERO)
CALL ChkMemErr('MAIN','TC_LOC',IZERO)

! Allocate a few arrays needed to exchange divergence and pressure info among meshes

IF (N_ZONE > 0) THEN
   ALLOCATE(DSUM_ALL(N_ZONE),STAT=IZERO)
   ALLOCATE(PSUM_ALL(N_ZONE),STAT=IZERO)
   ALLOCATE(USUM_ALL(N_ZONE),STAT=IZERO)
ENDIF

! Start the clock

T     = T_BEGIN
MESH_STOP_STATUS = NO_STOP
 
! Create unique tags for all mesh exchanges
 
ALLOCATE(REQ(NMESHES*NMESHES*10)) 
REQ = MPI_REQUEST_NULL
ALLOCATE(PREQ(NMESHES*NMESHES*10)) 
PREQ = MPI_REQUEST_NULL
ALLOCATE(ARRAY_OF_STATUSES(MPI_STATUS_SIZE,NMESHES*NMESHES*10))
ALLOCATE(ARRAY_OF_STATUSES2(MPI_STATUS_SIZE,NMESHES*NMESHES*10))
ALLOCATE(TAGS(NMESHES,NMESHES,0:2))
TAG = 0
DO NM=1,NMESHES
   DO NOM=NM,NMESHES
      TAG = TAG+1
      TAGS(NM,NOM,0) = TAG
      TAGS(NOM,NM,0) = TAG
   ENDDO
ENDDO
TAGS(:,:,1) = TAGS(:,:,0) + 1000
TAGS(:,:,2) = TAGS(:,:,0) + 2000
 
! Initialize global parameters (All Nodes)
 
CALL INITIALIZE_GLOBAL_VARIABLES
CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
 
! Initialize radiation (All Nodes)
 
IF (RADIATION) CALL INIT_RADIATION
CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
 
! Allocate and initialize mesh-specific variables
 
DO NM=MYID+1,NMESHES,NUMPROCS
   CALL INITIALIZE_MESH_VARIABLES(NM)
ENDDO
CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
 
! Allocate and initialize mesh variable exchange arrays
 
DO NM=MYID+1,NMESHES,NUMPROCS
CALL INITIALIZE_MESH_EXCHANGE(NM)
ENDDO
CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
 
CALL MPI_ALLGATHER(I_MIN(1,MYID+1),NMESHES,MPI_INTEGER,I_MIN, NMESHES,MPI_INTEGER,MPI_COMM_WORLD,IERR)
CALL MPI_ALLGATHER(I_MAX(1,MYID+1),NMESHES,MPI_INTEGER,I_MAX, NMESHES,MPI_INTEGER,MPI_COMM_WORLD,IERR)
CALL MPI_ALLGATHER(J_MIN(1,MYID+1),NMESHES,MPI_INTEGER,J_MIN, NMESHES,MPI_INTEGER,MPI_COMM_WORLD,IERR)
CALL MPI_ALLGATHER(J_MAX(1,MYID+1),NMESHES,MPI_INTEGER,J_MAX, NMESHES,MPI_INTEGER,MPI_COMM_WORLD,IERR)
CALL MPI_ALLGATHER(K_MIN(1,MYID+1),NMESHES,MPI_INTEGER,K_MIN, NMESHES,MPI_INTEGER,MPI_COMM_WORLD,IERR)
CALL MPI_ALLGATHER(K_MAX(1,MYID+1),NMESHES,MPI_INTEGER,K_MAX, NMESHES,MPI_INTEGER,MPI_COMM_WORLD,IERR)
CALL MPI_ALLGATHER(NIC(1,MYID+1),  NMESHES,MPI_INTEGER,NIC,   NMESHES,MPI_INTEGER,MPI_COMM_WORLD,IERR)
 
I_MIN = TRANSPOSE(I_MIN)
I_MAX = TRANSPOSE(I_MAX)
J_MIN = TRANSPOSE(J_MIN)
J_MAX = TRANSPOSE(J_MAX)
K_MIN = TRANSPOSE(K_MIN)
K_MAX = TRANSPOSE(K_MAX)
NIC   = TRANSPOSE(NIC)
 
DO NM=MYID+1,NMESHES,NUMPROCS
   CALL DOUBLE_CHECK(NM)
ENDDO
CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
 
! Potentially read data from a previous calculation 
 
DO NM=MYID+1,NMESHES,NUMPROCS
   IF (RESTART) CALL READ_RESTART(T(NM),NM)
ENDDO
CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
 
! Initialize output files containing global data (Master Node Only)
 
IF (MYID==0) CALL INITIALIZE_GLOBAL_DUMPS
CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
 
! Initialize output files that are mesh-specific
 
DO NM=MYID+1,NMESHES,NUMPROCS
   CALL INITIALIZE_MESH_DUMPS(NM)
   CALL INITIALIZE_DROPLETS(NM)
   CALL INITIALIZE_TREES(NM)
!     IF (ANY(EVACUATION_GRID)) CALL INITIALIZE_EVACUATION(NM)
   CALL POST_RECEIVES(NM,0)
ENDDO
CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
 
! Write out character strings to .smv file
 
CALL WRITE_STRINGS
 
! Initialize Mesh Exchange Arrays (All Nodes)
 
CALL MESH_EXCHANGE(0)
CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)

! Make an initial dump of ambient values

DO NM=MYID+1,NMESHES,NUMPROCS
   CALL UPDATE_OUTPUTS(T(NM),NM)      
   CALL DUMP_MESH_OUTPUTS(T(NM),NM)
ENDDO
CALL DUMP_GLOBAL_OUTPUTS(T(1))
 
!***********************************************************************************************************************************
!                                                           MAIN TIMESTEPPING LOOP
!***********************************************************************************************************************************
 
MAIN_LOOP: DO  
 
   ICYC  = ICYC + 1 
 
   IF (MOD(ICYC,3)==0 .AND. TIMING) THEN
      CALL DATE_AND_TIME(BIG_BEN(1),BIG_BEN(2),BIG_BEN(3),DATE_TIME)
      WRITE(0,'(A,I2,A,I6,A,I2,A,I3.3)')  ' Thread ',MYID+1,' starts iteration',ICYC,' at ', DATE_TIME(7),'.',DATE_TIME(8)
   ENDIF
 
   EXCHANGE_RADIATION = .FALSE.
   IF (RADIATION) THEN
      IF (MOD(ICYC,ANGLE_INCREMENT*TIME_STEP_INCREMENT)==0) EXCHANGE_RADIATION = .TRUE.
   ENDIF
 
   ! Synchronize clocks
 
   CALL MPI_ALLGATHER(T(MYID+1),1,MPI_DOUBLE_PRECISION,T,1, MPI_DOUBLE_PRECISION,MPI_COMM_WORLD,IERR)
 
   ! Check for program stops
 
   INQUIRE(FILE=TRIM(CHID)//'.stop',EXIST=EX)
   IF (EX) MESH_STOP_STATUS = USER_STOP
   CALL MPI_ALLGATHER(MESH_STOP_STATUS(MYID+1),1,MPI_INTEGER,MESH_STOP_STATUS,1,MPI_INTEGER,MPI_COMM_WORLD,IERR)
 
   ! Figure out fastest and slowest meshes
 
   T_MAX = -1000000._EB
   T_MIN =  1000000._EB
   DO NM=1,NMESHES
      T_MIN = MIN(T(NM),T_MIN)
      T_MAX = MAX(T(NM),T_MAX)
      IF (MESH_STOP_STATUS(NM)/=NO_STOP) GLOBAL_STOP_STATUS = MESH_STOP_STATUS(NM)
   ENDDO
 
   ! Determine time step
 
   IF (SYNCHRONIZE) THEN
      DT_SYNC(MYID+1) = MESHES(MYID+1)%DTNEXT
      CALL MPI_ALLGATHER(DT_SYNC(MYID+1),1,MPI_DOUBLE_PRECISION, DT_SYNC,1,MPI_DOUBLE_PRECISION,MPI_COMM_WORLD,IERR)
      IF (SYNC_TIME_STEP(MYID+1)) THEN
         MESHES(MYID+1)%DTNEXT = MINVAL(DT_SYNC,MASK=SYNC_TIME_STEP)
         T(MYID+1) = MINVAL(T,MASK=SYNC_TIME_STEP)
         ACTIVE_MESH(MYID+1) = .TRUE.
      ELSE
         ACTIVE_MESH(MYID+1) = .FALSE.
         IF (T(MYID+1)+MESHES(MYID+1)%DTNEXT <= T_MAX)  ACTIVE_MESH(MYID+1) = .TRUE.
         IF (GLOBAL_STOP_STATUS/=NO_STOP) ACTIVE_MESH(MYID+1) = .TRUE.
      ENDIF
   ELSE
      ACTIVE_MESH = .FALSE.
      DO NM=1,NMESHES
         IF (T(NM)+MESHES(NM)%DTNEXT <= T_MAX) ACTIVE_MESH(NM) = .TRUE.
         IF (GLOBAL_STOP_STATUS/=NO_STOP) ACTIVE_MESH(NM) = .TRUE.
      ENDDO
   ENDIF
 
   ! Determine when to dump out diagnostics to the .out file
 
   DIAGNOSTICS = .FALSE.
   LO10 = LOG10(REAL(ICYC,EB))
   IF (MOD(ICYC,10**LO10)==0 .OR. MOD(ICYC,100)==0 .OR. T_MIN>=T_END .OR. GLOBAL_STOP_STATUS/=NO_STOP) DIAGNOSTICS = .TRUE.
 
   ! Give every processor the full ACTIVE_MESH array
 
   CALL MPI_ALLGATHER(ACTIVE_MESH(MYID+1), 1, MPI_LOGICAL,  ACTIVE_MESH,1, MPI_LOGICAL, MPI_COMM_WORLD, IERR)
 
   ! If no meshes are due to be updated, update them all
 
   IF (ALL(.NOT.ACTIVE_MESH)) ACTIVE_MESH = .TRUE.
 
!     Do not do EVACuation if past the max iteration criteria
!
!     IF (ANY(EVACUATION_GRID)) THEN
!       EVAC_DT = 1000000.
!       DO NM=1,NMESHES
!         IF (.NOT.EVACUATION_ONLY(NM))
!    .         EVAC_DT = MIN(EVAC_DT,MESHES(NM)%DTNEXT)
!       ENDDO
!       DO NM=1,NMESHES
!         IF (EVACUATION_ONLY(NM)) THEN
!           IF (ICYC > EVAC_TIME_ITERATIONS) THEN
!             ACTIVE_MESH(NM) = .FALSE.
!             EVAC_DT = MIN(EVAC_DT, EVAC_DT_STEADY_STATE)
!             MESHES(NM)%DT     = EVAC_DT
!             T(NM)           = T(NM) + MESHES(NM)%DT
!             IF (EVACUATION_GRID(NM) ) THEN
!               CALL EVACUATE_HUMANS(T(NM),NM)
!               IF (T(NM)>=PART_CLOCK(NM)) THEN
!                 CALL DUMP_EVAC(PART_CLOCK(NM),NM)
!                 DO
!                   PART_CLOCK(NM) = PART_CLOCK(NM) + WPAR
!                   IF (PART_CLOCK(NM)>=T(NM)) EXIT
!                 ENDDO
!               ENDIF
!             ENDIF
!           ELSE
!             ACTIVE_MESH(NM) = .TRUE.
!             EVAC_DT = MIN(EVAC_DT, EVAC_DT_FLOWFIELD)
!           ENDIF
!         ENDIF
!       ENDDO
!       DO NM=1,NMESHES
!         IF (EVACUATION_ONLY(NM)) MESHES(NM)%DTNEXT = EVAC_DT
!       ENDDO
!     ENDIF
!
   PREDICTOR = .TRUE.
   CORRECTOR = .FALSE.

   ! Diagnostic calls

   IF (DEBUG) WRITE(0,*) 'Cycle ',ICYC,' Mesh ',MYID+1, ' starting',ACTIVE_MESH(MYID+1)

   IF (MOD(ICYC,3)==0 .AND. TIMING) THEN
      CALL DATE_AND_TIME(BIG_BEN(1),BIG_BEN(2),BIG_BEN(3),DATE_TIME)
      IF (ACTIVE_MESH(MYID+1)) WRITE(0,'(A,I2,A,I2,A,I3.3)') ' Thread ',MYID+1,' is active at ', DATE_TIME(7),'.',DATE_TIME(8)
   ENDIF
 
   ! Begin the PREDICTOR step
 
   COMPUTE_FINITE_DIFFERENCES_1: DO NM=MYID+1,NMESHES,NUMPROCS
      IF (.NOT.ACTIVE_MESH(NM)) CYCLE COMPUTE_FINITE_DIFFERENCES_1
      MESHES(NM)%DT = MESHES(NM)%DTNEXT
      NTCYC(NM)   = NTCYC(NM) + 1
 
      CALL INSERT_DROPLETS_AND_PARTICLES(T(NM),NM)
      CALL COMPUTE_VELOCITY_FLUX(T(NM),NM)
      CALL UPDATE_PARTICLES(T(NM),NM)
 
!     IF (EVACUATION_ONLY(NM)) CALL EVACUATE_HUMANS(T(NM),NM)
 
      IF (.NOT.ISOTHERMAL .OR. N_SPECIES>0) CALL MASS_FINITE_DIFFERENCES(NM)
 
   ENDDO COMPUTE_FINITE_DIFFERENCES_1
 
   CHANGE_TIME_STEP_LOOP: DO
 
      COMPUTE_DIVERGENCE_LOOP: DO NM=MYID+1,NMESHES,NUMPROCS
         IF (.NOT.ACTIVE_MESH(NM)) CYCLE COMPUTE_DIVERGENCE_LOOP
         IF (.NOT.ISOTHERMAL .OR. N_SPECIES>0) THEN
            CALL DENSITY(NM)
            CALL WALL_BC(T(NM),NM)
         ENDIF
         CALL DIVERGENCE_PART_1(T(NM),NM)
      ENDDO COMPUTE_DIVERGENCE_LOOP

      CALL EXCHANGE_DIVERGENCE_INFO

      COMPUTE_PRESSURE_LOOP: DO NM=MYID+1,NMESHES,NUMPROCS
         IF (.NOT.ACTIVE_MESH(NM)) CYCLE COMPUTE_PRESSURE_LOOP
         CALL DIVERGENCE_PART_2(NM)
         CALL PRESSURE_SOLVER(NM)
      ENDDO COMPUTE_PRESSURE_LOOP

      IF (PRESSURE_CORRECTION) CALL CORRECT_PRESSURE(1)
 
!     IF (ANY(EVACUATION_GRID) .AND. EVACUATION_ONLY(NM)) THEN
!        PRESSURE_ITERATION_LOOP: DO N=1,EVAC_PRESSURE_ITERATIONS
!           CALL NO_FLUX
!           CALL PRESSURE_SOLVER(NM)
!        ENDDO PRESSURE_ITERATION_LOOP
!     ENDIF
 
      PREDICT_VELOCITY_LOOP: DO NM=MYID+1,NMESHES,NUMPROCS
         IF (.NOT.ACTIVE_MESH(NM)) CYCLE PREDICT_VELOCITY_LOOP
         CALL VELOCITY_PREDICTOR(T(NM),NM,MESH_STOP_STATUS(NM))
      ENDDO PREDICT_VELOCITY_LOOP
 
      IF (SYNCHRONIZE) THEN
         NM = MYID+1
         CALL MPI_ALLGATHER(CHANGE_TIME_STEP(NM),1,MPI_LOGICAL, CHANGE_TIME_STEP,1,MPI_LOGICAL,MPI_COMM_WORLD,IERR)
         CALL MPI_ALLGATHER(MESH_STOP_STATUS(NM),1,MPI_INTEGER,MESH_STOP_STATUS,1, MPI_INTEGER,MPI_COMM_WORLD,IERR)
         IF (ANY(MESH_STOP_STATUS/=NO_STOP)) THEN
            IF (ANY(MESH_STOP_STATUS==INSTABILITY_STOP)) GLOBAL_STOP_STATUS = INSTABILITY_STOP
            EXIT CHANGE_TIME_STEP_LOOP
         ENDIF
         IF (ANY(CHANGE_TIME_STEP)) THEN
            CHANGE_TIME_STEP = .TRUE.
            DT_SYNC(NM) = MESHES(NM)%DT
            DTNEXT_SYNC(NM) = MESHES(NM)%DTNEXT
            CALL MPI_ALLGATHER(DT_SYNC(NM),1,MPI_DOUBLE_PRECISION, DT_SYNC,1,MPI_DOUBLE_PRECISION,MPI_COMM_WORLD,IERR)
            CALL MPI_ALLGATHER(DTNEXT_SYNC(NM),1,MPI_DOUBLE_PRECISION, DTNEXT_SYNC,1,MPI_DOUBLE_PRECISION,MPI_COMM_WORLD,IERR)
            MESHES(NM)%DTNEXT = MINVAL(DTNEXT_SYNC,MASK=SYNC_TIME_STEP)
            MESHES(NM)%DT     = MINVAL(DT_SYNC,MASK=SYNC_TIME_STEP)
         ENDIF
      ENDIF
 
      IF (MESH_STOP_STATUS(MYID+1)/=NO_STOP) THEN
         GLOBAL_STOP_STATUS = MESH_STOP_STATUS(MYID+1)
         EXIT CHANGE_TIME_STEP_LOOP
      ENDIF
 
      IF (.NOT.ANY(CHANGE_TIME_STEP)) EXIT CHANGE_TIME_STEP_LOOP
 
   ENDDO CHANGE_TIME_STEP_LOOP
 
   CHANGE_TIME_STEP = .FALSE.
 
   ! Do the first step in the Runge-Kutta update scheme for sprinklers and detectors
 
   UPDATE_TIME: DO NM=MYID+1,NMESHES,NUMPROCS
      IF (.NOT.ACTIVE_MESH(NM)) CYCLE UPDATE_TIME
      CALL POST_RECEIVES(NM,1)
      T(NM) = T(NM) + MESHES(NM)%DT  ! Advance the time and start the CORRECTOR part of the time step
   ENDDO UPDATE_TIME
 
!====================================================================================================================
 
   ! Exchange information among meshes
 
   IF (MOD(ICYC,3)==0.AND.TIMING.AND.ACTIVE_MESH(MYID+1)) THEN
      CALL DATE_AND_TIME(BIG_BEN(1),BIG_BEN(2),BIG_BEN(3),DATE_TIME)
      WRITE(0,'(A,I2,A,I2,A,I3.3)')  ' Thread ',MYID+1,' enters Mesh Exchange 1 at ', DATE_TIME(7),'.',DATE_TIME(8)
   ENDIF
 
   CALL MESH_EXCHANGE(1)
 
   IF (MOD(ICYC,3)==0.AND.TIMING.AND.ACTIVE_MESH(MYID+1)) THEN
   CALL DATE_AND_TIME(BIG_BEN(1),BIG_BEN(2),BIG_BEN(3),DATE_TIME)
   WRITE(0,'(A,I2,A,I2,A,I3.3)')  ' Thread ',MYID+1,' exits  Mesh Exchange 1 at ', DATE_TIME(7),'.',DATE_TIME(8)
   ENDIF
 
!+=============================================+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
   CORRECTOR = .TRUE.
   PREDICTOR = .FALSE.
 
   COMPUTE_FINITE_DIFFERENCES_2: DO NM=MYID+1,NMESHES,NUMPROCS
      IF (.NOT.ACTIVE_MESH(NM)) CYCLE COMPUTE_FINITE_DIFFERENCES_2
      CALL COMPUTE_VELOCITY_FLUX(T(NM),NM)
      IF (.NOT.ISOTHERMAL .OR. N_SPECIES>0) THEN
         CALL MASS_FINITE_DIFFERENCES(NM)
         CALL DENSITY(NM)
         ! Do combustion, then apply thermal, species and density boundary conditions and solve for radiation
         IF (N_REACTIONS > 0) CALL COMBUSTION (NM)
         CALL WALL_BC(T(NM),NM)
         CALL COMPUTE_RADIATION(NM)
      ENDIF
!     IF (EVACUATION_ONLY(NM)) CALL EVACUATE_HUMANS(T(NM),NM)
      CALL UPDATE_PARTICLES(T(NM),NM)
      CALL DIVERGENCE_PART_1(T(NM),NM)
   ENDDO COMPUTE_FINITE_DIFFERENCES_2

   CALL EXCHANGE_DIVERGENCE_INFO

   COMPUTE_FINITE_DIFFERENCES_3: DO NM=MYID+1,NMESHES,NUMPROCS
      IF (.NOT.ACTIVE_MESH(NM)) CYCLE COMPUTE_FINITE_DIFFERENCES_3
      CALL DIVERGENCE_PART_2(NM)
      CALL PRESSURE_SOLVER(NM)
   ENDDO COMPUTE_FINITE_DIFFERENCES_3

   IF (PRESSURE_CORRECTION) CALL CORRECT_PRESSURE(2)
 
!     IF (ANY(EVACUATION_GRID) .AND. EVACUATION_ONLY(NM)) THEN
!        PRESSURE_ITERATION_LOOP2: DO N=1,EVAC_PRESSURE_ITERATIONS
!           CALL NO_FLUX
!           CALL PRESSURE_SOLVER(NM)
!        ENDDO PRESSURE_ITERATION_LOOP2
!     ENDIF
 
   CORRECT_VELOCITY_LOOP: DO NM=MYID+1,NMESHES,NUMPROCS
      IF (.NOT.ACTIVE_MESH(NM)) CYCLE CORRECT_VELOCITY_LOOP
      CALL POST_RECEIVES(NM,2)   ! Post Receive Arrays
      CALL OPEN_AND_CLOSE(T(NM),NM)   ! Doors, windows, etc.
      CALL VELOCITY_CORRECTOR(T(NM),NM)
      CALL UPDATE_OUTPUTS(T(NM),NM)
      CALL DUMP_MESH_OUTPUTS(T(NM),NM)
      IF (DIAGNOSTICS) CALL CHECK_DIVERGENCE(NM)
   ENDDO CORRECT_VELOCITY_LOOP
 
   !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
   ! Exchange information among meshes
 
   IF (MOD(ICYC,3)==0.AND.TIMING.AND.ACTIVE_MESH(MYID+1)) THEN
      CALL DATE_AND_TIME(BIG_BEN(1),BIG_BEN(2),BIG_BEN(3),DATE_TIME)
      WRITE(0,'(A,I2,A,I2,A,I3.3)')  ' Thread ',MYID+1,' enters Mesh Exchange 2 at ', DATE_TIME(7),'.',DATE_TIME(8)
   ENDIF
 
   CALL MESH_EXCHANGE(2)
   IF (MOD(ICYC,3)==0.AND.TIMING.AND.ACTIVE_MESH(MYID+1)) THEN
      CALL DATE_AND_TIME(BIG_BEN(1),BIG_BEN(2),BIG_BEN(3),DATE_TIME)
      WRITE(0,'(A,I2,A,I2,A,I3.3)')  ' Thread ',MYID+1,' exits  Mesh Exchange 2 at ', DATE_TIME(7),'.',DATE_TIME(8)
   ENDIF
 
   !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
   ! Write character strings out to the .smv file
 
   IF (DIAGNOSTICS) CALL WRITE_STRINGS
 
   ! Exchange info for diagnostic print out
 
   IF (DIAGNOSTICS) CALL EXCHANGE_DIAGNOSTICS

   ! Check for dumping end of timestep outputs

   CALL DUMP_GLOBAL_OUTPUTS(T_MIN)
   CALL UPDATE_CONTROLS(T)
 
   ! Dump out diagnostics

   IF (MYID==0 .AND. DIAGNOSTICS) CALL WRITE_DIAGNOSTICS(T)
 
   ! Stop the run

   IF (T_MIN>=T_END .OR. GLOBAL_STOP_STATUS/=NO_STOP) EXIT MAIN_LOOP
 
   ! Flush Buffers (All Nodes)
 
   IF (MOD(ICYC,10)==0) CALL FLUSH_BUFFERS
   IF (MOD(ICYC,10)==0 .AND. ANY(EVACUATION_GRID)) CALL FLUSH_BUFFER(LU121_EVAC)
   IF (MOD(ICYC,3) ==0 .AND. TIMING) THEN
      CALL DATE_AND_TIME(BIG_BEN(1),BIG_BEN(2),BIG_BEN(3),DATE_TIME)
      WRITE(0,'(A,I2,A,I6,A,I2,A,I3.3)')  ' Thread ',MYID+1,' ends iteration',ICYC,' at ', DATE_TIME(7),'.',DATE_TIME(8)
   ENDIF
 
ENDDO MAIN_LOOP
 
!****************************************************************************************************************************
!                                                   END OF TIME STEPPING LOOP
!****************************************************************************************************************************
 
TUSED(1,MYID+1) = SECOND() - TUSED(1,MYID+1)
CALL MPI_GATHER(TUSED(1,MYID+1),N_TIMERS,MPI_DOUBLE_PRECISION, TUSED,N_TIMERS,MPI_DOUBLE_PRECISION,0, MPI_COMM_WORLD,IERR)
IF (MYID==0) CALL TIMINGS
CALL MPI_FINALIZE(IERR)
 
SELECT CASE(GLOBAL_STOP_STATUS)
   CASE(NO_STOP)
      CALL SHUTDOWN('STOP: FDS completed successfully')
   CASE(INSTABILITY_STOP) 
      CALL SHUTDOWN('STOP: Numerical Instability')
   CASE(USER_STOP) 
      CALL SHUTDOWN('STOP: FDS stopped by user')
END SELECT
 
 
CONTAINS
 
 
SUBROUTINE EXCHANGE_DIVERGENCE_INFO

! Exchange information mesh to mesh needed for divergence integrals

IF (N_ZONE > 0) THEN
   CALL MPI_ALLREDUCE(DSUM(1,MYID+1),DSUM_ALL(1),N_ZONE,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,IERR)
   CALL MPI_ALLREDUCE(PSUM(1,MYID+1),PSUM_ALL(1),N_ZONE,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,IERR)
   CALL MPI_ALLREDUCE(USUM(1,MYID+1),USUM_ALL(1),N_ZONE,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,IERR)
   DSUM(1:N_ZONE,MYID+1) = DSUM_ALL(1:N_ZONE)
   PSUM(1:N_ZONE,MYID+1) = PSUM_ALL(1:N_ZONE)
   USUM(1:N_ZONE,MYID+1) = USUM_ALL(1:N_ZONE)
ENDIF

END SUBROUTINE EXCHANGE_DIVERGENCE_INFO

 
SUBROUTINE INITIALIZE_MESH_EXCHANGE(NM)
 
! Create arrays by which info is to exchanged across meshes
 
INTEGER IMIN,IMAX,JMIN,JMAX,KMIN,KMAX,NOM,IOR,IW
INTEGER, INTENT(IN) :: NM
TYPE (MESH_TYPE), POINTER :: M2,M
LOGICAL FOUND
 
M=>MESHES(NM)
ALLOCATE(MESHES(NM)%OMESH(NMESHES))
 
OTHER_MESH_LOOP: DO NOM=1,NMESHES
 
   IF (NOM==NM) CYCLE OTHER_MESH_LOOP
 
   M2=>MESHES(NOM)
   IMIN=0 
   IMAX=M2%IBP1
   JMIN=0 
   JMAX=M2%JBP1
   KMIN=0 
   KMAX=M2%KBP1
   NIC(NOM,NM) = 0
   FOUND = .FALSE.
   SEARCH_LOOP: DO IW=1,M%NEWC
      IF (M%IJKW(9,IW)/=NOM) CYCLE SEARCH_LOOP
      NIC(NOM,NM) = NIC(NOM,NM) + 1
      FOUND = .TRUE.
      IOR = M%IJKW(4,IW)
      SELECT CASE(IOR)
         CASE( 1) 
            IMIN=MAX(IMIN,M%IJKW(10,IW)-1)
         CASE(-1) 
            IMAX=MIN(IMAX,M%IJKW(10,IW))
         CASE( 2) 
            JMIN=MAX(JMIN,M%IJKW(11,IW)-1)
         CASE(-2) 
            JMAX=MIN(JMAX,M%IJKW(11,IW))
         CASE( 3) 
            KMIN=MAX(KMIN,M%IJKW(12,IW)-1)
         CASE(-3) 
            KMAX=MIN(KMAX,M%IJKW(12,IW))
      END SELECT
   ENDDO SEARCH_LOOP
 
   IF ( M2%XS>=M%XS .AND. M2%XF<=M%XF .AND. M2%YS>=M%YS .AND. M2%YF<=M%YF .AND. &
      M2%ZS>=M%ZS .AND. M2%ZF<=M%ZF ) FOUND = .TRUE.
 
   IF (.NOT.FOUND) CYCLE OTHER_MESH_LOOP
 
   I_MIN(NOM,NM) = IMIN
   I_MAX(NOM,NM) = IMAX
   J_MIN(NOM,NM) = JMIN
   J_MAX(NOM,NM) = JMAX
   K_MIN(NOM,NM) = KMIN
   K_MAX(NOM,NM) = KMAX
 
   ALLOCATE(M%OMESH(NOM)% TMP(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   M%OMESH(NOM)%TMP = TMPA
   ALLOCATE(M%OMESH(NOM)%   H(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   M%OMESH(NOM)%H = 0.
   ALLOCATE(M%OMESH(NOM)%   U(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   M%OMESH(NOM)%U = U0
   ALLOCATE(M%OMESH(NOM)%   V(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   M%OMESH(NOM)%V = V0
   ALLOCATE(M%OMESH(NOM)%   W(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   M%OMESH(NOM)%W = W0
   ALLOCATE(M%OMESH(NOM)% FVX(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   ALLOCATE(M%OMESH(NOM)% FVY(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
   ALLOCATE(M%OMESH(NOM)% FVZ(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX))
 
   IF (N_SPECIES>0) THEN
      ALLOCATE(M%OMESH(NOM)%  YY(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX,N_SPECIES))
      ALLOCATE(M%OMESH(NOM)% YYS(IMIN:IMAX,JMIN:JMAX,KMIN:KMAX,N_SPECIES))
      DO N=1,N_SPECIES
      M%OMESH(NOM)%YY(:,:,:,N)  = SPECIES(N)%YY0
      M%OMESH(NOM)%YYS(:,:,:,N) = SPECIES(N)%YY0
      ENDDO
   ENDIF
 
   ! Wall arrays
 
   ALLOCATE(M%OMESH(NOM)%IJKW(12,M2%NEWC))
   ALLOCATE(M%OMESH(NOM)%BOUNDARY_TYPE(0:M2%NEWC))
   ALLOCATE(M%OMESH(NOM)%WALL(0:M2%NEWC))
 
   ! Particle and Droplet Orphan Arrays
 
   IF (DROPLET_FILE) THEN
      M%OMESH(NOM)%N_DROP_ORPHANS = 0
      M%OMESH(NOM)%N_DROP_ORPHANS_DIM = 1000
      ALLOCATE(M%OMESH(NOM)%DROPLET(M%OMESH(NOM)%N_DROP_ORPHANS_DIM), STAT=IZERO)
      CALL ChkMemErr('INIT','DROPLET',IZERO)
   ENDIF
 
ENDDO OTHER_MESH_LOOP
 
END SUBROUTINE INITIALIZE_MESH_EXCHANGE
 
 

SUBROUTINE DOUBLE_CHECK(NM)
 
! Double check exchange pairs
 
INTEGER NOM
INTEGER, INTENT(IN) :: NM
TYPE (MESH_TYPE), POINTER :: M2,M
 
M=>MESHES(NM)
 
OTHER_MESH_LOOP: DO NOM=1,NMESHES
 
   IF (NOM==NM) CYCLE OTHER_MESH_LOOP
 
   IF (NIC(NM,NOM)==0 .AND. NIC(NOM,NM)>0) THEN
      M2=>MESHES(NOM)
      ALLOCATE(M%OMESH(NOM)%IJKW(12,M2%NEWC))
      ALLOCATE(M%OMESH(NOM)%BOUNDARY_TYPE(0:M2%NEWC))
      ALLOCATE(M%OMESH(NOM)%WALL(0:M2%NEWC))
   ENDIF
 
ENDDO OTHER_MESH_LOOP
 
END SUBROUTINE DOUBLE_CHECK
 
 

SUBROUTINE POST_RECEIVES(NM,CODE)
USE RADCONS, ONLY: NRA,NSB
 
INTEGER, INTENT(IN) :: NM,CODE
 
N_REQ = 0
 
OTHER_MESH_LOOP: DO NOM=1,NMESHES
 
   IF (NIC(NM,NOM)==0 .AND. NIC(NOM,NM)==0) CYCLE OTHER_MESH_LOOP
   IF (CODE>0 .AND. .NOT.ACTIVE_MESH(NOM)) CYCLE OTHER_MESH_LOOP
 
   IF (DEBUG) THEN
      WRITE(0,*) NM,' posting receives from ',NOM,' code=',code
      IF (CODE==0) WRITE(0,'(A,I2,A,I2,A,I5)') 'NIC(',NM,',',NOM,')=',NIC(NM,NOM)
   ENDIF
 
   M =>MESHES(NM)
   M4=>MESHES(NOM)
   M3=>MESHES(NM)%OMESH(NOM)
 
   RNODE = NOM-1
   TAG   = TAGS(NM,NOM,CODE)
 
   INITIALIZATION_IF: IF (CODE==0) THEN
 
      IF (NIC(NM,NOM)>0) THEN
         ALLOCATE(M3%RPKG1(NIC(NM,NOM)*(3+N_SPECIES)+1))
         ALLOCATE(M3%RPKG2(NIC(NM,NOM)*(9+N_SPECIES)+1))
         IF (PRESSURE_CORRECTION) ALLOCATE(M3%RPKG3(NIC(NM,NOM)*(6      )+1))
         ALLOCATE(M3%WRPKG((NRA*NSB+1)*NIC(NM,NOM)+1))
      ENDIF
 
      N_REQ = N_REQ+1
      CALL MPI_IRECV(M3%IJKW(1,1),12*M4%NEWC, MPI_INTEGER,RNODE,TAG,MPI_COMM_WORLD,REQ(N_REQ),IERR)
 
      IF (NIC(NM,NOM)>0 .OR. NIC(NOM,NM)>0) THEN
         ALLOCATE(M3%R_RDBUF(13*N_DROP_ADOPT_MAX))
         ALLOCATE(M3%R_IDBUF( 2*N_DROP_ADOPT_MAX))
         ALLOCATE(M3%R_LDBUF(   N_DROP_ADOPT_MAX))
      ENDIF
 
   ENDIF INITIALIZATION_IF
 
   PREDICTOR: IF (CODE==1 .AND. NIC(NM,NOM)>0) THEN
      N_REQ = N_REQ+1
      CALL MPI_IRECV(M3%RPKG1(1),NIC(NM,NOM)*(3+N_SPECIES)+1, MPI_DOUBLE_PRECISION,RNODE,TAG,MPI_COMM_WORLD, REQ(N_REQ),IERR)
   ENDIF PREDICTOR
 
   CORRECTOR: IF (CODE==0 .OR. CODE==2) THEN
 
      N_REQ = N_REQ+1
      CALL MPI_IRECV(M3%BOUNDARY_TYPE(0),M4%NEWC+1, MPI_INTEGER,RNODE,TAG,MPI_COMM_WORLD, REQ(N_REQ),IERR)
 
      IF (CODE==2 .AND. NIC(NM,NOM)>0) THEN
         N_REQ=N_REQ+1
         CALL MPI_IRECV(M3%RPKG2(1),NIC(NM,NOM)*(9+N_SPECIES)+1, MPI_DOUBLE_PRECISION,RNODE,TAG,MPI_COMM_WORLD, REQ(N_REQ),IERR)
      ENDIF
      IF (EXCHANGE_RADIATION .AND. NIC(NM,NOM)>0 .AND. CODE==2) THEN
         IWW = NIC(NM,NOM)
         N_REQ=N_REQ+1
         CALL MPI_IRECV(M3%WRPKG(1),(NRA*NSB+1)*IWW+1, MPI_DOUBLE_PRECISION,RNODE,TAG,MPI_COMM_WORLD, REQ(N_REQ),IERR)
      ENDIF
 
   ENDIF CORRECTOR
 
   ! Droplet Orphan Numbers
 
   IF (DROPLET_FILE .AND.  (NIC(NM,NOM)>0 .OR. NIC(NOM,NM)>0)) THEN
      N_REQ=N_REQ+1
      CALL MPI_IRECV(M3%N_DROP_ADOPT, 1,MPI_INTEGER,RNODE,TAG,MPI_COMM_WORLD, REQ(N_REQ),IERR)
   ENDIF
 
   ! Droplet Buffer Arrays

   IF (DROPLET_FILE .AND. (NIC(NM,NOM)>0 .OR. NIC(NOM,NM)>0)) THEN
      BUFFER_SIZE=13*N_DROP_ADOPT_MAX
      N_REQ=N_REQ+1
      CALL MPI_IRECV(M3%R_RDBUF(1),BUFFER_SIZE, MPI_DOUBLE_PRECISION,RNODE,TAG,MPI_COMM_WORLD, REQ(N_REQ),IERR)
      BUFFER_SIZE=2*N_DROP_ADOPT_MAX
      N_REQ=N_REQ+1
      CALL MPI_IRECV(M3%R_IDBUF(1),BUFFER_SIZE, MPI_INTEGER,RNODE,TAG,MPI_COMM_WORLD, REQ(N_REQ),IERR)
      BUFFER_SIZE=N_DROP_ADOPT_MAX
      N_REQ=N_REQ+1
      CALL MPI_IRECV(M3%R_LDBUF(1),BUFFER_SIZE, MPI_LOGICAL,RNODE,TAG,MPI_COMM_WORLD, REQ(N_REQ),IERR)
   ENDIF
 
ENDDO OTHER_MESH_LOOP
 
END SUBROUTINE POST_RECEIVES
 
 
 
SUBROUTINE MESH_EXCHANGE(CODE)
USE RADCONS, ONLY: NRA,NSB
 
! Exchange Information between Meshes
 
REAL(EB) :: TNOW
INTEGER, INTENT(IN) :: CODE
INTEGER NM,II,JJ,KK,LL,NC,N,NN,SNODE
INTEGER :: NN1,NN2
 
TNOW = SECOND()
 
! Send Information to other meshes
 
NM = MYID+1
 
SEND_OTHER_MESH_LOOP: DO NOM=1,NMESHES
 
   IF (NIC(NOM,NM)==0 .AND. NIC(NM,NOM)==0)  CYCLE SEND_OTHER_MESH_LOOP
 
   IF (CODE>0) THEN
      IF (.NOT.ACTIVE_MESH(NM) .OR. .NOT.ACTIVE_MESH(NOM))  CYCLE SEND_OTHER_MESH_LOOP
   ENDIF
 
   IF (DEBUG) THEN
      WRITE(0,*) NM,' sending data to ',NOM,' code=',CODE, ' tag=',TAGS(NM,NOM,CODE)
   ENDIF
 
   M =>MESHES(NM)
   M3=>MESHES(NM)%OMESH(NOM)
   M4=>MESHES(NOM)
 
   SNODE = NOM-1
   RNODE = NM-1
 
   TAG = TAGS(NM,NOM,CODE)
 
   INITIALIZE_SEND_IF: IF (CODE==0) THEN
 
      IF (NIC(NOM,NM)>0) THEN
         ALLOCATE(M3%SPKG1(NIC(NOM,NM)*(3+N_SPECIES)+1))
         ALLOCATE(M3%SPKG2(NIC(NOM,NM)*(9+N_SPECIES)+1))
         ALLOCATE(M3%SPKG3(NIC(NOM,NM)*(6      )+1))
      ENDIF
 
      N_REQ=N_REQ+1
      CALL MPI_ISEND(M%IJKW(1,1),12*M%NEWC, MPI_INTEGER,SNODE,TAG,MPI_COMM_WORLD,REQ(N_REQ),IERR)
 
      IF (NIC(NOM,NM)>0)  ALLOCATE(M3%WSPKG((NRA*NSB+1)*NIC(NOM,NM)+1))
 
      IF (DROPLET_FILE .AND.  (NIC(NOM,NM)>0 .OR. NIC(NM,NOM)>0)) THEN
         ALLOCATE(M3%S_RDBUF(13*N_DROP_ADOPT_MAX))
         ALLOCATE(M3%S_IDBUF( 2*N_DROP_ADOPT_MAX))
         ALLOCATE(M3%S_LDBUF(   N_DROP_ADOPT_MAX))
      ENDIF
 
   ENDIF INITIALIZE_SEND_IF
 
   SEND_PREDICTOR_IF: IF (CODE==1) THEN
 
      IF (NIC(NOM,NM)>0) THEN
         LL = 0
         IWW = 0
         PACK_SPKG1: DO IW=1,M4%NEWC
            IF (M3%IJKW(9,IW)/=NM .OR. M3%BOUNDARY_TYPE(IW)/=INTERPOLATED_BOUNDARY) CYCLE PACK_SPKG1
            IWW = IWW + 1
            II = M3%IJKW(10,IW)
            JJ = M3%IJKW(11,IW)
            KK = M3%IJKW(12,IW)
            M3%SPKG1(LL+1) = REAL(IW,EB)
            M3%SPKG1(LL+2) = M%TMP(II,JJ,KK)
            M3%SPKG1(LL+3) = M%H(II,JJ,KK)
            IF (N_SPECIES>0) M3%SPKG1(LL+4:LL+3+N_SPECIES) = M%YYS(II,JJ,KK,1:N_SPECIES)
            LL = LL+3+N_SPECIES
         ENDDO PACK_SPKG1
         M3%SPKG1(IWW*(3+N_SPECIES)+1) = -999.0_EB
         N_REQ=N_REQ+1
         CALL MPI_ISEND(M3%SPKG1(1),IWW*(3+N_SPECIES)+1, MPI_DOUBLE_PRECISION,SNODE,TAG,MPI_COMM_WORLD, REQ(N_REQ),IERR)
      ENDIF
 
   ENDIF SEND_PREDICTOR_IF
 
   SEND_CORRECTOR_IF: IF (CODE==0 .OR. CODE==2) THEN
 
      N_REQ=N_REQ+1
      CALL MPI_ISEND(M%BOUNDARY_TYPE(0),M%NEWC+1, MPI_INTEGER,SNODE,TAG,MPI_COMM_WORLD, REQ(N_REQ),IERR)
 
      IF (CODE==2 .AND. NIC(NOM,NM)>0) THEN
         LL = 0
         IWW = 0
         PACK_SPKG2: DO IW=1,M4%NEWC
            IF (M3%IJKW(9,IW)/=NM .OR. M3%BOUNDARY_TYPE(IW)/=INTERPOLATED_BOUNDARY) CYCLE PACK_SPKG2
            IWW = IWW + 1
            II = M3%IJKW(10,IW)
            JJ = M3%IJKW(11,IW)
            KK = M3%IJKW(12,IW)
            M3%SPKG2(LL+1) = REAL(IW,EB)
            M3%SPKG2(LL+2) = M%TMP(II,JJ,KK)
            M3%SPKG2(LL+3) = M%H(II,JJ,KK)
            M3%SPKG2(LL+4) = M%U(II,JJ,KK)
            M3%SPKG2(LL+5) = M%V(II,JJ,KK)
            M3%SPKG2(LL+6) = M%W(II,JJ,KK)
            M3%SPKG2(LL+7) = M%U(II-1,JJ,KK)
            M3%SPKG2(LL+8) = M%V(II,JJ-1,KK)
            M3%SPKG2(LL+9) = M%W(II,JJ,KK-1)
            IF (N_SPECIES>0) M3%SPKG2(LL+10:LL+9+N_SPECIES) = M%YY(II,JJ,KK,1:N_SPECIES)
            LL = LL+9+N_SPECIES
         ENDDO PACK_SPKG2
         M3%SPKG2(IWW*(9+N_SPECIES)+1) = -999.0_EB
         N_REQ=N_REQ+1
         CALL MPI_ISEND(M3%SPKG2(1),IWW*(9+N_SPECIES)+1, MPI_DOUBLE_PRECISION,SNODE,TAG,MPI_COMM_WORLD, REQ(N_REQ),IERR)
      ENDIF
 
      SEND_RADIATION: IF ( NIC(NOM,NM)>0 .AND. EXCHANGE_RADIATION .AND. CODE==2) THEN
         IWW=0
         LL =0
         PACK_WSPKG: DO IW=1,M4%NEWC
            IF (M3%IJKW(9,IW)/=NM .OR. M3%BOUNDARY_TYPE(IW)/=INTERPOLATED_BOUNDARY) CYCLE PACK_WSPKG
            IWW = IWW+1
            LL  = LL +1
            M3%WSPKG(LL) = REAL(IW,EB)
            DO NN2=1,NSB
               DO NN1=1,NRA
                  LL = LL + 1
                  M3%WSPKG(LL) = M3%WALL(IW)%ILW(NN1,NN2)
               ENDDO
            ENDDO
         ENDDO PACK_WSPKG
         M3%WSPKG(LL+1) = -999.0_EB
         N_REQ=N_REQ+1
         CALL MPI_ISEND(M3%WSPKG(1),(NRA*NSB+1)*IWW+1, MPI_DOUBLE_PRECISION,SNODE,TAG,MPI_COMM_WORLD, REQ(N_REQ),IERR)
      ENDIF SEND_RADIATION
 
   ENDIF SEND_CORRECTOR_IF
 
   ! Get Number of Droplet Orphans
 
   IF (DROPLET_FILE) THEN
      N_REQ=N_REQ+1
      CALL MPI_ISEND(M3%N_DROP_ORPHANS, 1,MPI_INTEGER,SNODE,TAG,MPI_COMM_WORLD,REQ(N_REQ),IERR)
   ENDIF
 
   ! Sending/Receiving Droplet Buffer Arrays
 
   IF_SEND_DROPLETS: IF (DROPLET_FILE) THEN 
 
      NC = 13
      DO N=1,MIN(M3%N_DROP_ORPHANS,N_DROP_ADOPT_MAX)
         M3%S_RDBUF((N-1)*NC+1)  = M3%DROPLET(N)%X
         M3%S_RDBUF((N-1)*NC+2)  = M3%DROPLET(N)%Y
         M3%S_RDBUF((N-1)*NC+3)  = M3%DROPLET(N)%Z
         M3%S_RDBUF((N-1)*NC+4)  = M3%DROPLET(N)%TMP
         M3%S_RDBUF((N-1)*NC+5)  = M3%DROPLET(N)%U
         M3%S_RDBUF((N-1)*NC+6)  = M3%DROPLET(N)%V
         M3%S_RDBUF((N-1)*NC+7)  = M3%DROPLET(N)%W
         M3%S_RDBUF((N-1)*NC+8)  = M3%DROPLET(N)%R
         M3%S_RDBUF((N-1)*NC+9)  = M3%DROPLET(N)%PWT
         M3%S_RDBUF((N-1)*NC+10) = M3%DROPLET(N)%A_X
         M3%S_RDBUF((N-1)*NC+11) = M3%DROPLET(N)%A_Y
         M3%S_RDBUF((N-1)*NC+12) = M3%DROPLET(N)%A_Z
         M3%S_RDBUF((N-1)*NC+13) = M3%DROPLET(N)%T
      ENDDO
      BUFFER_SIZE = NC*MIN(M3%N_DROP_ORPHANS,N_DROP_ADOPT_MAX)
      BUFFER_SIZE = MAX(1,BUFFER_SIZE)
      N_REQ=N_REQ+1
      CALL MPI_ISEND(M3%S_RDBUF(1),BUFFER_SIZE, MPI_DOUBLE_PRECISION,SNODE,TAG,MPI_COMM_WORLD, REQ(N_REQ),IERR)
 
      NC = 2
      DO N=1,MIN(M3%N_DROP_ORPHANS,N_DROP_ADOPT_MAX)
         M3%S_IDBUF((N-1)*NC+1) = M3%DROPLET(N)%IOR
         M3%S_IDBUF((N-1)*NC+2) = M3%DROPLET(N)%CLASS
      ENDDO
      BUFFER_SIZE = NC*MIN(M3%N_DROP_ORPHANS,N_DROP_ADOPT_MAX)
      BUFFER_SIZE = MAX(1,BUFFER_SIZE)
      N_REQ=N_REQ+1
      CALL MPI_ISEND(M3%S_IDBUF(1),BUFFER_SIZE, MPI_INTEGER,SNODE,TAG,MPI_COMM_WORLD,REQ(N_REQ),IERR)
 
      NC = 1
      DO N=1,MIN(M3%N_DROP_ORPHANS,N_DROP_ADOPT_MAX)
         M3%S_LDBUF((N-1)*NC+1) = M3%DROPLET(N)%SHOW
      ENDDO
      BUFFER_SIZE = NC*MIN(M3%N_DROP_ORPHANS,N_DROP_ADOPT_MAX)
      BUFFER_SIZE = MAX(1,BUFFER_SIZE)
      N_REQ=N_REQ+1
      CALL MPI_ISEND(M3%S_LDBUF(1),BUFFER_SIZE, MPI_LOGICAL,SNODE,TAG,MPI_COMM_WORLD,REQ(N_REQ),IERR)
 
      M3%N_DROP_ORPHANS = 0
 
   ENDIF IF_SEND_DROPLETS
 
ENDDO SEND_OTHER_MESH_LOOP
 
! Receive Messages (NOM is the receiver, NM is the sender)
 
CALL MPI_WAITALL(N_REQ,REQ(1:N_REQ),ARRAY_OF_STATUSES,IERR)
 
NOM = MYID+1
 
MESH_LOOP: DO NM=1,NMESHES
 
   IF (NIC(NOM,NM)==0 .AND. NIC(NM,NOM)==0) CYCLE MESH_LOOP
 
   IF (CODE>0) THEN
      IF (.NOT.ACTIVE_MESH(NM) .OR. .NOT.ACTIVE_MESH(NOM))  CYCLE MESH_LOOP
   ENDIF
 
   IF (DEBUG) THEN
      WRITE(0,*) NOM,' receiving data from ',NM, ' code=',CODE,' tag=',TAGS(NM,NOM,CODE)
   ENDIF
 
   M =>MESHES(NM)
   M2=>MESHES(NOM)%OMESH(NM)
   M4=>MESHES(NOM)
 
   SNODE = NOM-1
   RNODE = NM-1
 
   TAG = TAGS(NM,NOM,CODE)
 
   INITIALIZE_RECEIVE_IF: IF (CODE==0 .AND. RADIATION) THEN
      DO IW=1,M%NEWC
         IF (M2%IJKW(9,IW)==NOM) THEN
            ALLOCATE(M2%WALL(IW)%ILW(NRA,NSB))
            M2%WALL(IW)%ILW = SIGMA*TMPA4*RPI
         ENDIF
      ENDDO
   ENDIF INITIALIZE_RECEIVE_IF
 
   RECEIVE_PREDICTOR_IF: IF (CODE==1) THEN
      IF (NIC(NOM,NM)>0) THEN
         LL = 0
         UNPACK_RPKG1: DO 
            IW = NINT(M2%RPKG1(LL+1))
            IF (IW==-999) EXIT UNPACK_RPKG1
            II = M4%IJKW(10,IW)
            JJ = M4%IJKW(11,IW)
            KK = M4%IJKW(12,IW)
            M2%TMP(II,JJ,KK) = M2%RPKG1(LL+2)
            M2%H(II,JJ,KK)   = M2%RPKG1(LL+3)
            IF (N_SPECIES>0) M2%YYS(II,JJ,KK,1:N_SPECIES)= M2%RPKG1(LL+4:LL+3+N_SPECIES)
            LL = LL+3+N_SPECIES
         ENDDO UNPACK_RPKG1
      ENDIF
   ENDIF RECEIVE_PREDICTOR_IF
 
   RECEIVE_CORRECTOR_IF: IF (CODE==0 .OR. CODE==2) THEN
 
      IF (CODE==2 .AND. NIC(NOM,NM)>0) THEN
         LL = 0
         UNPACK_RPKG2: DO 
            IW = NINT(M2%RPKG2(LL+1))
            IF (IW==-999) EXIT UNPACK_RPKG2
            II = M4%IJKW(10,IW)
            JJ = M4%IJKW(11,IW)
            KK = M4%IJKW(12,IW)
            M2%TMP(II,JJ,KK) = M2%RPKG2(LL+2)
            M2%H(II,JJ,KK)   = M2%RPKG2(LL+3)
            M2%U(II,JJ,KK)   = M2%RPKG2(LL+4)
            M2%V(II,JJ,KK)   = M2%RPKG2(LL+5)
            M2%W(II,JJ,KK)   = M2%RPKG2(LL+6)
            M2%U(II-1,JJ,KK) = M2%RPKG2(LL+7)
            M2%V(II,JJ-1,KK) = M2%RPKG2(LL+8)
            M2%W(II,JJ,KK-1) = M2%RPKG2(LL+9)
            IF (N_SPECIES>0) M2%YY(II,JJ,KK,1:N_SPECIES)= M2%RPKG2(LL+10:LL+9+N_SPECIES)
            LL = LL+9+N_SPECIES
         ENDDO UNPACK_RPKG2
      ENDIF
 
      RECEIVE_RADIATION: IF ( NIC(NOM,NM)>0 .AND. EXCHANGE_RADIATION  .AND. CODE==2) THEN
         LL =0
         UNPACK_WRPKG: DO 
            LL  = LL + 1
            IW = NINT(M2%WRPKG(LL))
            IF (IW==-999) EXIT UNPACK_WRPKG
            DO NN2=1,NSB
               DO NN1=1,NRA
                  LL = LL + 1
                  M4%WALL(IW)%ILW(NN1,NN2) = M2%WRPKG(LL)
               ENDDO
            ENDDO
         ENDDO UNPACK_WRPKG
      ENDIF RECEIVE_RADIATION
 
   ENDIF RECEIVE_CORRECTOR_IF
 
   ! Get Number of Droplet Orphans
 
   IF (DROPLET_FILE) THEN
      M2%N_DROP_ADOPT = MIN(M2%N_DROP_ADOPT,N_DROP_ADOPT_MAX)
      IF (M4%NLP+M2%N_DROP_ADOPT>M4%NLPDIM) THEN
         CALL RE_ALLOCATE_DROPLETS(1,NOM,0)
      ENDIF
   ENDIF
 
   ! Sending/Receiving Droplet Buffer Arrays
 
   IF_RECEIVE_DROPLETS: IF (DROPLET_FILE) THEN 
 
      IF_NO_DROPLETS_SENT: IF (M2%N_DROP_ADOPT==0) THEN
 
      ELSE
 
         NC = 13
         DO N=M4%NLP+1,M4%NLP+M2%N_DROP_ADOPT
            NN = N-M4%NLP-1
            M4%DROPLET(N)%X   = M2%R_RDBUF((NN)*NC+1) 
            M4%DROPLET(N)%Y   = M2%R_RDBUF((NN)*NC+2) 
            M4%DROPLET(N)%Z   = M2%R_RDBUF((NN)*NC+3) 
            M4%DROPLET(N)%TMP = M2%R_RDBUF((NN)*NC+4) 
            M4%DROPLET(N)%U   = M2%R_RDBUF((NN)*NC+5) 
            M4%DROPLET(N)%V   = M2%R_RDBUF((NN)*NC+6) 
            M4%DROPLET(N)%W   = M2%R_RDBUF((NN)*NC+7) 
            M4%DROPLET(N)%R   = M2%R_RDBUF((NN)*NC+8) 
            M4%DROPLET(N)%PWT = M2%R_RDBUF((NN)*NC+9) 
            M4%DROPLET(N)%A_X = M2%R_RDBUF((NN)*NC+10) 
            M4%DROPLET(N)%A_Y = M2%R_RDBUF((NN)*NC+11) 
            M4%DROPLET(N)%A_Z = M2%R_RDBUF((NN)*NC+12) 
            M4%DROPLET(N)%T   = M2%R_RDBUF((NN)*NC+13) 
         ENDDO
 
         NC = 2
         DO N=M4%NLP+1,M4%NLP+M2%N_DROP_ADOPT
            NN = N-M4%NLP-1
            M4%DROPLET(N)%IOR    = M2%R_IDBUF((NN)*NC+1) 
            M4%DROPLET(N)%CLASS  = M2%R_IDBUF((NN)*NC+2) 
         ENDDO
 
         NC = 1
         DO N=M4%NLP+1,M4%NLP+M2%N_DROP_ADOPT
            NN = N-M4%NLP-1
            M4%DROPLET(N)%SHOW = M2%R_LDBUF((NN)*NC+1)  
         ENDDO
 
         M4%NLP = M4%NLP + M2%N_DROP_ADOPT
 
      ENDIF IF_NO_DROPLETS_SENT
   ENDIF IF_RECEIVE_DROPLETS
 
ENDDO MESH_LOOP
 
TUSED(11,:)=TUSED(11,:) + SECOND() - TNOW
END SUBROUTINE MESH_EXCHANGE
 
 

SUBROUTINE WRITE_STRINGS
 
! Write character strings out to the .smv file
 
INTEGER :: N,NOM,N_STRINGS_DUM
CHARACTER(50), ALLOCATABLE, DIMENSION(:) :: STRING_DUM
 
! All meshes send their STRINGs to node 0
 
IF (MYID>0) THEN
   CALL MPI_SEND(MESHES(MYID+1)%N_STRINGS,1,MPI_INTEGER, 0,1,MPI_COMM_WORLD,IERR)
   IF (MESHES(MYID+1)%N_STRINGS>0)  CALL MPI_SEND(MESHES(MYID+1)%STRING(1),MESHES(MYID+1)%N_STRINGS*50, &
       MPI_CHARACTER,0,MYID,MPI_COMM_WORLD,IERR)
ENDIF
 
! Node 0 receives the STRINGs and writes them to the .smv file
 
IF (MYID==0) THEN
   DO N=1,MESHES(1)%N_STRINGS
      WRITE(LU_SMV,'(A)') TRIM(MESHES(1)%STRING(N))
   ENDDO
   OTHER_MESH_LOOP: DO NOM=2,NMESHES 
      CALL MPI_RECV(N_STRINGS_DUM,1,MPI_INTEGER, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      IF (N_STRINGS_DUM>0) THEN
         ALLOCATE(STRING_DUM(N_STRINGS_DUM))
         CALL MPI_RECV(STRING_DUM(1),N_STRINGS_DUM*50, MPI_CHARACTER,NOM-1,NOM-1, MPI_COMM_WORLD,STATUS,IERR)
         DO N=1,N_STRINGS_DUM
            WRITE(LU_SMV,'(A)') TRIM(STRING_DUM(N))
         ENDDO
         DEALLOCATE(STRING_DUM)
      ENDIF
   ENDDO OTHER_MESH_LOOP
ENDIF
 
! All STRING arrays are zeroed out
 
MESHES(MYID+1)%N_STRINGS = 0
 
END SUBROUTINE WRITE_STRINGS
 
 

SUBROUTINE EXCHANGE_DIAGNOSTICS
 
INTEGER  :: NOM,NM,NECYC
REAL(EB) :: T_SUM, TNOW
 
TNOW = SECOND()
NM = MYID+1

T_SUM = 0.
SUM_LOOP: DO I=2,N_TIMERS
   IF (I==9 .OR. I==10) CYCLE SUM_LOOP
   T_SUM = T_SUM + TUSED(I,NM)
ENDDO SUM_LOOP
 
NECYC          = MAX(1,NTCYC(NM)-NCYC(NM))
T_PER_STEP(NM) = (T_SUM-T_ACCUM(NM))/REAL(NECYC,EB)
T_ACCUM(NM)    = T_SUM
NCYC(NM)       = NTCYC(NM)
 
CALL MPI_GATHER(T_ACCUM(MYID+1),1,MPI_DOUBLE_PRECISION, T_ACCUM,1,MPI_DOUBLE_PRECISION,0, MPI_COMM_WORLD,IERR)
CALL MPI_GATHER(T_PER_STEP(MYID+1),1,MPI_DOUBLE_PRECISION, T_PER_STEP,1,MPI_DOUBLE_PRECISION,0, MPI_COMM_WORLD,IERR)
CALL MPI_GATHER(NTCYC(MYID+1),1,MPI_INTEGER, NTCYC,1,MPI_INTEGER,0, MPI_COMM_WORLD,IERR)
CALL MPI_GATHER(HRR(MYID+1),1,MPI_DOUBLE_PRECISION, HRR,1,MPI_DOUBLE_PRECISION,0, MPI_COMM_WORLD,IERR)
CALL MPI_GATHER(RHRR(MYID+1),1,MPI_DOUBLE_PRECISION, RHRR,1,MPI_DOUBLE_PRECISION,0, MPI_COMM_WORLD,IERR)
 
IF (MYID>0) THEN
 
   CALL MPI_SEND(MESHES(MYID+1)%DT,1,MPI_DOUBLE_PRECISION, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%CFL,1,MPI_DOUBLE_PRECISION, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%DIVMX,1,MPI_DOUBLE_PRECISION, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%DIVMN,1,MPI_DOUBLE_PRECISION, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%RESMAX,1,MPI_DOUBLE_PRECISION, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%POIS_PTB,1,MPI_DOUBLE_PRECISION, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%POIS_ERR,1,MPI_DOUBLE_PRECISION, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%VN,1,MPI_DOUBLE_PRECISION, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%ICFL,1,MPI_INTEGER, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%JCFL,1,MPI_INTEGER, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%KCFL,1,MPI_INTEGER, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%IMX,1,MPI_INTEGER, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%JMX,1,MPI_INTEGER, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%KMX,1,MPI_INTEGER, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%IMN,1,MPI_INTEGER, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%JMN,1,MPI_INTEGER, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%KMN,1,MPI_INTEGER, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%IRM,1,MPI_INTEGER, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%JRM,1,MPI_INTEGER, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%KRM,1,MPI_INTEGER, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%I_VN,1,MPI_INTEGER, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%J_VN,1,MPI_INTEGER, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%K_VN,1,MPI_INTEGER, 0,1,MPI_COMM_WORLD,IERR)
   CALL MPI_SEND(MESHES(MYID+1)%NLP,1,MPI_INTEGER, 0,1,MPI_COMM_WORLD,IERR)

ELSE 

   DO NOM=2,NMESHES
      CALL MPI_RECV(MESHES(NOM)%DT,1,MPI_DOUBLE_PRECISION, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%CFL,1,MPI_DOUBLE_PRECISION, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%DIVMX,1,MPI_DOUBLE_PRECISION, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%DIVMN,1,MPI_DOUBLE_PRECISION, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%RESMAX,1,MPI_DOUBLE_PRECISION, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%POIS_PTB,1,MPI_DOUBLE_PRECISION, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%POIS_ERR,1,MPI_DOUBLE_PRECISION, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%VN,1,MPI_DOUBLE_PRECISION, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%ICFL,1,MPI_INTEGER, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%JCFL,1,MPI_INTEGER, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%KCFL,1,MPI_INTEGER, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%IMX,1,MPI_INTEGER, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%JMX,1,MPI_INTEGER, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%KMX,1,MPI_INTEGER, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%IMN,1,MPI_INTEGER, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%JMN,1,MPI_INTEGER, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%KMN,1,MPI_INTEGER, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%IRM,1,MPI_INTEGER, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%JRM,1,MPI_INTEGER, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%KRM,1,MPI_INTEGER, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%I_VN,1,MPI_INTEGER, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%J_VN,1,MPI_INTEGER, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%K_VN,1,MPI_INTEGER, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(MESHES(NOM)%NLP,1,MPI_INTEGER, NOM-1,1,MPI_COMM_WORLD,STATUS,IERR)
   ENDDO
 
ENDIF
 
TUSED(11,:) = TUSED(11,:) + SECOND() - TNOW
END SUBROUTINE EXCHANGE_DIAGNOSTICS


SUBROUTINE CORRECT_PRESSURE(CODE) !!!! Experimental Code, DO NOT USE

REAL(EB), DIMENSION(NMESHES*4,NMESHES*4) :: A,A_LOC
REAL(EB), DIMENSION(NMESHES*4) :: B,B_LOC
TYPE (MESH_TYPE), POINTER :: M
TYPE (OMESH_TYPE), POINTER :: OM,M3
INTEGER :: IERROR,NM,SNODE,RNODE,LL,II,JJ,KK,CODE,I,J,K,IOR
LOGICAL :: FLAG

! Post Receives for arrays containing Pressure boundary info

N_PREQ = 0
NM = MYID+1

OTHER_MESH_LOOP: DO NOM=1,NMESHES

   IF (NIC(NM,NOM)==0 .AND. NIC(NOM,NM)==0) CYCLE OTHER_MESH_LOOP
   IF (.NOT.ACTIVE_MESH(NOM)) CYCLE OTHER_MESH_LOOP

   IF (DEBUG) THEN
      WRITE(0,*) NM,' posting pressure receives from ',NOM,' code=',code
      IF (CODE==0) WRITE(0,'(A,I2,A,I2,A,I5)') 'NIC(',NM,',',NOM,')=',NIC(NM,NOM)
   ENDIF

   M =>MESHES(NM)
   M3=>MESHES(NM)%OMESH(NOM)

   RNODE = NOM-1
   TAG   = TAGS(NM,NOM,CODE)

   N_PREQ = N_PREQ+1
   CALL MPI_IRECV(M3%RPKG3(1),NIC(NM,NOM)*6+1, MPI_DOUBLE_PRECISION,RNODE,TAG,MPI_COMM_WORLD, PREQ(N_PREQ),IERR)

ENDDO OTHER_MESH_LOOP

! Exchange boundary values of H and FVX, FVY, FVZ

SEND_OTHER_MESH_LOOP: DO NOM=1,NMESHES

   IF (NIC(NOM,NM)==0 .AND. NIC(NM,NOM)==0) CYCLE SEND_OTHER_MESH_LOOP

   M =>MESHES(NM)
   M3=>MESHES(NM)%OMESH(NOM)
   M4=>MESHES(NOM)

   SNODE = NOM-1
   RNODE = NM-1

   TAG = TAGS(NM,NOM,CODE)

   LL = 0
   IWW = 0
   PACK_SPKG3: DO IW=1,M4%NEWC
      IF (M3%IJKW(9,IW)/=NM .OR. M3%BOUNDARY_TYPE(IW)/=INTERPOLATED_BOUNDARY) CYCLE PACK_SPKG3
      IWW = IWW + 1
      II = M3%IJKW(10,IW)
      JJ = M3%IJKW(11,IW)
      KK = M3%IJKW(12,IW)
      IOR = M3%IJKW(4,IW)
      M3%SPKG3(LL+1) = REAL(IW,EB)
      M3%SPKG3(LL+2) = M%H(II,JJ,KK)
      SELECT CASE(IOR)
         CASE(-1) 
            M3%SPKG3(LL+3) = M%H(II-1,JJ,KK)
            M3%SPKG3(LL+4) = M%FVX(II-1,JJ,KK)
         CASE( 1) 
            M3%SPKG3(LL+3) = M%H(II+1,JJ,KK)
            M3%SPKG3(LL+4) = M%FVX(II,JJ,KK)
         CASE(-2) 
            M3%SPKG3(LL+3) = M%H(II,JJ-1,KK)
            M3%SPKG3(LL+5) = M%FVY(II,JJ-1,KK)
         CASE( 2) 
            M3%SPKG3(LL+3) = M%H(II,JJ+1,KK)
            M3%SPKG3(LL+5) = M%FVY(II,JJ,KK)
         CASE(-3) 
            M3%SPKG3(LL+3) = M%H(II,JJ,KK-1)
            M3%SPKG3(LL+6) = M%FVZ(II,JJ,KK-1)
         CASE( 3) 
            M3%SPKG3(LL+3) = M%H(II,JJ,KK+1)
            M3%SPKG3(LL+6) = M%FVZ(II,JJ,KK)
      END SELECT
      LL = LL+6
   ENDDO PACK_SPKG3
   M3%SPKG3(IWW*6+1) = -999.0_EB
   N_PREQ=N_PREQ+1
   CALL MPI_ISEND(M3%SPKG3(1),IWW*6+1, MPI_DOUBLE_PRECISION,SNODE,TAG,MPI_COMM_WORLD, PREQ(N_PREQ),IERR)

   IF (DEBUG) THEN
      WRITE(0,*) NM,' sending P data to ',NOM, ' tag=',TAGS(NM,NOM,CODE),' PREQ=',PREQ(N_PREQ)
   ENDIF

ENDDO SEND_OTHER_MESH_LOOP

CALL MPI_WAITALL(N_PREQ,PREQ(1:N_PREQ),ARRAY_OF_STATUSES2,IERR)

NOM = MYID+1

RECEIVE_OTHER_MESH_LOOP: DO NM=1,NMESHES

IF (NIC(NOM,NM)==0 .AND. NIC(NM,NOM)==0)  CYCLE RECEIVE_OTHER_MESH_LOOP

M =>MESHES(NM)
M2=>MESHES(NOM)%OMESH(NM)
M4=>MESHES(NOM)

SNODE = NOM-1
RNODE = NM-1
TAG = TAGS(NM,NOM,CODE)

LL = 0
UNPACK_RPKG3: DO
   IW = NINT(M2%RPKG3(LL+1))
   IF (IW==-999) EXIT UNPACK_RPKG3
   II = M4%IJKW(10,IW)
   JJ = M4%IJKW(11,IW)
   KK = M4%IJKW(12,IW)
   IOR = M4%IJKW(4,IW)
   M2%H(II,JJ,KK)                = M2%RPKG3(LL+2)
   SELECT CASE(IOR)
      CASE(-1) 
         M2%H(II-1,JJ,KK)   = M2%RPKG3(LL+3)
         M2%FVX(II-1,JJ,KK) = M2%RPKG3(LL+4)
      CASE( 1) 
         M2%H(II+1,JJ,KK)   = M2%RPKG3(LL+3)
         M2%FVX(II,JJ,KK)   = M2%RPKG3(LL+4)
      CASE(-2) 
         M2%H(II,JJ-1,KK)   = M2%RPKG3(LL+3)
         M2%FVY(II,JJ-1,KK) = M2%RPKG3(LL+5)
      CASE( 2) 
         M2%H(II,JJ+1,KK)   = M2%RPKG3(LL+3)
         M2%FVY(II,JJ,KK)   = M2%RPKG3(LL+5)
      CASE(-3) 
         M2%H(II,JJ,KK-1)   = M2%RPKG3(LL+3)
         M2%FVZ(II,JJ,KK-1) = M2%RPKG3(LL+6)
      CASE( 3) 
         M2%H(II,JJ,KK+1)   = M2%RPKG3(LL+3)
         M2%FVZ(II,JJ,KK)   = M2%RPKG3(LL+6)
   END SELECT
   LL = LL+6
ENDDO UNPACK_RPKG3

ENDDO RECEIVE_OTHER_MESH_LOOP

! Construct "correction matrix" A

A = 0.
B = 0.
A_LOC = 0.
B_LOC = 0.

MESH_LOOP_1: DO NM=MYID+1,NMESHES,NUMPROCS
   CALL COMPUTE_A_B(A_LOC,B_LOC,NM)
ENDDO MESH_LOOP_1

CALL MPI_ALLREDUCE(A_LOC(1,1),A(1,1),(NMESHES*4)**2, MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,IERR)
CALL MPI_ALLREDUCE(B_LOC(1),B(1),(NMESHES*4), MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,IERR)

IF (MYID==0) THEN
   DO I=1,4*NMESHES
      WRITE(0,'(16F7.1,3X,F7.1)') (A(I,J),J=1,4*NMESHES),B(I)
   ENDDO
ENDIF

CALL GAUSSJ(A,NMESHES*4,NMESHES*4,B,1,1,IERROR)

IF (MYID==0) THEN
   IF (IERROR>0) WRITE(0,*) ' IERROR= ',IERROR
   WRITE(0,*)
   DO I=1,4*NMESHES
      WRITE(0,'(F12.5)') B(I)
   ENDDO
   WRITE(0,*)
ENDIF

MESH_LOOP_2: DO NM=MYID+1,NMESHES,NUMPROCS
   CALL UPDATE_PRESSURE(B,NM)
ENDDO MESH_LOOP_2

END SUBROUTINE CORRECT_PRESSURE


SUBROUTINE DUMP_GLOBAL_OUTPUTS(T)

! Dump HRR data to CHID_hrr.csv, MASS data to CHID_mass.csv, DEVICE data to _devc.csv

REAL(EB) :: T
INTEGER :: N

! Dump out HRR info  after first "gathering" data to node 0

IF_DUMP_HRR: IF (T>=HRR_CLOCK) THEN
   CALL MPI_ALLGATHER(HRR_COUNT(MYID+1),1,MPI_DOUBLE_PRECISION, HRR_COUNT,1,MPI_DOUBLE_PRECISION,MPI_COMM_WORLD,IERR)
   IF (MINVAL(HRR_COUNT,MASK=.NOT.EVACUATION_ONLY)>0._EB) THEN
      CALL MPI_GATHER(HRR_SUM(MYID+1), 1, MPI_DOUBLE_PRECISION, HRR_SUM, 1,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,IERR)
      CALL MPI_GATHER(RHRR_SUM(MYID+1),1, MPI_DOUBLE_PRECISION, RHRR_SUM,1,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,IERR)
      CALL MPI_GATHER(CHRR_SUM(MYID+1),1, MPI_DOUBLE_PRECISION, CHRR_SUM,1,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,IERR)
      CALL MPI_GATHER(FHRR_SUM(MYID+1),1, MPI_DOUBLE_PRECISION, FHRR_SUM,1,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,IERR)
      CALL MPI_GATHER(MLR_SUM(MYID+1), 1, MPI_DOUBLE_PRECISION, MLR_SUM, 1,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,IERR)
      IF (MYID==0) CALL DUMP_HRR(T)
      HRR_CLOCK = HRR_CLOCK + DT_HRR
      HRR_SUM   = 0._EB
      RHRR_SUM  = 0._EB
      CHRR_SUM  = 0._EB
      FHRR_SUM  = 0._EB
      MLR_SUM   = 0._EB
      HRR_COUNT = 0._EB
   ENDIF
ENDIF IF_DUMP_HRR

!     Dump out Evac info: EVAC_TODO next lines should be
!     made to work also in the parallel code.
!
!      IF (T>=EVAC_CLOCK .AND. ANY(EVACUATION_GRID)) THEN
!        CALL DUMP_EVAC_CSV(T)
!        EVAC_CLOCK = EVAC_CLOCK + DTHRR
!      ENDIF

! Dump out Mass info after first "gathering" data to node 0

IF_DUMP_MASS: IF (T>=MINT_CLOCK) THEN
   CALL MPI_ALLGATHER(MINT_COUNT(MYID+1),1,MPI_DOUBLE_PRECISION, MINT_COUNT,1,MPI_DOUBLE_PRECISION,MPI_COMM_WORLD,IERR)
   IF (MINVAL(MINT_COUNT,MASK=.NOT.EVACUATION_ONLY)>0.) THEN
      CALL MPI_GATHER(MINT_SUM(0,MYID+1),21,MPI_DOUBLE_PRECISION, MINT_SUM,21,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD, IERR)
      IF (MYID==0) CALL DUMP_MASS(T)
      MINT_CLOCK    = MINT_CLOCK + DT_MASS
      MINT_SUM   = 0._EB
      MINT_COUNT = 0._EB
   ENDIF
ENDIF IF_DUMP_MASS

! Exchange DEVICE parameters among meshes and dump out DEVICE info after first "gathering" data to node 0
 
IF_DUMP_DEVC: IF (T>=DEVC_CLOCK .AND. N_DEVC>0) THEN
  
   ! Exchange the CURRENT_STATE of each DEViCe

   STATE_LOC(1:N_DEVC) = .FALSE.  ! _LOC is a temporary array that holds the STATE value for the devices on each node
   DO N=1,N_DEVC
      IF (DEVICE(N)%MESH==MYID+1) STATE_LOC(N) = DEVICE(N)%CURRENT_STATE 
   ENDDO
   CALL MPI_ALLREDUCE(STATE_LOC(1),STATE_GLB(1),N_DEVC,MPI_LOGICAL,MPI_LXOR,MPI_COMM_WORLD,IERR)
   DEVICE(1:N_DEVC)%CURRENT_STATE = STATE_GLB(1:N_DEVC)

   ! Exchange the INSTANT_VALUE of each DEViCe

   TC_LOC(1:N_DEVC) = 0._EB 
   DO N=1,N_DEVC
      IF (DEVICE(N)%MESH==MYID+1) TC_LOC(N) = DEVICE(N)%INSTANT_VALUE
   ENDDO
   CALL MPI_ALLREDUCE(TC_LOC(1),TC_GLB(1),N_DEVC,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,IERR)
   DEVICE(1:N_DEVC)%INSTANT_VALUE = TC_GLB(1:N_DEVC)

   ! Exchange the INSTANT_VALUE of each DEViCe

   TC_LOC(1:N_DEVC) = 0._EB
   DO N=1,N_DEVC
      IF (DEVICE(N)%MESH==MYID+1) TC_LOC(N) = DEVICE(N)%T_CHANGE
   ENDDO
   CALL MPI_ALLREDUCE(TC_LOC(1),TC_GLB(1),N_DEVC,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,IERR)
   DEVICE(1:N_DEVC)%T_CHANGE = TC_GLB(1:N_DEVC)

   ! Exchange the current COUNT of each DEViCe

   COUNT_LOC(1:N_DEVC) = DEVICE(1:N_DEVC)%COUNT
   CALL MPI_ALLREDUCE(COUNT_LOC(1),COUNT_GLB(1),N_DEVC,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,IERR)

   ! Get the current VALUEs of all DEViCes into DEVICE(:)%VALUE on node 0

   IF (MINVAL(COUNT_GLB)>0) THEN
      TC_LOC(1:N_DEVC) = DEVICE(1:N_DEVC)%VALUE 
      CALL MPI_REDUCE(TC_LOC(1),TC_GLB(1),N_DEVC,MPI_DOUBLE_PRECISION,MPI_SUM,0,MPI_COMM_WORLD,IERR)
      IF (MYID==0) THEN
         DEVICE(1:N_DEVC)%VALUE = TC_GLB(1:N_DEVC)
         DEVICE(1:N_DEVC)%COUNT = COUNT_GLB(1:N_DEVC)
         CALL DUMP_DEVICES(T)
      ENDIF
      DEVC_CLOCK = DEVC_CLOCK + DT_DEVC
      DEVICE(1:N_DEVC)%VALUE = 0._EB
      DEVICE(1:N_DEVC)%COUNT = 0
   ENDIF
ENDIF IF_DUMP_DEVC

! Dump CONTROL info. No gathering required as CONTROL is updated on all meshes

IF (T>=CTRL_CLOCK .AND. N_CTRL>0) THEN
   CALL DUMP_CONTROLS(T)
   CTRL_CLOCK = CTRL_CLOCK + DT_CTRL
ENDIF

END SUBROUTINE DUMP_GLOBAL_OUTPUTS

END PROGRAM FDS
