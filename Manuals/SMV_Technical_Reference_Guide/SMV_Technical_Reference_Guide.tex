\documentclass[11pt,twoside]{book}

%% include commands for bios, titles etc used in multiple documents
\input{../Bibliography/commoncommands}
\IfFileExists{../Bibliography/gitrevision.tex}
{\input{../Bibliography/gitrevision}}
{\newcommand{\gitrevision}{unknown} }

%\doublespace
\begin{document}

\bibliographystyle{unsrt}
\pagestyle{empty}
%
% ----------------------  first cover/title page --------------------------
%
\begin{minipage}[t][9in][s]{6.5in}

\headerA{1017-2\\Sixth Edition\\}

\vspace{1in}

\headerB{
Smokeview, A Tool for Visualizing\\
Fire Dynamics Simulation Data\\
Volume II: Technical Reference Guide\\
}
%\flushright{(Draft: \today)}

\vspace{.5in}
\headerC{Glenn P. Forney}

\vfill

\begin{flushright}
\includegraphics[width=2.in]{FIGURES/nistident_flright_vec}
\end{flushright}

\end{minipage}

\newpage

\hspace{5in}
\newpage

%
% ----------------------  second cover/title page --------------------------
%
\begin{minipage}[t][9in][s]{6.5in}

\headerA{1017-2\\Sixth Edition\\}

\vspace{1.in}

\headerB{
Smokeview, A Tool for Visualizing\\
Fire Dynamics Simulation Data\\
Volume II: Technical Reference Guide\\
}

\vspace{.5in}

\headerC{Glenn P. Forney\\
{\em Fire Research Division}\\
{\em Engineering Laboratory}\\
}

\vspace{.25in}

%\flushright{\today \\
\begin{flushright}
\today \\
Smokeview Version \smvversion \\
\emph{Git Revision:}~\gitrevision
\end{flushright}

\vfill

\begin{flushright}
\includegraphics[width=1in]{../Bibliography/doc}
\end{flushright}

\titlesigs

\end{minipage}


\date{}
%\pubnumber{xxxx}
\title{\ttitle}
\author{Glenn P. Forney}

%\pubdate{February 2001}
%\makecover{1}

\setlength{\parindent}{0.25in}

\newpage

\begin{minipage}[t][9in][s]{6.5in}

\begin{flushright}
Certain commercial entities, equipment, or materials may be identified in this \\
document in order to describe an experimental procedure or concept adequately. Such \\
identification is not intended to imply recommendation or endorsement by the \\
National Institute of Standards and Technology, nor is it intended to imply that the \\
entities, materials, or equipment are necessarily the best available for the purpose.
\end{flushright}

\vspace{3in}

\large
\begin{flushright}
\bf National Institute of Standards and Technology Special Publication 1017-2\\
Natl.~Inst.~Stand.~Technol.~Spec.~Publ.~1017-2, \pageref{LastPage} pages (June 2016) \\
CODEN: NSPUE2
\end{flushright}

\vfill

\end{minipage}


\frontmatter
\pagestyle{plain}

%
% -------------------  Preface ------------------------
%

\chapter{Preface}
\smvoverview
This guide is Volume II the Smokeview Technical Reference guide.

Smokeview is a software tool designed to visualize numerical
calculations generated by the Fire Dynamics Simulator (FDS), a
computational fluid dynamics (CFD) model of fire-driven fluid flow
and CFAST a two-zone fire model used to calculate the evolving
distribution of smoke, fire gases and temperature. This report
documents some of the algorithms Smokeview uses to visualize fire
dynamics data giving some of the technical and programming
details. Details on the use of Smokeview may be found in the
Smokeview User's Guide. Smokeview uses the 3D graphics library
OpenGL to visualizing fire and smoke data. This library is used to
specify the location, color and lighting of objects residing
within a {\em 3D world}\ defined by FDS. In the context of FDS,
these objects may be used to represent geometry (such as
blockages) or to visualize data. Smokeview presents fire modeling
data using visualization techniques such as tracer particles, 2D
shaded contours, iso-surfaces or flow vectors.  Soot data or smoke
is visualized using a variation of the 2D shaded contour technique
where transparency rather than color is used to represent the
opacity or optical thickness of smoke.  The details used to
implement various techniques for visualizing smoke are discussed.

%---------------------------------------------------------------------------------
%------------------------ About the Author ---------------------------------------
%---------------------------------------------------------------------------------

\chapter{About the Author}

\begin{description}
\gforneybio
\end{description}

%
% -------------------  Disclaimer ------------------------
%

\chapter{Disclaimer}

The US Department of Commerce makes no warranty, expressed or
implied, to users of Smokeview, and accepts no responsibility for
its use. Users of Smokeview assume sole responsibility under
Federal law for determining the appropriateness of its use in any
particular application; for any conclusions drawn from the results
of its use; and for any actions taken or not taken as a result of
analysis performed using this tools.

Smokeview and the companion program FDS is intended for use only
by those competent in the fields of fluid dynamics,
thermodynamics, combustion, and heat transfer, and is intended
only to supplement the informed judgment of the qualified user.
These software packages may or may not have predictive capability
when applied to a specific set of factual circumstances. Lack of
accurate predictions could lead to erroneous conclusions with
regard to fire safety. All results should be evaluated by an
informed user.

Throughout this document, the mention of computer hardware or
commercial software does not constitute endorsement by NIST, nor
does it indicate that the products are necessarily those best
suited for the intended purpose.

%
% -------------------  Acknowledgements ------------------------
%

%\chapter*{Acknowledgements}

%Feedback is encouraged and may be sent to glenn.forney@nist.gov .

\cleardoublepage
\tableofcontents

\cleardoublepage
\listoffigures

\mainmatter

\pagenumbering{arabic}

%
% -------------------  Introduction ------------------------
%

\chapter{Introduction}
\section{Basic Description of Smokeview}
Smokeview is a software tool designed to visualize numerical
predictions generated by the Fire Dynamics Simulator (FDS), a
computational fluid dynamics (CFD) model of fire-driven fluid
flow~\cite{FDS_Tech_Guide,FDS_Users_Guide} and CFAST a two-zone
fire model\cite{CFAST_Tech_Guide_6} used to calculate the evolving
distribution of smoke, fire gases and temperature. Most of
Smokeview is written in the C programming language using the 3D
graphics library, OpenGL~\cite{OpenGLRed}, for implementing
visualization algorithms and GLUT~\cite{OpenGLGlut} for
interacting with both the user and the operating system. More
specifically, OpenGL is used to specify the location, color and
lighting of objects residing within a {\em 3D world}\ defined by
FDS. In the context of FDS, these objects may be used to represent
geometry (such as blockages) or to visualize data. Smokeview uses
these underlying techniques as building blocks to visualize data
such as tracer particles, 2D shaded contours or 3D level
iso-surfaces.  Soot data or smoke may also be visualized using a
variation of a 2D shaded contour, where transparency rather than
color is used to represent the opacity or optical thickness of
smoke. This report describes these algorithms giving some of the
technical and programmatic details.

Smokeview is comprised of approximately \smvlines\ lines of code.
Most of it is written in C~\cite{C:book}. A small but important
part is written in Fortran 90~\cite{Fortran:book}.  This part is
used to read data generated by FDS.  Additional software libraries
(about 250~000 lines of code) are used for implementing dialogs,
rendering images and decompressing data files. The use of portable
libraries allows Smokeview to run on many platforms including
Windows, Linux and OS X (for the Macintosh).

The fundamental purpose of visualization is to gain insight into
the phenomena being studied. There is no one best method for
visualizing data. Each visualization technique highlights a
different aspect of the data. Smokeview visualizes fire dynamics
data, typically results from the Fire Dynamics Simulator. This
data takes many forms.  Some data is static, whereas other data
evolves with time. Some data represents geometric objects whereas
other data represents the solution to the flow equations solved by
FDS or a zone fire model such as CFAST. Smokeview displays fire
dynamics data allowing quantitative assessment to be performed
using visualization techniques such as animated tracer particles
that follow the flow, animated shaded 2D and 3D contours that
display flow quantities and animated flow vectors that display
flow quantities and direction. Smokeview also visualizes smoke
realistically by converting soot density to smoke opacity,
displaying smoke as it would actually appear. Each of these
visualization techniques highlight different aspects of the
underlying flow phenomena.

For details on the use of Smokeview, the reader is advised to read
the Smokeview User's Guide~\cite{Smokeview_Users_Guide}. For
details on how Smokeview is verified, see the Smokeview
Verification Guide~\cite{Smokeview_Verification_Guide}.  For
details on setting up and running FDS cases, read the FDS User's
Guide~\cite{FDS_Users_Guide}.  For details on the theory and
algorithms implemented in FDS read the FDS Technical
Guide~\cite{FDS_Tech_Guide}.

%
% -------------------  Version History ------------------------
%

\section{Version History}

Beginning in the early 1980s and continuing into the 1990s, Howard
Baum and Ronald Rehm of NIST developed the basic flow solver that
evolved into the Fire Dynamics Simulator which was publicly
released in 2000\cite{McGrattan:6}.  Their solution technique,
known as Large Eddy Simulation or LES, captures numerically very
complicated fire plume dynamics.  Unfortunately, the power of the
methodology could not be appreciated without an effective way to
view the calculation results.  Early attempts to visualize the
calculation results consisted of nothing more than little
particles swirling about in a box.  This was useful to the model
developers, but hardly to anyone else.  It just did not look like
a fire.

Smokeview was written to address this problem. It is an advanced
scientific visualization tool whose drawing algorithms are based
on physics, not just a tool for drawing pretty pictures. Version 1
of Smokeview was publicly released in February 2000, version 2 in
December 2001, version 3 in November 2002, version 4 in July
2004 and version 5 in September 2007.
The present version of Smokeview is 6, officially released
in June 2012.

Along with particle tracking as performed before, it visualized
fire flow data by coloring and animating fire/smoke flow making it
much easier to interpret FDS simulation results.  Immediately
after September 11, 2001, work began on both FDS and Smokeview to
enable them to model and visualize much larger problems.  As a
result, fire scenarios with several million grid cells can now be
modeled and visualized using a cluster of computers.

The next big step in Smokeview's development was the
implementation of an algorithm for realistically visualizing
smoke. The line between FDS which performs smoke flow computations
and Smokeview which performs smoke flow visualization became
blurred as Smokeview now performs physics-based computations
(Beer's law) in order to visualize the smoke.  The present
algorithm for visualizing smoke only considers the effects of
absorption - how much an object is obscured by smoke.  Future work
involves modeling the effects of scattering - how the interaction
between light and smoke effects the visualization and coloring the
fire more realistically based on physics principles such as the
blackbody temperature curve.  The challenge is to represent color
in an appropriate manner, considering the complexities associated
with perception.  For example, one complication is that often the
color that one perceives depends on what was just seen.

%
% -------------------  Model Development ------------------------
%

\section{Model Development}
Currently, Smokeview is maintained by the Engineering Laboratory
(EL) of the National Institute of Standards and Technology.
The FDS-Smokeview development team uses git for version control
and the website github.com to assist open source software
development by providing a repository for source code, revision
control, program distribution, bug tracking, and various other
very useful services.

The Smokeview manuals are typeset using \LaTeX, specifically, PDF
\LaTeX. The \LaTeX\ files are essentially text files that are
under GIT version control. The figures are either in the form
of PDF or jpeg files, depending on whether they are vector or
raster format. There are a variety of \LaTeX\ packages available,
including MiKTeX, a Windows version. The FDS-Smokeview developers
edit the manuals as part of the day to day upkeep of the model.
Different editions of the manuals are distinguished by date.

Changes made to Smokeview are tracked using revision control
software. Not every change results in a change to the version
number. The version number changes after it is judged that the
source code changes warrant a version number change. For minor
changes and bug fixes, incremental versions are released,
referenced according to fractions of the integer version number.
For example, version 5.1.4 would be a maintenance release of
feature version 5.1, which in turn is an update within the major
application release referred to as Smokeview 5. This happens every
few weeks. A minor release from 5.2 to 5.3, for example, might
happen only a few times a year, when significant improvements have
been made to the visualizations.

A suite of simple verification visualizations are routinely run to
ensure that the daily changes have not altered any of the
important visualization algorithms. The Smokeview verification
suite is documented in Ref~\cite{Smokeview_Verification_Guide}.

%
% -------------------  Capabilities ------------------------
%

\section{Capabilities}

Smokeview is a program designed to visualize numerical
calculations generated by the Fire Dynamics Simulator. Smokeview
visualizes both dynamic and static data.  Dynamic data is
visualized by animating particle flow (showing location and {\em
values}\ of tracer particles), 2D contour slices (both within the
domain and on solid surfaces) and 3D iso surfaces.  2D contour
slices can also be drawn with colored vectors that use velocity
data to show flow direction, speed and value. Static data is
visualized similarly by drawing 2D contours, vector plots and 3D
level surfaces. Smokeview features in more detail include:

\begin{description}
\item[Particle Animations] Lagrangian or moving particles can be
used to visualize the flow field. Often these particles represent
smoke or water droplets.

\item[Color Contours] Animated 2D shaded color contour plots are
used to visualize gas phase information, such as temperature or
density.

\item[Animated Flow Vectors] Flow vector animations, though
similar to color contour animations (the vector colors are the
same as the corresponding contour colors), are better than solid
contour animations at highlighting flow features.

\item[Animated Isosurfaces] Isosurface or 3D level surface
animations may be used to represent flame boundaries, layer
interfaces and various other gas phase variables.

\item[Realistic Smoke] Smoke, fire and sprinkler spray are
displayed realistically using a series of partially transparent
planes.

\end{description}

This report describes some of the technical details involved in implementing these capabilities.

%
% -------------------  Overview ------------------------
%

\section{Overview}

Smoke and other attributes of fire are visualized by Smokeview
using both quantitative and realistic techniques.  Smokeview uses
quantitative display techniques such as 2D and 3D contouring.
Realistic display of data refers to the intent of presenting the
data in a form as it would actually appear. The first part of this
document presents some of the details involved in using these
techniques for displaying FDS generated data.

To implement these techniques, Smokeview uses various tools and
techniques such as color, lighting, motion and transformation.
These basic building blocks, discussed in Appendix
\ref{visoverview}, are used by each of the techniques Smokeview
uses for visualizing data, in particular, smoke visualization. A
more thorough treatment may be may be found in Martz's OpenGL
Distilled~\cite{martz:06}, the OpenGL Programming Guide (Red
book)~\cite{OpenGLRed} or the SuperBible~\cite{SUPERBIBLE}.
Appendix \ref{smvprogstruct} gives some of the programmatic
details in particular giving the structure and naming conventions
of some of the program source files and how the external libraries
are organized and used.  Appendix \ref{openglinterface} gives the
details of how the OpenGL components used by Smokeview interact
with the host operating system.  Finally, several miscellaneous
topics such as image rendering and data compression are detailed.

%
% -------------------  Preliminaries ------------------------
%

\chapter{Preliminaries}
\label{visoverview}
\section{Defining Objects} Smokeview defines object locations in terms of a right
handed coordinate system with the $x$~axis pointing to the right, the $y$~axis
pointing to the back and the $z$~axis pointing up (see Fig. \ref{figrighthand}).
Coordinate values as defined in an FDS input file for objects such as blockages,
vents, etc. are transformed internally within Smokeview to lie between 0.0 and 1.0.
All Smokeview objects are drawn by grouping appropriately {\em OpenGL} vertices.
\begin{figure}[\figoptions]
\begin{center}
\includegraphics[width=3.0in]{FIGURES/righthandrule}
\end{center}
\caption{Right hand rule used by Smokeview for specifying a 3D vertex locations.}
\label{figrighthand}
\end{figure}

A vertex in OpenGL has the same meaning as in geometry, a
location. Vertices are specified in Smokeview using either {\bf
glVertex3f(x,y,z)}\ or {\bf glVertex3fv(xv)}.  The suffix for
glVertex indicates the number and type of data value to be passed.
For example, {\em 3f}\ is used when passing 3 scalar floating
points.  The suffix {\em 3fv}\ is used to when passing a pointer
(or equivalently a memory address) to 3 floating point  values.

To illustrate, suppose that {\tt xyz}\ is a floating point array
of size 3 containing a 3D coordinate.  One could then use either
of the two OpenGL calls:
\begin{lstlisting}
glVertex3fv(xyz);
glVertex3f(xyz[0],xyz[1],xyz[2]);
\end{lstlisting}
to represent the vertex location.

Groups of vertices may be {\em built up}\ to form more complex
geometric objects. Several objects are illustrated in Fig.
\ref{figshapes}.  They are formed by grouping vertices together
and surrounding them with calls to {\tt glBegin()}\ and {\tt
glEnd()}. The argument passed to {\tt glBegin()}\ determines which
higher level object is drawn. To draw a shaded triangle one would
use
\begin{lstlisting}
glBegin(GL_TRIANGLE);
glVertex3f(0.0,0.0,0.0);
glVertex3f(0.0,1.0,0.0);
glVertex3f(1.0,0.0,0.0);
glEnd();
\end{lstlisting}
Similarly, to draw points or to connect the vertices with lines
(also shown in Fig. \ref{figshapes}) one would replace {\tt
GL\_TRIANGLE}\ above with {\tt GL\_POINTS}\ or {\tt GL\_LINES}\
respectively.
\begin{figure}[\figoptions]
\begin{center}
\includegraphics[width=6.0in]{FIGURES/shapes}
\end{center}
\caption[Points, lines and a shaded triangle drawn using OpenGL.]
{Points, lines and a shaded triangle drawn using OpenGL. Vertices
are defined using {\tt glVertex*} and the particular shapes are
generated by passing {\tt GL\_POINTS}, {\tt GL\_LINES}, and {\tt
GL\_TRIANGLE}\ to {\tt glBegin()} } \label{figshapes}
\end{figure}

The triangle is the fundamental construct Smokeview uses to
visualize objects.  To be useful though, these objects need to be
colored, moved and projected onto a 2D terminal screen. These
topics are discussed in the following sections.

%
% -------------------  Setting the Scene ------------------------
%

\subsection{Setting the Scene}
3D objects must be flattened or converted to 2D in order to
display them on a computer screen.  This occurs in two steps.  The
first step is called a projection.  Smokeview uses three kinds of
projections: perspective, orthographic and stereo.  The second
step takes whatever projection that has been applied and maps the
resulting flattened geometry onto a subset of the computer screen.
This window subset, usually a rectangle, is called a viewport. All
viewports in Smokeview are rectangular.

\subsection{Projections}
Projections are used to flatten the 3D scene onto a two
dimensional plane. Two common projections are orthographic and
perspective. An orthographic projection is size preserving.
Objects in the foreground take up the same amount of screen space
as objects in the background. This projection is sometimes called
a parallel projection because parallel lines in the 3D scene
remain parallel when drawn on the screen.

A perspective projection creates an illusion of depth by causing
objects in the background to take up less screen space than the
same sized object drawn in the foreground.  Both projection
methods are available in Smokeview.

Smokeview uses {\tt glFrustum}\ to perform perspective projections
\begin{lstlisting}
      glFrustum(
        (double)fleft,(double)fright,
        (double)fdown,(double)fup,
        (double)fnear,(double)ffar);
\end{lstlisting}
and {\tt glOrtho}\ to perform orthographic projections
\begin{lstlisting}
      glOrtho(
        (double)fleft,(double)fright,
        (double)fdown,(double)fup,
        (double)fnear,(double)ffar);
\end{lstlisting}

\noindent where {\tt fleft}, {\tt fright}, {\tt fdown}, {\tt fup}, {\tt fnear},
{\tt ffar} are six clipping planes bounding the view frustum (truncated pyramid)
for the perspective projection or the box in the orthographic projection.
Drawing does not occur outside of the 3D region defined by these 6 clipping planes.
An additional six clipping planes parallel to the x, y and z axes may be activated
in Smokeview (using the clipping dialog box) to hide geometry making it easier to
see interior objects or visualizations (hence the term clipping plane).  OpenGL
allows one to define clipping planes along arbitrarily oriented planes.
\begin{figure}[\figoptions]
\begin{center}
\includegraphics[width=4.0in]{FIGURES/figviewport}
\end{center}
\caption{Example view frustum used to convert 3D scenes to 2D
screen viewport.}
 \label{figfrustum}
\end{figure}

\subsection{Stereo Projections}

A stereo projection is simply a perspective applied twice making adjustments
to simulate the viewpoint as seen for an observer's left and right eye.
The two resulting versions of the scene can then be drawn in succession
using shuttered glasses synced with the monitor to render the stereo effect.
Alternatively, left and right versions of the scene may be drawn at the same
time using stereo viewers to reveal the stereo effect.  Figure \ref{figstereo}
illustrates the two view frustums used for a stereo projection.

\begin{figure}[\figoptions]
\begin{center}
\includegraphics[width=3.0in]{FIGURES/fig_stereo}
\end{center}
\caption{View frustums for stereo pairs.}
 \label{figstereo}
\end{figure}

\subsection{Viewports}
A viewport is the particular portion of the screen where the
drawing occurs.  Smokeview defines separate viewports for drawing
the title, time bar, color bar and the 3D scene.  Figure
\ref{figviewports} illustrates the relationship between the 3D
scene and the 2D screen giving several viewport examples used by
Smokeview.
\begin{figure}[\figoptions]
\begin{center}
\includegraphics[width=4.0in]{FIGURES/figviewport2}
\end{center}
\caption{Examples of several viewports in a typical Smokeview scene.}
 \label{figviewports}
\end{figure}

Smokeview uses {\tt glViewport()}\ to establish a window viewport.  In particular, the call
\begin{lstlisting}
glViewport(left,down,width,height);
\end{lstlisting}
is used to set up the portion of the screen where 3D drawing occurs where {\tt left}\
and {\tt down}\ are the bottom left screen coordinates of the viewport and {\tt width}\
and {\tt height}\ are the width and height of the viewport.

%
% -------------------  Color, Shading and Blending ------------------------
%

\section{Coloring, Shading and Blending Objects}
Color, shading and blending are three aspects of the same process
used to draw objects residing in a three dimensional environment.
Smokeview uses color to display and more importantly to
distinguish between two or more geometric or data elements.
Shading adds a further depth cue (besides perspective projections
discussed earlier) to present the illusion of 3 dimensions.  Using
a virtual light source, colors are changed subtly based upon the
relative orientation of the light source and the surface being
drawn.  Portions of the surface oriented away from the light are
drawn darker than portions oriented towards the light.  Blending
is the process of combining the colors of two or more objects in
such a way that objects in the background may be seen through
semi-transparent objects drawn in the foreground.  Together,
color, shading and blending add to the illusion that the image
drawn on a two dimensional terminal screen is three dimensional.

\subsection{Color}
Color in OpenGL is defined using four not three components.
Besides the expected components of red, green and blue, OpenGL
uses a component designated as {\em alpha}\ to represent
opaqueness. Each component ranges from 0.0 to 1.0. An alpha
component of 0.0 indicates a color that is completely transparent
while an alpha component of 1.0 represents a color that is
completely opaque.

Colors are specified using the OpenGL routine {\tt glColorXXX()}.
As with {\tt glVertexXXX()}, XXX is replaced by a suffix used to
indicate the number and type of argument passed.  For the most
part, Smokeview uses {\tt glColor3f}, {\tt glColor4f}, {\tt
glColor3fv} and {\tt glColor4fv}.  As before, the 3 or 4 indicates
the number of data values used.  If 3 is specified in the call
then it is tacitly assumed that the fourth component, {\tt alpha},
has value 1.0.  In other words, the color is opaque.  The {\tt f}\
parameter indicates that floating point values are used and the
{\tt v}\ parameter indicates that the variable passed is a pointer
to the actual data to be referenced.

\subsection{Shading} OpenGL uses two shading models for drawing
objects, flat and Gouraud.  These models are specified using {\tt
glShadeModel(GL\_FLAT)}\ and {\tt glShadeModel(gl\_SMOOTH)}\
respectively. Gouraud shading is also referred to as smooth
shading.  Flat shading assumes that objects are drawn in an
environment with uniform lighting - light surrounds an object
equally in all directions. Smooth lighting on the other hand
assumes that light comes from a particular direction.  This causes
subtle changes in color to occur across an object's surface.
Figure \ref{figlighting} shows examples of FDS blockages (the
standard townhouse scenario) drawn using flat and smooth shading.
Flat shading diminishes the three dimensionality of the scene.
\begin{figure}[\figoptions]
\begin{center}
\begin{tabular}{cc}
\includegraphics[width=5.0in]{FIGURES/th_unlit}\\
flat shading\\
\includegraphics[width=5.0in]{FIGURES/th_lit}\\
smooth (Gouraud) shading\\
\end{tabular}
\end{center}
\caption [The FDS townhouse case drawn using flat and smooth
shading.] { The FDS townhouse case drawn using flat and smooth
shading. All blockage surfaces have identical colors when drawn
with flat shading.  When drawn with smooth shading, blockage
colors change.  Surfaces are darker when not in direct view of the
light source adding to a sense of depth. } \label{figlighting}
\end{figure}

A normal vector, another vertex attribute, is required to
implement a smooth lighting scheme. A normal vector points in a
direction perpendicular to the surface at the vertex. OpenGL uses
this information to estimate the fraction of light from the light
source reflected off of the given surface and intercepted by the
observer.  This is similar to a configuration factor calculation
performed in fire modeling.  The amount of light perceived by the
observer depends on the relative orientation of the light source,
the object (as specified by the location and normal vector of each
vertex) and the observer.

For planar surfaces, the same normal vector is applied to each
vertex defining the surface. For curved surfaces, normal vectors
are determined using an average of the normal directions of faces
surrounding the vertex.  If normals are not averaged then the
discontinuity in slope going from one face or triangle to another
will result in a faceted or gem-like appearance.  Figure
\ref{fignormals} shows examples of drawing using non-averaged and
averaged normals.
\begin{figure}[\figoptions]
\begin{center}
\begin{tabular}{cc}
\includegraphics[width=3.0in]{FIGURES/triangle_normal}&
\includegraphics[width=3.0in]{FIGURES/triangle_normal2}\\
\includegraphics[width=3.0in]{FIGURES/sphere_facet}&
\includegraphics[width=3.0in]{FIGURES/sphere_lit}\\
separate normals $\rightarrow$ faceted drawing&averaged normals $\rightarrow$ smooth drawing\\
\end{tabular}
\end{center}
\caption {Two spheres drawn showing the effect of using averaged
normals.  Using non-averaged normals results in a faceted or
gem-like appearance. } \label{fignormals}
\end{figure}

The Gouraud method for shading then determines a vertex color
using the angle between the light source direction and the vertex
normal vector. The color of the object being shaded is then
determined by interpolating these colors.

Smokeview uses smooth shading or lighting to draw blockages and
iso-surfaces. Particle, slice and boundary files are drawn without
shading as are 3D smoke and Plot3D files.


\subsection{Blending}
\label{blending} Smokeview using OpenGL draws semi-transparent
objects by combining or blending the color of the object currently
being drawn with the color in the current background
buffer.\footnote{The background buffer is updated as each object
is drawn.} The blending fraction is determined from the alpha
color component of the object currently being drawn. A small alpha
results in a small contribution from the currently drawn object
color while a large alpha results in a large contribution.  More
precisely:
\begin{eqnarray}
\noindent\mbox{updated background color} = \alpha\times
\mbox{fragment color} + (1-\alpha)\times \mbox{original background
color}
\end{eqnarray}
This particular blending model is the most common (there are
others) and is activated in Smokeview using the OpenGL call
\begin{lstlisting}
glBlendFunc(GL_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
\end{lstlisting}

Choosing an alpha less than one allows one to {\em see through}\
objects. Smokeview uses this feature to implement partially
transparent blockages and 2D animated slices. Slice files
illustrated in Fig. \ref{figtransparent} are drawn using
transparency. Smokeview also implements data chopping or hiding
using blending or transparency.  Data to be hidden is assigned an
alpha value of 0.0 causing it to be completely transparent.

\begin{figure}[\figoptions]
\begin{center}
\begin{tabular}{c}
\includegraphics[width=5.0in]{FIGURES/th_transparent}\\
partially transparent slice plane\\
\includegraphics[width=5.0in]{FIGURES/th_solid}\\
opaque slice plane\\
\end{tabular}
\end{center}
\caption {A slice file drawn transparently mixes
slice colors with those in the background.  When drawn opaquely,
any portion of the scene behind the slice file is hidden. }
\label{figtransparent}
\end{figure}

Complications arise, however, because this blending model is not
commutative.  The final color the user sees depends on the order
in which the intermediate colors are drawn. To demonstrate this
simply, consider two objects, one opaque and one semi-transparent.
An opaque object drawn second and in front of a semi-transparent
object will totally obscure the semi-transparent object. A
semi-transparent object drawn second and in front of an opaque
object will blend with but not obscure the opaque object drawn
previously.

To be more precise, consider two objects with colors $c_1$ and
$c_2$ and alpha values $\alpha_1$ and $\alpha_2$.   Let the
background color be denoted $b_0$.  Then blending object 1 with
the background results in a new background color, $b_1$, given by
\begin{eqnarray}
b_1=(1-\alpha_1)b_0 + \alpha_1c_1
\end{eqnarray}
Blending the color $c_2$ with $b_1$ results in a new background color, $b_2$, given by
\begin{eqnarray}
b_2&=&(1-\alpha_2)b_1 + \alpha_2c_2\\
&=&(1-\alpha_2)((1-\alpha_1)b_0 + \alpha_1c_1)+\alpha_2c_2\\
&=&(1-\alpha_2)(1-\alpha_1)b_0 + \alpha_1c_1 + \alpha_2c_2 - \alpha_2\alpha_1c_1
\end{eqnarray}

Now blend colors $c_1$ and $c_2$ to the original background in the
opposite order. Blending the color $c_2$ to with the background
color $b_0$ results in a new background color, $\hat{b}_1$, given
by
\begin{eqnarray}
\hat{b}_1=(1-\alpha_2)b_0 + \alpha_2c_2
\end{eqnarray}
Blending $c_1$ to the interim background color $\hat{b}_1$ results in a new background color,
$\hat{b}_2$, given by
\begin{eqnarray}
\hat{b_2}&=&(1-\alpha_1)\hat{b}_0+\alpha_1c_1\\
\hat{b_2}&=&(1-\alpha_1)((1-\alpha_2)b_0 + \alpha_2c_2)+\alpha_1c_1\\
\hat{b_2}&=&(1-\alpha_1)(1-\alpha_2)b_0 + \alpha_2c_2 + \alpha_1c_1 - \alpha_1\alpha_2c_2
\end{eqnarray}


In general, $b_2-\hat{b}_2=\alpha_1\alpha_2(c_2-c_1)\ne 0$, unless
$c_1=c_2$.  Of course $b_2=\hat{b}_2=0$ if $\alpha_1=0$ or
$\alpha_2=0$ but this is a trivial case in which one of the two
fragments is completely transparent.

The application to Smokeview is that since all smoke is drawn with
the same color, smoke slice plane drawing is order independent.
However, whenever fire is visualized along with smoke, multiple
colors may exist in a given plane (black for smoke, orange for
fire).  In this case, the order that the planes are drawn becomes
important.

In order then to prevent inconsistent drawing for the general
case, opaque objects are drawn first then partially transparent
objects are drawn next from back to front (from the point of view
of the observer). Otherwise transparent objects may appear blended
in front of objects when they should in fact be obscured. Of
significance in Smokeview, is that slice plane ordering is not
important when drawing 3D smoke since all smoke is drawn with the
same color (but different opacities).  However, order is important
when drawing smoke and fire (two different colors) or if
considering more elaborate lighting algorithms where in general
every vertex may have a different color (due to lighting effects).

When lighting is not applied, colors within a triangle are
determined in two steps using bi-linear interpolation. First,
colors along a triangle edge are linearly interpolated using the
two colors of the vertices bounding the edge. Second, the interior
colors are determined along a horizontal scan line again using
linear interpolation using colors previously interpolated on the
triangle edge.

Flat shaded triangles may be drawn more efficiently but are not
effective at visualizing a 3D effect.  More sophisticated shading
techniques are required and are discussed next.

%
% -------------------  Motion ------------------------
%

\section{Motion} Previous sections discussed how appearance is important
in visualization.  This section discusses how motion may be used to gain
insight into fire phenomena.  Motion may be thought of in two separate but
equivalent ways - keeping the scene fixed and changing the observer's location
and view direction or keeping the observer fixed and translating, rotating
and/or scaling the scene.

Objects are moved or translated in OpenGL by applying a transformation to
the current {\bf modelview}\ matrix.  The transformation is a matrix whose
particular form depends on whether it is a translation, a rotation or a scaling.

A translation by $(x,y,z)$ is performed by using {\tt glTranslate3f(x,y,z)}.
This OpenGL call generates the matrix
\begin{eqnarray}
T=\left(%
\begin{array}{cccc}
  1 & 0 & 0 & -x \\
  0 & 1 & 0 & -y \\
  0 & 0 & 1 & -z \\
  0 & 0 & 0 & 1 \\
\end{array}%
\right)
\end{eqnarray}
and applies it to the modelview matrix.

A rotation of $\theta$ degrees about the unit-vector axis, $(x,y,z)$,
is performed using {\tt glRotatef($\theta$,x,y,z)}.  A rotation of
$\theta$ degrees about the $x$~axis is performed using {\tt glRotate($\theta$,1.0,0.0,0.0)}.
This OpenGL call generates the matrix
\begin{eqnarray}
R=\left(%
\begin{array}{cccc}
  1 & 0 & 0 & 0 \\
  0 & \cos(\theta) & -\sin(\theta) & 0 \\
  0 & \sin(\theta) & \cos(\theta) & 0 \\
  0 & 0 & 0 & 1 \\
\end{array}%
\right)
\end{eqnarray}
and applies it to the modelview matrix.

It is of interest to rotate a scene between vectors $u$ and $v$
about an axis perpendicular to both vectors as illustrated in Fig.
\ref{figrotateuv}. The rotation axis is formed by generating the
cross-product of u and v, namely $u\times v$.  The rotation amount
$\theta$ is found using $cos(\theta)=u\cdot v/(||u||\cdot ||v||)$
.  For the special case that $u$ and $v$ are unit vectors and
$u=(0,0,1)$, a vector along the $z$~axis, then $\theta$ and the
rotation axis are given by
\begin{eqnarray}
\theta&=&\cos^{-1}(v_z)\\
u\times v&=&(-v_y,v_x,0)
\end{eqnarray}
so that the OpenGL call to perform the desired rotation would be
{\tt glRotatef}$(180\cos^{-1}(v_z)/\pi,-v_y,v_x,0)$.

\begin{figure}[\figoptions]
\begin{center}
\begin{tabular}{c}
\includegraphics[width=2.5in]{FIGURES/rotate_uv}
\end{tabular}
\end{center}
\caption{Diagram relating the vector $u\times v$ and the angle $\theta$
with vectors $u$, $v$. }
\label{figrotateuv}
\end{figure}

A scaling of $(a,b,c)$ meaning that $x$ components are scaled by
$a$, $y$ components are scaled by $b$, and $z$ components are
scaled by $c$ is performed using {\tt glScale3f(a,b,c)}. This
OpenGL call generates the matrix
\begin{eqnarray}
R=\left(%
\begin{array}{cccc}
  a & 0 & 0 & 0 \\
  0 & b & 0 & 0 \\
  0 & 0 & c & 0 \\
  0 & 0 & 0 & 1 \\
\end{array}%
\right)
\end{eqnarray}
and applies it to the modelview matrix. Smokeview uses scaling to
view cases with large aspect ratios, tunnel fires for example.

This multiplication is usually performed in hardware by the video
card.  The modelview matrix is initialized to the identity matrix
then multiplied by these translation, rotation or scaling
transformation matrices as the scene is moved using the {\tt
glTranslate}, {\tt glRotate}\ and {\tt glScale} OpenGL calls.


\subsection{Implementation}
The desired translation and rotation amounts are communicated
between the user and Smokeview using keyboard and/or mouse
callback routines.  Mouse motion is intercepted by the GLUT mouse
callback routines in Smokeview and named {\tt mouse}\ (first time
mouse is clicked) and {\tt motion}\ (when mouse is pressed and
moving).  GLUT {\em informs}\ the callback of the screen pixel
coordinate which Smokeview uses to determine an elevation or
azimuth angle or a translation amount depending on which control
key (none, CTRL or ALT) is pressed. Smokeview translates and
scales the coordinate system defined in an FDS scenario using
\newcommand{\mmin}{\mbox{min}}
\newcommand{\mmax}{\mbox{max}}
\begin{eqnarray}
\hat{x}&=&(x-x_{\min})/(xyz_{\max}-xyz_{\min})\\
\hat{y}&=&(y-y_{\min})/(xyz_{\max}-xyz_{\min})\\
\hat{z}&=&(z-z_{\min})/(xyz_{\max}-xyz_{\min})
\end{eqnarray}
where $x_{\min}$ and $x_{\max}$ are the smallest and largest $x$
coordinate considering all meshes.  $y_{\min}$, $y_{\max}$,
$z_{\min}$ and $z_{\max}$ are defined similarly.

The Smokeview scene is then translated in this coordinate system
using {\tt glTranslate} using the mouse position as passed to
Smokeview by GLUT.

The Smokeview scene may be rotated about either a vertical or
horizontal axis both passing through the scene center.  The
rotation angle about the horizontal axis (aligned perpendicular to
the viewer's line of sight) is called an elevation angle and the
rotation angle about the vertical axis is called an azimuth angle.
These two angles and the translation amount are used by Smokeview
to control the orientation of the scene.   Rotations are then
implemented in Smokeview using
\begin{lstlisting}
    glTranslatef(xcen,ycen,zcen);
    glRotatef(YZ_AXIS_angle,cos(az_angle),-sin(az_angle),1.0);
    glRotatef(XY_AXIS_angle,0.0,0.0,1.0);
    glTranslatef(-xcen,-ycen,-zcen);
\end{lstlisting}
where {\tt xcen, ycen, zcen}\ are the coordinates of the scene
center, YZ\_AXIS\_angle is the elevation angle, and
XY\_AXIS\_angle is the azimuth angle.  The scene center (center of
rotation) is translated to the origin, requested rotations are
implemented, then the scene is translated back to its original
location.

%
% -------------------  Visualizing Data ------------------------
%

\chapter{Visualizing Data}
Smokeview uses color and contours to visualize data
quantitatively. Color is used to indicate {\em how much}\ of a
quantity is at a given location whereas contours are used to
identify {\em where}\ rather than {\em how much}\ a specified
quantity occurs.

Coloring methods for visualizing data work by assigning colors
based upon data values to various vertices within the scene. These
vertices coincide with the FDS grid, either within a horizontal or
vertical plane (slice or Plot3D file) or on a blockage exterior
(boundary file).  The video card then interpolates these colors at
the interior of the figure, usually a triangle, formed by the
vertices. Coloring variations result from differing methods for
interpolating color between the vertices, either interpolating
within the 3D color cube or using a 1D texture map (the colorbar).

Smokeview uses {\em marching}\ algorithms for generating contours,
marching squares for generating 2D contours and marching
cubes~\cite{marchingcubes} for generating 3D contours. {\em
Marching}\ algorithms work by reducing the general contouring
problem to that of finding the contour in an elementary figure
such as a square or a cube.  Marching squares are used for finding
2D contours in a plane and marching cubes are used for finding
isosurfaces in a volume. A contour for a region is then generated
by splitting the region into a series of squares for 2D contours
or a series of cubes for a 3D contour and finally assembling the
contour acquired from all the parts.

Smokeview uses two methods for representing Smokeview flow data
realistically.  The first involves particles, representing smoke
flow by tracking tracer particles as they move through the
simulation influenced by an underlying  velocity field.  This
velocity field and the particle motion is computed by FDS and
communicated to Smokeview using data files.  This was the first
method Smokeview implemented for visualizing smoke flow and was
inspired by the software tool named Frames written by James Sims.

The second method for visualizing smoke flow involves a method
known as volumetric rendering.  Smoke transparency is visualized
using the optical properties of soot noting that the amount
of light obscured by smoke and hence its shade depends on
the quantity of smoke between the observer and the background.
Smokeview then integrates the smoke opacity one grid plane at a
time using a simple implementation of Beer's law in the video
hardware.



%
% -------------------  Coloring Data ------------------------
%

\section{Coloring Data}
Smokeview uses several methods to visualize data quantitatively
involving converting data values to color. The basic procedure is
to
\begin{enumerate}
\item obtain minimum and maximum data bounds to use in scaling,
either through calculation or specification by the user,

\item map data onto integer indices between 0 to 255 ,

\item obtain colors using indices computed in step 2 to index into
a color table (a numerical representation of the color bar)

\item display colors using 1D texture maps (or {\tt glColorxx}\ in
the case of particles).
\end{enumerate}
These steps are detailed in the following sections.   It is
important to point out that the use of 1D texture maps in step 4
enables more detail to be obtained from the visualization due to
the way that color interpolations between grid points are
performed.

\subsection{Determining Data Bounds}Smokeview uses three methods for
setting data bounds.  First, the bounds may be set by the user.
This would be useful to ensure consistent coloring when several
file types are displayed simultaneously (say slice and boundary files).
A second method is to use {\em percentile}\ bounds (1st and 99th by default)
which are useful when data outliers are present.  To find percentile bounds,
Smokeview scans the data computing a histogram.  It then picks data bounds at
a specified percentile levels, 1st and 99th by default.  The third method for
setting data bounds is to simply pick the global bounds for the data.

\subsection{Converting data to a color}
An index into a color table of size 256 is computed using

\begin{eqnarray}
\mbox{color index}=\left\{
\begin{array}{ll}
  0 & v < v_{min}\\
  1+253(v-v_{min})/(v_{max}-v_{min}) & v_{min}\le v \le v_{max} \\
  255 & v > v_{max}
\end{array}
\right.
\end{eqnarray}

\noindent where $v_{min}$ and $v_{max}$ are specified data bounds.
Each table entry contains 4 components (red, green, blue and
opacity).  Each component is scaled from 0.0 to 1.0.  The data in
the colorbar data structure then defines colors (by default) as
illustrated by the {\bf bold path}\ in Fig. \ref{colorbarinfo}.
Other colorbars may be used, for example a color bar containing
shades of gray from white to black.


\begin{figure}[\figoptions]
\begin{center}
\begin{tabular}{cc}
\includegraphics[height=4.0in]
{FIGURES/rainbowcolor}&\includegraphics[height=4.0in]{FIGURES/3dcolorcube}\\
a) colorbar&b) 3D color cube\\
\end{tabular}
\end{center}
\caption[1D colorbar and 3D color cube]{The 1D colorbar on the
left is mapped onto the 3D color cube along the {\bf bold path}
from blue to cyan to green to yellow to red.  Colors interpolated
within the cube are different than colors interpolated within the
colorbar.}
\label{colorbarinfo}%
\end{figure}

\subsection{Interpolating Colors}

Consider the following code segment for drawing a shaded triangle
with red, green and blue vertices:
\begin{lstlisting}
glBegin(GL_TRIANGLE);
glColor3f(1.0,0.0,0.0);
glVertex3f(0.0,0.0,0.0);

glColor3f(0.0,1.0,0.0);
glVertex3f(0.0,1.0,0.0);

glColor3f(0.0,0.0,1.0);
glVertex3f(1.0,0.0,0.0);
glEnd();
\end{lstlisting}

OpenGL interpolates colors between the vertices and interior to
the triangle using the color cube as in Fig. \ref{colorbarinfo}.
For example, if two vertices A and B are colored $(0.0,1.0,0.5)$
and $(1.0,0.5,0.0)$, then a point half way in between would be
colored $(0.5,0.75,0.25)$, the average of the two colors.  This
color is the midpoint of the line segment AB interior to the color
cube.

Smokeview version 4 (and earlier) uses this method, interpolating
data within the 3D color cube (not the colorbar).  As a result,
near the fire or wherever there are large temperature gradients,
interpolation artifacts occur.  For example, if a red (1,0,0)
region occurs near a blue (0,0,1) region, the interpolated color
halfway in between would be (0.5,0.0,0.5), a shade of purple, not
in the colorbar.  In general, suppose that $ci_j$ is an integer
index between 0 and 255 and that $f(ci_j)$ is the $ci_j$'th color
in the colorbar.  Then the interpolated color between the
two colors $f(c_1)$ and $f(c_2)$ would be
\begin{eqnarray}
\mbox{interpolated color}=(f(c_1)+f(c_2))/2
\end{eqnarray}

This is not a good method for displaying colors related to data
since only data on the colorbar have physical meaning.  By using
1D texture maps, color indices are interpolated not colors.
Therefore, colors displayed in data plots are always contained in
the colorbar which is what we want.

Smokeview interpolates color indices not colors. As a result,
interpolated colors are contained in the colorbar.  This
interpolation method is implemented using 1D texture maps.  A 1D
texture map is defined using the desired colorbar.  A texture
coordinate is assigned to each data vertex.    Color indices at
pixels between vertices are interpolated using the texture
coordinate.  In general, Smokeview uses the scheme,
\begin{eqnarray}
\mbox{interpolated color}=f((c_1+c_2)/2)
\end{eqnarray}
where $c_1$ and $c_2$ are color indices as before.

The following code segment sets up the use of 1D texture map.

\begin{lstlisting}
  glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_REPLACE);
  glEnable(GL_TEXTURE_1D);
  glBindTexture(GL_TEXTURE_1D,texture_slice_colorbar_id);
\end{lstlisting}

The following code segments (simplified) shows an example of drawing a slice in a YZ plane.

\begin{lstlisting}
   for(j=jmin; j<jmax; j++){
     for(k=kmin; k<kmax; k++){
       glTexCoord1f( r11); glVertex3f(xplane, yy1,  z1);
       glTexCoord1f( r31); glVertex3f(xplane,  y3,  z1);
       glTexCoord1f(rmid); glVertex3f(xplane,ymid,zmid);

       glTexCoord1f( r31); glVertex3f(xplane,  y3,  z1);
       glTexCoord1f( r33); glVertex3f(xplane,  y3,  z3);
       glTexCoord1f(rmid); glVertex3f(xplane,ymid,zmid);

       glTexCoord1f( r33); glVertex3f(xplane,  y3,  z3);
       glTexCoord1f( r13); glVertex3f(xplane, yy1,  z3);
       glTexCoord1f(rmid); glVertex3f(xplane,ymid,zmid);

       glTexCoord1f( r13); glVertex3f(xplane, yy1,  z3);
       glTexCoord1f( r11); glVertex3f(xplane, yy1,  z1);
       glTexCoord1f(rmid); glVertex3f(xplane,ymid,zmid);
     }
   }
   glEnd();
\end{lstlisting}



Figure \ref{fignewslice} shows the old and new method for
coloring.  Note that the new method results in crisper, clearer
colors. Fig. \ref{colorinterp} illustrates two methods for
interpolating color.  Colors are interpolated in Fig.
\ref{colorinterp}a within the color cube where the colors within
the cube have value (r,g,b).  Colors are interpolated in Fig.
\ref{colorinterp}b with the colorbar.

\begin{figure}[\figoptions]
\begin{center}
\begin{tabular}{cc}
\includegraphics[width=3.0in]
{FIGURES/plume_bad}&\includegraphics[width=3.0in]{FIGURES/plume_good}\\
interpolate colors within a 3D color cube&interpolate colors within 1D texture color bar\\
\end{tabular}
\caption [Slice file snapshots illustrating old and new method for
coloring data.] {Slice file snapshots illustrating old and new
method for coloring data.}
\label{fignewslice}%
\end{center}
\end{figure}



\begin{figure}[\figoptions]
\begin{center}
\begin{tabular}{c}
\includegraphics[height=4.0in]{FIGURES/interpcolorrgb}\\
a) colors interpolated within the color cube\\
\includegraphics[height=4.0in]{FIGURES/interpcolorindex}\\
b) colors interpolated within the colorbar\\
\end{tabular}
\end{center}
\caption[Color interpolation examples] {Illustration showing
colors representing data interpolated two different ways within a
triangle: interpolated with the 3D color cube and interpolated
with the colorbar}
\label{colorinterp}%
\end{figure}

%
% -------------------  2D Contours ------------------------
%

\section{2D Contours}

The {\em 2D contouring problem}\ may be stated as: find the region
in a 2D plane where a particular value exists {\em (line
contour)}\ or an interval of values exist {\em (banded contour)}.
In each case, the  region to be contoured is divided into a series
of squares.  The problem is solved for each square and assembled
to obtain the general solution.  The square locations correspond
to the grid set up in the FDS input file.

\subsection{Line contours}
\begin{figure}[\figoptions]
\begin{center}
\includegraphics[width=7.0in]{FIGURES/2d_linecontours}
\end{center}
\caption{2D line contour canonical forms.
  }
\label{fig2dline}%
\end{figure}
Mathematically, the 2D line contouring problem may be expressed
as: for some level $L$, find the line(s) in the desired region
where $f(x,y)=L$.  Consider this problem for one square and assume
that $f$ is known at each square corner.  The problem is solved by
noting that the value of $f$ at each of the four square corners is
either greater than or less than or equal to the contour level
$L$.  There are then two states at each of the four corners.  As a
result, there are 16 cases to consider.  These 16 cases may be
reduced to 4 after accounting for various symmetries such as
rotational, mirror and high/low.  High/low symmetry refers to the
observation that a case with one corner value above $L$ will look
the same as one with 3 corners above $L$. Figure \ref{fig2dline}
shows these four cases.  Corners with blue dots indicate that the
solution at this point is greater than $L$.  Red lines indicate
the line contouring solution.  The algorithm may be summarized as
follows:
\begin{enumerate}
\item Split the region to be contoured into a number of squares,
each square aligned with the underlying FDS grid.

\item For  each square:
\begin{enumerate}
\item Number the square corners as illustrated in Fig.
\ref{fig2dline}.

\item For each cell corner beginning with corner 0: assign 1 if
its value exceeds $L$, 0 otherwise.

\item Use resulting 4 digit binary number $(0\rightarrow 15)$ to
determine the case number to be plotted.  Using this numbering
scheme, the cases are numbered from left to right 0 1, 5 and 3.
\end{enumerate}
\end{enumerate}

\subsection{Banded contours}
\begin{figure}[\figoptions]
\begin{center}
\includegraphics[width=7.0in]{FIGURES/2d_bandcontours}
\end{center}
\caption{2D band contour canonical forms.
  }
\label{fig2dband}%
\end{figure}
The banded contouring algorithm works similarly to the line
contouring algorithm discussed previously.  The 2D banded
contouring problem may be expressed mathematically as given an
interval $[L,H]$, find the 2D region where $L\le f(x,y)\le H$. The
problem is solved by noting that the value of $f$ at each of four
square corners is either less than $L$, greater than $H$ or in
between.  There are three states at each of four corners resulting
in 81 cases to consider.  These 81 cases may be reduced to 13
after accounting for various symmetries such as rotational, mirror
and high/low. High/low symmetry is defined as before. Figure
\ref{fig2dband} shows these four cases.  Each square corner is
labeled with an L, M or H denoting that the value of $f$ at that
corner is below $L$, between $L$  and $H$ or above $H$
respectively.  The contoured region is bounded by black lines and
contains a series of one or more red lines in the interior. The
algorithm may be summarized as follows:
\begin{enumerate}
\item Split the region to be contoured into a number of squares,
each square aligned with the underlying FDS grid.

\item For  each square:
\begin{enumerate}
\item Number square corners as illustrated in Fig.
\ref{fig2dband}.

\item For each cell corner beginning with corner 0: assign 0 if
value is less than $L$, 1 if value is between $L$ and $H$ and 2 if
value exceeds $H$.

\item Use resulting 4 digit base 3 number $(0\rightarrow 80)$ to
determine the case number to be plotted. The case numbers in the
first row are 0, 40, 1, 2 and 3.  The case numbers in the second
row are 5, 8, 10, 11 and 13.  The case numbers in the last row are
14, 16 and 20.
\end{enumerate}
\end{enumerate}

%
% -------------------  3D Contours - Isosurfaces ------------------------
%

\clearpage
\section{3D Contours - Isosurfaces}
An isosurface is a surface in 3-D space that defines constant
values of a dependent variable. For example, if one is interested
in investigating regions at a certain temperature, say
\SI{100}{\degC}, one would generate an animated isosurface
specifying this value..

The isosurfaces are generated at each desired time step using a
marching cube algorithm~\cite{marchingcubes}\ modified to remove
ambiguities. A decimation procedure is used to reduce the number
of resulting triangles by collapsing nodes of triangles with large
aspect ratios and re-triangulating. This makes the isosurface look
better and also reduces storage requirements. Figures
\ref{figisoa} and \ref{figisob} illustrates the use of isosurfaces
for visualizing the stoichiometric mixture fraction. These figures
show different ways of drawing isosurfaces.

\paragraph{Isosurface uncertainty} Data used to generate isosurfaces
has uncertainty, therefore the location of the isosurface
also has uncertainty.  Bounds for this uncertainty may be expressed
in terms of data uncertainty and data variation (the smaller the
variation the larger the uncertainty).
The Smokeview verification guide~\cite{Smokeview_Verification_Guide}
shows that the uncertainty in isosurface location, $\Delta x$,
between two node, data value pairs $(x_1,T_1)$ and $(x_2,T_2)$  may be bounded using

\begin{eqnarray}
\left|\frac{\Delta x}{x_2-x_1}\right|\le \frac{\max(|\Delta
T_1|,|\Delta T_2|)}{|T_2-T_1|}
\end{eqnarray}

\noindent where $\Delta T_1$ and $\Delta T_2$ are the uncertainty
in $T_1$ and $T_2$ at $x_1$ and $x_2$ respectively.

\paragraph{Algorithm for generating an Isosurface} The algorithm for
generating an isosurface may be summarized as follows:
\begin{enumerate}
\item Split region to be contoured into a number of cubes, each cube
aligned with the underlying FDS grid.
\item For  each cube:
\begin{enumerate}
\item Number cube corners from 0 to 7 as illustrated in Fig.
\ref{figisosetup}. \item For each cube corner beginning with
corner 0: assign 1 if value exceeds $L$, 0 otherwise. \item Use
resulting 8 digit binary number $(0\rightarrow 255)$ to determine
the case number to be plotted. \item Triangulate cube surface,
storing vertex locations and edge numbers according to case
\end{enumerate}
\item Triangle decimation.  Eliminate small triangles (any
triangle with two or more vertices {\em closest}\ to the same
node). Replace removed triangle vertices with a vertex with
coordinates that are the average of the three removed vertices
coordinates.  Re-triangulate using this new vertex.  This process
is illustrated in Fig. \ref{figdecimate}. \item Estimate normal
directions (to be associated with a vertex).  For each vertex:
\begin{enumerate}
\item determine triangles sharing the vertex
\item determine the normal vector (normalized with length 1.0) of each
triangle using the vertex
\item construct a harmonic weighted average of triangle normal vectors
where all weights sum to 1.0 and each weight is inversely proportional
to the corresponding triangle area
\item store the resulting average along with vertex data
\end{enumerate}
\end{enumerate}

\paragraph{Vertex normals in 3D} An averaged normal vector, $V_i$, for
vertex $i$ may then be determined by summing over all triangles $n$
connected to a vertex $i$ as in
\begin{eqnarray}
V_{i}&=&\sum_n\frac{U_n}{A_n}/\sum_n\frac{1}{A_n}
=\sum_n\frac{u_n\times v_n}{||u_n\times
v_n||^2}/\sum_n\frac{1}{||u_n\times v_n||}
\end{eqnarray}
where for the $n$'th triangle, $u_n$ and $v_n$ are two sides,
$A_n=||u_n\times v_n||$ is the triangle area and $U_n=u_n\times v_n/A_n$
is a unit vector normal to the triangle.


\begin{figure}[\figoptions]
\begin{center}
\includegraphics[height=8.5in]{FIGURES/plume5a_iso_full}\\
\end{center}
\caption{Snapshot of an isosurface of temperature at 100 \degC\ (212 \degF).
  }
\label{figisoa}%
\end{figure}

\begin{figure}[\figoptions]
\begin{center}
\begin{tabular}{c}
\includegraphics[height=4.0in]{FIGURES/plume5a_iso_lines}\\
outline view\\
\includegraphics[height=4.0in]{FIGURES/plume5a_iso_solid}\\
solid view
\end{tabular}
\end{center}
\caption{Snapshot of an isosurface of temperature at 100 \degC\ (212 \degF).
  }
\label{figisob}%
\end{figure}

\begin{figure}[\figoptions]
\begin{center}
\includegraphics[width=7.0in]{FIGURES/3d_contours}
\end{center}
\caption[3D isosurface canonical forms.]{3D isosurface canonical
forms. Dots occur at corners where the data value is greater than
the isosurface value.  Other corners are below the isosurface
value.  Red polygons intersect cube edges at the isosurface value.
The red polygon (isosurface) NEVER intersects an edge with two or
zero dots on the ends.
  }
\label{figisosetup}%
\end{figure}


\begin{figure}[\figoptions]
\begin{center}
\begin{tabular}{c}
\includegraphics[height=4.0in]{FIGURES/decimate_before}\\
before decimation\\
\includegraphics[height=4.0in]{FIGURES/decimate_after}\\
after decimation
\end{tabular}
\end{center}
\caption[Example of triangle decimation.]{Example of triangle decimation.
Triangle with red dots is removed.  Region is re-triangulated by replacing
any edges connected to a red dot with the blue dot (average position of removed red dot).}
\label{figdecimate}%
\end{figure}

%
% -------------------  Section on isosurface slope derivation ------------------------
%

\begin{figure}[\figoptions]
\begin{center}
\includegraphics[width=5.0in]{FIGURES/3point_line_smooth}
\end{center}
\caption{Setup for determining the slope of a smooth curve passing through three points.}
\label{figlinesmooth}%
\end{figure}

\paragraph{Vertex normals in 2D} The use of inverse area weights or
harmonic averages to construct average normal vectors at isosurface
vertices is justified by the following two dimensional example.
As illustrated in Fig. \ref{figlinesmooth}, consider the
quadratic $y(x)=A+Bx+Cx^2$ with $y(-\Delta x_2)=0$,
$y(0)=1$ and $y(\Delta x_1)=0$ .  The slope at $x=0$ is given by $y'(0)=B$.
Likewise, the slope of the vector perpendicular to this curve at $x=0$ is $-1/B$.
The coefficient $B$ may be determined from the two simultaneous equations
$y(\Delta x_1)=0$ and  $(y(-\Delta x_2)=0$ (note that $A=1$ since $y(0)=1$) or
\begin{eqnarray}
1+B\Delta x_1 + C \Delta x_1^2 &= &0\\
1-B\Delta x_2 + C \Delta x_2^2 &= &0
\end{eqnarray}
which has solution
\begin{eqnarray}
B&=&\frac{\Delta x_1^2-\Delta x_2^2}{\Delta x_1\Delta x_2(\Delta x_1+\Delta x_2)}=
\frac{\Delta x_1-\Delta x_2}{\Delta x_1\Delta x_2}
\end{eqnarray}
The slope $N$ of the normal at $x=0$ is then given by
\begin{eqnarray}
N=-\frac{1}{B}&=&\frac{1}{1/\Delta x_1-1/\Delta x_2}
\end{eqnarray}
The slope $N_1$ of the normal to the line segment between
$(0,1)$ and $(\Delta x_1,0)$ is $N_1=\Delta x_1$.
The slope $N_2$ of the normal to the line segment between
$(-\Delta x_2,0)$ and (0,1) is $N_2=-\Delta x_2$.
Therefore the average slope $N$ may be expressed in terms of
$N_1$ and $N_2$ as
\begin{eqnarray}
N=\frac{1}{1/N_1+1/N_2}
\end{eqnarray}

\section{Particle Systems}
\subsection{Massless Particles}
FDS uses particles as tracer elements to allow one to visualize
flow.  FDS also uses particles as droplets to model fire
suppression or as fuel elements that can be transported and
burned, for example, as embers emitted from a burning tree.
Particle positions are determined in FDS using the differential
equation
\begin{eqnarray}
\frac{dx_p}{dt}=V(x_p,t)
\end{eqnarray}
where $x_p$ represents particle position and $V$ represents the
velocity field.

The assumption this model uses to compute particle flow is that
the drag force on the particle is large compared to $mg$, the
force due to gravity.

Figure \ref{figpart} shows particles represented as particles and
as streaks. A particle streak visualizes where a particle is
located over a period of time.  The streak length is specified as
time. Static particle images are not effective at displaying
motion.  For example, the particle image in Fig. \ref{figpart}a
does not show particle motion.  Streak lines, however, in Fig.
\ref{figpart}b shows curved motion due to interior obstructions.
Particle size is specified using
\begin{lstlisting}
glPointSize(partpointsize);
\end{lstlisting}
The floating point value of {\tt partpointsize}\ is specified
using the {\tt File/Bounds} dialog box.  Streak line length is
specified in terms of time, a certain number of seconds before the
current display time.  Streak length is also specified in the {\tt
File/Bounds}\ dialog box.

\begin{figure}[\figoptions]
\begin{center}
\begin{tabular}{cc}
\includegraphics[width=3.0in]{../SMV_Verification_Guide/SCRIPT_FIGURES/plume5c_part}&
\includegraphics[width=3.0in]{../SMV_Verification_Guide/SCRIPT_FIGURES/plume5c_streak}\\
a) Particles&b) Particle streaks\\
\end{tabular}
\end{center}
\caption{Plume flow visualized using particles and particle streaks.}
\label{figpart}%
\end{figure}

\section{Computing and Visualizing Fractional Effective Dose data}
The fractional effective dose (FED), developed by
Purser~\cite{SFPE:Purser}, is a measure of human incapacitation
due to combustion gases.  FED index data is computed by Smokeview
using CO, $\mathrm{CO_2}$ and $\mathrm{O_2}$ gas concentration
data computed by FDS. Future work involves incorporating other
constituents such as soot or HCN.  Smokeview obtains this data
from FDS using slice files.

The total FED is computed here in terms of FED components for CO
and $\mathrm{O_2}$.  A hyper-ventilating factor due to
$\mathrm{CO_2}$ is applied to the FED for CO. The total FED is
then given by

\be \mathrm{FED}_\mathrm{tot} = \mathrm{FED}_\mathrm{CO} \times
\mathrm{HV}_\mathrm{CO_2} + \mathrm{FED}_\mathrm{O_2} \ee

Other terms involving CN, NOx and irritants are neglected. The
fraction of an incapacitating dose due to CO,
$\mathrm{FED}_\mathrm{CO}$ is calculated using

\be \mathrm{FED}_\mathrm{CO}(t) = \int_0^t 2.764 \times 10^{-5} \,
(C_\mathrm{CO}(t))^{1.036} \, dt \label{eq:fedCO} \ee

where $t$ is time in minutes and $C_\mathrm{CO}$ is the CO
concentration (ppm). The fraction of an incapacitating dose due to
low O${}_2$ hypoxia , $\mathrm{FED}_\mathrm{O_2}$, is calculated
using

\be \mathrm{FED}_\mathrm{O_2}(t) =  \int_0^t \frac{dt}{\exp \left
[ 8.13 - 0.54 \, (20.9 - C_\mathrm{O_2}(t)) \right ] }
\label{eq:fedO2} \ee

where $t$ is time in minutes and $C_\mathrm{O_2}$ is the O${}_2$
concentration (volume per cent). The hyperventilation factor
induced by carbon dioxide, $\mathrm{HV}_\mathrm{CO_2}$, is
calculated using

\be \mathrm{HV}_\mathrm{CO_2}(t) = \frac{ \exp( 0.1903 \,
C_\mathrm{CO_2}(t) +  2.0004 ) }{7.1} \label{eq:co2hyp} \ee

where $t$ is time in minutes and $C_\mathrm{CO_2}$ is the
$\mathrm{CO_2}$ concentration (percent).

\subsection{FED example}
Assuming that $C_\mathrm{CO}(t)=\mathrm{CO}$,
$C_\mathrm{CO_2}(t)=\mathrm{CO_2}$ and
$C_\mathrm{O_2}(t)=\mathrm{O_2}$ are constant, equations
\ref{eq:fedCO}, \ref{eq:fedO2} and \ref{eq:co2hyp} reduce to

\be \mathrm{FED}_\mathrm{CO}(t) = 2.764 \times 10^{-5} \,
\mathrm{CO}^{1.036} \, t \label{eq:fedCOcons} \ee

\be \mathrm{FED}_\mathrm{O_2}(t) =   \exp( -8.13 + 0.54 \, (20.9 -
\mathrm{O_2}) )t \label{eq:fedO2cons} \ee

\be
\mathrm{HV}_\mathrm{CO_2}(t) = \frac{ \exp( 0.1903 \, \mathrm{CO_2} +  2.0004 ) }{7.1}
\label{eq:fedCO2cons}
\ee

so that the total FED is given by

\begin{eqnarray}
\mathrm{FED}_\mathrm{tot}
&= &\mathrm{FED}_\mathrm{CO}(t)\times\mathrm{HV}_\mathrm{CO_2}(t)+\mathrm{FED}_\mathrm{O_2}(t)\\
\nonumber
 &= &\left(2.764 \times 10^{-5} \, \mathrm{CO}^{1.036}\times
\frac{ \exp( 0.1903 \, \mathrm{CO_2} +  2.0004 ) }{7.1}\exp( -8.13
+ 0.54 \, (20.9 - \mathrm{O_2}) )\right) t\\
\end{eqnarray}

Figure \ref{fig:fedplot} presents two FED computations where CO,
$\mathrm{CO_2}$ and $\mathrm{O_2}$ are constant.
The first for a smoke filled room with CO=\SI{10000}{ppm},
$\mathrm{CO_2}=5 \%$ and $\mathrm{O_2}=10 \%$ and the second for a
room with ambient conditions with CO=\SI{9}{ppm},
$\mathrm{CO_2}=0 \%$ and $\mathrm{O_2}=21 \%$

\begin{figure}[\figoptions]
\begin{center}
\begin{tabular}{cc}
\includegraphics[width=3.0in]{FIGURES/fed_clear}&
\includegraphics[width=3.0in]{FIGURES/fed_smoke}\\
a) ambient&b) smoke filled\\
\end{tabular}
\end{center}
\caption{Plot of FED vs. time for ambient and smoke filled rooms.}
\label{fig:fedplot}%
\end{figure}

%
% -------------------  Volumetric Methods ------------------------
%

\chapter{Visualizing Smoke and Fire}

\newcommand{\citesmv}{\cite{Smokeview_Users_Guide}}
\newcommand{\paper}{chapter}
\input{smoke_notes}
%
% -------------------  Future Work ------------------------
%

\chapter{Future Work}

Smokeview is a software tool used to gain insight into results
generated by fire models such as the Fire Dynamics Simulator or
CFAST. Two general areas of research need to be addressed in order
to improve this tool. First, scenarios with a large number of grid
cells need to be visualized more effectively and efficiently and
second, some visualization algorithms need to be improved and
others need to be added in order to more effectively interpret
fire modeling data. Some areas of research to accomplish these
goals are described in more detail in the following sections.

%
% -------------------  Visualize Cases more Realistically ------------------------
%

\section{Visualize Cases more Realistically}
Realism is a metric used to gauge qualitatively the accuracy of
fire and smoke display. Realism itself is not the primary goal,
however.  It is a side effect of the application of more physics.
The primary goal is to gain a better understanding of the data.
This requires a more accurate representation of the underlying
data which in turn requires the application of more physics.  Two
areas being investigated are
\begin{itemize}
\item Investigate techniques for visualizing fire more
realistically by using information about the fire such as its
temperature and composition (soot and various gas species) to
color it more realistically.  Flame temperatures need to be
modeled directly by FDS in order in order to use the blackbody
temperature curve to obtain flame color.  Further, the resolution
of the computation needs to be consistent with the desired
resolution of the flame image.

\item Investigate algorithms for modeling the interaction of light
and smoke. The {\em transport} of light into and out of the
smoke/fire ({\em i.e., scattering}) is another important factor
that effects its appearance.  Light sources could consist of
either man made lights or from the fire itself.  Work also needs
to be done to generalize the wavelength of light used to visualize
the scene, i.e., implementing an algorithm in Smokeview to
simulate a thermal imager or infrared viewer.
\end{itemize}

%
% -------------------  Fire Computations in Smokeview ------------------------
%

\section{Fire Computations in Smokeview}
The roles of FDS and Smokeview seem clear, FDS performs fire
computations and Smokeview visualizes them. This distinction
became blurred with the addition of 3D smoke visualization
algorithms in Smokeview. Further blurring the distinction,
pre-visualization steps are performed in FDS, to convert soot
density to a smoke opacity. These two codes represent a suite of
software dedicated to advanced scientific fire modeling and
visualization.

Additional fire computations are planned for Smokeview.  The user
will gain insight into the fire phenomena much more quickly by
being able to manipulate and solve their problem in real time. Two
examples are detailed below.

\begin{itemize}
\item  Investigate methods for modeling the motion of fire brands
using either wind fields computed by FDS or wind fields defined in
Smokeview. This allows one to define the initial position and
distribution of fire brands and to note where they land.

\item Implement a level set method proposed by Rehm and
McDermott~\cite{Rehm:LevelSet} for tracking an outdoor fire line.  The
method would take into account terrain (i.e., non-level
ground) defined by the user for outdoor fire applications.
\end{itemize}

%
% -------------------  Visualize Larger Cases ------------------------
%

\section{Visualize Larger Cases}
Techniques need to be investigated for visualizing larger cases
more effectively.  Updating Smokeview to allow 64 bit memory
addressing is just one option.  This is a brute force method.
Techniques are also required for honing or zeroing in on data of
interest.  The fire line used to visualize WUI (wildland urban
interface) simulations is a good example of this.  A fire line in
the context of Smokeview is simply a visual display of temperature
only visible where the fire is located.  Additional techniques for
visualizing large cases that need to be investigated include:

\begin{itemize}
\item Investigate methods for making it easier to probe or mine
data, i.e., to retrieve data of particular interest.  Now
FDS data is stored sequentially.  For large data sets one needs to
retrieve data efficiently at a particular time and region without
reading the entire data set.

User defined spatial and temporal data subsets need to be loaded
efficiently in order to shorten the time required to visualize
cases.

\item Investigate standardized methods for storing data more
efficiently and more effectively.  Can we do it better and be
practical?  The idea would be not to change how FDS outputs data
but to consider whether a separate {\em filter}\ program that
would convert FDS generated data into a different format that
would enable other tools besides Smokeview to be able to visualize
data, for example the visualization tool kit VTK~\cite{VTK}.

\item Investigate parallelization methods for visualizing data.
Smokeview presently has a limited ability to execute code in
parallel using a technique known as multi-threading.    For
example, smooth blockages if present, are smoothed in parallel
using the pthreads library. Smokeview in this respect is
multi-threaded.  Techniques will be investigated for performing
the drawing or visualization in parallel.  This may be necessary
as cases get larger and larger.  One technique for parallelizing
the visualization is to use several video cards each one drawing a
portion of the scene.
\end{itemize}

%
% -------------------  Tools and Techniques ------------------------
%

\section{Tools and Techniques}

\begin{itemize}

\item Investigate methods for using the video card to perform
scientific computations. The computational power of the video card
is already  being exploited by Smokeview to perform simple smoke
computations. It will need to be exploited even more in order to
make the proposed fire coloring and smoke lighting computations
practical. Techniques are being investigated for performing the
computations needed to implement the more realistic fire and smoke
computations discussed earlier, in particular CUDA~\cite{CUDA}.
Techniques such as these will be required it more complex
visualization algorithms are to be effective.

\item Investigate alternative methods for implementing a graphical
user interfaces (GUI) for Smokeview. Smokeview uses GLUT for
implementing a simple user interface.  GLUT was not intended for
developing user interfaces as complex as what Smokeview requires.
Alternatives for implementing user interfaces will be
investigated.

\item Currently FDS and Smokeview run in batch mode without using
updated information. As FDS or CFAST begin to use data
assimilation techniques, it would be useful if Smokeview could
incorporate updated results as they are computed.

\end{itemize}

%
% -------------------  References ------------------------
%

\bibliography{../Bibliography/FDS_general,../Bibliography/FDS_refs,../Bibliography/FDS_mathcomp,../Bibliography/sv_fire,../Bibliography/sv_graphics}

\addcontentsline{toc}{chapter}{Bibliography}

%
% -------------------  Appendices ------------------------
%

\appendix
\addcontentsline{toc}{chapter}{Appendices}


%
% -------------------  Smokeview Program Structure ----------
%

\chapter{Smokeview Program Structure}
\label{smvprogstruct}

This chapter gives an overview of the program structure for
Smokeview. Smokeview consists of about \smvlines\ lines of code.
Most of it is written in C using standard libraries such as
OpenGL~\cite{OpenGLRed} for implementing the graphics,
GLUT~\cite{OpenGLGlut} for providing a simple menu based user
interface and interacting with the host operating system.
Additional graphical user interface (GUI) elements are implemented
as dialog boxes using the OpenGL based widget library
GLUI~\cite{GLUILIB}. The libraries GD~\cite{GDLIB},
libpng~\cite{PNGLIB}, and libjpeg~\cite{JPEGLIB} are used for
converting Smokeview scenes/results into images files. The library
libzip~\cite{ZLIB} is used for compression. Smokeview uses this
compression library when generating PNG files and when reading in
3D smoke files compressed by Smokezip.

A small portion of Smokeview is written in Fortran 90 to input
data generated by FDS.  The use of portable libraries allows
Smokeview to run on many platforms including Windows, and various
versions of Unix such as IRIX (for the SGI), Linux and OS X (for
the Macintosh).

Figure \ref{smvlibstruct} illustrates how these libraries and
Smokeview are organized.

\begin{figure}
\includegraphics[width=5.0in]{FIGURES/smvlibstruct}
\caption{Smokeview external library usage}
\label{smvlibstruct}
\end{figure}


Since Smokeview is a large program and is constantly changing, it
is not practical to give a line by line detailed description. The
interested user, however, should be able to use this overview as a
starting point to dig into those parts of Smokeview that may be of
interest.

The program structure of Smokeview is fundamentally different than
that of FDS in one important respect.  Smokeview is an {\em event
driven}\ program with a graphical user interface.  The term {\em
event driven}\ in this context means that the user controls the
program flow using various means such as pressing a key, clicking
or dragging the mouse, selecting a menu item, etc.  In other
words, the user initiates events not the program. The Smokeview
response then depends on which {\em event}\ has occurred.

The program structure may then be described as follows. Smokeview
starts out by performing initializations and setting up the
OpenGL environment. This is followed by a call to a GLUT routine
that implements the {\em event loop}. The {\em event loop}\ is
literally a program loop without an exit which detects when the
user invokes the various events, again these are key clicks, mouse
clicks, menu selection, etc. Once an event is detected, a
user {\em callback}\ routine is called.  Note that user callback
routines are Smokeview code and the event loop is GLUT library
code. Part of Smokeview's initialization process is to define
which C procedures are associated with which callbacks.  This is
performed in the Smokeview C routine {\tt InitOpenGL}\ located in
the source file {\tt startup.c}.

There is a Smokeview callback routine for every action that is
performed.  For example, the user callback for loading a 3D smoke
file is {\tt Load3DMenu}.  This is a menu callback because it is
called after the user selects a menu item.  All menu callbacks are
located in the source file {\tt menu.h}.  All other callback
routines are located in the source file {\tt callback.c}.

Figure \ref{figprogstruct} illustrates the program structure
described in the previous paragraphs.  Every OpenGL/GLUT program
will use most of the callbacks named in this figure.

\begin{figure}
\begin{center}
\includegraphics[width=5.0in]{FIGURES/smvprogstruct}
\end{center}
\caption{Smokeview program structure}
\label{figprogstruct}
\end{figure}

%
% -------------------  Interfacing OpenGL with the Host Operating System ----------
%

\chapter{Interfacing OpenGL with the Host Operating System}
\label{openglinterface}
OpenGL by design draws the 3D geometry but
does not interact with the user or the operating system. Smokeview
uses the graphics library utility toolkit (GLUT) for interacting
with the user {\em via}\ the keyboard and mouse and for
interacting with the operating system to swap display buffers, to
display fonts, to set maximum frame rates, etc. Though not as
sophisticated as other libraries, GLUT is simple to use and is
portable allowing Smokeview to be built on a number of different
computer platforms including a PC running Windows or Linux, a
Silicon Graphics workstation running IRIX or a Macintosh running
OS X.

%
% -------------------  Buffers ------------------------
%

\section{Buffers} Smokeview uses several buffers provided by
OpenGL for visualization.  GLUT is used to manipulate these
buffers. Smokeview uses double buffering.  Double buffering is the
technique where drawing occurs in the {\bf back buffer}\ while the
scene is simultaneously displayed using the {\bf front buffer}.
Smokeview uses the GLUT routine {\tt glutSwapBuffers();}\ to swap
the front and back buffers once drawing is complete. Screen
flickering occurs the if the display (front) buffer is updated
while drawing occurs.

Hidden lines and surfaces are removed from a scene using the {\bf
depth buffer}.  Each time Smokeview draws an object, its depth
(distance from the observer) is compared to the value previously
stored in the depth buffer.  If the object's depth is less than
the value stored in the depth buffer then the object is considered
visible and the new depth value is store in the buffer. Otherwise
the depth buffer remains unchanged and the object is considered
hidden.

%
% -------------------  Initialization and Callback Routines ------------------------
%

\section{Initialization and Callback Routines}
Initializations are performed by GLUT to set up windows and to
define display modes.  Smokeview defines the display to handle
color, a depth buffer and double buffering by passing the OpenGL
keywords {\tt GLUT\_RGB}, {\tt GLUT\_DEPTH} and {\tt GLUT\_DOUBLE}
to {\tt glutInitDisplayMode} as in

\begin{lstlisting}
  glutInitDisplayMode(GLUT_RGB|GLUT_DEPTH|GLUT_DOUBLE);
\end{lstlisting}

Smokeview creates a window with width {\tt windW}\ and height {\tt
windH} using the GLUT calls

\begin{lstlisting}
  glutInitWindowSize(windW, windH);
  glutCreateWindow("");
\end{lstlisting}

and defines callbacks with

\begin{lstlisting}
  glutSpecialUpFunc(specialkeyboard_up);
  glutKeyboardUpFunc(keyboard_up);
  glutKeyboardFunc(keyboard);
  glutMouseFunc(mouse);
  glutSpecialFunc(specialkeyboard);
  glutMotionFunc(motion);
  glutReshapeFunc(Reshape);
  glutDisplayFunc(Display);
\end{lstlisting}

A callback is a routine that is called when a particular event
occurs.  For Smokeview these events would be when a keyboard key
is depressed (or when the key is released), when the mouse is
clicked or when the mouse is moved.  Smokeview determines rotation
and translation amounts using the {\tt motion} callback defined
with {\tt glutMotionFunc(motion)}.




%
% -------------------  Compressing Data ------------------------
%

%\chapter{Compressing Data}
\chapter{Rendering Smokeview Images}

Smokeview uses the library GD~\cite{GDLIB} to convert the
currently displayed scene into either a JPEG, PNG or GIF image.
Smokeview reads in the OpenGL back buffer and then uses the GD
routine, {\tt gdImageSetPixel}\ to store the image data in GD's
internal format one pixel at a time.    Finally, Smokeview uses a
GD routine to convert the image into the desired image format.

A summary of the steps in more detail are:
\begin{enumerate}
\item Allocate memory buffers and file pointers
\begin{lstlisting}
  RENDERfile = fopen(RENDERfilename, "wb");
  pixels = (GLubyte *) malloc(width * height * sizeof(GLubyte) * 3);
\end{lstlisting}

\item Read pixel data from the back buffer
\begin{lstlisting}

  glReadPixels(x, y, width, height, GL_RGB, GL_UNSIGNED_BYTE, OpenGLimage);
\end{lstlisting}
\item Allocate the gd data structures used to hold image data
\begin{lstlisting}
  RENDERimage = gdImageCreateTrueColor(width,height);
\end{lstlisting}

\item Set pixel data

\begin{lstlisting}
  for (i = height-1 ; i>=0; i--) {
    for(j=0;j<width;j++){
      r=*p++; g=*p++; b=*p++;
      rgb = (r<<16)|(g<<8)|b;
      gdImageSetPixel(RENDERimage,j,i,rgb);

    }
  }
\end{lstlisting}

\item Write out data to a JPEG image file

\begin{lstlisting}
    gdImageJpeg(RENDERimage,RENDERfile,-1);
\end{lstlisting}

\item deallocate memory buffers and free file pointer

\begin{lstlisting}
  fclose(RENDERfile);
  gdImageDestroy(RENDERimage);
  free(OpenGLimage);
\end{lstlisting}

\end{enumerate}

\end{document}
