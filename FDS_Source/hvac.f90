MODULE HVAC_ROUTINES
 
! Compute the HVAC mass and energy transport
 
USE PRECISION_PARAMETERS
USE GLOBAL_CONSTANTS
USE MESH_POINTERS
USE DEVICE_VARIABLES
USE CONTROL_VARIABLES
USE COMP_FUNCTIONS, ONLY: SECOND, CHECKREAD, SHUTDOWN
USE MEMORY_FUNCTIONS, ONLY: ChkMemErr
 
IMPLICIT NONE

REAL(EB), ALLOCATABLE, DIMENSION(:,:):: NODE_CP,NODE_P,NODE_TMP,NODE_RHO,NODE_RSUM,DUCT_MF
REAL(EB), ALLOCATABLE, DIMENSION(:,:,:):: NODE_ZZ
REAL(EB), ALLOCATABLE, DIMENSION(:,:,:):: LEAK_CP,LEAK_TMP,LEAK_RHO,LEAK_RSUM,LEAK_P
REAL(EB), ALLOCATABLE, DIMENSION(:,:,:,:):: LEAK_ZZ
CHARACTER(LABEL_LENGTH), ALLOCATABLE, DIMENSION(:,:) :: NODE_DUCT_A,DUCT_NODE_A
CHARACTER(LABEL_LENGTH), ALLOCATABLE, DIMENSION(:) :: NODE_FILTER_A,DUCT_FAN_A,DUCT_AIRCOIL_A
INTEGER :: LEAK_DUCTS = 0
INTEGER, ALLOCATABLE, DIMENSION(:,:):: LEAK_PATH
CHARACTER(255), PARAMETER :: hvacid='$Id$'
CHARACTER(255), PARAMETER :: hvacrev='$Revision$'
CHARACTER(255), PARAMETER :: hvacdate='$Date$'
CHARACTER(255) :: MESSAGE
REAL(EB), ALLOCATABLE, DIMENSION(:,:) :: LHS
REAL(EB), ALLOCATABLE, DIMENSION(:) :: RHS,DPSTAR
INTEGER :: ITER,ITER_MAX=10

PUBLIC HVAC_CALC,GET_REV_hvac,READ_HVAC,PROC_HVAC,HVAC_BC_IN,FIND_NETWORKS
 
CONTAINS


SUBROUTINE READ_HVAC

! Read and process HVAC networks

USE MATH_FUNCTIONS, ONLY: GET_RAMP_INDEX,GET_TABLE_INDEX
USE MISC_FUNCTIONS, ONLY: SEARCH_CONTROLLER
INTEGER , PARAMETER :: MAX_DUCTS = 20
INTEGER :: IOS,IZERO,N_HVAC_READ,NS,N,ND,NN,I_AIRCOIL=0,I_DUCT=0,I_DUCTNODE=0,I_FAN=0 ,I_FILTER=0
REAL(EB) :: AREA,DIAMETER,XYZ(3),LOSS(MAX_DUCTS,MAX_DUCTS),VOLUME_FLOW,MAX_FLOW,MAX_PRESSURE,ROUGHNESS,LENGTH,TNOW,TAU_AC,&
            TAU_FAN,TAU_VF,FIXED_Q,CLEAN_LOSS,&
            COOLANT_MASS_FLOW,COOLANT_SPECIFIC_HEAT,COOLANT_TEMPERATURE,PERIMETER,MASS_FLOW
REAL(EB) :: LOADING(MAX_SPECIES),EFFICIENCY(MAX_SPECIES),LOADING_MULTIPLIER(MAX_SPECIES)
LOGICAL :: ROUND, SQUARE, DAMPER, REVERSE, AMBIENT
CHARACTER(LABEL_LENGTH) :: TYPE_ID,DEVC_ID,CTRL_ID,DUCT_ID(MAX_DUCTS),NODE_ID(2),VENT_ID,FAN_ID,AIRCOIL_ID,RAMP_ID,ID,FILTER_ID
CHARACTER(LABEL_LENGTH) :: SPEC_ID(MAX_SPECIES)
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
NAMELIST /HVAC/ AIRCOIL_ID,AMBIENT,AREA,CLEAN_LOSS,COOLANT_SPECIFIC_HEAT,COOLANT_MASS_FLOW,COOLANT_TEMPERATURE,CTRL_ID,DAMPER,&
                DEVC_ID,DIAMETER,&
                DUCT_ID,EFFICIENCY,FAN_ID,FILTER_ID,FIXED_Q,ID,LENGTH,LOADING,LOADING_MULTIPLIER,LOSS,MASS_FLOW,MAX_FLOW,&
                MAX_PRESSURE,&
                NODE_ID,PERIMETER,RAMP_ID,REVERSE,ROUGHNESS,SPEC_ID,TAU_AC,TAU_FAN,TAU_VF,TYPE_ID,VENT_ID,VOLUME_FLOW,XYZ

TNOW=SECOND()

N_HVAC_READ = 0
 
REWIND(LU_INPUT)
COUNT_HVAC_LOOP: DO
   CALL CHECKREAD('HVAC',LU_INPUT,IOS)
   IF (IOS==1) EXIT COUNT_HVAC_LOOP
   READ(LU_INPUT,HVAC,END=15,ERR=16,IOSTAT=IOS)
   N_HVAC_READ = N_HVAC_READ + 1
   16 IF (IOS>0) THEN
         WRITE(MESSAGE,'(A,I5)') 'ERROR: Problem with HVAC line number ',N_HVAC_READ+1
         CALL SHUTDOWN(MESSAGE)
      ENDIF
   SELECT CASE(TYPE_ID)
      CASE ('DUCT')
         N_DUCTS = N_DUCTS + 1
      CASE ('NODE')
         N_DUCTNODES = N_DUCTNODES + 1
      CASE ('FILTER')
         N_FILTERS = N_FILTERS + 1
      CASE ('FAN')
         N_FANS = N_FANS + 1
      CASE ('AIRCOIL')
         N_AIRCOILS = N_AIRCOILS + 1
   END SELECT
ENDDO COUNT_HVAC_LOOP
15 CONTINUE

LEAK_DUCTS = 0
IF (ANY(SURFACE%LEAK_PATH(1)>0).OR.ANY(SURFACE%LEAK_PATH(2)>0)) THEN 
   ALLOCATE(LEAK_PATH(0:N_ZONE,0:N_ZONE),STAT=IZERO)
   CALL ChkMemErr('HVAC','LEAK_PATH',IZERO)
   LEAK_PATH = 0
   DO NS=1,N_SURF
      IF (SURFACE(NS)%LEAK_PATH(1)>0 .OR. SURFACE(NS)%LEAK_PATH(2)>0) &
         LEAK_PATH(MINVAL(SURFACE(NS)%LEAK_PATH),MAXVAL(SURFACE(NS)%LEAK_PATH))=1
   ENDDO
   LEAK_DUCTS = SUM(LEAK_PATH)
   N_DUCTS = N_DUCTS + LEAK_DUCTS
   N_DUCTNODES = N_DUCTNODES + 2 * LEAK_DUCTS
ENDIF

IF (N_HVAC_READ > 0) HVAC_SOLVE = .TRUE.

IF ((N_DUCTS > 0 .AND. N_DUCTNODES <= 0) .OR. (N_DUCTS <= 0 .AND. N_DUCTNODES > 0)) THEN
   WRITE(MESSAGE,'(A)') 'ERROR: Must have both DUCTs and DUCTNODEs in the input file'
   CALL SHUTDOWN(MESSAGE)
ENDIF

ALLOCATE(DUCT(N_DUCTS),STAT=IZERO)
CALL ChkMemErr('HVAC','DUCT',IZERO)
ALLOCATE(DUCT_NE(N_DUCTS),STAT=IZERO)
CALL ChkMemErr('HVAC','DUCT_NE',IZERO)
DUCT_NE = 0
ALLOCATE(DUCTNODE(N_DUCTNODES),STAT=IZERO)
CALL ChkMemErr('HVAC','DUCTNODE',IZERO)
ALLOCATE(DUCTNODE_NE(N_DUCTNODES),STAT=IZERO)
CALL ChkMemErr('HVAC','DUCTNODE_NE',IZERO)
DUCTNODE_NE = 0
ALLOCATE(FILTER(N_FILTERS),STAT=IZERO)
CALL ChkMemErr('HVAC','FILTER',IZERO)
ALLOCATE(FAN(N_FANS),STAT=IZERO)
CALL ChkMemErr('HVAC','FAN',IZERO)
ALLOCATE(AIRCOIL(N_AIRCOILS),STAT=IZERO)
CALL ChkMemErr('HVAC','AIRCOIL',IZERO)

!Temp arrays for input processing
ALLOCATE(DUCT_NODE_A(N_DUCTS,2),STAT=IZERO)
CALL ChkMemErr('HVAC','NODE_DUCTS',IZERO)
ALLOCATE(NODE_DUCT_A(N_DUCTNODES,MAX_DUCTS),STAT=IZERO)
CALL ChkMemErr('HVAC','NODE_DUCTS',IZERO)
ALLOCATE(NODE_FILTER_A(N_DUCTNODES),STAT=IZERO)
CALL ChkMemErr('HVAC','NODE_DUCTS',IZERO)
ALLOCATE(DUCT_FAN_A(N_DUCTS),STAT=IZERO)
CALL ChkMemErr('HVAC','DUCT_FAN',IZERO)
ALLOCATE(DUCT_AIRCOIL_A(N_DUCTS),STAT=IZERO)
CALL ChkMemErr('HVAC','DUCT_AIRCOIL',IZERO)

REWIND(LU_INPUT)
DO NN=1,N_HVAC_READ
   CALL SET_HVAC_DEFAULTS
   READ(LU_INPUT,HVAC)
   SELECT CASE (TYPE_ID)
      CASE('DUCT')
         I_DUCT = I_DUCT + 1
         DU=> DUCT(I_DUCT)
         DU%ID   = ID
         IF (DIAMETER <= 0._EB .AND. AREA <= 0._EB .AND. PERIMETER <= 0._EB) THEN
            WRITE(MESSAGE,'(A,I5)') 'ERROR: Duct has no AREA, DIAMETER, or PERIMTER, HVAC line number ',NN
            CALL SHUTDOWN(MESSAGE)
         ENDIF
         IF (DIAMETER > 0._EB) THEN
            IF (PERIMETER > 0._EB) THEN
              WRITE(MESSAGE,'(A,I5)') 'ERROR: Duct cannot input both PERIMETER and DIAMETER, HVAC line number ',NN
              CALL SHUTDOWN(MESSAGE)
            ENDIF
            AREA = 0.5_EB*PIO2*DIAMETER**2
         ENDIF
         IF (AREA > 0._EB) THEN
            IF (DIAMETER >  0._EB .AND. PERIMETER >  0._EB) THEN               
              WRITE(MESSAGE,'(A,I5)') 'ERROR: Duct cannot input both PERIMETER and DIAMETER with AREA, HVAC line number ',NN
              CALL SHUTDOWN(MESSAGE)
            ENDIF
            IF (PERIMETER <= 0._EB) DIAMETER = SQRT(2._EB*AREA/PIO2)
            IF (PERIMETER >  0._EB) DIAMETER = 4._EB*AREA/PERIMETER
         ENDIF  
         IF (PERIMETER > 0._EB .AND. AREA <= 0._EB) THEN
            WRITE(MESSAGE,'(A,I5)') 'ERROR: Duct cannot have PERIMETER without AREA, HVAC line number ',NN
            CALL SHUTDOWN(MESSAGE)
         ENDIF
         DU%AREA_INITIAL = AREA
         DU%AREA = AREA
         DU%DIAMETER = DIAMETER
         DU%LENGTH = LENGTH         
         DU%REVERSE = REVERSE
         IF (N_TRACKED_SPECIES > 0) THEN
            ALLOCATE(DU%ZZ(N_TRACKED_SPECIES))
            DU%ZZ(1:N_TRACKED_SPECIES) = SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
         ENDIF
         DU%LOSS(1:2) = MAX(0._EB,LOSS(1:2,1))
         IF (CTRL_ID /='null' .AND. DEVC_ID /='null') THEN
            WRITE(MESSAGE,'(A,I5)') 'ERROR: Can only specify one of CTRL_ID or DEVC_ID, HVAC line number ',NN
            CALL SHUTDOWN(MESSAGE)
         ENDIF
         IF (DAMPER .AND. (FAN_ID /='null' .OR. AIRCOIL_ID /='null') .OR. &
             FAN_ID/='null' .AND. (DAMPER .OR. AIRCOIL_ID /='null') .OR. &
             AIRCOIL_ID/='null' .AND. (DAMPER .OR. FAN_ID /='null')) THEN
            WRITE(MESSAGE,'(A,I5)') 'ERROR: Duct can only have one of damper, fan or aircoil, HVAC line number ',NN
            CALL SHUTDOWN(MESSAGE)
         ENDIF
         IF (FAN_ID/='null' .AND. N_FANS<=0) THEN
            WRITE(MESSAGE,'(A,I5)') 'ERROR: Duct has fan specied but no fans have been defined, HVAC line number ',NN
            CALL SHUTDOWN(MESSAGE)
         ENDIF
         DU%DAMPER = DAMPER
         DUCT_AIRCOIL_A(I_DUCT) = AIRCOIL_ID
         DUCT_FAN_A(I_DUCT) = FAN_ID
         IF (CTRL_ID /= 'null' .OR. DEVC_ID /= 'null') &
            CALL SEARCH_CONTROLLER('HVAC',CTRL_ID,DEVC_ID,DU%DEVC_INDEX,DU%CTRL_INDEX,NN)
         IF (DAMPER) THEN
            IF (DU%DEVC_INDEX > 0) THEN
                DU%DAMPER_OPEN = DEVICE(DU%DEVC_INDEX)%INITIAL_STATE                
            ELSEIF (DU%CTRL_INDEX > 0) THEN
                DU%DAMPER_OPEN = CONTROL(DU%CTRL_INDEX)%INITIAL_STATE                
            ELSE
                DU%DAMPER_OPEN = .TRUE.
            ENDIF
            IF (.NOT. DU%DAMPER_OPEN) DU%AREA = 0._EB
         ELSEIF (FAN_ID /='null') THEN
            IF (DU%DEVC_INDEX > 0) THEN
                DU%FAN_OPERATING = DEVICE(DU%DEVC_INDEX)%INITIAL_STATE                
            ELSEIF (DU%CTRL_INDEX > 0) THEN
                DU%FAN_OPERATING = CONTROL(DU%CTRL_INDEX)%INITIAL_STATE                
            ELSE
                DU%FAN_OPERATING = .TRUE.
            ENDIF
            IF (DU%FAN_OPERATING) DU%FAN_ON_TIME = T_BEGIN
            IF (.NOT. DU%FAN_OPERATING) DU%DP_FAN = 0._EB
         ELSEIF (AIRCOIL_ID /='null') THEN
            IF (DU%DEVC_INDEX > 0) THEN
                DU%COIL_OPERATING = DEVICE(DU%DEVC_INDEX)%INITIAL_STATE                
            ELSEIF (DU%CTRL_INDEX > 0) THEN
                DU%COIL_OPERATING = CONTROL(DU%CTRL_INDEX)%INITIAL_STATE                
            ELSE
                DU%COIL_OPERATING = .TRUE.
            ENDIF
            IF (DU%COIL_OPERATING) DU%COIL_ON_TIME = T_BEGIN
         ENDIF  
         DUCT_NODE_A(I_DUCT,:) = NODE_ID
         IF (VOLUME_FLOW < 1.E7_EB .AND. MASS_FLOW < 1.E7_EB) THEN
            WRITE(MESSAGE,'(A,A)') 'ERROR: Duct has both MASS_FLOW and VOLUME_FLOW defined.  DUCT ID:',TRIM(DU%ID)
            CALL SHUTDOWN(MESSAGE)
         ENDIF
         DU%MASS_FLOW_INITIAL = MASS_FLOW
         DU%VOLUME_FLOW_INITIAL = VOLUME_FLOW
         DU%ROUGHNESS = ROUGHNESS
         DU%TAU = TAU_VF
         IF (TAU_VF > 0._EB) DU%RAMP_INDEX = TANH_RAMP 
         IF (TAU_VF < 0._EB) DU%RAMP_INDEX = TSQR_RAMP
         IF (RAMP_ID /= 'null') CALL GET_RAMP_INDEX(RAMP_ID,'DUCT',DU%RAMP_INDEX)
         
      CASE('NODE')
         I_DUCTNODE = I_DUCTNODE + 1
         NODE_DUCT_A(I_DUCTNODE,:) = DUCT_ID   
         NODE_FILTER_A(I_DUCTNODE) = FILTER_ID      
         DN => DUCTNODE(I_DUCTNODE)
         DN%ID = ID
         DN%VENT_ID = VENT_ID
         DN%XYZ      = XYZ
         DN%AMBIENT  = AMBIENT
         DO ND = 1, MAX_DUCTS
            IF (NODE_DUCT_A(I_DUCTNODE,ND) == 'null') EXIT
            DN%N_DUCTS=ND
         ENDDO
         IF (DN%N_DUCTS > 2 .AND. TRIM(FILTER_ID)/='null') THEN
            WRITE(MESSAGE,'(A,A)') 'ERROR: Ductnode with a filter must have <=2 ducts. Ductnode ID: ',TRIM(DN%ID)
            CALL SHUTDOWN(MESSAGE)         
         ENDIF
         ALLOCATE(DN%LOSS_ARRAY(MAX(2,DN%N_DUCTS),MAX(2,DN%N_DUCTS)))
         DN%LOSS_ARRAY = 0._EB
         IF (DN%N_DUCTS >=2) THEN
            DN%LOSS_ARRAY = LOSS(1:DN%N_DUCTS,1:DN%N_DUCTS)
         ELSE
            DN%LOSS_ARRAY(1,2) = LOSS(1,1)
            DN%LOSS_ARRAY(2,1) = LOSS(2,1)
         ENDIF
         IF (TRIM(FILTER_ID)/='null') THEN
            ALLOCATE(DN%FILTER_LOADING(1:N_TRACKED_SPECIES,3))
            DN%FILTER_LOADING = 0._EB
            SPEC_LOOP1: DO N=1,N_TRACKED_SPECIES
               IF (TRIM(SPEC_ID(N))=='null') EXIT SPEC_LOOP1
               DO NS = 1,N_TRACKED_SPECIES
                  IF (TRIM(SPECIES_MIXTURE(NS)%ID)==TRIM(SPEC_ID(N))) THEN
                     DN%FILTER_LOADING(NS,1) = LOADING(N)
                     EXIT
                  ENDIF
                  IF (NS==N_TRACKED_SPECIES) THEN
                     WRITE(MESSAGE,'(A,A,A,A,A)') 'ERROR: Problem with DUCTNODE:',TRIM(ID),' SPEC ',TRIM(SPEC_ID(N)),' not found'
                     CALL SHUTDOWN(MESSAGE)
                  ENDIF   
               ENDDO         
            ENDDO SPEC_LOOP1
         ENDIF
         
      CASE('FAN')
         I_FAN = I_FAN + 1
         FAN(I_FAN)%ID = ID
         FAN(I_FAN)%OFF_LOSS = LOSS(1,1)
         FAN(I_FAN)%FAN_RAMP = RAMP_ID
         FAN(I_FAN)%VOL_FLOW = VOLUME_FLOW
         FAN(I_FAN)%MAX_PRES = MAX_PRESSURE
         FAN(I_FAN)%MAX_FLOW = MAX_FLOW
         FAN(I_FAN)%TAU = TAU_FAN
         IF (TAU_FAN > 0._EB) FAN(I_FAN)%SPIN_INDEX = TANH_RAMP 
         IF (TAU_FAN < 0._EB) FAN(I_FAN)%SPIN_INDEX = TSQR_RAMP
         IF (RAMP_ID /= 'null') CALL GET_RAMP_INDEX(RAMP_ID,'FAN',FAN(I_FAN)%RAMP_INDEX)
         IF(( (MAX_FLOW<1.E6_EB .OR. MAX_PRESSURE<1.E6_EB) .AND. (VOLUME_FLOW<1.E6_EB .OR. RAMP_ID/='null')))THEN !.OR. &
            WRITE(MESSAGE,'(A,I5)') 'ERROR: FAN can only be one of constant volume, quadratic or ramp, HVAC line number ',NN
            CALL SHUTDOWN(MESSAGE)
         ENDIF
         IF ((MAX_PRESSURE<1.E6_EB .AND. MAX_FLOW>1.E6_EB) .OR. (MAX_PRESSURE>1.E6_EB .AND. MAX_FLOW<1.E6_EB)) THEN
            WRITE(MESSAGE,'(A,I5)') 'ERROR: IF one of MAX_PRESSURE or MAX_FLOW given, both must be specified, HVAC line number '&
                                    ,NN
            CALL SHUTDOWN(MESSAGE)
         ENDIF
         IF (VOLUME_FLOW < 1.E6_EB) THEN
            FAN(I_FAN)%FAN_TYPE = 1
         ELSEIF(RAMP_ID/='null') THEN
            FAN(I_FAN)%FAN_TYPE = 3
         ELSE
            FAN(I_FAN)%FAN_TYPE = 2            
         ENDIF
                
      CASE('FILTER')         
         I_FILTER = I_FILTER + 1
         FILTER(I_FILTER)%ID = ID
         FILTER(I_FILTER)%CLEAN_LOSS = CLEAN_LOSS
         IF (TRIM(RAMP_ID)/='null') CALL GET_RAMP_INDEX(RAMP_ID,'FILTER',FILTER(I_FILTER)%RAMP_INDEX)
         ALLOCATE(FILTER(I_FILTER)%EFFICIENCY(1:N_TRACKED_SPECIES))
         FILTER(I_FILTER)%EFFICIENCY = 0._EB
         ALLOCATE(FILTER(I_FILTER)%MULTIPLIER(1:N_TRACKED_SPECIES))
         FILTER(I_FILTER)%MULTIPLIER = 0._EB                  
         FILTER(I_FILTER)%LOADING_LOSS = LOSS(1,1)
         SPEC_LOOP2: DO N=1,N_TRACKED_SPECIES
            IF (TRIM(SPEC_ID(N))=='null') EXIT SPEC_LOOP2
            DO NS = 1,N_TRACKED_SPECIES
               IF (TRIM(SPECIES_MIXTURE(NS)%ID)==TRIM(SPEC_ID(N))) THEN
                  FILTER(I_FILTER)%EFFICIENCY(NS)   = EFFICIENCY(N)
                  FILTER(I_FILTER)%MULTIPLIER(NS) = LOADING_MULTIPLIER(N)                  
                  EXIT
               ENDIF
               IF (NS==N_TRACKED_SPECIES) THEN
                  WRITE(MESSAGE,'(A,A,A,A,A)') 'ERROR: Problem with FILTER:',TRIM(ID),' SPEC ',TRIM(SPEC_ID(N)),' not found'
                  CALL SHUTDOWN(MESSAGE)
               ENDIF   
            ENDDO         
         ENDDO SPEC_LOOP2         
      CASE('AIRCOIL')
         I_AIRCOIL = I_AIRCOIL+1
         AIRCOIL(I_AIRCOIL)%COOLANT_SPECIFIC_HEAT   = COOLANT_SPECIFIC_HEAT*1000._EB
         AIRCOIL(I_AIRCOIL)%COOLANT_MASS_FLOW = COOLANT_MASS_FLOW
         AIRCOIL(I_AIRCOIL)%COOLANT_TEMPERATURE = COOLANT_TEMPERATURE+TMPM
         AIRCOIL(I_AIRCOIL)%EFFICIENCY   = EFFICIENCY(1)
         AIRCOIL(I_AIRCOIL)%FIXED_Q      = FIXED_Q*1000._EB
         AIRCOIL(I_AIRCOIL)%ID           = ID
         AIRCOIL(I_AIRCOIL)%TAU          = TAU_AC
         IF (TAU_AC > 0._EB) AIRCOIL(I_AIRCOIL)%RAMP_INDEX = TANH_RAMP 
         IF (TAU_AC < 0._EB) AIRCOIL(I_AIRCOIL)%RAMP_INDEX = TSQR_RAMP         
         AIRCOIL(I_AIRCOIL)%RAMP_ID      = RAMP_ID         
         IF (RAMP_ID /= 'null') CALL GET_RAMP_INDEX(RAMP_ID,'DUCT',AIRCOIL(I_AIRCOIL)%RAMP_INDEX)         
   END SELECT   
ENDDO

TUSED(16,1)=TUSED(16,1)+SECOND()-TNOW

RETURN

CONTAINS

SUBROUTINE SET_HVAC_DEFAULTS

AIRCOIL_ID   = 'null'
AMBIENT      = .FALSE.
AREA         = -1._EB
COOLANT_SPECIFIC_HEAT   = 4186._EB
COOLANT_MASS_FLOW = -1.E10_EB
COOLANT_TEMPERATURE = 293.15_EB
EFFICIENCY   = 1.0_EB
CLEAN_LOSS   = 0._EB
CTRL_ID      = 'null'
DAMPER       = .FALSE.
DEVC_ID      = 'null'
DIAMETER     = -1._EB
DUCT_ID      = 'null'
FAN_ID       = 'null'
FIXED_Q      = -1.E10_EB
FILTER_ID    = 'null'
LENGTH       = 1._EB
LOADING      = 0._EB
LOADING_MULTIPLIER = 1._EB
LOSS         = 0._EB
MASS_FLOW    = 1.E7_EB
MAX_FLOW     = 1.E7_EB
MAX_PRESSURE = 1.E7_EB
NODE_ID      = 'null'
PERIMETER    = -1._EB
RAMP_ID      = 'null'
REVERSE      = .FALSE.
ROUGHNESS    = 0._EB
ROUND        = .TRUE.
SPEC_ID      = 'null'
SQUARE       = .FALSE.
TYPE_ID      = 'null'
TAU_AC       = 1._EB
TAU_FAN      = 1._EB
TAU_VF       = 1._EB
VENT_ID      = 'null'
VOLUME_FLOW  = 1.E7_EB
XYZ          = 0.

RETURN

END SUBROUTINE SET_HVAC_DEFAULTS

END SUBROUTINE READ_HVAC


SUBROUTINE PROC_HVAC
USE PHYSICAL_FUNCTIONS, ONLY: GET_AVERAGE_SPECIFIC_HEAT
INTEGER :: I1,I2,J1,J2,K1,K2,IOR
INTEGER :: IZERO,NS,N,ND,ND2,NM,NN,NF,NV
REAL(EB) :: CP,ZZ_GET(0:N_TRACKED_SPECIES),TNOW
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
TNOW=SECOND()

IF (LEAK_DUCTS > 0) THEN
   HVAC_SOLVE = .TRUE.
   CALL LEAKAGE_HVAC
   DUCT(N_DUCTS - LEAK_DUCTS + 1:N_DUCTS)%LEAKAGE=.TRUE.
   DUCTNODE(N_DUCTNODES - 2*LEAK_DUCTS + 1:N_DUCTNODES)%LEAKAGE=.TRUE.
   ALLOCATE(LEAK_TMP(0:N_ZONE,0:N_ZONE,1:NMESHES),STAT=IZERO)
   CALL ChkMemErr('HVAC','LEAK_TMP',IZERO)
   LEAK_TMP = TMPA
   ALLOCATE(LEAK_RHO(0:N_ZONE,0:N_ZONE,1:NMESHES),STAT=IZERO)
   CALL ChkMemErr('HVAC','LEAK_RHO',IZERO)
   LEAK_RHO = RHOA
   ALLOCATE(LEAK_RSUM(0:N_ZONE,0:N_ZONE,1:NMESHES),STAT=IZERO)
   CALL ChkMemErr('HVAC','LEAK_RSUM',IZERO)
   LEAK_RSUM = RSUM0
   ALLOCATE(LEAK_CP(0:N_ZONE,0:N_ZONE,1:NMESHES),STAT=IZERO)
   CALL ChkMemErr('HVAC','LEAK_CP',IZERO)
   IF (N_TRACKED_SPECIES > 0) THEN
      ALLOCATE(LEAK_ZZ(0:N_ZONE,0:N_ZONE,1:N_TRACKED_SPECIES,1:NMESHES),STAT=IZERO)
      CALL ChkMemErr('HVAC','LEAK_ZZ',IZERO)
      ZZ_GET(1:N_TRACKED_SPECIES) =  SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
      DO NS=1,N_TRACKED_SPECIES
         LEAK_ZZ(:,:,NS,:) = ZZ_GET(NS)
      ENDDO
   ENDIF
   CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CP,TMPA)      
   LEAK_CP = CP
   ALLOCATE(LEAK_P(0:N_ZONE,0:N_ZONE,1:NMESHES),STAT=IZERO)
   LEAK_P = P_INF
   CALL ChkMemErr('HVAC','LEAK_P',IZERO)   
ENDIF

DO ND = 1, N_DUCTS
   DU => DUCT(ND)
   IF (DU%LEAKAGE) CYCLE
   DO N = 1, ND
      IF (N==ND) CYCLE
      IF (TRIM(DU%ID)==TRIM(DUCT(N)%ID)) THEN
         WRITE(MESSAGE,'(A,A)') 'ERROR: Two ducts with the same ID. DUCT ID:',TRIM(DU%ID)
         CALL SHUTDOWN(MESSAGE)
      ENDIF
   ENDDO
   DO NN = 1, N_DUCTNODES 
      IF(TRIM(DUCTNODE(NN)%ID) == TRIM(DUCT_NODE_A(ND,1))) THEN
        DU%NODE_INDEX(1) = NN
        DU%X(1) =DUCTNODE(NN)%XYZ(1)
        DU%Y(1) =DUCTNODE(NN)%XYZ(2)
        DU%Z(1) =DUCTNODE(NN)%XYZ(3)
        CYCLE
      ENDIF
      IF(TRIM(DUCTNODE(NN)%ID) == TRIM(DUCT_NODE_A(ND,2))) THEN
        DU%NODE_INDEX(2) = NN
        DU%X(2) =DUCTNODE(NN)%XYZ(1)
        DU%Y(2) =DUCTNODE(NN)%XYZ(2)
        DU%Z(2) =DUCTNODE(NN)%XYZ(3)
        CYCLE
      ENDIF
      IF (DU%NODE_INDEX(1) > 0 .AND. DU%NODE_INDEX(2) > 0) EXIT
   ENDDO
   IF (DU%NODE_INDEX(1) <= 0) THEN
      WRITE(MESSAGE,'(A,I3,A,A)') 'ERROR: Duct node 1 not located, DUCT ',ND,', DUCT ID:',TRIM(DU%ID)
      CALL SHUTDOWN(MESSAGE)
   ENDIF
   IF (DU%NODE_INDEX(2) <= 0) THEN
      WRITE(MESSAGE,'(A,I3,A,A)') 'ERROR: Duct node 2 not located, DUCT ',ND,', DUCT ID:',TRIM(DU%ID)
      CALL SHUTDOWN(MESSAGE)
   ENDIF
   IF (DU%NODE_INDEX(1) == DU%NODE_INDEX(2)) THEN
      WRITE(MESSAGE,'(A,I3,A,A)') 'ERROR: Duct node 1 cannot be the same as duct node 2, DUCT ',ND,', DUCT ID:',TRIM(DU%ID)
      CALL SHUTDOWN(MESSAGE)
   ENDIF
   IF (DUCT_FAN_A(ND)/='null') THEN
      DU%DP_FAN = 0._EB
      DO NF = 1, N_FANS
         IF(TRIM(FAN(NF)%ID) == TRIM(DUCT_FAN_A(ND))) THEN
            DU%FAN_INDEX = NF
            EXIT
         ENDIF
      ENDDO
      IF (DU%FAN_INDEX <= 0) THEN
         WRITE(MESSAGE,'(A,I3,A,A)') 'ERROR: Fan not located for DUCT ',ND,', DUCT ID:',TRIM(DU%ID)
         CALL SHUTDOWN(MESSAGE)
      ENDIF
   ENDIF   
   IF (DUCT_AIRCOIL_A(ND)/='null') THEN
      DU%COIL_Q = 0._EB
      DO NF = 1, N_AIRCOILS
         IF(TRIM(AIRCOIL(NF)%ID) == TRIM(DUCT_AIRCOIL_A(ND))) THEN
            DU%AIRCOIL_INDEX = NF
            EXIT
         ENDIF
      ENDDO
      IF (DU%AIRCOIL_INDEX <= 0) THEN
         WRITE(MESSAGE,'(A,I3,A,A)') 'ERROR: Aircoil not located for DUCT ',ND,', DUCT ID:',TRIM(DU%ID)
         CALL SHUTDOWN(MESSAGE)
      ENDIF
   ENDIF     
ENDDO

NODE_LOOP: DO NN = 1, N_DUCTNODES
   DN => DUCTNODE(NN)
   DO N = 1, NN
      IF (N==NN) CYCLE
      IF (TRIM(DN%ID)==TRIM(DUCTNODE(N)%ID)) THEN
         WRITE(MESSAGE,'(A,A)') 'ERROR: Two duct node with the same ID. DUCTNODE ID:',TRIM(DN%ID)
         CALL SHUTDOWN(MESSAGE)
      ENDIF
   ENDDO
   
   IF (DN%LEAKAGE) THEN
      DN%TMP  = TMPA
      DN%RHO  = RHOA
      DN%P    = P_INF
      DN%RSUM = RSUM0
      IF (N_TRACKED_SPECIES > 0) THEN
         ALLOCATE(DN%ZZ(N_TRACKED_SPECIES))
         DN%ZZ(1:N_TRACKED_SPECIES) = SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
         ALLOCATE(DN%ZZ_V(N_TRACKED_SPECIES))            
         DN%ZZ_V(1:N_TRACKED_SPECIES) = SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
         ZZ_GET(1:N_TRACKED_SPECIES) = DN%ZZ_V(1:N_TRACKED_SPECIES)
      ENDIF
      CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,DN%CP,TMPA)      
      DN%TMP_V  = DN%TMP
      DN%RSUM_V = DN%RSUM
      DN%CP_V   = DN%CP
      DN%RHO_V  = DN%RHO
      CYCLE NODE_LOOP
   ENDIF   
   IF (DN%VENT_ID /= 'null') THEN
      MESH_LOOP: DO NM = 1, NMESHES
         NODE_VENT_LOOP:DO NV = 1, MESHES(NM)%N_VENT
            IF(MESHES(NM)%VENTS(NV)%ID == DN%VENT_ID) THEN
               IF (MESHES(NM)%VENTS(NV)%SURF_INDEX /= HVAC_SURF_INDEX) THEN
                  WRITE(MESSAGE,'(A,A)') 'ERROR: DUCTNODE attached to VENT without SURF_ID HVAC for VENT ID ',&
                                          MESHES(NM)%VENTS(NV)%ID
               ENDIF
               DN%MESH_INDEX = NM
               DN%VENT_INDEX = NV
               IOR = MESHES(NM)%VENTS(NV)%IOR
               I1 = MESHES(NM)%VENTS(NV)%I1
               I2 = MESHES(NM)%VENTS(NV)%I2
               J1 = MESHES(NM)%VENTS(NV)%J1
               J2 = MESHES(NM)%VENTS(NV)%J2
               K1 = MESHES(NM)%VENTS(NV)%K1
               K2 = MESHES(NM)%VENTS(NV)%K2
               MESHES(NM)%VENTS(NV)%NODE_INDEX=NN
               DN%XYZ(1) = 0.5_EB*(MESHES(NM)%X(I1)+MESHES(NM)%X(I2))
               DN%XYZ(2) = 0.5_EB*(MESHES(NM)%Y(J1)+MESHES(NM)%Y(J2))
               DN%XYZ(3) = 0.5_EB*(MESHES(NM)%Z(K1)+MESHES(NM)%Z(K2))
               EXIT NODE_VENT_LOOP
            ENDIF
         ENDDO NODE_VENT_LOOP
      ENDDO MESH_LOOP
   ENDIF
   IF (DN%VENT_INDEX > 0 .AND. DN%AMBIENT) THEN
      WRITE(MESSAGE,'(A,I5,A,A)') 'ERROR: DUCTNODE cannot be AMBIENT and have an assigned VENT_ID, DUCTNODE ',NN,&
                                  ', DUCTNODE ID:',TRIM(DN%ID)
      CALL SHUTDOWN(MESSAGE)
   ENDIF
   IF (DN%N_DUCTS == 1 .AND. DN%VENT_INDEX < 0 .AND. .NOT. DN%AMBIENT) THEN
      WRITE(MESSAGE,'(A,I5,A,A)') 'ERROR: Internal DUCTNODE must have at least two attached ducts, DUCTNODE ',NN,&
                                  ', DUCTNODE ID:',TRIM(DN%ID)
      CALL SHUTDOWN(MESSAGE)
   ENDIF  
   IF (DN%N_DUCTS> 1 .AND. (DN%AMBIENT .OR. DN%VENT_INDEX > 0) ) THEN
      WRITE(MESSAGE,'(A,I5,A,A)') 'ERROR: External DUCTNODE can only have one attached duct, DUCTNODE ',NN,&
                                  ', DUCTNODE ID:',TRIM(DN%ID)
      CALL SHUTDOWN(MESSAGE)
   ENDIF  
   ALLOCATE(DN%DUCT_INDEX(DN%N_DUCTS))
   ALLOCATE(DN%DIR(DN%N_DUCTS))
   DN%DUCT_INDEX = -1
   DO ND = 1,DN%N_DUCTS
      DO ND2 = 1, N_DUCTS
         IF (NODE_DUCT_A(NN,ND) == DUCT(ND2)%ID) THEN
            DN%DUCT_INDEX(ND) = ND2
            IF (DUCT(ND2)%NODE_INDEX(1)==NN) THEN
               DN%DIR(ND) = -1._EB
            ELSE
               DN%DIR(ND) = 1._EB
            ENDIF
            CYCLE
         ENDIF
      ENDDO
      IF (DN%DUCT_INDEX(ND)==-1) THEN
         WRITE(MESSAGE,'(A,I5,A,I5,A,A)') 'ERROR: DUCT ',ND,' not found for DUCTNODE ',NN,&
                                  ', DUCTNODE ID:',TRIM(DN%ID)
         CALL SHUTDOWN(MESSAGE)
      ENDIF  
   ENDDO

   !Initialize duct node properties
   IF (N_TRACKED_SPECIES > 0) THEN
      ALLOCATE(DN%ZZ(N_TRACKED_SPECIES))
      DN%ZZ(1:N_TRACKED_SPECIES) = SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
      ALLOCATE(DN%ZZ_V(N_TRACKED_SPECIES))            
      DN%ZZ_V(1:N_TRACKED_SPECIES) = SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
   ENDIF
   DN%RSUM   = RSUM0
   IF (STRATIFICATION) THEN      
      DN%TMP  = TMPA + LAPSE_RATE*DN%XYZ(3)    
      IF (ABS(LAPSE_RATE)>TWO_EPSILON_EB) THEN      
         DN%P = P_INF*(DN%TMP/TMPA)**(GVEC(3)/RSUM0/LAPSE_RATE)
      ELSE
         DN%P = P_INF*EXP(GVEC(3)*(DN%XYZ(3)-GROUND_LEVEL)/(RSUM0*TMPA))
      ENDIF      
      DN%RHO   =  DN%P/(TMPA*RSUM0)
   ELSE
      DN%TMP  = TMPA
      DN%P      = P_INF
      DN%RHO    = RHOA
   ENDIF
   IF (N_TRACKED_SPECIES > 0) ZZ_GET(1:N_TRACKED_SPECIES) = DN%ZZ_V(1:N_TRACKED_SPECIES)
   CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,DN%CP,TMPA)      
   DN%TMP_V  = DN%TMP
   DN%RSUM_V = DN%RSUM
   DN%CP_V   = DN%CP
   DN%RHO_V  = DN%RHO
   IF(TRIM(NODE_FILTER_A(NN))/='null') THEN
      DO N = 1,N_FILTERS
         IF(TRIM(NODE_FILTER_A(NN))==TRIM(FILTER(N)%ID)) THEN
            DN%FILTER_INDEX = N
            EXIT
         ENDIF
         IF (N==N_FILTERS) THEN
            WRITE(MESSAGE,'(A,A,A,A,A)') 'ERROR: Problem with DUCTNODE:',TRIM(DN%ID), &
                                         ',FILTER ',TRIM(NODE_FILTER_A(NN)),' not found'
            CALL SHUTDOWN(MESSAGE)
         ENDIF
      ENDDO
   ENDIF
ENDDO NODE_LOOP

!Temp arrays for input processing
IF (ALLOCATED(DUCT_NODE_A)) DEALLOCATE(DUCT_NODE_A)
IF (ALLOCATED(NODE_DUCT_A)) DEALLOCATE(NODE_DUCT_A)
IF (ALLOCATED(NODE_FILTER_A)) DEALLOCATE(NODE_FILTER_A)
IF (ALLOCATED(DUCT_FAN_A)) DEALLOCATE(DUCT_FAN_A)

CALL DETERMINE_FIXED_ELEMENTS(0._EB)

ALLOCATE(NODE_P(1:N_DUCTNODES,1:NMESHES))
ALLOCATE(NODE_TMP(1:N_DUCTNODES,1:NMESHES))
ALLOCATE(NODE_RHO(1:N_DUCTNODES,1:NMESHES))
ALLOCATE(NODE_RSUM(1:N_DUCTNODES,1:NMESHES))
ALLOCATE(NODE_CP(1:N_DUCTNODES,1:NMESHES))
IF (N_TRACKED_SPECIES > 0) ALLOCATE(NODE_ZZ(1:N_DUCTNODES,1:N_TRACKED_SPECIES,1:NMESHES))

DO NN=1,N_DUCTNODES
   NODE_P(NN,1:NMESHES)    = DUCTNODE(NN)%P
   NODE_TMP(NN,1:NMESHES)  = DUCTNODE(NN)%TMP
   NODE_RHO(NN,1:NMESHES)  = DUCTNODE(NN)%RHO
   NODE_CP(NN,1:NMESHES)   = DUCTNODE(NN)%CP
   NODE_RSUM(NN,1:NMESHES) = DUCTNODE(NN)%RSUM   
   IF (N_TRACKED_SPECIES > 0) THEN   
      DO N=1,N_TRACKED_SPECIES
         NODE_ZZ(NN,N,1:NMESHES) = SPECIES_MIXTURE(N)%ZZ0
      ENDDO
   ENDIF
ENDDO

ALLOCATE(DUCT_MF(1:N_DUCTS,1:NMESHES))
DUCT_MF(1:N_DUCTS,1:NMESHES) = 0._EB

TUSED(16,1)=TUSED(16,1)+SECOND()-TNOW

RETURN

END SUBROUTINE PROC_HVAC


SUBROUTINE HVAC_CALC(T)
!Solve for flows in the HVAC networks
INTEGER :: NNE,NN
REAL(EB), INTENT(INOUT) :: T
LOGICAL :: CHANGE=.TRUE.
TYPE(NETWORK_TYPE), POINTER:: NE=>NULL()

IF (CORRECTOR) THEN
   DUCT%VEL(OLD) = DUCT%VEL(NEW)
   DO NN=1,N_DUCTNODES
      IF(DUCTNODE(NN)%FILTER_INDEX > 0) DUCTNODE(NN)%FILTER_LOADING(:,OLD)=DUCTNODE(NN)%FILTER_LOADING(:,NEW)
   ENDDO
   RETURN
ENDIF

CALL COLLAPSE_HVAC_BC
CALL FIND_NETWORKS(CHANGE,T)

ITER = 0
DO NNE = 1, N_NETWORKS
   NE =>NETWORK(NNE)
   CALL SET_GUESS(NNE,T)  
ENDDO

IF (N_ZONE >0) ALLOCATE(DPSTAR(1:N_ZONE))

CALL DPSTARCALC
DUCTNODE%P = DUCTNODE%P - P_INF 
DO NNE = 1, N_NETWORKS
   NE =>NETWORK(NNE)
   IF (NE%N_MATRIX > 0) THEN 
      ITER = 0
      ALLOCATE(LHS(NE%N_MATRIX,NE%N_MATRIX))
      ALLOCATE(RHS(NE%N_MATRIX))
      DO WHILE (ITER < ITER_MAX)
         LHS = 0._EB
         RHS = 0._EB
         CALL SET_DONOR(NNE)
         CALL UPDATE_LOSS(NNE)
         IF (N_AIRCOILS > 0) CALL COIL_UPDATE(T)
         CALL RHSNODE(NNE)         
         CALL RHSDUCT(NNE)   
         CALL LHSNODE(NNE)
         CALL LHSDUCT(NNE)
         CALL MATRIX_SOLVE(NNE)
         CALL HVAC_UPDATE(NNE)
         CALL CONVERGENCE_CHECK(NNE)
         ITER = ITER + 1
         IF (ITER < ITER_MAX) CALL SET_GUESS(NNE,T)        
      ENDDO
      DEALLOCATE(LHS)
      DEALLOCATE(RHS)
   ELSE
      CALL SET_DONOR(NNE)
      IF (N_AIRCOILS > 0) CALL COIL_UPDATE(T)
      CALL HVAC_UPDATE(NNE)
   ENDIF
ENDDO

DUCTNODE%P = DUCTNODE%P + P_INF 

CALL UPDATE_NODE_BC

IF (ALLOCATED(DPSTAR)) DEALLOCATE(DPSTAR)

END SUBROUTINE HVAC_CALC


SUBROUTINE MATRIX_SOLVE(NNE)
USE MATH_FUNCTIONS,ONLY : GAUSSJ
INTEGER :: NNE,IERR,ND,NN
TYPE(NETWORK_TYPE), POINTER :: NE=>NULL()
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()

NE =>NETWORK(NNE)
CALL GAUSSJ(LHS,NE%N_MATRIX,NE%N_MATRIX,RHS,1,1,IERR)
DO ND = 1,NE%N_DUCTS
   DU=>DUCT(NE%DUCT_INDEX(ND))
   IF (DU%FIXED .OR. DU%AREA < TWO_EPSILON_EB) CYCLE
   DU%VEL(NEW) = RHS(NE%MATRIX_INDEX(ND))
ENDDO
DO NN = 1,NE%N_DUCTNODES
   DN=>DUCTNODE(NE%NODE_INDEX(NN))
   IF (DN%FIXED) CYCLE
   DN%P = RHS(NE%MATRIX_INDEX(NE%N_DUCTS+NN))
ENDDO

END SUBROUTINE MATRIX_SOLVE


SUBROUTINE HVAC_UPDATE(NNE)

!Iterate duct network to update all ducts and nodes

USE COMP_FUNCTIONS, ONLY: SECOND
USE PHYSICAL_FUNCTIONS, ONLY : GET_AVERAGE_SPECIFIC_HEAT,GET_SPECIFIC_GAS_CONSTANT
REAL(EB) :: TNOW,MTOT,ETOT,VTOT,ZZTOT(1:N_TRACKED_SPECIES),TGUESS,VFLOW,ZZ_GET(0:N_TRACKED_SPECIES),CP,CP2,DCPDT
INTEGER, INTENT(IN) :: NNE
INTEGER :: NN,ND,NS,ITMP,ITCOUNT
LOGICAL :: CYCLE_FLAG
TYPE (DUCTNODE_TYPE), POINTER :: DN=>NULL(),DN2=>NULL()
TYPE (DUCT_TYPE), POINTER :: DU=>NULL()
TYPE (NETWORK_TYPE), POINTER :: NE=>NULL()

TNOW=SECOND()
NE => NETWORK(NNE)
DUCT%UPDATED = .FALSE.
DO NN = 1,NE%N_DUCTNODES
   DN=>DUCTNODE(NE%NODE_INDEX(NN))
   DN%UPDATED = .FALSE.
   IF (DN%VENT_INDEX > 0 .OR. DN%LEAKAGE) THEN   
      DU => DUCT(DN%DUCT_INDEX(1))
      IF (DU%VEL(NEW)*DN%DIR(1) < -TWO_EPSILON_EB) DN%UPDATED = .TRUE.
   ENDIF
ENDDO
DO ND = 1,NE%N_DUCTS
   DUCT(NE%DUCT_INDEX(ND))%UPDATED = .FALSE.
ENDDO

ITER_LOOP: DO
   CYCLE_FLAG = .FALSE.
   DUCT_LOOP:DO ND = 1,NE%N_DUCTS
      DU=>DUCT(NE%DUCT_INDEX(ND))
      IF (DU%UPDATED) CYCLE DUCT_LOOP
      CYCLE_FLAG = .TRUE.
      IF (DU%VEL(NEW) > TWO_EPSILON_EB) THEN
         DN => DUCTNODE(DU%NODE_INDEX(1))
      ELSEIF (DU%VEL(NEW) < -TWO_EPSILON_EB) THEN
         DN => DUCTNODE(DU%NODE_INDEX(2))
      ELSE
         DU%UPDATED = .TRUE.
         DU%VEL(NEW) = 0._EB
         DU%RHO_D = 0.5_EB*(DUCTNODE(DU%NODE_INDEX(1))%RHO+DUCTNODE(DU%NODE_INDEX(2))%RHO)
         CYCLE DUCT_LOOP
      ENDIF
      IF (DN%UPDATED) THEN
         DU%RHO_D  = DN%RHO
         DU%TMP_D  = DN%TMP
         DU%CP_D   = DN%CP         
         DU%UPDATED = .TRUE.
         IF (N_TRACKED_SPECIES > 0) DU%ZZ(:) = DN%ZZ(:)
      ENDIF
   ENDDO DUCT_LOOP

   NODE_LOOP:DO NN = 1,NE%N_DUCTNODES   
      DN=>DUCTNODE(NE%NODE_INDEX(NN))
      IF(DN%UPDATED) CYCLE NODE_LOOP
      CYCLE_FLAG = .TRUE.
      VTOT = 0._EB
      MTOT = 0._EB
      ETOT = 0._EB
      IF(N_TRACKED_SPECIES > 0) ZZTOT = 0._EB
      TGUESS = 0._EB
      DO ND = 1,DN%N_DUCTS
         DU => DUCT(DN%DUCT_INDEX(ND))   
         IF (DU%AREA<=TWO_EPSILON_EB) CYCLE
         IF (DU%VEL(NEW)*DN%DIR(ND) < 0._EB) CYCLE
         IF (DU%VEL(NEW)*DN%DIR(ND) > 0._EB .AND. .NOT. DU%UPDATED) CYCLE NODE_LOOP
         VFLOW = ABS(DU%VEL(NEW)*DU%AREA)
         VTOT = VTOT + VFLOW
         MTOT = MTOT + VFLOW * DU%RHO_D         
         ETOT = ETOT + VFLOW * DU%RHO_D * DU%TMP_D * DU%CP_D + DU%COIL_Q

         IF (STRATIFICATION .AND. DN%VENT_INDEX <= 0 ) THEN
            IF (DU%NODE_INDEX(1)==NE%NODE_INDEX(NN)) THEN
               DN2=>DUCTNODE(DU%NODE_INDEX(2))
            ELSE
               DN2=>DUCTNODE(DU%NODE_INDEX(1))       
            ENDIF
            ETOT = ETOT + DU%RHO_D*VFLOW*GVEC(3)*(DN%XYZ(3)-DN2%XYZ(3))
         ENDIF
         IF(N_TRACKED_SPECIES > 0) ZZTOT = ZZTOT + VFLOW * DU%RHO_D * DU%ZZ
         TGUESS = TGUESS + VFLOW * DU%RHO_D * DU%TMP_D
         IF (DN%FILTER_INDEX > 0) THEN
            MTOT = MTOT - SUM(DN%FILTER_LOADING(:,3))
            ZZTOT = ZZTOT - DN%FILTER_LOADING(:,3)
            TGUESS = TGUESS - SUM(DN%FILTER_LOADING(:,3))*DU%TMP_D
            ITMP = MIN(5000,NINT(DU%TMP_D))
            DO NS = 1,N_TRACKED_SPECIES
               ETOT = ETOT - CPBAR_Z(ITMP,NS)*DU%TMP_D*DN%FILTER_LOADING(NS,3)
               IF (STRATIFICATION .AND. DN%VENT_INDEX <= 0 ) ETOT = ETOT - DN%FILTER_LOADING(NS,3)*GVEC(3)*(DN%XYZ(3)-DN2%XYZ(3))
            ENDDO
         ENDIF
      ENDDO

      DN%UPDATED = .TRUE.
      IF (ABS(MTOT)<=TWO_EPSILON_EB) CYCLE NODE_LOOP
      IF(N_TRACKED_SPECIES > 0) THEN
         DN%ZZ(:)  = ZZTOT/MTOT
         ZZ_GET(1:N_TRACKED_SPECIES) = DN%ZZ(1:N_TRACKED_SPECIES)
         CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,DN%RSUM)
      ENDIF
      TGUESS = TGUESS / MTOT      
      ETOT = ETOT/ MTOT
      DN%TMP = TGUESS

      ITCOUNT = 0
      CP_LOOP: DO
         ITCOUNT = ITCOUNT + 1
         CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CP,TGUESS)
         IF (TGUESS>1._EB) THEN
            CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CP2,TGUESS-1._EB)
            DCPDT = CP - CP2
         ELSE
            CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CP2,TGUESS+1._EB)
            DCPDT = CP2- CP
         ENDIF

         DN%TMP =TGUESS+(ETOT-CP*TGUESS)/(CP+TGUESS*DCPDT)
         IF (ABS(DN%TMP - TGUESS) < TWO_EPSILON_EB) EXIT CP_LOOP
         IF ((DN%TMP - TGUESS)/DN%TMP < 0.0005_EB) EXIT CP_LOOP
         IF (ITCOUNT > 10) THEN
            DN%TMP = 0.5_EB*(DN%TMP+TGUESS)
            CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,DN%CP,DN%TMP)
            EXIT CP_LOOP
         ENDIF
         TGUESS = DN%TMP
      ENDDO CP_LOOP
      DN%CP = CP
      DN%RHO = (DN%P+P_INF)/(DN%RSUM*DN%TMP)
   ENDDO NODE_LOOP

   IF (.NOT. CYCLE_FLAG) EXIT ITER_LOOP

ENDDO ITER_LOOP

DO NN = 1,NE%N_DUCTNODES
   DN=>DUCTNODE(NE%NODE_INDEX(NN))
   NODE_P(NN,:) = DN%P+P_INF
   NODE_TMP(NN,:) = DN%TMP
   NODE_RHO(NN,:) = DN%RHO
   NODE_CP(NN,:)= DN%CP
   NODE_RSUM(NN,:) = DN%RSUM
   IF (N_TRACKED_SPECIES > 0) THEN 
      DO NS=1,N_TRACKED_SPECIES
         NODE_ZZ(NN,NS,:) = DN%ZZ(NS)
      ENDDO
   ENDIF
ENDDO

TUSED(16,1)=TUSED(16,1)+SECOND()-TNOW

END SUBROUTINE HVAC_UPDATE


SUBROUTINE RHSNODE(NETWORK_INDEX)
USE GLOBAL_CONSTANTS
INTEGER, INTENT(IN)::NETWORK_INDEX
INTEGER :: NN,ND, ARRAYLOC
TYPE(NETWORK_TYPE), POINTER::NE=>NULL()
TYPE(DUCT_TYPE), POINTER::DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER::DN=>NULL()

NE => NETWORK(NETWORK_INDEX)
DO NN = 1, NE%N_DUCTNODES
   DN => DUCTNODE(NE%NODE_INDEX(NN))
   IF (DN%FIXED .OR. DN%VENT_INDEX > 0 .OR. DN%AMBIENT .OR. DN%LEAKAGE) CYCLE
   ARRAYLOC = NE%MATRIX_INDEX(NE%N_DUCTS+DUCTNODE_NE(NE%NODE_INDEX(NN)))
   DO ND = 1,DN%N_DUCTS
      DU => DUCT(DN%DUCT_INDEX(ND))
      IF (DU%FIXED) RHS(ARRAYLOC) = RHS(ARRAYLOC) + DN%DIR(ND)*DU%RHO_D*DU%VOLUME_FLOW       
   END DO
   IF (DN%FILTER_INDEX > 0) RHS(ARRAYLOC) = RHS(ARRAYLOC) - SUM(DN%FILTER_LOADING(:,3))
   
ENDDO

END SUBROUTINE RHSNODE


SUBROUTINE LHSNODE(NETWORK_INDEX)
USE GLOBAL_CONSTANTS
INTEGER, INTENT(IN)::NETWORK_INDEX
INTEGER :: NN,ND, ARRAYLOC1,ARRAYLOC2
TYPE(NETWORK_TYPE), POINTER::NE=>NULL()
TYPE(DUCT_TYPE), POINTER::DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER::DN=>NULL()

NE => NETWORK(NETWORK_INDEX)
DO NN = 1, NE%N_DUCTNODES
   DN => DUCTNODE(NE%NODE_INDEX(NN))
   IF (DN%FIXED .OR. DN%VENT_INDEX > 0 .OR. DN%LEAKAGE) CYCLE
   ARRAYLOC1 = NE%MATRIX_INDEX(NE%N_DUCTS+DUCTNODE_NE(NE%NODE_INDEX(NN)))
   DO ND = 1,DN%N_DUCTS
      DU => DUCT(DN%DUCT_INDEX(ND))
      IF (DU%FIXED .OR. DU%AREA <=TWO_EPSILON_EB) CYCLE
      ARRAYLOC2 = NE%MATRIX_INDEX(DUCT_NE(DN%DUCT_INDEX(ND)))
      LHS(ARRAYLOC1,ARRAYLOC2) = -DN%DIR(ND)*DU%RHO_D*DU%AREA      
   END DO
ENDDO

END SUBROUTINE LHSNODE


SUBROUTINE DPSTARCALC

USE GLOBAL_CONSTANTS
INTEGER :: NN,IPZ
TYPE(DUCT_TYPE), POINTER::DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER::DN=>NULL()
TYPE(P_ZONE_TYPE), POINTER::PZ=>NULL()

DO IPZ = 1,N_ZONE
   PZ => P_ZONE(IPZ)
   IF (PZ%N_DUCTNODES==0) CYCLE
   DPSTAR(IPZ) = P_ZONE(IPZ)%DPSTAR * DT
   DO NN = 1,PZ%N_DUCTNODES
      DN=>DUCTNODE(PZ%NODE_INDEX(NN))
      DU=>DUCT(DN%DUCT_INDEX(1))
      DPSTAR(IPZ) = DPSTAR(IPZ)  - DN%DIR(1) * DU%AREA * DU%VEL(OLD) * DT/PSUM(IPZ,1)
      IF (DU%FIXED) DPSTAR(IPZ) = DPSTAR(IPZ)  + DN%DIR(1) * DU%AREA * DU%VEL(NEW) * DT/PSUM(IPZ,1)
   ENDDO   
ENDDO

END SUBROUTINE DPSTARCALC


SUBROUTINE RHSDUCT(NETWORK_INDEX)

USE GLOBAL_CONSTANTS
INTEGER, INTENT(IN)::NETWORK_INDEX
INTEGER :: ND, ARRAYLOC,IPZ
REAL(EB) :: HEAD,XYZ(3)
TYPE(NETWORK_TYPE), POINTER::NE=>NULL()
TYPE(DUCT_TYPE), POINTER::DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER::DN=>NULL()

NE => NETWORK(NETWORK_INDEX)

DO ND = 1, NE%N_DUCTS
   DU => DUCT(NE%DUCT_INDEX(ND))
   IF (DU%FIXED .OR. DU%AREA < TWO_EPSILON_EB) CYCLE
   HEAD = 0._EB
   ARRAYLOC = NE%MATRIX_INDEX(DUCT_NE(NE%DUCT_INDEX(ND)))
   DN=>DUCTNODE(DU%NODE_INDEX(1))
   IF (DN%AMBIENT) THEN
      HEAD = HEAD + DN%P
   ELSEIF (DN%VENT_INDEX > 0 .OR. DN%LEAKAGE) THEN
      HEAD = HEAD + DN%P   
      IF (N_ZONE > 0) THEN
         IPZ = DN%ZONE_INDEX
         IF (IPZ > 0) HEAD = HEAD + DPSTAR(IPZ)
      ENDIF
   ENDIF
   XYZ = DN%XYZ

   DN=>DUCTNODE(DU%NODE_INDEX(2))
   IF (DN%AMBIENT) THEN
      HEAD = HEAD - DN%P
   ELSEIF (DN%VENT_INDEX > 0 .OR. DN%LEAKAGE) THEN
      HEAD = HEAD - DN%P   
      IF (N_ZONE > 0) THEN
         IPZ = DN%ZONE_INDEX
         IF (IPZ > 0) HEAD = HEAD - DPSTAR(IPZ)
      ENDIF
   ENDIF
   XYZ = DN%XYZ - XYZ
   IF(.NOT. DU%LEAKAGE) THEN
     ! IF (STRATIFICATION) THEN

    !     HEAD = HEAD + (DN%P+P_INF)*(1._EB-EXP(-(GVEC(1)*XYZ(1)+GVEC(2)*XYZ(2)+GVEC(3)*XYZ(3))/(DU%RSUM_D*DU%TMP_D)))
    !  ELSE
         HEAD = HEAD + (GVEC(1)*XYZ(1)+GVEC(2)*XYZ(2)+GVEC(3)*XYZ(3))*DU%RHO_D
    !  ENDIF

   ENDIF
   RHS(ARRAYLOC) = DU%VEL(OLD)+DT/DU%LENGTH*(HEAD+DU%DP_FAN)/DU%RHO_D + &
                   0.5_EB*DU%TOTAL_LOSS*ABS(DU%VEL(NEW))*DU%VEL(GUESS)*DT/DU%LENGTH
ENDDO

END SUBROUTINE RHSDUCT


SUBROUTINE LHSDUCT(NETWORK_INDEX)
USE GLOBAL_CONSTANTS
INTEGER, INTENT(IN)::NETWORK_INDEX
INTEGER :: NN,ND, ARRAYLOC1,ARRAYLOC2
TYPE(NETWORK_TYPE), POINTER::NE=>NULL()
TYPE(DUCT_TYPE), POINTER::DU=>NULL(),DU2=>NULL()
TYPE(DUCTNODE_TYPE), POINTER::DN=>NULL(),DN2=>NULL()
TYPE(P_ZONE_TYPE), POINTER::PZ=>NULL()
NE => NETWORK(NETWORK_INDEX)
DUCT_LOOP: DO ND = 1, NE%N_DUCTS
   DU => DUCT(NE%DUCT_INDEX(ND))
   IF (DU%FIXED .OR. DU%AREA < TWO_EPSILON_EB) CYCLE DUCT_LOOP
   ARRAYLOC1 = NE%MATRIX_INDEX(DUCT_NE(NE%DUCT_INDEX(ND)))
   LHS(ARRAYLOC1,ARRAYLOC1) = 1._EB+0.5_EB*DU%TOTAL_LOSS*ABS(DU%VEL(NEW)+DU%VEL(GUESS))*DT/DU%LENGTH
   DN=>DUCTNODE(DU%NODE_INDEX(1))
   IF (DN%VENT_INDEX < 0) THEN
      IF (.NOT. DN%AMBIENT .AND. .NOT. DN%LEAKAGE) THEN
         ARRAYLOC2 = NE%MATRIX_INDEX(NE%N_DUCTS+DUCTNODE_NE(DU%NODE_INDEX(1)))
         LHS(ARRAYLOC1,ARRAYLOC2) = -DT/(DU%RHO_D*DU%LENGTH)
      ENDIF
      IF (DN%LEAKAGE .AND. .NOT. DN%AMBIENT) THEN
         PZ => P_ZONE(DN%ZONE_INDEX)
         DO NN=1,PZ%N_DUCTNODES
            DN2=>DUCTNODE(PZ%NODE_INDEX(NN))
            DU2=>DUCT(DN2%DUCT_INDEX(1))
            IF (DU2%AREA < TWO_EPSILON_EB .OR. DU2%FIXED) CYCLE
            ARRAYLOC2 = NE%MATRIX_INDEX(DUCT_NE(DN2%DUCT_INDEX(1)))
            LHS(ARRAYLOC1,ARRAYLOC2) = LHS(ARRAYLOC1,ARRAYLOC2) - DN2%DIR(1)*DU2%AREA*DT**2 / &
                                       (PSUM(DN%ZONE_INDEX,1)*DU%RHO_D*DU%LENGTH)
         ENDDO
      ENDIF
   ELSE
      IF (DN%ZONE_INDEX >0) THEN
         PZ => P_ZONE(DN%ZONE_INDEX)
         DO NN=1,PZ%N_DUCTNODES
            DN2=>DUCTNODE(PZ%NODE_INDEX(NN))
            DU2=>DUCT(DN2%DUCT_INDEX(1))
            IF (DU2%AREA < TWO_EPSILON_EB .OR. DU2%FIXED) CYCLE
            ARRAYLOC2 = NE%MATRIX_INDEX(DUCT_NE(DN2%DUCT_INDEX(1)))
            LHS(ARRAYLOC1,ARRAYLOC2) = LHS(ARRAYLOC1,ARRAYLOC2) - DN2%DIR(1)*DU2%AREA*DT**2 / &
                                       (PSUM(DN%ZONE_INDEX,1)*DU%RHO_D*DU%LENGTH)
         ENDDO
      ENDIF
   ENDIF
   DN=>DUCTNODE(DU%NODE_INDEX(2))
   IF (DN%VENT_INDEX < 0) THEN
      IF (.NOT. DN%AMBIENT .AND. .NOT. DN%LEAKAGE) THEN
         ARRAYLOC2 = NE%MATRIX_INDEX(NE%N_DUCTS+DUCTNODE_NE(DU%NODE_INDEX(2)))       
         LHS(ARRAYLOC1,ARRAYLOC2) = DT/(DU%RHO_D*DU%LENGTH)
      ENDIF
      IF (DN%LEAKAGE .AND. .NOT. DN%AMBIENT) THEN
         PZ => P_ZONE(DN%ZONE_INDEX)
         DO NN=1,PZ%N_DUCTNODES
            DN2=>DUCTNODE(PZ%NODE_INDEX(NN))
            DU2=>DUCT(DN2%DUCT_INDEX(1))
            IF (DU2%AREA < TWO_EPSILON_EB .OR. DU2%FIXED) CYCLE  
            ARRAYLOC2 = NE%MATRIX_INDEX(DUCT_NE(DN2%DUCT_INDEX(1)))
            LHS(ARRAYLOC1,ARRAYLOC2) = LHS(ARRAYLOC1,ARRAYLOC2) + DN2%DIR(1)*DU2%AREA*DT**2 / &
                                       (PSUM(DN%ZONE_INDEX,1)*DU%RHO_D*DU%LENGTH)
         ENDDO
      ENDIF
   ELSE
      IF (DN%ZONE_INDEX >0) THEN
         PZ => P_ZONE(DN%ZONE_INDEX)
         DO NN=1,PZ%N_DUCTNODES
            DN2=>DUCTNODE(PZ%NODE_INDEX(NN))
            DU2=>DUCT(DN2%DUCT_INDEX(1))
            IF (DU2%AREA < TWO_EPSILON_EB .OR. DU2%FIXED) CYCLE  
            ARRAYLOC2 = NE%MATRIX_INDEX(DUCT_NE(DN2%DUCT_INDEX(1)))
            LHS(ARRAYLOC1,ARRAYLOC2) = LHS(ARRAYLOC1,ARRAYLOC2) + DN2%DIR(1)*DU2%AREA*DT**2 / &
                                       (PSUM(DN%ZONE_INDEX,1)*DU%RHO_D*DU%LENGTH)
         ENDDO
      ENDIF
   ENDIF
ENDDO DUCT_LOOP

END SUBROUTINE LHSDUCT


SUBROUTINE UPDATE_FAN(T,DUCT_INDEX)
USE MATH_FUNCTIONS, ONLY : EVALUATE_RAMP
INTEGER, INTENT(IN) :: DUCT_INDEX
REAL(EB), INTENT(IN) :: T
REAL(EB) :: TSI
TYPE(DUCT_TYPE), POINTER::DU=>NULL()
TYPE(FAN_TYPE), POINTER::FA=>NULL()
REAL(EB) :: DEL_P,VDOT

DU=> DUCT(DUCT_INDEX)
FA=> FAN(DU%FAN_INDEX)
TSI = T - DU%FAN_ON_TIME
SELECT CASE (FA%FAN_TYPE)
   CASE(1) !Constant flow
      DU%VEL(NEW) = FA%VOL_FLOW/DU%AREA*EVALUATE_RAMP(TSI,FA%TAU,FA%SPIN_INDEX)
      IF (DU%REVERSE) DU%VEL(NEW)=-DU%VEL(NEW)
      DU%VOLUME_FLOW = DU%VEL(NEW)*DU%AREA 
      RETURN     
   CASE(2) !Quadratic
      VDOT = DU%VEL(NEW)*DU%AREA
      IF (DU%REVERSE) VDOT = -VDOT
      VDOT = MAX(0._EB,MIN(VDOT,FA%MAX_FLOW))
      DEL_P = FA%MAX_PRES - FA%MAX_PRES*(VDOT/FA%MAX_FLOW)**2
      DEL_P = DEL_P*EVALUATE_RAMP(TSI,FA%TAU,FA%SPIN_INDEX)            
   CASE(3) !Fan curve
      VDOT = DU%VEL(NEW)*DU%AREA
      IF (DU%REVERSE) VDOT = -VDOT
      DEL_P = EVALUATE_RAMP(VDOT,0._EB,FA%RAMP_INDEX)*EVALUATE_RAMP(TSI,FA%TAU,FA%SPIN_INDEX)      
END SELECT

IF (DU%REVERSE) DEL_P=-DEL_P
DU%DP_FAN = 0.2_EB*DEL_P+0.8_EB*DU%DP_FAN
END SUBROUTINE UPDATE_FAN


SUBROUTINE HVAC_BC_IN(NM)

! Average gas properties at VENTs connected to HVAC system

USE PHYSICAL_FUNCTIONS, ONLY : GET_SPECIFIC_GAS_CONSTANT,GET_AVERAGE_SPECIFIC_HEAT
INTEGER, INTENT(IN) :: NM
INTEGER :: NN,II,JJ,KK,I1,I2,J1,J2,K1,K2,IC,IW,IOR,NODE_ZONE,IZ1,IZ2,ITCOUNT
REAL(EB) :: ZZ_SUM(1:N_TRACKED_SPECIES),ZZ_GET(0:N_TRACKED_SPECIES),RHO_SUM,P_SUM,AREA_SUM,AREA, &
            TMP_SUM,H_SUM,H_G,TMP_NEW,CPBAR,CPBAR2,TNOW,P_AVE,DCPDT,FAC
REAL(EB), POINTER, DIMENSION(:,:,:) :: RHOP,UP,VP,WP,HP
REAL(EB), POINTER, DIMENSION(:,:) :: PBARP
TYPE (MESH_TYPE),POINTER :: M=>NULL()
TYPE (VENTS_TYPE),POINTER :: VT=>NULL()
TYPE (DUCTNODE_TYPE), POINTER :: DN=>NULL()
TYPE (SURFACE_TYPE), POINTER :: SF=>NULL()
TYPE (WALL_TYPE), POINTER :: WC=>NULL()

IF (EVACUATION_ONLY(NM)) RETURN

TNOW=SECOND()

M => MESHES(NM)
CALL POINT_TO_MESH(NM)

IF (PREDICTOR) THEN
   PBARP => PBAR
   RHOP  => RHO
   HP    => H
   UP    => U
   VP    => V
   WP    => W      
ELSE
   PBARP => PBAR_S
   RHOP  => RHOS
   HP    => HS
   UP    => US
   VP    => VS
   WP    => WS      
ENDIF

NODE_LOOP: DO NN = 1, N_DUCTNODES
   IF (N_TRACKED_SPECIES>0) ZZ_SUM=0._EB
   RHO_SUM=0._EB
   P_SUM=0._EB
   AREA_SUM=0._EB
   TMP_SUM=0._EB
   H_SUM=0._EB
   NODE_ZONE=-1
   DN=>DUCTNODE(NN)
   IF (DN%MESH_INDEX /= NM) CYCLE NODE_LOOP
   IF (DN%VENT_INDEX < 0) CYCLE NODE_LOOP

   VT=>VENTS(DN%VENT_INDEX)
   IOR = VT%IOR
   I1 = VT%I1
   I2 = VT%I2
   J1 = VT%J1
   J2 = VT%J2
   K1 = VT%K1
   K2 = VT%K2
   SELECT CASE (ABS(IOR))
      CASE (1)
         J1 = J1 + 1
         K1 = K1 + 1
         IF (IOR > 0) THEN
            I1 = I1 + 1
            I2 = I1
         ENDIF
      CASE (2)
         I1 = I1 + 1
         K1 = K1 + 1
         IF (IOR > 0) THEN
            J1 = J1 + 1
            J2 = J1
         ENDIF
      CASE (3)
         I1 = I1 + 1
         J1 = J1 + 1
         IF (IOR > 0) THEN
            K1 = K1 + 1
            K2 = K1
         ENDIF
   END SELECT
   VENT_LOOP: DO KK = K1,K2
      DO JJ = J1,J2
         DO II = I1, I2
            IC = CELL_INDEX(II,JJ,KK)
            IF (SOLID(IC)) CYCLE
            IW = WALL_INDEX(IC,-IOR)
            IF (IW==0) CYCLE VENT_LOOP
            WC => WALL(IW)
            AREA = WC%AW
            IF (WC%PRESSURE_ZONE /= NODE_ZONE) THEN
               IF (NODE_ZONE == -1) THEN
                  NODE_ZONE = WC%PRESSURE_ZONE
               ELSE
                  WRITE(MESSAGE,'(A,I5)') 'ERROR: VENT for a NODE must lie with a single pressure zone. Node: ',NN
                  CALL SHUTDOWN(MESSAGE)
               ENDIF
            ENDIF
            RHO_SUM = RHO_SUM + RHOP(II,JJ,KK)*AREA
            IF (N_TRACKED_SPECIES > 0) THEN
               ZZ_SUM = ZZ_SUM + ZZ(II,JJ,KK,:)*RHO(II,JJ,KK)*AREA
               ZZ_GET(1:N_TRACKED_SPECIES) = ZZ(II,JJ,KK,1:N_TRACKED_SPECIES)
            ENDIF
            CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CPBAR,TMP(II,JJ,KK))
            H_G   = CPBAR * TMP(II,JJ,KK)
            H_SUM = H_SUM+H_G*AREA*RHOP(II,JJ,KK)
            TMP_SUM = TMP_SUM + TMP(II,JJ,KK)*AREA
            IZ1 = PRESSURE_ZONE(II,JJ,KK)
            SELECT CASE (IOR)
               CASE (3)
                  P_AVE = 0.5_EB*(PBARP(KK-1,IZ1)+PBARP(KK,IZ1))
               CASE (-3)
                  P_AVE = 0.5_EB*(PBARP(KK,IZ1)+PBARP(KK+1,IZ1))
               CASE DEFAULT
                  P_AVE = PBARP(KK,IZ1)          
               END SELECT
               P_SUM = P_SUM + (P_AVE+RHO(II,JJ,KK)*(HP(II,JJ,KK)-KRES(II,JJ,KK)))*AREA      
            AREA_SUM = AREA_SUM + AREA      
         ENDDO
      ENDDO
   ENDDO VENT_LOOP
   IF (NODE_ZONE /= -1) DN%ZONE_INDEX = NODE_ZONE
   NODE_P(NN,NM)      = P_SUM / AREA_SUM
   TMP_SUM   = TMP_SUM / AREA_SUM
   IF (N_TRACKED_SPECIES>0) THEN
      NODE_ZZ(NN,1:N_TRACKED_SPECIES,NM) = ZZ_SUM(1:N_TRACKED_SPECIES) / RHO_SUM
      ZZ_GET(1:N_TRACKED_SPECIES) = NODE_ZZ(NN,1:N_TRACKED_SPECIES,NM)
      CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,NODE_RSUM(NN,NM))
   ENDIF
   H_SUM = H_SUM / RHO_SUM
   ITCOUNT = 0
   DO
      ITCOUNT = ITCOUNT + 1
      CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CPBAR,TMP_SUM)
      IF (TMP_SUM > 1._EB) THEN
         CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CPBAR2,TMP_SUM-1._EB)      
         DCPDT = CPBAR - CPBAR2
      ELSE
         CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CPBAR2,TMP_SUM+1._EB)      
         DCPDT = CPBAR2- CPBAR
      ENDIF        
      TMP_NEW = TMP_SUM  + (H_SUM - TMP_SUM*CPBAR) / (CPBAR + TMP_SUM*DCPDT)
      IF (ABS(TMP_SUM - TMP_NEW) < SPACING(TMP_NEW) .OR. ABS(TMP_SUM - TMP_NEW)/TMP_NEW < 0.0005_EB) EXIT
      IF (ITCOUNT > 10) THEN
         TMP_SUM = 0.5_EB*(TMP_SUM+TMP_NEW)
         EXIT
      ENDIF
      TMP_SUM = TMP_NEW
   ENDDO
   NODE_CP(NN,NM)  = CPBAR
   NODE_TMP(NN,NM) = TMP_SUM
   NODE_RHO(NN,NM) = RHO_SUM / AREA_SUM   
ENDDO NODE_LOOP

LEAKAGE_BC: IF (LEAK_DUCTS > 0) THEN
   LEAK_TMP(:,:,NM) = 0._EB
   LEAK_RHO(:,:,NM) = 0._EB
   LEAK_RSUM(:,:,NM) = 0._EB
   LEAK_CP(:,:,NM) = 0._EB
   FDS_LEAK_AREA(:,:,NM) = 0._EB
   LEAK_P(:,:,NM) = 0._EB         
   IF (N_TRACKED_SPECIES > 0) LEAK_ZZ(:,:,:,NM) = 0._EB
   WALL_LOOP: DO IW=1,N_EXTERNAL_WALL_CELLS+N_INTERNAL_WALL_CELLS
      WC=>WALL(IW)
      IF (WC%BOUNDARY_TYPE/=SOLID_BOUNDARY) CYCLE WALL_LOOP
      SF => SURFACE(WC%SURF_INDEX)
      IF (SF%LEAK_PATH(1) /= WC%PRESSURE_ZONE .AND. SF%LEAK_PATH(2) /= WC%PRESSURE_ZONE) CYCLE WALL_LOOP
      IF (SF%LEAK_PATH(1) == WC%PRESSURE_ZONE) THEN
         IZ1 = SF%LEAK_PATH(1)
         IZ2 = SF%LEAK_PATH(2)
      ELSE
         IZ1 = SF%LEAK_PATH(2)
         IZ2 = SF%LEAK_PATH(1)
      ENDIF
      IOR = WC%ONE_D%IOR      
      II = WC%ONE_D%IIG
      JJ = WC%ONE_D%JJG
      KK = WC%ONE_D%KKG
      AREA = WC%AW
      FDS_LEAK_AREA(IZ1,IZ2,NM) = FDS_LEAK_AREA(IZ1,IZ2,NM) + AREA
      LEAK_RHO(IZ1,IZ2,NM) = LEAK_RHO(IZ1,IZ2,NM) + RHOP(II,JJ,KK)*AREA
      SELECT CASE (IOR)
         CASE (3)
            P_AVE = 0.5_EB*(PBARP(KK-1,PRESSURE_ZONE(II,JJ,KK))+PBARP(KK,PRESSURE_ZONE(II,JJ,KK)))
         CASE (-3)
            P_AVE = 0.5_EB*(PBARP(KK,PRESSURE_ZONE(II,JJ,KK))+PBARP(KK+1,PRESSURE_ZONE(II,JJ,KK)))
         CASE DEFAULT
            P_AVE = PBARP(KK,PRESSURE_ZONE(II,JJ,KK))          
      END SELECT 
      LEAK_P(IZ1,IZ2,NM) = LEAK_P(IZ1,IZ2,NM) + P_AVE*AREA
      IF (N_TRACKED_SPECIES > 0) THEN
         ZZ_GET(1:N_TRACKED_SPECIES) = ZZ(II,JJ,KK,1:N_TRACKED_SPECIES)
         LEAK_ZZ(IZ1,IZ2,1:N_TRACKED_SPECIES,NM) = LEAK_ZZ(IZ1,IZ2,1:N_TRACKED_SPECIES,NM) + &
                                                   ZZ_GET(1:N_TRACKED_SPECIES)*RHO(II,JJ,KK)*AREA
      ENDIF
      CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CPBAR,TMP(II,JJ,KK))
      H_G = CPBAR * TMP(II,JJ,KK)
      LEAK_CP(IZ1,IZ2,NM) = LEAK_CP(IZ1,IZ2,NM)+H_G*AREA*RHOP(II,JJ,KK)
      LEAK_TMP(IZ1,IZ2,NM) = LEAK_TMP(IZ1,IZ2,NM)+ TMP(II,JJ,KK)*AREA
   END DO WALL_LOOP
   DO IZ1 = 0,N_ZONE
      DO IZ2 = 0,N_ZONE
         IF (LEAK_PATH(IZ1,IZ2) == 0 .AND. LEAK_PATH(IZ2,IZ1)==0 .OR. FDS_LEAK_AREA(IZ1,IZ2,NM)<=TWO_EPSILON_EB) CYCLE
         LEAK_TMP(IZ1,IZ2,NM) = LEAK_TMP(IZ1,IZ2,NM)/ FDS_LEAK_AREA(IZ1,IZ2,NM)
         IF (N_TRACKED_SPECIES>0) THEN
            LEAK_ZZ(IZ1,IZ2,1:N_TRACKED_SPECIES,NM) = LEAK_ZZ(IZ1,IZ2,1:N_TRACKED_SPECIES,NM) / LEAK_RHO(IZ1,IZ2,NM)
            ZZ_GET(1:N_TRACKED_SPECIES) = LEAK_ZZ(IZ1,IZ2,1:N_TRACKED_SPECIES,NM)
            CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,LEAK_RSUM(IZ1,IZ2,NM))
         ENDIF
         LEAK_CP(IZ1,IZ2,NM)  = LEAK_CP(IZ1,IZ2,NM)  / LEAK_RHO(IZ1,IZ2,NM)
         LEAK_RHO(IZ1,IZ2,NM) = LEAK_RHO(IZ1,IZ2,NM) / FDS_LEAK_AREA(IZ1,IZ2,NM)
         LEAK_P(IZ1,IZ2,NM) = LEAK_P(IZ1,IZ2,NM) / FDS_LEAK_AREA(IZ1,IZ2,NM)
         TMP_SUM = LEAK_TMP(IZ1,IZ2,NM)
         DO
            CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CPBAR,TMP_SUM)      
            TMP_NEW = LEAK_CP(IZ1,IZ2,NM) / CPBAR
            IF (ABS(TMP_SUM - TMP_NEW) < SPACING(TMP_NEW) .OR. ABS(TMP_SUM - TMP_NEW)/TMP_NEW < 0.0005_EB) EXIT
            TMP_SUM = TMP_NEW
         ENDDO    
         LEAK_TMP(IZ1,IZ2,NM) = TMP_NEW
         LEAK_CP(IZ1,IZ2,NM) = CPBAR
      ENDDO
   ENDDO    
   DO IZ2 = 1,N_ZONE 
      IF (FDS_LEAK_AREA(0,IZ2,NM)<=TWO_EPSILON_EB .AND. FDS_LEAK_AREA(IZ2,0,NM)>=TWO_EPSILON_EB) THEN
         ZZ_GET = 0._EB
         FDS_LEAK_AREA(0,IZ2,NM) = FDS_LEAK_AREA(IZ2,0,NM)
         IF (N_TRACKED_SPECIES > 0) THEN
            ZZ_GET(1:N_TRACKED_SPECIES) = SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
            LEAK_ZZ(0,IZ2,1:N_TRACKED_SPECIES,NM) = ZZ_GET
         ENDIF
         CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,LEAK_RSUM(0,IZ2,NM))
         K_SEARCH: DO KK = 0,KBAR
            IF (PBAR(KK,IZ2) >= LEAK_P(IZ2,0,NM) .AND. PBAR(KK+1,IZ2) < LEAK_P(IZ2,0,NM)) THEN
               FAC = (LEAK_P(IZ2,0,NM)-PBAR(KK,IZ2))/(PBAR(KK+1,IZ2)-PBAR(KK,IZ2))
               EXIT K_SEARCH
            ENDIF
         ENDDO K_SEARCH
         LEAK_P(0,IZ2,NM) = PBAR(KK,0)+FAC*(PBAR(KK+1,0)-PBAR(KK,0))
         LEAK_TMP(0,IZ2,NM) = TMP_0(KK)+FAC*(TMP_0(KK+1)-TMP_0(KK))
         CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,LEAK_CP(0,IZ2,NM), LEAK_TMP(0,IZ2,NM)) 
         LEAK_RHO(0,IZ2,NM) = LEAK_P(0,IZ2,NM)/LEAK_TMP(0,IZ2,NM)/LEAK_RSUM(0,IZ2,NM)
      ENDIF
   ENDDO
ENDIF LEAKAGE_BC

TUSED(16,:)=TUSED(16,:)+SECOND()-TNOW

END SUBROUTINE HVAC_BC_IN


SUBROUTINE DETERMINE_FIXED_ELEMENTS(T)
USE MATH_FUNCTIONS,ONLY:EVALUATE_RAMP
INTEGER:: NN,ND, COUNTER
REAL(EB), INTENT(IN):: T
LOGICAL :: CHANGE
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()

DUCTNODE%FIXED = .FALSE.
DUCT%FIXED = .FALSE.
DUCT%VOLUME_FLOW = 0._EB
CHANGE = .TRUE.

DUCT_LOOP: DO ND=1,N_DUCTS
   DU=>DUCT(ND)
   IF (DU%VOLUME_FLOW_INITIAL<1.E6_EB) THEN
      DU%VOLUME_FLOW = DU%VOLUME_FLOW_INITIAL*EVALUATE_RAMP(T,DU%TAU,DU%RAMP_INDEX)
      IF(DU%AREA > TWO_EPSILON_EB) DU%VEL(NEW) = DU%VOLUME_FLOW/DU%AREA
      DU%FIXED = .TRUE.   
      CYCLE DUCT_LOOP
   ENDIF
   IF (DU%MASS_FLOW_INITIAL<1.E6_EB) THEN
      IF (DU%MASS_FLOW_INITIAL >0._EB) THEN
         DU%VOLUME_FLOW = DU%MASS_FLOW_INITIAL/DUCTNODE(DU%NODE_INDEX(1))%RHO*EVALUATE_RAMP(T,DU%TAU,DU%RAMP_INDEX)
      ELSE
         DU%VOLUME_FLOW = DU%MASS_FLOW_INITIAL/DUCTNODE(DU%NODE_INDEX(2))%RHO*EVALUATE_RAMP(T,DU%TAU,DU%RAMP_INDEX)         
      ENDIF
      IF(DU%AREA > TWO_EPSILON_EB) DU%VEL(NEW) = DU%VOLUME_FLOW/DU%AREA
      DU%FIXED = .TRUE.   
      CYCLE DUCT_LOOP         
   ENDIF
   IF (DU%FAN_INDEX>0) THEN
      IF (DU%DEVC_INDEX > 0) THEN
         DU%FAN_OPERATING = DEVICE(DU%DEVC_INDEX)%CURRENT_STATE
         IF (DU%FAN_OPERATING .AND. (DEVICE(DU%DEVC_INDEX)%CURRENT_STATE .NEQV. DEVICE(DU%DEVC_INDEX)%PRIOR_STATE)) &
            DU%FAN_ON_TIME = T
      ELSEIF (DU%CTRL_INDEX > 0) THEN
         DU%FAN_OPERATING = CONTROL(DU%CTRL_INDEX)%CURRENT_STATE
         IF (DU%FAN_OPERATING .AND. (CONTROL(DU%CTRL_INDEX)%CURRENT_STATE .NEQV. CONTROL(DU%CTRL_INDEX)%PRIOR_STATE)) &
            DU%FAN_ON_TIME = T
      ENDIF
      IF (DU%FAN_OPERATING .AND. FAN(DU%FAN_INDEX)%FAN_TYPE==1) THEN
         DU%FIXED=.TRUE.
         CALL UPDATE_FAN(T,ND)
      ELSEIF (.NOT. DU%FAN_OPERATING .AND. FAN(DU%FAN_INDEX)%FAN_TYPE==1) THEN
         DU%FIXED = .FALSE.
         DU%VOLUME_FLOW = 0._EB
      ENDIF              
   ENDIF
ENDDO DUCT_LOOP

NODE_LOOP: DO NN = 1, N_DUCTNODES
      DN=>DUCTNODE(NN)
      IF (DN%VENT_INDEX > 0 .OR. DN%AMBIENT .OR. DN%LEAKAGE) THEN
         DN%FIXED = .TRUE.
         CHANGE = .TRUE.
         CYCLE NODE_LOOP
      ENDIF
      COUNTER = 0
      DO ND = 1,DN%N_DUCTS
         DU=>DUCT(DN%DUCT_INDEX(ND))
         IF (DU%FIXED .OR. DU%AREA < TWO_EPSILON_EB) COUNTER = COUNTER + 1
      ENDDO      
      IF (COUNTER==DN%N_DUCTS) THEN
         WRITE(MESSAGE,'(A,A)') 'ERROR: Cannot specifiy fixed flows for all branches of internal DUCTNODE:',TRIM(DN%ID)
         CALL SHUTDOWN(MESSAGE)
      ENDIF     
ENDDO NODE_LOOP

END SUBROUTINE DETERMINE_FIXED_ELEMENTS


SUBROUTINE FIND_NETWORKS(CHANGEIN,T)
INTEGER:: NZ,NN,ND,DUCT_COUNTER(N_DUCTS),NODE_COUNTER(N_DUCTNODES),COUNTER,COUNTER2,ZONE_COUNTER(N_ZONE)
INTEGER, DIMENSION(:), ALLOCATABLE :: NETWORK_DCOUNTER,NETWORK_NCOUNTER,RENUMBER
LOGICAL, INTENT(INOUT) :: CHANGEIN
LOGICAL :: CHANGE
REAL(EB), INTENT(INOUT):: T
INTEGER :: IZ1,IZ2
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()

CHANGE = CHANGEIN

IF (N_ZONE > 0) ZONE_COUNTER = 0

DO ND = 1, N_DUCTS
   DU => DUCT(ND)
   IF(.NOT. DU%DAMPER .AND. .NOT. DU%LEAKAGE) CYCLE
   IF(DU%DAMPER) THEN
      IF (DU%DEVC_INDEX > 0) THEN
         IF (DEVICE(DU%DEVC_INDEX)%CURRENT_STATE .NEQV. DU%DAMPER_OPEN) THEN
               DU%DAMPER_OPEN = DEVICE(DU%DEVC_INDEX)%CURRENT_STATE
               CHANGE = .TRUE.
               IF (DU%DAMPER_OPEN) THEN
                  DU%AREA = DU%AREA_INITIAL
               ELSE
                  DU%AREA = 0._EB
                  DU%VEL  = 0._EB
               ENDIF
         ENDIF
      ELSE
         IF (CONTROL(DU%CTRL_INDEX)%CURRENT_STATE .NEQV. DU%DAMPER_OPEN) THEN
               DU%DAMPER_OPEN = CONTROL(DU%CTRL_INDEX)%CURRENT_STATE
               CHANGE = .TRUE.
               IF (DU%DAMPER_OPEN) THEN
                  DU%AREA = DU%AREA_INITIAL
               ELSE
                  DU%AREA = 0._EB
                  DU%VEL  = 0._EB
               ENDIF
         ENDIF
      ENDIF
   ELSE ! LEAKAGE
      IZ1 = DUCTNODE(DU%NODE_INDEX(1))%ZONE_INDEX
      IZ2 = DUCTNODE(DU%NODE_INDEX(2))%ZONE_INDEX
      IF (MAXVAL(FDS_LEAK_AREA(IZ1,IZ2,:)) < TWO_EPSILON_EB .OR. MAXVAL(FDS_LEAK_AREA(IZ2,IZ1,:)) < TWO_EPSILON_EB) THEN
         DU%AREA = 0._EB
         DU%VEL  = 0._EB
      ELSE
         DU%AREA = DU%AREA_INITIAL
      ENDIF
   ENDIF
ENDDO

IF (CHANGE) THEN
   IF (ALLOCATED(NETWORK)) DEALLOCATE(NETWORK)
   DO NN = 1, N_DUCTNODES
      NZ = DUCTNODE(NN)%ZONE_INDEX
      IF (NZ>=1) THEN
         NODE_COUNTER(NN) = NZ
         ZONE_COUNTER(NZ) = ZONE_COUNTER(NZ) + 1
      ELSE
         NODE_COUNTER(NN) = NN+N_ZONE
      ENDIF
   ENDDO 
   IF (N_ZONE > 0) THEN
      DO NZ = 1, N_ZONE
         IF (ALLOCATED(P_ZONE(NZ)%NODE_INDEX)) DEALLOCATE(P_ZONE(NZ)%NODE_INDEX)
         ALLOCATE(P_ZONE(NZ)%NODE_INDEX(ZONE_COUNTER(NZ)))      
         P_ZONE(NZ)%N_DUCTNODES = ZONE_COUNTER(NZ)         
         COUNTER = 1
         DO NN = 1,N_DUCTNODES
            IF (DUCTNODE(NN)%ZONE_INDEX == NZ) THEN
               P_ZONE(NZ)%NODE_INDEX(COUNTER)=NN
               COUNTER = COUNTER + 1               
            ENDIF
         ENDDO   
      ENDDO      
   ENDIF  

   CHANGE = .TRUE.
   DO WHILE (CHANGE)
      CHANGE = .FALSE.
      DO ND = 1, N_DUCTS
         DU => DUCT(ND)
         IF (NODE_COUNTER(DU%NODE_INDEX(1)) /= NODE_COUNTER(DU%NODE_INDEX(2))) THEN
            CHANGE = .TRUE.
            COUNTER = MIN(NODE_COUNTER(DU%NODE_INDEX(1)),NODE_COUNTER(DU%NODE_INDEX(2)))
            DUCT_COUNTER(ND) = COUNTER
            NODE_COUNTER(DU%NODE_INDEX(1)) = COUNTER
            NODE_COUNTER(DU%NODE_INDEX(2)) = COUNTER
         ELSE
            DUCT_COUNTER(ND) = NODE_COUNTER(DU%NODE_INDEX(1))
         ENDIF
      ENDDO 

      IF (N_ZONE > 0) THEN   
         DO NZ = 1, N_ZONE
            COUNTER = 1
            COUNTER2 = 1
            DO NN = 1, P_ZONE(NZ)%N_DUCTNODES
               IF (NN==1) THEN
                  COUNTER = NODE_COUNTER(P_ZONE(NZ)%NODE_INDEX(NN))
                  COUNTER2 = COUNTER
               ELSE
                  IF (COUNTER /= NODE_COUNTER(P_ZONE(NZ)%NODE_INDEX(NN))) &
                     COUNTER2 = MAX(COUNTER2,NODE_COUNTER(P_ZONE(NZ)%NODE_INDEX(NN)))                     
                     COUNTER  = MIN(COUNTER,NODE_COUNTER(P_ZONE(NZ)%NODE_INDEX(NN)))                     
               ENDIF               
            ENDDO
            IF (COUNTER /= COUNTER2) THEN
               CHANGE = .TRUE.
               DO NN = 1, P_ZONE(NZ)%N_DUCTNODES   
                  NODE_COUNTER(P_ZONE(NZ)%NODE_INDEX(NN)) = COUNTER
               ENDDO
            ENDIF
         ENDDO
      ENDIF
   END DO
   
   ALLOCATE(RENUMBER(MAXVAL(NODE_COUNTER)))
   RENUMBER = 0
   N_NETWORKS = 0
   DO NN = 1,N_DUCTNODES
      IF (RENUMBER(NODE_COUNTER(NN)) == 0) THEN
         N_NETWORKS = N_NETWORKS + 1
         RENUMBER(NODE_COUNTER(NN)) = N_NETWORKS
      ENDIF
   ENDDO
   DO NN = 1,N_DUCTNODES
      NODE_COUNTER(NN) = RENUMBER(NODE_COUNTER(NN)) 
   ENDDO
   DO ND = 1,N_DUCTS
      DUCT_COUNTER(ND) = RENUMBER(DUCT_COUNTER(ND))       
   ENDDO
   DEALLOCATE(RENUMBER)
   
   ALLOCATE(NETWORK(N_NETWORKS))
   NETWORK%N_DUCTS=0
   NETWORK%N_DUCTNODES=0
   ALLOCATE(NETWORK_DCOUNTER(N_NETWORKS))
   NETWORK_DCOUNTER=0
   ALLOCATE(NETWORK_NCOUNTER(N_NETWORKS))
   NETWORK_NCOUNTER=0
   COUNTER = 0
   DO ND = 1, N_DUCTS
      NETWORK(DUCT_COUNTER(ND))%N_DUCTS = NETWORK(DUCT_COUNTER(ND))%N_DUCTS + 1
   ENDDO
   DO NN = 1, N_DUCTNODES
      NETWORK(NODE_COUNTER(NN))%N_DUCTNODES = NETWORK(NODE_COUNTER(NN))%N_DUCTNODES + 1
   ENDDO
   DO NN = 1, N_NETWORKS
      ALLOCATE(NETWORK(NN)%DUCT_INDEX(NETWORK(NN)%N_DUCTS))
      ALLOCATE(NETWORK(NN)%NODE_INDEX(NETWORK(NN)%N_DUCTNODES))
      ALLOCATE(NETWORK(NN)%MATRIX_INDEX(NETWORK(NN)%N_DUCTS+NETWORK(NN)%N_DUCTNODES))
      NETWORK(NN)%MATRIX_INDEX = 0
   ENDDO
   DO ND = 1, N_DUCTS
      NETWORK_DCOUNTER(DUCT_COUNTER(ND)) = NETWORK_DCOUNTER(DUCT_COUNTER(ND)) + 1
      NETWORK(DUCT_COUNTER(ND))%DUCT_INDEX(NETWORK_DCOUNTER(DUCT_COUNTER(ND))) = ND
      DUCT_NE(ND) = NETWORK_DCOUNTER(DUCT_COUNTER(ND))
   ENDDO
   DO NN = 1, N_DUCTNODES
      NETWORK_NCOUNTER(NODE_COUNTER(NN)) = NETWORK_NCOUNTER(NODE_COUNTER(NN)) + 1
      NETWORK(NODE_COUNTER(NN))%NODE_INDEX(NETWORK_NCOUNTER(NODE_COUNTER(NN))) = NN
      DUCTNODE_NE(NN) = NETWORK_NCOUNTER(NODE_COUNTER(NN))
   ENDDO
   DEALLOCATE(NETWORK_DCOUNTER)
   DEALLOCATE(NETWORK_NCOUNTER)
   CALL DETERMINE_FIXED_ELEMENTS(T)
   CALL SETUP_SOLUTION_POINTERS
ENDIF

END SUBROUTINE FIND_NETWORKS

SUBROUTINE SETUP_SOLUTION_POINTERS
INTEGER:: NNE,NN,ND,COUNTER
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()
TYPE(NETWORK_TYPE), POINTER :: NE=>NULL()

DO NNE = 1,N_NETWORKS
   COUNTER = 0
   NE => NETWORK(NNE)   
   DO ND=1,NE%N_DUCTS
      DU=>DUCT(NE%DUCT_INDEX(ND))
      IF (DU%FIXED .OR. DU%AREA<=TWO_EPSILON_EB) CYCLE
      COUNTER = COUNTER + 1
      NE%MATRIX_INDEX(ND)=COUNTER
   ENDDO
   DO NN=1,NE%N_DUCTNODES
      DN=>DUCTNODE(NE%NODE_INDEX(NN))      
      IF (DN%FIXED .OR. DN%VENT_INDEX>0) CYCLE
      COUNTER = COUNTER + 1
      NE%MATRIX_INDEX(NE%N_DUCTS+NN)=COUNTER
   ENDDO
   NE%N_MATRIX=COUNTER
ENDDO

END SUBROUTINE SETUP_SOLUTION_POINTERS


SUBROUTINE UPDATE_LOSS(NNE)
USE PHYSICAL_FUNCTIONS,ONLY:GET_VISCOSITY
REAL(EB) :: FRICTION_FACTOR,LOSS_SUM,ZZ_GET(0:N_TRACKED_SPECIES),VISCOSITY
INTEGER, INTENT(IN) :: NNE
INTEGER :: ND,ND2, NN,NUM_OUT
TYPE(DUCT_TYPE), POINTER :: DU=>NULL(),DU2=>NULL()
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()
TYPE(NETWORK_TYPE), POINTER :: NE=>NULL()

NE => NETWORK(NNE)

DO ND = 1, NE%N_DUCTS
   DUCT(NE%DUCT_INDEX(ND))%TOTAL_LOSS=0._EB
ENDDO
NODELOOP : DO NN=1,NE%N_DUCTNODES
  DN => DUCTNODE(NE%NODE_INDEX(NN))  
  NODECLASS: IF (DN%FILTER_INDEX > 0) THEN
     CALL FILTER_UPDATE(NE%NODE_INDEX(NN))
     IF (DUCT(DN%DUCT_INDEX(1))%AREA < TWO_EPSILON_EB .OR. DUCT(DN%DUCT_INDEX(2))%AREA < TWO_EPSILON_EB) CYCLE
     IF(DUCT(DN%DUCT_INDEX(1))%VEL(GUESS)*DN%DIR(1) > 0._EB) THEN
           DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS + &
              DN%FILTER_LOSS*DUCT(DN%DUCT_INDEX(1))%AREA/DUCT(DN%DUCT_INDEX(2))%AREA
     ELSE
        DUCT(DN%DUCT_INDEX(2))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(2))%TOTAL_LOSS + DN%FILTER_LOSS
     ENDIF
  ELSEIF(DN%VENT_INDEX > 0) THEN NODECLASS
     IF (DUCT(DN%DUCT_INDEX(1))%AREA < TWO_EPSILON_EB) CYCLE
     IF(DUCT(DN%DUCT_INDEX(1))%VEL(GUESS)*DN%DIR(1) < 0._EB) THEN
        DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS + DN%LOSS_ARRAY(1,2)
     ELSE
        DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS + DN%LOSS_ARRAY(2,1)
     ENDIF  
  ELSEIF(DN%FILTER_INDEX <=0 .AND. DN%N_DUCTS==2) THEN
     IF (DUCT(DN%DUCT_INDEX(1))%AREA < TWO_EPSILON_EB .OR. DUCT(DN%DUCT_INDEX(2))%AREA < TWO_EPSILON_EB) CYCLE
     IF(ABS(DUCT(DN%DUCT_INDEX(1))%VEL(GUESS)) > 1.E-6_EB) THEN
        IF(DUCT(DN%DUCT_INDEX(1))%VEL(GUESS)*DN%DIR(1) > 0._EB) THEN
           DUCT(DN%DUCT_INDEX(2))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(2))%TOTAL_LOSS + DN%LOSS_ARRAY(1,2)
        ELSE
           DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS + DN%LOSS_ARRAY(1,2)
        ENDIF
     ELSE
        LOSS_SUM = 0.5_EB*(DN%LOSS_ARRAY(1,2) + DN%LOSS_ARRAY(2,1)*DUCT(DN%DUCT_INDEX(2))%AREA/DUCT(DN%DUCT_INDEX(1))%AREA)
        DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(1))%TOTAL_LOSS + &
                                            LOSS_SUM*DUCT(DN%DUCT_INDEX(1))%AREA/DUCT(DN%DUCT_INDEX(2))%AREA
        DUCT(DN%DUCT_INDEX(2))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(2))%TOTAL_LOSS + LOSS_SUM
     ENDIF
  ELSE NODECLASS
     NUM_OUT = 0
     DO ND=1,DN%N_DUCTS
        DU => DUCT(DN%DUCT_INDEX(ND))
        IF (DU%VEL(GUESS)*DN%DIR(ND) < 0._EB .AND. ABS(DU%VEL(GUESS)) > 1.E-6_EB) NUM_OUT = NUM_OUT + 1
     ENDDO
     IF (NUM_OUT==0) THEN
        DO ND=1,DN%N_DUCTS
           DU => DUCT(DN%DUCT_INDEX(ND))
           DO ND2=1,DN%N_DUCTS
              IF (ND2==ND) CYCLE
              DU%TOTAL_LOSS = DU%TOTAL_LOSS + DN%LOSS_ARRAY(ND2,ND)/DN%N_DUCTS
           ENDDO
        ENDDO
     ELSEIF (NUM_OUT==1) THEN
        DO ND=1,DN%N_DUCTS
           DU => DUCT(DN%DUCT_INDEX(ND))
           IF (DU%VEL(GUESS)*DN%DIR(ND) < 0._EB .AND. ABS(DU%VEL(GUESS)) > 1.E-6_EB) THEN
              NUM_OUT = ND
              EXIT
           ENDIF
        ENDDO                
        DO ND=1,DN%N_DUCTS
           IF (ND==NUM_OUT) CYCLE           
           DUCT(DN%DUCT_INDEX(ND))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(ND))%TOTAL_LOSS + &
                                                DN%LOSS_ARRAY(ND,NUM_OUT)*DU%AREA/DUCT(DN%DUCT_INDEX(NUM_OUT))%AREA
        ENDDO
     ELSEIF (NUM_OUT == DN%N_DUCTS - 1) THEN
        DO ND=1,DN%N_DUCTS
           DU => DUCT(DN%DUCT_INDEX(ND))
           IF (DU%VEL(GUESS)*DN%DIR(ND) < 0._EB .AND. ABS(DU%VEL(GUESS)) > 1.E-6_EB) THEN
              CYCLE
           ELSE
              NUM_OUT = ND
              EXIT
           ENDIF
        ENDDO        
        DO ND=1,DN%N_DUCTS
           IF (ND==NUM_OUT) CYCLE
           DUCT(DN%DUCT_INDEX(ND))%TOTAL_LOSS = DUCT(DN%DUCT_INDEX(ND))%TOTAL_LOSS + DN%LOSS_ARRAY(NUM_OUT,ND)
        ENDDO
     ELSE
         LOSS_SUM = 0._EB
         DO ND=1,DN%N_DUCTS
            DU => DUCT(DN%DUCT_INDEX(ND))
            IF(DU%VEL(GUESS)*DN%DIR(ND) > 0._EB)  LOSS_SUM = LOSS_SUM + DU%VEL(GUESS)*DN%DIR(ND)*DU%AREA
         ENDDO
         DO ND=1,DN%N_DUCTS
            DU => DUCT(DN%DUCT_INDEX(ND))            
            IF (DU%VEL(GUESS)*DN%DIR(ND) < 0._EB .AND. ABS(DU%VEL(GUESS)) > 1.E-6_EB) THEN
               DO ND2=1,DN%N_DUCTS
                  DU2 => DUCT(DN%DUCT_INDEX(ND2))
                  IF (DU2%VEL(GUESS)*DN%DIR(ND2) > 0._EB) DU%TOTAL_LOSS = DU%TOTAL_LOSS + &
                                                          DU2%VEL(GUESS)*DN%DIR(ND2)*DU2%AREA*DN%LOSS_ARRAY(ND2,ND)/LOSS_SUM
               ENDDO
            ENDIF
         ENDDO
     ENDIF
  ENDIF NODECLASS
ENDDO NODELOOP

DO ND = 1, NE%N_DUCTS
   DU => DUCT(NE%DUCT_INDEX(ND))
   IF (DU%ROUGHNESS > TWO_EPSILON_EB) THEN
      ZZ_GET(1:N_TRACKED_SPECIES) = DU%ZZ(1:N_TRACKED_SPECIES)
      CALL GET_VISCOSITY(ZZ_GET,VISCOSITY,DU%TMP_D)
      FRICTION_FACTOR = COMPUTE_FRICTION_FACTOR(DU%RHO_D,VISCOSITY,ABS(DU%VEL(GUESS)),DU%DIAMETER,DU%ROUGHNESS)
   ELSE
      FRICTION_FACTOR = 0._EB
   ENDIF
   IF (DU%VEL(GUESS)>0._EB) THEN
      DU%TOTAL_LOSS = DU%LOSS(1)+DU%TOTAL_LOSS
   ELSEIF (DU%VEL(GUESS)<0._EB) THEN
      DU%TOTAL_LOSS = DU%LOSS(2)+DU%TOTAL_LOSS
   ELSE
      DU%TOTAL_LOSS = DU%TOTAL_LOSS+0.5_EB*(DU%LOSS(1)+DU%LOSS(2))
   ENDIF
   DU%TOTAL_LOSS = DU%TOTAL_LOSS + DU%LENGTH/DU%DIAMETER*FRICTION_FACTOR
   IF (DU%FAN_INDEX>0) THEN
      IF(.NOT. DU%FAN_OPERATING) DU%TOTAL_LOSS = DU%TOTAL_LOSS + FAN(DU%FAN_INDEX)%OFF_LOSS
   ENDIF
ENDDO

END SUBROUTINE UPDATE_LOSS


REAL(EB) FUNCTION COMPUTE_FRICTION_FACTOR(RHO,VISCOSITY,VEL,DIAM,ROUGHNESS)
REAL(EB), INTENT(IN) :: RHO,VISCOSITY,VEL,DIAM,ROUGHNESS
REAL(EB) :: EOD,RE_D

RE_D = MAX(100._EB,RHO*DIAM*VEL/VISCOSITY)
EOD = ROUGHNESS / DIAM
COMPUTE_FRICTION_FACTOR = LOG10(6.9_EB/RE_D+(EOD/3.7_EB)**1.11_EB)
COMPUTE_FRICTION_FACTOR = LOG10(EOD/3.7_EB-4.518_EB/RE_D*COMPUTE_FRICTION_FACTOR)
COMPUTE_FRICTION_FACTOR = (-0.5_EB/COMPUTE_FRICTION_FACTOR)**2

RETURN

END FUNCTION COMPUTE_FRICTION_FACTOR


SUBROUTINE SET_GUESS(NNE,T)
INTEGER, INTENT(IN) :: NNE
REAL(EB), INTENT(INOUT)::T
INTEGER :: ND
REAL(EB) :: VEL_TMP
TYPE(DUCT_TYPE),POINTER :: DU=>NULL()
TYPE(NETWORK_TYPE), POINTER :: NE=>NULL()

NE => NETWORK(NNE)

DO ND = 1,NE%N_DUCTS
   DU => DUCT(NE%DUCT_INDEX(ND))
   IF (DU%FAN_INDEX > 0 .AND. DU%FAN_OPERATING) THEN
      CALL UPDATE_FAN(T,NE%DUCT_INDEX(ND))     
   ELSEIF (DU%FAN_INDEX > 0 .AND. .NOT. DU%FAN_OPERATING) THEN
      DU%DP_FAN = 0._EB
   ENDIF  
   IF (DU%FAN_INDEX > 0 .AND. .NOT. DU%FAN_OPERATING) DU%DP_FAN = 0._EB
   IF (DU%FIXED) THEN
      DU%VEL(PREVIOUS)  = DU%VEL(NEW) 
      DU%VEL(GUESS)     = DU%VEL(NEW)
      CYCLE
   ENDIF
   IF (ITER == 0) THEN
      DU%VEL(GUESS)     = DU%VEL(OLD)
      DU%VEL(NEW)       = DU%VEL(OLD)
      DU%VEL(PREVIOUS)  = DU%VEL(OLD)  
   ELSE
      VEL_TMP = DU%VEL(NEW)
      IF (ABS(DU%VEL(GUESS)) < TWO_EPSILON_EB) THEN
         DU%VEL(GUESS)     = DU%VEL(NEW)         
         DU%VEL(NEW)       = DU%VEL(PREVIOUS)
      ELSEIF (SIGN(1._EB,DU%VEL(PREVIOUS))==SIGN(1._EB,DU%VEL(NEW))) THEN
         DU%VEL(GUESS)     = DU%VEL(NEW)         
         DU%VEL(NEW)       = DU%VEL(PREVIOUS)!0.6_EB*DU%VEL(PREVIOUS)+0.4_EB*DU%VEL(GUESS)
      ELSE
         DU%VEL(GUESS)     = DU%VEL(NEW)         
         DU%VEL(NEW)       = 0._EB
      ENDIF
      DU%VEL(PREVIOUS) = VEL_TMP
   ENDIF
ENDDO

END SUBROUTINE SET_GUESS


SUBROUTINE SET_DONOR(NNE)
USE MATH_FUNCTIONS, ONLY : EVALUATE_RAMP
INTEGER :: ND
INTEGER, INTENT(IN) :: NNE
REAL(EB) :: RHOLAST,TMPLAST,FVAL,OMFVAL,ITERFRAC
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()
TYPE(NETWORK_TYPE), POINTER :: NE=>NULL()

NE => NETWORK(NNE)
ITERFRAC = REAL(ITER,EB)/REAL(ITER_MAX,EB)
FVAL = MIN(1._EB,MAX(0._EB,(ITERFRAC-ONTH))/ONTH,1._EB)
OMFVAL = 1._EB - FVAL

DUCTLOOP: DO ND=1,NE%N_DUCTS
   DU=>DUCT(NE%DUCT_INDEX(ND))
   IF (DU%AREA < TWO_EPSILON_EB) CYCLE DUCTLOOP
   IF (DU%FIXED .AND. DU%FAN_INDEX < 0) THEN
      DU%VEL(PREVIOUS) = DU%VEL(NEW)
      DU%VEL(GUESS) = DU%VEL(NEW)
   ENDIF      
   RHOLAST = DU%RHO_D   
   TMPLAST = DU%TMP_D
   IF (DU%VEL(PREVIOUS)>0._EB) THEN
      DN=>DUCTNODE(DU%NODE_INDEX(1))
      IF(DN%VENT_INDEX > 0 .OR. DN%AMBIENT .OR. DN%LEAKAGE) THEN
         DN%RHO= DN%RHO_V
         DN%TMP= DN%TMP_V
         IF (N_TRACKED_SPECIES>0) DN%ZZ = DN%ZZ_V
         DN%RSUM = DN%RSUM_V
         DN%CP = DN%CP_V                  
      ENDIF
   ENDIF
   IF (DU%VEL(PREVIOUS)<0._EB) THEN
      DN=>DUCTNODE(DU%NODE_INDEX(2))
      IF(DN%VENT_INDEX > 0 .OR. DN%AMBIENT .OR. DN%LEAKAGE) THEN
         DN%RHO= DN%RHO_V
         DN%TMP= DN%TMP_V
         IF (N_TRACKED_SPECIES>0) DN%ZZ = DN%ZZ_V
         DN%RSUM = DN%RSUM_V
         DN%CP = DN%CP_V                  
      ENDIF
   ENDIF   
   IF (ABS(DU%VEL(PREVIOUS))>0._EB) THEN
      DU%CP_D = DN%CP
      DU%RHO_D = DN%RHO
      DU%TMP_D = DN%TMP
      DU%RSUM_D = DN%RSUM
   ELSE
      DU%CP_D = 0.5_EB*(DUCTNODE(DU%NODE_INDEX(1))%CP+DUCTNODE(DU%NODE_INDEX(2))%CP)
      DU%RHO_D = 0.5_EB*(DUCTNODE(DU%NODE_INDEX(1))%RHO+DUCTNODE(DU%NODE_INDEX(2))%RHO)
      DU%TMP_D = 0.5_EB*(DUCTNODE(DU%NODE_INDEX(1))%TMP+DUCTNODE(DU%NODE_INDEX(2))%TMP)
      DU%RSUM_D = 0.5_EB*(DUCTNODE(DU%NODE_INDEX(1))%RSUM+DUCTNODE(DU%NODE_INDEX(2))%RSUM)
   ENDIF
   IF (ITERFRAC > ONTH) THEN
      DU%RHO_D = FVAL*RHOLAST + OMFVAL*DU%RHO_D
      DU%TMP_D = FVAL*TMPLAST + OMFVAL*DU%TMP_D
   ENDIF   
ENDDO DUCTLOOP

END SUBROUTINE SET_DONOR


SUBROUTINE CONVERGENCE_CHECK(NNE)
INTEGER, INTENT(IN) :: NNE
INTEGER :: NN, ND
LOGICAL :: CONVERGED
REAL(EB) :: MSUM,MTOT,MFLOW,VEL
TYPE(NETWORK_TYPE), POINTER :: NE=>NULL()
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()

NE => NETWORK(NNE)
CONVERGED = .TRUE.
!Check duct velocity convergence
DO ND=1,NE%N_DUCTS
   DU => DUCT(NE%DUCT_INDEX(ND))
   IF (DU%AREA < TWO_EPSILON_EB) CYCLE
   IF (ABS(DU%VEL(PREVIOUS)) < 1.E-5_EB .AND. ABS(DU%VEL(NEW)) < 1.E-5_EB) CYCLE
   IF (DU%VEL(PREVIOUS) < 0._EB .EQV. DU%VEL(NEW) < 0._EB) THEN
        IF (ABS(DU%VEL(PREVIOUS))<=TWO_EPSILON_EB) THEN
           CONVERGED = .FALSE.
           EXIT
        ELSE
         IF (ABS(1._EB-DU%VEL(NEW)/DU%VEL(PREVIOUS)) > 0.05_EB) THEN
           CONVERGED = .FALSE.
            CYCLE
         ENDIF
        ENDIF
   ELSE
      CONVERGED = .FALSE.
   ENDIF
ENDDO
IF (.NOT. CONVERGED) RETURN

!Check node mass conservation convergence
DO NN=1,NE%N_DUCTNODES
   DN => DUCTNODE(NE%NODE_INDEX(NN))
   IF (DN%FIXED) CYCLE
   MSUM = 0._EB
   MTOT = 0._EB
   DO ND=1,DN%N_DUCTS
      DU=>DUCT(DN%DUCT_INDEX(ND))
      IF (ABS(DU%VEL(NEW))<1.E-7_EB) THEN
         VEL = 0._EB
      ELSE
         VEL = DU%VEL(NEW)
      ENDIF
      MFLOW = DN%DIR(ND)*VEL*DU%RHO_D*DU%AREA
      MSUM = MSUM + MFLOW
      MTOT = MTOT + ABS(MFLOW)
   ENDDO
   IF (DN%FILTER_INDEX > 0) THEN
      MFLOW = SUM(DN%FILTER_LOADING(:,3))*DT
      MSUM = MSUM - MFLOW
      MTOT = MTOT + MFLOW
   ENDIF
   IF(ABS(MSUM)< 1.E-6 * MTOT .OR. MTOT < TWO_EPSILON_EB) CYCLE
   CONVERGED = .FALSE.
ENDDO

IF (CONVERGED) ITER=ITER_MAX+1

END SUBROUTINE CONVERGENCE_CHECK


SUBROUTINE COLLAPSE_HVAC_BC

! Takes the MPI gathered mesh array of HVAC boundary conditions and updates the DUCTNODE boundary condition values.
USE PHYSICAL_FUNCTIONS, ONLY : GET_SPECIFIC_GAS_CONSTANT,GET_AVERAGE_SPECIFIC_HEAT
INTEGER:: NN,NM,IZ1,IZ2,ITCOUNT
REAL(EB) :: AREA_SUM,AREA,CPBAR,H_G,TMP_SUM,TMP_NEW,ZZ_GET(0:N_TRACKED_SPECIES),CPBAR2,DCPDT
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()

DO NN=1,N_DUCTNODES
   DN => DUCTNODE(NN)
   IF (DN%VENT_INDEX < 0 .AND. .NOT. DN%LEAKAGE) CYCLE
   IF (DN%VENT_INDEX > 0 .AND. .NOT. DN%LEAKAGE) THEN
      NM = DN%MESH_INDEX
      DN%P = 0.3_EB*NODE_P(NN,NM)+0.7_EB*DN%P
      DN%TMP_V = NODE_TMP(NN,NM)
      DN%RHO_V = NODE_RHO(NN,NM)
      DN%CP_V = NODE_CP(NN,NM)
      DN%RSUM_V = NODE_RSUM(NN,NM)
      IF (N_TRACKED_SPECIES > 0) DN%ZZ_V(1:N_TRACKED_SPECIES) = NODE_ZZ(NN,1:N_TRACKED_SPECIES,NM)
   ENDIF 
   LEAKAGE_IF: IF (DN%LEAKAGE) THEN
      IZ1 = DN%ZONE_INDEX
      IF (DUCT(DN%DUCT_INDEX(1))%NODE_INDEX(1)==NN) THEN
         IZ2 = DUCTNODE(DUCT(DN%DUCT_INDEX(1))%NODE_INDEX(2))%ZONE_INDEX
      ELSE
         IZ2 = DUCTNODE(DUCT(DN%DUCT_INDEX(1))%NODE_INDEX(1))%ZONE_INDEX
      ENDIF
      IF (IZ1 == 0 .AND. ALL(LEAK_RHO(IZ1,IZ2,:) <= TWO_EPSILON_EB)) CYCLE
      DN%TMP_V  = 0._EB
      DN%RHO_V  = 0._EB
      DN%CP_V   = 0._EB
      DN%P      = 0._EB
      DN%RSUM_V = 0._EB
      IF (N_TRACKED_SPECIES > 0) DN%ZZ_V = 0._EB       
      AREA_SUM = 0._EB
      DO NM=1,NMESHES
         AREA = FDS_LEAK_AREA(IZ1,IZ2,NM)
         AREA_SUM = AREA_SUM + AREA
         DN%RHO_V = DN%RHO_V + LEAK_RHO(IZ1,IZ2,NM) * AREA
         DN%TMP_V = DN%TMP_V + LEAK_TMP(IZ1,IZ2,NM) * AREA
         DN%P = DN%P + LEAK_P(IZ1,IZ2,NM) * AREA
         IF (N_TRACKED_SPECIES > 0) THEN
            ZZ_GET(1:N_TRACKED_SPECIES) = LEAK_ZZ(IZ1,IZ2,1:N_TRACKED_SPECIES,NM)
            DN%ZZ_V(1:N_TRACKED_SPECIES) = DN%ZZ_V(1:N_TRACKED_SPECIES) + ZZ_GET(1:N_TRACKED_SPECIES) * LEAK_RHO(IZ1,IZ2,NM) * AREA
         ENDIF
         CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CPBAR,LEAK_TMP(IZ1,IZ2,NM))
         H_G = CPBAR * LEAK_TMP(IZ1,IZ2,NM)
         DN%CP_V = DN%CP_V + H_G * AREA * LEAK_RHO(IZ1,IZ2,NM)
      ENDDO    
      FDS_LEAK_AREA(IZ1,IZ2,:) = AREA_SUM
      IF (AREA_SUM < TWO_EPSILON_EB) CYCLE
      IF (N_TRACKED_SPECIES>0) THEN
         DN%ZZ_V = DN%ZZ_V / DN%RHO_V
         ZZ_GET(1:N_TRACKED_SPECIES) = DN%ZZ_V(1:N_TRACKED_SPECIES)
         CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,DN%RSUM_V)
      ELSE
         DN%RSUM_V = RSUM0
      ENDIF  
      DN%TMP_V = DN%TMP_V / AREA_SUM
      DN%CP_V = DN%CP_V / DN%RHO_V
      DN%RHO_V = DN%RHO_V / AREA_SUM
      DN%P = DN%P/AREA_SUM
      TMP_SUM = DN%TMP_V
      ITCOUNT = 0
      DO
         ITCOUNT = ITCOUNT + 1
         CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CPBAR,TMP_SUM)      
         IF (TMP_SUM > 1._EB) THEN
            CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CPBAR2,TMP_SUM-1._EB)  
            DCPDT = CPBAR - CPBAR2
         ELSE
            CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CPBAR2,TMP_SUM+1._EB)  
            DCPDT = CPBAR2 - CPBAR
         ENDIF    
         TMP_NEW = TMP_SUM + (DN%CP_V - TMP_SUM*CPBAR)/(CPBAR+TMP_SUM*DCPDT)
         IF (ABS(TMP_SUM - TMP_NEW) < SPACING(TMP_NEW) .OR. ABS(TMP_SUM - TMP_NEW)/TMP_NEW < 0.0005_EB) EXIT
         IF (ITCOUNT>10) THEN
            TMP_NEW = 0.5_EB*(TMP_SUM+TMP_NEW)
            CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,CPBAR,TMP_SUM)  
            EXIT
         ENDIF
         TMP_SUM = TMP_NEW
      ENDDO
      DN%TMP_V = TMP_NEW
      DN%CP_V = CPBAR
   ENDIF LEAKAGE_IF
END DO

END SUBROUTINE COLLAPSE_HVAC_BC


SUBROUTINE UPDATE_NODE_BC
!Takes the MPI gathered mesh array of HVAC boundary conditions and updates the DUCTNODE boundary condition values.
INTEGER:: NN, NS, ND
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()

DO NN=1,N_DUCTNODES
   DN => DUCTNODE(NN)
   IF (DN%VENT_INDEX < 0) CYCLE
   NODE_P(NN,:) = DN%P
   NODE_TMP(NN,:) = DN%TMP
   IF(DN%VENT_INDEX > 0 .AND. DN%DIR(1)*DUCT(DN%DUCT_INDEX(1))%VEL(NEW) > 0._EB) THEN
      NODE_RHO(NN,:) = DUCT(DN%DUCT_INDEX(1))%RHO_D
   ELSE
      NODE_RHO(NN,:) = DN%RHO
   ENDIF   
   NODE_CP(NN,:) = DN%CP
   NODE_RSUM(NN,:) = DN%RSUM
   IF (N_TRACKED_SPECIES > 0) THEN
      DO NS=1,N_TRACKED_SPECIES
         NODE_ZZ(NN,NS,:) = DN%ZZ(NS)
      ENDDO
   ENDIF
END DO

DO ND=1,N_DUCTS
   DUCT_MF(ND,:) = DUCT(ND)%VEL(NEW)*DUCT(ND)%AREA*DUCT(ND)%RHO_D
ENDDO

END SUBROUTINE UPDATE_NODE_BC


SUBROUTINE LEAKAGE_HVAC

USE PHYSICAL_FUNCTIONS, ONLY: GET_AVERAGE_SPECIFIC_HEAT
REAL(EB) :: ZZ_GET(0:N_TRACKED_SPECIES)
INTEGER :: I_DUCT,I_DUCTNODE,NZ1,NZ2
TYPE (DUCTNODE_TYPE), POINTER:: DN1=>NULL(),DN2=>NULL()
TYPE (DUCT_TYPE), POINTER:: DU=>NULL()

I_DUCT = N_DUCTS - LEAK_DUCTS
I_DUCTNODE = N_DUCTNODES - 2 * LEAK_DUCTS

DO NZ1 = 0, N_ZONE
   DO NZ2 = 0, N_ZONE
      IF (LEAK_PATH(NZ1,NZ2) == 1) THEN
         I_DUCT = I_DUCT + 1
         LEAK_PATH(NZ1,NZ2) = I_DUCT
         I_DUCTNODE = I_DUCTNODE + 1
         DU => DUCT(I_DUCT)
         DU%AREA_INITIAL = P_ZONE(NZ2)%LEAK_AREA(NZ1)
         DU%AREA = P_ZONE(NZ2)%LEAK_AREA(NZ1)
         DU%DIAMETER = SQRT(DU%AREA / PI)*2._EB
         DU%LEAKAGE = .TRUE.
         WRITE(DU%ID,'(A,1X,I0,1X,I0)') 'LEAK',NZ1,NZ2 
         DU%LENGTH = 1._EB         
         DU%LOSS(1) = 1._EB                  
         DU%LOSS(2) = 1._EB
         DU%NODE_INDEX(1) = I_DUCTNODE
         DU%NODE_INDEX(2) = I_DUCTNODE+1
         DU%RHO_D = RHOA
         DU%TMP_D = TMPA
         DU%ROUGHNESS = 0._EB
         DU%VEL = 0._EB
         IF (N_TRACKED_SPECIES > 0) THEN
            ALLOCATE(DU%ZZ(N_TRACKED_SPECIES))
            ZZ_GET(1:N_TRACKED_SPECIES) = SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%ZZ0
            DU%ZZ(1:N_TRACKED_SPECIES) = ZZ_GET(1:N_TRACKED_SPECIES)
         ENDIF
         CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_GET,DU%CP_D,TMPA)
         DN1=>DUCTNODE(I_DUCTNODE)
         IF (NZ1==0) DN1%AMBIENT = .TRUE.
         ALLOCATE(DN1%DUCT_INDEX(1))
         ALLOCATE(DN1%DIR(1))
         ALLOCATE(DN1%LOSS_ARRAY(2,2))            
         DN1%LOSS_ARRAY = 0._EB
         DN1%DIR = -1._EB
         DN1%DUCT_INDEX = I_DUCT
         DN1%LEAKAGE = .TRUE.
         DN1%ZONE_INDEX=NZ1
         DN1%MESH_INDEX = 1         
         DN1%N_DUCTS = 1
         DN1%RSUM = RSUM0
         DN1%TMP = TMPA                
         DN1%XYZ = (/0._EB,0._EB,0._EB/)
         WRITE(DN1%ID,'(A,1X,I0,1X,I0)') 'LEAK',NZ1,NZ2
         I_DUCTNODE = I_DUCTNODE + 1
         DN2=>DUCTNODE(I_DUCTNODE)
         IF (NZ2==0) DN2%AMBIENT = .TRUE.
         ALLOCATE(DN2%DUCT_INDEX(1))
         ALLOCATE(DN2%DIR(1))
         ALLOCATE(DN2%LOSS_ARRAY(2,2))            
         DN2%LOSS_ARRAY = 0._EB
         DN2%DIR = 1._EB
         DN2%DUCT_INDEX = I_DUCT
         DN2%LEAKAGE = .TRUE.
         DN2%ZONE_INDEX=NZ2
         DN2%XYZ = (/0._EB,0._EB,0._EB/)
         DN2%MESH_INDEX = 1
         DN2%N_DUCTS = 1
         DN2%RSUM = RSUM0
         DN2%TMP = TMPA         
         WRITE(DN2%ID,'(A,1X,I0,1X,I0)') 'LEAK',NZ2,NZ1
      ENDIF
   ENDDO
ENDDO

END SUBROUTINE LEAKAGE_HVAC


SUBROUTINE FILTER_UPDATE(NODE_INDEX)
!Updates filter loss and loading solution
USE MATH_FUNCTIONS,ONLY:EVALUATE_RAMP
INTEGER,INTENT(IN)::NODE_INDEX
REAL(EB) :: TOTAL_LOADING
TYPE(DUCTNODE_TYPE),POINTER::DN,DN2
TYPE(DUCT_TYPE),POINTER::DU
TYPE(FILTER_TYPE),POINTER:: FI

DN => DUCTNODE(NODE_INDEX)
FI => FILTER(DN%FILTER_INDEX)

TOTAL_LOADING = DOT_PRODUCT(FI%MULTIPLIER,DN%FILTER_LOADING(:,1))
IF (FI%RAMP_INDEX > 0) THEN
   DN%FILTER_LOSS = EVALUATE_RAMP(TOTAL_LOADING,0._EB,FI%RAMP_INDEX)
ELSE
   DN%FILTER_LOSS = FI%CLEAN_LOSS + FI%LOADING_LOSS*TOTAL_LOADING
ENDIF

DU=>DUCT(DN%DUCT_INDEX(1))
IF (DU%VEL(GUESS) >= 0._EB .AND. DU%NODE_INDEX(2)==NODE_INDEX) THEN
  DN2 => DUCTNODE(DU%NODE_INDEX(1))
ELSEIF (DU%VEL(GUESS) <= 0._EB .AND. DU%NODE_INDEX(1)==NODE_INDEX) THEN
  DN2 => DUCTNODE(DU%NODE_INDEX(2))
ELSE
   DU=>DUCT(DN%DUCT_INDEX(2))
   IF (DU%VEL(GUESS) >= 0._EB .AND. DU%NODE_INDEX(2)==NODE_INDEX) THEN
   DN2 => DUCTNODE(DU%NODE_INDEX(1))
   ELSE
   DN2 => DUCTNODE(DU%NODE_INDEX(2))
   ENDIF
ENDIF

!Ultimately add in logic for condensible gases
DN%FILTER_LOADING(:,3) = DU%AREA*ABS(DU%VEL(GUESS))*DN2%RHO*DOT_PRODUCT(DN2%ZZ,FI%EFFICIENCY)
DN%FILTER_LOADING(:,2) = DN%FILTER_LOADING(:,1) + DN%FILTER_LOADING(:,3) * DT

END SUBROUTINE FILTER_UPDATE


SUBROUTINE COIL_UPDATE(T)
USE MATH_FUNCTIONS, ONLY : EVALUATE_RAMP
REAL(EB), INTENT(IN) :: T
REAL(EB) :: TMP_IN,TMP_OUT,MDOT_DU,E_IN_G,CP,TSI
INTEGER :: ND
TYPE(DUCT_TYPE),POINTER::DU
TYPE(AIRCOIL_TYPE),POINTER:: AC

COIL_LOOP: DO ND = 1,N_DUCTS
   DU => DUCT(ND)
   IF (DU%AIRCOIL_INDEX < 0) CYCLE COIL_LOOP
   IF (DU%DEVC_INDEX > 0) THEN
      DU%COIL_OPERATING = DEVICE(DU%DEVC_INDEX)%CURRENT_STATE
      IF (DU%COIL_OPERATING .AND. (DEVICE(DU%DEVC_INDEX)%CURRENT_STATE .NEQV. DEVICE(DU%DEVC_INDEX)%PRIOR_STATE)) &
            DU%COIL_ON_TIME = T
   ENDIF
   IF (DU%CTRL_INDEX > 0) THEN
      DU%COIL_OPERATING = CONTROL(DU%CTRL_INDEX)%CURRENT_STATE
      IF (DU%COIL_OPERATING .AND. (CONTROL(DU%CTRL_INDEX)%CURRENT_STATE .NEQV. CONTROL(DU%CTRL_INDEX)%PRIOR_STATE)) &
            DU%COIL_ON_TIME = T
   ENDIF

   DU%COIL_Q = 0._EB
   IF (.NOT. DU%COIL_OPERATING) CYCLE COIL_LOOP

   AC => AIRCOIL(DU%AIRCOIL_INDEX)
   IF (AC%FIXED_Q > -1.E9_EB) THEN
      TSI = T - DU%COIL_ON_TIME
      DU%COIL_Q = AC%FIXED_Q*EVALUATE_RAMP(TSI,AC%TAU,AC%RAMP_INDEX)      
   ELSE
      TMP_IN = DU%TMP_D
      CP = DU%CP_D
      MDOT_DU = DU%RHO_D*ABS(DU%VEL(GUESS))*DU%AREA
      E_IN_G = MDOT_DU*TMP_IN*CP
      TMP_OUT = (CP*MDOT_DU*TMP_IN + AC%COOLANT_TEMPERATURE*AC%COOLANT_MASS_FLOW*AC%COOLANT_SPECIFIC_HEAT)/&
                (CP*MDOT_DU + AC%COOLANT_MASS_FLOW*AC%COOLANT_SPECIFIC_HEAT)          
      DU%COIL_Q = AC%COOLANT_MASS_FLOW * AC%COOLANT_SPECIFIC_HEAT*(AC%COOLANT_TEMPERATURE - TMP_OUT)*AC%EFFICIENCY
   ENDIF
END DO COIL_LOOP

END SUBROUTINE COIL_UPDATE


SUBROUTINE GET_REV_HVAC(MODULE_REV,MODULE_DATE)
INTEGER,INTENT(INOUT) :: MODULE_REV
CHARACTER(255),INTENT(INOUT) :: MODULE_DATE
WRITE(MODULE_DATE,'(A)') hvacrev(INDEX(hvacrev,':')+2:LEN_TRIM(hvacrev)-2)
READ (MODULE_DATE,'(I5)') MODULE_REV
WRITE(MODULE_DATE,'(A)') hvacdate
END SUBROUTINE GET_REV_HVAC
 
END MODULE HVAC_ROUTINES
