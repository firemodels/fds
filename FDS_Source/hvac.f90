MODULE HVAC_ROUTINES
 
! Compute the HVAC mass and energy transport
 
USE PRECISION_PARAMETERS
USE GLOBAL_CONSTANTS
USE MESH_POINTERS
USE DEVICE_VARIABLES
USE CONTROL_VARIABLES
USE COMP_FUNCTIONS, ONLY: SECOND, CHECKREAD, SHUTDOWN
USE MEMORY_FUNCTIONS, ONLY: ChkMemErr
 
IMPLICIT NONE

REAL(EB), ALLOCATABLE, DIMENSION(:,:):: NODE_CP,NODE_P,NODE_TMP,NODE_RHO,NODE_RSUM,DUCT_U
REAL(EB), ALLOCATABLE, DIMENSION(:,:,:):: NODE_YY
REAL(EB), ALLOCATABLE, DIMENSION(:,:,:):: LEAK_CP,LEAK_TMP,LEAK_RHO,LEAK_RSUM
REAL(EB), ALLOCATABLE, DIMENSION(:,:,:,:):: LEAK_YY
INTEGER :: LEAK_DUCTS = 0
INTEGER, ALLOCATABLE, DIMENSION(:,:):: LEAK_PATH
CHARACTER(255), PARAMETER :: hvacid='$Id$'
CHARACTER(255), PARAMETER :: hvacrev='$Revision$'
CHARACTER(255), PARAMETER :: hvacdate='$Date$'
CHARACTER(100) :: MESSAGE
REAL(EB), ALLOCATABLE, DIMENSION(:,:) :: LHS
REAL(EB), ALLOCATABLE, DIMENSION(:) :: RHS
INTEGER :: ITER,ITER_MAX=10

PUBLIC HVAC_CALC,GET_REV_hvac,READ_HVAC,HVAC_BC_IN,FIND_NETWORKS
 
CONTAINS

SUBROUTINE READ_HVAC
!Read and process HVAC networks
USE MATH_FUNCTIONS, ONLY: GET_RAMP_INDEX
USE MISC_FUNCTIONS, ONLY: SEARCH_CONTROLLER
USE PHYSICAL_FUNCTIONS, ONLY:GET_AVERAGE_SPECIFIC_HEAT
INTEGER , PARAMETER :: MAX_DUCTS = 10
INTEGER :: I1,I2,J1,J2,K1,K2,IOR
INTEGER :: IOS,IZERO,N_HVAC_READ,NS,N,ND,ND2,NM,NN,NF,NV,ITMP,I_DUCT=0,I_DUCTNODE=0,I_FAN=0 !, &
!            AIRCOIL_INDEX,I_AIRCOIL=0,FAN_INDEX, INDEX,I_FILTER=0
REAL(EB) :: AREA,DIAMETER,XYZ(3),LOSS(MAX_DUCTS,MAX_DUCTS),VOLUME_FLOW,MAX_FLOW,MAX_PRESSURE,ROUGHNESS,LENGTH,TNOW, &
            TMP_WGT,TAU_FAN,TAU_VF,CP,YY_GET(1:N_TRACKED_SPECIES)
LOGICAL :: ROUND, SQUARE, DAMPER, REVERSE, AMBIENT
CHARACTER(30) :: TYPE_ID,DEVC_ID,CTRL_ID,DUCT_ID(MAX_DUCTS),NODE_ID(2),VENT_ID,TABLE_ID,FAN_ID,AIRCOIL_ID,RAMP_ID,ID 
! CHARACTER(30) :: SUBTYPE,FILTER_ID
CHARACTER(30), ALLOCATABLE, DIMENSION(:,:) :: NODE_DUCT_A,DUCT_NODE_A
CHARACTER(30), ALLOCATABLE, DIMENSION(:) :: NODE_FILTER_A,DUCT_FAN_A
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
!TYPE(FILTER_TYPE), POINTER :: FI=>NULL()
!TYPE(AIRCOIL_TYPE), POINTER :: AC=>NULL()
NAMELIST /HVAC/ TYPE_ID,AREA,DIAMETER,ROUND,SQUARE,LENGTH,DAMPER,REVERSE,LOSS,DUCT_ID,NODE_ID,FAN_ID, &!FILTER_ID,AIRCOIL_ID, &
                VENT_ID,DEVC_ID,CTRL_ID,RAMP_ID,TABLE_ID,ID,VOLUME_FLOW,MAX_FLOW,MAX_PRESSURE,ROUGHNESS,XYZ,AMBIENT,TAU_VF,TAU_FAN

TNOW=SECOND()

N_HVAC_READ = 0
 
REWIND(LU_INPUT)
COUNT_HVAC_LOOP: DO
   CALL CHECKREAD('HVAC',LU_INPUT,IOS)
   IF (IOS==1) EXIT COUNT_HVAC_LOOP
   READ(LU_INPUT,HVAC,END=15,ERR=16,IOSTAT=IOS)
   N_HVAC_READ = N_HVAC_READ + 1
   16 IF (IOS>0) THEN
         WRITE(MESSAGE,'(A,I2)') 'ERROR: Problem with HVAC line number ',N_HVAC_READ+1
         CALL SHUTDOWN(MESSAGE)
      ENDIF
   SELECT CASE(TYPE_ID)
      CASE ('DUCT')
         N_DUCTS = N_DUCTS + 1
      CASE ('NODE')
         N_DUCTNODES = N_DUCTNODES + 1
      CASE ('FILTER')
         N_FILTERS = N_FILTERS + 1
      CASE ('FAN')
         N_FANS = N_FANS + 1
      CASE ('AIRCOIL')
         N_AIRCOILS = N_AIRCOILS + 1
   END SELECT
ENDDO COUNT_HVAC_LOOP
15 CONTINUE

LEAK_DUCTS = 0
IF (ANY(SURFACE%LEAK_PATH(1)>0).OR.ANY(SURFACE%LEAK_PATH(2)>0)) THEN 
   ALLOCATE(LEAK_PATH(0:N_ZONE,0:N_ZONE),STAT=IZERO)
   CALL ChkMemErr('HVAC','LEAK_PATH',IZERO)
   LEAK_PATH = 0
   DO NS=1,N_SURF
      IF (SURFACE(NS)%LEAK_PATH(1)>0 .OR. SURFACE(NS)%LEAK_PATH(2)>0) &
         LEAK_PATH(MINVAL(SURFACE(NS)%LEAK_PATH),MAXVAL(SURFACE(NS)%LEAK_PATH))=1
   ENDDO
   LEAK_DUCTS = SUM(LEAK_PATH)
   N_DUCTS = N_DUCTS + LEAK_DUCTS
   N_DUCTNODES = N_DUCTNODES + 2 * LEAK_DUCTS
ENDIF

IF (N_HVAC_READ > 0) HVAC_SOLVE = .TRUE.

IF ((N_DUCTS > 0 .AND. N_DUCTNODES <= 0) .OR. (N_DUCTS <= 0 .AND. N_DUCTNODES > 0)) THEN
   WRITE(MESSAGE,'(A)') 'ERROR: Must have both DUCTs and DUCTNODEs in the input file'
   CALL SHUTDOWN(MESSAGE)
ENDIF

ALLOCATE(DUCT(N_DUCTS),STAT=IZERO)
CALL ChkMemErr('HVAC','DUCT',IZERO)
ALLOCATE(DUCT_NE(N_DUCTS),STAT=IZERO)
CALL ChkMemErr('HVAC','DUCT_NE',IZERO)
DUCT_NE = 0
ALLOCATE(DUCTNODE(N_DUCTNODES),STAT=IZERO)
CALL ChkMemErr('HVAC','DUCTNODE',IZERO)
ALLOCATE(DUCTNODE_NE(N_DUCTNODES),STAT=IZERO)
CALL ChkMemErr('HVAC','DUCTNODE_NE',IZERO)
DUCTNODE_NE = 0
ALLOCATE(FILTER(N_FILTERS),STAT=IZERO)
CALL ChkMemErr('HVAC','FILTER',IZERO)
ALLOCATE(FAN(N_FANS),STAT=IZERO)
CALL ChkMemErr('HVAC','FAN',IZERO)
ALLOCATE(AIRCOIL(N_AIRCOILS),STAT=IZERO)
CALL ChkMemErr('HVAC','AIRCOIL',IZERO)

!Temp arrays for input processing
ALLOCATE(DUCT_NODE_A(N_DUCTNODES,2),STAT=IZERO)
CALL ChkMemErr('HVAC','NODE_DUCTS',IZERO)
ALLOCATE(NODE_DUCT_A(N_DUCTNODES,10),STAT=IZERO)
CALL ChkMemErr('HVAC','NODE_DUCTS',IZERO)
ALLOCATE(NODE_FILTER_A(N_DUCTNODES),STAT=IZERO)
CALL ChkMemErr('HVAC','NODE_DUCTS',IZERO)
ALLOCATE(DUCT_FAN_A(N_DUCTS),STAT=IZERO)
CALL ChkMemErr('HVAC','DUCT_FAN',IZERO)

REWIND(LU_INPUT)
DO NN=1,N_HVAC_READ
   CALL SET_HVAC_DEFAULTS
   READ(LU_INPUT,HVAC)   
   SELECT CASE (TYPE_ID)
      CASE('DUCT')
         I_DUCT = I_DUCT + 1
         DU=> DUCT(I_DUCT)
         DU%ID   = ID
         IF (AREA < 0._EB) THEN
            IF (DIAMETER < 0._EB) THEN
              WRITE(MESSAGE,'(A,I2)') 'ERROR: Duct must have area or diameter specifiied, HVAC line number ',NN
              CALL SHUTDOWN(MESSAGE)
            ENDIF
            AREA = 0.5_EB*PIO2*DIAMETER**2
         ENDIF
         IF (DIAMETER < 0._EB) THEN
            IF (AREA < 0._EB) THEN
              WRITE(MESSAGE,'(A,I2)') 'ERROR: Duct must have area or diameter specified, HVAC line number ',NN
              CALL SHUTDOWN(MESSAGE)
            ENDIF
            DIAMETER = SQRT(2._EB*AREA/PIO2)
         ENDIF
         DU%AREA_INITIAL = AREA
         DU%AREA = AREA
         DU%DIAMETER = DIAMETER
         DU%LENGTH = LENGTH         
         DU%REVERSE = REVERSE
         IF (N_TRACKED_SPECIES > 0) THEN
            ALLOCATE(DU%YY(N_TRACKED_SPECIES))
            DU%YY(1:N_TRACKED_SPECIES) = YY_AMBIENT(1:N_TRACKED_SPECIES)
         ENDIF
!         IF (LOSS(1) < 0._EB .AND. VOLUME_FLOW > 1.E6_EB) THEN
!            WRITE(MESSAGE,'(A,I2)') 'ERROR: Duct needs a loss coefficient, HVAC line number ',NN
!            CALL SHUTDOWN(MESSAGE)
!         ENDIF
         DU%LOSS(1:2) = MAX(0._EB,LOSS(1:2,1))
         IF (CTRL_ID /='null' .AND. DEVC_ID /='null') THEN
            WRITE(MESSAGE,'(A,I2)') 'ERROR: Can only specify one of CTRL_ID or DEVC_ID, HVAC line number ',NN
            CALL SHUTDOWN(MESSAGE)
         ENDIF
         IF (DAMPER .AND. (FAN_ID /='null' .OR. AIRCOIL_ID /='null') .OR. &
             FAN_ID/='null' .AND. (DAMPER .OR. AIRCOIL_ID /='null') .OR. &
             AIRCOIL_ID/='null' .AND. (DAMPER .OR. FAN_ID /='null')) THEN
            WRITE(MESSAGE,'(A,I2)') 'ERROR: Duct can only have one of damper, fan or aircoil, HVAC line number ',NN
            CALL SHUTDOWN(MESSAGE)
         ENDIF
         IF (FAN_ID/='null' .AND. N_FANS<=0) THEN
            WRITE(MESSAGE,'(A,I2)') 'ERROR: Duct has fan specied but no fans have been defined, HVAC line number ',NN
            CALL SHUTDOWN(MESSAGE)
         ENDIF
         DU%DAMPER = DAMPER
         DUCT_FAN_A(I_DUCT) = FAN_ID
         IF (CTRL_ID /= 'null' .OR. DEVC_ID /= 'null') CALL SEARCH_CONTROLLER('HVAC',CTRL_ID,DEVC_ID,DU%DEVC_INDEX,DU%CTRL_INDEX,N)
         IF (DAMPER) THEN
            IF (DU%DEVC_INDEX > 0) THEN
                DU%DAMPER_OPEN = DEVICE(DU%DEVC_INDEX)%INITIAL_STATE                
            ELSEIF (DU%CTRL_INDEX > 0) THEN
                DU%DAMPER_OPEN = CONTROL(DU%CTRL_INDEX)%INITIAL_STATE                
            ELSE
                DU%DAMPER_OPEN = .TRUE.
            ENDIF
            IF (.NOT. DU%DAMPER_OPEN) DU%AREA = 0._EB
         ELSEIF (FAN_ID /='null') THEN
            IF (DU%DEVC_INDEX > 0) THEN
                DU%FAN_OPERATING = DEVICE(DU%DEVC_INDEX)%INITIAL_STATE                
            ELSEIF (DU%CTRL_INDEX > 0) THEN
                DU%FAN_OPERATING = CONTROL(DU%CTRL_INDEX)%INITIAL_STATE                
            ELSE
                DU%FAN_OPERATING = .TRUE.
            ENDIF
         ELSEIF (AIRCOIL_ID /='null') THEN
         ENDIF     
         IF (SQUARE) ROUND = .FALSE.
         DU%ROUND = ROUND
         DU%SQUARE = SQUARE
         DUCT_NODE_A(I_DUCT,:) = NODE_ID
         DU%VOLUME_FLOW_INITIAL = VOLUME_FLOW
         DU%ROUGHNESS = ROUGHNESS
         DU%TAU = TAU_VF
         IF (TAU_VF > 0._EB) DU%RAMP_INDEX = TANH_RAMP 
         IF (TAU_VF < 0._EB) DU%RAMP_INDEX = TSQR_RAMP
      CASE('NODE')
         I_DUCTNODE = I_DUCTNODE + 1
         NODE_DUCT_A(I_DUCTNODE,:) = DUCT_ID         
         DN => DUCTNODE(I_DUCTNODE)
         DN%ID = ID
         DN%VENT_ID = VENT_ID
         DN%TABLE_ID = TABLE_ID
         DN%XYZ      = XYZ
         DN%AMBIENT  = AMBIENT
         DO ND = 1, MAX_DUCTS
            IF (NODE_DUCT_A(I_DUCTNODE,ND) == 'null') EXIT
            DN%N_DUCTS=ND
         ENDDO
         ALLOCATE(DN%LOSS_ARRAY(MAX(2,DN%N_DUCTS),MAX(2,DN%N_DUCTS)))
         DN%LOSS_ARRAY = 0._EB
         IF (DN%N_DUCTS >=2) THEN
            DN%LOSS_ARRAY = LOSS(1:DN%N_DUCTS,1:DN%N_DUCTS)
         ELSE
            DN%LOSS_ARRAY(1,2) = LOSS(1,1)
            DN%LOSS_ARRAY(2,1) = LOSS(2,1)
         ENDIF
      CASE('FAN')
         I_FAN = I_FAN + 1
         FAN(I_FAN)%ID = ID
         FAN(I_FAN)%OFF_LOSS = LOSS(1,1)
         FAN(I_FAN)%FAN_RAMP = RAMP_ID
         FAN(I_FAN)%VOL_FLOW = VOLUME_FLOW
         FAN(I_FAN)%MAX_PRES = MAX_PRESSURE
         FAN(I_FAN)%MAX_FLOW = MAX_FLOW
         IF (RAMP_ID /= 'null') CALL GET_RAMP_INDEX(RAMP_ID,'FAN',FAN(I_FAN)%RAMP_INDEX)
         FAN(I_FAN)%TAU = TAU_FAN
         IF (TAU_FAN > 0._EB) FAN(I_FAN)%SPIN_INDEX = TANH_RAMP 
         IF (TAU_FAN < 0._EB) FAN(I_FAN)%SPIN_INDEX = TSQR_RAMP
         IF(( (MAX_FLOW<1.E6_EB .OR. MAX_PRESSURE<1.E6_EB) .AND. (VOLUME_FLOW<1.E6_EB .OR. RAMP_ID/='null')))THEN !.OR. &
            WRITE(MESSAGE,'(A,I2)') 'ERROR: FAN can only be one of constant volume, quadratic or ramp, HVAC line number ',NN
            CALL SHUTDOWN(MESSAGE)
         ENDIF
         IF ((MAX_PRESSURE<1.E6_EB .AND. MAX_FLOW>1.E6_EB) .OR. (MAX_PRESSURE>1.E6_EB .AND. MAX_FLOW<1.E6_EB)) THEN
            WRITE(MESSAGE,'(A,I2)') 'ERROR: IF one of MAX_PRESSURE or MAX_FLOW given, both must be specified, HVAC line number '&
                                    ,NN
            CALL SHUTDOWN(MESSAGE)
         ENDIF
         IF (VOLUME_FLOW < 1.E6_EB) THEN
            FAN(I_FAN)%FAN_TYPE = 1
         ELSEIF(RAMP_ID/='null') THEN
            FAN(I_FAN)%FAN_TYPE = 3
         ELSE
            FAN(I_FAN)%FAN_TYPE = 2            
         ENDIF
   END SELECT
ENDDO

IF (LEAK_DUCTS > 0) THEN
   HVAC_SOLVE = .TRUE.
   CALL LEAKAGE_HVAC
   DUCT(N_DUCTS - LEAK_DUCTS + 1:N_DUCTS)%LEAKAGE=.TRUE.
   DUCTNODE(N_DUCTNODES - 2*LEAK_DUCTS + 1:N_DUCTNODES)%LEAKAGE=.TRUE.
   ALLOCATE(LEAK_TMP(0:N_ZONE,0:N_ZONE,1:NMESHES))
   LEAK_TMP = TMPA
   ALLOCATE(LEAK_RHO(0:N_ZONE,0:N_ZONE,1:NMESHES))
   LEAK_RHO = RHOA
   ALLOCATE(LEAK_RSUM(0:N_ZONE,0:N_ZONE,1:NMESHES))
   LEAK_RSUM = RSUM0
   ALLOCATE(LEAK_CP(0:N_ZONE,0:N_ZONE,1:NMESHES))
   IF (N_TRACKED_SPECIES > 0) THEN
      ALLOCATE(LEAK_YY(0:N_ZONE,0:N_ZONE,1:N_TRACKED_SPECIES,1:NMESHES))
      YY_GET(1:N_TRACKED_SPECIES) =  YY_AMBIENT(1:N_TRACKED_SPECIES)
      DO NS=1,N_TRACKED_SPECIES
         LEAK_YY(:,:,NS,:) = YY_GET(NS)
      ENDDO
      CALL GET_AVERAGE_SPECIFIC_HEAT(YY_GET,CP,TMPA)      
      LEAK_CP = CP
   ELSE
      ITMP = INT(TMPA)
      TMP_WGT = TMPA - AINT(TMPA)
      LEAK_CP = Y2CP_C(ITMP)+TMP_WGT*(Y2CP_C(ITMP+1)-Y2CP_C(ITMP))
   ENDIF
ENDIF

DO ND = 1, N_DUCTS
   DU => DUCT(ND)
   IF (DU%LEAKAGE) CYCLE
   DO NN = 1, N_DUCTNODES 
      IF(DUCTNODE(NN)%ID == DUCT_NODE_A(ND,1)) THEN
        DU%NODE_INDEX(1) = NN
        DU%X(1) =DUCTNODE(NN)%XYZ(1)
        DU%Y(1) =DUCTNODE(NN)%XYZ(2)
        DU%Z(1) =DUCTNODE(NN)%XYZ(3)
        CYCLE
      ENDIF
      IF(DUCTNODE(NN)%ID == DUCT_NODE_A(ND,2)) THEN
        DU%NODE_INDEX(2) = NN
        DU%X(2) =DUCTNODE(NN)%XYZ(1)
        DU%Y(2) =DUCTNODE(NN)%XYZ(2)
        DU%Z(2) =DUCTNODE(NN)%XYZ(3)
        CYCLE
      ENDIF
      IF (DU%NODE_INDEX(1) > 0 .AND. DU%NODE_INDEX(2) > 0) EXIT
   ENDDO
   IF (DU%NODE_INDEX(1) <= 0) THEN
      WRITE(MESSAGE,'(A,I2)') 'ERROR: Duct node 1 not located, DUCT number ',ND
      CALL SHUTDOWN(MESSAGE)
   ENDIF
   IF (DU%NODE_INDEX(2) <= 0) THEN
      WRITE(MESSAGE,'(A,I2)') 'ERROR: Duct node 2 not located, DUCT number ',ND
      CALL SHUTDOWN(MESSAGE)
   ENDIF
   IF (DU%NODE_INDEX(1) == DU%NODE_INDEX(2)) THEN
      WRITE(MESSAGE,'(A,I2)') 'ERROR: Duct node 1 cannot be the same as duct node 2, DUCT number ',ND
      CALL SHUTDOWN(MESSAGE)
   ENDIF
   IF (DUCT_FAN_A(ND)/='null') THEN
      DO NF = 1, N_FANS
         IF(FAN(NF)%ID == DUCT_FAN_A(ND)) THEN
            DU%FAN_INDEX = NF
            EXIT
         ENDIF
      ENDDO
      IF (DU%FAN_INDEX <= 0) THEN
         WRITE(MESSAGE,'(A,I2)') 'ERROR: Fan not located for DUCT number ',ND
         CALL SHUTDOWN(MESSAGE)
      ENDIF
      IF (FAN(DU%FAN_INDEX)%FAN_TYPE==1) THEN
         DU%VOLUME_FLOW_INITIAL = FAN(DU%FAN_INDEX)%MAX_FLOW
      ENDIF
   ENDIF   
ENDDO

NODE_LOOP: DO NN = 1, N_DUCTNODES
   DN => DUCTNODE(NN)
   IF (DN%LEAKAGE) THEN
      DN%TMP  = TMPA
      DN%RHO  = RHOA
      DN%P      = P_INF
      DN%RSUM = RSUM0
      IF (N_TRACKED_SPECIES > 0) THEN
         ALLOCATE(DN%YY(N_TRACKED_SPECIES))
         DN%YY(1:N_TRACKED_SPECIES) = YY_AMBIENT(1:N_TRACKED_SPECIES)
         ALLOCATE(DN%YY_V(N_TRACKED_SPECIES))            
         DN%YY_V(1:N_TRACKED_SPECIES) = YY_AMBIENT(1:N_TRACKED_SPECIES)
         CALL GET_AVERAGE_SPECIFIC_HEAT(DN%YY_V,DN%CP,TMPA)      
      ELSE
         ITMP =MIN(4999,INT(TMPA))
         TMP_WGT = TMPA - ITMP
         DN%CP = Y2CP_C(ITMP)+TMP_WGT*(Y2CP_C(ITMP+1)-Y2CP_C(ITMP))
      ENDIF 
      DN%TMP_V  = DN%TMP
      DN%RSUM_V = DN%RSUM
      DN%CP_V   = DN%CP
      DN%RHO_V  = DN%RHO
      CYCLE NODE_LOOP
   ENDIF   
   IF (DN%VENT_ID /= 'null') THEN
      MESH_LOOP: DO NM = 1, NMESHES
         DO NV = 1, MESHES(NM)%N_VENT
            IF(MESHES(NM)%VENTS(NV)%ID == DN%VENT_ID) THEN
               IF (MESHES(NM)%VENTS(NV)%IBC /= HVAC_SURF_INDEX) THEN
                  WRITE(MESSAGE,'(A,A)') 'ERROR: DUCTNODE attached to VENT without SURF_ID HVAC for VENT ID ',&
                                          MESHES(NM)%VENTS(NV)%ID
               ENDIF
               DN%MESH_INDEX = NM
               DN%VENT_INDEX = NV
               IOR = MESHES(NM)%VENTS(NV)%IOR
               I1 = MESHES(NM)%VENTS(NV)%I1
               I2 = MESHES(NM)%VENTS(NV)%I2
               J1 = MESHES(NM)%VENTS(NV)%J1
               J2 = MESHES(NM)%VENTS(NV)%J2
               K1 = MESHES(NM)%VENTS(NV)%K1
               K2 = MESHES(NM)%VENTS(NV)%K2
               SELECT CASE (ABS(IOR))
                  CASE (1)
                     J1 = J1 + 1
                     K1 = K1 + 1
                  CASE (2)
                     I1 = I1 + 1
                     K1 = K1 + 1
                  CASE (3)
                     I1 = I1 + 1
                     J1 = J1 + 1
               END SELECT               
               MESHES(NM)%VENTS(NV)%NODE_INDEX=NN
               DN%XYZ(1) = 0.5_EB*(MESHES(NM)%X(I1)+MESHES(NM)%X(I2))
               DN%XYZ(2) = 0.5_EB*(MESHES(NM)%Y(J1)+MESHES(NM)%Y(J2))
               DN%XYZ(3) = 0.5_EB*(MESHES(NM)%Z(K1)+MESHES(NM)%Z(K2))
               EXIT MESH_LOOP            
            ENDIF
         ENDDO
      ENDDO MESH_LOOP
   ENDIF
   IF (DN%VENT_INDEX > 0 .AND. DN%AMBIENT) THEN
      WRITE(MESSAGE,'(A,I2)') 'ERROR: DUCTNODE cannot be AMBIENT and have an assigned VENT_ID, HVAC line number ',N
      CALL SHUTDOWN(MESSAGE)
   ENDIF
   IF (DN%N_DUCTS == 1 .AND. DN%VENT_INDEX < 0 .AND. .NOT. DN%AMBIENT) THEN
      WRITE(MESSAGE,'(A,I2)') 'ERROR: Internal DUCTNODE must have at least two attached ducts, DUCTNODE number ',NN
      CALL SHUTDOWN(MESSAGE)
   ENDIF  
   IF (DN%N_DUCTS> 1 .AND. (DN%AMBIENT .OR. DN%VENT_INDEX > 0) ) THEN
      WRITE(MESSAGE,'(A,I2)') 'ERROR: External DUCTNODE can only have one attached duct, DUCTNODE number ',NN
      CALL SHUTDOWN(MESSAGE)
   ENDIF  
   ALLOCATE(DN%DUCT_INDEX(DN%N_DUCTS))
   ALLOCATE(DN%DIR(DN%N_DUCTS))
   DN%DUCT_INDEX = -1
   ALLOCATE(DN%BRANCH_LOSS(DN%N_DUCTS))   
   DN%BRANCH_LOSS = 0._EB
   DO ND = 1,DN%N_DUCTS
      DO ND2 = 1, N_DUCTS
         IF (NODE_DUCT_A(NN,ND) == DUCT(ND2)%ID) THEN
            DN%DUCT_INDEX(ND) = ND2
            IF (DUCT(ND2)%NODE_INDEX(1)==NN) THEN
               DN%DIR(ND) = 1._EB
            ELSE
               DN%DIR(ND) =-1._EB
            ENDIF
            CYCLE
         ENDIF
      ENDDO
      IF (DN%DUCT_INDEX(ND)==-1) THEN
         WRITE(MESSAGE,'(A,I2,A,I2)') 'ERROR: DUCT ',ND,' not found for DUCTNODE number ',NN
         CALL SHUTDOWN(MESSAGE)
      ENDIF  
   ENDDO
   
   !Initialize duct node properties
   IF (N_TRACKED_SPECIES > 0) THEN
      ALLOCATE(DN%YY(N_TRACKED_SPECIES))
      DN%YY(1:N_TRACKED_SPECIES) = YY_AMBIENT(1:N_TRACKED_SPECIES)
      ALLOCATE(DN%YY_V(N_TRACKED_SPECIES))            
      DN%YY_V(1:N_TRACKED_SPECIES) = YY_AMBIENT(1:N_TRACKED_SPECIES)
   ENDIF
   DN%RSUM   = RSUM0
   IF (STRATIFICATION) THEN
      DN%TMP  = TMPA + LAPSE_RATE*DN%XYZ(3)    
      DN%P     =  P_INF*EXP(GVEC(3)*(DN%XYZ(3)-GROUND_LEVEL)/(RSUM0*TMPA))
      DN%RHO   =  DN%P/(TMPA*RSUM0)
   ELSE
      DN%TMP  = TMPA
      DN%P      = P_INF
      DN%RHO    = RHOA
   ENDIF
   IF (N_TRACKED_SPECIES > 0) THEN
      CALL GET_AVERAGE_SPECIFIC_HEAT(DN%YY_V,DN%CP,TMPA)      
   ELSE
      ITMP =MIN(4999,INT(TMPA))
      TMP_WGT = TMPA - ITMP
      DN%CP = Y2CP_C(ITMP)+TMP_WGT*(Y2CP_C(ITMP+1)-Y2CP_C(ITMP))
   ENDIF        
   
   DN%TMP_V  = DN%TMP
   DN%RSUM_V = DN%RSUM
   DN%CP_V   = DN%CP
   DN%RHO_V  = DN%RHO
ENDDO NODE_LOOP

!Temp arrays for input processing
IF (ALLOCATED(DUCT_NODE_A)) DEALLOCATE(DUCT_NODE_A)
IF (ALLOCATED(NODE_DUCT_A)) DEALLOCATE(NODE_DUCT_A)
IF (ALLOCATED(NODE_FILTER_A)) DEALLOCATE(NODE_FILTER_A)
IF (ALLOCATED(DUCT_FAN_A)) DEALLOCATE(DUCT_FAN_A)

CALL DETERMINE_FIXED_ELEMENTS(0._EB)

ALLOCATE(NODE_P(1:N_DUCTNODES,1:NMESHES))
ALLOCATE(NODE_TMP(1:N_DUCTNODES,1:NMESHES))
ALLOCATE(NODE_RHO(1:N_DUCTNODES,1:NMESHES))
ALLOCATE(NODE_RSUM(1:N_DUCTNODES,1:NMESHES))
ALLOCATE(NODE_CP(1:N_DUCTNODES,1:NMESHES))
IF (N_TRACKED_SPECIES > 0) ALLOCATE(NODE_YY(1:N_DUCTNODES,1:N_TRACKED_SPECIES,1:NMESHES))

DO NN=1,N_DUCTNODES
   NODE_P(NN,1:NMESHES)    = DUCTNODE(NN)%P
   NODE_TMP(NN,1:NMESHES)  = DUCTNODE(NN)%TMP
   NODE_RHO(NN,1:NMESHES)  = DUCTNODE(NN)%RHO
   NODE_CP(NN,1:NMESHES)   = DUCTNODE(NN)%CP
   NODE_RSUM(NN,1:NMESHES) = DUCTNODE(NN)%RSUM   
   IF (N_TRACKED_SPECIES > 0) THEN   
      DO N=1,N_TRACKED_SPECIES
         NODE_YY(NN,N,1:NMESHES) = YY_AMBIENT(N)
      ENDDO
   ENDIF
ENDDO

ALLOCATE(DUCT_U(1:N_DUCTS,1:NMESHES))
DUCT_U(1:N_DUCTS,1:NMESHES) = 0._EB

TUSED(16,1)=TUSED(16,1)+SECOND()-TNOW

RETURN

CONTAINS 

SUBROUTINE SET_HVAC_DEFAULTS

AIRCOIL_ID   = 'null'
AMBIENT      = .FALSE.
AREA         = -1._EB
CTRL_ID      = 'null'
DAMPER       = .FALSE.
DEVC_ID      = 'null'
DIAMETER     = -1._EB
DUCT_ID      = 'null'
FAN_ID       = 'null'
LENGTH       = 1._EB
LOSS         = 0._EB
MAX_FLOW     = 1.E7_EB
MAX_PRESSURE = 1.E7_EB
NODE_ID      = 'null'
RAMP_ID      = 'null'
REVERSE      = .FALSE.
ROUGHNESS    = 0._EB
ROUND        = .TRUE.
SQUARE       = .FALSE.
TABLE_ID     = 'null'
TYPE_ID      = 'null'
TAU_FAN      = 1._EB
TAU_VF       = 1._EB
VENT_ID      = 'null'
VOLUME_FLOW  = 1.E7_EB
XYZ          = 0.

RETURN

END SUBROUTINE SET_HVAC_DEFAULTS

END SUBROUTINE READ_HVAC

SUBROUTINE HVAC_CALC(T)
!Solve for flows in the HVAC networks
INTEGER :: NNE
REAL(EB), INTENT(INOUT) :: T
LOGICAL :: CHANGE=.TRUE.
TYPE(NETWORK_TYPE), POINTER:: NE=>NULL()

CALL FIND_NETWORKS(CHANGE,T)
CALL COLLAPSE_HVAC_BC

DO NNE = 1, N_NETWORKS
   NE =>NETWORK(NNE)
   ITER = 0
   CALL SET_GUESS(NNE,T)  
ENDDO
CALL DPSTARCALC
DO NNE = 1, N_NETWORKS
   IF (NE%N_MATRIX > 0) THEN 
      ALLOCATE(LHS(NE%N_MATRIX,NE%N_MATRIX))
      ALLOCATE(RHS(NE%N_MATRIX))
      DO WHILE (ITER < ITER_MAX)
!         WRITE(*,*) '**** ITER **** ',ITER
         LHS = 0._EB
         RHS = 0._EB      
         CALL SET_GUESS(NNE,T)      
         CALL SET_DONOR(NNE)
         CALL UPDATE_LOSS(NNE)
         CALL RHSNODE(NNE)
         CALL RHSDUCT(NNE)   
         CALL LHSNODE(NNE)
         CALL LHSDUCT(NNE)
         CALL MATRIX_SOLVE(NNE)
         CALL HVAC_UPDATE(NNE)
         CALL CONVERGENCE_CHECK(NNE)
         ITER = ITER + 1
      ENDDO
      DEALLOCATE(LHS)
      DEALLOCATE(RHS)
   ELSE
      CALL SET_DONOR(NNE)
      CALL HVAC_UPDATE(NNE)
   ENDIF
ENDDO
IF (CORRECTOR) DUCT%VEL(OLD) = DUCT%VEL(NEW)

CALL UPDATE_NODE_BC

END SUBROUTINE HVAC_CALC

SUBROUTINE MATRIX_SOLVE(NNE)
USE MATH_FUNCTIONS,ONLY : GAUSSJ
INTEGER :: NNE,IERR,ND,NN
TYPE(NETWORK_TYPE), POINTER :: NE=>NULL()
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()

NE =>NETWORK(NNE)

CALL GAUSSJ(LHS,NE%N_MATRIX,NE%N_MATRIX,RHS,1,1,IERR)
DO ND = 1,NE%N_DUCTS
   DU=>DUCT(NE%DUCT_INDEX(ND))
   IF (DU%FIXED .OR. DU%AREA < ZERO_P .OR. (DU%FAN_INDEX > 0 .AND. DU%FAN_OPERATING)) CYCLE
   DU%VEL(NEW) = RHS(NE%MATRIX_INDEX(ND))
ENDDO
DO NN = 1,NE%N_DUCTNODES
   DN=>DUCTNODE(NE%NODE_INDEX(NN))
   IF (DN%FIXED) CYCLE
   DN%P = RHS(NE%MATRIX_INDEX(NE%N_DUCTS+NN))
ENDDO

END SUBROUTINE MATRIX_SOLVE

SUBROUTINE HVAC_UPDATE(NNE)
!Iterate duct network to update all ducts and nodes
USE COMP_FUNCTIONS, ONLY: SECOND
USE PHYSICAL_FUNCTIONS, ONLY : GET_AVERAGE_SPECIFIC_HEAT,GET_AVERAGE_SPECIFIC_HEAT_BG,GET_SPECIFIC_GAS_CONSTANT
REAL(EB) :: TNOW,MTOT,ETOT,VTOT,YYTOT(1:N_TRACKED_SPECIES),TGUESS,VFLOW,YY_N(1:N_TRACKED_SPECIES)
INTEGER, INTENT(IN) :: NNE
INTEGER :: NN,ND,NS
LOGICAL :: CYCLE_FLAG
TYPE (DUCTNODE_TYPE), POINTER :: DN=>NULL()
TYPE (DUCT_TYPE), POINTER :: DU=>NULL()
TYPE (NETWORK_TYPE), POINTER :: NE=>NULL()

TNOW=SECOND()
NE => NETWORK(NNE)
DUCT%UPDATED = .FALSE.
DO NN = 1,NE%N_DUCTNODES
   DN=>DUCTNODE(NE%NODE_INDEX(NN))
   DN%UPDATED = .FALSE.
   IF (DN%VENT_INDEX > 0 .OR. DN%LEAKAGE) THEN   
      DU => DUCT(DN%DUCT_INDEX(1))
      IF (DU%VEL(NEW)*DN%DIR(1) > 0._EB) DN%UPDATED = .TRUE.
   ENDIF
ENDDO
DO ND = 1,NE%N_DUCTS
   DUCT(NE%DUCT_INDEX(ND))%UPDATED = .FALSE.
ENDDO

ITER_LOOP: DO
   CYCLE_FLAG = .FALSE.
   DUCT_LOOP:DO ND = 1,NE%N_DUCTS
      DU=>DUCT(NE%DUCT_INDEX(ND))
      
      IF (DU%UPDATED) CYCLE DUCT_LOOP
      CYCLE_FLAG = .TRUE.
      IF (DU%VEL(NEW) > ZERO_P) THEN
         DN => DUCTNODE(DU%NODE_INDEX(1))
      ELSEIF (DU%VEL(NEW) < -ZERO_P) THEN
         DN => DUCTNODE(DU%NODE_INDEX(2))
      ELSE
         DU%UPDATED = .TRUE.
         DU%VEL(NEW) = 0._EB
         CYCLE DUCT_LOOP
      ENDIF
      IF (DN%UPDATED) THEN
         DU%RHO_D  = DN%RHO
         DU%TMP_D  = DN%TMP
         DU%CP_D   = DN%CP         
         DU%UPDATED = .TRUE.
         IF (N_TRACKED_SPECIES > 0) DU%YY(:) = DN%YY(:)
      ENDIF
   ENDDO DUCT_LOOP
   NODE_LOOP:DO NN = 1,NE%N_DUCTNODES
      DN=>DUCTNODE(NE%NODE_INDEX(NN))
      IF(DN%UPDATED) CYCLE NODE_LOOP
      CYCLE_FLAG = .TRUE.
      VTOT = 0._EB
      MTOT = 0._EB
      ETOT = 0._EB
      IF(N_TRACKED_SPECIES > 0) YYTOT = 0._EB
      TGUESS = 0._EB
      DO ND = 1,DN%N_DUCTS
         DU => DUCT(DN%DUCT_INDEX(ND))         
         IF (DU%AREA<=ZERO_P) CYCLE
         IF (DU%VEL(NEW)*DN%DIR(ND) > 0._EB) CYCLE
         IF (DU%VEL(NEW)*DN%DIR(ND) < 0._EB .AND. .NOT. DU%UPDATED) CYCLE NODE_LOOP
         VFLOW = ABS(DU%VEL(NEW)*DU%AREA)
         VTOT = VTOT + VFLOW
         MTOT = MTOT + VFLOW * DU%RHO_D
         ETOT = ETOT + VFLOW * DU%RHO_D * DU%TMP_D * DU%CP_D
         IF(N_TRACKED_SPECIES > 0) YYTOT = YYTOT + VFLOW * DU%RHO_D * DU%YY
         TGUESS = TGUESS + VFLOW * DU%RHO_D * DU%TMP_D
      ENDDO
      DN%UPDATED = .TRUE.
      IF (ABS(MTOT)<=ZERO_P) CYCLE NODE_LOOP
      IF(N_TRACKED_SPECIES > 0) THEN
         DN%YY(:)  = YYTOT/MTOT
         YY_N = DN%YY
         CALL GET_SPECIFIC_GAS_CONSTANT(YY_N,DN%RSUM)
      ENDIF
      TGUESS = TGUESS / MTOT      
      ETOT = ETOT/ MTOT
      DN%TMP = TGUESS
      CP_LOOP: DO
         IF (N_TRACKED_SPECIES>0) THEN
            CALL GET_AVERAGE_SPECIFIC_HEAT(YY_N,DN%CP,TGUESS)
         ELSE
            CALL GET_AVERAGE_SPECIFIC_HEAT_BG(DN%CP,TGUESS)
         ENDIF
         DN%TMP = ETOT /DN%CP
         IF (ABS(DN%TMP - TGUESS) < ZERO_P) EXIT CP_LOOP
         IF ((DN%TMP - TGUESS)/DN%TMP < 0.0005_EB) EXIT CP_LOOP
         TGUESS = DN%TMP
      ENDDO CP_LOOP
      DN%RHO = DN%P/(DN%RSUM*DN%TMP)
   ENDDO NODE_LOOP
   IF (.NOT. CYCLE_FLAG) EXIT ITER_LOOP
ENDDO ITER_LOOP

DO NN = 1,NE%N_DUCTNODES
   DN=>DUCTNODE(NE%NODE_INDEX(NN))
   NODE_P(NN,:) = DN%P
   NODE_TMP(NN,:) = DN%TMP
   NODE_RHO(NN,:) = DN%RHO
   NODE_CP(NN,:)= DN%CP
   NODE_RSUM(NN,:) = DN%RSUM
   IF (N_TRACKED_SPECIES > 0) THEN 
      DO NS=1,N_TRACKED_SPECIES
         NODE_YY(NN,NS,:) = DN%YY(NS)
      ENDDO
   ENDIF
ENDDO

!WRITE(*,*) DUCT%VEL(NEW),' V'
!WRITE(*,*) DUCTNODE%TMP,' T'
!WRITE(*,*) DUCTNODE%P,' P'
!WRITE(*,*) (DUCTNODE%RHO),' R'
!WRITE(*,*) (DUCTNODE%RSUM),' RSUM'
!IF (N_TRACKED_SPECIES > 0) WRITE(*,*) (TRIM(DUCTNODE(NN)%ID),DUCTNODE(NN)%YY(:),NN=1,N_DUCTNODES)

TUSED(16,:)=TUSED(16,:)+SECOND()-TNOW

END SUBROUTINE HVAC_UPDATE


SUBROUTINE RHSNODE(NETWORK_INDEX)
USE GLOBAL_CONSTANTS
INTEGER, INTENT(IN)::NETWORK_INDEX
INTEGER :: NN,ND, ARRAYLOC
TYPE(NETWORK_TYPE), POINTER::NE=>NULL()
TYPE(DUCT_TYPE), POINTER::DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER::DN=>NULL()

NE => NETWORK(NETWORK_INDEX)
DO NN = 1, NE%N_DUCTNODES
   DN => DUCTNODE(NE%NODE_INDEX(NN))
   IF (DN%FIXED .OR. DN%VENT_INDEX > 0 .OR. DN%AMBIENT .OR. DN%LEAKAGE) CYCLE
   ARRAYLOC = NE%MATRIX_INDEX(NE%N_DUCTS+DUCTNODE_NE(NE%NODE_INDEX(NN)))
   DO ND = 1,DN%N_DUCTS
      DU => DUCT(DN%DUCT_INDEX(ND))
      IF (DU%FIXED .OR. (DU%FAN_INDEX >0 .AND. DU%FAN_OPERATING)) &
         RHS(ARRAYLOC) = RHS(ARRAYLOC) + DN%DIR(ND)*DU%RHO_D*DU%VOLUME_FLOW
   END DO
ENDDO

END SUBROUTINE RHSNODE

SUBROUTINE LHSNODE(NETWORK_INDEX)
USE GLOBAL_CONSTANTS
INTEGER, INTENT(IN)::NETWORK_INDEX
INTEGER :: NN,ND, ARRAYLOC1,ARRAYLOC2
TYPE(NETWORK_TYPE), POINTER::NE=>NULL()
TYPE(DUCT_TYPE), POINTER::DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER::DN=>NULL()

NE => NETWORK(NETWORK_INDEX)
DO NN = 1, NE%N_DUCTNODES
   DN => DUCTNODE(NE%NODE_INDEX(NN))
   IF (DN%FIXED .OR. DN%VENT_INDEX > 0 .OR. DN%LEAKAGE) CYCLE
   ARRAYLOC1 = NE%MATRIX_INDEX(NE%N_DUCTS+DUCTNODE_NE(NE%NODE_INDEX(NN)))
   DO ND = 1,DN%N_DUCTS
      DU => DUCT(DN%DUCT_INDEX(ND))
      IF (DU%FIXED .OR. DU%AREA <=ZERO_P .OR. (DU%FAN_INDEX >0 .AND. DU%FAN_OPERATING)) CYCLE
      ARRAYLOC2 = NE%MATRIX_INDEX(DUCT_NE(DN%DUCT_INDEX(ND)))
      LHS(ARRAYLOC1,ARRAYLOC2) = -DN%DIR(ND)*DU%RHO_D*DU%AREA      
   END DO
ENDDO

END SUBROUTINE LHSNODE



SUBROUTINE DPSTARCALC

USE GLOBAL_CONSTANTS
INTEGER :: NN,IPZ
TYPE(DUCT_TYPE), POINTER::DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER::DN=>NULL()
TYPE(P_ZONE_TYPE), POINTER::PZ=>NULL()

DO IPZ = 1,N_ZONE
   PZ => P_ZONE(IPZ)
   IF (PZ%N_DUCTNODES==0) CYCLE
   P_ZONE(IPZ)%DPSTAR = P_ZONE(IPZ)%DPSTAR * DT
   DO NN = 1,PZ%N_DUCTNODES
      DN=>DUCTNODE(PZ%NODE_INDEX(NN))
      DU=>DUCT(DN%DUCT_INDEX(1))
      P_ZONE(IPZ)%DPSTAR = P_ZONE(IPZ)%DPSTAR  + DN%DIR(1) * DU%AREA * DU%VEL(OLD) * DT/PSUM(IPZ,1)
      IF (DU%FIXED .OR. (DU%FAN_INDEX >0 .AND. DU%FAN_OPERATING)) &
         P_ZONE(IPZ)%DPSTAR = P_ZONE(IPZ)%DPSTAR  - DN%DIR(1) * DU%AREA * DU%VEL(NEW) * DT/PSUM(IPZ,1)
   ENDDO
ENDDO

END SUBROUTINE DPSTARCALC



SUBROUTINE RHSDUCT(NETWORK_INDEX)

USE GLOBAL_CONSTANTS
INTEGER, INTENT(IN)::NETWORK_INDEX
INTEGER :: ND, ARRAYLOC,IPZ
REAL(EB) :: HEAD,XYZ(3)
TYPE(NETWORK_TYPE), POINTER::NE=>NULL()
TYPE(DUCT_TYPE), POINTER::DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER::DN=>NULL()
TYPE(P_ZONE_TYPE), POINTER::PZ=>NULL()

NE => NETWORK(NETWORK_INDEX)
DO ND = 1, NE%N_DUCTS
   DU => DUCT(NE%DUCT_INDEX(ND))
   IF (DU%FIXED .OR. DU%AREA < ZERO_P .OR. (DU%FAN_INDEX >0 .AND. DU%FAN_OPERATING)) CYCLE
   HEAD = 0._EB
   ARRAYLOC = NE%MATRIX_INDEX(DUCT_NE(NE%DUCT_INDEX(ND)))
   DN=>DUCTNODE(DU%NODE_INDEX(1))
   IF (DN%AMBIENT) THEN
      HEAD = HEAD + DN%P
   ELSEIF (DN%VENT_INDEX > 0 .OR. DN%LEAKAGE) THEN
      HEAD = HEAD + DN%P   
      IF (N_ZONE > 0) THEN
         IPZ = DN%ZONE_INDEX
         IF (IPZ > 0) THEN
            PZ => P_ZONE(IPZ)
            HEAD = HEAD + PZ%DPSTAR
         ENDIF
      ENDIF
   ENDIF
   XYZ = DN%XYZ
   DN=>DUCTNODE(DU%NODE_INDEX(2))
   IF (DN%AMBIENT) THEN
      HEAD = HEAD - DN%P
   ELSEIF (DN%VENT_INDEX > 0 .OR. DN%LEAKAGE) THEN
      HEAD = HEAD - DN%P   
      IF (N_ZONE > 0) THEN
         IPZ = DN%ZONE_INDEX
         IF (IPZ > 0) THEN
            PZ => P_ZONE(IPZ)
            HEAD = HEAD - PZ%DPSTAR
         ENDIF
      ENDIF
   ENDIF
   XYZ = DN%XYZ - XYZ
   IF(.NOT. DU%LEAKAGE) THEN
      IF (STRATIFICATION) THEN
         HEAD = HEAD + DN%P*(1._EB-EXP(-(GVEC(1)*XYZ(1)+GVEC(2)*XYZ(2)+GVEC(3)*XYZ(3))/(DU%RSUM_D*DU%TMP_D)))
      ELSE
         HEAD = HEAD + (GVEC(1)*XYZ(1)+GVEC(2)*XYZ(2)+GVEC(3)*XYZ(3))*DU%RHO_D
      ENDIF
   ENDIF
   RHS(ARRAYLOC) = DU%VEL(OLD)+DT/DU%LENGTH*((HEAD+DU%DP_FAN)/DU%RHO_D+0.5_EB*DU%TOTAL_LOSS*ABS(DU%VEL(NEW))*DU%VEL(GUESS))
   
ENDDO

END SUBROUTINE RHSDUCT


SUBROUTINE LHSDUCT(NETWORK_INDEX)
USE GLOBAL_CONSTANTS
INTEGER, INTENT(IN)::NETWORK_INDEX
INTEGER :: NN,ND, ARRAYLOC1,ARRAYLOC2
TYPE(NETWORK_TYPE), POINTER::NE=>NULL()
TYPE(DUCT_TYPE), POINTER::DU=>NULL(),DU2=>NULL()
TYPE(DUCTNODE_TYPE), POINTER::DN=>NULL(),DN2=>NULL()
TYPE(P_ZONE_TYPE), POINTER::PZ=>NULL()
NE => NETWORK(NETWORK_INDEX)
DUCT_LOOP: DO ND = 1, NE%N_DUCTS
   DU => DUCT(NE%DUCT_INDEX(ND))
   IF (DU%FIXED .OR. DU%AREA < ZERO_P .OR. (DU%FAN_INDEX >0 .AND. DU%FAN_OPERATING)) CYCLE DUCT_LOOP
   ARRAYLOC1 = NE%MATRIX_INDEX(DUCT_NE(NE%DUCT_INDEX(ND)))
   LHS(ARRAYLOC1,ARRAYLOC1) = 1._EB+0.5_EB*DU%TOTAL_LOSS*ABS(DU%VEL(NEW)+DU%VEL(GUESS))*DT/DU%LENGTH
   DN=>DUCTNODE(DU%NODE_INDEX(1))
   IF (DN%VENT_INDEX < 0) THEN
      IF (.NOT. DN%AMBIENT .AND. .NOT. DN%LEAKAGE) THEN
         ARRAYLOC2 = NE%MATRIX_INDEX(NE%N_DUCTS+DUCTNODE_NE(DU%NODE_INDEX(1)))
         LHS(ARRAYLOC1,ARRAYLOC2) = -DT/(DU%RHO_D*DU%LENGTH)
      ENDIF
      IF (DN%LEAKAGE .AND. .NOT. DN%AMBIENT) THEN
         PZ => P_ZONE(DN%ZONE_INDEX)
         DO NN=1,PZ%N_DUCTNODES
            DN2=>DUCTNODE(PZ%NODE_INDEX(NN))
            DU2=>DUCT(DN2%DUCT_INDEX(1))
            IF (DU2%AREA < ZERO_P .OR. DU2%FIXED .OR. (DU2%FAN_INDEX >0 .AND. DU2%FAN_OPERATING)) CYCLE
            ARRAYLOC2 = NE%MATRIX_INDEX(DUCT_NE(DN2%DUCT_INDEX(1)))
            LHS(ARRAYLOC1,ARRAYLOC2) = LHS(ARRAYLOC1,ARRAYLOC2) + DN2%DIR(1)*DU2%AREA*DT**2 / &
                                       (PSUM(DN%ZONE_INDEX,DN%MESH_INDEX)*DU%RHO_D*DU%LENGTH)
         ENDDO
      ENDIF
   ELSE
      IF (DN%ZONE_INDEX >0) THEN
         PZ => P_ZONE(DN%ZONE_INDEX)
         DO NN=1,PZ%N_DUCTNODES
            DN2=>DUCTNODE(PZ%NODE_INDEX(NN))
            DU2=>DUCT(DN2%DUCT_INDEX(1))
            IF (DU2%AREA < ZERO_P .OR. DU2%FIXED .OR. (DU2%FAN_INDEX >0 .AND. DU2%FAN_OPERATING)) CYCLE
            ARRAYLOC2 = NE%MATRIX_INDEX(DUCT_NE(DN2%DUCT_INDEX(1)))
            LHS(ARRAYLOC1,ARRAYLOC2) = LHS(ARRAYLOC1,ARRAYLOC2) + DN2%DIR(1)*DU2%AREA*DT**2 / &
                                       (PSUM(DN%ZONE_INDEX,DN%MESH_INDEX)*DU%RHO_D*DU%LENGTH)
         ENDDO
      ENDIF
   ENDIF
   DN=>DUCTNODE(DU%NODE_INDEX(2))
   IF (DN%VENT_INDEX < 0) THEN
      IF (.NOT. DN%AMBIENT .AND. .NOT. DN%LEAKAGE) THEN
         ARRAYLOC2 = NE%MATRIX_INDEX(NE%N_DUCTS+DUCTNODE_NE(DU%NODE_INDEX(2)))         
         LHS(ARRAYLOC1,ARRAYLOC2) = DT/(DU%RHO_D*DU%LENGTH)
      ENDIF
      IF (DN%LEAKAGE .AND. .NOT. DN%AMBIENT) THEN
         PZ => P_ZONE(DN%ZONE_INDEX)
         DO NN=1,PZ%N_DUCTNODES
            DN2=>DUCTNODE(PZ%NODE_INDEX(NN))
            DU2=>DUCT(DN2%DUCT_INDEX(1))
            IF (DU2%AREA < ZERO_P .OR. DU2%FIXED .OR. (DU2%FAN_INDEX >0 .AND. DU2%FAN_OPERATING)) CYCLE  
            ARRAYLOC2 = NE%MATRIX_INDEX(DUCT_NE(DN2%DUCT_INDEX(1)))
            LHS(ARRAYLOC1,ARRAYLOC2) = LHS(ARRAYLOC1,ARRAYLOC2) - DN2%DIR(1)*DU2%AREA*DT**2 / &
                                       (PSUM(DN%ZONE_INDEX,DN%MESH_INDEX)*DU%RHO_D*DU%LENGTH)
         ENDDO
      ENDIF
   ELSE
      IF (DN%ZONE_INDEX >0) THEN
         PZ => P_ZONE(DN%ZONE_INDEX)
         DO NN=1,PZ%N_DUCTNODES
            DN2=>DUCTNODE(PZ%NODE_INDEX(NN))
            DU2=>DUCT(DN2%DUCT_INDEX(1))
            IF (DU2%AREA < ZERO_P .OR. DU2%FIXED .OR. (DU2%FAN_INDEX >0 .AND. DU2%FAN_OPERATING)) CYCLE  
            ARRAYLOC2 = NE%MATRIX_INDEX(DUCT_NE(DN2%DUCT_INDEX(1)))
            LHS(ARRAYLOC1,ARRAYLOC2) = LHS(ARRAYLOC1,ARRAYLOC2) - DN2%DIR(1)*DU2%AREA*DT**2 / &
                                       (PSUM(DN%ZONE_INDEX,DN%MESH_INDEX)*DU%RHO_D*DU%LENGTH)
         ENDDO
      ENDIF
   ENDIF
ENDDO DUCT_LOOP

END SUBROUTINE LHSDUCT

SUBROUTINE UPDATE_FAN(T,DUCT_INDEX)
USE MATH_FUNCTIONS, ONLY : EVALUATE_RAMP
INTEGER, INTENT(IN) :: DUCT_INDEX
REAL(EB), INTENT(IN) :: T
TYPE(DUCT_TYPE), POINTER::DU=>NULL()
TYPE(FAN_TYPE), POINTER::FA=>NULL()
REAL(EB) :: DEL_P

DU=> DUCT(DUCT_INDEX)
FA=> FAN(DU%FAN_INDEX)

SELECT CASE (FA%FAN_TYPE)
   CASE(1) !Constant flow
      DU%VEL(NEW) = FA%VOL_FLOW/DU%AREA
   CASE(2) !Quadratic
      DEL_P = DUCTNODE(DU%NODE_INDEX(2))%P - DUCTNODE(DU%NODE_INDEX(1))%P
      IF (DU%REVERSE) DEL_P = -DEL_P
      DEL_P = FA%MAX_PRES - DEL_P
      DU%VEL(NEW) = FA%MAX_FLOW*SIGN(1._EB,DEL_P)*SQRT(ABS(DEL_P)/FA%MAX_PRES)/DU%AREA
   CASE(3) !Fan curve
      DEL_P = DUCTNODE(DU%NODE_INDEX(2))%P - DUCTNODE(DU%NODE_INDEX(1))%P
      IF (DU%REVERSE) DEL_P = -DEL_P
      DU%VEL(NEW) = EVALUATE_RAMP(DEL_P,0._EB,FA%RAMP_INDEX)/DU%AREA      
END SELECT
IF (DU%REVERSE) DU%VEL(NEW) = -DU%VEL(NEW)
DU%VEL(NEW) = DU%VEL(NEW)*EVALUATE_RAMP(T,FA%TAU,FA%SPIN_INDEX)
DU%VEL(NEW) = 0.3*DU%VEL(NEW)+0.7*DU%VEL(GUESS)
DU%VOLUME_FLOW = DU%VEL(NEW)*DU%AREA

END SUBROUTINE UPDATE_FAN


SUBROUTINE HVAC_BC_IN(NM)
!Average gas properties at VENTs connected to HVAC system
USE PHYSICAL_FUNCTIONS, ONLY : GET_SPECIFIC_GAS_CONSTANT,GET_AVERAGE_SPECIFIC_HEAT,GET_AVERAGE_SPECIFIC_HEAT_BG
INTEGER, INTENT(IN) :: NM
INTEGER :: NN,II,JJ,KK,I1,I2,J1,J2,K1,K2,IC,IW,IOR,NODE_ZONE,IZ1,IZ2,IBC
REAL(EB) :: YY_SUM(N_TRACKED_SPECIES),YY_N(1:N_TRACKED_SPECIES),RHO_SUM,P_SUM,AREA_SUM,AREA,TMP_SUM,H_SUM,H_G,TMP_NEW,CPBAR,TNOW,&
           P_AVE !,VEL2
REAL(EB), POINTER, DIMENSION(:,:,:) :: RHOP,UP,VP,WP,HP
REAL(EB), POINTER, DIMENSION(:,:) :: PBARP
TYPE (MESH_TYPE),POINTER :: M=>NULL()
TYPE (VENTS_TYPE),POINTER :: VT=>NULL()
TYPE (DUCTNODE_TYPE), POINTER :: DN=>NULL()
TYPE (SURFACE_TYPE), POINTER :: SF=>NULL()

IF (EVACUATION_ONLY(NM)) RETURN

TNOW=SECOND()

M => MESHES(NM)
CALL POINT_TO_MESH(NM)

IF (PREDICTOR) THEN
   PBARP => PBAR
   RHOP  => RHO
   HP    => H
   UP    => U
   VP    => V
   WP    => W      
ELSE
   PBARP => PBAR_S
   RHOP  => RHOS
   HP    => HS
   UP    => US
   VP    => VS
   WP    => WS      
ENDIF

NODE_LOOP: DO NN = 1, N_DUCTNODES
   IF (N_TRACKED_SPECIES>0) YY_SUM=0._EB
   RHO_SUM=0._EB
   P_SUM=0._EB
   AREA_SUM=0._EB
   TMP_SUM=0._EB
   H_SUM=0._EB
   NODE_ZONE=-1
   DN=>DUCTNODE(NN)
   IF (DN%MESH_INDEX /= NM) CYCLE NODE_LOOP
   IF (DN%VENT_INDEX < 0) CYCLE NODE_LOOP

   VT=>VENTS(DN%VENT_INDEX)
   IOR = VT%IOR
   I1 = VT%I1
   I2 = VT%I2
   J1 = VT%J1
   J2 = VT%J2
   K1 = VT%K1
   K2 = VT%K2
   SELECT CASE (ABS(IOR))
      CASE (1)
         J1 = J1 + 1
         K1 = K1 + 1
         IF (IOR > 0) THEN
            I1 = I1 + 1
            I2 = I1
         ENDIF
      CASE (2)
         I1 = I1 + 1
         K1 = K1 + 1
         IF (IOR > 0) THEN
            J1 = J1 + 1
            J2 = J1
         ENDIF
      CASE (3)
         I1 = I1 + 1
         J1 = J1 + 1
         IF (IOR > 0) THEN
            K1 = K1 + 1
            K2 = K1
         ENDIF
   END SELECT
   VENT_LOOP: DO KK = K1,K2
      DO JJ = J1,J2
         DO II = I1, I2
            IC = CELL_INDEX(II,JJ,KK)
            IF (SOLID(IC)) CYCLE
            IW = WALL_INDEX(IC,-IOR)
            AREA = AW(IW)
            IF (PRESSURE_ZONE_WALL(IW) /= NODE_ZONE) THEN
               IF (NODE_ZONE == -1) THEN
                  NODE_ZONE = PRESSURE_ZONE_WALL(IW)
               ELSE
                  WRITE(MESSAGE,'(A,I2)') 'ERROR: VENT for a NODE must lie with a single pressure zone. Node: ',NN
                  CALL SHUTDOWN(MESSAGE)
               ENDIF
            ENDIF
            RHO_SUM = RHO_SUM + RHOP(II,JJ,KK)*AW(IW)
            IF (N_TRACKED_SPECIES > 0) THEN
               YY_SUM = YY_SUM+YY(II,JJ,KK,:)*RHO(II,JJ,KK)*AREA
               YY_N = YY(II,JJ,KK,:)
               CALL GET_AVERAGE_SPECIFIC_HEAT(YY_N,CPBAR,TMP(II,JJ,KK))
               H_G = CPBAR * TMP(II,JJ,KK)
            ELSE
               CALL GET_AVERAGE_SPECIFIC_HEAT_BG(CPBAR,TMP(II,JJ,KK))
               H_G = CPBAR * TMP(II,JJ,KK)
            ENDIF
            H_SUM = H_SUM+H_G*AREA*RHOP(II,JJ,KK)
            TMP_SUM = TMP_SUM + TMP(II,JJ,KK)*AREA
!            VEL2  = 0.25_EB*( (UP(II,JJ,KK)+UP(II-1,JJ,KK))**2+(VP(II,JJ,KK)+VP(II,JJ-1,KK))**2+(WP(II,JJ,KK)+WP(II,JJ,KK-1))**2)
            SELECT CASE (IOR)
               CASE (3)
                  P_AVE = 0.5_EB*(PBARP(KK-1,PRESSURE_ZONE(II,JJ,KK-1))+PBARP(KK,PRESSURE_ZONE(II,JJ,KK)))
               CASE (-3)
                  P_AVE = 0.5_EB*(PBARP(KK,PRESSURE_ZONE(II,JJ,KK))+PBARP(KK+1,PRESSURE_ZONE(II,JJ,KK+1)))
               CASE DEFAULT
                  P_AVE = PBARP(KK,PRESSURE_ZONE(II,JJ,KK))
            END SELECT
            P_SUM = P_SUM + (P_AVE+RHO(II,JJ,KK)*(HP(II,JJ,KK)-KRES(II,JJ,KK)))*AREA
            AREA_SUM = AREA_SUM + AREA
         ENDDO
      ENDDO
   ENDDO VENT_LOOP
   IF (NODE_ZONE /= -1) DN%ZONE_INDEX = NODE_ZONE
   NODE_P(NN,NM)      = P_SUM / AREA_SUM
   TMP_SUM   = TMP_SUM / AREA_SUM
   IF (N_TRACKED_SPECIES>0) NODE_YY(NN,1:N_TRACKED_SPECIES,NM) = YY_SUM(1:N_TRACKED_SPECIES) / RHO_SUM
   H_SUM = H_SUM / RHO_SUM
   DO
      IF (N_TRACKED_SPECIES > 0) THEN
         YY_N = DN%YY_V(:)
         CALL GET_AVERAGE_SPECIFIC_HEAT(YY_N,CPBAR,TMP_SUM)      
      ELSE
         CALL GET_AVERAGE_SPECIFIC_HEAT_BG(CPBAR,TMP(II,JJ,KK))
      ENDIF
      TMP_NEW = H_SUM / CPBAR
      IF (ABS(TMP_SUM - TMP_NEW) < ZERO_P .OR. ABS(TMP_SUM - TMP_NEW)/TMP_NEW < 0.0005_EB) EXIT
      TMP_SUM = TMP_NEW
   ENDDO
   NODE_CP(NN,NM)  = CPBAR
   NODE_TMP(NN,NM) = TMP_SUM
   NODE_RHO(NN,NM) = RHO_SUM / AREA_SUM   
   IF (N_TRACKED_SPECIES>0) THEN
      YY_N = NODE_YY(NN,1:N_TRACKED_SPECIES,NM)
      CALL GET_SPECIFIC_GAS_CONSTANT(YY_N,NODE_RSUM(NN,NM))
   ENDIF
ENDDO NODE_LOOP

LEAKAGE_BC: IF (LEAK_DUCTS > 0) THEN
   LEAK_TMP(:,:,NM) = 0._EB
   LEAK_RHO(:,:,NM) = 0._EB
   LEAK_RSUM(:,:,NM) = 0._EB
   LEAK_CP(:,:,NM) = 0._EB
   FDS_LEAK_AREA(:,:,NM) = 0._EB
   IF (N_TRACKED_SPECIES > 0) LEAK_YY(:,:,:,NM) = 0._EB
   WALL_LOOP: DO IW=1,N_EXTERNAL_WALL_CELLS+N_INTERNAL_WALL_CELLS
      IF (BOUNDARY_TYPE(IW)/=SOLID_BOUNDARY .AND. BOUNDARY_TYPE(IW)/=POROUS_BOUNDARY) CYCLE WALL_LOOP
      IBC = IJKW(5,IW)
      SF => SURFACE(IBC)
      IF (SF%LEAK_PATH(1) /= PRESSURE_ZONE_WALL(IW) .AND. SF%LEAK_PATH(2) /= PRESSURE_ZONE_WALL(IW)) CYCLE WALL_LOOP
      IF (SF%LEAK_PATH(1) == PRESSURE_ZONE_WALL(IW)) THEN
         IZ1 = SF%LEAK_PATH(1)
         IZ2 = SF%LEAK_PATH(2)
      ELSE
         IZ1 = SF%LEAK_PATH(2)
         IZ2 = SF%LEAK_PATH(1)
      ENDIF
      II = IJKW(6,IW)
      JJ = IJKW(7,IW)
      KK = IJKW(8,IW)
      AREA = AW(IW)
      FDS_LEAK_AREA(IZ1,IZ2,NM) = FDS_LEAK_AREA(IZ1,IZ2,NM) + AREA
      LEAK_RHO(IZ1,IZ2,NM) = LEAK_RHO(IZ1,IZ2,NM) + RHOP(II,JJ,KK)*AREA
      IF (N_TRACKED_SPECIES > 0) THEN
         YY_N = YY(II,JJ,KK,:)
         LEAK_YY(IZ1,IZ2,1:N_TRACKED_SPECIES,NM) = LEAK_YY(IZ1,IZ2,1:N_TRACKED_SPECIES,NM)+YY_N*RHO(II,JJ,KK)*AREA
         CALL GET_AVERAGE_SPECIFIC_HEAT(YY_N,CPBAR,TMP(II,JJ,KK))
         H_G = CPBAR * TMP(II,JJ,KK)
      ELSE
         CALL GET_AVERAGE_SPECIFIC_HEAT_BG(CPBAR,TMP(II,JJ,KK))
         H_G = CPBAR * TMP(II,JJ,KK)
      ENDIF
      LEAK_CP(IZ1,IZ2,NM) = LEAK_CP(IZ1,IZ2,NM)+H_G*AREA*RHOP(II,JJ,KK)
      LEAK_TMP(IZ1,IZ2,NM) = LEAK_TMP(IZ1,IZ2,NM)+ TMP(II,JJ,KK)*AREA
   END DO WALL_LOOP
   DO IZ1 = 0,N_ZONE
      DO IZ2 = 0,N_ZONE
         IF (LEAK_PATH(IZ1,IZ2) == 0 .AND. LEAK_PATH(IZ2,IZ1)==0 .OR. FDS_LEAK_AREA(IZ1,IZ2,NM)<=ZERO_P) CYCLE
         LEAK_TMP(IZ1,IZ2,NM) = LEAK_TMP(IZ1,IZ2,NM)/ FDS_LEAK_AREA(IZ1,IZ2,NM)
         IF (N_TRACKED_SPECIES>0) THEN
            LEAK_YY(IZ1,IZ2,1:N_TRACKED_SPECIES,NM) = LEAK_YY(IZ1,IZ2,1:N_TRACKED_SPECIES,NM) / LEAK_RHO(IZ1,IZ2,NM)
            YY_N = LEAK_YY(IZ1,IZ2,1:N_TRACKED_SPECIES,NM)
            CALL GET_SPECIFIC_GAS_CONSTANT(YY_N,LEAK_RSUM(IZ1,IZ2,NM))
         ENDIF
         LEAK_CP(IZ1,IZ2,NM)  = LEAK_CP(IZ1,IZ2,NM)  / LEAK_RHO(IZ1,IZ2,NM)
         LEAK_RHO(IZ1,IZ2,NM) = LEAK_RHO(IZ1,IZ2,NM) / FDS_LEAK_AREA(IZ1,IZ2,NM)
         TMP_SUM = LEAK_TMP(IZ1,IZ2,NM)
         DO
            IF (N_TRACKED_SPECIES > 0) THEN
               CALL GET_AVERAGE_SPECIFIC_HEAT(YY_N,CPBAR,TMP_SUM)      
            ELSE
               CALL GET_AVERAGE_SPECIFIC_HEAT_BG(CPBAR,TMP_SUM)      
            ENDIF
            TMP_NEW = LEAK_CP(IZ1,IZ2,NM) / CPBAR
            IF (ABS(TMP_SUM - TMP_NEW) < ZERO_P .OR. ABS(TMP_SUM - TMP_NEW)/TMP_NEW < 0.0005_EB) EXIT
            TMP_SUM = TMP_NEW
         ENDDO    
         LEAK_TMP(IZ1,IZ2,NM) = TMP_NEW
         LEAK_CP(IZ1,IZ2,NM) = CPBAR
      ENDDO
   ENDDO     
ENDIF LEAKAGE_BC

TUSED(16,:)=TUSED(16,:)+SECOND()-TNOW

END SUBROUTINE HVAC_BC_IN

SUBROUTINE DETERMINE_FIXED_ELEMENTS(T)
USE MATH_FUNCTIONS,ONLY:EVALUATE_RAMP
INTEGER:: NN,ND, COUNTER,DUCT_INDEX
REAL(EB) :: VOLUME_FLOW,ABS_VOLUME_FLOW
REAL(EB), INTENT(IN):: T
LOGICAL :: CHANGE
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()

DUCTNODE%FIXED = .FALSE.
DUCT%FIXED = .FALSE.
DUCT%VOLUME_FLOW = 0._EB
CHANGE = .TRUE.
FIXED_LOOP: DO WHILE (CHANGE)
   CHANGE = .FALSE.
   NODE_LOOP: DO NN = 1, N_DUCTNODES
      DN=>DUCTNODE(NN)
      IF( DN%FIXED) CYCLE NODE_LOOP
      IF (DN%VENT_INDEX > 0 .OR. DN%AMBIENT .OR. DN%LEAKAGE) THEN
         DN%FIXED = .TRUE.
         CHANGE = .TRUE.
         DU=>DUCT(DN%DUCT_INDEX(1))
         IF (DU%FIXED) CYCLE
         IF (DU%VOLUME_FLOW_INITIAL<1.E6_EB) THEN
            DU%VOLUME_FLOW = DU%VOLUME_FLOW_INITIAL*EVALUATE_RAMP(T,DU%TAU,DU%RAMP_INDEX)
            IF(DU%AREA > ZERO_P) DU%VEL(NEW) = DU%VOLUME_FLOW/DU%AREA
            DU%FIXED = .TRUE.
         ELSEIF (DU%FAN_INDEX > 0) THEN
            IF (DU%DEVC_INDEX > 0) THEN
               DU%FAN_OPERATING = DEVICE(DU%DEVC_INDEX)%CURRENT_STATE
            ELSEIF (DU%CTRL_INDEX > 0) THEN
               DU%FAN_OPERATING = CONTROL(DU%CTRL_INDEX)%CURRENT_STATE
            ENDIF
         ENDIF
         CYCLE NODE_LOOP
      ENDIF
      COUNTER = 0
      DO ND=1,DN%N_DUCTS
         DU=>DUCT(DN%DUCT_INDEX(ND))
         IF (DU%VOLUME_FLOW_INITIAL<1.E6_EB) THEN
            DU%VOLUME_FLOW = DU%VOLUME_FLOW_INITIAL*EVALUATE_RAMP(T,DU%TAU,DU%RAMP_INDEX)
            IF(DU%AREA > ZERO_P) DU%VEL(NEW) = DU%VOLUME_FLOW/DU%AREA
            DU%FIXED = .TRUE.
         ELSEIF (DU%FAN_INDEX > 0) THEN
            IF (DU%DEVC_INDEX > 0) THEN
               DU%FAN_OPERATING = DEVICE(DU%DEVC_INDEX)%CURRENT_STATE
            ELSEIF (DU%CTRL_INDEX > 0) THEN
               DU%FAN_OPERATING = CONTROL(DU%CTRL_INDEX)%CURRENT_STATE
            ENDIF
         ENDIF
         IF (DU%FIXED .OR. DU%AREA < ZERO_P) THEN
            COUNTER = COUNTER + 1
         ENDIF
      ENDDO
      
      IF (COUNTER >= DN%N_DUCTS - 1) THEN
         IF (DN%N_DUCTS == 1)  THEN
            DN%FIXED = .TRUE.
            CHANGE = .TRUE.         
         ELSE  
            VOLUME_FLOW = 0._EB
            ABS_VOLUME_FLOW = 0._EB      
            DO ND=1,DN%N_DUCTS
               DU=>DUCT(DN%DUCT_INDEX(ND))         
               IF (DU%FIXED) THEN
                  IF (DU%AREA > ZERO_P) THEN
                     VOLUME_FLOW = VOLUME_FLOW + DN%DIR(ND) * DU%VOLUME_FLOW
                     ABS_VOLUME_FLOW = ABS_VOLUME_FLOW + ABS(DU%VOLUME_FLOW)
                  ENDIF
               ELSE
                  DUCT_INDEX = ND
               ENDIF            
            ENDDO
            IF (COUNTER==DN%N_DUCTS) THEN
               IF (ABS(VOLUME_FLOW)/ABS_VOLUME_FLOW > 1.E-6_EB) THEN
                  WRITE(MESSAGE,'(A,A)') 'ERROR: Volume flow does not sum to zero for DUCTNODE = ',TRIM(DN%ID)
                  CALL SHUTDOWN(MESSAGE)
               ENDIF
            ELSE
               DU=>DUCT(DN%DUCT_INDEX(DUCT_INDEX))
               DU%VOLUME_FLOW = -DN%DIR(DUCT_INDEX) * VOLUME_FLOW
               DU%VEL(NEW) = DU%VOLUME_FLOW/DU%AREA
               DU%FIXED = .TRUE.
            ENDIF
            DN%FIXED = .TRUE.
            CHANGE = .TRUE.
         ENDIF
      ENDIF
   END DO NODE_LOOP
END DO FIXED_LOOP

END SUBROUTINE DETERMINE_FIXED_ELEMENTS


SUBROUTINE FIND_NETWORKS(CHANGEIN,T)
INTEGER:: NZ,NN,ND,DUCT_COUNTER(N_DUCTS),NODE_COUNTER(N_DUCTNODES),COUNTER,COUNTER2,NETWORK_COUNTER(N_DUCTS),&
          ZONE_COUNTER(N_ZONE)
INTEGER, DIMENSION(:), ALLOCATABLE :: NETWORK_DCOUNTER,NETWORK_NCOUNTER
LOGICAL, INTENT(INOUT) :: CHANGEIN
LOGICAL :: CHANGE
REAL(EB), INTENT(INOUT):: T
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()

CHANGE = CHANGEIN

IF (N_ZONE > 0) ZONE_COUNTER = 0

DO ND = 1, N_DUCTS
   DU => DUCT(ND)
   IF(.NOT. DU%DAMPER) CYCLE
   IF (DU%DEVC_INDEX > 0) THEN
      IF (DEVICE(DU%DEVC_INDEX)%CURRENT_STATE .NEQV. DU%DAMPER_OPEN) THEN
            DU%DAMPER_OPEN = DEVICE(DU%DEVC_INDEX)%CURRENT_STATE
            CHANGE = .TRUE.
            IF (DU%DAMPER_OPEN) THEN
               DU%AREA = DU%AREA_INITIAL
            ELSE
               DU%AREA = 0._EB
               DU%VEL  = 0._EB
            ENDIF
      ENDIF
   ELSE
      IF (CONTROL(DU%CTRL_INDEX)%CURRENT_STATE .NEQV. DU%DAMPER_OPEN) THEN
            DU%DAMPER_OPEN = CONTROL(DU%CTRL_INDEX)%CURRENT_STATE
            CHANGE = .TRUE.
            IF (DU%DAMPER_OPEN) THEN
               DU%AREA = DU%AREA_INITIAL
            ELSE
               DU%AREA = 0._EB
               DU%VEL  = 0._EB
            ENDIF
      ENDIF
   ENDIF
ENDDO
IF (CHANGE) THEN
   IF (ALLOCATED(NETWORK)) DEALLOCATE(NETWORK)
   DO NN = 1, N_DUCTNODES
      NZ = DUCTNODE(NN)%ZONE_INDEX
      IF (NZ>=1) THEN
         NODE_COUNTER(NN) = NZ
         ZONE_COUNTER(NZ) = ZONE_COUNTER(NZ) + 1
      ELSE
         NODE_COUNTER(NN) = NN+N_ZONE
      ENDIF
   ENDDO 
   IF (N_ZONE > 0) THEN
      DO NZ = 1, N_ZONE
       IF (ASSOCIATED(P_ZONE(NZ)%NODE_INDEX)) DEALLOCATE(P_ZONE(NZ)%NODE_INDEX)
         ALLOCATE(P_ZONE(NZ)%NODE_INDEX(ZONE_COUNTER(NZ)))      
         P_ZONE(NZ)%N_DUCTNODES = ZONE_COUNTER(NZ)         
         COUNTER = 1
         DO NN = 1,N_DUCTNODES
            IF (DUCTNODE(NN)%ZONE_INDEX == NZ) THEN
               P_ZONE(NZ)%NODE_INDEX(COUNTER)=NN
               COUNTER = COUNTER + 1               
            ENDIF
         ENDDO   
      ENDDO      
   ENDIF  
   CHANGE = .TRUE.
   DO WHILE (CHANGE)
      CHANGE = .FALSE.
      DO ND = 1, N_DUCTS
         DU => DUCT(ND)
         IF (NODE_COUNTER(DU%NODE_INDEX(1)) /= NODE_COUNTER(DU%NODE_INDEX(2))) THEN
            CHANGE = .TRUE.
            COUNTER = MIN(NODE_COUNTER(DU%NODE_INDEX(1)),NODE_COUNTER(DU%NODE_INDEX(2)))
            DUCT_COUNTER(ND) = COUNTER
            NODE_COUNTER(DU%NODE_INDEX(1)) = COUNTER
            NODE_COUNTER(DU%NODE_INDEX(2)) = COUNTER
         ELSE
            DUCT_COUNTER(ND) = NODE_COUNTER(DU%NODE_INDEX(1))
         ENDIF
      ENDDO 
      IF (N_ZONE > 0) THEN   
         DO NZ = 1, N_ZONE
            COUNTER = 1
            COUNTER2 = 1
            DO NN = 1, P_ZONE(NZ)%N_DUCTNODES
               IF (NN==1) THEN
                  COUNTER = NODE_COUNTER(P_ZONE(NZ)%NODE_INDEX(NN))
                  COUNTER2 = COUNTER
               ELSE
                  IF (COUNTER /= NODE_COUNTER(P_ZONE(NZ)%NODE_INDEX(NN))) &
                     COUNTER2 = MAX(COUNTER2,NODE_COUNTER(P_ZONE(NZ)%NODE_INDEX(NN)))                     
                     COUNTER  = MIN(COUNTER,NODE_COUNTER(P_ZONE(NZ)%NODE_INDEX(NN)))                     
               ENDIF               
            ENDDO
            IF (COUNTER /= COUNTER2) THEN
               CHANGE = .TRUE.
               DO NN = 1, P_ZONE(NZ)%N_DUCTNODES   
                  NODE_COUNTER(P_ZONE(NZ)%NODE_INDEX(NN)) = COUNTER
               ENDDO
            ENDIF
         ENDDO
      ENDIF
   END DO
   IF (MINVAL(NODE_COUNTER) > 1) NODE_COUNTER = NODE_COUNTER - MINVAL(NODE_COUNTER) + 1
   IF (MINVAL(DUCT_COUNTER) > 1) DUCT_COUNTER = DUCT_COUNTER - MINVAL(DUCT_COUNTER) + 1
   NETWORK_COUNTER = 0
   DO ND = 1, N_DUCTS
      NETWORK_COUNTER(DUCT_COUNTER(ND))=1
   ENDDO

   N_NETWORKS = SUM(NETWORK_COUNTER)
   ALLOCATE(NETWORK(N_NETWORKS))
   NETWORK%N_DUCTS=0
   NETWORK%N_DUCTNODES=0
   ALLOCATE(NETWORK_DCOUNTER(N_NETWORKS))
   NETWORK_DCOUNTER=0
   ALLOCATE(NETWORK_NCOUNTER(N_NETWORKS))
   NETWORK_NCOUNTER=0
   COUNTER = 0
   DO ND = 1, N_DUCTS
      IF(NETWORK_COUNTER(ND)==1) THEN
         COUNTER = COUNTER + 1
         NETWORK_COUNTER(ND) = COUNTER
      ENDIF
   ENDDO   
   DO ND = 1, N_DUCTS
      NETWORK(NETWORK_COUNTER(DUCT_COUNTER(ND)))%N_DUCTS = NETWORK(NETWORK_COUNTER(DUCT_COUNTER(ND)))%N_DUCTS + 1
   ENDDO
   DO NN = 1, N_DUCTNODES
      NETWORK(NETWORK_COUNTER(NODE_COUNTER(NN)))%N_DUCTNODES = NETWORK(NETWORK_COUNTER(NODE_COUNTER(NN)))%N_DUCTNODES + 1
   ENDDO
   DO NN = 1, N_NETWORKS
      ALLOCATE(NETWORK(NN)%DUCT_INDEX(NETWORK(NN)%N_DUCTS))
      ALLOCATE(NETWORK(NN)%NODE_INDEX(NETWORK(NN)%N_DUCTNODES))
      ALLOCATE(NETWORK(NN)%MATRIX_INDEX(NETWORK(NN)%N_DUCTS+NETWORK(NN)%N_DUCTNODES))
      NETWORK(NN)%MATRIX_INDEX = 0
   ENDDO
   DO ND = 1, N_DUCTS
      NETWORK_DCOUNTER(NETWORK_COUNTER(DUCT_COUNTER(ND))) = NETWORK_DCOUNTER(NETWORK_COUNTER(DUCT_COUNTER(ND))) + 1
      NETWORK(NETWORK_COUNTER(DUCT_COUNTER(ND)))%DUCT_INDEX(NETWORK_DCOUNTER(NETWORK_COUNTER(DUCT_COUNTER(ND)))) = ND
      DUCT_NE(ND) = NETWORK_DCOUNTER(NETWORK_COUNTER(DUCT_COUNTER(ND)))
   ENDDO
   DO NN = 1, N_DUCTNODES
      NETWORK_NCOUNTER(NETWORK_COUNTER(NODE_COUNTER(NN))) = NETWORK_NCOUNTER(NETWORK_COUNTER(NODE_COUNTER(NN))) + 1
      NETWORK(NETWORK_COUNTER(NODE_COUNTER(NN)))%NODE_INDEX(NETWORK_NCOUNTER(NETWORK_COUNTER(NODE_COUNTER(NN)))) = NN
      DUCTNODE_NE(NN) = NETWORK_NCOUNTER(NETWORK_COUNTER(NODE_COUNTER(NN)))
   ENDDO
   DEALLOCATE(NETWORK_DCOUNTER)
   DEALLOCATE(NETWORK_NCOUNTER)
   CALL DETERMINE_FIXED_ELEMENTS(T)
   CALL SETUP_SOLUTION_POINTERS
ENDIF

END SUBROUTINE FIND_NETWORKS

SUBROUTINE SETUP_SOLUTION_POINTERS
INTEGER:: NNE,NN,ND,COUNTER
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()
TYPE(NETWORK_TYPE), POINTER :: NE=>NULL()

DO NNE = 1,N_NETWORKS
   COUNTER = 0
   NE => NETWORK(NNE)   
   DO ND=1,NE%N_DUCTS
      DU=>DUCT(NE%DUCT_INDEX(ND))
      IF (DU%FIXED .OR. DU%AREA<=ZERO_P .OR. (DU%FAN_INDEX >0 .AND. DU%FAN_OPERATING)) CYCLE
      COUNTER = COUNTER + 1
      NE%MATRIX_INDEX(ND)=COUNTER
   ENDDO
   DO NN=1,NE%N_DUCTNODES
      DN=>DUCTNODE(NE%NODE_INDEX(NN))      
      IF (DN%FIXED .OR. DN%VENT_INDEX>0) CYCLE
      COUNTER = COUNTER + 1
      NE%MATRIX_INDEX(NE%N_DUCTS+NN)=COUNTER
   ENDDO
   NE%N_MATRIX=COUNTER
ENDDO

END SUBROUTINE SETUP_SOLUTION_POINTERS


SUBROUTINE UPDATE_LOSS(NNE)
REAL(EB) :: FRICTION_FACTOR,LOSS_SUM
INTEGER, INTENT(IN) :: NNE
INTEGER :: ND,ND2, NN
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()
TYPE(NETWORK_TYPE), POINTER :: NE=>NULL()

NE => NETWORK(NNE)
!!IF(N_FILTERS > 0) CALL FILTER_UPDATE(NNE)
DO ND = 1, NE%N_DUCTS
   DUCT(NE%DUCT_INDEX(ND))%TOTAL_LOSS=0._EB
ENDDO
NODELOOP : DO NN=1,NE%N_DUCTNODES
  DN => DUCTNODE(NE%NODE_INDEX(NN))
  DN%BRANCH_LOSS = 0._EB
  NODECLASS: IF (DN%FILTER_INDEX > 0) THEN
     IF(DUCT(DN%DUCT_INDEX(1))%VEL(GUESS)*DN%DIR(1) < 0._EB) THEN
        DN%BRANCH_LOSS(2) = DN%FILTER_LOSS
     ELSE
        DN%BRANCH_LOSS(1) = DN%FILTER_LOSS     
     ENDIF
  ELSEIF(DN%VENT_INDEX > 0) THEN NODECLASS
     IF(DUCT(DN%DUCT_INDEX(1))%FIXED .OR. (DUCT(DN%DUCT_INDEX(1))%FAN_INDEX >0 .AND. DUCT(DN%DUCT_INDEX(1))%FAN_OPERATING)) CYCLE
     IF(DUCT(DN%DUCT_INDEX(1))%VEL(GUESS)*DN%DIR(1) > 0._EB) THEN
        DN%BRANCH_LOSS(1) = DN%LOSS_ARRAY(1,2)
     ELSE
        DN%BRANCH_LOSS(1) = DN%LOSS_ARRAY(2,1)
     ENDIF     
  ELSE NODECLASS
     DO ND=1,DN%N_DUCTS
        DU => DUCT(DN%DUCT_INDEX(ND))
        IF (DU%VEL(GUESS)*DN%DIR(ND) > 0._EB) THEN
           DN%BRANCH_LOSS(ND) = ABS(DU%VEL(GUESS))*DU%AREA*DU%RHO_D
        ELSE
           DN%BRANCH_LOSS(ND) = 0._EB
        ENDIF
     ENDDO
     IF (SUM(DN%BRANCH_LOSS) < ZERO_P) THEN
        DN%BRANCH_LOSS = 0.5_EB * SUM(DN%LOSS_ARRAY)/DN%N_DUCTS
     ELSE
        DN%BRANCH_LOSS = DN%BRANCH_LOSS / SUM(DN%BRANCH_LOSS)
        DO ND=1,DN%N_DUCTS
           IF (DN%BRANCH_LOSS(ND)> ZERO_P) CYCLE
           LOSS_SUM = 0._EB
           DO ND2=1,DN%N_DUCTS
             IF(DN%BRANCH_LOSS(ND2) < ZERO_P) CYCLE
             LOSS_SUM = LOSS_SUM + DN%BRANCH_LOSS(ND2)*DN%LOSS_ARRAY(ND,ND2)
           ENDDO
           DUCT(DN%DUCT_INDEX(ND))%TOTAL_LOSS = LOSS_SUM
        ENDDO
     ENDIF
  ENDIF NODECLASS
ENDDO NODELOOP

DO ND = 1, NE%N_DUCTS
   DU => DUCT(NE%DUCT_INDEX(ND))
   IF (DU%ROUGHNESS > ZERO_P) THEN
      FRICTION_FACTOR = COMPUTE_FRICTION_FACTOR(DU%RHO_D,DU%TMP_D,ABS(DU%VEL(GUESS)),DU%DIAMETER,DU%ROUGHNESS)
   ELSE
      FRICTION_FACTOR = 0._EB
   ENDIF
   IF (DU%VEL(GUESS)>0._EB) THEN
      DU%TOTAL_LOSS = DU%LOSS(1)+DU%TOTAL_LOSS
   ELSEIF (DU%VEL(GUESS)<0._EB) THEN
      DU%TOTAL_LOSS = DU%LOSS(2)+DU%TOTAL_LOSS
   ELSE
      DU%TOTAL_LOSS = DU%TOTAL_LOSS+0.5_EB*(DU%LOSS(1)+DU%LOSS(2))
   ENDIF
   DU%TOTAL_LOSS = DU%TOTAL_LOSS + DU%LENGTH/DU%DIAMETER*FRICTION_FACTOR
   IF (DU%FAN_INDEX>0) THEN
      IF(.NOT. DU%FAN_OPERATING) DU%TOTAL_LOSS = DU%TOTAL_LOSS + FAN(DU%FAN_INDEX)%OFF_LOSS
   ENDIF
ENDDO

END SUBROUTINE UPDATE_LOSS


REAL(EB) FUNCTION COMPUTE_FRICTION_FACTOR(RHO,TEMPIN,VEL,DIAM,ROUGHNESS)
REAL(EB), INTENT(IN) :: RHO,TEMPIN,VEL,DIAM,ROUGHNESS
REAL(EB) :: EOD,RE_D,VISCOSITY,TEMP

TEMP = MAX(MIN(TEMPIN,2400._EB),200._EB)
!Visocisty power interpolation of 200 K - 2400 K, 200 K step,  J.P. Holman, Heat Transfer, 7th Ed
VISCOSITY = 3.9424E-7_EB*TEMP**0.67311_EB
RE_D = MAX(100._EB,RHO*DIAM*VEL/VISCOSITY)
EOD = ROUGHNESS / DIAM
COMPUTE_FRICTION_FACTOR = LOG10(6.9_EB/RE_D+(EOD/3.7_EB)**1.11_EB)
COMPUTE_FRICTION_FACTOR = LOG10(EOD/3.7_EB-4.518_EB/RE_D*COMPUTE_FRICTION_FACTOR)
COMPUTE_FRICTION_FACTOR = (-0.5_EB/COMPUTE_FRICTION_FACTOR)**2

RETURN

END FUNCTION COMPUTE_FRICTION_FACTOR


!SUBROUTINE FILTER_UPDATE(NNE)
!INTEGER, INTENT(IN) :: NNE
!
!RETURN
!
!END SUBROUTINE FILTER_UPDATE


SUBROUTINE SET_GUESS(NNE,T)
INTEGER, INTENT(IN) :: NNE
REAL(EB), INTENT(INOUT)::T
INTEGER :: ND
REAL(EB) :: VEL_TMP,RAMP_T
TYPE(DUCT_TYPE),POINTER :: DU=>NULL()
TYPE(NETWORK_TYPE), POINTER :: NE=>NULL()

NE => NETWORK(NNE)

DO ND = 1,NE%N_DUCTS
   DU => DUCT(NE%DUCT_INDEX(ND))
   IF (DU%FAN_INDEX > 0 .AND. DU%FAN_OPERATING) THEN
      DU%VEL(PREVIOUS)  = DU%VEL(NEW)
      IF (DU%DEVC_INDEX > 0) THEN
         RAMP_T = T - DEVICE(DU%DEVC_INDEX)%T_CHANGE
      ELSEIF(DU%CTRL_INDEX > 0) THEN
         RAMP_T = T - CONTROL(DU%CTRL_INDEX)%T_CHANGE
      ELSE
         RAMP_T = T
      ENDIF  
      CALL UPDATE_FAN(RAMP_T,NE%DUCT_INDEX(ND))
      DU%VEL(GUESS) = DU%VEL(NEW)
      CYCLE
   ENDIF
   IF (ITER == 0) THEN
      IF (DU%FIXED) THEN
         DU%VEL(PREVIOUS)  = DU%VEL(OLD) 
         CYCLE
      ENDIF
      DU%VEL(GUESS)     = DU%VEL(OLD)
      DU%VEL(NEW)       = DU%VEL(OLD)
      DU%VEL(PREVIOUS)  = DU%VEL(OLD)  
   ELSE
      VEL_TMP = DU%VEL(NEW)
      IF (ABS(DU%VEL(GUESS)) < ZERO_P) THEN
         DU%VEL(GUESS)     = DU%VEL(NEW)         
         DU%VEL(NEW)       = DU%VEL(PREVIOUS)
      ELSEIF (SIGN(1._EB,DU%VEL(PREVIOUS))==SIGN(1._EB,DU%VEL(NEW))) THEN
         DU%VEL(GUESS)     = DU%VEL(NEW)         
         DU%VEL(NEW)       = DU%VEL(PREVIOUS)!0.6_EB*DU%VEL(PREVIOUS)+0.4_EB*DU%VEL(GUESS)
      ELSE
         DU%VEL(GUESS)     = DU%VEL(NEW)         
         DU%VEL(NEW)       = 0._EB
      ENDIF
      DU%VEL(PREVIOUS) = VEL_TMP
   ENDIF
ENDDO

END SUBROUTINE SET_GUESS


SUBROUTINE SET_DONOR(NNE)
USE MATH_FUNCTIONS, ONLY : EVALUATE_RAMP
INTEGER :: ND
INTEGER, INTENT(IN) :: NNE
REAL(EB) :: RHOLAST,TMPLAST,FVAL,OMFVAL,ITERFRAC
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()
TYPE(NETWORK_TYPE), POINTER :: NE=>NULL()

NE => NETWORK(NNE)
ITERFRAC = REAL(ITER,EB)/REAL(ITER_MAX,EB)
FVAL = MIN(1._EB,MAX(0._EB,(ITERFRAC-ONTH))/ONTH,1._EB)
OMFVAL = 1._EB - FVAL

DUCTLOOP: DO ND=1,NE%N_DUCTS
   DU=>DUCT(NE%DUCT_INDEX(ND))
   IF (DU%AREA < ZERO_P) CYCLE DUCTLOOP
   IF (DU%FIXED .AND. DU%FAN_INDEX < 0) THEN
      DU%VEL(PREVIOUS) = DU%VEL(NEW)
      DU%VEL(GUESS) = DU%VEL(NEW)
   ENDIF      
   RHOLAST = DU%RHO_D   
   TMPLAST = DU%TMP_D
   IF (DU%VEL(PREVIOUS)>=0._EB) THEN
      DN=>DUCTNODE(DU%NODE_INDEX(1))
      IF(DN%VENT_INDEX > 0 .OR. DN%AMBIENT .OR. DN%LEAKAGE) THEN
         DN%RHO= DN%RHO_V
         DN%TMP= DN%TMP_V
         IF (N_TRACKED_SPECIES>0) DN%YY = DN%YY_V
         DN%RSUM = DN%RSUM_V
         DN%CP = DN%CP_V                  
      ENDIF
   ENDIF
   IF (DU%VEL(PREVIOUS)<0._EB) THEN
      DN=>DUCTNODE(DU%NODE_INDEX(2))
      IF(DN%VENT_INDEX > 0 .OR. DN%AMBIENT .OR. DN%LEAKAGE) THEN
         DN%RHO= DN%RHO_V
         DN%TMP= DN%TMP_V
         IF (N_TRACKED_SPECIES>0) DN%YY = DN%YY_V
         DN%RSUM = DN%RSUM_V
         DN%CP = DN%CP_V                  
      ENDIF
   ENDIF
   DU%RHO_D = DN%RHO
   DU%TMP_D = DN%TMP
   DU%RSUM_D = DN%RSUM
   IF (ITERFRAC > ONTH) THEN
      DU%RHO_D = FVAL*RHOLAST + OMFVAL*DU%RHO_D
      DU%TMP_D = FVAL*TMPLAST + OMFVAL*DU%TMP_D
   ENDIF   
ENDDO DUCTLOOP

END SUBROUTINE SET_DONOR


SUBROUTINE CONVERGENCE_CHECK(NNE)
INTEGER, INTENT(IN) :: NNE
INTEGER :: NN, ND
LOGICAL :: CONVERGED
REAL(EB) :: MSUM,MTOT,MFLOW,VEL
TYPE(NETWORK_TYPE), POINTER :: NE=>NULL()
TYPE(DUCT_TYPE), POINTER :: DU=>NULL()
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()

NE => NETWORK(NNE)
CONVERGED = .TRUE.
!Check duct velocity convergence
DO ND=1,NE%N_DUCTS
   DU => DUCT(NE%DUCT_INDEX(ND))
   IF (DU%AREA < ZERO_P) CYCLE
   IF (ABS(DU%VEL(PREVIOUS)) < 1.E-5_EB .AND. ABS(DU%VEL(NEW)) < 1.E-5_EB) CYCLE
   IF (DU%VEL(PREVIOUS) < 0._EB .EQV. DU%VEL(NEW) < 0._EB) THEN
        IF (ABS(DU%VEL(PREVIOUS))<=ZERO_P) THEN
           CONVERGED = .FALSE.
           EXIT
        ELSE
         IF (ABS(1._EB-DU%VEL(NEW)/DU%VEL(PREVIOUS)) > 0.05_EB) THEN
           CONVERGED = .FALSE.
            CYCLE
         ENDIF
        ENDIF
   ELSE
      CONVERGED = .FALSE.
   ENDIF
ENDDO
IF (.NOT. CONVERGED) RETURN

!Check node mass conservation convergence
DO NN=1,NE%N_DUCTNODES
   DN => DUCTNODE(NE%NODE_INDEX(NN))
   IF (DN%FIXED) CYCLE
   MSUM = 0._EB
   MTOT = 0._EB
   DO ND=1,DN%N_DUCTS
      DU=>DUCT(DN%DUCT_INDEX(ND))
      IF (ABS(DU%VEL(NEW))<1.E-7_EB) THEN
         VEL = 0._EB
      ELSE
         VEL = DU%VEL(NEW)
      ENDIF
      MFLOW = DN%DIR(ND)*VEL*DU%RHO_D*DU%AREA
      MSUM = MSUM + MFLOW
      MTOT = MTOT + ABS(MFLOW)
   ENDDO
   IF(ABS(MSUM)< 1.E-6 * MTOT .OR. MTOT < ZERO_P) CYCLE
   CONVERGED = .FALSE.
ENDDO

IF (CONVERGED) ITER=ITER_MAX

END SUBROUTINE CONVERGENCE_CHECK


SUBROUTINE COLLAPSE_HVAC_BC
!Takes the MPI gathered mesh array of HVAC boundary conditions and updates the DUCTNODE boundary condition values.
USE PHYSICAL_FUNCTIONS, ONLY : GET_SPECIFIC_GAS_CONSTANT,GET_AVERAGE_SPECIFIC_HEAT,GET_AVERAGE_SPECIFIC_HEAT_BG
INTEGER:: NN,NM,IZ1,IZ2
REAL(EB) :: AREA_SUM,AREA,CPBAR,H_G,TMP_SUM,TMP_NEW,YY_N(1:N_TRACKED_SPECIES)
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()

DO NN=1,N_DUCTNODES
   DN => DUCTNODE(NN)
   IF (DN%VENT_INDEX < 0 .AND. .NOT. DN%LEAKAGE) CYCLE
   IF (DN%VENT_INDEX > 0 .AND. .NOT. DN%LEAKAGE) THEN
      NM = DN%MESH_INDEX
      DN%P = NODE_P(NN,NM)
      DN%TMP_V = NODE_TMP(NN,NM)
      DN%RHO_V = NODE_RHO(NN,NM)
      DN%CP_V = NODE_CP(NN,NM)
      DN%RSUM_V = NODE_RSUM(NN,NM)
      IF (N_TRACKED_SPECIES > 0) DN%YY_V(1:N_TRACKED_SPECIES) = NODE_YY(NN,1:N_TRACKED_SPECIES,NM)
   ENDIF
   LEAKAGE_IF: IF (DN%LEAKAGE) THEN
      IZ1 = DN%ZONE_INDEX
      IF (DUCT(DN%DUCT_INDEX(1))%NODE_INDEX(1)==NN) THEN
         IZ2 = DUCTNODE(DUCT(DN%DUCT_INDEX(1))%NODE_INDEX(2))%ZONE_INDEX
      ELSE
         IZ2 = DUCTNODE(DUCT(DN%DUCT_INDEX(1))%NODE_INDEX(1))%ZONE_INDEX
      ENDIF
      IF (IZ1 == 0 .AND. ALL(LEAK_RHO(IZ1,IZ2,:) <= ZERO_P)) CYCLE
      IF (PREDICTOR) DN%P = 0.5_EB*(PBAR(0,IZ1)+PBAR(1,IZ1))
      IF (CORRECTOR) DN%P = 0.5_EB*(PBAR(0,IZ1)+PBAR(1,IZ1))
      DN%TMP_V = 0._EB
      DN%RHO_V = 0._EB
      DN%CP_V = 0._EB
      DN%RSUM_V = 0._EB
      IF (N_TRACKED_SPECIES > 0) DN%YY_V = 0._EB       
      AREA_SUM = 0._EB
      DO NM=1,NMESHES
         AREA = FDS_LEAK_AREA(IZ1,IZ2,NM)
         AREA_SUM = AREA_SUM + AREA
         DN%RHO_V = DN%RHO_V + LEAK_RHO(IZ1,IZ2,NM) * AREA
         DN%TMP_V = DN%TMP_V + LEAK_TMP(IZ1,IZ2,NM) * AREA
         IF (N_TRACKED_SPECIES > 0) THEN
            YY_N(1:N_TRACKED_SPECIES) = LEAK_YY(IZ1,IZ2,1:N_TRACKED_SPECIES,NM)
            DN%YY_V(1:N_TRACKED_SPECIES) = DN%YY_V(1:N_TRACKED_SPECIES) + YY_N(1:N_TRACKED_SPECIES) * LEAK_RHO(IZ1,IZ2,NM) * AREA
            CALL GET_AVERAGE_SPECIFIC_HEAT(YY_N,CPBAR,LEAK_TMP(IZ1,IZ2,NM))
            H_G = CPBAR * LEAK_TMP(IZ1,IZ2,NM)
         ELSE
            CALL GET_AVERAGE_SPECIFIC_HEAT_BG(CPBAR,LEAK_TMP(IZ1,IZ2,NM))
            H_G = CPBAR * LEAK_TMP(IZ1,IZ2,NM)
         ENDIF
         DN%CP_V = DN%CP_V + H_G * AREA * LEAK_RHO(IZ1,IZ2,NM)
      ENDDO    
      FDS_LEAK_AREA(IZ1,IZ2,:) = AREA_SUM
      IF (N_TRACKED_SPECIES>0) THEN
         DN%YY_V = DN%YY_V / DN%RHO_V
         YY_N = DN%YY_V
         CALL GET_SPECIFIC_GAS_CONSTANT(YY_N,DN%RSUM_V)
      ELSE
         DN%RSUM_V = RSUM0
      ENDIF  
      DN%TMP_V = DN%TMP_V / AREA_SUM
      DN%CP_V = DN%CP_V / DN%RHO_V
      DN%RHO_V = DN%RHO_V / AREA_SUM
      TMP_SUM = DN%TMP_V
      DO
         IF (N_TRACKED_SPECIES > 0) THEN
            CALL GET_AVERAGE_SPECIFIC_HEAT(YY_N,CPBAR,TMP_SUM)      
         ELSE
            CALL GET_AVERAGE_SPECIFIC_HEAT_BG(CPBAR,TMP_SUM)      
         ENDIF
         TMP_NEW = DN%CP_V / CPBAR
         IF (ABS(TMP_SUM - TMP_NEW) < ZERO_P .OR. ABS(TMP_SUM - TMP_NEW)/TMP_NEW < 0.0005_EB) EXIT
         TMP_SUM = TMP_NEW
      ENDDO
      DN%TMP_V = TMP_NEW
      DN%CP_V = CPBAR
   ENDIF LEAKAGE_IF
END DO

END SUBROUTINE COLLAPSE_HVAC_BC

SUBROUTINE UPDATE_NODE_BC
!Takes the MPI gathered mesh array of HVAC boundary conditions and updates the DUCTNODE boundary condition values.
INTEGER:: NN, NS, ND
TYPE(DUCTNODE_TYPE), POINTER :: DN=>NULL()

DO NN=1,N_DUCTNODES
   DN => DUCTNODE(NN)
   IF (DN%VENT_INDEX < 0) CYCLE
   NODE_P(NN,:) = DN%P
   NODE_TMP(NN,:) = DN%TMP
   NODE_RHO(NN,:) = DN%RHO
   NODE_CP(NN,:) = DN%CP
   NODE_RSUM(NN,:) = DN%RSUM
   IF (N_TRACKED_SPECIES > 0) THEN
      DO NS=1,N_TRACKED_SPECIES
         NODE_YY(NN,NS,:) = DN%YY(NS)
      ENDDO
   ENDIF
END DO

DO ND=1,N_DUCTS
   DUCT_U(ND,:) = DUCT(ND)%VEL(NEW)*DUCT(ND)%AREA
ENDDO

END SUBROUTINE UPDATE_NODE_BC


SUBROUTINE LEAKAGE_HVAC
USE PHYSICAL_FUNCTIONS, ONLY: GET_AVERAGE_SPECIFIC_HEAT,GET_AVERAGE_SPECIFIC_HEAT_BG
REAL(EB) :: YY_GET(1:N_TRACKED_SPECIES)
INTEGER :: I_DUCT,I_DUCTNODE,NZ1,NZ2
TYPE (DUCTNODE_TYPE), POINTER:: DN1=>NULL(),DN2=>NULL()
TYPE (DUCT_TYPE), POINTER:: DU=>NULL()

I_DUCT = N_DUCTS - LEAK_DUCTS
I_DUCTNODE = N_DUCTNODES - 2 * LEAK_DUCTS
DO NZ1 = 0, N_ZONE
   DO NZ2 = 0, N_ZONE
      IF (LEAK_PATH(NZ1,NZ2) == 1) THEN
         I_DUCT = I_DUCT + 1
         LEAK_PATH(NZ1,NZ2) = I_DUCT
         I_DUCTNODE = I_DUCTNODE + 1
         DU => DUCT(I_DUCT)
         DU%AREA_INITIAL = P_ZONE(NZ2)%LEAK_AREA(NZ1)
         DU%AREA = P_ZONE(NZ2)%LEAK_AREA(NZ1)
         DU%DIAMETER = SQRT(DU%AREA / PI)*2._EB
         DU%LEAKAGE = .TRUE.
         DU%LENGTH = 1._EB         
         DU%LOSS(1) = 1._EB                  
         DU%LOSS(2) = 1._EB
         DU%NODE_INDEX(1) = I_DUCTNODE
         DU%NODE_INDEX(2) = I_DUCTNODE+1
         DU%RHO_D = RHOA
         DU%TMP_D = TMPA
         DU%ROUGHNESS = 0._EB
         DU%VEL = 0._EB
         IF (N_TRACKED_SPECIES > 0) THEN
            ALLOCATE(DU%YY(N_TRACKED_SPECIES))
            YY_GET = YY_AMBIENT(1:N_TRACKED_SPECIES)
            DU%YY(1:N_TRACKED_SPECIES) = YY_GET
            CALL GET_AVERAGE_SPECIFIC_HEAT(YY_GET,DU%CP_D,TMPA)
         ELSE
            CALL GET_AVERAGE_SPECIFIC_HEAT_BG(DU%CP_D,TMPA)
         ENDIF         
         DN1=>DUCTNODE(I_DUCTNODE)
         IF (NZ1==0) DN1%AMBIENT = .TRUE.
         ALLOCATE(DN1%DUCT_INDEX(1))
         ALLOCATE(DN1%DIR(1))
         ALLOCATE(DN1%BRANCH_LOSS(1))   
         ALLOCATE(DN1%LOSS_ARRAY(2,2))            
         DN1%LOSS_ARRAY = 0._EB
         DN1%BRANCH_LOSS = 0._EB
         DN1%DIR = 1._EB
         DN1%DUCT_INDEX = I_DUCT
         DN1%LEAKAGE = .TRUE.
         DN1%ZONE_INDEX=NZ1
         DN1%MESH_INDEX = 1
         DN1%N_DUCTS = 1
         DN1%RSUM = RSUM0
         DN1%TMP = TMPA
         DN1%XYZ = (/0._EB,0._EB,0._EB/)
         WRITE(DN1%ID,'(A,1X,I0,1X,I0)') 'LEAK',NZ1,NZ2
         I_DUCTNODE = I_DUCTNODE + 1
         DN2=>DUCTNODE(I_DUCTNODE)
         IF (NZ2==0) DN2%AMBIENT = .TRUE.
         ALLOCATE(DN2%DUCT_INDEX(1))
         ALLOCATE(DN2%DIR(1))
         ALLOCATE(DN2%BRANCH_LOSS(1))   
         ALLOCATE(DN2%LOSS_ARRAY(2,2))            
         DN2%LOSS_ARRAY = 0._EB
         DN2%BRANCH_LOSS = 0._EB         
         DN2%DIR = -1._EB
         DN2%DUCT_INDEX = I_DUCT
         DN2%LEAKAGE = .TRUE.
         DN2%ZONE_INDEX=NZ2
         DN2%XYZ = (/0._EB,0._EB,0._EB/)
         DN2%MESH_INDEX = 1
         DN2%N_DUCTS = 1
         DN2%RSUM = RSUM0
         DN2%TMP = TMPA         
         WRITE(DN2%ID,'(A,1X,I0,1X,I0)') 'LEAK',NZ2,NZ1
      ENDIF
   ENDDO
ENDDO


END SUBROUTINE

SUBROUTINE GET_REV_HVAC(MODULE_REV,MODULE_DATE)
INTEGER,INTENT(INOUT) :: MODULE_REV
CHARACTER(255),INTENT(INOUT) :: MODULE_DATE
WRITE(MODULE_DATE,'(A)') hvacrev(INDEX(hvacrev,':')+1:LEN_TRIM(hvacrev)-2)
READ (MODULE_DATE,'(I5)') MODULE_REV
WRITE(MODULE_DATE,'(A)') hvacdate
END SUBROUTINE GET_REV_HVAC
 
END MODULE HVAC_ROUTINES
