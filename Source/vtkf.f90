!< PENF GLOBAL PARAMETERS AND VARIABLES.

MODULE PENF_GLOBAL_PARAMETERS_VARIABLES
!< PENF GLOBAL PARAMETERS AND VARIABLES.
!<
!< @NOTE ALL MODULE DEFINED ENTITIES ARE PUBLIC.

IMPLICIT NONE
PUBLIC
SAVE

INTEGER, PARAMETER :: ENDIANL = 1 !< LITTLE ENDIAN PARAMETER.
INTEGER, PARAMETER :: ENDIANB = 0 !< BIG ENDIAN PARAMETER.

! PORTABLE KIND PARAMETERS
#ifdef _ASCII_SUPPORTED
INTEGER, PARAMETER :: ASCII = SELECTED_CHAR_KIND('ASCII')     !< ASCII CHARACTER SET KIND.
#else
INTEGER, PARAMETER :: ASCII = SELECTED_CHAR_KIND('DEFAULT')   !< ASCII CHARACTER SET KIND DEFINED AS DEFAULT SET.
#endif
#ifdef _UCS4_SUPPORTED
INTEGER, PARAMETER :: UCS4  = SELECTED_CHAR_KIND('ISO_10646') !< UNICODE CHARACTER SET KIND.
#else
INTEGER, PARAMETER :: UCS4  = SELECTED_CHAR_KIND('DEFAULT')   !< UNICODE CHARACTER SET KIND DEFINED AS DEFAULT SET.
#endif
#if defined _CK_IS_DEFAULT
INTEGER, PARAMETER :: CK  = SELECTED_CHAR_KIND('DEFAULT')     !< DEFAULT KIND CHARACTER.
#elif defined _CK_IS_ASCII
INTEGER, PARAMETER :: CK  = ASCII                             !< DEFAULT KIND CHARACTER.
#elif defined _CK_IS_UCS4
INTEGER, PARAMETER :: CK  = UCS4                              !< DEFAULT KIND CHARACTER.
#else
INTEGER, PARAMETER :: CK  = SELECTED_CHAR_KIND('DEFAULT')     !< DEFAULT KIND CHARACTER.
#endif

INTEGER, PARAMETER :: R16P = SELECTED_REAL_KIND(33,4931) !< 33 DIGITS, RANGE \([10^{-4931}, 10^{+4931} - 1]\); 128 BITS.
INTEGER, PARAMETER :: R8P  = SELECTED_REAL_KIND(15,307)  !< 15 DIGITS, RANGE \([10^{-307} , 10^{+307}  - 1]\); 64 BITS.
INTEGER, PARAMETER :: R4P  = SELECTED_REAL_KIND(6,37)    !< 6  DIGITS, RANGE \([10^{-37}  , 10^{+37}   - 1]\); 32 BITS.
#if defined _R_P_IS_R16P
INTEGER, PARAMETER :: R_P  = R16P                        !< DEFAULT REAL PRECISION.
#elif defined _R_P_IS_R8P
INTEGER, PARAMETER :: R_P  = R8P                         !< DEFAULT REAL PRECISION.
#elif defined _R_P_IS_R4P
INTEGER, PARAMETER :: R_P  = R4P                         !< DEFAULT REAL PRECISION.
#else
INTEGER, PARAMETER :: R_P  = R8P                         !< DEFAULT REAL PRECISION.
#endif

INTEGER, PARAMETER :: I8P = SELECTED_INT_KIND(18) !< RANGE \([-2^{63},+2^{63} - 1]\), 19 DIGITS PLUS SIGN; 64 BITS.
INTEGER, PARAMETER :: I4P = SELECTED_INT_KIND(9)  !< RANGE \([-2^{31},+2^{31} - 1]\), 10 DIGITS PLUS SIGN; 32 BITS.
INTEGER, PARAMETER :: I2P = SELECTED_INT_KIND(4)  !< RANGE \([-2^{15},+2^{15} - 1]\), 5  DIGITS PLUS SIGN; 16 BITS.
INTEGER, PARAMETER :: I1P = SELECTED_INT_KIND(2)  !< RANGE \([-2^{7} ,+2^{7}  - 1]\), 3  DIGITS PLUS SIGN; 8  BITS.
INTEGER, PARAMETER :: I_P = I4P                   !< DEFAULT INTEGER PRECISION.

! FORMAT PARAMETERS
CHARACTER(*), PARAMETER :: FR16P = '(E42.33E4)' !< OUTPUT FORMAT FOR KIND=R16P REAL.
CHARACTER(*), PARAMETER :: FR8P  = '(E23.15E3)' !< OUTPUT FORMAT FOR KIND=R8P REAL.
CHARACTER(*), PARAMETER :: FR4P  = '(E13.6E2)'  !< OUTPUT FORMAT FOR KIND=R4P REAL.
#if defined _R_P_IS_R16P
CHARACTER(*), PARAMETER :: FR_P  = FR16P        !< OUTPUT FORMAT FOR KIND=R_P REAL.
#elif defined _R_P_IS_R8P
CHARACTER(*), PARAMETER :: FR_P  = FR8P         !< OUTPUT FORMAT FOR KIND=R_P REAL.
#elif defined _R_P_IS_R4P
CHARACTER(*), PARAMETER :: FR_P  = FR4P         !< OUTPUT FORMAT FOR KIND=R_P REAL.
#else
CHARACTER(*), PARAMETER :: FR_P  = FR8P         !< OUTPUT FORMAT FOR KIND=R_P REAL.
#endif

CHARACTER(*), PARAMETER :: FI8P   = '(I20)'    !< OUTPUT FORMAT FOR KIND=I8P INTEGER.
CHARACTER(*), PARAMETER :: FI8PZP = '(I20.19)' !< OUTPUT FORMAT FOR KIND=I8P INTEGER WITH ZERO PREFIXING.
CHARACTER(*), PARAMETER :: FI4P   = '(I11)'    !< OUTPUT FORMAT FOR KIND=I4P INTEGER.
CHARACTER(*), PARAMETER :: FI4PZP = '(I11.10)' !< OUTPUT FORMAT FOR KIND=I4P INTEGER WITH ZERO PREFIXING.
CHARACTER(*), PARAMETER :: FI2P   = '(I6)'     !< OUTPUT FORMAT FOR KIND=I2P INTEGER.
CHARACTER(*), PARAMETER :: FI2PZP = '(I6.5)'   !< OUTPUT FORMAT FOR KIND=I2P INTEGER WITH ZERO PREFIXING.
CHARACTER(*), PARAMETER :: FI1P   = '(I4)'     !< OUTPUT FORMAT FOR KIND=I1P INTEGER.
CHARACTER(*), PARAMETER :: FI1PZP = '(I4.3)'   !< OUTPUT FORMAT FOR KIND=I1P INTEGER WITH ZERO PREFIXING.
CHARACTER(*), PARAMETER :: FI_P   = FI4P       !< OUTPUT FORMAT FOR KIND=I_P INTEGER.
CHARACTER(*), PARAMETER :: FI_PZP = FI4PZP     !< OUTPUT FORMAT FOR KIND=I_P INTEGER WITH ZERO PREFIXING.

! LENGTH (NUMBER OF DIGITS) OF FORMATTED NUMBERS
INTEGER, PARAMETER :: DR16P = 42    !< NUMBER OF DIGITS OF OUTPUT FORMAT FR16P.
INTEGER, PARAMETER :: DR8P  = 23    !< NUMBER OF DIGITS OF OUTPUT FORMAT FR8P.
INTEGER, PARAMETER :: DR4P  = 13    !< NUMBER OF DIGITS OF OUTPUT FORMAT FR4P.
#if defined _R_P_IS_R16P
INTEGER, PARAMETER :: DR_P  = DR16P !< NUMBER OF DIGITS OF OUTPUT FORMAT FR_P.
#elif defined _R_P_IS_R8P
INTEGER, PARAMETER :: DR_P  = DR8P  !< NUMBER OF DIGITS OF OUTPUT FORMAT FR_P.
#elif defined _R_P_IS_R4P
INTEGER, PARAMETER :: DR_P  = DR4P  !< NUMBER OF DIGITS OF OUTPUT FORMAT FR_P.
#else
INTEGER, PARAMETER :: DR_P  = DR8P  !< NUMBER OF DIGITS OF OUTPUT FORMAT FR_P.
#endif

INTEGER, PARAMETER :: DI8P  = 20   !< NUMBER OF DIGITS OF OUTPUT FORMAT I8P.
INTEGER, PARAMETER :: DI4P  = 11   !< NUMBER OF DIGITS OF OUTPUT FORMAT I4P.
INTEGER, PARAMETER :: DI2P  = 6    !< NUMBER OF DIGITS OF OUTPUT FORMAT I2P.
INTEGER, PARAMETER :: DI1P  = 4    !< NUMBER OF DIGITS OF OUTPUT FORMAT I1P.
INTEGER, PARAMETER :: DI_P  = DI4P !< NUMBER OF DIGITS OF OUTPUT FORMAT I_P.

! LIST OF KINDS
INTEGER,      PARAMETER :: CHARACTER_KINDS_LIST(1:3) = [ASCII, UCS4, CK]                        !< LIST OF CHARACTER KINDS.
INTEGER,      PARAMETER :: REAL_KINDS_LIST(1:4)      = [R16P, R8P, R4P, R_P]                    !< LIST OF REAL KINDS.
CHARACTER(*), PARAMETER :: REAL_FORMATS_LIST(1:4)    = [FR16P, FR8P, FR4P//' ', FR_P]           !< LIST OF REAL FORMATS.
INTEGER,      PARAMETER :: INTEGER_KINDS_LIST(1:5)   = [I8P, I4P, I2P, I1P,I_P]                 !< LIST OF INTEGER KINDS.
CHARACTER(*), PARAMETER :: INTEGER_FORMATS_LIST(1:5) = [FI8P, FI4P, FI2P//' ', FI1P//' ', FI_P] !< LIST OF INTEGER FORMATS.

! MINIMUM AND MAXIMUM (REPRESENTABLE) VALUES
REAL(R16P),   PARAMETER :: MINR16P = -HUGE(1._R16P) !< MINIMUM VALUE OF KIND=R16P REAL.
REAL(R16P),   PARAMETER :: MAXR16P =  HUGE(1._R16P) !< MAXIMUM VALUE OF KIND=R16P REAL.
REAL(R8P),    PARAMETER :: MINR8P  = -HUGE(1._R8P ) !< MINIMUM VALUE OF KIND=R8P REAL.
REAL(R8P),    PARAMETER :: MAXR8P  =  HUGE(1._R8P ) !< MAXIMUM VALUE OF KIND=R8P REAL.
REAL(R4P),    PARAMETER :: MINR4P  = -HUGE(1._R4P ) !< MINIMUM VALUE OF KIND=R4P REAL.
REAL(R4P),    PARAMETER :: MAXR4P  =  HUGE(1._R4P ) !< MAXIMUM VALUE OF KIND=R4P REAL.
REAL(R_P),    PARAMETER :: MINR_P  = -HUGE(1._R_P ) !< MINIMUM VALUE OF KIND=R_P REAL.
REAL(R_P),    PARAMETER :: MAXR_P  =  HUGE(1._R_P ) !< MAXIMUM VALUE OF KIND=R_P REAL.
INTEGER(I8P), PARAMETER :: MINI8P  = -HUGE(1_I8P)   !< MINIMUM VALUE OF KIND=I8P INTEGER.
INTEGER(I4P), PARAMETER :: MINI4P  = -HUGE(1_I4P)   !< MINIMUM VALUE OF KIND=I4P INTEGER.
INTEGER(I2P), PARAMETER :: MINI2P  = -HUGE(1_I2P)   !< MINIMUM VALUE OF KIND=I2P INTEGER.
INTEGER(I1P), PARAMETER :: MINI1P  = -HUGE(1_I1P)   !< MINIMUM VALUE OF KIND=I1P INTEGER.
INTEGER(I_P), PARAMETER :: MINI_P  = -HUGE(1_I_P)   !< MINIMUM VALUE OF KIND=I_P INTEGER.
INTEGER(I8P), PARAMETER :: MAXI8P  =  HUGE(1_I8P)   !< MAXIMUM VALUE OF KIND=I8P INTEGER.
INTEGER(I4P), PARAMETER :: MAXI4P  =  HUGE(1_I4P)   !< MAXIMUM VALUE OF KIND=I4P INTEGER.
INTEGER(I2P), PARAMETER :: MAXI2P  =  HUGE(1_I2P)   !< MAXIMUM VALUE OF KIND=I2P INTEGER.
INTEGER(I1P), PARAMETER :: MAXI1P  =  HUGE(1_I1P)   !< MAXIMUM VALUE OF KIND=I1P INTEGER.
INTEGER(I_P), PARAMETER :: MAXI_P  =  HUGE(1_I_P)   !< MAXIMUM VALUE OF KIND=I_P INTEGER.

! REAL SMALLEST (REPRESENTABLE) VALUES
REAL(R16P), PARAMETER :: SMALLR16P = TINY(1._R16P) !< SMALLEST REPRESENTABLE VALUE OF KIND=R16P REAL.
REAL(R8P),  PARAMETER :: SMALLR8P  = TINY(1._R8P ) !< SMALLEST REPRESENTABLE VALUE OF KIND=R8P REAL.
REAL(R4P),  PARAMETER :: SMALLR4P  = TINY(1._R4P ) !< SMALLEST REPRESENTABLE VALUE OF KIND=R4P REAL.
REAL(R_P),  PARAMETER :: SMALLR_P  = TINY(1._R_P ) !< SMALLEST REPRESENTABLE VALUE OF KIND=R_P REAL.

! SMALLEST REAL REPRESENTABLE DIFFERENCE BY THE RUNNING CALCULATOR
REAL(R16P), PARAMETER :: ZEROR16P = NEAREST(1._R16P, 1._R16P) - &
                                    NEAREST(1._R16P,-1._R16P) !< SMALLEST REPRESENTABLE DIFFERENCE OF KIND=R16P REAL.
REAL(R8P),  PARAMETER :: ZEROR8P  = NEAREST(1._R8P, 1._R8P) - &
                                    NEAREST(1._R8P,-1._R8P)   !< SMALLEST REPRESENTABLE DIFFERENCE OF KIND=R8P REAL.
REAL(R4P),  PARAMETER :: ZEROR4P  = NEAREST(1._R4P, 1._R4P) - &
                                    NEAREST(1._R4P,-1._R4P)   !< SMALLEST REPRESENTABLE DIFFERENCE OF KIND=R4P REAL.
REAL(R_P),  PARAMETER :: ZEROR_P  = NEAREST(1._R_P, 1._R_P) - &
                                    NEAREST(1._R_P,-1._R_P)   !< SMALLEST REPRESENTABLE DIFFERENCE OF KIND=R_P REAL.

! BITS/BYTES MEMORY REQUIREMENTS (REAL VARIABLES MUST BE COMPUTED AT RUNTIME)
INTEGER(I2P)            :: BIR16P                         !< NUMBER OF BITS OF KIND=R16P REAL.
INTEGER(I1P)            :: BIR8P                          !< NUMBER OF BITS OF KIND=R8P REAL.
INTEGER(I1P)            :: BIR4P                          !< NUMBER OF BITS OF KIND=R4P REAL.
INTEGER(I1P)            :: BIR_P                          !< NUMBER OF BITS OF KIND=R_P REAL.
INTEGER(I2P)            :: BYR16P                         !< NUMBER OF BYTES OF KIND=R16P REAL.
INTEGER(I1P)            :: BYR8P                          !< NUMBER OF BYTES OF KIND=R8P REAL.
INTEGER(I1P)            :: BYR4P                          !< NUMBER OF BYTES OF KIND=R4P REAL.
INTEGER(I1P)            :: BYR_P                          !< NUMBER OF BYTES OF KIND=R_P REAL.
INTEGER(I8P), PARAMETER :: BII8P = BIT_SIZE(MAXI8P)       !< NUMBER OF BITS OF KIND=I8P INTEGER.
INTEGER(I4P), PARAMETER :: BII4P = BIT_SIZE(MAXI4P)       !< NUMBER OF BITS OF KIND=I4P INTEGER.
INTEGER(I2P), PARAMETER :: BII2P = BIT_SIZE(MAXI2P)       !< NUMBER OF BITS OF KIND=I2P INTEGER.
INTEGER(I1P), PARAMETER :: BII1P = BIT_SIZE(MAXI1P)       !< NUMBER OF BITS OF KIND=I1P INTEGER.
INTEGER(I_P), PARAMETER :: BII_P = BIT_SIZE(MAXI_P)       !< NUMBER OF BITS OF KIND=I_P INTEGER.
INTEGER(I8P), PARAMETER :: BYI8P = BIT_SIZE(MAXI8P)/8_I8P !< NUMBER OF BYTES OF KIND=I8P INTEGER.
INTEGER(I4P), PARAMETER :: BYI4P = BIT_SIZE(MAXI4P)/8_I4P !< NUMBER OF BYTES OF KIND=I4P INTEGER.
INTEGER(I2P), PARAMETER :: BYI2P = BIT_SIZE(MAXI2P)/8_I2P !< NUMBER OF BYTES OF KIND=I2P INTEGER.
INTEGER(I1P), PARAMETER :: BYI1P = BIT_SIZE(MAXI1P)/8_I1P !< NUMBER OF BYTES OF KIND=I1P INTEGER.
INTEGER(I_P), PARAMETER :: BYI_P = BIT_SIZE(MAXI_P)/8_I_P !< NUMBER OF BYTES OF KIND=I_P INTEGER.
ENDMODULE PENF_GLOBAL_PARAMETERS_VARIABLES



!< PENF BIT/BYTE SIZE FUNCTIONS.

MODULE PENF_B_SIZE
!< PENF BIT/BYTE SIZE FUNCTIONS.
USE PENF_GLOBAL_PARAMETERS_VARIABLES

IMPLICIT NONE
PRIVATE
SAVE
PUBLIC :: BIT_SIZE, BYTE_SIZE

INTERFACE BIT_SIZE
  !< OVERLOADING OF THE INTRINSIC *BIT_SIZE* FUNCTION FOR COMPUTING THE NUMBER OF BITS OF (ALSO) REAL AND CHARACTER VARIABLES.
  MODULE PROCEDURE                &
                   BIT_SIZE_R16P, &
                   BIT_SIZE_R8P,  &
                   BIT_SIZE_R4P,  &
                   BIT_SIZE_CHR
ENDINTERFACE

INTERFACE BYTE_SIZE
  !< COMPUTE THE NUMBER OF BYTES OF A VARIABLE.
  MODULE PROCEDURE                 &
                   BYTE_SIZE_I8P,  &
                   BYTE_SIZE_I4P,  &
                   BYTE_SIZE_I2P,  &
                   BYTE_SIZE_I1P,  &
                   BYTE_SIZE_R16P, &
                   BYTE_SIZE_R8P,  &
                   BYTE_SIZE_R4P,  &
                   BYTE_SIZE_CHR
ENDINTERFACE

CONTAINS
   ELEMENTAL FUNCTION BIT_SIZE_R16P(I) RESULT(BITS)
   !< COMPUTE THE NUMBER OF BITS OF A REAL VARIABLE.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT FI2P, BIT_SIZE(1._R16P)
   !<```
   !=> 128 <<<
   REAL(R16P), INTENT(IN) :: I       !< REAL VARIABLE WHOSE NUMBER OF BITS MUST BE COMPUTED.
   INTEGER(I2P)           :: BITS    !< NUMBER OF BITS OF R.
   INTEGER(I1P)           :: MOLD(1) !< "MOLDING" DUMMY VARIABLE FOR BITS COUNTING.

   BITS = SIZE(TRANSFER(I, MOLD), DIM=1, KIND=I2P) * 8_I2P
   ENDFUNCTION BIT_SIZE_R16P

   ELEMENTAL FUNCTION BIT_SIZE_R8P(I) RESULT(BITS)
   !< COMPUTE THE NUMBER OF BITS OF A REAL VARIABLE.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT FI1P, BIT_SIZE(1._R8P)
   !<```
   !=> 64 <<<
   REAL(R8P), INTENT(IN) :: I       !< REAL VARIABLE WHOSE NUMBER OF BITS MUST BE COMPUTED.
   INTEGER(I1P)          :: BITS    !< NUMBER OF BITS OF R.
   INTEGER(I1P)          :: MOLD(1) !< "MOLDING" DUMMY VARIABLE FOR BITS COUNTING.

   BITS = SIZE(TRANSFER(I, MOLD), DIM=1, KIND=I1P) * 8_I1P
   ENDFUNCTION BIT_SIZE_R8P

   ELEMENTAL FUNCTION BIT_SIZE_R4P(I) RESULT(BITS)
   !< COMPUTE THE NUMBER OF BITS OF A REAL VARIABLE.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT FI1P, BIT_SIZE(1._R4P)
   !<```
   !=> 32 <<<
   REAL(R4P), INTENT(IN) :: I       !< REAL VARIABLE WHOSE NUMBER OF BITS MUST BE COMPUTED.
   INTEGER(I1P)          :: BITS    !< NUMBER OF BITS OF R.
   INTEGER(I1P)          :: MOLD(1) !< "MOLDING" DUMMY VARIABLE FOR BITS COUNTING.

   BITS = SIZE(TRANSFER(I, MOLD), DIM=1, KIND=I1P) * 8_I1P
   ENDFUNCTION BIT_SIZE_R4P

   ELEMENTAL FUNCTION BIT_SIZE_CHR(I) RESULT(BITS)
   !< COMPUTE THE NUMBER OF BITS OF A CHARACTER VARIABLE.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT FI4P, BIT_SIZE('AB')
   !<```
   !=> 16 <<<
   CHARACTER(*), INTENT(IN) :: I       !< CHARACTER VARIABLE WHOSE NUMBER OF BITS MUST BE COMPUTED.
   INTEGER(I4P)             :: BITS    !< NUMBER OF BITS OF C.
   INTEGER(I1P)             :: MOLD(1) !< "MOLDING" DUMMY VARIABLE FOR BITS COUNTING.

   BITS = SIZE(TRANSFER(I, MOLD), DIM=1, KIND=I4P) * 8_I4P
   ENDFUNCTION BIT_SIZE_CHR

   ELEMENTAL FUNCTION BYTE_SIZE_R16P(I) RESULT(BYTES)
   !< COMPUTE THE NUMBER OF BYTES OF A REAL VARIABLE.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT FI1P, BYTE_SIZE(1._R16P)
   !<```
   !=> 16 <<<
   REAL(R16P), INTENT(IN) :: I     !< REAL VARIABLE WHOSE NUMBER OF BYTES MUST BE COMPUTED.
   INTEGER(I1P)           :: BYTES !< NUMBER OF BYTES OF R.

   BYTES = INT(BIT_SIZE(I),I1P) / 8_I1P
   ENDFUNCTION BYTE_SIZE_R16P

   ELEMENTAL FUNCTION BYTE_SIZE_R8P(I) RESULT(BYTES)
   !< COMPUTE THE NUMBER OF BYTES OF A REAL VARIABLE.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT FI1P, BYTE_SIZE(1._R8P)
   !<```
   !=> 8 <<<
   REAL(R8P), INTENT(IN) :: I     !< REAL VARIABLE WHOSE NUMBER OF BYTES MUST BE COMPUTED.
   INTEGER(I1P)          :: BYTES !< NUMBER OF BYTES OF R.

   BYTES = BIT_SIZE(I) / 8_I1P
   ENDFUNCTION BYTE_SIZE_R8P

   ELEMENTAL FUNCTION BYTE_SIZE_R4P(I) RESULT(BYTES)
   !< COMPUTE THE NUMBER OF BYTES OF A REAL VARIABLE.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT FI1P, BYTE_SIZE(1._R4P)
   !<```
   !=> 4 <<<
   REAL(R4P), INTENT(IN) :: I     !< REAL VARIABLE WHOSE NUMBER OF BYTES MUST BE COMPUTED.
   INTEGER(I1P)          :: BYTES !< NUMBER OF BYTES OF R.

   BYTES = BIT_SIZE(I) / 8_I1P
   ENDFUNCTION BYTE_SIZE_R4P

   ELEMENTAL FUNCTION BYTE_SIZE_CHR(I) RESULT(BYTES)
   !< COMPUTE THE NUMBER OF BYTES OF A CHARACTER VARIABLE.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT FI1P, BYTE_SIZE('AB')
   !<```
   !=> 2 <<<
   CHARACTER(*), INTENT(IN) :: I     !< CHARACTER VARIABLE WHOSE NUMBER OF BYTES MUST BE COMPUTED.
   INTEGER(I4P)             :: BYTES !< NUMBER OF BYTES OF C.

   BYTES = BIT_SIZE(I) / 8_I4P
   ENDFUNCTION BYTE_SIZE_CHR

   ELEMENTAL FUNCTION BYTE_SIZE_I8P(I) RESULT(BYTES)
   !< COMPUTE THE NUMBER OF BYTES OF AN INTEGER VARIABLE.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT FI1P, BYTE_SIZE(1_I8P)
   !<```
   !=> 8 <<<
   INTEGER(I8P), INTENT(IN) :: I     !< INTEGER VARIABLE WHOSE NUMBER OF BYTES MUST BE COMPUTED.
   INTEGER(I1P)             :: BYTES !< NUMBER OF BYTES OF I.

   BYTES = BIT_SIZE(I) / 8_I1P
   ENDFUNCTION BYTE_SIZE_I8P

   ELEMENTAL FUNCTION BYTE_SIZE_I4P(I) RESULT(BYTES)
   !< COMPUTE THE NUMBER OF BYTES OF AN INTEGER VARIABLE.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT FI1P, BYTE_SIZE(1_I4P)
   !<```
   !=> 4 <<<
   INTEGER(I4P), INTENT(IN) :: I     !< INTEGER VARIABLE WHOSE NUMBER OF BYTES MUST BE COMPUTED.
   INTEGER(I1P)             :: BYTES !< NUMBER OF BYTES OF I.

   BYTES = BIT_SIZE(I) / 8_I1P
   ENDFUNCTION BYTE_SIZE_I4P

   ELEMENTAL FUNCTION BYTE_SIZE_I2P(I) RESULT(BYTES)
   !< COMPUTE THE NUMBER OF BYTES OF AN INTEGER VARIABLE.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT FI1P, BYTE_SIZE(1_I2P)
   !<```
   !=> 2 <<<
   INTEGER(I2P), INTENT(IN) :: I     !< INTEGER VARIABLE WHOSE NUMBER OF BYTES MUST BE COMPUTED.
   INTEGER(I1P)             :: BYTES !< NUMBER OF BYTES OF I.

   BYTES = BIT_SIZE(I) / 8_I1P
   ENDFUNCTION BYTE_SIZE_I2P

   ELEMENTAL FUNCTION BYTE_SIZE_I1P(I) RESULT(BYTES)
   !< COMPUTE THE NUMBER OF BYTES OF AN INTEGER VARIABLE.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT FI1P, BYTE_SIZE(1_I1P)
   !<```
   !=> 1 <<<
   INTEGER(I1P), INTENT(IN) :: I     !< INTEGER VARIABLE WHOSE NUMBER OF BYTES MUST BE COMPUTED.
   INTEGER(I1P)             :: BYTES !< NUMBER OF BYTES OF I.

   BYTES = BIT_SIZE(I) / 8_I1P
   ENDFUNCTION BYTE_SIZE_I1P
ENDMODULE PENF_B_SIZE


!< PENF STRING-TO-NUMBER (AND VICEVERSA) FACILITY.

MODULE PENF_STRINGIFY
!< PENF STRING-TO-NUMBER (AND VICEVERSA) FACILITY.
USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY : STDERR=>ERROR_UNIT
USE PENF_B_SIZE
USE PENF_GLOBAL_PARAMETERS_VARIABLES

IMPLICIT NONE
PRIVATE
SAVE
PUBLIC :: STR

INTERFACE STR
  !< CONVERT NUMBER (REAL AND INTEGER) TO STRING (NUMBER TO STRING TYPE CASTING).
  MODULE PROCEDURE                       &
                   STRF_R16P,STR_R16P,   &
                   STRF_R8P ,STR_R8P,    &
                   STRF_R4P ,STR_R4P,    &
                   STRF_I8P ,STR_I8P,    &
                   STRF_I4P ,STR_I4P,    &
                   STRF_I2P ,STR_I2P,    &
                   STRF_I1P ,STR_I1P,    &
                             STR_BOL,    &
                             STR_A_R16P, &
                             STR_A_R8P,  &
                             STR_A_R4P,  &
                             STR_A_I8P,  &
                             STR_A_I4P,  &
                             STR_A_I2P,  &
                             STR_A_I1P
ENDINTERFACE



CONTAINS

   ELEMENTAL FUNCTION STRF_R16P(FM, N) RESULT(STR)
   !< CONVERT REAL TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(FM=FR16P, N=1._R16P)
   !<```
   !=> 0.100000000000000000000000000000000E+0001 <<<
   CHARACTER(*), INTENT(IN) :: FM  !< FORMAT DIFFERENT FROM THE STANDARD FOR THE KIND.
   REAL(R16P),   INTENT(IN) :: N   !< REAL TO BE CONVERTED.
   CHARACTER(DR16P)         :: STR !< RETURNED STRING CONTAINING INPUT NUMBER.

   WRITE(STR, TRIM(FM)) N
   ENDFUNCTION STRF_R16P

   ELEMENTAL FUNCTION STRF_R8P(FM, N) RESULT(STR)
   !< CONVERT REAL TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(FM=FR8P, N=1._R8P)
   !<```
   !=> 0.100000000000000E+001 <<<
   CHARACTER(*), INTENT(IN) :: FM  !< FORMAT DIFFERENT FROM THE STANDARD FOR THE KIND.
   REAL(R8P),    INTENT(IN) :: N   !< REAL TO BE CONVERTED.
   CHARACTER(DR8P)          :: STR !< RETURNED STRING CONTAINING INPUT NUMBER.

   WRITE(STR, TRIM(FM)) N
   ENDFUNCTION STRF_R8P

   ELEMENTAL FUNCTION STRF_R4P(FM, N) RESULT(STR)
   !< CONVERT REAL TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(FM=FR4P, N=1._R4P)
   !<```
   !=> 0.100000E+01 <<<
   CHARACTER(*), INTENT(IN) :: FM  !< FORMAT DIFFERENT FROM THE STANDARD FOR THE KIND.
   REAL(R4P),    INTENT(IN) :: N   !< REAL TO BE CONVERTED.
   CHARACTER(DR4P)          :: STR !< RETURNED STRING CONTAINING INPUT NUMBER.

   WRITE(STR, TRIM(FM)) N
   ENDFUNCTION STRF_R4P

   ELEMENTAL FUNCTION STRF_I8P(FM, N) RESULT(STR)
   !< CONVERT INTEGER TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(FM=FI8P, N=1_I8P)
   !<```
   !=> 1 <<<
   CHARACTER(*), INTENT(IN) :: FM  !< FORMAT DIFFERENT FROM THE STANDARD FOR THE KIND.
   INTEGER(I8P), INTENT(IN) :: N   !< INTEGER TO BE CONVERTED.
   CHARACTER(DI8P)          :: STR !< RETURNED STRING CONTAINING INPUT NUMBER.

   WRITE(STR, TRIM(FM)) N
   ENDFUNCTION STRF_I8P

   ELEMENTAL FUNCTION STRF_I4P(FM, N) RESULT(STR)
   !< CONVERT INTEGER TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(FM=FI4P, N=1_I4P)
   !<```
   !=> 1 <<<
   CHARACTER(*), INTENT(IN) :: FM  !< FORMAT DIFFERENT FROM THE STANDARD FOR THE KIND.
   INTEGER(I4P), INTENT(IN) :: N   !< INTEGER TO BE CONVERTED.
   CHARACTER(DI4P)          :: STR !< RETURNED STRING CONTAINING INPUT NUMBER.

   WRITE(STR, TRIM(FM)) N
   ENDFUNCTION STRF_I4P

   ELEMENTAL FUNCTION STRF_I2P(FM, N) RESULT(STR)
   !< CONVERT INTEGER TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(FM=FI2P, N=1_I2P)
   !<```
   !=> 1 <<<
   CHARACTER(*), INTENT(IN) :: FM  !< FORMAT DIFFERENT FROM THE STANDARD FOR THE KIND.
   INTEGER(I2P), INTENT(IN) :: N   !< INTEGER TO BE CONVERTED.
   CHARACTER(DI2P)          :: STR !< RETURNED STRING CONTAINING INPUT NUMBER.

   WRITE(STR, TRIM(FM)) N
   ENDFUNCTION STRF_I2P

   ELEMENTAL FUNCTION STRF_I1P(FM, N) RESULT(STR)
   !< CONVERT INTEGER TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(FM=FI1P, N=1_I1P)
   !<```
   !=> 1 <<<
   CHARACTER(*), INTENT(IN) :: FM  !< FORMAT DIFFERENT FROM THE STANDARD FOR THE KIND.
   INTEGER(I1P), INTENT(IN) :: N   !< INTEGER TO BE CONVERTED.
   CHARACTER(DI1P)          :: STR !< RETURNED STRING CONTAINING INPUT NUMBER.

   WRITE(STR, TRIM(FM)) N
   ENDFUNCTION STRF_I1P

   ELEMENTAL FUNCTION STR_R16P(N, NO_SIGN, COMPACT) RESULT(STR)
   !< CONVERT REAL TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=-1._R16P)
   !<```
   !=> -0.100000000000000000000000000000000E+0001 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=-1._R16P, NO_SIGN=.TRUE.)
   !<```
   !=> 0.100000000000000000000000000000000E+0001 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=-1._R16P, COMPACT=.TRUE.)
   !<```
   !=> -0.1E+1 <<<
   REAL(R16P), INTENT(IN)           :: N       !< REAL TO BE CONVERTED.
   LOGICAL,    INTENT(IN), OPTIONAL :: NO_SIGN !< FLAG FOR LEAVING OUT THE SIGN.
   LOGICAL,    INTENT(IN), OPTIONAL :: COMPACT !< FLAG FOR *COMPACTING* STRING ENCODING.
   CHARACTER(DR16P)                 :: STR     !< RETURNED STRING CONTAINING INPUT NUMBER.

   WRITE(STR, FR16P) N               ! CASTING OF N TO STRING.
   IF (N>0._R16P) STR(1:1)='+'       ! PREFIXING PLUS IF N>0.
   IF (PRESENT(NO_SIGN)) STR=STR(2:) ! LEAVING OUT THE SIGN.
   IF (PRESENT(COMPACT)) THEN
     IF (COMPACT) CALL COMPACT_REAL_STRING(STRING=STR)
   ENDIF
   ENDFUNCTION STR_R16P

   ELEMENTAL FUNCTION STR_R8P(N, NO_SIGN, COMPACT) RESULT(STR)
   !< CONVERT REAL TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=-1._R8P)
   !<```
   !=> -0.100000000000000E+001 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=-1._R8P, NO_SIGN=.TRUE.)
   !<```
   !=> 0.100000000000000E+001 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=-1._R8P, COMPACT=.TRUE.)
   !<```
   !=> -0.1E+1 <<<
   REAL(R8P), INTENT(IN)           :: N       !< REAL TO BE CONVERTED.
   LOGICAL,   INTENT(IN), OPTIONAL :: NO_SIGN !< FLAG FOR LEAVING OUT THE SIGN.
   LOGICAL,   INTENT(IN), OPTIONAL :: COMPACT !< FLAG FOR *COMPACTING* STRING ENCODING.
   CHARACTER(DR8P)                 :: STR     !< RETURNED STRING CONTAINING INPUT NUMBER.

   WRITE(STR, FR8P) N                ! CASTING OF N TO STRING.
   IF (N>0._R8P) STR(1:1)='+'        ! PREFIXING PLUS IF N>0.
   IF (PRESENT(NO_SIGN)) STR=STR(2:) ! LEAVING OUT THE SIGN.
   IF (PRESENT(COMPACT)) THEN
     IF (COMPACT) CALL COMPACT_REAL_STRING(STRING=STR)
   ENDIF
   ENDFUNCTION STR_R8P

   ELEMENTAL FUNCTION STR_R4P(N, NO_SIGN, COMPACT) RESULT(STR)
   !< CONVERT REAL TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=-1._R4P)
   !<```
   !=> -0.100000E+01 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=-1._R4P, NO_SIGN=.TRUE.)
   !<```
   !=> 0.100000E+01 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=-1._R4P, COMPACT=.TRUE.)
   !<```
   !=> -0.1E+1 <<<
   REAL(R4P), INTENT(IN)           :: N       !< REAL TO BE CONVERTED.
   LOGICAL,   INTENT(IN), OPTIONAL :: NO_SIGN !< FLAG FOR LEAVING OUT THE SIGN.
   LOGICAL,   INTENT(IN), OPTIONAL :: COMPACT !< FLAG FOR *COMPACTING* STRING ENCODING.
   CHARACTER(DR4P)                 :: STR     !< RETURNED STRING CONTAINING INPUT NUMBER.

   WRITE(STR, FR4P) N                ! CASTING OF N TO STRING.
   IF (N>0._R4P) STR(1:1)='+'        ! PREFIXING PLUS IF N>0.
   IF (PRESENT(NO_SIGN)) STR=STR(2:) ! LEAVING OUT THE SIGN.
   IF (PRESENT(COMPACT)) THEN
     IF (COMPACT) CALL COMPACT_REAL_STRING(STRING=STR)
   ENDIF
   ENDFUNCTION STR_R4P

   ELEMENTAL FUNCTION STR_I8P(N, NO_SIGN) RESULT(STR)
   !< CONVERT INTEGER TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=-1_I8P)
   !<```
   !=> -1 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=-1_I8P, NO_SIGN=.TRUE.)
   !<```
   !=> 1 <<<
   INTEGER(I8P), INTENT(IN)           :: N       !< INTEGER TO BE CONVERTED.
   LOGICAL,      INTENT(IN), OPTIONAL :: NO_SIGN !< FLAG FOR LEAVING OUT THE SIGN.
   CHARACTER(DI8P)                    :: STR     !< RETURNED STRING CONTAINING INPUT NUMBER PLUS PADDING ZEROS.

   WRITE(STR, FI8P) N                ! CASTING OF N TO STRING.
   STR = ADJUSTL(TRIM(STR))          ! REMOVING WHITE SPACES.
   IF (N>=0_I8P) STR='+'//TRIM(STR)  ! PREFIXING PLUS IF N>0.
   IF (PRESENT(NO_SIGN)) STR=STR(2:) ! LEAVING OUT THE SIGN.
   ENDFUNCTION STR_I8P

   ELEMENTAL FUNCTION STR_I4P(N, NO_SIGN) RESULT(STR)
   !< CONVERTING INTEGER TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=-1_I4P)
   !<```
   !=> -1 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=-1_I4P, NO_SIGN=.TRUE.)
   !<```
   !=> 1 <<<
   INTEGER(I4P), INTENT(IN)           :: N       !< INTEGER TO BE CONVERTED.
   LOGICAL,      INTENT(IN), OPTIONAL :: NO_SIGN !< FLAG FOR LEAVING OUT THE SIGN.
   CHARACTER(DI4P)                    :: STR     !< RETURNED STRING CONTAINING INPUT NUMBER PLUS PADDING ZEROS.

   WRITE(STR, FI4P) N                ! CASTING OF N TO STRING.
   STR = ADJUSTL(TRIM(STR))          ! REMOVING WHITE SPACES.
   IF (N>=0_I4P) STR='+'//TRIM(STR)  ! PREFIXING PLUS IF N>0.
   IF (PRESENT(NO_SIGN)) STR=STR(2:) ! LEAVING OUT THE SIGN.
   ENDFUNCTION STR_I4P

   ELEMENTAL FUNCTION STR_I2P(N, NO_SIGN) RESULT(STR)
   !< CONVERT INTEGER TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=-1_I2P)
   !<```
   !=> -1 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=-1_I2P, NO_SIGN=.TRUE.)
   !<```
   !=> 1 <<<
   INTEGER(I2P), INTENT(IN)           :: N       !< INTEGER TO BE CONVERTED.
   LOGICAL,      INTENT(IN), OPTIONAL :: NO_SIGN !< FLAG FOR LEAVING OUT THE SIGN.
   CHARACTER(DI2P)                    :: STR     !< RETURNED STRING CONTAINING INPUT NUMBER PLUS PADDING ZEROS.

   WRITE(STR, FI2P) N                ! CASTING OF N TO STRING.
   STR = ADJUSTL(TRIM(STR))          ! REMOVING WHITE SPACES.
   IF (N>=0_I2P) STR='+'//TRIM(STR)  ! PREFIXING PLUS IF N>0.
   IF (PRESENT(NO_SIGN)) STR=STR(2:) ! LEAVING OUT THE SIGN.
   ENDFUNCTION STR_I2P

   ELEMENTAL FUNCTION STR_I1P(N, NO_SIGN) RESULT(STR)
   !< CONVERT INTEGER TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=-1_I1P)
   !<```
   !=> -1 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=-1_I1P, NO_SIGN=.TRUE.)
   !<```
   !=> 1 <<<
   INTEGER(I1P), INTENT(IN)           :: N       !< INTEGER TO BE CONVERTED.
   LOGICAL,      INTENT(IN), OPTIONAL :: NO_SIGN !< FLAG FOR LEAVING OUT THE SIGN.
   CHARACTER(DI1P)                    :: STR     !< RETURNED STRING CONTAINING INPUT NUMBER PLUS PADDING ZEROS.

   WRITE(STR, FI1P) N                ! CASTING OF N TO STRING.
   STR = ADJUSTL(TRIM(STR))          ! REMOVING WHITE SPACES.
   IF (N>=0_I1P) STR='+'//TRIM(STR)  ! PREFIXING PLUS IF N>0.
   IF (PRESENT(NO_SIGN)) STR=STR(2:) ! LEAVING OUT THE SIGN.
   ENDFUNCTION STR_I1P

   ELEMENTAL FUNCTION STR_BOL(N) RESULT(STR)
   !< CONVERT LOGICAL TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=.TRUE.)
   !<```
   !=> T <<<
   LOGICAL, INTENT(IN):: N   !< LOGICAL TO BE CONVERTED.
   CHARACTER(1)::        STR !< RETURNED STRING CONTAINING INPUT NUMBER PLUS PADDING ZEROS.

   WRITE(STR, '(L1)') N
   ENDFUNCTION STR_BOL

   PURE FUNCTION STR_A_R16P(N, NO_SIGN, SEPARATOR, DELIMITERS, COMPACT) RESULT(STR)
   !< CONVERTING REAL ARRAY TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1._R16P, -2._R16P])
   !<```
   !=> +0.100000000000000000000000000000000E+0001,-0.200000000000000000000000000000000E+0001 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1._R16P, 2._R16P], NO_SIGN=.TRUE.)
   !<```
   !=> 0.100000000000000000000000000000000E+0001,0.200000000000000000000000000000000E+0001 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1._R16P, -2._R16P], SEPARATOR='|')
   !<```
   !=> +0.100000000000000000000000000000000E+0001|-0.200000000000000000000000000000000E+0001 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1._R16P, -2._R16P], DELIMITERS=['(', ')'])
   !<```
   !=> (+0.100000000000000000000000000000000E+0001,-0.200000000000000000000000000000000E+0001) <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1._R16P, -2._R16P], COMPACT=.TRUE.)
   !<```
   !=> +0.1E+1,-0.2E+1 <<<
   REAL(R16P),   INTENT(IN)           :: N(:)            !< REAL ARRAY TO BE CONVERTED.
   LOGICAL,      INTENT(IN), OPTIONAL :: NO_SIGN         !< FLAG FOR LEAVING OUT THE SIGN.
   CHARACTER(1), INTENT(IN), OPTIONAL :: SEPARATOR       !< EVENTUAL SEPARATOR OF ARRAY VALUES.
   CHARACTER(*), INTENT(IN), OPTIONAL :: DELIMITERS(1:2) !< EVENTUAL DELIMITERS OF ARRAY VALUES.
   LOGICAL,      INTENT(IN), OPTIONAL :: COMPACT         !< FLAG FOR *COMPACTING* STRING ENCODING.
   CHARACTER(LEN=:), ALLOCATABLE      :: STR             !< RETURNED STRING CONTAINING INPUT NUMBER.
   CHARACTER(DR16P)                   :: STRN            !< STRING CONTAINING OF ELEMENT OF INPUT ARRAY NUMBER.
   CHARACTER(LEN=1)                   :: SEP             !< ARRAY VALUES SEPARATOR
   INTEGER                            :: I               !< COUNTER.

   STR = ''
   SEP = ','
   IF(PRESENT(SEPARATOR)) SEP = SEPARATOR
   DO I=1,SIZE(N)
     STRN = STR_R16P(NO_SIGN=NO_SIGN, COMPACT=COMPACT, N=N(I))
     STR = STR//SEP//TRIM(STRN)
   ENDDO
   STR = TRIM(STR(2:))
   IF (PRESENT(DELIMITERS)) STR = DELIMITERS(1)//STR//DELIMITERS(2)
   ENDFUNCTION STR_A_R16P

   PURE FUNCTION STR_A_R8P(N, NO_SIGN, SEPARATOR, DELIMITERS, COMPACT) RESULT(STR)
   !< CONVERT REAL ARRAY TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1._R8P, -2._R8P])
   !<```
   !=> +0.100000000000000E+001,-0.200000000000000E+001 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1._R8P, 2._R8P], NO_SIGN=.TRUE.)
   !<```
   !=> 0.100000000000000E+001,0.200000000000000E+001 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1._R8P, -2._R8P], SEPARATOR='|')
   !<```
   !=> +0.100000000000000E+001|-0.200000000000000E+001 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1._R8P, -2._R8P], DELIMITERS=['(', ')'])
   !<```
   !=> (+0.100000000000000E+001,-0.200000000000000E+001) <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1._R8P, -2._R8P], COMPACT=.TRUE.)
   !<```
   !=> +0.1E+1,-0.2E+1 <<<
   REAL(R8P),    INTENT(IN)           :: N(:)            !< REAL ARRAY TO BE CONVERTED.
   LOGICAL,      INTENT(IN), OPTIONAL :: NO_SIGN         !< FLAG FOR LEAVING OUT THE SIGN.
   CHARACTER(1), INTENT(IN), OPTIONAL :: SEPARATOR       !< EVENTUAL SEPARATOR OF ARRAY VALUES.
   CHARACTER(*), INTENT(IN), OPTIONAL :: DELIMITERS(1:2) !< EVENTUAL DELIMITERS OF ARRAY VALUES.
   LOGICAL,      INTENT(IN), OPTIONAL :: COMPACT         !< FLAG FOR *COMPACTING* STRING ENCODING.
   CHARACTER(LEN=:), ALLOCATABLE      :: STR             !< RETURNED STRING CONTAINING INPUT NUMBER.
   CHARACTER(DR8P)                    :: STRN            !< STRING CONTAINING OF ELEMENT OF INPUT ARRAY NUMBER.
   CHARACTER(LEN=1)                   :: SEP             !< ARRAY VALUES SEPARATOR
   INTEGER                            :: I               !< COUNTER.

   STR = ''
   SEP = ','
   IF(PRESENT(SEPARATOR)) SEP = SEPARATOR
   DO I=1,SIZE(N)
     STRN = STR_R8P(NO_SIGN=NO_SIGN, COMPACT=COMPACT, N=N(I))
     STR = STR//SEP//TRIM(STRN)
   ENDDO
   STR = TRIM(STR(2:))
   IF (PRESENT(DELIMITERS)) STR = DELIMITERS(1)//STR//DELIMITERS(2)
   ENDFUNCTION STR_A_R8P

   PURE FUNCTION STR_A_R4P(N, NO_SIGN, SEPARATOR, DELIMITERS, COMPACT) RESULT(STR)
   !< CONVERT REAL ARRAY TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1._R4P, -2._R4P])
   !<```
   !=> +0.100000E+01,-0.200000E+01 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1._R4P, 2._R4P], NO_SIGN=.TRUE.)
   !<```
   !=> 0.100000E+01,0.200000E+01 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1._R4P, -2._R4P], SEPARATOR='|')
   !<```
   !=> +0.100000E+01|-0.200000E+01 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1._R4P, -2._R4P], DELIMITERS=['(', ')'])
   !<```
   !=> (+0.100000E+01,-0.200000E+01) <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1._R4P, -2._R4P], COMPACT=.TRUE.)
   !<```
   !=> +0.1E+1,-0.2E+1 <<<
   REAL(R4P),    INTENT(IN)           :: N(:)            !< REAL ARRAY TO BE CONVERTED.
   LOGICAL,      INTENT(IN), OPTIONAL :: NO_SIGN         !< FLAG FOR LEAVING OUT THE SIGN.
   CHARACTER(1), INTENT(IN), OPTIONAL :: SEPARATOR       !< EVENTUAL SEPARATOR OF ARRAY VALUES.
   CHARACTER(*), INTENT(IN), OPTIONAL :: DELIMITERS(1:2) !< EVENTUAL DELIMITERS OF ARRAY VALUES.
   LOGICAL,      INTENT(IN), OPTIONAL :: COMPACT         !< FLAG FOR *COMPACTING* STRING ENCODING.
   CHARACTER(LEN=:), ALLOCATABLE      :: STR             !< RETURNED STRING CONTAINING INPUT NUMBER.
   CHARACTER(DR4P)                    :: STRN            !< STRING CONTAINING OF ELEMENT OF INPUT ARRAY NUMBER.
   CHARACTER(LEN=1)                   :: SEP             !< ARRAY VALUES SEPARATOR
   INTEGER                            :: I               !< COUNTER.

   STR = ''
   SEP = ','
   IF(PRESENT(SEPARATOR)) SEP = SEPARATOR
   DO I=1,SIZE(N)
     STRN = STR_R4P(NO_SIGN=NO_SIGN, COMPACT=COMPACT, N=N(I))
     STR = STR//SEP//TRIM(STRN)
   ENDDO
   STR = TRIM(STR(2:))
   IF (PRESENT(DELIMITERS)) STR = DELIMITERS(1)//STR//DELIMITERS(2)
   ENDFUNCTION STR_A_R4P

   PURE FUNCTION STR_A_I8P(N, NO_SIGN, SEPARATOR, DELIMITERS) RESULT(STR)
   !< CONVERT INTEGER ARRAY TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1_I8P, -2_I8P])
   !<```
   !=> +1,-2 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1_I8P, 2_I8P], NO_SIGN=.TRUE.)
   !<```
   !=> 1,2 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1_I8P, -2_I8P], SEPARATOR='|')
   !<```
   !=> +1|-2 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1_I8P, -2_I8P], DELIMITERS=['(', ')'])
   !<```
   !=> (+1,-2) <<<
   INTEGER(I8P), INTENT(IN)           :: N(:)            !< INTEGER ARRAY TO BE CONVERTED.
   LOGICAL,      INTENT(IN), OPTIONAL :: NO_SIGN         !< FLAG FOR LEAVING OUT THE SIGN.
   CHARACTER(1), INTENT(IN), OPTIONAL :: SEPARATOR       !< EVENTUAL SEPARATOR OF ARRAY VALUES.
   CHARACTER(*), INTENT(IN), OPTIONAL :: DELIMITERS(1:2) !< EVENTUAL DELIMITERS OF ARRAY VALUES.
   CHARACTER(LEN=:), ALLOCATABLE      :: STR             !< RETURNED STRING CONTAINING INPUT NUMBER.
   CHARACTER(DI8P)                    :: STRN            !< STRING CONTAINING OF ELEMENT OF INPUT ARRAY NUMBER.
   CHARACTER(LEN=1)                   :: SEP             !< ARRAY VALUES SEPARATOR
   INTEGER                            :: I               !< COUNTER.

   STR = ''
   SEP = ','
   IF(PRESENT(SEPARATOR)) SEP = SEPARATOR
   IF (PRESENT(NO_SIGN)) THEN
     DO I=1,SIZE(N)
       STRN = STR_I8P(NO_SIGN=NO_SIGN, N=N(I))
       STR = STR//SEP//TRIM(STRN)
     ENDDO
   ELSE
     DO I=1,SIZE(N)
       STRN = STR_I8P(N=N(I))
       STR = STR//SEP//TRIM(STRN)
     ENDDO
   ENDIF
   STR = TRIM(STR(2:))
   IF (PRESENT(DELIMITERS)) STR = DELIMITERS(1)//STR//DELIMITERS(2)
   ENDFUNCTION STR_A_I8P

   PURE FUNCTION STR_A_I4P(N, NO_SIGN, SEPARATOR, DELIMITERS) RESULT(STR)
   !< CONVERT INTEGER ARRAY TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1_I4P, -2_I4P])
   !<```
   !=> +1,-2 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1_I4P, 2_I4P], NO_SIGN=.TRUE.)
   !<```
   !=> 1,2 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1_I4P, -2_I4P], SEPARATOR='|')
   !<```
   !=> +1|-2 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1_I4P, -2_I4P], DELIMITERS=['(', ')'])
   !<```
   !=> (+1,-2) <<<
   INTEGER(I4P), INTENT(IN)           :: N(:)            !< INTEGER ARRAY TO BE CONVERTED.
   LOGICAL,      INTENT(IN), OPTIONAL :: NO_SIGN         !< FLAG FOR LEAVING OUT THE SIGN.
   CHARACTER(1), INTENT(IN), OPTIONAL :: SEPARATOR       !< EVENTUAL SEPARATOR OF ARRAY VALUES.
   CHARACTER(*), INTENT(IN), OPTIONAL :: DELIMITERS(1:2) !< EVENTUAL DELIMITERS OF ARRAY VALUES.
   CHARACTER(LEN=:), ALLOCATABLE      :: STR             !< RETURNED STRING CONTAINING INPUT NUMBER.
   CHARACTER(DI4P)                    :: STRN            !< STRING CONTAINING OF ELEMENT OF INPUT ARRAY NUMBER.
   CHARACTER(LEN=1)                   :: SEP             !< ARRAY VALUES SEPARATOR
   INTEGER                            :: I               !< COUNTER.

   STR = ''
   SEP = ','
   IF(PRESENT(SEPARATOR)) SEP = SEPARATOR
   IF (PRESENT(NO_SIGN)) THEN
     DO I=1,SIZE(N)
       STRN = STR_I4P(NO_SIGN=NO_SIGN, N=N(I))
       STR = STR//SEP//TRIM(STRN)
     ENDDO
   ELSE
     DO I=1,SIZE(N)
       STRN = STR_I4P(N=N(I))
       STR = STR//SEP//TRIM(STRN)
     ENDDO
   ENDIF
   STR = TRIM(STR(2:))
   IF (PRESENT(DELIMITERS)) STR = DELIMITERS(1)//STR//DELIMITERS(2)
   ENDFUNCTION STR_A_I4P

   PURE FUNCTION STR_A_I2P(N, NO_SIGN, SEPARATOR, DELIMITERS) RESULT(STR)
   !< CONVERT INTEGER ARRAY TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1_I2P, -2_I2P])
   !<```
   !=> +1,-2 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1_I2P, 2_I2P], NO_SIGN=.TRUE.)
   !<```
   !=> 1,2 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1_I2P, -2_I2P], SEPARATOR='|')
   !<```
   !=> +1|-2 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1_I2P, -2_I2P], DELIMITERS=['(', ')'])
   !<```
   !=> (+1,-2) <<<
   INTEGER(I2P), INTENT(IN)           :: N(:)            !< INTEGER ARRAY TO BE CONVERTED.
   LOGICAL,      INTENT(IN), OPTIONAL :: NO_SIGN         !< FLAG FOR LEAVING OUT THE SIGN.
   CHARACTER(1), INTENT(IN), OPTIONAL :: SEPARATOR       !< EVENTUAL SEPARATOR OF ARRAY VALUES.
   CHARACTER(*), INTENT(IN), OPTIONAL :: DELIMITERS(1:2) !< EVENTUAL DELIMITERS OF ARRAY VALUES.
   CHARACTER(LEN=:), ALLOCATABLE      :: STR             !< RETURNED STRING CONTAINING INPUT NUMBER.
   CHARACTER(DI2P)                    :: STRN            !< STRING CONTAINING OF ELEMENT OF INPUT ARRAY NUMBER.
   CHARACTER(LEN=1)                   :: SEP             !< ARRAY VALUES SEPARATOR
   INTEGER                            :: I               !< COUNTER.

   STR = ''
   SEP = ','
   IF(PRESENT(SEPARATOR)) SEP = SEPARATOR
   IF (PRESENT(NO_SIGN)) THEN
     DO I=1,SIZE(N)
       STRN = STR_I2P(NO_SIGN=NO_SIGN, N=N(I))
       STR = STR//SEP//TRIM(STRN)
     ENDDO
   ELSE
     DO I=1,SIZE(N)
       STRN = STR_I2P(N=N(I))
       STR = STR//SEP//TRIM(STRN)
     ENDDO
   ENDIF
   STR = TRIM(STR(2:))
   IF (PRESENT(DELIMITERS)) STR = DELIMITERS(1)//STR//DELIMITERS(2)
   ENDFUNCTION STR_A_I2P

   PURE FUNCTION STR_A_I1P(N, NO_SIGN, SEPARATOR, DELIMITERS) RESULT(STR)
   !< CONVERT INTEGER ARRAY TO STRING.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1_I1P, -2_I1P])
   !<```
   !=> +1,-2 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1_I1P, 2_I1P], NO_SIGN=.TRUE.)
   !<```
   !=> 1,2 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1_I1P, -2_I1P], SEPARATOR='|')
   !<```
   !=> +1|-2 <<<
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT "(A)", STR(N=[1_I1P, -2_I1P], DELIMITERS=['(', ')'])
   !<```
   !=> (+1,-2) <<<
   INTEGER(I1P), INTENT(IN)           :: N(:)            !< INTEGER ARRAY TO BE CONVERTED.
   LOGICAL,      INTENT(IN), OPTIONAL :: NO_SIGN         !< FLAG FOR LEAVING OUT THE SIGN.
   CHARACTER(1), INTENT(IN), OPTIONAL :: SEPARATOR       !< EVENTUAL SEPARATOR OF ARRAY VALUES.
   CHARACTER(*), INTENT(IN), OPTIONAL :: DELIMITERS(1:2) !< EVENTUAL DELIMITERS OF ARRAY VALUES.
   CHARACTER(LEN=:), ALLOCATABLE      :: STR             !< RETURNED STRING CONTAINING INPUT NUMBER.
   CHARACTER(DI1P)                    :: STRN            !< STRING CONTAINING OF ELEMENT OF INPUT ARRAY NUMBER.
   CHARACTER(LEN=1)                   :: SEP             !< ARRAY VALUES SEPARATOR
   INTEGER                            :: I               !< COUNTER.

   STR = ''
   SEP = ','
   IF(PRESENT(SEPARATOR)) SEP = SEPARATOR
   IF (PRESENT(NO_SIGN)) THEN
     DO I=1,SIZE(N)
       STRN = STR_I1P(NO_SIGN=NO_SIGN, N=N(I))
       STR = STR//SEP//TRIM(STRN)
     ENDDO
   ELSE
     DO I=1,SIZE(N)
       STRN = STR_I1P(N=N(I))
       STR = STR//SEP//TRIM(STRN)
     ENDDO
   ENDIF
   STR = TRIM(STR(2:))
   IF (PRESENT(DELIMITERS)) STR = DELIMITERS(1)//STR//DELIMITERS(2)
   ENDFUNCTION STR_A_I1P

   PURE SUBROUTINE COMPACT_REAL_STRING(STRING)
   !< AUTHOR: IZAAK BEEKMAN
   !< DATE: 02/24/2015
   !<
   !< COMPACT A STRING REPRESENTING A REAL NUMBER, SO THAT THE SAME VALUE IS DISPLAYED WITH FEWER CHARACTERS.
   !<
   !< @NOTE NO NEED TO ADD DOCTEST: THIS IS TESTED BY A LOT OF DOCTESTS OF OTHER TBPS.
   CHARACTER(LEN=*),INTENT(INOUT) :: STRING      !< STRING REPRESENTATION OF A REAL NUMBER.
   CHARACTER(LEN=LEN(STRING))     :: SIGNIFICAND !< SIGNIFICAND CHARACTERS.
   CHARACTER(LEN=LEN(STRING))     :: EXPNT       !< EXPONENT CHARACTERS.
   CHARACTER(LEN=2)               :: SEPARATOR   !< SEPARATOR CHARACTERS.
   INTEGER(I4P)                   :: EXP_START   !< START POSITION OF EXPONENT.
   INTEGER(I4P)                   :: DECIMAL_POS !< DECIMAL POSITIONS.
   INTEGER(I4P)                   :: SIG_TRIM    !< SIGNATURE TRIM.
   INTEGER(I4P)                   :: EXP_TRIM    !< EXPONENT TRIM.
   INTEGER(I4P)                   :: I           !< COUNTER

   STRING = ADJUSTL(STRING)
   EXP_START = SCAN(STRING, 'EEDD')
   IF (EXP_START == 0) EXP_START = SCAN(STRING, '-+', BACK=.TRUE.)
   DECIMAL_POS = SCAN(STRING, '.')
   IF (EXP_START /= 0) SEPARATOR = STRING(EXP_START:EXP_START)
   IF ( EXP_START < DECIMAL_POS ) THEN ! POSSIBLY SIGNED, EXPONENT-LESS FLOAT
     SIGNIFICAND = STRING
     SIG_TRIM = LEN(TRIM(SIGNIFICAND))
     DO I = LEN(TRIM(SIGNIFICAND)), DECIMAL_POS+2, -1 ! LOOK FROM RIGHT TO LEFT AT 0S, BUT SAVE ONE AFTER THE DECIMAL PLACE
       IF (SIGNIFICAND(I:I) == '0') THEN
         SIG_TRIM = I-1
       ELSE
         EXIT
       ENDIF
     ENDDO
     STRING = TRIM(SIGNIFICAND(1:SIG_TRIM))
   ELSEIF (EXP_START > DECIMAL_POS) THEN ! FLOAT HAS EXPONENT
     SIGNIFICAND = STRING(1:EXP_START-1)
     SIG_TRIM = LEN(TRIM(SIGNIFICAND))
     DO I = LEN(TRIM(SIGNIFICAND)),DECIMAL_POS+2,-1 ! LOOK FROM RIGHT TO LEFT AT 0S
       IF (SIGNIFICAND(I:I) == '0') THEN
         SIG_TRIM = I-1
       ELSE
         EXIT
       ENDIF
     ENDDO
     EXPNT = ADJUSTL(STRING(EXP_START+1:))
     IF (EXPNT(1:1) == '+' .OR. EXPNT(1:1) == '-') THEN
       SEPARATOR = TRIM(ADJUSTL(SEPARATOR))//EXPNT(1:1)
       EXP_START = EXP_START + 1
       EXPNT     = ADJUSTL(STRING(EXP_START+1:))
     ENDIF
     EXP_TRIM = 1
     DO I = 1,(LEN(TRIM(EXPNT))-1) ! LOOK AT EXPONENT LEADING ZEROS SAVING LAST
       IF (EXPNT(I:I) == '0') THEN
         EXP_TRIM = I+1
       ELSE
         EXIT
       ENDIF
     ENDDO
     STRING = TRIM(ADJUSTL(SIGNIFICAND(1:SIG_TRIM)))// &
              TRIM(ADJUSTL(SEPARATOR))// &
              TRIM(ADJUSTL(EXPNT(EXP_TRIM:)))
   !ELSE ! MAL-FORMED REAL, BUT THIS CODE SHOULD BE UNREACHABLE
   ENDIF
   ENDSUBROUTINE COMPACT_REAL_STRING


ENDMODULE PENF_STRINGIFY


!< PORTABILITY ENVIRONMENT FOR FORTRAN POOR PEOPLE.

MODULE PENF
!< PORTABILITY ENVIRONMENT FOR FORTRAN POOR PEOPLE.
USE PENF_GLOBAL_PARAMETERS_VARIABLES
#ifdef __INTEL_COMPILER
USE PENF_B_SIZE
#else
USE PENF_B_SIZE, ONLY : BIT_SIZE, BYTE_SIZE
#endif
USE PENF_STRINGIFY, ONLY : STR

IMPLICIT NONE
PRIVATE
SAVE
! GLOBAL PARAMETERS AND VARIABLES
PUBLIC :: ENDIANL, ENDIANB, ENDIAN, IS_INITIALIZED
PUBLIC :: ASCII, UCS4, CK
PUBLIC :: R16P, FR16P, DR16P, MINR16P, MAXR16P, BIR16P, BYR16P, SMALLR16P, ZEROR16P
PUBLIC :: R8P,  FR8P,  DR8P,  MINR8P,  MAXR8P,  BIR8P,  BYR8P,  SMALLR8P,  ZEROR8P
PUBLIC :: R4P,  FR4P,  DR4P,  MINR4P,  MAXR4P,  BIR4P,  BYR4P,  SMALLR4P,  ZEROR4P
PUBLIC :: R_P,  FR_P,  DR_P,  MINR_P,  MAXR_P,  BIR_P,  BYR_P,  SMALLR_P,  ZEROR_P
PUBLIC :: I8P,  FI8P,  DI8P,  MINI8P,  MAXI8P,  BII8P,  BYI8P
PUBLIC :: I4P,  FI4P,  DI4P,  MINI4P,  MAXI4P,  BII4P,  BYI4P
PUBLIC :: I2P,  FI2P,  DI2P,  MINI2P,  MAXI2P,  BII2P,  BYI2P
PUBLIC :: I1P,  FI1P,  DI1P,  MINI1P,  MAXI1P,  BII1P,  BYI1P
PUBLIC :: I_P,  FI_P,  DI_P,  MINI_P,  MAXI_P,  BII_P,  BYI_P
PUBLIC :: CHARACTER_KINDS_LIST, REAL_KINDS_LIST, REAL_FORMATS_LIST
PUBLIC :: INTEGER_KINDS_LIST, INTEGER_FORMATS_LIST
! BIT/BYTE SIZE FUNCTIONS
PUBLIC :: BIT_SIZE, BYTE_SIZE
! STRINGIFY FACILITY
PUBLIC :: STR
! MISCELLANEA FACILITY
PUBLIC :: CHECK_ENDIAN
PUBLIC :: DIGIT
PUBLIC :: PENF_INIT
PUBLIC :: PENF_PRINT

INTEGER, PROTECTED :: ENDIAN         = ENDIANL !< BIT ORDERING: LITTLE ENDIAN (ENDIANL), OR BIG ENDIAN (ENDIANB).
LOGICAL, PROTECTED :: IS_INITIALIZED = .FALSE. !< CHECK THE INITIALIZATION OF SOME VARIABLES THAT MUST BE INITIALIZED.

#ifdef __GFORTRAN__
! WORK-AROUND FOR STRANGE GFORTRAN BUG...
INTERFACE BIT_SIZE
  !< OVERLOADING OF THE INTRINSIC *BIT_SIZE* FUNCTION FOR COMPUTING THE NUMBER OF BITS OF (ALSO) REAL AND CHARACTER VARIABLES.
ENDINTERFACE
#endif

INTERFACE DIGIT
  !< COMPUTE THE NUMBER OF DIGITS IN DECIMAL BASE OF THE INPUT INTEGER.
  MODULE PROCEDURE DIGIT_I8, DIGIT_I4, DIGIT_I2, DIGIT_I1
ENDINTERFACE

CONTAINS
   ! PUBLIC PROCEDURES
   SUBROUTINE CHECK_ENDIAN()
   !< CHECK THE TYPE OF BIT ORDERING (BIG OR LITTLE ENDIAN) OF THE RUNNING ARCHITECTURE.
   !<
   !> @NOTE THE RESULT IS STORED INTO THE *ENDIAN* GLOBAL VARIABLE.
   !<
   !<```FORTRAN
   !< USE PENF
   !< CALL CHECK_ENDIAN
   !< PRINT *, ENDIAN
   !<```
   !=> 1 <<<
   IF (IS_LITTLE_ENDIAN()) THEN
      ENDIAN = ENDIANL
   ELSE
      ENDIAN = ENDIANB
   ENDIF
   CONTAINS
      PURE FUNCTION IS_LITTLE_ENDIAN() RESULT(IS_LITTLE)
      !< CHECK IF THE TYPE OF THE BIT ORDERING OF THE RUNNING ARCHITECTURE IS LITTLE ENDIAN.
      LOGICAL      :: IS_LITTLE !< LOGICAL OUTPUT: TRUE IS THE RUNNING ARCHITECTURE USES LITTLE ENDIAN ORDERING, FALSE OTHERWISE.
      INTEGER(I1P) :: INT1(1:4) !< ONE BYTE INTEGER ARRAY FOR CASTING 4 BYTES INTEGER.

      INT1 = TRANSFER(1_I4P, INT1)
      IS_LITTLE = (INT1(1)==1_I1P)
      ENDFUNCTION IS_LITTLE_ENDIAN
   ENDSUBROUTINE CHECK_ENDIAN

   SUBROUTINE PENF_INIT()
   !< INITIALIZE PENF'S VARIABLES THAT ARE NOT INITIALIZED INTO THE DEFINITION SPECIFICATION.
   !<
   !<```FORTRAN
   !< USE PENF
   !< CALL PENF_INIT
   !< PRINT FI1P, BYR4P
   !<```
   !=> 4 <<<

   CALL CHECK_ENDIAN
   BIR16P = BIT_SIZE(MAXR16P) ; BYR16P = BIR16P / 8_I2P
   BIR8P  = BIT_SIZE(MAXR8P)  ; BYR8P  = BIR8P  / 8_I1P
   BIR4P  = BIT_SIZE(MAXR4P)  ; BYR4P  = BIR4P  / 8_I1P
   BIR_P  = BIT_SIZE(MAXR_P)  ; BYR_P  = BIR_P  / 8_I1P
   IS_INITIALIZED = .TRUE.
   ENDSUBROUTINE PENF_INIT

   SUBROUTINE PENF_PRINT(UNIT, PREF, IOSTAT, IOMSG)
   !< PRINT TO THE SPECIFIED UNIT THE PENF'S ENVIRONMENT DATA.
   !<
   !<```FORTRAN
   !< USE PENF
   !< INTEGER :: U
   !< OPEN(NEWUNIT=U, STATUS='SCRATCH')
   !< CALL PENF_PRINT(U)
   !< CLOSE(U)
   !< PRINT "(A)", 'DONE'
   !<```
   !=> DONE <<<
   INTEGER(I4P), INTENT(IN)            :: UNIT    !< LOGIC UNIT.
   CHARACTER(*), INTENT(IN),  OPTIONAL :: PREF    !< PREFIXING STRING.
   INTEGER(I4P), INTENT(OUT), OPTIONAL :: IOSTAT  !< IO ERROR.
   CHARACTER(*), INTENT(OUT), OPTIONAL :: IOMSG   !< IO ERROR MESSAGE.
   CHARACTER(LEN=:), ALLOCATABLE       :: PREFD   !< PREFIXING STRING.
   INTEGER(I4P)                        :: IOSTATD !< IO ERROR.
   CHARACTER(500)                      :: IOMSGD  !< TEMPORARY VARIABLE FOR IO ERROR MESSAGE.

   IF (.NOT.IS_INITIALIZED) CALL PENF_INIT
   PREFD = '' ; IF (PRESENT(PREF)) PREFD = PREF
   IF (ENDIAN==ENDIANL) THEN
     WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)PREFD//'THIS ARCHITECTURE HAS LITTLE ENDIAN BIT ORDERING'
   ELSE
     WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)PREFD//'THIS ARCHITECTURE HAS BIG ENDIAN BIT ORDERING'
   ENDIF
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'CHARACTER KIND:'
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  ASCII: '//STR(N=ASCII)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  UCS4:  '//STR(N=UCS4)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  CK:    '//STR(N=CK)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'REALS KIND, FORMAT AND CHARACTERS NUMBER:'
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  R16P: '//STR(N=R16P)//','//FR16P//','//STR(N=DR16P)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  R8P:  '//STR(N=R8P )//','//FR8P //','//STR(N=DR8P )
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  R4P:  '//STR(N=R4P )//','//FR4P //','//STR(N=DR4P )
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  R_P:  '//STR(N=R_P )//','//FR_P //','//STR(N=DR_P )
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'IntEGERS KIND, FORMAT AND CHARACTERS NUMBER:'
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  I8P:  '//STR(N=I8P)//','//FI8P //','//STR(N=DI8P)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  I4P:  '//STR(N=I4P)//','//FI4P //','//STR(N=DI4P)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  I2P:  '//STR(N=I2P)//','//FI2P //','//STR(N=DI2P)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  I1P:  '//STR(N=I1P)//','//FI1P //','//STR(N=DI1P)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'REALS MINIMUM AND MAXIMUM VALUES:'
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  R16P: '//STR(N=MINR16P)//','//STR(N=MAXR16P)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  R8P:  '//STR(N=MINR8P )//','//STR(N=MAXR8P )
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  R4P:  '//STR(N=MINR4P )//','//STR(N=MAXR4P )
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  R_P:  '//STR(N=MINR_P )//','//STR(N=MAXR_P )
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'IntEGERGS MINIMUM AND MAXIMUM VALUES:'
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  I8P:  '//STR(N=MINI8P )//','//STR(N=MAXI8P)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  I4P:  '//STR(N=MINI4P )//','//STR(N=MAXI4P)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  I2P:  '//STR(N=MINI2P )//','//STR(N=MAXI2P)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  I1P:  '//STR(N=MINI1P )//','//STR(N=MAXI1P)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'REALS BITS/BYTES SIZES:'
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  R16P: '//STR(N=BIR16P)//'/'//STR(N=BYR16P)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  R8P:  '//STR(N=BIR8P )//'/'//STR(N=BYR8P )
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  R4P:  '//STR(N=BIR4P )//'/'//STR(N=BYR4P )
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  R_P:  '//STR(N=BIR_P )//'/'//STR(N=BYR_P )
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'IntEGERS BITS/BYTES SIZES:'
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  I8P:  '//STR(N=BII8P)//'/'//STR(N=BYI8P)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  I4P:  '//STR(N=BII4P)//'/'//STR(N=BYI4P)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  I2P:  '//STR(N=BII2P)//'/'//STR(N=BYI2P)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  I1P:  '//STR(N=BII1P)//'/'//STR(N=BYI1P)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'SMALLEST REALS'
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  SMALLR16P: '//STR(SMALLR16P, .TRUE.)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  SMALLR8P:  '//STR(SMALLR8P,  .TRUE.)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  SMALLR4P:  '//STR(SMALLR4P,  .TRUE.)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  SMALLR_P:  '//STR(SMALLR_P,  .TRUE.)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'MACHINE ZERO'
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  ZEROR16P: '//STR(ZEROR16P, .TRUE.)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  ZEROR8P:  '//STR(ZEROR8P,  .TRUE.)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  ZEROR4P:  '//STR(ZEROR4P,  .TRUE.)
   WRITE(UNIT=UNIT,FMT='(A)',IOSTAT=IOSTATD,IOMSG=IOMSGD)  PREFD//'  ZEROR_P:  '//STR(ZEROR_P,  .TRUE.)
   IF (PRESENT(IOSTAT)) IOSTAT = IOSTATD
   IF (PRESENT(IOMSG))  IOMSG  = IOMSGD
   ENDSUBROUTINE PENF_PRINT

   ! PRIVATE PROCEDURES
   ELEMENTAL FUNCTION DIGIT_I8(N) RESULT(DIGIT)
   !< COMPUTE THE NUMBER OF DIGITS IN DECIMAL BASE OF THE INPUT INTEGER.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT FI4P, DIGIT(100_I8P)
   !<```
   !=> 3 <<<
   INTEGER(I8P), INTENT(IN) :: N     !< INPUT INTEGER.
   CHARACTER(DI8P)          :: STR   !< RETURNED STRING CONTAINING INPUT NUMBER PLUS PADDING ZEROS.
   INTEGER(I4P)             :: DIGIT !< NUMBER OF DIGITS.

   WRITE(STR, FI8P) ABS(N)        ! CASTING OF N TO STRING.
   DIGIT = LEN_TRIM(ADJUSTL(STR)) ! CALCULATING THE DIGITS NUMBER OF N.
   ENDFUNCTION DIGIT_I8

   ELEMENTAL FUNCTION DIGIT_I4(N) RESULT(DIGIT)
   !< COMPUTE THE NUMBER OF DIGITS IN DECIMAL BASE OF THE INPUT INTEGER.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT FI4P, DIGIT(100_I4P)
   !<```
   !=> 3 <<<
   INTEGER(I4P), INTENT(IN) :: N     !< INPUT INTEGER.
   CHARACTER(DI4P)          :: STR   !< RETURNED STRING CONTAINING INPUT NUMBER PLUS PADDING ZEROS.
   INTEGER(I4P)             :: DIGIT !< NUMBER OF DIGITS.

   WRITE(STR, FI4P) ABS(N)        ! CASTING OF N TO STRING.
   DIGIT = LEN_TRIM(ADJUSTL(STR)) ! CALCULATING THE DIGITS NUMBER OF N.
   ENDFUNCTION DIGIT_I4

   ELEMENTAL FUNCTION DIGIT_I2(N) RESULT(DIGIT)
   !< COMPUTE THE NUMBER OF DIGITS IN DECIMAL BASE OF THE INPUT INTEGER.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT FI4P, DIGIT(100_I2P)
   !<```
   !=> 3 <<<
   INTEGER(I2P), INTENT(IN) :: N     !< INPUT INTEGER.
   CHARACTER(DI2P)          :: STR   !< RETURNED STRING CONTAINING INPUT NUMBER PLUS PADDING ZEROS.
   INTEGER(I4P)             :: DIGIT !< NUMBER OF DIGITS.

   WRITE(STR, FI2P) ABS(N)        ! CASTING OF N TO STRING.
   DIGIT = LEN_TRIM(ADJUSTL(STR)) ! CALCULATING THE DIGITS NUMBER OF N.
   ENDFUNCTION DIGIT_I2

   ELEMENTAL FUNCTION DIGIT_I1(N) RESULT(DIGIT)
   !< COMPUTE THE NUMBER OF DIGITS IN DECIMAL BASE OF THE INPUT INTEGER.
   !<
   !<```FORTRAN
   !< USE PENF
   !< PRINT FI4P, DIGIT(100_I1P)
   !<```
   !=> 3 <<<
   INTEGER(I1P), INTENT(IN) :: N     !< INPUT INTEGER.
   CHARACTER(DI1P)          :: STR   !< RETURNED STRING CONTAINING INPUT NUMBER PLUS PADDING ZEROS.
   INTEGER(I4P)             :: DIGIT !< NUMBER OF DIGITS.

   WRITE(STR, FI1P) ABS(N)        ! CASTING OF N TO STRING.
   DIGIT = LEN_TRIM(ADJUSTL(STR)) ! CALCULATING THE DIGITS NUMBER OF N.
   ENDFUNCTION DIGIT_I1
ENDMODULE PENF







!< KISS LIBRARY FOR PACKING HETEROGENEOUS DATA INTO SINGLE (HOMOGENEOUS) PACKED ONE.
!
MODULE BEFOR64_PACK_DATA_M
!< KISS LIBRARY FOR PACKING HETEROGENEOUS DATA INTO SINGLE (HOMOGENEOUS) PACKED ONE.
USE PENF

IMPLICIT NONE
PRIVATE
PUBLIC :: PACK_DATA

INTERFACE PACK_DATA
  !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
  !<
  !< THIS IS USEFUL FOR ENCODING DIFFERENT (HETEROGENEOUS) KINDS VARIABLES INTO A SINGLE (HOMOGENEOUS) STREAM OF BITS.
  !< @NOTE THIS PROCEDURE EXPLOITS THE `TRANSFER` BUILTIN FUNCTION, THAT FROM THE STANDARD (2003+) IS DEFINED AS
  !< `TRANSFER(SOURCE, MOLD [, SIZE])`. DATA OBJECT HAVING A PHYSICAL REPRESENTATION IDENTICAL TO THAT OF `SOURCE` BUT WITH THE TYPE
  !< AND TYPE PARAMETERS OF `MOLD`. THE RESULT IS OF THE SAME TYPE AND TYPE PARAMETERS AS `MOLD`.
  !< IF `MOLD` IS AN ARRAY AND `SIZE` IS ABSENT, THE RESULT IS AN ARRAY AND OF RANK ONE. ITS SIZE IS AS SMALL AS POSSIBLE SUCH
  !< THAT ITS PHYSICAL REPRESENTATION IS NOT SHORTER THAN THAT OF `SOURCE`.
  !<
  !< PRESENTLY, THE FOLLOWING COMBINATIONS ARE AVAILABLE:
  !<
  !<* [ ] ARRAYS-ARRAYS:
  !<    * [X] REAL(ANY)-REAL(ANY);
  !<    * [X] REAL(ANY)-INTEGER(ANY);
  !<    * [X] INTEGER(ANY)-INTEGER(ANY);
  !<    * [X] INTEGER(ANY)-REAL(ANY);
  !<    * [ ] REAL(ANY)-CHARACTER;
  !<    * [ ] CHARACTER-REAL(ANY);
  !<    * [ ] INTEGER(ANY)-CHARACTER;
  !<    * [ ] CHARACTER-INTEGER(ANY);
  !<* [ ] SCALARS-SCALARS:
  !<    * [ ] REAL(ANY)-REAL(ANY);
  !<    * [ ] REAL(ANY)-INTEGER(ANY);
  !<    * [ ] INTEGER(ANY)-INTEGER(ANY);
  !<    * [ ] INTEGER(ANY)-REAL(ANY);
  !<    * [ ] REAL(ANY)-CHARACTER;
  !<    * [ ] CHARACTER-REAL(ANY);
  !<    * [ ] INTEGER(ANY)-CHARACTER;
  !<    * [ ] CHARACTER-INTEGER(ANY);
  !<
  !<### EXAMPLES OF USAGE
  !<
  !<#### PACKING TWO REAL ARRAYS, ONE WITH KIND R8P AND ONE WITH R4P
  !<```ORTRAN
  !<REAL(R8P)::                 ARRAY_R8(1:12)
  !<REAL(R4P)::                 ARRAY_R4(-1:5)
  !<INTEGER(I1P), ALLOCATABLE:: RPACK
  !<...
  !<CALL PACK_DATA(A1=ARRAY_R8,A2=ARRAY_R4,PACKED=RPACK)
  !<```
  !<#### PACKING TWO ARRAYS, ONE REAL WITH KIND R4P AND ONE INTEGER WITH I4P
  !<```ORTRAN
  !<REAL(R4P)::                 ARRAY_R4(2)
  !<INTEGER(I4P)::              ARRAY_I4(0:2)
  !<INTEGER(I1P), ALLOCATABLE:: RPACK
  !<...
  !<CALL PACK_DATA(A1=ARRAY_R4,A2=ARRAY_I4,PACKED=RPACK)
  !<```
  MODULE PROCEDURE PACK_DATA_R8_R4, PACK_DATA_R8_I8, PACK_DATA_R8_I4, PACK_DATA_R8_I2, PACK_DATA_R8_I1, &
                   PACK_DATA_R4_R8, PACK_DATA_R4_I8, PACK_DATA_R4_I4, PACK_DATA_R4_I2, PACK_DATA_R4_I1, &
                   PACK_DATA_I8_R8, PACK_DATA_I8_R4, PACK_DATA_I8_I4, PACK_DATA_I8_I2, PACK_DATA_I8_I1, &
                   PACK_DATA_I4_R8, PACK_DATA_I4_R4, PACK_DATA_I4_I8, PACK_DATA_I4_I2, PACK_DATA_I4_I1, &
                   PACK_DATA_I2_R8, PACK_DATA_I2_R4, PACK_DATA_I2_I8, PACK_DATA_I2_I4, PACK_DATA_I2_I1, &
                   PACK_DATA_I1_R8, PACK_DATA_I1_R4, PACK_DATA_I1_I8, PACK_DATA_I1_I4, PACK_DATA_I1_I2
ENDINTERFACE

CONTAINS
   PURE SUBROUTINE PACK_DATA_R8_R4(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< REAL(R8P)                 :: A1(1)
   !< REAL(R4P)                 :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(SIZE(PACK, DIM=1))
   !<```
   !=> 63 <<<
   REAL(R8P),                 INTENT(IN)    :: A1(1:)    !< FIRS DATA STREAM.
   REAL(R4P),                 INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_R8_R4

   PURE SUBROUTINE PACK_DATA_R8_I8(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< REAL(R8P)                 :: A1(1)
   !< INTEGER(I8P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(9)
   !<```
   !=> 1 <<<
   REAL(R8P),                 INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I8P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_R8_I8

   PURE SUBROUTINE PACK_DATA_R8_I4(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< REAL(R8P)                 :: A1(1)
   !< INTEGER(I4P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(9)
   !<```
   !=> 1 <<<
   REAL(R8P),                 INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I4P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_R8_I4

   PURE SUBROUTINE PACK_DATA_R8_I2(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< REAL(R8P)                 :: A1(1)
   !< INTEGER(I2P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(9)
   !<```
   !=> 1 <<<
   REAL(R8P),                 INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I2P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_R8_I2

   PURE SUBROUTINE PACK_DATA_R8_I1(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< REAL(R8P)                 :: A1(1)
   !< INTEGER(I1P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(9)
   !<```
   !=> 1 <<<
   REAL(R8P),                 INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I1P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_R8_I1

   PURE SUBROUTINE PACK_DATA_R4_R8(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< REAL(R4P)                 :: A1(1)
   !< REAL(R8P)                 :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(SIZE(PACK, DIM=1))
   !<```
   !=> 63 <<<
   REAL(R4P),                 INTENT(IN)    :: A1(1:)    !< FIRS DATA STREAM.
   REAL(R8P),                 INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_R4_R8

   PURE SUBROUTINE PACK_DATA_R4_I8(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< REAL(R4P)                 :: A1(1)
   !< INTEGER(I8P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(5)
   !<```
   !=> 1 <<<
   REAL(R4P),                 INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I8P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_R4_I8

   PURE SUBROUTINE PACK_DATA_R4_I4(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< REAL(R4P)                 :: A1(1)
   !< INTEGER(I4P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(5)
   !<```
   !=> 1 <<<
   REAL(R4P),                 INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I4P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_R4_I4

   PURE SUBROUTINE PACK_DATA_R4_I2(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< REAL(R4P)                 :: A1(1)
   !< INTEGER(I2P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(5)
   !<```
   !=> 1 <<<
   REAL(R4P),                 INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I2P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_R4_I2

   PURE SUBROUTINE PACK_DATA_R4_I1(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< REAL(R4P)                 :: A1(1)
   !< INTEGER(I1P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(5)
   !<```
   !=> 1 <<<
   REAL(R4P),                 INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I1P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_R4_I1

   PURE SUBROUTINE PACK_DATA_I8_R8(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I8P)              :: A1(1)
   !< REAL(R8P)                 :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(SIZE(PACK, DIM=1))
   !<```
   !=> 63 <<<
   INTEGER(I8P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   REAL(R8P),                 INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I8_R8

   PURE SUBROUTINE PACK_DATA_I8_R4(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I8P)              :: A1(1)
   !< REAL(R4P)                 :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(SIZE(PACK, DIM=1))
   !<```
   !=> 63 <<<
   INTEGER(I8P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   REAL(R4P),                 INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I8_R4

   PURE SUBROUTINE PACK_DATA_I8_I4(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I8P)              :: A1(1)
   !< INTEGER(I4P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(9)
   !<```
   !=> 1 <<<
   INTEGER(I8P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I4P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I8_I4

   PURE SUBROUTINE PACK_DATA_I8_I2(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I8P)              :: A1(1)
   !< INTEGER(I2P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(9)
   !<```
   !=> 1 <<<
   INTEGER(I8P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I2P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I8_I2

   PURE SUBROUTINE PACK_DATA_I8_I1(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I8P)              :: A1(1)
   !< INTEGER(I1P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(9)
   !<```
   !=> 1 <<<
   INTEGER(I8P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I1P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I8_I1

   PURE SUBROUTINE PACK_DATA_I4_R8(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I4P)              :: A1(1)
   !< REAL(R8P)                 :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(SIZE(PACK, DIM=1))
   !<```
   !=> 63 <<<
   INTEGER(I4P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   REAL(R8P),                 INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I4_R8

   PURE SUBROUTINE PACK_DATA_I4_R4(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I4P)              :: A1(1)
   !< REAL(R4P)                 :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(SIZE(PACK, DIM=1))
   !<```
   !=> 63 <<<
   INTEGER(I4P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   REAL(R4P),                 INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I4_R4

   PURE SUBROUTINE PACK_DATA_I4_I8(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I4P)              :: A1(1)
   !< INTEGER(I8P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(5)
   !<```
   !=> 1 <<<
   INTEGER(I4P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I8P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I4_I8

   PURE SUBROUTINE PACK_DATA_I4_I2(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I4P)              :: A1(1)
   !< INTEGER(I2P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(5)
   !<```
   !=> 1 <<<
   INTEGER(I4P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I2P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I4_I2

   PURE SUBROUTINE PACK_DATA_I4_I1(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I4P)              :: A1(1)
   !< INTEGER(I1P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(5)
   !<```
   !=> 1 <<<
   INTEGER(I4P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I1P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I4_I1

   PURE SUBROUTINE PACK_DATA_I2_R8(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I2P)              :: A1(1)
   !< REAL(R8P)                 :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(SIZE(PACK, DIM=1))
   !<```
   !=> 63 <<<
   INTEGER(I2P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   REAL(R8P),                 INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I2_R8

   PURE SUBROUTINE PACK_DATA_I2_R4(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I2P)              :: A1(1)
   !< REAL(R4P)                 :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(SIZE(PACK, DIM=1))
   !<```
   !=> 63 <<<
   INTEGER(I2P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   REAL(R4P),                 INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I2_R4

   PURE SUBROUTINE PACK_DATA_I2_I8(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I2P)              :: A1(1)
   !< INTEGER(I8P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(3)
   !<```
   !=> 1 <<<
   INTEGER(I2P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I8P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I2_I8

   PURE SUBROUTINE PACK_DATA_I2_I4(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I2P)              :: A1(1)
   !< INTEGER(I4P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(3)
   !<```
   !=> 1 <<<
   INTEGER(I2P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I4P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I2_I4

   PURE SUBROUTINE PACK_DATA_I2_I1(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I2P)              :: A1(1)
   !< INTEGER(I1P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(3)
   !<```
   !=> 1 <<<
   INTEGER(I2P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I1P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I2_I1

   PURE SUBROUTINE PACK_DATA_I1_R8(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I1P)              :: A1(1)
   !< REAL(R8P)                 :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(SIZE(PACK, DIM=1))
   !<```
   !=> 63 <<<
   INTEGER(I1P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   REAL(R8P),                 INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I1_R8

   PURE SUBROUTINE PACK_DATA_I1_R4(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I1P)              :: A1(1)
   !< REAL(R4P)                 :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(SIZE(PACK, DIM=1))
   !<```
   !=> 63 <<<
   INTEGER(I1P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   REAL(R4P),                 INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I1_R4

   PURE SUBROUTINE PACK_DATA_I1_I8(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I1P)              :: A1(1)
   !< INTEGER(I8P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(2)
   !<```
   !=> 1 <<<
   INTEGER(I1P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I8P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I1_I8

   PURE SUBROUTINE PACK_DATA_I1_I4(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I1P)              :: A1(1)
   !< INTEGER(I4P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(2)
   !<```
   !=> 1 <<<
   INTEGER(I1P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I4P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I1_I4

   PURE SUBROUTINE PACK_DATA_I1_I2(A1, A2, PACKED)
   !< PACK DIFFERENT KINDS OF DATA INTO SINGLE I1P ARRAY.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I1P)              :: A1(1)
   !< INTEGER(I2P)              :: A2(1)
   !< INTEGER(I1P), ALLOCATABLE :: PACK(:)
   !< A1(1) = 0
   !< A2(1) = 1
   !< CALL PACK_DATA(A1=A1, A2=A2, PACKED=PACK)
   !< PRINT *, PACK(2)
   !<```
   !=> 1 <<<
   INTEGER(I1P),              INTENT(IN)    :: A1(1:)    !< FIRST DATA STREAM.
   INTEGER(I2P),              INTENT(IN)    :: A2(1:)    !< SECOND DATA STREAM.
   INTEGER(I1P), ALLOCATABLE, INTENT(INOUT) :: PACKED(:) !< PACKED DATA INTO I1P ARRAY.
   INTEGER(I1P), ALLOCATABLE                :: P1(:)     !< TEMPORARY PACKED DATA OF FIRST STREAM.
   INTEGER(I1P), ALLOCATABLE                :: P2(:)     !< TEMPORARY PACKED DATA OF SECOND STREAM.

   P1 = TRANSFER(A1,P1)
   P2 = TRANSFER(A2,P2)
   PACKED = [P1,P2]
   ENDSUBROUTINE PACK_DATA_I1_I2
ENDMODULE BEFOR64_PACK_DATA_M



!< BEFOR64, BASE64 ENCODING/DECODING LIBRARY FOR FORTRAN POOR PEOPLE.

MODULE BEFOR64
!< BEFOR64, BASE64 ENCODING/DECODING LIBRARY FOR FORTRAN POOR PEOPLE.
USE PENF
USE BEFOR64_PACK_DATA_M

IMPLICIT NONE
PRIVATE
PUBLIC :: IS_B64_INITIALIZED, B64_INIT
PUBLIC :: B64_ENCODE, B64_ENCODE_UP
PUBLIC :: B64_DECODE, B64_DECODE_UP
PUBLIC :: PACK_DATA

LOGICAL       :: IS_B64_INITIALIZED=.FALSE. !< FLAG FOR CHECKING THE INITIALIZATION OF THE LIBRARY.
CHARACTER(64) :: BASE64="ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/" !< BASE64 ALPHABET.

INTERFACE B64_ENCODE
  !< ENCODE NUMBERS (INTEGER AND REAL) TO BASE64.
  !<
  !< THIS IS AN INTERFACE FOR ENCODING INTEGER AND REAL NUMBERS OF ANY KINDS INTO A BASE64 STRING. THIS INTERFACE CAN ENCODE BOTH
  !< SCALAR AND ARRAY.
  !<
  !< @WARNING THE ENCODED STRING IS RETURNED AS VARYING LENGTH CHARACTER STRING, `CHARACTER(LEN=:), ALLOCATABLE:: STRING`, THUS THE
  !< COMPILER MUST SUPPORT SUCH A FORTRAN (2003) FEATURE.
  !<
  !< @NOTE BEFORE START TO ENCODE ANYTHING THE LIBRARY MUST BE INITIALIZED. THE PROCEDURE `B64_INIT` MUST BE CALLED AT FIRST. THE
  !< GLOBAL VARIABLE `IS_B64_INITIALIZED` CAN BE USED TO CHECK THE STATUS OF THE INITIALIZATION.
  !<
  !<### USAGE
  !< FOR A PRACTICAL EXAMPLE SEE THE `AUTOTEST` PROCEDURE.
  !<
  !<#### SCALAR ENCODING
  !<```ORTRAN
  !<CHARACTER(LEN=:), ALLOCATABLE:: CODE64 ! BASE64 ENCODED STRING
  !<...
  !<CALL B64_ENCODE(N=12._R8P,CODE=CODE64)
  !<```
  !<
  !<#### ARRAY ENCODING
  !<```ORTRAN
  !<CHARACTER(LEN=:), ALLOCATABLE:: CODE64 ! BASE64 ENCODED STRING
  !<...
  !<CALL B64_ENCODE(N=[12_I4P,1_I4P],CODE=CODE64)
  !<```
  !<
  !< @NOTE IF YOU WANT TO ENCODE HETEROGENOUS DATA (E.G. INTEGER AND REAL NUMBERS), YOU MUST USE THE AUXILIARY `PACK_DATA`
  !< PROCEDURE.
  !<
  !< @WARNING THE ENCODING OF ARRAY OF STRINGS IS ADMITTED ONLY IF EACH STRING OF THE ARRAY HAS THE SAME LENGTH.
  MODULE PROCEDURE &
#if defined _R16P
                   B64_ENCODE_R16,    B64_ENCODE_R16_A, &
#endif
                   B64_ENCODE_R8,     B64_ENCODE_R8_A,  &
                   B64_ENCODE_R4,     B64_ENCODE_R4_A,  &
                   B64_ENCODE_I8,     B64_ENCODE_I8_A,  &
                   B64_ENCODE_I4,     B64_ENCODE_I4_A,  &
                   B64_ENCODE_I2,     B64_ENCODE_I2_A,  &
                   B64_ENCODE_I1,     B64_ENCODE_I1_A,  &
                   B64_ENCODE_STRING, B64_ENCODE_STRING_A
ENDINTERFACE

INTERFACE B64_ENCODE_UP
  !< ENCODE UNLIMITED POLYMORPHIC VARIABLE TO BASE64.
  !<
  !< THIS IS AN INTERFACE FOR ENCODING BOTH SCALAR AND ARRAY.
  !<
  !< @WARNING THE ENCODED STRING IS RETURNED AS VARYING LENGTH CHARACTER STRING, `CHARACTER(LEN=:), ALLOCATABLE:: STRING`, THUS THE
  !< COMPILER MUST SUPPORT SUCH A FORTRAN (2003) FEATURE.
  !<
  !< @NOTE BEFORE START TO ENCODE ANYTHING THE LIBRARY MUST BE INITIALIZED. THE PROCEDURE `B64_INIT` MUST BE CALLED AT FIRST. THE
  !< GLOBAL VARIABLE `IS_B64_INITIALIZED` CAN BE USED TO CHECK THE STATUS OF THE INITIALIZATION.
  !<
  !<### USAGE
  !< FOR A PRACTICAL EXAMPLE SEE THE `AUTOTEST` PROCEDURE.
  !<
  !<#### SCALAR ENCODING
  !<```ORTRAN
  !<CHARACTER(LEN=:), ALLOCATABLE:: CODE64 ! BASE64 ENCODED STRING
  !<...
  !<CALL B64_ENCODE_UP(UP=12._R8P,CODE=CODE64)
  !<```
  !<
  !<#### ARRAY ENCODING
  !<```ORTRAN
  !<CHARACTER(LEN=:), ALLOCATABLE:: CODE64 ! BASE64 ENCODED STRING
  !<...
  !<CALL B64_ENCODE_UP(UP=[12_I4P,1_I4P],CODE=CODE64)
  !<```
  !<
  !< @NOTE IF YOU WANT TO ENCODE HETEROGENOUS DATA (E.G. INTEGER AND REAL NUMBERS), YOU MUST USE THE AUXILIARY `PACK_DATA`
  !< PROCEDURE.
  !<
  !< @WARNING THE ENCODING OF ARRAY OF STRINGS IS ADMITTED ONLY IF EACH STRING OF THE ARRAY HAS THE SAME LENGTH.
  MODULE PROCEDURE B64_ENCODE_UP, B64_ENCODE_UP_A
ENDINTERFACE

INTERFACE B64_DECODE
  !< DECODE NUMBERS (INTEGER AND REAL) FROM BASE64.
  !<
  !< THIS IS AN INTERFACE FOR DECODING INTEGER AND REAL NUMBERS OF ANY KINDS FROM A BASE64 STRING. THIS INTERFACE CAN DECODE BOTH
  !< SCALAR AND ARRAY.
  !<
  !< @NOTE BEFORE START TO DECODE ANYTHING THE LIBRARY MUST BE INITIALIZED. THE PROCEDURE `B64_INIT` MUST BE CALLED AT FIRST. THE
  !< GLOBAL VARIABLE `IS_B64_INITIALIZED` CAN BE USED TO CHECK THE STATUS OF THE INITIALIZATION.
  !<
  !<### USAGE
  !< FOR A PRACTICAL EXAMPLE SEE THE `AUTOTEST` PROCEDURE.
  !<
  !<#### SCALAR DECODING
  !<```ORTRAN
  !<REAL(R8P):: DECODED ! SCALAR TO BE DECODED
  !<...
  !<CALL B64_DECODE(CODE='AAAAAAAA8D8=',N=DECODED)
  !<```
  !<
  !<#### ARRAY DECODING
  !<```ORTRAN
  !<INTEGER(I8P):: DECODED(1:4) ! ARRAY TO BE DECODED
  !<...
  !<CALL B64_DECODE(CODE='FWAAAAAAAABEAQAAAAAAABBWHAEAAAAAAGAAAAAAAAA=',N=DECODED)
  !<```
  !<
  !< @NOTE IF YOU WANT TO DECODE HETEROGENOUS DATA (E.G. INTEGER AND REAL NUMBERS), YOU MUST USE THE AUXILIARY `PACK_DATA`
  !< PROCEDURE.
  !<
  !< @WARNING THE DECODING OF ARRAY OF STRINGS IS ADMITTED ONLY IF EACH STRING OF THE ARRAY HAS THE SAME LENGTH.
  MODULE PROCEDURE &
#if defined _R16P
                   B64_DECODE_R16,    B64_DECODE_R16_A, &
#endif
                   B64_DECODE_R8,     B64_DECODE_R8_A,  &
                   B64_DECODE_R4,     B64_DECODE_R4_A,  &
                   B64_DECODE_I8,     B64_DECODE_I8_A,  &
                   B64_DECODE_I4,     B64_DECODE_I4_A,  &
                   B64_DECODE_I2,     B64_DECODE_I2_A,  &
                   B64_DECODE_I1,     B64_DECODE_I1_A,  &
                   B64_DECODE_STRING, B64_DECODE_STRING_A
ENDINTERFACE

INTERFACE B64_DECODE_UP
  !< DECODE UNLIMITED POLYMORPHIC VARIABLE FROM BASE64.
  !<
  !< THIS IS AN INTERFACE FOR DECODING BOTH SCALAR AND ARRAY.
  !<
  !< @NOTE BEFORE START TO DECODE ANYTHING THE LIBRARY MUST BE INITIALIZED. THE PROCEDURE `B64_INIT` MUST BE CALLED AT FIRST. THE
  !< GLOBAL VARIABLE `IS_B64_INITIALIZED` CAN BE USED TO CHECK THE STATUS OF THE INITIALIZATION.
  !<
  !<### USAGE
  !< FOR A PRACTICAL EXAMPLE SEE THE `AUTOTEST` PROCEDURE.
  !<
  !<#### SCALAR DECODING
  !<```ORTRAN
  !<REAL(R8P):: DECODED ! SCALAR TO BE DECODED
  !<...
  !<CALL B64_DECODE_UP(CODE='AAAAAAAA8D8=',UP=DECODED)
  !<```
  !<
  !<#### ARRAY DECODING
  !<```ORTRAN
  !<INTEGER(I8P):: DECODED(1:4) ! ARRAY TO BE DECODED
  !<...
  !<CALL B64_DECODE_UP(CODE='FWAAAAAAAABEAQAAAAAAABBWHAEAAAAAAGAAAAAAAAA=',UP=DECODED)
  !<```
  !<
  !< @NOTE IF YOU WANT TO DECODE HETEROGENOUS DATA (E.G. INTEGER AND REAL NUMBERS), YOU MUST USE THE AUXILIARY `PACK_DATA`
  !< PROCEDURE.
  !<
  !< @WARNING THE DECODING OF ARRAY OF STRINGS IS ADMITTED ONLY IF EACH STRING OF THE ARRAY HAS THE SAME LENGTH.
  MODULE PROCEDURE B64_DECODE_UP, B64_DECODE_UP_A
ENDINTERFACE

CONTAINS
   SUBROUTINE B64_INIT()
   !< INITIALIZE THE BEFOR64 LIBRARY.
   !<
   !< @NOTE THIS PROCEDURE **MUST** BE CALLED BEFORE ENCODING/DECODING ANYTHING!
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< CALL B64_INIT
   !< PRINT "(L1)", IS_B64_INITIALIZED
   !<```
   !=> T <<<

   IF (.NOT.IS_INITIALIZED) CALL PENF_INIT
   IS_B64_INITIALIZED = .TRUE.
   ENDSUBROUTINE B64_INIT

   PURE SUBROUTINE ENCODE_BITS(BITS, PADD, CODE)
   !< ENCODE A BITS STREAM (MUST BE MULTIPLE OF 24 BITS) INTO BASE64 CHARCATERS CODE (OF LENGTH MULTIPLE OF 4).
   !<
   !< THE BITS STREAM ARE ENCODED IN CHUNKS OF 24 BITS AS THE FOLLOWING EXAMPLE (IN LITTLE ENDIAN ORDER)
   !<```
   !< +--FIRST OCTET--+-SECOND OCTET--+--THIRD OCTET--+
   !< |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|
   !< +-----------+---+-------+-------+---+-----------+
   !< |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|
   !< +--1.INDEX--+--2.INDEX--+--3.INDEX--+--4.INDEX--+
   !<```
   !< @NOTE THE 4 INDEXES ARE STORED INTO 4 ELEMENTS 8 BITS ARRAY, THUS 2 BITS OF EACH ARRAY ELEMENT ARE NOT USED.
   !<
   !< @NOTE THE NUMBER OF PADDINGS MUST BE COMPUTED OUTSIDE THIS PROCEDURE, INTO THE CALLING SCOPE.
   !<
   !< @WARNING THIS PROCEDURE IS THE BACKEND OF ENCODING, THUS IT MUST BE NEVER CALLED OUTSIDE THE MODULE.
   INTEGER(I1P), INTENT(IN)  :: BITS(1:)  !< BITS TO BE ENCODED.
   INTEGER(I4P), INTENT(IN)  :: PADD      !< NUMBER OF PADDING CHARACTERS ('=').
   CHARACTER(*), INTENT(OUT) :: CODE      !< CHARACTERS CODE.
   INTEGER(I1P)              :: SIXB(1:4) !< 6 BITS SLICES (STORED INTO 8 BITS INTEGER) OF 24 BITS INPUT.
   INTEGER(I8P)              :: C         !< COUNTER.
   INTEGER(I8P)              :: E         !< COUNTER.
   INTEGER(I8P)              :: NB        !< LENGTH OF BITS ARRAY.

   NB=SIZE(BITS,DIM=1,KIND=I8P)
   C = 1_I8P
   DO E=1_I8P,NB,3_I8P ! LOOP OVER ARRAY ELEMENTS: 3 BYTES (24 BITS) SCANNING
      SIXB = 0_I1P
         CALL MVBITS(BITS(E  ),2,6,SIXB(1),0)
         CALL MVBITS(BITS(E  ),0,2,SIXB(2),4)
      IF (E+1<=NB) THEN
         CALL MVBITS(BITS(E+1),4,4,SIXB(2),0)
         CALL MVBITS(BITS(E+1),0,4,SIXB(3),2)
      ENDIF
      IF (E+2<=NB) THEN
         CALL MVBITS(BITS(E+2),6,2,SIXB(3),0)
         CALL MVBITS(BITS(E+2),0,6,SIXB(4),0)
      ENDIF
      SIXB = SIXB + 1_I1P
      CODE(C  :C  ) = BASE64(SIXB(1):SIXB(1))
      CODE(C+1:C+1) = BASE64(SIXB(2):SIXB(2))
      CODE(C+2:C+2) = BASE64(SIXB(3):SIXB(3))
      CODE(C+3:C+3) = BASE64(SIXB(4):SIXB(4))
      C = C + 4_I8P
   ENDDO
   IF (PADD>0) CODE(LEN(CODE)-PADD+1:)=REPEAT('=',PADD)
   ENDSUBROUTINE ENCODE_BITS

   PURE SUBROUTINE DECODE_BITS(CODE, BITS)
   !< DECODE A BASE64 STRING INTO A SEQUENCE OF BITS STREAM.
   !<
   !< THE BASE64 STRING MUST BE PARSED WITH A STRIKE OF 4 CHARACTERS AND CONVERTED INTO A 3 BYTES STREAM. CONSIDERING THE BASE64 CODE
   !< `QUJD` THE DECODING PROCESS MUST DO
   !<```
   !< +-B64 CHAR--+-B64 CHAR--+-B64 CHAR--+-B64 CHAR--+
   !< |      Q    |      U    |      J    |      D    |
   !< +-B64 INDEX-+-B64 INDEX-+-B64 INDEX-+-B64 INDEX-+
   !< !      16   |      20   |      9    |      3    |
   !< +-6 BITS----+-6 BITS----+-6 BITS----+-6 BITS----+
   !< |0 1 0 0 0 0|0 1 0 1 0 0|0 0 1 0 0 1|0 0 0 0 1 1|
   !< +-----------+---+-------+-------+---+-----------+
   !< |0 1 0 0 0 0 0 1|0 1 0 0 0 0 1 0|0 1 0 0 0 0 1 1|
   !< +-----8 BITS----+-----8 BITS----+-----8 BITS----+
   !<```
   !< @NOTE THE BITS PATTERN IS RETURNED AS A 1-BYTE ELEMENT ARRAY, THE DIMENSION OF WITCH MUST BE COMPUTED OUTSIDE THIS PROCEDURE.
   !<
   !< @WARNING THIS PROCEDURE IS THE BACKEND OF DECODING, THUS IT MUST BE NEVER CALLED OUTSIDE THE MODULE.
   CHARACTER(*), INTENT(IN)  :: CODE      !< CHARACTERS CODE.
   INTEGER(I1P), INTENT(OUT) :: BITS(1:)  !< BITS DECODED.
   INTEGER(I1P)              :: SIXB(1:4) !< 6 BITS SLICES (STORED INTO 8 BITS INTEGER) OF 24 BITS INPUT.
   INTEGER(I8P)              :: C         !< COUNTER.
   INTEGER(I8P)              :: E         !< COUNTER.
   INTEGER(I8P)              :: NB        !< LENGTH OF BITS ARRAY.

   NB=SIZE(BITS,DIM=1,KIND=I8P)
   E = 1_I8P
   DO C=1_I8P,LEN(CODE),4_I8P ! LOOP OVER CODE CHARACTERS: 3 BYTES (24 BITS) SCANNING
      SIXB = 0_I1P
      SIXB(1) = INT(INDEX(BASE64,CODE(C  :C  )),I1P) - 1_I1P
      SIXB(2) = INT(INDEX(BASE64,CODE(C+1:C+1)),I1P) - 1_I1P
      SIXB(3) = INT(INDEX(BASE64,CODE(C+2:C+2)),I1P) - 1_I1P
      SIXB(4) = INT(INDEX(BASE64,CODE(C+3:C+3)),I1P) - 1_I1P
         CALL MVBITS(SIXB(1),0,6,BITS(E  ),2) ; CALL MVBITS(SIXB(2),4,2,BITS(E  ),0)
      IF (E+1<=NB) THEN
         CALL MVBITS(SIXB(2),0,4,BITS(E+1),4) ; CALL MVBITS(SIXB(3),2,4,BITS(E+1),0)
      ENDIF
      IF (E+2<=NB) THEN
         CALL MVBITS(SIXB(3),0,2,BITS(E+2),6) ; CALL MVBITS(SIXB(4),0,6,BITS(E+2),0)
      ENDIF
      E = E + 3_I8P
   ENDDO
   ENDSUBROUTINE DECODE_BITS

   SUBROUTINE B64_ENCODE_UP(UP, CODE)
   !< ENCODE AN UNLIMITED POLYMORPHIC SCALAR TO BASE64.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(LEN=:), ALLOCATABLE :: CODE64
   !< CALL B64_ENCODE_UP(UP=1._R8P, CODE=CODE64)
   !< PRINT "(A)", CODE64
   !<```
   !=> AAAAAAAA8D8= <<<
   CLASS(*),                      INTENT(IN)  :: UP   !< UNLIMITED POLYMORPHIC VARIABLE TO BE ENCODED.
   CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: CODE !< ENCODED SCALAR.

   SELECT TYPE(UP)
   TYPE IS(REAL(R8P))
      CALL B64_ENCODE_R8(N=UP,CODE=CODE)
   TYPE IS(REAL(R4P))
      CALL B64_ENCODE_R4(N=UP,CODE=CODE)
   TYPE IS(INTEGER(I8P))
      CALL B64_ENCODE_I8(N=UP,CODE=CODE)
   TYPE IS(INTEGER(I4P))
      CALL B64_ENCODE_I4(N=UP,CODE=CODE)
   TYPE IS(INTEGER(I2P))
      CALL B64_ENCODE_I2(N=UP,CODE=CODE)
   TYPE IS(INTEGER(I1P))
      CALL B64_ENCODE_I1(N=UP,CODE=CODE)
   TYPE IS(CHARACTER(*))
      CALL B64_ENCODE_STRING(S=UP,CODE=CODE)
   ENDSELECT
   ENDSUBROUTINE B64_ENCODE_UP

   PURE SUBROUTINE B64_ENCODE_UP_A(UP, CODE)
   !< ENCODE AN UNLIMITED POLYMORPHIC ARRAY TO BASE64.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(LEN=:), ALLOCATABLE :: CODE64
   !< CALL B64_ENCODE_UP(UP=[0._R4P,-32.12_R4P], CODE=CODE64)
   !< PRINT "(A)", CODE64
   !<```
   !=> AAAAAOF6AMI= <<<
   CLASS(*),                      INTENT(IN)  :: UP(1:) !< UNLIMITED POLYMORPHIC VARIABLE TO BE ENCODED.
   CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: CODE   !< ENCODED ARRAY.

   SELECT TYPE(UP)
   TYPE IS(REAL(R8P))
      CALL B64_ENCODE_R8_A(N=UP,CODE=CODE)
   TYPE IS(REAL(R4P))
      CALL B64_ENCODE_R4_A(N=UP,CODE=CODE)
   TYPE IS(INTEGER(I8P))
      CALL B64_ENCODE_I8_A(N=UP,CODE=CODE)
   TYPE IS(INTEGER(I4P))
      CALL B64_ENCODE_I4_A(N=UP,CODE=CODE)
   TYPE IS(INTEGER(I2P))
      CALL B64_ENCODE_I2_A(N=UP,CODE=CODE)
   TYPE IS(INTEGER(I1P))
      CALL B64_ENCODE_I1_A(N=UP,CODE=CODE)
   TYPE IS(CHARACTER(*))
      CALL B64_ENCODE_STRING_A(S=UP,CODE=CODE)
   ENDSELECT
   ENDSUBROUTINE B64_ENCODE_UP_A

   SUBROUTINE B64_DECODE_UP(CODE, UP)
   !< DECODE AN UNLIMITED POLYMORPHIC SCALAR FROM BASE64.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I4P) :: SCALAR_I4
   !< CALL B64_DECODE_UP(CODE='5WCAAA==',UP=SCALAR_I4)
   !< PRINT "(L1)", SCALAR_I4==2023_I4P
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN)  :: CODE !< ENCODED SCALAR.
   CLASS(*),     INTENT(OUT) :: UP   !< UNLIMITED POLYMORPHIC VARIABLE TO BE DECODED.

   SELECT TYPE(UP)
   TYPE IS(REAL(R8P))
      CALL B64_DECODE_R8(CODE=CODE,N=UP)
   TYPE IS(REAL(R4P))
      CALL B64_DECODE_R4(CODE=CODE,N=UP)
   TYPE IS(INTEGER(I8P))
      CALL B64_DECODE_I8(CODE=CODE,N=UP)
   TYPE IS(INTEGER(I4P))
      CALL B64_DECODE_I4(CODE=CODE,N=UP)
   TYPE IS(INTEGER(I2P))
      CALL B64_DECODE_I2(CODE=CODE,N=UP)
   TYPE IS(INTEGER(I1P))
      CALL B64_DECODE_I1(CODE=CODE,N=UP)
   TYPE IS(CHARACTER(*))
      CALL B64_DECODE_STRING(CODE=CODE,S=UP)
   ENDSELECT
   ENDSUBROUTINE B64_DECODE_UP

   SUBROUTINE B64_DECODE_UP_A(CODE, UP)
   !< DECODE AN UNLIMITED POLYMORPHIC ARRAY FROM BASE64.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I8P) :: ARRAY_I8(1:4)
   !< CALL B64_DECODE_UP(CODE='FWAAAAAAAABEAQAAAAAAABBWHAEAAAAAAGAAAAAAAAA=', UP=ARRAY_I8)
   !< PRINT "(L1)", STR(N=ARRAY_I8)==STR(N=[23_I8P,324_I8P,25456656_I8P,2_I8P])
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN)  :: CODE   !< ENCODED ARRAY.
   CLASS(*),     INTENT(OUT) :: UP(1:) !< UNLIMITED POLYMORPHIC VARIABLE TO BE DECODED.

   SELECT TYPE(UP)
   TYPE IS(REAL(R8P))
      CALL B64_DECODE_R8_A(CODE=CODE,N=UP)
   TYPE IS(REAL(R4P))
      CALL B64_DECODE_R4_A(CODE=CODE,N=UP)
   TYPE IS(INTEGER(I8P))
      CALL B64_DECODE_I8_A(CODE=CODE,N=UP)
   TYPE IS(INTEGER(I4P))
      CALL B64_DECODE_I4_A(CODE=CODE,N=UP)
   TYPE IS(INTEGER(I2P))
      CALL B64_DECODE_I2_A(CODE=CODE,N=UP)
   TYPE IS(INTEGER(I1P))
      CALL B64_DECODE_I1_A(CODE=CODE,N=UP)
   TYPE IS(CHARACTER(*))
      CALL B64_DECODE_STRING_A(CODE=CODE,S=UP)
   ENDSELECT
   ENDSUBROUTINE B64_DECODE_UP_A

   PURE SUBROUTINE B64_ENCODE_R16(N, CODE)
   !< ENCODE SCALAR NUMBER TO BASE64 (R16P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(LEN=:), ALLOCATABLE :: CODE64
   !< CALL B64_ENCODE(N=134.231_R16P, CODE=CODE64)
   !< PRINT "(A)", CODE64
   !<```
   !=> CKWCWMTHYEA= <<<
   REAL(R16P),                    INTENT(IN)  :: N       !< NUMBER TO BE ENCODED.
   CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: CODE    !< ENCODED SCALAR.
   INTEGER(I1P),     ALLOCATABLE              :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.
   INTEGER(I4P)                               :: PADD    !< NUMBER OF PADDING CHARACTERS ('=').

   ALLOCATE(NI1P(1:((BYR16P+2)/3)*3)) ; NI1P = 0_I1P
   CODE = REPEAT(' ',((BYR16P+2)/3)*4)
   NI1P = TRANSFER(N,NI1P)
#if defined _R16P
   PADD = MOD((BYR16P),3_I2P) ; IF (PADD>0_I4P) PADD = 3_I4P - PADD
#else
   PADD = MOD((BYR16P),3_I2P) ; IF (PADD>0_I4P) PADD = 3_I4P - PADD
   ! johodges Edited from 3_I1P to 3_I2P
#endif
   CALL ENCODE_BITS(BITS=NI1P,PADD=PADD,CODE=CODE)
   ENDSUBROUTINE B64_ENCODE_R16

   PURE SUBROUTINE B64_ENCODE_R8(N, CODE)
   !< ENCODE SCALAR NUMBER TO BASE64 (R8P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(LEN=:), ALLOCATABLE :: CODE64
   !< CALL B64_ENCODE(N=1._R8P, CODE=CODE64)
   !< PRINT "(A)", CODE64
   !<```
   !=> AAAAAAAA8D8= <<<
   REAL(R8P),                     INTENT(IN)  :: N       !< NUMBER TO BE ENCODED.
   CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: CODE    !< ENCODED SCALAR.
   INTEGER(I1P),     ALLOCATABLE              :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.
   INTEGER(I4P)                               :: PADD    !< NUMBER OF PADDING CHARACTERS ('=').

   ALLOCATE(NI1P(1:((BYR8P+2)/3)*3)) ; NI1P = 0_I1P
   CODE = REPEAT(' ',((BYR8P+2)/3)*4)
   NI1P = TRANSFER(N,NI1P)
   PADD = MOD((BYR8P),3_I1P) ; IF (PADD>0_I4P) PADD = 3_I4P - PADD
   CALL ENCODE_BITS(BITS=NI1P,PADD=PADD,CODE=CODE)
   ENDSUBROUTINE B64_ENCODE_R8

   PURE SUBROUTINE B64_ENCODE_R4(N, CODE)
   !< ENCODE SCALAR NUMBER TO BASE64 (R4P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(LEN=:), ALLOCATABLE :: CODE64
   !< CALL B64_ENCODE(N=0._R4P, CODE=CODE64)
   !< PRINT "(A)", CODE64
   !<```
   !=> AAAAAA== <<<
   REAL(R4P),                     INTENT(IN)  :: N       !< NUMBER TO BE ENCODED.
   CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: CODE    !< ENCODED SCALAR.
   INTEGER(I1P),     ALLOCATABLE              :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.
   INTEGER(I4P)                               :: PADD    !< NUMBER OF PADDING CHARACTERS ('=').

   ALLOCATE(NI1P(1:((BYR4P+2)/3)*3)) ; NI1P = 0_I1P
   CODE = REPEAT(' ',((BYR4P+2)/3)*4)
   NI1P = TRANSFER(N,NI1P)
   PADD = MOD((BYR4P),3_I1P) ; IF (PADD>0_I4P) PADD = 3_I4P - PADD
   CALL ENCODE_BITS(BITS=NI1P,PADD=PADD,CODE=CODE)
   ENDSUBROUTINE B64_ENCODE_R4

   PURE SUBROUTINE B64_ENCODE_I8(N, CODE)
   !< ENCODE SCALAR NUMBER TO BASE64 (I8P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(LEN=:), ALLOCATABLE :: CODE64
   !< CALL B64_ENCODE(N=23_I8P, CODE=CODE64)
   !< PRINT "(A)", CODE64
   !<```
   !=> FWAAAAAAAAA= <<<
   INTEGER(I8P),                  INTENT(IN)  :: N       !< NUMBER TO BE ENCODED.
   CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: CODE    !< ENCODED SCALAR.
   INTEGER(I1P),     ALLOCATABLE              :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.
   INTEGER(I4P)                               :: PADD    !< NUMBER OF PADDING CHARACTERS ('=').

   !ALLOCATE(NI1P(1:((BYI8P+2)/3)*3)) ; NI1P = 0_I1P
   !CODE = REPEAT(' ',((BYI8P+2)/3)*4)
   ALLOCATE(NI1P(1:3)) ; NI1P = 0_I1P
   CODE = REPEAT(' ',12)
   NI1P = TRANSFER(N,NI1P)
   PADD = MOD((BYI8P),3_I8P) ; IF (PADD>0_I4P) PADD = 3_I4P - PADD
   CALL ENCODE_BITS(BITS=NI1P,PADD=PADD,CODE=CODE)
   ENDSUBROUTINE B64_ENCODE_I8

   PURE SUBROUTINE B64_ENCODE_I4(N, CODE)
   !< ENCODE SCALAR NUMBER TO BASE64 (I4P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(LEN=:), ALLOCATABLE :: CODE64
   !< CALL B64_ENCODE(N=2023_I4P, CODE=CODE64)
   !< PRINT "(A)", CODE64
   !<```
   !=> 5WCAAA== <<<
   INTEGER(I4P),                  INTENT(IN)  :: N       !< NUMBER TO BE ENCODED.
   CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: CODE    !< ENCODED SCALAR.
   INTEGER(I1P),     ALLOCATABLE              :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.
   INTEGER(I4P)                               :: PADD    !< NUMBER OF PADDING CHARACTERS ('=').

   ALLOCATE(NI1P(1:((BYI4P+2)/3)*3)) ; NI1P = 0_I1P
   CODE = REPEAT(' ',((BYI4P+2)/3)*4)
   NI1P = TRANSFER(N,NI1P)
   PADD = MOD((BYI4P),3_I4P) ; IF (PADD>0_I4P) PADD = 3_I4P - PADD
   CALL ENCODE_BITS(BITS=NI1P,PADD=PADD,CODE=CODE)
   ENDSUBROUTINE B64_ENCODE_I4

   PURE SUBROUTINE B64_ENCODE_I2(N, CODE)
   !< ENCODE SCALAR NUMBER TO BASE64 (I2P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(LEN=:), ALLOCATABLE :: CODE64
   !< CALL B64_ENCODE(N=-203_I2P, CODE=CODE64)
   !< PRINT "(A)", CODE64
   !<```
   !=> NF8= <<<
   INTEGER(I2P),                  INTENT(IN)  :: N       !< NUMBER TO BE ENCODED.
   CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: CODE    !< ENCODED SCALAR.
   INTEGER(I1P),     ALLOCATABLE              :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.
   INTEGER(I4P)                               :: PADD    !< NUMBER OF PADDING CHARACTERS ('=').

   ALLOCATE(NI1P(1:3)) ; NI1P = 0_I1P
   CODE = REPEAT(' ',4_I1P)
   !ALLOCATE(NI1P(1:((BYI2P+2_I1P)/3_I1P)*3_I1P)) ; NI1P = 0_I1P
   !CODE = REPEAT(' ',((BYI2P+2_I1P)/3_I1P)*4_I1P)
   NI1P = TRANSFER(N,NI1P)
   PADD = MOD((BYI2P),3_I2P) ; IF (PADD>0_I4P) PADD = 3_I4P - PADD
   CALL ENCODE_BITS(BITS=NI1P,PADD=PADD,CODE=CODE)
   ENDSUBROUTINE B64_ENCODE_I2

   PURE SUBROUTINE B64_ENCODE_I1(N, CODE)
   !< ENCODE SCALAR NUMBER TO BASE64 (I1P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(LEN=:), ALLOCATABLE :: CODE64
   !< CALL B64_ENCODE(N=120_I1P, CODE=CODE64)
   !< PRINT "(A)", CODE64
   !<```
   !=> EA== <<<
   INTEGER(I1P),                  INTENT(IN)  :: N       !< NUMBER TO BE ENCODED.
   CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: CODE    !< ENCODED SCALAR.
   INTEGER(I1P),     ALLOCATABLE              :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.
   INTEGER(I4P)                               :: PADD    !< NUMBER OF PADDING CHARACTERS ('=').

   ALLOCATE(NI1P(1:((BYI1P+2)/3)*3)) ; NI1P = 0_I1P
   CODE = REPEAT(' ',((BYI1P+2)/3)*4)
   NI1P = TRANSFER(N,NI1P)
   PADD = MOD((BYI1P),3_I1P) ; IF (PADD>0_I4P) PADD = 3_I4P - PADD
   CALL ENCODE_BITS(BITS=NI1P,PADD=PADD,CODE=CODE)
   ENDSUBROUTINE B64_ENCODE_I1

   PURE SUBROUTINE B64_ENCODE_STRING(S, CODE)
   !< ENCODE SCALAR STRING TO BASE64.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(LEN=:), ALLOCATABLE :: CODE64
   !< CALL B64_ENCODE(S='HELLO', CODE=CODE64)
   !< PRINT "(A)", CODE64
   !<```
   !=> AGVSBG8= <<<
   CHARACTER(*),                  INTENT(IN)  :: S       !< STRING TO BE ENCODED.
   CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: CODE    !< ENCODED SCALAR.
   INTEGER(I1P),     ALLOCATABLE              :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.
   INTEGER(I4P)                               :: PADD    !< NUMBER OF PADDING CHARACTERS ('=').
   INTEGER(I4P)                               :: BYCHS   !< BYTES OF CHARACTER STRING.

   BYCHS = BYTE_SIZE(S)
   ALLOCATE(NI1P(1:((BYCHS+2)/3)*3)) ; NI1P = 0_I1P
   CODE = REPEAT(' ',((BYCHS+2)/3)*4)
   NI1P = TRANSFER(S,NI1P)
   PADD = MOD((BYCHS),3_I4P) ; IF (PADD>0_I4P) PADD = 3_I4P - PADD
   CALL ENCODE_BITS(BITS=NI1P,PADD=PADD,CODE=CODE)
   ENDSUBROUTINE B64_ENCODE_STRING

   PURE SUBROUTINE B64_ENCODE_R16_A(N, CODE)
   !< ENCODE ARRAY NUMBERS TO BASE64 (R16P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(LEN=:), ALLOCATABLE :: CODE64
   !< CALL B64_ENCODE(N=[121._R16P,2.32_R16P], CODE=CODE64)
   !< PRINT "(A)", CODE64
   !<```
   !=> AAAAAABAXKCPWVUOXI8CQA== <<<
   REAL(R16P),                    INTENT(IN)  :: N(1:)   !< ARRAY OF NUMBERS TO BE ENCODED.
   CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: CODE    !< ENCODED ARRAY.
   INTEGER(I1P),     ALLOCATABLE              :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.
   INTEGER(I4P)                               :: PADD    !< NUMBER OF PADDING CHARACTERS ('=').
   INTEGER(I8P)                               :: NS      !< SIZE OF N.

   NS = SIZE(N,DIM=1)
   ALLOCATE(NI1P(1:((NS*BYR16P+2)/3)*3)) ; NI1P = 0_I1P
   CODE = REPEAT(' ',((NS*BYR16P+2)/3)*4)
   NI1P = TRANSFER(N,NI1P)
   PADD = INT(MOD((NS*BYR16P),3_I8P),I4P) ; IF (PADD>0_I4P) PADD = 3_I4P - PADD
   CALL ENCODE_BITS(BITS=NI1P,PADD=PADD,CODE=CODE)
   ENDSUBROUTINE B64_ENCODE_R16_A

   PURE SUBROUTINE B64_ENCODE_R8_A(N, CODE)
   !< ENCODE ARRAY NUMBERS TO BASE64 (R8P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(LEN=:), ALLOCATABLE :: CODE64
   !< CALL B64_ENCODE(N=[1._R8P,2._R8P], CODE=CODE64)
   !< PRINT "(A)", CODE64
   !<```
   !=> AAAAAAAA8D8AAAAAAAAAQA== <<<
   REAL(R8P),                     INTENT(IN)  :: N(1:)   !< ARRAY OF NUMBERS TO BE ENCODED.
   CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: CODE    !< ENCODED ARRAY.
   INTEGER(I1P),     ALLOCATABLE              :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.
   INTEGER(I4P)                               :: PADD    !< NUMBER OF PADDING CHARACTERS ('=').
   INTEGER(I8P)                               :: NS      !< SIZE OF N.

   NS = SIZE(N,DIM=1)
   ALLOCATE(NI1P(1:((NS*BYR8P+2)/3)*3)) ; NI1P = 0_I1P
   CODE = REPEAT(' ',((NS*BYR8P+2)/3)*4)
   NI1P = TRANSFER(N,NI1P)
   PADD = INT(MOD((NS*BYR8P),3_I8P),I4P) ; IF (PADD>0_I4P) PADD = 3_I4P - PADD
   CALL ENCODE_BITS(BITS=NI1P,PADD=PADD,CODE=CODE)
   ENDSUBROUTINE B64_ENCODE_R8_A

   PURE SUBROUTINE B64_ENCODE_R4_A(N, CODE)
   !< ENCODE ARRAY NUMBERS TO BASE64 (R4P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(LEN=:), ALLOCATABLE :: CODE64
   !< CALL B64_ENCODE(N=[0._R4P,-32.12_R4P], CODE=CODE64)
   !< PRINT "(A)", CODE64
   !<```
   !=> AAAAAOF6AMI= <<<
   REAL(R4P),                     INTENT(IN)  :: N(1:)   !< ARRAY OF NUMBERS TO BE ENCODED.
   CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: CODE    !< ENCODED ARRAY.
   INTEGER(I1P),     ALLOCATABLE              :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.
   INTEGER(I4P)                               :: PADD    !< NUMBER OF PADDING CHARACTERS ('=').
   INTEGER(I8P)                               :: NS      !< SIZE OF N.

   NS = SIZE(N,DIM=1)
   ALLOCATE(NI1P(1:((NS*BYR4P+2)/3)*3)) ; NI1P = 0_I1P
   CODE = REPEAT(' ',((NS*BYR4P+2)/3)*4)
   NI1P = TRANSFER(N,NI1P)
   PADD = INT(MOD((NS*BYR4P),3_I8P),I4P) ; IF (PADD>0_I4P) PADD = 3_I4P - PADD
   CALL ENCODE_BITS(BITS=NI1P,PADD=PADD,CODE=CODE)
   ENDSUBROUTINE B64_ENCODE_R4_A

   PURE SUBROUTINE B64_ENCODE_I8_A(N, CODE)
   !< ENCODE ARRAY NUMBERS TO BASE64 (I8P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(LEN=:), ALLOCATABLE :: CODE64
   !< CALL B64_ENCODE(N=[23_I8P,324_I8P,25456656_I8P,2_I8P], CODE=CODE64)
   !< PRINT "(A)", CODE64
   !<```
   !=> FWAAAAAAAABEAQAAAAAAABBWHAEAAAAAAGAAAAAAAAA= <<<
   INTEGER(I8P),                  INTENT(IN)  :: N(1:)   !< ARRAY OF NUMBERS TO BE ENCODED.
   CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: CODE    !< ENCODED ARRAY.
   INTEGER(I1P),     ALLOCATABLE              :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.
   INTEGER(I4P)                               :: PADD    !< NUMBER OF PADDING CHARACTERS ('=').
   INTEGER(I8P)                               :: NS      !< SIZE OF N.

   NS = SIZE(N,DIM=1)
   ALLOCATE(NI1P(1:((NS*BYI8P+2)/3)*3)) ; NI1P = 0_I1P
   CODE = REPEAT(' ',((NS*BYI8P+2)/3)*4)
   NI1P = TRANSFER(N,NI1P)
   PADD = INT(MOD((NS*BYI8P),3_I8P),I4P) ; IF (PADD>0_I4P) PADD = 3_I4P - PADD
   CALL ENCODE_BITS(BITS=NI1P,PADD=PADD,CODE=CODE)
   ENDSUBROUTINE B64_ENCODE_I8_A

   PURE SUBROUTINE B64_ENCODE_I4_A(N, CODE)
   !< ENCODE ARRAY NUMBERS TO BASE64 (I4P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(LEN=:), ALLOCATABLE :: CODE64
   !< CALL B64_ENCODE(N=[2023_I4P,-24_I4P], CODE=CODE64)
   !< PRINT "(A)", CODE64
   !<```
   !=> 5WCAAOJ///8= <<<
   INTEGER(I4P),                  INTENT(IN)  :: N(1:)   !< ARRAY OF NUMBERS TO BE ENCODED.
   CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: CODE    !< ENCODED ARRAY.
   INTEGER(I1P),     ALLOCATABLE              :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.
   INTEGER(I4P)                               :: PADD    !< NUMBER OF PADDING CHARACTERS ('=').
   INTEGER(I8P)                               :: NS      !< SIZE OF N.

   NS = SIZE(N,DIM=1)
   ALLOCATE(NI1P(1:((NS*BYI4P+2)/3)*3)) ; NI1P = 0_I1P
   CODE = REPEAT(' ',((NS*BYI4P+2)/3)*4)
   NI1P = TRANSFER(N,NI1P)
   PADD = INT(MOD((NS*BYI4P),3_I8P),I4P) ; IF (PADD>0_I4P) PADD = 3_I4P - PADD
   CALL ENCODE_BITS(BITS=NI1P,PADD=PADD,CODE=CODE)
   ENDSUBROUTINE B64_ENCODE_I4_A

   PURE SUBROUTINE B64_ENCODE_I2_A(N, CODE)
   !< ENCODE ARRAY NUMBERS TO BASE64 (I2P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(LEN=:), ALLOCATABLE :: CODE64
   !< CALL B64_ENCODE(N=[-203_I2P,-10_I2P], CODE=CODE64)
   !< PRINT "(A)", CODE64
   !<```
   !=> NF/2/W== <<<
   INTEGER(I2P),                  INTENT(IN)  :: N(1:)   !< ARRAY OF NUMBERS TO BE ENCODED.
   CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: CODE    !< ENCODED ARRAY.
   INTEGER(I1P),     ALLOCATABLE              :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.
   INTEGER(I4P)                               :: PADD    !< NUMBER OF PADDING CHARACTERS ('=').
   INTEGER(I8P)                               :: NS      !< SIZE OF N.

   NS = SIZE(N,DIM=1)
   ALLOCATE(NI1P(1:((NS*BYI2P+2)/3)*3)) ; NI1P = 0_I1P
   CODE = REPEAT(' ',((NS*BYI2P+2)/3)*4)
   NI1P = TRANSFER(N,NI1P)
   PADD = INT(MOD((NS*BYI2P),3_I8P),I4P) ; IF (PADD>0_I4P) PADD = 3_I4P - PADD
   CALL ENCODE_BITS(BITS=NI1P,PADD=PADD,CODE=CODE)
   ENDSUBROUTINE B64_ENCODE_I2_A

   PURE SUBROUTINE B64_ENCODE_I1_A(N, CODE)
   !< ENCODE ARRAY NUMBERS TO BASE64 (I1P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(LEN=:), ALLOCATABLE :: CODE64
   !< CALL B64_ENCODE(N=[120_I1P,-1_I1P], CODE=CODE64)
   !< PRINT "(A)", CODE64
   !<```
   !=> EP8= <<<
   INTEGER(I1P),                  INTENT(IN)  :: N(1:)   !< ARRAY OF NUMBERS TO BE ENCODED.
   CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: CODE    !< ENCODED ARRAY.
   INTEGER(I1P),     ALLOCATABLE              :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.
   INTEGER(I4P)                               :: PADD    !< NUMBER OF PADDING CHARACTERS ('=').
   INTEGER(I8P)                               :: NS      !< SIZE OF N.

   NS = SIZE(N,DIM=1)
   ALLOCATE(NI1P(1:((NS*BYI1P+2)/3)*3)) ; NI1P = 0_I1P
   CODE = REPEAT(' ',((NS*BYI1P+2)/3)*4)
   NI1P = TRANSFER(N,NI1P)
   PADD = INT(MOD((NS*BYI1P),3_I8P),I4P) ; IF (PADD>0_I4P) PADD = 3_I4P - PADD
   CALL ENCODE_BITS(BITS=NI1P,PADD=PADD,CODE=CODE)
   ENDSUBROUTINE B64_ENCODE_I1_A

   PURE SUBROUTINE B64_ENCODE_STRING_A(S, CODE)
   !< ENCODE ARRAY STRING TO BASE64.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(LEN=:), ALLOCATABLE :: CODE64
   !< CALL B64_ENCODE(S=['HELLO','WORLD'], CODE=CODE64)
   !< PRINT "(A)", CODE64
   !<```
   !=> AGVSBG93B3JSZA== <<<
   CHARACTER(*),                  INTENT(IN)  :: S(1:)   !< STRING TO BE ENCODED.
   CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: CODE    !< ENCODED SCALAR.
   INTEGER(I1P),     ALLOCATABLE              :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.
   INTEGER(I4P)                               :: PADD    !< NUMBER OF PADDING CHARACTERS ('=').
   INTEGER(I4P)                               :: BYCHS   !< BYTES OF CHARACTER STRING.

   BYCHS = BYTE_SIZE(S(1))*SIZE(S,DIM=1)
   ALLOCATE(NI1P(1:((BYCHS+2)/3)*3)) ; NI1P = 0_I1P
   CODE = REPEAT(' ',((BYCHS+2)/3)*4)
   NI1P = TRANSFER(S,NI1P)
   PADD = MOD((BYCHS),3_I4P) ; IF (PADD>0_I4P) PADD = 3_I4P - PADD
   CALL ENCODE_BITS(BITS=NI1P,PADD=PADD,CODE=CODE)
   ENDSUBROUTINE B64_ENCODE_STRING_A

   ELEMENTAL SUBROUTINE B64_DECODE_R16(CODE, N)
   !< DECODE A BASE64 CODE INTO A SCALAR NUMBER (R16P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< REAL(R16P) :: SCALAR_R16
   !< CALL B64_DECODE(CODE='CKWCWMTHYEA=',N=SCALAR_R16)
   !< PRINT "(L1)", SCALAR_R16==134.231_R16P
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN)  :: CODE    !< ENCODED SCALAR.
   REAL(R16P),   INTENT(OUT) :: N       !< NUMBER TO BE DECODED.
   INTEGER(I1P), ALLOCATABLE :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.

   ALLOCATE(NI1P(1:BYR16P)) ; NI1P = 0_I1P
   CALL DECODE_BITS(CODE=CODE,BITS=NI1P)
   N = TRANSFER(NI1P,N)
   ENDSUBROUTINE B64_DECODE_R16

   ELEMENTAL SUBROUTINE B64_DECODE_R8(CODE, N)
   !< DECODE A BASE64 CODE INTO A SCALAR NUMBER (R8P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< REAL(R8P) :: SCALAR_R8
   !< CALL B64_DECODE(CODE='AAAAAAAA8D8=',N=SCALAR_R8)
   !< PRINT "(L1)", SCALAR_R8==1._R8P
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN)  :: CODE    !< ENCODED SCALAR.
   REAL(R8P),    INTENT(OUT) :: N       !< NUMBER TO BE DECODED.
   INTEGER(I1P), ALLOCATABLE :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.

   ALLOCATE(NI1P(1:BYR8P)) ; NI1P = 0_I1P
   CALL DECODE_BITS(CODE=CODE,BITS=NI1P)
   N = TRANSFER(NI1P,N)
   ENDSUBROUTINE B64_DECODE_R8

   ELEMENTAL SUBROUTINE B64_DECODE_R4(CODE, N)
   !< DECODE A BASE64 CODE INTO A SCALAR NUMBER (R4P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< REAL(R4P) :: SCALAR_R4
   !< CALL B64_DECODE(CODE='AAAAAA==',N=SCALAR_R4)
   !< PRINT "(L1)", SCALAR_R4==0._R4P
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN)  :: CODE    !< ENCODED SCALAR.
   REAL(R4P),    INTENT(OUT) :: N       !< NUMBER TO BE DECODED.
   INTEGER(I1P), ALLOCATABLE :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.

   ALLOCATE(NI1P(1:BYR4P)) ; NI1P = 0_I1P
   CALL DECODE_BITS(CODE=CODE,BITS=NI1P)
   N = TRANSFER(NI1P,N)
   ENDSUBROUTINE B64_DECODE_R4

   ELEMENTAL SUBROUTINE B64_DECODE_I8(CODE, N)
   !< DECODE A BASE64 CODE INTO A SCALAR NUMBER (I8P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I8P) :: SCALAR_I8
   !< CALL B64_DECODE(CODE='FWAAAAAAAAA=',N=SCALAR_I8)
   !< PRINT "(L1)", SCALAR_I8==23_I8P
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN)  :: CODE    !< ENCODED SCALAR.
   INTEGER(I8P), INTENT(OUT) :: N       !< NUMBER TO BE DECODED.
   INTEGER(I1P), ALLOCATABLE :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.

   ALLOCATE(NI1P(1:BYI8P)) ; NI1P = 0_I1P
   CALL DECODE_BITS(CODE=CODE,BITS=NI1P)
   N = TRANSFER(NI1P,N)
   ENDSUBROUTINE B64_DECODE_I8

   ELEMENTAL SUBROUTINE B64_DECODE_I4(CODE, N)
   !< DECODE A BASE64 CODE INTO A SCALAR NUMBER (I4P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I4P) :: SCALAR_I4
   !< CALL B64_DECODE(CODE='5WCAAA==',N=SCALAR_I4)
   !< PRINT "(L1)", SCALAR_I4==2023_I4P
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN)  :: CODE    !< ENCODED SCALAR.
   INTEGER(I4P), INTENT(OUT) :: N       !< NUMBER TO BE DECODED.
   INTEGER(I1P), ALLOCATABLE :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.

   ALLOCATE(NI1P(1:BYI4P)) ; NI1P = 0_I1P
   CALL DECODE_BITS(CODE=CODE,BITS=NI1P)
   N = TRANSFER(NI1P,N)
   ENDSUBROUTINE B64_DECODE_I4

   ELEMENTAL SUBROUTINE B64_DECODE_I2(CODE, N)
   !< DECODE A BASE64 CODE INTO A SCALAR NUMBER (I2P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I2P) :: SCALAR_I2
   !< CALL B64_DECODE(CODE='NF8=',N=SCALAR_I2)
   !< PRINT "(L1)", SCALAR_I2==-203_I2P
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN)  :: CODE    !< ENCODED SCALAR.
   INTEGER(I2P), INTENT(OUT) :: N       !< NUMBER TO BE DECODED.
   INTEGER(I1P), ALLOCATABLE :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.

   ALLOCATE(NI1P(1:BYI2P)) ; NI1P = 0_I1P
   CALL DECODE_BITS(CODE=CODE,BITS=NI1P)
   N = TRANSFER(NI1P,N)
   ENDSUBROUTINE B64_DECODE_I2

   ELEMENTAL SUBROUTINE B64_DECODE_I1(CODE, N)
   !< DECODE A BASE64 CODE INTO A SCALAR NUMBER (I1P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I1P) :: SCALAR_I1
   !< CALL B64_DECODE(CODE='EA==',N=SCALAR_I1)
   !< PRINT "(L1)", SCALAR_I1==120_I1P
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN)  :: CODE    !< ENCODED SCALAR.
   INTEGER(I1P), INTENT(OUT) :: N       !< NUMBER TO BE DECODED.
   INTEGER(I1P), ALLOCATABLE :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.

   ALLOCATE(NI1P(1:BYI1P)) ; NI1P = 0_I1P
   CALL DECODE_BITS(CODE=CODE,BITS=NI1P)
   N = TRANSFER(NI1P,N)
   ENDSUBROUTINE B64_DECODE_I1

   ELEMENTAL SUBROUTINE B64_DECODE_STRING(CODE, S)
   !< DECODE A BASE64 CODE INTO A SCALAR STRING.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(:), ALLOCATABLE :: CODE64
   !< CODE64 = REPEAT(' ',5)
   !< CALL B64_DECODE(CODE='AGVSBG8=',S=CODE64)
   !< PRINT "(L1)", CODE64=='HELLO'
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN)  :: CODE    !< ENCODED SCALAR.
   CHARACTER(*), INTENT(OUT) :: S       !< STRING TO BE DECODED.
   INTEGER(I1P), ALLOCATABLE :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.

   ALLOCATE(NI1P(1:BYTE_SIZE(S))) ; NI1P = 0_I1P
   CALL DECODE_BITS(CODE=CODE,BITS=NI1P)
   S = TRANSFER(NI1P,S)
   ENDSUBROUTINE B64_DECODE_STRING

   PURE SUBROUTINE B64_DECODE_R16_A(CODE, N)
   !< DECODE A BASE64 CODE INTO AN ARRAY NUMBERS (R16P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< REAL(R16P) :: ARRAY_R16(1:2)
   !< CALL B64_DECODE(CODE='AAAAAABAXKCPWVUOXI8CQA==',N=ARRAY_R16)
   !< PRINT "(L1)", STR(N=ARRAY_R16)==STR(N=[121._R16P,2.32_R16P])
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN)  :: CODE    !< ENCODED ARRAY.
   REAL(R16P),   INTENT(OUT) :: N(1:)   !< ARRAY OF NUMBERS TO BE DECODED.
   INTEGER(I1P), ALLOCATABLE :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.

   ALLOCATE(NI1P(1:SIZE(N,DIM=1)*BYR16P)) ; NI1P = 0_I1P
   CALL DECODE_BITS(CODE=CODE,BITS=NI1P)
   N = TRANSFER(NI1P,N)
   ENDSUBROUTINE B64_DECODE_R16_A

   PURE SUBROUTINE B64_DECODE_R8_A(CODE, N)
   !< DECODE A BASE64 CODE INTO AN ARRAY NUMBERS (R8P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< REAL(R8P) :: ARRAY_R8(1:2)
   !< CALL B64_DECODE(CODE='AAAAAAAA8D8AAAAAAAAAQA==',N=ARRAY_R8)
   !< PRINT "(L1)", STR(N=ARRAY_R8)==STR(N=[1._R8P,2._R8P])
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN)  :: CODE    !< ENCODED ARRAY.
   REAL(R8P),    INTENT(OUT) :: N(1:)   !< ARRAY OF NUMBERS TO BE DECODED.
   INTEGER(I1P), ALLOCATABLE :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.

   ALLOCATE(NI1P(1:SIZE(N,DIM=1)*BYR8P)) ; NI1P = 0_I1P
   CALL DECODE_BITS(CODE=CODE,BITS=NI1P)
   N = TRANSFER(NI1P,N)
   ENDSUBROUTINE B64_DECODE_R8_A

   PURE SUBROUTINE B64_DECODE_R4_A(CODE, N)
   !< DECODE A BASE64 CODE INTO AN ARRAY NUMBERS (R4P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< REAL(R4P) :: ARRAY_R4(1:2)
   !< CALL B64_DECODE(CODE='AAAAAOF6AMI=',N=ARRAY_R4)
   !< PRINT "(L1)", STR(N=ARRAY_R4)==STR(N=[0._R4P,-32.12_R4P])
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN)  :: CODE    !< ENCODED ARRAY.
   REAL(R4P),    INTENT(OUT) :: N(1:)   !< ARRAY OF NUMBERS TO BE DECODED.
   INTEGER(I1P), ALLOCATABLE :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.

   ALLOCATE(NI1P(1:SIZE(N,DIM=1)*BYR4P)) ; NI1P = 0_I1P
   CALL DECODE_BITS(CODE=CODE,BITS=NI1P)
   N = TRANSFER(NI1P,N)
   ENDSUBROUTINE B64_DECODE_R4_A

   PURE SUBROUTINE B64_DECODE_I8_A(CODE, N)
   !< DECODE A BASE64 CODE INTO AN ARRAY NUMBERS (I8P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I8P) :: ARRAY_I8(1:4)
   !< CALL B64_DECODE(CODE='FWAAAAAAAABEAQAAAAAAABBWHAEAAAAAAGAAAAAAAAA=',N=ARRAY_I8)
   !< PRINT "(L1)", STR(N=ARRAY_I8)==STR(N=[23_I8P,324_I8P,25456656_I8P,2_I8P])
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN)  :: CODE    !< ENCODED ARRAY.
   INTEGER(I8P), INTENT(OUT) :: N(1:)   !< ARRAY OF NUMBERS TO BE DECODED.
   INTEGER(I1P), ALLOCATABLE :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.

   ALLOCATE(NI1P(1:SIZE(N,DIM=1)*BYI8P)) ; NI1P = 0_I1P
   CALL DECODE_BITS(CODE=CODE,BITS=NI1P)
   N = TRANSFER(NI1P,N)
   ENDSUBROUTINE B64_DECODE_I8_A

   PURE SUBROUTINE B64_DECODE_I4_A(CODE, N)
   !< DECODE A BASE64 CODE INTO AN ARRAY NUMBERS (I4P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I4P) :: ARRAY_I4(1:2)
   !< CALL B64_DECODE(CODE='5WCAAOJ///8=',N=ARRAY_I4)
   !< PRINT "(L1)", STR(N=ARRAY_I4)==STR(N=[2023_I4P,-24_I4P])
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN)  :: CODE    !< ENCODED ARRAY.
   INTEGER(I4P), INTENT(OUT) :: N(1:)   !< ARRAY OF NUMBERS TO BE DECODED.
   INTEGER(I1P), ALLOCATABLE :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.

   ALLOCATE(NI1P(1:SIZE(N,DIM=1)*BYI4P)) ; NI1P = 0_I1P
   CALL DECODE_BITS(CODE=CODE,BITS=NI1P)
   N = TRANSFER(NI1P,N)
   ENDSUBROUTINE B64_DECODE_I4_A

   PURE SUBROUTINE B64_DECODE_I2_A(CODE, N)
   !< DECODE A BASE64 CODE INTO AN ARRAY NUMBERS (I2P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I2P) :: ARRAY_I2(1:2)
   !< CALL B64_DECODE(CODE='NF/2/W==',N=ARRAY_I2)
   !< PRINT "(L1)", STR(N=ARRAY_I2)==STR(N=[-203_I2P,-10_I2P])
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN)  :: CODE    !< ENCODED ARRAY.
   INTEGER(I2P), INTENT(OUT) :: N(1:)   !< ARRAY OF NUMBERS TO BE DECODED.
   INTEGER(I1P), ALLOCATABLE :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.

   ALLOCATE(NI1P(1:SIZE(N,DIM=1)*BYI2P)) ; NI1P = 0_I1P
   CALL DECODE_BITS(CODE=CODE,BITS=NI1P)
   N = TRANSFER(NI1P,N)
   ENDSUBROUTINE B64_DECODE_I2_A

   PURE SUBROUTINE B64_DECODE_I1_A(CODE, N)
   !< DECODE A BASE64 CODE INTO AN ARRAY NUMBERS (I1P).
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< INTEGER(I1P) :: ARRAY_I1(1:2)
   !< CALL B64_DECODE(CODE='EP8=',N=ARRAY_I1)
   !< PRINT "(L1)", STR(N=ARRAY_I1)==STR(N=[120_I1P,-1_I1P])
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN)  :: CODE    !< ENCODED ARRAY.
   INTEGER(I1P), INTENT(OUT) :: N(1:)   !< ARRAY OF NUMBERS TO BE DECODED.
   INTEGER(I1P), ALLOCATABLE :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.

   ALLOCATE(NI1P(1:SIZE(N,DIM=1)*BYI1P)) ; NI1P = 0_I1P
   CALL DECODE_BITS(CODE=CODE,BITS=NI1P)
   N = TRANSFER(NI1P,N)
   ENDSUBROUTINE B64_DECODE_I1_A

   PURE SUBROUTINE B64_DECODE_STRING_A(CODE, S)
   !< DECODE A BASE64 CODE INTO AN ARRAY OF STRINGS.
   !<
   !<```FORTRAN
   !< USE BEFOR64
   !< USE PENF
   !< CHARACTER(5) :: ARRAY_S(1:2)
   !< CALL B64_DECODE(CODE='AGVSBG93B3JSZA==',S=ARRAY_S)
   !< PRINT "(L1)", ARRAY_S(1)//ARRAY_S(2)=='HELLOWORLD'
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN)  :: CODE    !< ENCODED SCALAR.
   CHARACTER(*), INTENT(OUT) :: S(1:)   !< STRING TO BE DECODED.
   INTEGER(I1P), ALLOCATABLE :: NI1P(:) !< ONE BYTE INTEGER ARRAY CONTAINING N.

   ALLOCATE(NI1P(1:BYTE_SIZE(S(1))*SIZE(S,DIM=1))) ; NI1P = 0_I1P
   CALL DECODE_BITS(CODE=CODE,BITS=NI1P)
   S = TRANSFER(NI1P,S)
   ENDSUBROUTINE B64_DECODE_STRING_A
ENDMODULE BEFOR64










!< STRINGIFOR, DEFINITION OF `STRING` TYPE.
MODULE STRINGIFOR_STRING_T
!< STRINGIFOR, DEFINITION OF `STRING` TYPE.
USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY : IOSTAT_EOR
USE BEFOR64, ONLY : B64_DECODE, B64_ENCODE
USE PENF, ONLY : I1P, I2P, I4P, I8P, R4P, R8P, R16P, STR

IMPLICIT NONE
PRIVATE
SAVE
! EXPOSE STINGIFOR OVERLOADED BUILTINS AND OPERATORS
! PUBLIC :: ADJUSTL, ADJUSTR, COUNT, INDEX, LEN, LEN_TRIM, REPEAT, SCAN, TRIM, VERIFY
PUBLIC :: ADJUSTL, ADJUSTR, COUNT, INDEX, LEN_TRIM, REPEAT, SCAN, TRIM, VERIFY
! EXPOSE STINGIFOR OBJECTS
PUBLIC :: CK
PUBLIC :: GLOB
PUBLIC :: STRJOIN
PUBLIC :: STRING

INTEGER, PARAMETER :: CK = SELECTED_CHAR_KIND('DEFAULT') !< DEFAULT CHARACTER KIND.

TYPE :: STRING
  !< OOP DESIGNED STRING CLASS.
  CHARACTER(KIND=CK, LEN=:), ALLOCATABLE :: RAW !< RAW DATA.
  CONTAINS
    ! PUBLIC METHODS
    ! BUILTINS REPLACEMENTS
    PROCEDURE, PASS(SELF) :: ADJUSTL  => SADJUSTL                 !< ADJUSTL REPLACEMENT.
    PROCEDURE, PASS(SELF) :: ADJUSTR  => SADJUSTR                 !< ADJUSTR REPLACEMENT.
    PROCEDURE, PASS(SELF) :: COUNT    => SCOUNT                   !< COUNT REPLACEMENT.
    GENERIC               :: INDEX    => SINDEX_STRING_STRING, &
                                         SINDEX_STRING_CHARACTER  !< INDEX REPLACEMENT.
    PROCEDURE, PASS(SELF) :: LEN      => SLEN                     !< LEN REPLACEMENT.
    PROCEDURE, PASS(SELF) :: LEN_TRIM => SLEN_TRIM                !< LEN_TRIM REPLACEMENT.
    GENERIC               :: REPEAT   => SREPEAT_STRING_STRING, &
                                         SREPEAT_CHARACTER_STRING !< REPEAT REPLACEMENT.
    GENERIC               :: SCAN     => SSCAN_STRING_STRING,    &
                                         SSCAN_STRING_CHARACTER   !< SCAN REPLACEMENT.
    PROCEDURE, PASS(SELF) :: TRIM     => STRIM                    !< TRIM REPLACEMENT.
    GENERIC               :: VERIFY   => SVERIFY_STRING_STRING, &
                                         SVERIFY_STRING_CHARACTER !< VERIFY REPLACEMENT.
    ! AUXILIARY METHODS
    PROCEDURE, PASS(SELF) :: BASEDIR          !< RETURN THE BASE DIRECTORY NAME OF A STRING CONTAINING A FILE NAME.
    PROCEDURE, PASS(SELF) :: BASENAME         !< RETURN THE BASE FILE NAME OF A STRING CONTAINING A FILE NAME.
    PROCEDURE, PASS(SELF) :: CAMELCASE        !< RETURN A STRING WITH ALL WORDS CAPITALIZED WITHOUT SPACES.
    PROCEDURE, PASS(SELF) :: CAPITALIZE       !< RETURN A STRING WITH ITS FIRST CHARACTER CAPITALIZED AND THE REST LOWERCASED.
    PROCEDURE, PASS(SELF) :: CHARS            !< RETURN THE RAW CHARACTERS DATA.
    PROCEDURE, PASS(SELF) :: DECODE           !< DECODE STRING.
    PROCEDURE, PASS(SELF) :: ENCODE           !< ENCODE STRING.
    PROCEDURE, PASS(SELF) :: ESCAPE           !< ESCAPE BACKSLASHES (OR CUSTOM ESCAPE CHARACTER).
    PROCEDURE, PASS(SELF) :: EXTENSION        !< RETURN THE EXTENSION OF A STRING CONTAINING A FILE NAME.
    PROCEDURE, PASS(SELF) :: FILL             !< PAD STRING ON THE LEFT (OR RIGHT) WITH ZEROS (OR OTHER CHAR) TO FILL WIDTH.
    PROCEDURE, PASS(SELF) :: CUSTOMFREE             !< FREE DYNAMIC MEMORY.
    GENERIC               :: GLOB =>         &
                             GLOB_CHARACTER, &
                             GLOB_STRING      !< GLOB SEARCH, FINDS ALL THE PATHNAMES MATCHING A GIVEN PATTERN.
    GENERIC               :: INSERT =>      &
                             INSERT_STRING, &
                             INSERT_CHARACTER !< INSERT SUBSTRING INTO STRING AT A SPECIFIED POSITION.
    GENERIC               :: JOIN =>       &
                             JOIN_STRINGS, &
                             JOIN_CHARACTERS  !< RETURN A STRING THAT IS A JOIN OF AN ARRAY OF STRINGS OR CHARACTERS.
    GENERIC               :: STRJOIN =>   &
                             STRJOIN_STRINGS, &
                             STRJOIN_CHARACTERS, &
                             STRJOIN_STRINGS_ARRAY, &
                             STRJOIN_CHARACTERS_ARRAY  !< RETURN A STRING THAT IS A JOIN OF AN ARRAY OF STRINGS OR CHARACTERS;
                                                       !< RETURN JOIN 1D STRING ARRAY OF AN 2D ARRAY OF STRINGS OR CHARACTERS IN COLUMNS OR ROWS.
    PROCEDURE, PASS(SELF) :: LOWER            !< RETURN A STRING WITH ALL LOWERCASE CHARACTERS.
    PROCEDURE, PASS(SELF) :: PARTITION        !< SPLIT STRING AT SEPARATOR AND RETURN THE 3 PARTS (BEFORE, THE SEPARATOR AND AFTER).
    PROCEDURE, PASS(SELF) :: READ_FILE        !< READ A FILE A SINGLE STRING STREAM.
    PROCEDURE, PASS(SELF) :: READ_LINE        !< READ LINE (RECORD) FROM A CONNECTED UNIT.
    PROCEDURE, PASS(SELF) :: READ_LINES       !< READ (ALL) LINES (RECORDS) FROM A CONNECTED UNIT AS A SINGLE ASCII STREAM.
    PROCEDURE, PASS(SELF) :: REPLACE          !< RETURN A STRING WITH ALL OCCURRENCES OF SUBSTRING OLD REPLACED BY NEW.
    PROCEDURE, PASS(SELF) :: REVERSE          !< RETURN A REVERSED STRING.
    PROCEDURE, PASS(SELF) :: SEARCH           !< SEARCH FOR *TAGGED* RECORD INTO STRING.
    PROCEDURE, PASS(SELF) :: SLICE            !< RETURN THE RAW CHARACTERS DATA SLICED.
    PROCEDURE, PASS(SELF) :: SNAKECASE        !< RETURN A STRING WITH ALL WORDS LOWERCASE SEPARATED BY "_".
    PROCEDURE, PASS(SELF) :: SPLIT            !< RETURN A LIST OF SUBSTRING IN THE STRING, USING SEP AS THE DELIMITER STRING.
    PROCEDURE, PASS(SELF) :: SPLIT_CHUNKED    !< RETURN A LIST OF SUBSTRING IN THE STRING, USING SEP AS THE DELIMITER STRING.
    PROCEDURE, PASS(SELF) :: STARTCASE        !< RETURN A STRING WITH ALL WORDS CAPITALIZED, E.G. TITLE CASE.
    PROCEDURE, PASS(SELF) :: STRIP            !< RETURN A STRING WITH THE LEADING AND TRAILING CHARACTERS REMOVED.
    PROCEDURE, PASS(SELF) :: SWAPCASE         !< RETURN A STRING WITH UPPERCASE CHARS CONVERTED TO LOWERCASE AND VICE VERSA.
    PROCEDURE, PASS(SELF) :: TEMPNAME         !< RETURN A SAFE TEMPORARY NAME SUITABLE FOR TEMPORARY FILE OR DIRECTORIES.
    GENERIC               :: TO_NUMBER =>   &
                             TO_INTEGER_I1P,&
#ifndef _NVF
                             TO_INTEGER_I2P,&
#endif
                             TO_INTEGER_I4P,&
                             TO_INTEGER_I8P,&
#if defined _R16P
                             TO_REAL_R16P,  &
#endif
                             TO_REAL_R8P,   &
                             TO_REAL_R4P      !< CAST STRING TO NUMBER.
    PROCEDURE, PASS(SELF) :: UNESCAPE         !< UNESCAPE DOUBLE BACKSLASHES (OR CUSTOM ESCAPED CHARACTER).
    PROCEDURE, PASS(SELF) :: UNIQUE           !< REDUCE TO ONE (UNIQUE) MULTIPLE OCCURRENCES OF A SUBSTRING INTO A STRING.
    PROCEDURE, PASS(SELF) :: UPPER            !< RETURN A STRING WITH ALL UPPERCASE CHARACTERS.
    PROCEDURE, PASS(SELF) :: WRITE_FILE       !< WRITE A SINGLE STRING STREAM INTO FILE.
    PROCEDURE, PASS(SELF) :: WRITE_LINE       !< WRITE LINE (RECORD) TO A CONNECTED UNIT.
    PROCEDURE, PASS(SELF) :: WRITE_LINES      !< WRITE LINES (RECORDS) TO A CONNECTED UNIT.
    ! INQUIRE METHODS
    PROCEDURE, PASS(SELF) :: END_WITH     !< RETURN TRUE IF A STRING ENDS WITH A SPECIFIED SUFFIX.
    PROCEDURE, PASS(SELF) :: IS_ALLOCATED !< RETURN TRUE IF THE STRING IS ALLOCATED.
    PROCEDURE, PASS(SELF) :: IS_DIGIT     !< RETURN TRUE IF ALL CHARACTERS IN THE STRING ARE DIGITS.
    PROCEDURE, PASS(SELF) :: IS_INTEGER   !< RETURN TRUE IF THE STRING CONTAINS AN INTEGER.
    PROCEDURE, PASS(SELF) :: IS_LOWER     !< RETURN TRUE IF ALL CHARACTERS IN THE STRING ARE LOWERCASE.
    PROCEDURE, PASS(SELF) :: IS_NUMBER    !< RETURN TRUE IF THE STRING CONTAINS A NUMBER (REAL OR INTEGER).
    PROCEDURE, PASS(SELF) :: IS_REAL      !< RETURN TRUE IF THE STRING CONTAINS AN REAL.
    PROCEDURE, PASS(SELF) :: IS_UPPER     !< RETURN TRUE IF ALL CHARACTERS IN THE STRING ARE UPPERCASE.
    PROCEDURE, PASS(SELF) :: START_WITH   !< RETURN TRUE IF A STRING STARTS WITH A SPECIFIED PREFIX.
    ! OPERATORS
    GENERIC :: ASSIGNMENT(=) => STRING_ASSIGN_STRING,      &
                                STRING_ASSIGN_CHARACTER,   &
                                STRING_ASSIGN_INTEGER_I1P, &
                                STRING_ASSIGN_INTEGER_I2P, &
                                STRING_ASSIGN_INTEGER_I4P, &
                                STRING_ASSIGN_INTEGER_I8P, &
#if defined _R16P
                                STRING_ASSIGN_REAL_R16P,   &
#endif
                                STRING_ASSIGN_REAL_R8P,    &
                                STRING_ASSIGN_REAL_R4P              !< ASSIGNMENT OPERATOR OVERLOADING.
    GENERIC :: OPERATOR(//) => STRING_CONCAT_STRING,    &
                               STRING_CONCAT_CHARACTER, &
                               CHARACTER_CONCAT_STRING              !< CONCATENATION OPERATOR OVERLOADING.
    GENERIC :: OPERATOR(.CAT.) => STRING_CONCAT_STRING_STRING,    &
                                  STRING_CONCAT_CHARACTER_STRING, &
                                  CHARACTER_CONCAT_STRING_STRING    !< CONCATENATION OPERATOR (STRING OUTPUT) OVERLOADING.
    GENERIC :: OPERATOR(==) => STRING_EQ_STRING,    &
                               STRING_EQ_CHARACTER, &
                               CHARACTER_EQ_STRING                  !< EQUAL OPERATOR OVERLOADING.
    GENERIC :: OPERATOR(/=) => STRING_NE_STRING,    &
                               STRING_NE_CHARACTER, &
                               CHARACTER_NE_STRING                  !< NOT EQUAL OPERATOR OVERLOADING.
    GENERIC :: OPERATOR(<) => STRING_LT_STRING,    &
                              STRING_LT_CHARACTER, &
                              CHARACTER_LT_STRING                   !< LOWER THAN OPERATOR OVERLOADING.
    GENERIC :: OPERATOR(<=) => STRING_LE_STRING,    &
                               STRING_LE_CHARACTER, &
                               CHARACTER_LE_STRING                  !< LOWER EQUAL THAN OPERATOR OVERLOADING.
    GENERIC :: OPERATOR(>=) => STRING_GE_STRING,    &
                               STRING_GE_CHARACTER, &
                               CHARACTER_GE_STRING                  !< GREATER EQUAL THAN OPERATOR OVERLOADING.
    GENERIC :: OPERATOR(>) => STRING_GT_STRING,    &
                              STRING_GT_CHARACTER, &
                              CHARACTER_GT_STRING                   !< GREATER THAN OPERATOR OVERLOADING.
    ! IO
    GENERIC :: READ(FORMATTED) => READ_FORMATTED       !< FORMATTED INPUT.
    GENERIC :: WRITE(FORMATTED) => WRITE_FORMATTED     !< FORMATTED OUTPUT.
    GENERIC :: READ(UNFORMATTED) => READ_UNFORMATTED   !< UNFORMATTED INPUT.
    GENERIC :: WRITE(UNFORMATTED) => WRITE_UNFORMATTED !< UNFORMATTED OUTPUT.
    ! PRIVATE METHODS
    ! BUILTINS REPLACEMENTS
    PROCEDURE, PRIVATE, PASS(SELF) :: SINDEX_STRING_STRING     !< INDEX REPLACEMENT.
    PROCEDURE, PRIVATE, PASS(SELF) :: SINDEX_STRING_CHARACTER  !< INDEX REPLACEMENT.
    PROCEDURE, PRIVATE, PASS(SELF) :: SREPEAT_STRING_STRING    !< REPEAT REPLACEMENT.
    PROCEDURE, PRIVATE, NOPASS     :: SREPEAT_CHARACTER_STRING !< REPEAT REPLACEMENT.
    PROCEDURE, PRIVATE, PASS(SELF) :: SSCAN_STRING_STRING      !< SCAN REPLACEMENT.
    PROCEDURE, PRIVATE, PASS(SELF) :: SSCAN_STRING_CHARACTER   !< SCAN REPLACEMENT.
    PROCEDURE, PRIVATE, PASS(SELF) :: SVERIFY_STRING_STRING    !< VERIFY REPLACEMENT.
    PROCEDURE, PRIVATE, PASS(SELF) :: SVERIFY_STRING_CHARACTER !< VERIFY REPLACEMENT.
    ! AUXILIARY METHODS
    PROCEDURE, PRIVATE, PASS(SELF) :: GLOB_CHARACTER   !< GLOB SEARCH (CHARACTER OUTPUT).
    PROCEDURE, PRIVATE, PASS(SELF) :: GLOB_STRING      !< GLOB SEARCH (STRING OUTPUT).
    PROCEDURE, PRIVATE, PASS(SELF) :: INSERT_STRING    !< INSERT SUBSTRING INTO STRING AT A SPECIFIED POSITION.
    PROCEDURE, PRIVATE, PASS(SELF) :: INSERT_CHARACTER !< INSERT SUBSTRING INTO STRING AT A SPECIFIED POSITION.
    PROCEDURE, PRIVATE, PASS(SELF) :: JOIN_STRINGS     !< RETURN JOIN STRING OF AN ARRAY OF STRINGS.
    PROCEDURE, PRIVATE, PASS(SELF) :: JOIN_CHARACTERS  !< RETURN JOIN STRING OF AN ARRAY OF CHARACTERS.
    PROCEDURE, PRIVATE, NOPASS :: STRJOIN_STRINGS  !< RETURN JOIN STRING OF AN ARRAY OF STRINGS.
    PROCEDURE, PRIVATE, NOPASS :: STRJOIN_CHARACTERS        !< RETURN JOIN STRING OF AN ARRAY OF STRINGS.
    PROCEDURE, PRIVATE, NOPASS :: STRJOIN_STRINGS_ARRAY     !< RETURN JOIN 1D STRING ARRAY OF AN 2D ARRAY OF STRINGS IN C OR R.
    PROCEDURE, PRIVATE, NOPASS :: STRJOIN_CHARACTERS_ARRAY  !< RETURN JOIN 1D STRING ARRAY OF AN 2D ARRAY OF CHARACTERS IN C OR R.
    PROCEDURE, PRIVATE, PASS(SELF) :: TO_INTEGER_I1P   !< CAST STRING TO INTEGER.
#ifndef _NVF
    PROCEDURE, PRIVATE, PASS(SELF) :: TO_INTEGER_I2P   !< CAST STRING TO INTEGER.
#endif
    PROCEDURE, PRIVATE, PASS(SELF) :: TO_INTEGER_I4P   !< CAST STRING TO INTEGER.
    PROCEDURE, PRIVATE, PASS(SELF) :: TO_INTEGER_I8P   !< CAST STRING TO INTEGER.
    PROCEDURE, PRIVATE, PASS(SELF) :: TO_REAL_R4P      !< CAST STRING TO REAL.
    PROCEDURE, PRIVATE, PASS(SELF) :: TO_REAL_R8P      !< CAST STRING TO REAL.
    PROCEDURE, PRIVATE, PASS(SELF) :: TO_REAL_R16P     !< CAST STRING TO REAL.
    ! ASSIGNMENTS
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_ASSIGN_STRING      !< ASSIGNMENT OPERATOR FROM STRING INPUT.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_ASSIGN_CHARACTER   !< ASSIGNMENT OPERATOR FROM CHARACTER INPUT.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_ASSIGN_INTEGER_I1P !< ASSIGNMENT OPERATOR FROM INTEGER INPUT.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_ASSIGN_INTEGER_I2P !< ASSIGNMENT OPERATOR FROM INTEGER INPUT.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_ASSIGN_INTEGER_I4P !< ASSIGNMENT OPERATOR FROM INTEGER INPUT.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_ASSIGN_INTEGER_I8P !< ASSIGNMENT OPERATOR FROM INTEGER INPUT.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_ASSIGN_REAL_R4P    !< ASSIGNMENT OPERATOR FROM REAL INPUT.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_ASSIGN_REAL_R8P    !< ASSIGNMENT OPERATOR FROM REAL INPUT.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_ASSIGN_REAL_R16P   !< ASSIGNMENT OPERATOR FROM REAL INPUT.
    ! CONCATENATION OPERATORS
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_CONCAT_STRING           !< CONCATENATION WITH STRING.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_CONCAT_CHARACTER        !< CONCATENATION WITH CHARACTER.
    PROCEDURE, PRIVATE, PASS(RHS) :: CHARACTER_CONCAT_STRING        !< CONCATENATION WITH CHARACTER (INVERTED).
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_CONCAT_STRING_STRING    !< CONCATENATION WITH STRING (STRING OUTPUT).
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_CONCAT_CHARACTER_STRING !< CONCATENATION WITH CHARACTER (STRING OUTPUT).
    PROCEDURE, PRIVATE, PASS(RHS) :: CHARACTER_CONCAT_STRING_STRING !< CONCATENATION WITH CHARACTER (INVERTED, STRING OUTPUT).
    ! LOGICAL OPERATORS
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_EQ_STRING    !< EQUAL TO STRING LOGICAL OPERATOR.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_EQ_CHARACTER !< EQUAL TO CHARACTER LOGICAL OPERATOR.
    PROCEDURE, PRIVATE, PASS(RHS) :: CHARACTER_EQ_STRING !< EQUAL TO CHARACTER (INVERTED) LOGICAL OPERATOR.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_NE_STRING    !< NOT EQUAL TO STRING LOGICAL OPERATOR.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_NE_CHARACTER !< NOT EQUAL TO CHARACTER LOGICAL OPERATOR.
    PROCEDURE, PRIVATE, PASS(RHS) :: CHARACTER_NE_STRING !< NOT EQUAL TO CHARACTER (INVERTED) LOGICAL OPERATOR.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_LT_STRING    !< LOWER THAN TO STRING LOGICAL OPERATOR.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_LT_CHARACTER !< LOWER THAN TO CHARACTER LOGICAL OPERATOR.
    PROCEDURE, PRIVATE, PASS(RHS) :: CHARACTER_LT_STRING !< LOWER THAN TO CHARACTER (INVERTED) LOGICAL OPERATOR.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_LE_STRING    !< LOWER EQUAL THAN TO STRING LOGICAL OPERATOR.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_LE_CHARACTER !< LOWER EQUAL THAN TO CHARACTER LOGICAL OPERATOR.
    PROCEDURE, PRIVATE, PASS(RHS) :: CHARACTER_LE_STRING !< LOWER EQUAL THAN TO CHARACTER (INVERTED) LOGICAL OPERATOR.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_GE_STRING    !< GREATER EQUAL THAN TO STRING LOGICAL OPERATOR.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_GE_CHARACTER !< GREATER EQUAL THAN TO CHARACTER LOGICAL OPERATOR.
    PROCEDURE, PRIVATE, PASS(RHS) :: CHARACTER_GE_STRING !< GREATER EQUAL THAN TO CHARACTER (INVERTED) LOGICAL OPERATOR.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_GT_STRING    !< GREATER THAN TO STRING LOGICAL OPERATOR.
    PROCEDURE, PRIVATE, PASS(LHS) :: STRING_GT_CHARACTER !< GREATER THAN TO CHARACTER LOGICAL OPERATOR.
    PROCEDURE, PRIVATE, PASS(RHS) :: CHARACTER_GT_STRING !< GREATER THAN TO CHARACTER (INVERTED) LOGICAL OPERATOR.
    ! IO
    PROCEDURE, PRIVATE, PASS(DTV) :: READ_FORMATTED                !< FORMATTED INPUT.
    PROCEDURE, PRIVATE, PASS(DTV) :: READ_DELIMITED                !< READ A DELIMITED INPUT.
    PROCEDURE, PRIVATE, PASS(DTV) :: READ_UNDELIMITED              !< READ AN UNDELIMITED INPUT.
    PROCEDURE, PRIVATE, PASS(DTV) :: READ_UNDELIMITED_LISTDIRECTED !< READ AN UNDELIMITED LIST DIRECTED INPUT.
    PROCEDURE, PRIVATE, PASS(DTV) :: WRITE_FORMATTED               !< FORMATTED OUTPUT.
    PROCEDURE, PRIVATE, PASS(DTV) :: READ_UNFORMATTED              !< UNFORMATTED INPUT.
    PROCEDURE, PRIVATE, PASS(DTV) :: WRITE_UNFORMATTED             !< UNFORMATTED OUTPUT.
    ! MISCELLANEA
    PROCEDURE, PRIVATE, PASS(SELF) :: REPLACE_ONE_OCCURRENCE !< REPLACE THE FIRST OCCURRENCE OF SUBSTRING OLD BY NEW.
ENDTYPE STRING

! INTERNAL PARAMETERS
CHARACTER(KIND=CK, LEN=26), PARAMETER :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< UPPER CASE ALPHABET.
CHARACTER(KIND=CK, LEN=26), PARAMETER :: LOWER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< LOWER CASE ALPHABET.
CHARACTER(KIND=CK, LEN=1),  PARAMETER :: SPACE          = ' '                          !< SPACE CHARACTER.
CHARACTER(KIND=CK, LEN=1),  PARAMETER :: TAB            = ACHAR(9)                     !< TAB CHARACTER.
CHARACTER(KIND=CK, LEN=1),  PARAMETER :: UIX_DIR_SEP    = CHAR(47)                     !< UNIX/LINUX DIRECTORIES SEPARATOR (/).
CHARACTER(KIND=CK, LEN=1),  PARAMETER :: BACKSLASH      = CHAR(92)                     !< BACKSLASH CHARACTER.

INTERFACE GLOB
  !< OVERLOADING GLOB PROCEDURE.
  !<```FORTRAN
  !< TYPE(STRING)                  :: ASTRING
  !< CHARACTER(LEN=:), ALLOCATABLE :: ALIST_CHR(:)
  !< TYPE(STRING),     ALLOCATABLE :: ALIST_STR(:)
  !< INTEGER, PARAMETER            :: NF=5
  !< CHARACTER(14)                 :: FILES(1:NF)
  !< INTEGER                       :: FILE_UNIT
  !< INTEGER                       :: F
  !< INTEGER                       :: FF
  !< LOGICAL                       :: TEST_PASSED
  !< DO F=1, NF
  !<    FILES(F) = ASTRING%TEMPNAME(PREFIX='FOO-')
  !<    OPEN(NEWUNIT=FILE_UNIT, FILE=FILES(F))
  !<    WRITE(FILE_UNIT, *)F
  !<    CLOSE(UNIT=FILE_UNIT)
  !< ENDDO
  !< CALL GLOB(SELF=ASTRING, PATTERN='FOO-*', LIST=ALIST_CHR)
  !< CALL GLOB(SELF=ASTRING, PATTERN='FOO-*', LIST=ALIST_STR)
  !< DO F=1, NF
  !<    OPEN(NEWUNIT=FILE_UNIT, FILE=FILES(F))
  !<    CLOSE(UNIT=FILE_UNIT, STATUS='DELETE')
  !< ENDDO
  !< TEST_PASSED = .FALSE.
  !< OUTER_CHR: DO F=1, SIZE(ALIST_CHR, DIM=1)
  !<    DO FF=1, NF
  !<       TEST_PASSED = ALIST_CHR(F) == FILES(FF)
  !<       IF (TEST_PASSED) CYCLE OUTER_CHR
  !<    ENDDO
  !< ENDDO OUTER_CHR
  !< IF (TEST_PASSED) THEN
  !<    TEST_PASSED = .FALSE.
  !<    OUTER_STR: DO F=1, SIZE(ALIST_STR, DIM=1)
  !<       DO FF=1, NF
  !<          TEST_PASSED = ALIST_STR(F) == FILES(FF)
  !<          IF (TEST_PASSED) CYCLE OUTER_STR
  !<       ENDDO
  !<    ENDDO OUTER_STR
  !< ENDIF
  !< PRINT '(L1)', TEST_PASSED
  !<```
  !=> T <<<
  MODULE PROCEDURE GLOB_CHARACTER, GLOB_STRING
ENDINTERFACE GLOB

INTERFACE STRJOIN
  MODULE PROCEDURE STRJOIN_STRINGS, STRJOIN_CHARACTERS, STRJOIN_STRINGS_ARRAY, STRJOIN_CHARACTERS_ARRAY
ENDINTERFACE STRJOIN

! BUILTIN OVERLOADING
INTERFACE ADJUSTL
  !< BUILTIN ADJUSTL OVERLOADING.
  MODULE PROCEDURE SADJUSTL_CHARACTER
ENDINTERFACE ADJUSTL

INTERFACE ADJUSTR
  !< BUILTIN ADJUSTR OVERLOADING.
  MODULE PROCEDURE SADJUSTR_CHARACTER
ENDINTERFACE ADJUSTR

INTERFACE COUNT
  !< BUILTIN COUNT OVERLOADING.
  MODULE PROCEDURE COUNT_SUBSTRING
ENDINTERFACE

INTERFACE INDEX
  !< BUILTIN INDEX OVERLOADING.
  MODULE PROCEDURE SINDEX_STRING_STRING, SINDEX_STRING_CHARACTER, SINDEX_CHARACTER_STRING
ENDINTERFACE INDEX

!INTERFACE LEN
!  !< BUILTIN LEN OVERLOADING.
!  MODULE PROCEDURE SLEN
!ENDINTERFACE LEN

INTERFACE LEN_TRIM
  !< BUILTIN LEN_TRIM OVERLOADING.
  MODULE PROCEDURE SLEN_TRIM
ENDINTERFACE LEN_TRIM

INTERFACE REPEAT
  !< BUILTIN REPEAT OVERLOADING.
  MODULE PROCEDURE SREPEAT_STRING_STRING
ENDINTERFACE REPEAT

INTERFACE SCAN
  !< BUILTIN SCAN OVERLOADING.
  MODULE PROCEDURE SSCAN_STRING_STRING, SSCAN_STRING_CHARACTER, SSCAN_CHARACTER_STRING
ENDINTERFACE SCAN

INTERFACE TRIM
  !< BUILTIN TRIM OVERLOADING.
  MODULE PROCEDURE STRIM
ENDINTERFACE TRIM

INTERFACE VERIFY
  !< BUILTIN VERIFY OVERLOADING.
  MODULE PROCEDURE SVERIFY_STRING_STRING, SVERIFY_STRING_CHARACTER, SVERIFY_CHARACTER_STRING
ENDINTERFACE VERIFY

CONTAINS
   ! PUBLIC NON TBP

   ! CREATOR
   PURE FUNCTION STRING_(C)
   !< RETURN A STRING GIVEN A CHARACTER INPUT.
   !<
   !<```FORTRAN
   !< PRINT "(L1)", STRING('HELLO WORLD')//''=='HELLO WORLD'
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN) :: C       !< CHARACTER.
   TYPE(STRING)             :: STRING_ !< STRING.

   STRING_%RAW = C
   ENDFUNCTION STRING_

   ! BUILTINS REPLACEMENTS
   PURE FUNCTION SADJUSTL_CHARACTER(S) RESULT(ADJUSTED)
   !< LEFT ADJUST A STRING BY REMOVING LEADING SPACES (CHARACTER OUTPUT).
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< ASTRING = '   HELLO WORLD!'
   !< PRINT "(L1)", ADJUSTL(ASTRING)=='HELLO WORLD!   '
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN)              :: S        !< STRING.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE :: ADJUSTED !< ADJUSTED STRING.

   IF (ALLOCATED(S%RAW)) ADJUSTED = ADJUSTL(S%RAW)
   ENDFUNCTION SADJUSTL_CHARACTER

   PURE FUNCTION SADJUSTR_CHARACTER(S) RESULT(ADJUSTED)
   !< RIGHT ADJUST A STRING BY REMOVING LEADING SPACES (CHARACTER OUTPUT).
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< ASTRING = 'HELLO WORLD!   '
   !< PRINT "(L1)", ADJUSTR(ASTRING)=='   HELLO WORLD!'
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN)              :: S        !< STRING.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE :: ADJUSTED !< ADJUSTED STRING.

   IF (ALLOCATED(S%RAW)) ADJUSTED = ADJUSTR(S%RAW)
   ENDFUNCTION SADJUSTR_CHARACTER

   ELEMENTAL FUNCTION COUNT_SUBSTRING(S, SUBSTRING) RESULT(NO)
   !< COUNT THE NUMBER OF OCCURENCES OF A SUBSTRING INTO A STRING.
   !<
   !<```FORTRAN
   !< PRINT "(L1)", COUNT('HELLO', SUBSTRING='LL')==1
   !<```
   !=> T <<<
   CHARACTER(*), INTENT(IN) :: S         !< STRING.
   CHARACTER(*), INTENT(IN) :: SUBSTRING !< SUBSTRING.
   INTEGER(I4P)             :: NO        !< NUMBER OF OCCURRENCES.
   INTEGER(I4P)             :: C1        !< COUNTERS.
   INTEGER(I4P)             :: C2        !< COUNTERS.

   NO = 0
   IF (LEN(SUBSTRING) > LEN(S)) RETURN
   C1 = 1
   DO
     C2 = INDEX(STRING=S(C1:), SUBSTRING=SUBSTRING)
     IF (C2==0) RETURN
     NO = NO + 1
     C1 = C1 + C2 + LEN(SUBSTRING)
   ENDDO
   ENDFUNCTION COUNT_SUBSTRING

   ELEMENTAL FUNCTION SINDEX_CHARACTER_STRING(S, SUBSTRING, BACK) RESULT(I)
   !< RETURN THE POSITION OF THE START OF THE FIRST OCCURRENCE OF STRING `SUBSTRING` AS A SUBSTRING IN `STRING`, COUNTING FROM ONE.
   !< IF `SUBSTRING` IS NOT PRESENT IN `STRING`, ZERO IS RETURNED. IF THE BACK ARGUMENT IS PRESENT AND TRUE, THE RETURN VALUE IS
   !< THE START OF THE LAST OCCURRENCE RATHER THAN THE FIRST.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: STRING1
   !< LOGICAL      :: TEST_PASSED(2)
   !< STRING1 = 'LLO'
   !< TEST_PASSED(1) = INDEX(S='HELLO WORLD HELLO!', SUBSTRING=STRING1)==INDEX(STRING='HELLO WORLD HELLO!', SUBSTRING='LLO')
   !< TEST_PASSED(2) = INDEX(S='HELLO WORLD HELLO!', SUBSTRING=STRING1, BACK=.TRUE.)==INDEX(STRING='HELLO WORLD HELLO!', &
   !<                                                                                       SUBSTRING='LLO', BACK=.TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)           :: S         !< STRING.
   TYPE(STRING),              INTENT(IN)           :: SUBSTRING !< SEARCHED SUBSTRING.
   LOGICAL,                   INTENT(IN), OPTIONAL :: BACK      !< START OF THE LAST OCCURRENCE RATHER THAN THE FIRST.
   INTEGER                                         :: I         !< RESULT OF THE SEARCH.

   IF (ALLOCATED(SUBSTRING%RAW)) THEN
     I = INDEX(STRING=S, SUBSTRING=SUBSTRING%RAW, BACK=BACK)
   ELSE
     I = 0
   ENDIF
   ENDFUNCTION SINDEX_CHARACTER_STRING

   ELEMENTAL FUNCTION SSCAN_CHARACTER_STRING(S, SET, BACK) RESULT(I)
   !< RETURN THE LEFTMOST (IF BACK IS EITHER ABSENT OR EQUALS FALSE, OTHERWISE THE RIGHTMOST) CHARACTER OF STRING THAT IS IN SET.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: STRING1
   !< LOGICAL      :: TEST_PASSED(2)
   !< STRING1 = 'LLO'
   !< TEST_PASSED(1) = SCAN(S='HELLO WORLD HELLO!', SET=STRING1)==SCAN(STRING='HELLO WORLD HELLO!', SET='LLO')
   !< TEST_PASSED(2) = SCAN(S='HELLO WORLD HELLO!', SET=STRING1, BACK=.TRUE.)==SCAN(STRING='HELLO WORLD HELLO!', &
   !<                                                                               SET='LLO', BACK=.TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)           :: S    !< STRING.
   TYPE(STRING),              INTENT(IN)           :: SET  !< SEARCHED SET.
   LOGICAL,                   INTENT(IN), OPTIONAL :: BACK !< START OF THE LAST OCCURRENCE RATHER THAN THE FIRST.
   INTEGER                                         :: I    !< RESULT OF THE SEARCH.

   IF (ALLOCATED(SET%RAW)) THEN
     I = SCAN(STRING=S, SET=SET%RAW, BACK=BACK)
   ELSE
     I = 0
   ENDIF
   ENDFUNCTION SSCAN_CHARACTER_STRING

   ELEMENTAL FUNCTION SVERIFY_CHARACTER_STRING(S, SET, BACK) RESULT(I)
   !< RETURN THE LEFTMOST (IF `BACK` IS EITHER ABSENT OR EQUALS FALSE, OTHERWISE THE RIGHTMOST) CHARACTER OF STRING THAT IS NOT
   !< IN `SET`. IF ALL CHARACTERS OF `STRING` ARE FOUND IN `SET`, THE RESULT IS ZERO.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: STRING1
   !< LOGICAL      :: TEST_PASSED(2)
   !< STRING1 = 'ELL'
   !< TEST_PASSED(1) = VERIFY(S='HELLO WORLD HELLO!', SET=STRING1)==VERIFY(STRING='HELLO WORLD HELLO!', SET='LLO')
   !< TEST_PASSED(2) = VERIFY(S='HELLO WORLD HELLO!', SET=STRING1, BACK=.TRUE.)==VERIFY(STRING='HELLO WORLD HELLO!', SET='LLO', &
   !<                                                                                   BACK=.TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)           :: S    !< STRING.
   TYPE(STRING),              INTENT(IN)           :: SET  !< SEARCHED SET.
   LOGICAL,                   INTENT(IN), OPTIONAL :: BACK !< START OF THE LAST OCCURRENCE RATHER THAN THE FIRST.
   INTEGER                                         :: I    !< RESULT OF THE SEARCH.

   IF (ALLOCATED(SET%RAW)) THEN
     I = VERIFY(STRING=S, SET=SET%RAW, BACK=BACK)
   ELSE
     I = 0
   ENDIF
   ENDFUNCTION SVERIFY_CHARACTER_STRING

   ! PUBLIC METHODS

   ! BUILTINS REPLACEMENTS
   ELEMENTAL FUNCTION SADJUSTL(SELF) RESULT(ADJUSTED)
   !< LEFT ADJUST A STRING BY REMOVING LEADING SPACES.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< ASTRING = '   HELLO WORLD!'
   !< PRINT "(L1)", ASTRING%ADJUSTL()//''=='HELLO WORLD!   '
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF     !< THE STRING.
   TYPE(STRING)              :: ADJUSTED !< ADJUSTED STRING.

   ADJUSTED = SELF
   IF (ALLOCATED(ADJUSTED%RAW)) ADJUSTED%RAW = ADJUSTL(ADJUSTED%RAW)
   ENDFUNCTION SADJUSTL

   ELEMENTAL FUNCTION SADJUSTR(SELF) RESULT(ADJUSTED)
   !< RIGHT ADJUST A STRING BY REMOVING LEADING SPACES.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< ASTRING = 'HELLO WORLD!   '
   !< PRINT "(L1)", ASTRING%ADJUSTR()//''=='   HELLO WORLD!'
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF     !< THE STRING.
   TYPE(STRING)              :: ADJUSTED !< ADJUSTED STRING.

   ADJUSTED = SELF
   IF (ALLOCATED(ADJUSTED%RAW)) ADJUSTED%RAW = ADJUSTR(ADJUSTED%RAW)
   ENDFUNCTION SADJUSTR

   ELEMENTAL FUNCTION SCOUNT(SELF, SUBSTRING, IGNORE_ISOLATED) RESULT(NO)
   !< COUNT THE NUMBER OF OCCURENCES OF A SUBSTRING INTO A STRING.
   !<
   !< @NOTE IF `IGNORE_ISOLATED` IS SET TO TRUE THE EVENTUAL "ISOLATED" OCCURENCES ARE IGNORED: AN ISOLATED OCCURRENCES ARE THOSE
   !< OCCURRENCES HAPPENING AT THE START OF STRING (THUS NOT HAVING A LEFT COMPANION) OR AT THE END OF THE STRING (THUS NOT HAVING
   !< A RIGHT COMPANION).
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(4)
   !< ASTRING = '   HELLO WORLD  !    '
   !< TEST_PASSED(1) = ASTRING%COUNT(SUBSTRING=' ')==10
   !< ASTRING = 'HELLO WORLD  !    '
   !< TEST_PASSED(2) = ASTRING%COUNT(SUBSTRING=' ', IGNORE_ISOLATED=.TRUE.)==6
   !< ASTRING = '    HELLO WORLD  !'
   !< TEST_PASSED(3) = ASTRING%COUNT(SUBSTRING=' ', IGNORE_ISOLATED=.TRUE.)==6
   !< ASTRING = '   HELLO WORLD  !    '
   !< TEST_PASSED(4) = ASTRING%COUNT(SUBSTRING=' ', IGNORE_ISOLATED=.TRUE.)==8
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN)              :: SELF             !< THE STRING.
   CHARACTER(*),  INTENT(IN)              :: SUBSTRING        !< SUBSTRING.
   LOGICAL,       INTENT(IN), OPTIONAL    :: IGNORE_ISOLATED  !< IGNORE "ISOLATED" OCCURRENCES.
   INTEGER                                :: NO               !< NUMBER OF OCCURRENCES.
   LOGICAL                                :: IGNORE_ISOLATED_ !< IGNORE "ISOLATED" OCCURRENCES, LOCAL VARIABLE.
   INTEGER                                :: C1               !< COUNTER.
   INTEGER                                :: C2               !< COUNTER.

   NO = 0
   IF (ALLOCATED(SELF%RAW)) THEN
      IF (LEN(SUBSTRING)>LEN(SELF%RAW)) RETURN
      IGNORE_ISOLATED_ = .FALSE. ; IF (PRESENT(IGNORE_ISOLATED)) IGNORE_ISOLATED_ = IGNORE_ISOLATED
      C1 = 1
      DO
         C2 = INDEX(STRING=SELF%RAW(C1:), SUBSTRING=SUBSTRING)
         IF (C2==0) RETURN
         IF (.NOT.IGNORE_ISOLATED_) THEN
            NO = NO + 1
         ELSE
            IF (.NOT.((C1==1.AND.C2==1) .OR. (C1==LEN(SELF%RAW)-LEN(SUBSTRING)+1))) THEN
               NO = NO + 1
            ENDIF
         ENDIF
         C1 = C1 + C2 - 1 + LEN(SUBSTRING)
      ENDDO
   ENDIF
   ENDFUNCTION SCOUNT

   ELEMENTAL FUNCTION SINDEX_STRING_STRING(SELF, SUBSTRING, BACK) RESULT(I)
   !< RETURN THE POSITION OF THE START OF THE FIRST OCCURRENCE OF STRING `SUBSTRING` AS A SUBSTRING IN `STRING`, COUNTING FROM ONE.
   !< IF `SUBSTRING` IS NOT PRESENT IN `STRING`, ZERO IS RETURNED. IF THE BACK ARGUMENT IS PRESENT AND TRUE, THE RETURN VALUE IS
   !< THE START OF THE LAST OCCURRENCE RATHER THAN THE FIRST.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: STRING1
   !< TYPE(STRING) :: STRING2
   !< LOGICAL      :: TEST_PASSED(2)
   !< STRING1 = 'HELLO WORLD HELLO!'
   !< STRING2 = 'LLO'
   !< TEST_PASSED(1) = STRING1%INDEX(SUBSTRING=STRING2)==INDEX(STRING='HELLO WORLD HELLO!', SUBSTRING='LLO')
   !< TEST_PASSED(2) = STRING1%INDEX(SUBSTRING=STRING2, BACK=.TRUE.)==INDEX(STRING='HELLO WORLD HELLO!', SUBSTRING='LLO', &
   !<                                                                       BACK=.TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN)           :: SELF      !< THE STRING.
   TYPE(STRING),  INTENT(IN)           :: SUBSTRING !< SEARCHED SUBSTRING.
   LOGICAL,       INTENT(IN), OPTIONAL :: BACK      !< START OF THE LAST OCCURRENCE RATHER THAN THE FIRST.
   INTEGER                             :: I         !< RESULT OF THE SEARCH.

   IF (ALLOCATED(SELF%RAW)) THEN
      I = INDEX(STRING=SELF%RAW, SUBSTRING=SUBSTRING%RAW, BACK=BACK)
   ELSE
      I = 0
   ENDIF
   ENDFUNCTION SINDEX_STRING_STRING

   ELEMENTAL FUNCTION SINDEX_STRING_CHARACTER(SELF, SUBSTRING, BACK) RESULT(I)
   !< RETURN THE POSITION OF THE START OF THE FIRST OCCURRENCE OF STRING `SUBSTRING` AS A SUBSTRING IN `STRING`, COUNTING FROM ONE.
   !< IF `SUBSTRING` IS NOT PRESENT IN `STRING`, ZERO IS RETURNED. IF THE BACK ARGUMENT IS PRESENT AND TRUE, THE RETURN VALUE IS
   !< THE START OF THE LAST OCCURRENCE RATHER THAN THE FIRST.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: STRING1
   !< LOGICAL      :: TEST_PASSED(2)
   !< STRING1 = 'HELLO WORLD HELLO!'
   !< TEST_PASSED(1) = STRING1%INDEX(SUBSTRING='LLO')==INDEX(STRING='HELLO WORLD HELLO!', SUBSTRING='LLO')
   !< TEST_PASSED(2) = STRING1%INDEX(SUBSTRING='LLO',BACK=.TRUE.)==INDEX(STRING='HELLO WORLD HELLO!', SUBSTRING='LLO', BACK=.TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF      !< THE STRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)           :: SUBSTRING !< SEARCHED SUBSTRING.
   LOGICAL,                   INTENT(IN), OPTIONAL :: BACK      !< START OF THE LAST OCCURRENCE RATHER THAN THE FIRST.
   INTEGER                                         :: I         !< RESULT OF THE SEARCH.

   IF (ALLOCATED(SELF%RAW)) THEN
      I = INDEX(STRING=SELF%RAW, SUBSTRING=SUBSTRING, BACK=BACK)
   ELSE
      I = 0
   ENDIF
   ENDFUNCTION SINDEX_STRING_CHARACTER

   ELEMENTAL FUNCTION SLEN(SELF) RESULT(L)
   !< RETURN THE LENGTH OF A STRING.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< ASTRING = 'HELLO WORLD!   '
   !< PRINT "(L1)", ASTRING%LEN()==LEN('HELLO WORLD!   ')
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF !< THE STRING.
   INTEGER                   :: L    !< STRING LENGTH.

   IF (ALLOCATED(SELF%RAW)) THEN
      L = LEN(STRING=SELF%RAW)
   ELSE
      L = 0
   ENDIF
   ENDFUNCTION SLEN

   ELEMENTAL FUNCTION SLEN_TRIM(SELF) RESULT(L)
   !< RETURN THE LENGTH OF A STRING, IGNORING ANY TRAILING BLANKS.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< ASTRING = 'HELLO WORLD!   '
   !< PRINT "(L1)", ASTRING%LEN_TRIM()==LEN_TRIM('HELLO WORLD!   ')
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF !< THE STRING.
   INTEGER                   :: L    !< STRING LENGTH.

   IF (ALLOCATED(SELF%RAW)) THEN
      L = LEN_TRIM(STRING=SELF%RAW)
   ELSE
      L = 0
   ENDIF
   ENDFUNCTION SLEN_TRIM

   ELEMENTAL FUNCTION SREPEAT_STRING_STRING(SELF, NCOPIES) RESULT(REPEATED)
   !< CONCATENATES SEVERAL COPIES OF AN INPUT STRING.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< ASTRING = 'X'
   !< PRINT "(L1)", ASTRING%REPEAT(5)//''=='XXXXX'
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF     !< STRING TO BE REPEATED.
   INTEGER,       INTENT(IN) :: NCOPIES  !< NUMBER OF STRING COPIES.
   TYPE(STRING)              :: REPEATED !< REPEATED STRING.
#ifdef _NVF
   CHARACTER(9999)           :: NVF_BUG  !< WORK AROUND FOR NVFORTRAN BUG.
#endif

#ifdef _NVF
   NVF_BUG = SELF%RAW
   REPEATED%RAW = REPEAT(STRING=TRIM(NVF_BUG), NCOPIES=NCOPIES)
#else
   REPEATED%RAW = REPEAT(STRING=SELF%RAW, NCOPIES=NCOPIES)
#endif
   ENDFUNCTION SREPEAT_STRING_STRING

   ELEMENTAL FUNCTION SREPEAT_CHARACTER_STRING(RSTRING, NCOPIES) RESULT(REPEATED)
   !< CONCATENATES SEVERAL COPIES OF AN INPUT STRING.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< ASTRING = 'Y'
   !< PRINT "(L1)", ASTRING%REPEAT('X', 5)//''=='XXXXX'
   !<```
   !=> T <<<
   CHARACTER(KIND=CK, LEN=*), INTENT(IN) :: RSTRING  !< STRING TO BE REPEATED.
   INTEGER,                   INTENT(IN) :: NCOPIES  !< NUMBER OF STRING COPIES.
   TYPE(STRING)                          :: REPEATED !< REPEATED STRING.

   REPEATED%RAW = REPEAT(STRING=RSTRING, NCOPIES=NCOPIES)
   ENDFUNCTION SREPEAT_CHARACTER_STRING

   ELEMENTAL FUNCTION SSCAN_STRING_STRING(SELF, SET, BACK) RESULT(I)
   !< RETURN THE LEFTMOST (IF BACK IS EITHER ABSENT OR EQUALS FALSE, OTHERWISE THE RIGHTMOST) CHARACTER OF STRING THAT IS IN SET.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: STRING1
   !< TYPE(STRING) :: STRING2
   !< LOGICAL      :: TEST_PASSED(2)
   !< STRING1 = 'HELLO WORLD HELLO!'
   !< STRING2 = 'LLO'
   !< TEST_PASSED(1) = STRING1%SCAN(SET=STRING2)==SCAN(STRING='HELLO WORLD HELLO!', SET='LLO')
   !< TEST_PASSED(2) = STRING1%SCAN(SET=STRING2, BACK=.TRUE.)==SCAN(STRING='HELLO WORLD HELLO!', SET='LLO', BACK=.TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN)           :: SELF  !< THE STRING.
   TYPE(STRING),  INTENT(IN)           :: SET   !< SEARCHED SET.
   LOGICAL,       INTENT(IN), OPTIONAL :: BACK  !< START OF THE LAST OCCURRENCE RATHER THAN THE FIRST.
   INTEGER                             :: I     !< RESULT OF THE SEARCH.

   IF (ALLOCATED(SELF%RAW).AND.ALLOCATED(SET%RAW)) THEN
     I = SCAN(STRING=SELF%RAW, SET=SET%RAW, BACK=BACK)
   ELSE
     I = 0
   ENDIF
   ENDFUNCTION SSCAN_STRING_STRING

   ELEMENTAL FUNCTION SSCAN_STRING_CHARACTER(SELF, SET, BACK) RESULT(I)
   !< RETURN THE LEFTMOST (IF BACK IS EITHER ABSENT OR EQUALS FALSE, OTHERWISE THE RIGHTMOST) CHARACTER OF STRING THAT IS IN SET.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: STRING1
   !< LOGICAL      :: TEST_PASSED(2)
   !< STRING1 = 'HELLO WORLD HELLO!'
   !< TEST_PASSED(1) = STRING1%SCAN(SET='LLO')==SCAN(STRING='HELLO WORLD HELLO!', SET='LLO')
   !< TEST_PASSED(2) = STRING1%SCAN(SET='LLO', BACK=.TRUE.)==SCAN(STRING='HELLO WORLD HELLO!', SET='LLO', BACK=.TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF  !< THE STRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)           :: SET   !< SEARCHED SET.
   LOGICAL,                   INTENT(IN), OPTIONAL :: BACK  !< START OF THE LAST OCCURRENCE RATHER THAN THE FIRST.
   INTEGER                                         :: I     !< RESULT OF THE SEARCH.

   IF (ALLOCATED(SELF%RAW)) THEN
     I = SCAN(STRING=SELF%RAW, SET=SET, BACK=BACK)
   ELSE
     I = 0
   ENDIF
   ENDFUNCTION SSCAN_STRING_CHARACTER

   ELEMENTAL FUNCTION STRIM(SELF) RESULT(TRIMMED)
   !< REMOVE TRAILING SPACES.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< ASTRING = 'HELLO WORLD!   '
   !< PRINT "(L1)", ASTRING%TRIM()==TRIM('HELLO WORLD!   ')
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF    !< THE STRING.
   TYPE(STRING)              :: TRIMMED !< TRIMMED STRING.

   TRIMMED = SELF
   IF (ALLOCATED(TRIMMED%RAW)) TRIMMED%RAW = TRIM(TRIMMED%RAW)
   ENDFUNCTION STRIM

   ELEMENTAL FUNCTION SVERIFY_STRING_STRING(SELF, SET, BACK) RESULT(I)
   !< RETURN THE LEFTMOST (IF `BACK` IS EITHER ABSENT OR EQUALS FALSE, OTHERWISE THE RIGHTMOST) CHARACTER OF STRING THAT IS NOT
   !< IN `SET`. IF ALL CHARACTERS OF `STRING` ARE FOUND IN `SET`, THE RESULT IS ZERO.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: STRING1
   !< TYPE(STRING) :: STRING2
   !< LOGICAL      :: TEST_PASSED(2)
   !< STRING1 = 'HELLO WORLD HELLO!'
   !< STRING2 = 'LLO'
   !< TEST_PASSED(1) = STRING1%VERIFY(SET=STRING2)==VERIFY(STRING='HELLO WORLD HELLO!', SET='LLO')
   !< TEST_PASSED(2) = STRING1%VERIFY(SET=STRING2, BACK=.TRUE.)==VERIFY(STRING='HELLO WORLD HELLO!', SET='LLO', BACK=.TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN)           :: SELF  !< THE STRING.
   TYPE(STRING),  INTENT(IN)           :: SET   !< SEARCHED SET.
   LOGICAL,       INTENT(IN), OPTIONAL :: BACK  !< START OF THE LAST OCCURRENCE RATHER THAN THE FIRST.
   INTEGER                             :: I     !< RESULT OF THE SEARCH.

   IF (ALLOCATED(SELF%RAW).AND.ALLOCATED(SET%RAW)) THEN
     I = VERIFY(STRING=SELF%RAW, SET=SET%RAW, BACK=BACK)
   ELSE
     I = 0
   ENDIF
   ENDFUNCTION SVERIFY_STRING_STRING

   ELEMENTAL FUNCTION SVERIFY_STRING_CHARACTER(SELF, SET, BACK) RESULT(I)
   !< RETURN THE LEFTMOST (IF `BACK` IS EITHER ABSENT OR EQUALS FALSE, OTHERWISE THE RIGHTMOST) CHARACTER OF STRING THAT IS NOT
   !< IN `SET`. IF ALL CHARACTERS OF `STRING` ARE FOUND IN `SET`, THE RESULT IS ZERO.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: STRING1
   !< LOGICAL      :: TEST_PASSED(2)
   !< STRING1 = 'HELLO WORLD HELLO!'
   !< TEST_PASSED(1) = STRING1%VERIFY(SET='LLO')==VERIFY(STRING='HELLO WORLD HELLO!', SET='LLO')
   !< TEST_PASSED(2) = STRING1%VERIFY(SET='LLO', BACK=.TRUE.)==VERIFY(STRING='HELLO WORLD HELLO!', SET='LLO', BACK=.TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF  !< THE STRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)           :: SET   !< SEARCHED SET.
   LOGICAL,                   INTENT(IN), OPTIONAL :: BACK  !< START OF THE LAST OCCURRENCE RATHER THAN THE FIRST.
   INTEGER                                         :: I     !< RESULT OF THE SEARCH.

   IF (ALLOCATED(SELF%RAW)) THEN
     I = VERIFY(STRING=SELF%RAW, SET=SET, BACK=BACK)
   ELSE
     I = 0
   ENDIF
   ENDFUNCTION SVERIFY_STRING_CHARACTER

   ! AUXILIARY METHODS
   ELEMENTAL FUNCTION BASEDIR(SELF, SEP)
   !< RETURN THE BASE DIRECTORY NAME OF A STRING CONTAINING A FILE NAME.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: STRING1
   !< LOGICAL      :: TEST_PASSED(4)
   !< STRING1 = '/BAR/FOO.TAR.BZ2'
   !< TEST_PASSED(1) = STRING1%BASEDIR()//''=='/BAR'
   !< STRING1 = './BAR/FOO.TAR.BZ2'
   !< TEST_PASSED(2) = STRING1%BASEDIR()//''=='./BAR'
   !< STRING1 = 'BAR/FOO.TAR.BZ2'
   !< TEST_PASSED(3) = STRING1%BASEDIR()//''=='BAR'
   !< STRING1 = '\BAR\FOO.TAR.BZ2'
   !< TEST_PASSED(4) = STRING1%BASEDIR(SEP='\')//''=='\BAR'
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF    !< THE STRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN), OPTIONAL :: SEP     !< DIRECTORY SEPARATOR.
   TYPE(STRING)                                    :: BASEDIR !< BASE DIRECTORY NAME.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE          :: SEP_    !< SEPARATOR, DEFAULT VALUE.
   INTEGER                                         :: POS     !< CHARACTER POSITION.

   IF (ALLOCATED(SELF%RAW)) THEN
     SEP_ = UIX_DIR_SEP ; IF (PRESENT(SEP)) SEP_ = SEP
     BASEDIR = SELF
     POS = INDEX(SELF%RAW, SEP_, BACK=.TRUE.)
     IF (POS>0) BASEDIR%RAW = SELF%RAW(1:POS-1)
   ENDIF
   ENDFUNCTION BASEDIR

   ELEMENTAL FUNCTION BASENAME(SELF, SEP, EXTENSION, STRIP_LAST_EXTENSION)
   !< RETURN THE BASE FILE NAME OF A STRING CONTAINING A FILE NAME.
   !<
   !< OPTIONALLY, THE EXTENSION IS ALSO STRIPPED IF PROVIDED OR THE LAST ONE IF REQUIRED, E.G.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(5)
   !< ASTRING = 'BAR/FOO.TAR.BZ2'
   !< TEST_PASSED(1) = ASTRING%BASENAME()//''=='FOO.TAR.BZ2'
   !< TEST_PASSED(2) = ASTRING%BASENAME(EXTENSION='.TAR.BZ2')//''=='FOO'
   !< TEST_PASSED(3) = ASTRING%BASENAME(STRIP_LAST_EXTENSION=.TRUE.)//''=='FOO.TAR'
   !< ASTRING = '\BAR\FOO.TAR.BZ2'
   !< TEST_PASSED(4) = ASTRING%BASENAME(SEP='\')//''=='FOO.TAR.BZ2'
   !< ASTRING = 'BAR'
   !< TEST_PASSED(5) = ASTRING%BASENAME(STRIP_LAST_EXTENSION=.TRUE.)//''=='BAR'
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF                 !< THE STRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN), OPTIONAL :: SEP                  !< DIRECTORY SEPARATOR.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN), OPTIONAL :: EXTENSION            !< FILE EXTENSION.
   LOGICAL,                   INTENT(IN), OPTIONAL :: STRIP_LAST_EXTENSION !< FLAG TO ENABLE THE STRIPPING OF LAST EXTENSION.
   TYPE(STRING)                                    :: BASENAME             !< BASE FILE NAME.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE          :: SEP_                 !< SEPARATOR, DEFAULT VALUE.
   INTEGER                                         :: POS                  !< CHARACTER POSITION.

   IF (ALLOCATED(SELF%RAW)) THEN
      SEP_ = UIX_DIR_SEP ; IF (PRESENT(SEP)) SEP_ = SEP
      BASENAME = SELF
      POS = INDEX(BASENAME%RAW, SEP_, BACK=.TRUE.)
      IF (POS>0) BASENAME%RAW = SELF%RAW(POS+1:)
      IF (PRESENT(EXTENSION)) THEN
         POS = INDEX(BASENAME%RAW, EXTENSION, BACK=.TRUE.)
         IF (POS>0) BASENAME%RAW = BASENAME%RAW(1:POS-1)
      ELSEIF (PRESENT(STRIP_LAST_EXTENSION)) THEN
         IF (STRIP_LAST_EXTENSION) THEN
            POS = INDEX(BASENAME%RAW, '.', BACK=.TRUE.)
            IF (POS>0) BASENAME%RAW = BASENAME%RAW(1:POS-1)
         ENDIF
      ENDIF
   ENDIF
   ENDFUNCTION BASENAME

   ELEMENTAL FUNCTION CAMELCASE(SELF, SEP)
   !< RETURN A STRING WITH ALL WORDS CAPITALIZED WITHOUT SPACES.
   !<
   !< @NOTE MULTIPLE SUBSEQUENT SEPARATORS ARE COLLAPSED TO ONE OCCURENCE.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< ASTRING = 'CAMEL CASE VAR'
   !< PRINT '(L1)', ASTRING%CAMELCASE()//''=='CAMELCASEVAR'
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF      !< THE STRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN), OPTIONAL :: SEP       !< SEPARATOR.
   TYPE(STRING)                                    :: CAMELCASE !< CAMEL CASE STRING.
   TYPE(STRING), ALLOCATABLE                       :: TOKENS(:) !< STRING TOKENS.

   IF (ALLOCATED(SELF%RAW)) THEN
     CALL SELF%SPLIT(TOKENS=TOKENS, SEP=SEP)
     TOKENS = TOKENS%CAPITALIZE()
     CAMELCASE = CAMELCASE%JOIN(ARRAY=TOKENS)
   ENDIF
   ENDFUNCTION CAMELCASE

   ELEMENTAL FUNCTION CAPITALIZE(SELF) RESULT(CAPITALIZED)
   !< RETURN A STRING WITH ITS FIRST CHARACTER CAPITALIZED AND THE REST LOWERCASED.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< ASTRING = 'SAY ALL HELLO WORLD!'
   !< PRINT '(L1)', ASTRING%CAPITALIZE()//''=='SAY ALL HELLO WORLD!'
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF        !< THE STRING.
   TYPE(STRING)              :: CAPITALIZED !< UPPER CASE STRING.
   INTEGER                   :: C           !< CHARACTER COUNTER.

   IF (ALLOCATED(SELF%RAW)) THEN
     CAPITALIZED = SELF%LOWER()
     C = INDEX(LOWER_ALPHABET, CAPITALIZED%RAW(1:1))
     IF (C>0) CAPITALIZED%RAW(1:1) = UPPER_ALPHABET(C:C)
   ENDIF
   ENDFUNCTION CAPITALIZE

   PURE FUNCTION CHARS(SELF) RESULT(RAW)
   !< RETURN THE RAW CHARACTERS DATA.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< ASTRING = 'SAY ALL HELLO WORLD!'
   !< PRINT '(L1)', ASTRING%CHARS()=='SAY ALL HELLO WORLD!'
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN)              :: SELF !< THE STRING.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE :: RAW  !< RAW CHARACTERS DATA.

   IF (ALLOCATED(SELF%RAW)) THEN
     RAW = SELF%RAW
   ELSE
     RAW = ''
   ENDIF
   ENDFUNCTION CHARS

   ELEMENTAL FUNCTION DECODE(SELF, CODEC) RESULT(DECODED)
   !< RETURN A STRING DECODED ACCORDINGLY THE CODEC.
   !<
   !< @NOTE ONLY BASE64 CODEC IS CURRENTLY AVAILABLE.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< ASTRING = 'SG93IGFYZSB5B3U/'
   !< PRINT '(L1)', ASTRING%DECODE(CODEC='BASE64')//''=='HOW ARE YOU?'
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN) :: SELF    !< THE STRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN) :: CODEC   !< ENCODING CODEC.
   TYPE(STRING)                          :: DECODED !< DECODED STRING.
   TYPE(STRING)                          :: CODEC_U !< ENCODING CODEC IN UPPER CASE STRING.

   IF (ALLOCATED(SELF%RAW)) THEN
     DECODED = SELF
     CODEC_U = CODEC
     SELECT CASE(CODEC_U%UPPER()//'')
     CASE('BASE64')
       CALL B64_DECODE(CODE=SELF%RAW, S=DECODED%RAW)
     ENDSELECT
     DECODED = DECODED%STRIP(REMOVE_NULLS=.TRUE.)
   ENDIF
   ENDFUNCTION DECODE

   ELEMENTAL FUNCTION ENCODE(SELF, CODEC) RESULT(ENCODED)
   !< RETURN A STRING ENCODED ACCORDINGLY THE CODEC.
   !<
   !< @NOTE ONLY BASE64 CODEC IS CURRENTLY AVAILABLE.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< ASTRING = 'HOW ARE YOU?'
   !< PRINT '(L1)', ASTRING%ENCODE(CODEC='BASE64')//''=='SG93IGFYZSB5B3U/'
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN) :: SELF    !< THE STRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN) :: CODEC   !< ENCODING CODEC.
   TYPE(STRING)                          :: ENCODED !< ENCODED STRING.

   IF (ALLOCATED(SELF%RAW)) THEN
     ENCODED = CODEC
     SELECT CASE(ENCODED%UPPER()//'')
     CASE('BASE64')
       CALL B64_ENCODE(S=SELF%RAW, CODE=ENCODED%RAW)
     ENDSELECT
   ENDIF
   ENDFUNCTION ENCODE

   ELEMENTAL FUNCTION ESCAPE(SELF, TO_ESCAPE, ESC) RESULT(ESCAPED)
   !< ESCAPE BACKSLASHES (OR CUSTOM ESCAPE CHARACTER).
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(2)
   !< ASTRING = '^\S \D+\S*'
   !< TEST_PASSED(1) = ASTRING%ESCAPE(TO_ESCAPE='\')//''=='^\\S \\D+\\S*'
   !< TEST_PASSED(2) = ASTRING%ESCAPE(TO_ESCAPE='\', ESC='|')//''=='^|\S |\D+|\S*'
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF      !< THE STRING.
   CHARACTER(KIND=CK, LEN=1), INTENT(IN)           :: TO_ESCAPE !< CHARACTER TO BE ESCAPED.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN), OPTIONAL :: ESC       !< CHARACTER USED TO ESCAPE.
   TYPE(STRING)                                    :: ESCAPED   !< ESCAPED STRING.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE          :: ESC_      !< CHARACTER TO ESCAPE, LOCAL VARIABLE.
   INTEGER                                         :: C         !< CHARACTER COUNTER.

   IF (ALLOCATED(SELF%RAW)) THEN
     ESC_ = BACKSLASH ; IF (PRESENT(ESC)) ESC_ = ESC
     ESCAPED%RAW = ''
     DO C=1, LEN(SELF%RAW)
       IF (SELF%RAW(C:C)==TO_ESCAPE) THEN
         ESCAPED%RAW = ESCAPED%RAW//ESC_//TO_ESCAPE
       ELSE
         ESCAPED%RAW = ESCAPED%RAW//SELF%RAW(C:C)
       ENDIF
     ENDDO
   ENDIF
   ENDFUNCTION ESCAPE

   ELEMENTAL FUNCTION EXTENSION(SELF)
   !< RETURN THE EXTENSION OF A STRING CONTAINING A FILE NAME.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< ASTRING = '/BAR/FOO.TAR.BZ2'
   !< PRINT '(L1)', ASTRING%EXTENSION()//''=='.BZ2'
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN)              :: SELF      !< THE STRING.
   TYPE(STRING)                           :: EXTENSION !< EXTENSION FILE NAME.
   INTEGER                                :: POS       !< CHARACTER POSITION.

   IF (ALLOCATED(SELF%RAW)) THEN
      EXTENSION = ''
      POS = INDEX(SELF%RAW, '.', BACK=.TRUE.)
      IF (POS>0) EXTENSION%RAW = SELF%RAW(POS:)
   ENDIF
   ENDFUNCTION EXTENSION

   ELEMENTAL FUNCTION FILL(SELF, WIDTH, RIGHT, FILLING_CHAR) RESULT(FILLED)
   !< PAD STRING ON THE LEFT (OR RIGHT) WITH ZEROS (OR OTHER CHAR) TO FILL WIDTH.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(4)
   !< ASTRING = 'THIS IS STRING EXAMPLE....WOW!!!'
   !< TEST_PASSED(1) = ASTRING%FILL(WIDTH=40)//''=='00000000THIS IS STRING EXAMPLE....WOW!!!'
   !< TEST_PASSED(2) = ASTRING%FILL(WIDTH=50)//''=='000000000000000000THIS IS STRING EXAMPLE....WOW!!!'
   !< TEST_PASSED(3) = ASTRING%FILL(WIDTH=50, RIGHT=.TRUE.)//''=='THIS IS STRING EXAMPLE....WOW!!!000000000000000000'
   !< TEST_PASSED(4) = ASTRING%FILL(WIDTH=40, FILLING_CHAR='*')//''=='********THIS IS STRING EXAMPLE....WOW!!!'
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF          !< THE STRING.
   INTEGER,                   INTENT(IN)           :: WIDTH         !< FINAL WIDTH OF FILLED STRING.
   LOGICAL,                   INTENT(IN), OPTIONAL :: RIGHT         !< FILL ON THE RIGHT INSTEAD OF LEFT.
   CHARACTER(KIND=CK, LEN=1), INTENT(IN), OPTIONAL :: FILLING_CHAR  !< FILLING CHARACTER (DEFAULT "0").
   TYPE(STRING)                                    :: FILLED        !< FILLED STRING.
   LOGICAL                                         :: RIGHT_        !< FILL ON THE RIGHT INSTEAD OF LEFT, LOCAL VARIABLE.
   CHARACTER(KIND=CK, LEN=1)                       :: FILLING_CHAR_ !< FILLING CHARACTER (DEFAULT "0"), LOCAL VARIABLE.

   IF (ALLOCATED(SELF%RAW)) THEN
      IF (WIDTH>LEN(SELF%RAW)) THEN
         RIGHT_ = .FALSE. ; IF (PRESENT(RIGHT)) RIGHT_ = RIGHT
         FILLING_CHAR_ = '0' ; IF (PRESENT(FILLING_CHAR)) FILLING_CHAR_ = FILLING_CHAR
         IF (.NOT.RIGHT_) THEN
            FILLED%RAW = REPEAT(FILLING_CHAR_, WIDTH-LEN(SELF%RAW))//SELF%RAW
         ELSE
            FILLED%RAW = SELF%RAW//REPEAT(FILLING_CHAR_, WIDTH-LEN(SELF%RAW))
         ENDIF
      ENDIF
   ENDIF
   ENDFUNCTION FILL

   ELEMENTAL SUBROUTINE CUSTOMFREE(SELF)
   !< FREE DYNAMIC MEMORY.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< ASTRING = 'THIS IS STRING EXAMPLE....WOW!!!'
   !< CALL ASTRING%FREE
   !< PRINT '(L1)', ASTRING%IS_ALLOCATED().EQV..FALSE.
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(INOUT) :: SELF !< THE STRING.

   IF (ALLOCATED(SELF%RAW)) DEALLOCATE(SELF%RAW)
   ENDSUBROUTINE CUSTOMFREE

   SUBROUTINE GLOB_CHARACTER(SELF, PATTERN, LIST)
   !< GLOB SEARCH (CHARACTER OUTPUT), FINDS ALL THE PATHNAMES MATCHING A GIVEN PATTERN ACCORDING TO THE RULES USED BY THE UNIX
   !< SHELL.
   !<
   !< @NOTE METHOD NOT PORTABLE: WORKS ONLY ON UNIX/GNU LINUX OS.
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: ALIST_CHR(:)
   !< INTEGER, PARAMETER            :: NF=5
   !< CHARACTER(14)                 :: FILES(1:NF)
   !< INTEGER                       :: FILE_UNIT
   !< INTEGER                       :: F
   !< INTEGER                       :: FF
   !< LOGICAL                       :: TEST_PASSED
   !< DO F=1, NF
   !<    FILES(F) = ASTRING%TEMPNAME(PREFIX='FOO-')
   !<    OPEN(NEWUNIT=FILE_UNIT, FILE=FILES(F))
   !<    WRITE(FILE_UNIT, *)F
   !<    CLOSE(UNIT=FILE_UNIT)
   !< ENDDO
   !< CALL ASTRING%GLOB(PATTERN='FOO-*', LIST=ALIST_CHR)
   !< DO F=1, NF
   !<    OPEN(NEWUNIT=FILE_UNIT, FILE=FILES(F))
   !<    CLOSE(UNIT=FILE_UNIT, STATUS='DELETE')
   !< ENDDO
   !< TEST_PASSED = .FALSE.
   !< OUTER_CHR: DO F=1, SIZE(ALIST_CHR, DIM=1)
   !<    DO FF=1, NF
   !<       TEST_PASSED = ALIST_CHR(F) == FILES(FF)
   !<       IF (TEST_PASSED) CYCLE OUTER_CHR
   !<    ENDDO
   !< ENDDO OUTER_CHR
   !< PRINT '(L1)', TEST_PASSED
   !<```
   !=> T <<<
   CLASS(STRING),                 INTENT(IN)  :: SELF           !< THE STRING.
   CHARACTER(*),                  INTENT(IN)  :: PATTERN        !< GIVEN PATTERN.
   CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: LIST(:)        !< LIST OF MATCHING PATHNAMES.
   TYPE(STRING), ALLOCATABLE                  :: LIST_(:)       !< LIST OF MATCHING PATHNAMES.
   INTEGER(I4P)                               :: MAX_LEN        !< MAXIMUM LENGTH.
   INTEGER(I4P)                               :: MATCHES_NUMBER !< MATCHES NUMBER.
   INTEGER(I4P)                               :: M              !< COUNTER.

   CALL SELF%GLOB(PATTERN=PATTERN, LIST=LIST_)
   IF (ALLOCATED(LIST_)) THEN
      MATCHES_NUMBER = SIZE(LIST_, DIM=1)
      MAX_LEN = 0
      DO M=1, MATCHES_NUMBER
         MAX_LEN = MAX(MAX_LEN, LIST_(M)%LEN())
      ENDDO
      ALLOCATE(CHARACTER(MAX_LEN) :: LIST(1:MATCHES_NUMBER))
      DO M=1, MATCHES_NUMBER
         LIST(M) = LIST_(M)%CHARS()
      ENDDO
   ENDIF
   ENDSUBROUTINE GLOB_CHARACTER

   SUBROUTINE GLOB_STRING(SELF, PATTERN, LIST)
   !< GLOB SEARCH (STRING OUTPUT), FINDS ALL THE PATHNAMES MATCHING A GIVEN PATTERN ACCORDING TO THE RULES USED BY THE UNIX SHELL.
   !<
   !< @NOTE METHOD NOT PORTABLE: WORKS ONLY ON UNIX/GNU LINUX OS.
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< TYPE(STRING),     ALLOCATABLE :: ALIST_STR(:)
   !< INTEGER, PARAMETER            :: NF=5
   !< CHARACTER(14)                 :: FILES(1:NF)
   !< INTEGER                       :: FILE_UNIT
   !< INTEGER                       :: F
   !< INTEGER                       :: FF
   !< LOGICAL                       :: TEST_PASSED
   !<
   !< DO F=1, NF
   !<    FILES(F) = ASTRING%TEMPNAME(PREFIX='FOO-')
   !<    OPEN(NEWUNIT=FILE_UNIT, FILE=FILES(F))
   !<    WRITE(FILE_UNIT, *)F
   !<    CLOSE(UNIT=FILE_UNIT)
   !< ENDDO
   !< CALL ASTRING%GLOB(PATTERN='FOO-*', LIST=ALIST_STR)
   !< DO F=1, NF
   !<    OPEN(NEWUNIT=FILE_UNIT, FILE=FILES(F))
   !<    CLOSE(UNIT=FILE_UNIT, STATUS='DELETE')
   !< ENDDO
   !< TEST_PASSED = .FALSE.
   !< OUTER_STR: DO F=1, SIZE(ALIST_STR, DIM=1)
   !<    DO FF=1, NF
   !<       TEST_PASSED = ALIST_STR(F) == FILES(FF)
   !<       IF (TEST_PASSED) CYCLE OUTER_STR
   !<    ENDDO
   !< ENDDO OUTER_STR
   !< PRINT '(L1)', TEST_PASSED
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)  :: SELF     !< THE STRING.
   CHARACTER(*),              INTENT(IN)  :: PATTERN  !< GIVEN PATTERN.
   TYPE(STRING), ALLOCATABLE, INTENT(OUT) :: LIST(:)  !< LIST OF MATCHING PATHNAMES.
   TYPE(STRING)                           :: TEMPFILE !< SAFE TEMPORARY FILE.
   CHARACTER(LEN=:), ALLOCATABLE          :: TEMPNAME !< SAFE TEMPORARY NAME.
   INTEGER(I4P)                           :: TEMPUNIT !< UNIT OF TEMPORARY FILE.

   TEMPNAME = SELF%TEMPNAME()
   CALL EXECUTE_COMMAND_LINE('LS -1 '//TRIM(ADJUSTL(PATTERN))//' > '//TEMPNAME)
   CALL TEMPFILE%READ_FILE(FILE=TEMPNAME)
   CALL TEMPFILE%SPLIT(SEP=NEW_LINE('A'), TOKENS=LIST)
   OPEN(NEWUNIT=TEMPUNIT, FILE=TEMPNAME)
   CLOSE(UNIT=TEMPUNIT, STATUS='DELETE')
   ENDSUBROUTINE GLOB_STRING

   ELEMENTAL FUNCTION INSERT_CHARACTER(SELF, SUBSTRING, POS) RESULT(INSERTED)
   !< INSERT SUBSTRING INTO STRING AT A SPECIFIED POSITION.
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: ACHARACTER
   !< LOGICAL                       :: TEST_PASSED(5)
   !< ASTRING = 'THIS IS STRING EXAMPLE WOW!!!'
   !< ACHARACTER = '... '
   !< TEST_PASSED(1) = ASTRING%INSERT(SUBSTRING=ACHARACTER, POS=1)//''=='... THIS IS STRING EXAMPLE WOW!!!'
   !< TEST_PASSED(2) = ASTRING%INSERT(SUBSTRING=ACHARACTER, POS=23)//''=='THIS IS STRING EXAMPLE...  WOW!!!'
   !< TEST_PASSED(3) = ASTRING%INSERT(SUBSTRING=ACHARACTER, POS=29)//''=='THIS IS STRING EXAMPLE WOW!!!... '
   !< TEST_PASSED(4) = ASTRING%INSERT(SUBSTRING=ACHARACTER, POS=-1)//''=='... THIS IS STRING EXAMPLE WOW!!!'
   !< TEST_PASSED(5) = ASTRING%INSERT(SUBSTRING=ACHARACTER, POS=100)//''=='THIS IS STRING EXAMPLE WOW!!!... '
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),    INTENT(IN) :: SELF      !< THE STRING.
   CHARACTER(LEN=*), INTENT(IN) :: SUBSTRING !< SUBSTRING.
   INTEGER,          INTENT(IN) :: POS       !< POSITION FROM WHICH INSERT SUBSTRING.
   TYPE(STRING)                 :: INSERTED  !< INSERTED STRING.
   INTEGER                      :: SAFEPOS   !< SAFE POSITION FROM WHICH INSERT SUBSTRING.

   IF (ALLOCATED(SELF%RAW)) THEN
      INSERTED = SELF
      SAFEPOS = MIN(MAX(1, POS), LEN(SELF%RAW))
      IF (SAFEPOS==1) THEN
         INSERTED%RAW = SUBSTRING//SELF%RAW
      ELSEIF (SAFEPOS==LEN(SELF%RAW)) THEN
         INSERTED%RAW = SELF%RAW//SUBSTRING
      ELSE
         INSERTED%RAW = SELF%RAW(1:SAFEPOS-1)//SUBSTRING//SELF%RAW(SAFEPOS:)
      ENDIF
   ELSE
      INSERTED%RAW = SUBSTRING
   ENDIF
   ENDFUNCTION INSERT_CHARACTER

   ELEMENTAL FUNCTION INSERT_STRING(SELF, SUBSTRING, POS) RESULT(INSERTED)
   !< INSERT SUBSTRING INTO STRING AT A SPECIFIED POSITION.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< TYPE(STRING) :: ANOTHERSTRING
   !< LOGICAL      :: TEST_PASSED(5)
   !< ASTRING = 'THIS IS STRING EXAMPLE WOW!!!'
   !< ANOTHERSTRING = '... '
   !< TEST_PASSED(1) = ASTRING%INSERT(SUBSTRING=ANOTHERSTRING, POS=1)//''=='... THIS IS STRING EXAMPLE WOW!!!'
   !< TEST_PASSED(2) = ASTRING%INSERT(SUBSTRING=ANOTHERSTRING, POS=23)//''=='THIS IS STRING EXAMPLE...  WOW!!!'
   !< TEST_PASSED(3) = ASTRING%INSERT(SUBSTRING=ANOTHERSTRING, POS=29)//''=='THIS IS STRING EXAMPLE WOW!!!... '
   !< TEST_PASSED(4) = ASTRING%INSERT(SUBSTRING=ANOTHERSTRING, POS=-1)//''=='... THIS IS STRING EXAMPLE WOW!!!'
   !< TEST_PASSED(5) = ASTRING%INSERT(SUBSTRING=ANOTHERSTRING, POS=100)//''=='THIS IS STRING EXAMPLE WOW!!!... '
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF      !< THE STRING.
   TYPE(STRING),  INTENT(IN) :: SUBSTRING !< SUBSTRING.
   INTEGER,       INTENT(IN) :: POS       !< POSITION FROM WHICH INSERT SUBSTRING.
   TYPE(STRING)              :: INSERTED  !< INSERTED STRING.
   INTEGER                   :: SAFEPOS   !< SAFE POSITION FROM WHICH INSERT SUBSTRING.

   IF (ALLOCATED(SELF%RAW)) THEN
      INSERTED = SELF
      IF (ALLOCATED(SUBSTRING%RAW)) THEN
         SAFEPOS = MIN(MAX(1, POS), LEN(SELF%RAW))
         IF (SAFEPOS==1) THEN
            INSERTED%RAW = SUBSTRING%RAW//SELF%RAW
         ELSEIF (SAFEPOS==LEN(SELF%RAW)) THEN
            INSERTED%RAW = SELF%RAW//SUBSTRING%RAW
         ELSE
            INSERTED%RAW = SELF%RAW(1:SAFEPOS-1)//SUBSTRING%RAW//SELF%RAW(SAFEPOS:)
         ENDIF
      ENDIF
   ELSE
      IF (ALLOCATED(SUBSTRING%RAW)) INSERTED%RAW = SUBSTRING%RAW
   ENDIF
   ENDFUNCTION INSERT_STRING

   PURE FUNCTION JOIN_STRINGS(SELF, ARRAY, SEP) RESULT(JOIN)
   !< RETURN A STRING THAT IS A JOIN OF AN ARRAY OF STRINGS.
   !<
   !< THE JOIN-SEPARATOR IS SET EQUALS TO SELF IF SELF HAS A VALUE OR IT IS SET TO A NULL STRING ''. THIS VALUE CAN BE OVERRIDDEN
   !< PASSING A CUSTOM SEPARATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< TYPE(STRING) :: STRINGS(3)
   !< LOGICAL      :: TEST_PASSED(5)
   !< STRINGS(1) = 'ONE'
   !< STRINGS(2) = 'TWO'
   !< STRINGS(3) = 'THREE'
   !< TEST_PASSED(1) = (ASTRING%JOIN(ARRAY=STRINGS)//''==STRINGS(1)//STRINGS(2)//STRINGS(3))
   !< TEST_PASSED(2) = (ASTRING%JOIN(ARRAY=STRINGS, SEP='-')//''==STRINGS(1)//'-'//STRINGS(2)//'-'//STRINGS(3))
   !< CALL STRINGS(1)%FREE
   !< STRINGS(2) = 'TWO'
   !< STRINGS(3) = 'THREE'
   !< TEST_PASSED(3) = (ASTRING%JOIN(ARRAY=STRINGS, SEP='-')//''==STRINGS(2)//'-'//STRINGS(3))
   !< STRINGS(1) = 'ONE'
   !< STRINGS(2) = 'TWO'
   !< CALL STRINGS(3)%FREE
   !< TEST_PASSED(4) = (ASTRING%JOIN(ARRAY=STRINGS, SEP='-')//''==STRINGS(1)//'-'//STRINGS(2))
   !< STRINGS(1) = 'ONE'
   !< CALL STRINGS(2)%FREE
   !< STRINGS(3) = 'THREE'
   !< TEST_PASSED(5) = (ASTRING%JOIN(ARRAY=STRINGS, SEP='-')//''==STRINGS(1)//'-'//STRINGS(3))
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF      !< THE STRING.
   TYPE(STRING),              INTENT(IN)           :: ARRAY(1:) !< ARRAY TO BE JOINED.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN), OPTIONAL :: SEP       !< SEPARATOR.
   TYPE(STRING)                                    :: JOIN      !< THE JOIN OF ARRAY.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE          :: SEP_      !< SEPARATOR, DEFAULT VALUE.
   INTEGER                                         :: A         !< COUNTER.

   IF (ALLOCATED(SELF%RAW)) THEN
      SEP_ = SELF%RAW
   ELSE
      SEP_ = ''
   ENDIF
   IF (PRESENT(SEP)) SEP_ = SEP
   JOIN = ''
   DO A=2, SIZE(ARRAY, DIM=1)
      IF (ALLOCATED(ARRAY(A)%RAW)) JOIN%RAW = JOIN%RAW//SEP_//ARRAY(A)%RAW
   ENDDO
   IF (ALLOCATED(ARRAY(1)%RAW)) THEN
      JOIN%RAW = ARRAY(1)%RAW//JOIN%RAW
   ELSE
      JOIN%RAW = JOIN%RAW(LEN(SEP_)+1:LEN(JOIN%RAW))
   ENDIF
   ENDFUNCTION JOIN_STRINGS

   PURE FUNCTION JOIN_CHARACTERS(SELF, ARRAY, SEP) RESULT(JOIN)
   !< RETURN A STRING THAT IS A JOIN OF AN ARRAY OF CHARACTERS.
   !<
   !< THE JOIN-SEPARATOR IS SET EQUALS TO SELF IF SELF HAS A VALUE OR IT IS SET TO A NULL STRING ''. THIS VALUE CAN BE OVERRIDDEN
   !< PASSING A CUSTOM SEPARATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< CHARACTER(5) :: CHARACTERS(3)
   !< LOGICAL      :: TEST_PASSED(6)
   !< CHARACTERS(1) = 'ONE'
   !< CHARACTERS(2) = 'TWO'
   !< CHARACTERS(3) = 'THREE'
   !< TEST_PASSED(1) = (ASTRING%JOIN(ARRAY=CHARACTERS)//''==CHARACTERS(1)//CHARACTERS(2)//CHARACTERS(3))
   !< TEST_PASSED(2) = (ASTRING%JOIN(ARRAY=CHARACTERS, SEP='-')//''==CHARACTERS(1)//'-'//CHARACTERS(2)//'-'//CHARACTERS(3))
   !< CHARACTERS(1) = ''
   !< CHARACTERS(2) = 'TWO'
   !< CHARACTERS(3) = 'THREE'
   !< TEST_PASSED(3) = (ASTRING%JOIN(ARRAY=CHARACTERS, SEP='-')//''==CHARACTERS(2)//'-'//CHARACTERS(3))
   !< CHARACTERS(1) = 'ONE'
   !< CHARACTERS(2) = 'TWO'
   !< CHARACTERS(3) = ''
   !< TEST_PASSED(4) = (ASTRING%JOIN(ARRAY=CHARACTERS, SEP='-')//''==CHARACTERS(1)//'-'//CHARACTERS(2))
   !< CHARACTERS(1) = 'ONE'
   !< CHARACTERS(2) = ''
   !< CHARACTERS(3) = 'THREE'
   !< TEST_PASSED(5) = (ASTRING%JOIN(ARRAY=CHARACTERS, SEP='-')//''==CHARACTERS(1)//'-'//CHARACTERS(3))
   !< CHARACTERS(1) = 'ONE'
   !< CHARACTERS(2) = 'TWO'
   !< CHARACTERS(3) = 'THREE'
   !< ASTRING = '_'
   !< TEST_PASSED(6) = (ASTRING%JOIN(ARRAY=CHARACTERS)//''==CHARACTERS(1)//'_'//CHARACTERS(2)//'_'//CHARACTERS(3))
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF      !< THE STRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)           :: ARRAY(1:) !< ARRAY TO BE JOINED.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN), OPTIONAL :: SEP       !< SEPARATOR.
   TYPE(STRING)                                    :: JOIN      !< THE JOIN OF ARRAY.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE          :: SEP_      !< SEPARATOR, DEFAULT VALUE.
   INTEGER                                         :: A         !< COUNTER.

   IF (ALLOCATED(SELF%RAW)) THEN
      SEP_ = SELF%RAW
   ELSE
      SEP_ = ''
   ENDIF
   IF (PRESENT(SEP)) SEP_ = SEP
   JOIN = ''
   DO A=2, SIZE(ARRAY, DIM=1)
      IF (ARRAY(A)/='') JOIN%RAW = JOIN%RAW//SEP_//ARRAY(A)
   ENDDO
   IF (ARRAY(1)/='') THEN
      JOIN%RAW = ARRAY(1)//JOIN%RAW
   ELSE
      JOIN%RAW = JOIN%RAW(LEN(SEP_)+1:LEN(JOIN%RAW))
   ENDIF
   ENDFUNCTION JOIN_CHARACTERS

   PURE FUNCTION STRJOIN_STRINGS(ARRAY, SEP) RESULT(JOIN)
   !< RETURN A STRING THAT IS A JOIN OF AN ARRAY OF STRINGS.
   !<
   !< THE JOIN-SEPARATOR IS SET EQUALS TO A NULL STRING '' IF CUSTOM SEPARATOR ISN'T SPECIFIED.
   !<
   !<```FORTRAN
   !< TYPE(STRING)     :: STRINGS(3)
   !< LOGICAL          :: TEST_PASSED(5)
   !< STRINGS(1) = 'ONE'
   !< STRINGS(2) = 'TWO'
   !< STRINGS(3) = 'THREE'
   !< TEST_PASSED(1) = (STRJOIN(ARRAY=STRINGS)//''==STRINGS(1)//STRINGS(2)//STRINGS(3))
   !< TEST_PASSED(2) = (STRJOIN(ARRAY=STRINGS, SEP='-')//''==STRINGS(1)//'-'//STRINGS(2)//'-'//STRINGS(3))
   !< CALL STRINGS(1)%FREE
   !< STRINGS(2) = 'TWO'
   !< STRINGS(3) = 'THREE'
   !< TEST_PASSED(3) = (STRJOIN(ARRAY=STRINGS, SEP='-')//''==STRINGS(2)//'-'//STRINGS(3))
   !< STRINGS(1) = 'ONE'
   !< STRINGS(2) = 'TWO'
   !< CALL STRINGS(3)%FREE
   !< TEST_PASSED(4) = (STRJOIN(ARRAY=STRINGS, SEP='-')//''==STRINGS(1)//'-'//STRINGS(2))
   !< STRINGS(1) = 'ONE'
   !< CALL STRINGS(2)%FREE
   !< STRINGS(3) = 'THREE'
   !< TEST_PASSED(5) = (STRJOIN(ARRAY=STRINGS, SEP='-')//''==STRINGS(1)//'-'//STRINGS(3))
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: ARRAY(1:) !< ARRAY TO BE JOINED.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN), OPTIONAL :: SEP       !< SEPARATOR.
   TYPE(STRING)                                    :: JOIN      !< THE JOIN OF ARRAY.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE          :: SEP_      !< SEPARATOR, DEFAULT VALUE.
   INTEGER                                         :: A         !< COUNTER.

   SEP_ = ''
   IF (PRESENT(SEP)) SEP_ = SEP
   JOIN = ''
   DO A=2, SIZE(ARRAY, DIM=1)
      IF (ALLOCATED(ARRAY(A)%RAW))JOIN%RAW = JOIN%RAW//SEP_//ARRAY(A)%RAW
   ENDDO
   IF (ALLOCATED(ARRAY(1)%RAW)) THEN
      JOIN%RAW = ARRAY(1)%RAW//JOIN%RAW
   ELSE
      JOIN%RAW = JOIN%RAW(LEN(SEP_)+1:LEN(JOIN%RAW))
   ENDIF
   ENDFUNCTION STRJOIN_STRINGS

  PURE FUNCTION STRJOIN_CHARACTERS(ARRAY, SEP, IS_TRIM) RESULT(JOIN)
   !< RETURN A STRING THAT IS A JOIN OF AN ARRAY OF CHARACTERS.
   !<
   !< THE JOIN-SEPARATOR IS SET EQUALS TO A NULL STRING '' IF CUSTOM SEPARATOR ISN'T SPECIFIED.
   !< THE TRIM FUNCTION IS APPLIED TO ARRAY ITEMS IF OPTIONAL LOGICAL IS_TRIM VARIABLE ISN'T SET TO .FALSE.
   !<
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)           :: ARRAY(1:) !< ARRAY TO BE JOINED.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN), OPTIONAL :: SEP       !< SEPARATOR.
   LOGICAL,                   INTENT(IN), OPTIONAL :: IS_TRIM   !< FLAG TO SETUP TRIM CHARACTER OR NOT
   TYPE(STRING)                                    :: JOIN      !< THE JOIN OF ARRAY.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE          :: SEP_      !< SEPARATOR, DEFAULT VALUE.
   LOGICAL                                         :: IS_TRIM_  !< FLAG TO SETUP TRIM CHARACTER OR NOT
   INTEGER                                         :: A         !< COUNTER.

   SEP_ = ''
   IF (PRESENT(SEP)) SEP_ = SEP
   IS_TRIM_ = .TRUE. ; IF (PRESENT(IS_TRIM)) IS_TRIM_ = IS_TRIM
   JOIN = ''

   IF (IS_TRIM_) THEN
       DO A=2, SIZE(ARRAY, DIM=1)
          IF (TRIM(ARRAY(A))/='') JOIN%RAW = JOIN%RAW//SEP_//TRIM(ARRAY(A))
       ENDDO
       IF (TRIM(ARRAY(1))/='') THEN
          JOIN%RAW = TRIM(ARRAY(1))//JOIN%RAW
       ELSE
          JOIN%RAW = JOIN%RAW(LEN(SEP_)+1:LEN(JOIN%RAW))
       ENDIF
   ELSE
       DO A=2, SIZE(ARRAY, DIM=1)
          IF (ARRAY(A)/='') JOIN%RAW = JOIN%RAW//SEP_//ARRAY(A)
       ENDDO
       IF (ARRAY(1)/='') THEN
          JOIN%RAW = ARRAY(1)//JOIN%RAW
       ELSE
          JOIN%RAW = JOIN%RAW(LEN(SEP_)+1:LEN(JOIN%RAW))
       ENDIF
   ENDIF
   ENDFUNCTION STRJOIN_CHARACTERS

   PURE FUNCTION STRJOIN_STRINGS_ARRAY(ARRAY, SEP, IS_COL) RESULT(JOIN)
   !< RETURN A STRING THAT IS A JOIN OF COLUMNS OR ROWS OF AN ARRAY OF STRINGS.
   !<
   !< THE JOIN-SEPARATOR IS SET EQUALS TO A NULL STRING '' IF CUSTOM SEPARATOR ISN'T SPECIFIED.
   !< THE IS_COL IS SETUP THE DIRECTION OF JOIN: WITHIN DEFAULT COLUMNS (.TRUE.) OR ROWS(.FALSE.).
   !<
   !<```FORTRAN
   !< TYPE(STRING), ALLOCATABLE :: STRINGS_ARR(:, :)
   !< LOGICAL                   :: TEST_PASSED(5)
   !<
   !< STRINGS_ARR = RESHAPE( SOURCE = &
   !<                        [STRING('ONE'), STRING('TWO'), STRING('THREE'),  &
   !<                         STRING('ONE'), STRING('TWO'), STRING('THREE')], &
   !<                        SHAPE = [3, 2] )
   !<
   !< TEST_PASSED(1) = ALL( STRJOIN(ARRAY=STRINGS_ARR) == &
   !<                       RESHAPE([STRING('ONETWOTHREE'), STRING('ONETWOTHREE')], &
   !<                       SHAPE = [2]) )
   !<
   !< TEST_PASSED(2) = ALL( STRJOIN(ARRAY=STRINGS_ARR, SEP='_') == &
   !<                       RESHAPE([STRING('ONE_TWO_THREE'), STRING('ONE_TWO_THREE')], &
   !<                       SHAPE = [2]) )
   !<
   !<  TEST_PASSED(3) = ALL( STRJOIN(ARRAY=STRINGS_ARR, IS_COL=.FALSE.) == &
   !<                        RESHAPE([STRING('ONEONE'), STRING('TWOTWO'), STRING('THREETHREE')], &
   !<                        SHAPE = [3]) )
   !<
   !<  TEST_PASSED(4) = ALL( STRJOIN(ARRAY=STRINGS_ARR, SEP='_', IS_COL=.FALSE.) == &
   !<                        RESHAPE([STRING('ONE_ONE'), STRING('TWO_TWO'), STRING('THREE_THREE')], &
   !<                        SHAPE = [3]) )
   !<
   !< CALL STRINGS_ARR(2, 1)%FREE
   !< TEST_PASSED(5) = ALL( STRJOIN(ARRAY=STRINGS_ARR, SEP='_', IS_COL=.FALSE.) == &
   !<                  RESHAPE([STRING('ONE_ONE'), STRING('TWO'), STRING('THREE_THREE')], &
   !<                  SHAPE = [3]) )
   !<
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: ARRAY(1:, 1:) !< ARRAY TO BE JOINED.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN), OPTIONAL :: SEP  !< SEPARATOR.
   LOGICAL,                   INTENT(IN), OPTIONAL :: IS_COL  !< DIRECTION: 'COLUMNS' IF .TRUE. OR 'ROWS' IF .FALSE.
   TYPE(STRING),              ALLOCATABLE          :: JOIN(:)       !< THE JOIN OF ARRAY.
   TYPE(STRING),              ALLOCATABLE          :: SLICE(:)      !< THE COLUMN OR ROW SLICE OF ARRAY
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE          :: SEP_          !< SEPARATOR, DEFAULT VALUE.
   LOGICAL                                         :: IS_COL_       !< DIRECTION, DEFAULT VALUE.
   INTEGER                                      :: A, JOIN_SIZE, SLICE_SIZE  !< COUNTER, SIZES OF JOIN VECTOR AND OF SLICE OF ARRAY

   SEP_    = ''     ; IF (PRESENT(SEP)) SEP_ = SEP
   IS_COL_ = .TRUE. ; IF (PRESENT(IS_COL)) IS_COL_ = IS_COL

   IF (IS_COL_) THEN
       JOIN_SIZE  = SIZE(ARRAY, DIM=2)
       SLICE_SIZE = SIZE(ARRAY, DIM=1)

       IF (.NOT.ALLOCATED(JOIN))  ALLOCATE(JOIN(JOIN_SIZE))
       IF (.NOT.ALLOCATED(SLICE)) ALLOCATE(SLICE(SLICE_SIZE))
       DO A = 1, JOIN_SIZE
           SLICE(:) = ARRAY(:, A)
           JOIN(A)  = STRJOIN_STRINGS(SLICE, SEP_)
       END DO
   ELSE
       JOIN_SIZE  = SIZE(ARRAY, DIM=1)
       SLICE_SIZE = SIZE(ARRAY, DIM=2)

       IF (.NOT.ALLOCATED(JOIN))  ALLOCATE(JOIN(JOIN_SIZE))
       IF (.NOT.ALLOCATED(SLICE)) ALLOCATE(SLICE(SLICE_SIZE))
       DO A = 1, JOIN_SIZE
           SLICE(:) = ARRAY(A, :)
           JOIN(A)  = STRJOIN_STRINGS(SLICE, SEP_)
       END DO
   ENDIF
   ENDFUNCTION STRJOIN_STRINGS_ARRAY

  PURE FUNCTION STRJOIN_CHARACTERS_ARRAY(ARRAY, SEP, IS_TRIM, IS_COL) RESULT(JOIN)
   !< RETURN A STRING THAT IS A JOIN OF COLUMNS OR ROWS OF AN ARRAY OF CHARACTERS.
   !<
   !< THE JOIN-SEPARATOR IS SET EQUALS TO A NULL STRING '' IF CUSTOM SEPARATOR ISN'T SPECIFIED.
   !< THE TRIM FUNCTION IS APPLIED TO ARRAY ITEMS IF OPTIONAL LOGICAL IS_TRIM VARIABLE ISN'T SET TO .FALSE.
   !< THE IS_COL IS SETUP THE DIRECTION OF JOIN: WITHIN DEFAULT COLUMNS (.TRUE.) OR ROWS(.FALSE.).
   !<
   !<```FORTRAN
   !< CHARACTER(LEN=10)         :: CHARS_ARR(3, 2)
   !< LOGICAL                   :: TEST_PASSED(9)
   !< CHARS_ARR(:, 1) = ['ONE       ', 'TWO       ', 'THREE     ']
   !< CHARS_ARR(:, 2) = ['ONE       ', 'TWO       ', 'THREE     ']
   !<
   !< TEST_PASSED(1) = ALL( STRJOIN(ARRAY=CHARS_ARR) == &
   !<                       RESHAPE([STRING('ONETWOTHREE'), STRING('ONETWOTHREE')], &
   !<                       SHAPE = [2]) )
   !<
   !< TEST_PASSED(2) = ALL( STRJOIN(ARRAY=CHARS_ARR, IS_TRIM=.FALSE.) ==  &
   !<                       RESHAPE([STRING('ONE       TWO       THREE     '),  &
   !<                                STRING('ONE       TWO       THREE     ')], &
   !<                       SHAPE = [2]) )
   !<
   !< TEST_PASSED(3) = ALL( STRJOIN(ARRAY=CHARS_ARR, SEP='_') == &
   !<                       RESHAPE([STRING('ONE_TWO_THREE'), STRING('ONE_TWO_THREE')], &
   !<                       SHAPE = [2]) )
   !<
   !< TEST_PASSED(4) = ALL( STRJOIN(ARRAY=CHARS_ARR, SEP='_', IS_TRIM=.FALSE.) ==  &
   !<                       RESHAPE([STRING('ONE       _TWO       _THREE     '),  &
   !<                                STRING('ONE       _TWO       _THREE     ')], &
   !<                       SHAPE = [2]) )
   !<
   !< TEST_PASSED(5) = ALL( STRJOIN(ARRAY=CHARS_ARR, IS_COL=.FALSE.) == &
   !<                       RESHAPE([STRING('ONEONE'), STRING('TWOTWO'), STRING('THREETHREE')], &
   !<                       SHAPE = [3]) )
   !<
   !< TEST_PASSED(6) = ALL( STRJOIN(ARRAY=CHARS_ARR, IS_TRIM=.FALSE., IS_COL=.FALSE.) ==  &
   !<                       RESHAPE([STRING('ONE       ONE       '),  &
   !<                                STRING('TWO       TWO       '),  &
   !<                                STRING('THREE     THREE     ')], &
   !<                       SHAPE = [3]) )
   !<
   !< TEST_PASSED(7) = ALL( STRJOIN(ARRAY=CHARS_ARR, SEP='_', IS_COL=.FALSE.) == &
   !<                       RESHAPE([STRING('ONE_ONE'), STRING('TWO_TWO'), STRING('THREE_THREE')], &
   !<                       SHAPE = [3]) )
   !<
   !< TEST_PASSED(8) = ALL( STRJOIN(ARRAY=CHARS_ARR, SEP='_', IS_TRIM=.FALSE., IS_COL=.FALSE.) ==  &
   !<                       RESHAPE([STRING('ONE       _ONE       '),  &
   !<                                STRING('TWO       _TWO       '),  &
   !<                                STRING('THREE     _THREE     ')], &
   !<                       SHAPE = [3]) )
   !<
   !< CHARS_ARR(2,1) = ''
   !< TEST_PASSED(9) = ALL( STRJOIN(ARRAY=CHARS_ARR, SEP='_', IS_COL=.FALSE.) ==  &
   !<                       RESHAPE([STRING('ONE_ONE'),  &
   !<                                STRING('TWO'),  &
   !<                                STRING('THREE_THREE')], &
   !<                       SHAPE = [3]) )
   !<
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)           :: ARRAY(1:, 1:) !< ARRAY TO BE JOINED.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN), OPTIONAL :: SEP       !< SEPARATOR.
   LOGICAL,                   INTENT(IN), OPTIONAL :: IS_TRIM   !< FLAG TO SETUP TRIM CHARACTER OR NOT
   LOGICAL,                   INTENT(IN), OPTIONAL :: IS_COL    !< DIRECTION: 'COLUMNS' IF .TRUE. OR 'ROWS' IF .FALSE.
   TYPE(STRING),              ALLOCATABLE          :: JOIN(:)   !< THE JOIN OF ARRAY.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE          :: SLICE(:)  !< THE COLUMN OR ROW SLICE OF ARRAY
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE          :: SEP_      !< SEPARATOR, DEFAULT VALUE.
   LOGICAL                                         :: IS_TRIM_  !< FLAG TO SETUP TRIM CHARACTER OR NOT
   LOGICAL                                         :: IS_COL_   !< DIRECTION, DEFAULT VALUE.
   INTEGER                                      :: A, JOIN_SIZE, SLICE_SIZE  !< COUNTER, SIZES OF JOIN VECTOR AND OF SLICE OF ARRAY
   INTEGER                                   :: ITEM_LEN  !< LENGTH OF ARRAY ITEM (ALL ITEMS OF CHARACTER ARRAY HAVE EQUAL LENGTHS)

   ITEM_LEN = LEN(ARRAY(1,1)) !< ALL ITEMS OF CHARACTER ARRAY HAVE EQUAL LENGTHS
   SEP_     = ''     ; IF (PRESENT(SEP)) SEP_ = SEP
   IS_TRIM_ = .TRUE. ; IF (PRESENT(IS_TRIM)) IS_TRIM_ = IS_TRIM
   IS_COL_  = .TRUE. ; IF (PRESENT(IS_COL)) IS_COL_ = IS_COL

   IF (IS_COL_) THEN
       JOIN_SIZE  = SIZE(ARRAY, DIM=2)
       SLICE_SIZE = SIZE(ARRAY, DIM=1)

       IF (.NOT.ALLOCATED(JOIN))  ALLOCATE(JOIN(JOIN_SIZE))
       IF (.NOT.ALLOCATED(SLICE)) ALLOCATE(CHARACTER(LEN=ITEM_LEN) :: SLICE(SLICE_SIZE))
       DO A = 1, JOIN_SIZE
           SLICE(:) = ARRAY(:, A)
           JOIN(A)  = STRJOIN_CHARACTERS(SLICE, SEP_, IS_TRIM_)
       END DO
   ELSE
       JOIN_SIZE  = SIZE(ARRAY, DIM=1)
       SLICE_SIZE = SIZE(ARRAY, DIM=2)

       IF (.NOT.ALLOCATED(JOIN))  ALLOCATE(JOIN(JOIN_SIZE))
       IF (.NOT.ALLOCATED(SLICE)) ALLOCATE(CHARACTER(LEN=ITEM_LEN) :: SLICE(SLICE_SIZE))
       DO A = 1, JOIN_SIZE
           SLICE(:) = ARRAY(A, :)
           JOIN(A)  = STRJOIN_CHARACTERS(SLICE, SEP_, IS_TRIM_)
       END DO
   ENDIF
   ENDFUNCTION STRJOIN_CHARACTERS_ARRAY

   ELEMENTAL FUNCTION LOWER(SELF)
   !< RETURN A STRING WITH ALL LOWERCASE CHARACTERS.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = 'HELLO WORLD!'
   !< TEST_PASSED(1) = ASTRING%LOWER()//''=='HELLO WORLD!'
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF  !< THE STRING.
   TYPE(STRING)              :: LOWER !< UPPER CASE STRING.
   INTEGER                   :: N1    !< CHARACTERS COUNTER.
   INTEGER                   :: N2    !< CHARACTERS COUNTER.

   IF (ALLOCATED(SELF%RAW)) THEN
      LOWER = SELF
      DO N1=1, LEN(SELF%RAW)
         N2 = INDEX(UPPER_ALPHABET, SELF%RAW(N1:N1))
         IF (N2>0) LOWER%RAW(N1:N1) = LOWER_ALPHABET(N2:N2)
      ENDDO
   ENDIF
   ENDFUNCTION LOWER

   PURE FUNCTION PARTITION(SELF, SEP) RESULT(PARTITIONS)
   !< SPLIT STRING AT SEPARATOR AND RETURN THE 3 PARTS (BEFORE, THE SEPARATOR AND AFTER).
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< TYPE(STRING) :: STRINGS(3)
   !< LOGICAL      :: TEST_PASSED(3)
   !< ASTRING = 'HELLO WORLD!'
   !< STRINGS = ASTRING%PARTITION(SEP='LO WO')
   !< TEST_PASSED(1) = (STRINGS(1)//''=='HEL'.AND.STRINGS(2)//''=='LO WO'.AND.STRINGS(3)//''=='RLD!')
   !< STRINGS = ASTRING%PARTITION(SEP='HELLO')
   !< TEST_PASSED(2) = (STRINGS(1)//''==''.AND.STRINGS(2)//''=='HELLO'.AND.STRINGS(3)//''==' WORLD!')
   !< ASTRING = 'HELLO WORLD!'
   !< STRINGS = ASTRING%PARTITION()
   !< TEST_PASSED(3) = (STRINGS(1)//''=='HELLO'.AND.STRINGS(2)//''==' '.AND.STRINGS(3)//''=='WORLD!')
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF            !< THE STRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN), OPTIONAL :: SEP             !< SEPARATOR.
   TYPE(STRING)                                    :: PARTITIONS(1:3) !< PARTIONS: BEFORE THE SEPARATOR, THE SEPARATOR ITSELS AND
                                                                      !< AFTER THE SEPARATOR.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE          :: SEP_            !< SEPARATOR, DEFAULT VALUE.
   INTEGER                                         :: C               !< CHARACTER COUNTER.

   IF (ALLOCATED(SELF%RAW)) THEN
      SEP_ = SPACE ; IF (PRESENT(SEP)) SEP_ = SEP

      PARTITIONS(1) = SELF
      PARTITIONS(2) = SEP_
      PARTITIONS(3) = ''
      IF (LEN(SEP_)>=LEN(SELF%RAW)) RETURN
      C = INDEX(SELF%RAW, SEP_)
      IF (C>0) THEN
         PARTITIONS(1)%RAW = SELF%RAW(1:C-1)
         PARTITIONS(2)%RAW = SELF%RAW(C:C+LEN(SEP_)-1)
         PARTITIONS(3)%RAW = SELF%RAW(C+LEN(SEP_):)
      ENDIF
   ENDIF
   ENDFUNCTION PARTITION

   SUBROUTINE READ_FILE(SELF, FILE, IS_FAST, FORM, IOSTAT, IOMSG)
   !< READ A FILE AS A SINGLE STRING STREAM.
   !<
   !< @NOTE ALL THE LINES ARE STORED INTO THE STRING SELF AS A SINGLE ASCII STREAM. EACH LINE (RECORD) IS SEPARATED BY A `NEW_LINE`
   !< CHARACTER.
   !<
   !< @NOTE FOR UNFORMATTED READ ONLY `ACCESS='STREAM'` IS SUPPORTED WITH NEW_LINE AS LINE TERMINATOR.
   !<
   !< @NOTE *FAST* FILE READING ALLOWS A VERY EFFICIENT READING OF STREAMED FILE, BUT IT DUMPS FILE AS SINGLE STREAMED STRING.
   !<
   !<```FORTRAN
   !< TYPE(STRING)              :: ASTRING
   !< TYPE(STRING), ALLOCATABLE :: STRINGS(:)
   !< TYPE(STRING)              :: LINE(3)
   !< INTEGER                   :: IOSTAT
   !< CHARACTER(LEN=99)         :: IOMSG
   !< INTEGER                   :: SCRATCH
   !< INTEGER                   :: L
   !< LOGICAL                   :: TEST_PASSED(9)
   !< LINE(1) = ' HELLO WORLD!   '
   !< LINE(2) = 'HOW ARE YOU?  '
   !< LINE(3) = '   ALL SAY: "FINE THANKS"'
   !< OPEN(NEWUNIT=SCRATCH, FILE='READ_FILE_TEST.TMP')
   !< WRITE(SCRATCH, "(A)") LINE(1)%CHARS()
   !< WRITE(SCRATCH, "(A)") LINE(2)%CHARS()
   !< WRITE(SCRATCH, "(A)") LINE(3)%CHARS()
   !< CLOSE(SCRATCH)
   !< CALL ASTRING%READ_FILE(FILE='READ_FILE_TEST.TMP', IOSTAT=IOSTAT, IOMSG=IOMSG)
   !< CALL ASTRING%SPLIT(TOKENS=STRINGS, SEP=NEW_LINE('A'))
   !< TEST_PASSED(1) = (SIZE(STRINGS, DIM=1)==SIZE(LINE, DIM=1))
   !< DO L=1, SIZE(STRINGS, DIM=1)
   !<   TEST_PASSED(L+1) = (STRINGS(L)==LINE(L))
   !< ENDDO
   !< OPEN(NEWUNIT=SCRATCH, FILE='READ_FILE_TEST.TMP', FORM='UNFORMATTED', ACCESS='STREAM')
   !< WRITE(SCRATCH) LINE(1)%CHARS()//NEW_LINE('A')
   !< WRITE(SCRATCH) LINE(2)%CHARS()//NEW_LINE('A')
   !< WRITE(SCRATCH) LINE(3)%CHARS()//NEW_LINE('A')
   !< CLOSE(SCRATCH)
   !< CALL ASTRING%READ_FILE(FILE='READ_FILE_TEST.TMP', FORM='UNFORMATTED', IOSTAT=IOSTAT, IOMSG=IOMSG)
   !< CALL ASTRING%SPLIT(TOKENS=STRINGS, SEP=NEW_LINE('A'))
   !< TEST_PASSED(5) = (SIZE(STRINGS, DIM=1)==SIZE(LINE, DIM=1))
   !< DO L=1, SIZE(STRINGS, DIM=1)
   !<   TEST_PASSED(L+5) = (STRINGS(L)==LINE(L))
   !< ENDDO
   !< OPEN(NEWUNIT=SCRATCH, FILE='READ_FILE_TEST.TMP', FORM='UNFORMATTED', ACCESS='STREAM')
   !< CLOSE(SCRATCH, STATUS='DELETE')
   !< CALL ASTRING%READ_FILE(FILE='READ_FILE_TEST.TMP', IOSTAT=IOSTAT)
   !< TEST_PASSED(9) = (IOSTAT/=0)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),    INTENT(INOUT)           :: SELF       !< THE STRING.
   CHARACTER(LEN=*), INTENT(IN)              :: FILE       !< FILE NAME.
   LOGICAL,          INTENT(IN),    OPTIONAL :: IS_FAST    !< FLAG TO ENABLE (SUPER) FAST FILE READING.
   CHARACTER(LEN=*), INTENT(IN),    OPTIONAL :: FORM       !< FORMAT OF UNIT.
   INTEGER,          INTENT(OUT),   OPTIONAL :: IOSTAT     !< IO STATUS CODE.
   CHARACTER(LEN=*), INTENT(INOUT), OPTIONAL :: IOMSG      !< IO STATUS MESSAGE.
   LOGICAL                                   :: IS_FAST_   !< FLAG TO ENABLE (SUPER) FAST FILE READING, LOCAL VARIABLE.
   TYPE(STRING)                              :: FORM_      !< FORMAT OF UNIT, LOCAL VARIABLE.
   INTEGER                                   :: IOSTAT_    !< IO STATUS CODE, LOCAL VARIABLE.
   CHARACTER(LEN=:), ALLOCATABLE             :: IOMSG_     !< IO STATUS MESSAGE, LOCAL VARIABLE.
   INTEGER                                   :: UNIT       !< LOGICAL UNIT.
   LOGICAL                                   :: DOES_EXIST !< CHECK IF FILE EXIST.
   INTEGER(I4P)                              :: FILESIZE   !< SIZE OF THE FILE FOR FAST READING.

   IOMSG_ = REPEAT(' ', 99) ; IF (PRESENT(IOMSG)) IOMSG_ = IOMSG
   INQUIRE(FILE=FILE, IOMSG=IOMSG_, IOSTAT=IOSTAT_, EXIST=DOES_EXIST)
   IF (DOES_EXIST) THEN
      IS_FAST_ = .FALSE. ; IF (PRESENT(IS_FAST)) IS_FAST_ = IS_FAST
      IF (IS_FAST_) THEN
         OPEN(NEWUNIT=UNIT, FILE=FILE, ACCESS='STREAM', FORM='UNFORMATTED', IOMSG=IOMSG_, IOSTAT=IOSTAT_)
         INQUIRE(FILE=FILE, SIZE=FILESIZE)
         IF (ALLOCATED(SELF%RAW)) DEALLOCATE(SELF%RAW)
         ALLOCATE(CHARACTER(LEN=FILESIZE):: SELF%RAW)
         READ(UNIT=UNIT, IOSTAT=IOSTAT_, IOMSG=IOMSG_) SELF%RAW
         CLOSE(UNIT)
      ELSE
         FORM_ = 'FORMATTED' ; IF (PRESENT(FORM)) FORM_ = FORM ; FORM_ = FORM_%UPPER()
         SELECT CASE(FORM_%CHARS())
         CASE('FORMATTED')
            OPEN(NEWUNIT=UNIT, FILE=FILE, STATUS='OLD', ACTION='READ', IOMSG=IOMSG_, IOSTAT=IOSTAT_, ERR=10)
         CASE('UNFORMATTED')
            OPEN(NEWUNIT=UNIT, FILE=FILE, STATUS='OLD', ACTION='READ', FORM='UNFORMATTED', ACCESS='STREAM', &
                 IOMSG=IOMSG_, IOSTAT=IOSTAT_, ERR=10)
         ENDSELECT
         CALL SELF%READ_LINES(UNIT=UNIT, FORM=FORM, IOMSG=IOMSG_, IOSTAT=IOSTAT_)
         10 CLOSE(UNIT)
      ENDIF
   ELSE
      IOSTAT_ = 1
      IOMSG_ = 'FILE NOT FOUND'
   ENDIF
   IF (PRESENT(IOSTAT)) IOSTAT = IOSTAT_
   IF (PRESENT(IOMSG)) IOMSG = IOMSG_
   ENDSUBROUTINE READ_FILE

   SUBROUTINE READ_LINE(SELF, UNIT, FORM, IOSTAT, IOMSG)
   !< READ LINE (RECORD) FROM A CONNECTED UNIT.
   !<
   !< THE LINE IS READ AS AN ASCII STREAM READ UNTIL THE EOR IS REACHED.
   !<
   !< @NOTE FOR UNFORMATTED READ ONLY `ACCESS='STREAM'` IS SUPPORTED WITH NEW_LINE AS LINE TERMINATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING)      :: ASTRING
   !< TYPE(STRING)      :: LINE(3)
   !< INTEGER           :: IOSTAT
   !< CHARACTER(LEN=99) :: IOMSG
   !< INTEGER           :: SCRATCH
   !< INTEGER           :: L
   !< LOGICAL           :: TEST_PASSED(6)
   !< LINE(1) = ' HELLO WORLD!   '
   !< LINE(2) = 'HOW ARE YOU?  '
   !< LINE(3) = '   ALL SAY: "FINE THANKS"'
   !< OPEN(NEWUNIT=SCRATCH, STATUS='SCRATCH')
   !< WRITE(SCRATCH, "(A)") LINE(1)%CHARS()
   !< WRITE(SCRATCH, "(A)") LINE(2)%CHARS()
   !< WRITE(SCRATCH, "(A)") LINE(3)%CHARS()
   !< REWIND(SCRATCH)
   !< L = 0
   !< IOSTAT = 0
   !< DO
   !<   L = L + 1
   !<   CALL ASTRING%READ_LINE(UNIT=SCRATCH, IOSTAT=IOSTAT, IOMSG=IOMSG)
   !<   IF (IOSTAT/=0.AND..NOT.IS_IOSTAT_EOR(IOSTAT)) THEN
   !<     EXIT
   !<   ELSE
   !<     TEST_PASSED(L) = (ASTRING==LINE(L))
   !<   ENDIF
   !< ENDDO
   !< CLOSE(SCRATCH)
   !< OPEN(NEWUNIT=SCRATCH, STATUS='SCRATCH', FORM='UNFORMATTED', ACCESS='STREAM')
   !< WRITE(SCRATCH) LINE(1)%CHARS()//NEW_LINE('A')
   !< WRITE(SCRATCH) LINE(2)%CHARS()//NEW_LINE('A')
   !< WRITE(SCRATCH) LINE(3)%CHARS()//NEW_LINE('A')
   !< REWIND(SCRATCH)
   !< L = 0
   !< IOSTAT = 0
   !< DO
   !<   L = L + 1
   !<   CALL ASTRING%READ_LINE(UNIT=SCRATCH, IOSTAT=IOSTAT, IOMSG=IOMSG, FORM='UNFORMATTED')
   !<   IF (IOSTAT/=0.AND..NOT.IS_IOSTAT_EOR(IOSTAT)) THEN
   !<     EXIT
   !<   ELSE
   !<     TEST_PASSED(L+3) = (ASTRING==LINE(L))
   !<   ENDIF
   !< ENDDO
   !< CLOSE(SCRATCH)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),    INTENT(INOUT)           :: SELF    !< THE STRING.
   INTEGER,          INTENT(IN)              :: UNIT    !< LOGICAL UNIT.
   CHARACTER(LEN=*), INTENT(IN),    OPTIONAL :: FORM    !< FORMAT OF UNIT.
   INTEGER,          INTENT(OUT),   OPTIONAL :: IOSTAT  !< IO STATUS CODE.
   CHARACTER(LEN=*), INTENT(INOUT), OPTIONAL :: IOMSG   !< IO STATUS MESSAGE.
   TYPE(STRING)                              :: FORM_   !< FORMAT OF UNIT, LOCAL VARIABLE.
   INTEGER                                   :: IOSTAT_ !< IO STATUS CODE, LOCAL VARIABLE.
   CHARACTER(LEN=:),          ALLOCATABLE    :: IOMSG_  !< IO STATUS MESSAGE, LOCAL VARIABLE.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE    :: LINE    !< LINE STORAGE.
   CHARACTER(KIND=CK, LEN=1)                 :: CH      !< CHARACTER STORAGE.

   FORM_ = 'FORMATTED' ; IF (PRESENT(FORM)) FORM_ = FORM ; FORM_ = FORM_%UPPER()
   IOMSG_ = REPEAT(' ', 99) ; IF (PRESENT(IOMSG)) IOMSG_ = IOMSG
   LINE = ''
   SELECT CASE(FORM_%CHARS())
   CASE('FORMATTED')
      DO
         READ(UNIT, "(A)", ADVANCE='NO', IOSTAT=IOSTAT_, IOMSG=IOMSG_, ERR=10, END=10, EOR=10) CH
         LINE = LINE//CH
      ENDDO
   CASE('UNFORMATTED')
      DO
         READ(UNIT, IOSTAT=IOSTAT_, IOMSG=IOMSG_, ERR=10, END=10) CH
         IF (CH==NEW_LINE('A')) THEN
            IOSTAT_ = IOSTAT_EOR
            EXIT
         ENDIF
         LINE = LINE//CH
      ENDDO
   ENDSELECT
   10 IF (LINE/='') SELF%RAW = LINE
   IF (PRESENT(IOSTAT)) IOSTAT = IOSTAT_
   IF (PRESENT(IOMSG)) IOMSG = IOMSG_
   ENDSUBROUTINE READ_LINE

   SUBROUTINE READ_LINES(SELF, UNIT, FORM, IOSTAT, IOMSG)
   !< READ (ALL) LINES (RECORDS) FROM A CONNECTED UNIT AS A SINGLE ASCII STREAM.
   !<
   !< @NOTE ALL THE LINES ARE STORED INTO THE STRING SELF AS A SINGLE ASCII STREAM. EACH LINE (RECORD) IS SEPARATED BY A `NEW_LINE`
   !< CHARACTER. THE LINE IS READ AS AN ASCII STREAM READ UNTIL THE EOR IS REACHED.
   !<
   !< @NOTE THE CONNECTED UNIT IS REWINDED. AT A SUCCESSFUL EXIT CURRENT RECORD IS AT EOF, AT THE BEGINNING OTHERWISE.
   !<
   !< @NOTE FOR UNFORMATTED READ ONLY `ACCESS='STREAM'` IS SUPPORTED WITH NEW_LINE AS LINE TERMINATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING)              :: ASTRING
   !< TYPE(STRING), ALLOCATABLE :: STRINGS(:)
   !< TYPE(STRING)              :: LINE(3)
   !< INTEGER                   :: IOSTAT
   !< CHARACTER(LEN=99)         :: IOMSG
   !< INTEGER                   :: SCRATCH
   !< INTEGER                   :: L
   !< LOGICAL                   :: TEST_PASSED(8)
   !<
   !< LINE(1) = ' HELLO WORLD!   '
   !< LINE(2) = 'HOW ARE YOU?  '
   !< LINE(3) = '   ALL SAY: "FINE THANKS"'
   !< OPEN(NEWUNIT=SCRATCH, STATUS='SCRATCH')
   !< WRITE(SCRATCH, "(A)") LINE(1)%CHARS()
   !< WRITE(SCRATCH, "(A)") LINE(2)%CHARS()
   !< WRITE(SCRATCH, "(A)") LINE(3)%CHARS()
   !< CALL ASTRING%READ_LINES(UNIT=SCRATCH, IOSTAT=IOSTAT, IOMSG=IOMSG)
   !< CALL ASTRING%SPLIT(TOKENS=STRINGS, SEP=NEW_LINE('A'))
   !< TEST_PASSED(1) = (SIZE(STRINGS, DIM=1)==SIZE(LINE, DIM=1))
   !< DO L=1, SIZE(STRINGS, DIM=1)
   !<   TEST_PASSED(L+1) = (STRINGS(L)==LINE(L))
   !< ENDDO
   !< CLOSE(SCRATCH)
   !< OPEN(NEWUNIT=SCRATCH, STATUS='SCRATCH', FORM='UNFORMATTED', ACCESS='STREAM')
   !< WRITE(SCRATCH) LINE(1)%CHARS()//NEW_LINE('A')
   !< WRITE(SCRATCH) LINE(2)%CHARS()//NEW_LINE('A')
   !< WRITE(SCRATCH) LINE(3)%CHARS()//NEW_LINE('A')
   !< CALL ASTRING%READ_LINES(UNIT=SCRATCH, FORM='UNFORMATTED', IOSTAT=IOSTAT, IOMSG=IOMSG)
   !< CALL ASTRING%SPLIT(TOKENS=STRINGS, SEP=NEW_LINE('A'))
   !< TEST_PASSED(5) = (SIZE(STRINGS, DIM=1)==SIZE(LINE, DIM=1))
   !< DO L=1, SIZE(STRINGS, DIM=1)
   !<   TEST_PASSED(L+5) = (STRINGS(L)==LINE(L))
   !< ENDDO
   !< CLOSE(SCRATCH)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),    INTENT(INOUT)           :: SELF    !< THE STRING.
   INTEGER,          INTENT(IN)              :: UNIT    !< LOGICAL UNIT.
   CHARACTER(LEN=*), INTENT(IN),    OPTIONAL :: FORM    !< FORMAT OF UNIT.
   INTEGER,          INTENT(OUT),   OPTIONAL :: IOSTAT  !< IO STATUS CODE.
   CHARACTER(LEN=*), INTENT(INOUT), OPTIONAL :: IOMSG   !< IO STATUS MESSAGE.
   INTEGER                                   :: IOSTAT_ !< IO STATUS CODE, LOCAL VARIABLE.
   CHARACTER(LEN=:), ALLOCATABLE             :: IOMSG_  !< IO STATUS MESSAGE, LOCAL VARIABLE.
   TYPE(STRING)                              :: LINES   !< LINES STORAGE.
   TYPE(STRING)                              :: LINE    !< LINE STORAGE.

   IOMSG_ = REPEAT(' ', 99) ; IF (PRESENT(IOMSG)) IOMSG_ = IOMSG
   REWIND(UNIT)
   IOSTAT_ = 0
   LINES%RAW = ''
   DO
      LINE%RAW = ''
      CALL LINE%READ_LINE(UNIT=UNIT, FORM=FORM, IOSTAT=IOSTAT_, IOMSG=IOMSG_)
      IF (IOSTAT_/=0.AND..NOT.IS_IOSTAT_EOR(IOSTAT_)) THEN
         EXIT
      ELSEIF (LINE/='') THEN
         LINES%RAW = LINES%RAW//LINE%RAW//NEW_LINE('A')
      ENDIF
   ENDDO
   IF (LINES%RAW/='') SELF%RAW = LINES%RAW
   IF (PRESENT(IOSTAT)) IOSTAT = IOSTAT_
   IF (PRESENT(IOMSG)) IOMSG = IOMSG_
   ENDSUBROUTINE READ_LINES

   ELEMENTAL FUNCTION REPLACE(SELF, OLD, NEW, COUNT) RESULT(REPLACED)
   !< RETURN A STRING WITH ALL OCCURRENCES OF SUBSTRING OLD REPLACED BY NEW.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(3)
   !< ASTRING = 'WHEN YOU ARE SAD YOU SHOULD THINK TO ME :-)'
   !< TEST_PASSED(1) = (ASTRING%REPLACE(OLD='YOU', NEW='THEY')//''=='WHEN THEY ARE SAD THEY SHOULD THINK TO ME :-)')
   !< TEST_PASSED(2) = (ASTRING%REPLACE(OLD='YOU', NEW='THEY', COUNT=1)//''=='WHEN THEY ARE SAD YOU SHOULD THINK TO ME :-)')
   !< ASTRING = REPEAT(NEW_LINE('A')//'ABCD', 20)
   !< ASTRING = ASTRING%REPLACE(OLD=NEW_LINE('A'), NEW='|CR|')
   !< ASTRING = ASTRING%REPLACE(OLD='|CR|', NEW=NEW_LINE('A')//'    ')
   !< TEST_PASSED(3) = (ASTRING//''==REPEAT(NEW_LINE('A')//'    '//'ABCD', 20))
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF     !< THE STRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)           :: OLD      !< OLD SUBSTRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)           :: NEW      !< NEW SUBSTRING.
   INTEGER,                   INTENT(IN), OPTIONAL :: COUNT    !< NUMBER OF OLD OCCURENCES TO BE REPLACED.
   TYPE(STRING)                                    :: REPLACED !< THE STRING WITH OLD REPLACED BY NEW.
   INTEGER                                         :: R        !< COUNTER.

   IF (ALLOCATED(SELF%RAW)) THEN
      REPLACED = SELF
      R = 0
      DO
         IF (INDEX(REPLACED%RAW, OLD)>0) THEN
            REPLACED = REPLACED%REPLACE_ONE_OCCURRENCE(OLD=OLD, NEW=NEW)
            R = R + 1
            IF (PRESENT(COUNT)) THEN
               IF (R>=COUNT) EXIT
            ENDIF
         ELSE
            EXIT
         ENDIF
      ENDDO
   ENDIF
   ENDFUNCTION REPLACE

   ELEMENTAL FUNCTION REVERSE(SELF) RESULT(REVERSED)
   !< RETURN A REVERSED STRING.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(2)
   !< ASTRING = 'ABCDEFGHILMNOPQRSTUVZ'
   !< TEST_PASSED(1) = (ASTRING%REVERSE()//''=='ZVUTSRQPONMLIHGFEDCBA')
   !< ASTRING = '0123456789'
   !< TEST_PASSED(2) = (ASTRING%REVERSE()//''=='9876543210')
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF     !< THE STRING.
   TYPE(STRING)              :: REVERSED !< THE REVERSED STRING.
   INTEGER                   :: LENGTH   !< LENGTH OF THE STRING.
   INTEGER                   :: C        !< COUNTER.

   IF (ALLOCATED(SELF%RAW)) THEN
      REVERSED = SELF
      LENGTH = LEN(SELF%RAW)
      DO C=1, LENGTH
         REVERSED%RAW(C:C) = SELF%RAW(LENGTH-C+1:LENGTH-C+1)
      ENDDO
   ENDIF
   ENDFUNCTION REVERSE

   FUNCTION SEARCH(SELF, TAG_START, TAG_END, IN_STRING, IN_CHARACTER, ISTART, IEND) RESULT(TAG)
   !< SEARCH FOR *TAGGED* RECORD INTO STRING, RETURN THE FIRST RECORD FOUND (IF ANY) MATCHING THE TAGS.
   !<
   !< OPTIONALLY, RETURNS THE INDEXES OF TAG START/END, THUS THIS IS NOT AN `ELEMENTAL` FUNCTION.
   !<
   !< @NOTE THE TAGGED RECORD IS SEARCHED INTO SELF IF ALLOCATED OTHERWISE INTO `IN_STRING` IF PASSED OR, EVENTUALLY, INTO
   !< `IN_CHARACTER` IS PASSED. IF TAG IS NOT FOUND THE RETURN STRING IS NOT ALLOCATED AND THE START/END INDEXES (IF REQUESTED) ARE
   !< ZERO.
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< TYPE(STRING)                  :: ANOTHERSTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: ACHARACTER
   !< INTEGER                       :: ISTART
   !< INTEGER                       :: IEND
   !< LOGICAL                       :: TEST_PASSED(5)
   !< ASTRING = '<TEST> <FIRST> HELLO </FIRST> <FIRST> NOT THE FIRST </FIRST> </TEST>'
   !< ANOTHERSTRING = ASTRING%SEARCH(TAG_START='<FIRST>', TAG_END='</FIRST>')
   !< TEST_PASSED(1) = ANOTHERSTRING//''=='<FIRST> HELLO </FIRST>'
   !< ASTRING = '<TEST> <A> <A> <A> THE NESTED A </A> </A> </A> </TEST>'
   !< ANOTHERSTRING = ASTRING%SEARCH(TAG_START='<A>', TAG_END='</A>')
   !< TEST_PASSED(2) = ANOTHERSTRING//''=='<A> <A> <A> THE NESTED A </A> </A> </A>'
   !< CALL ASTRING%FREE
   !< ANOTHERSTRING = '<TEST> <A> <A> <A> THE NESTED A </A> </A> </A> </TEST>'
   !< ASTRING = ASTRING%SEARCH(IN_STRING=ANOTHERSTRING, TAG_START='<A>', TAG_END='</A>')
   !< TEST_PASSED(3) = ASTRING//''=='<A> <A> <A> THE NESTED A </A> </A> </A>'
   !< CALL ASTRING%FREE
   !< ACHARACTER = '<TEST> <A> <A> <A> THE NESTED A </A> </A> </A> </TEST>'
   !< ASTRING = ASTRING%SEARCH(IN_CHARACTER=ACHARACTER, TAG_START='<A>', TAG_END='</A>')
   !< TEST_PASSED(4) = ASTRING//''=='<A> <A> <A> THE NESTED A </A> </A> </A>'
   !< ACHARACTER = '<TEST> <FIRST> HELLO </FIRST> <SEC> <SEC>NOT THE FIRST</SEC> </SEC> </TEST>'
   !< ASTRING = ASTRING%SEARCH(IN_CHARACTER=ACHARACTER, TAG_START='<SEC>', TAG_END='</SEC>', ISTART=ISTART, IEND=IEND)
   !< TEST_PASSED(5) = ASTRING//''==ACHARACTER(31:67)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)            :: SELF         !< THE STRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)            :: TAG_START    !< START TAG.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)            :: TAG_END      !< END TAG.
   TYPE(STRING),              INTENT(IN),  OPTIONAL :: IN_STRING    !< SEARCH INTO THIS STRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN),  OPTIONAL :: IN_CHARACTER !< SEARCH INTO THIS CHARACTER STRING.
   INTEGER,                   INTENT(OUT), OPTIONAL :: ISTART       !< STARTING INDEX OF TAG INSIDE THE STRING.
   INTEGER,                   INTENT(OUT), OPTIONAL :: IEND         !< ENDING INDEX OF TAG INSIDE THE STRING.
   TYPE(STRING)                                     :: TAG          !< FIRST TAG FOUND.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE           :: RAW          !< RAW STRING INTO WHICH SEARCH THE TAG.
   INTEGER                                          :: ISTART_      !< STARTING INDEX OF TAG INSIDE THE STRING, LOCAL VARIABLE.
   INTEGER                                          :: IEND_        !< ENDING INDEX OF TAG INSIDE THE STRING, LOCAL VARIABLE.
   INTEGER                                          :: NESTED_TAGS  !< NUMBER OF NESTED TAGS INSIDE TAG.
   INTEGER                                          :: T            !< COUNTER.

   RAW = ''
   IF (PRESENT(IN_STRING)) THEN
      RAW = IN_STRING%RAW
   ELSEIF (PRESENT(IN_CHARACTER)) THEN
      RAW = IN_CHARACTER
   ELSE
      IF (ALLOCATED(SELF%RAW)) RAW = SELF%RAW
   ENDIF
   ISTART_ = 0
   IEND_ = 0
   IF (RAW/='') THEN
      ISTART_ = INDEX(RAW, TAG_START)
      IEND_ = INDEX(RAW, TAG_END)
      IF (ISTART_>0.AND.IEND_>0) THEN
         IEND_ = IEND_ + LEN(TAG_END) - 1
         TAG%RAW = RAW(ISTART_:IEND_)
         NESTED_TAGS = TAG%COUNT(TAG_START)
         IF (NESTED_TAGS>1) THEN
            DO T=2, NESTED_TAGS
               IEND_ = IEND_ + LEN(TAG_END) - 1 + INDEX(RAW(IEND_+1:), TAG_END)
            ENDDO
            TAG%RAW = RAW(ISTART_:IEND_)
         ENDIF
      ENDIF
   ENDIF
   IF (PRESENT(ISTART)) ISTART = ISTART_
   IF (PRESENT(IEND)) IEND = IEND_
   ENDFUNCTION SEARCH

   PURE FUNCTION SLICE(SELF, ISTART, IEND) RESULT(RAW)
   !< RETURN THE RAW CHARACTERS DATA SLICED.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< ASTRING = 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.'
   !< PRINT "(A)", ASTRING%SLICE(11,25)
   !<```
   !=> BROWN FOX JUMPS <<<
   CLASS(STRING), INTENT(IN)              :: SELF   !< THE STRING.
   INTEGER,       INTENT(IN)              :: ISTART !< SLICE START INDEX.
   INTEGER,       INTENT(IN)              :: IEND   !< SLICE END   INDEX.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE :: RAW    !< RAW CHARACTERS DATA.

   IF (ALLOCATED(SELF%RAW)) THEN
      RAW = SELF%RAW(ISTART:IEND)
   ELSE
      RAW = ''
   ENDIF
   ENDFUNCTION SLICE

   ELEMENTAL FUNCTION SNAKECASE(SELF, SEP)
   !< RETURN A STRING WITH ALL WORDS LOWERCASE SEPARATED BY "_".
   !<
   !< @NOTE MULTIPLE SUBSEQUENT SEPARATORS ARE COLLAPSED TO ONE OCCURENCE.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.'
   !< TEST_PASSED(1) = ASTRING%SNAKECASE()//''=='THE_QUICK_BROWN_FOX_JUMPS_OVER_THE_LAZY_DOG.'
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF      !< THE STRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN), OPTIONAL :: SEP       !< SEPARATOR.
   TYPE(STRING)                                    :: SNAKECASE !< SNAKE CASE STRING.
   TYPE(STRING), ALLOCATABLE                       :: TOKENS(:) !< STRING TOKENS.

   IF (ALLOCATED(SELF%RAW)) THEN
      CALL SELF%SPLIT(TOKENS=TOKENS, SEP=SEP)
      TOKENS = TOKENS%LOWER()
      SNAKECASE = SNAKECASE%JOIN(ARRAY=TOKENS, SEP='_')
   ENDIF
   ENDFUNCTION SNAKECASE

   PURE SUBROUTINE SPLIT(SELF, TOKENS, SEP, MAX_TOKENS)
   !< RETURN A LIST OF SUBSTRING IN THE STRING, USING SEP AS THE DELIMITER STRING.
   !<
   !< @NOTE MULTIPLE SUBSEQUENT SEPARATORS ARE COLLAPSED TO ONE OCCURRENCE.
   !<
   !< @NOTE IF `MAX_TOKENS` IS PASSED THE RETURNED NUMBER OF TOKENS IS EITHER `MAX_TOKENS` OR `MAX_TOKENS + 1`.
   !<
   !<```FORTRAN
   !< TYPE(STRING)              :: ASTRING
   !< TYPE(STRING), ALLOCATABLE :: STRINGS(:)
   !< LOGICAL                   :: TEST_PASSED(11)
   !< ASTRING = '+AB-++CRE-++CRE-AB+'
   !< CALL ASTRING%SPLIT(TOKENS=STRINGS, SEP='+')
   !< TEST_PASSED(1) = (STRINGS(1)//''=='AB-'.AND.STRINGS(2)//''=='CRE-'.AND.STRINGS(3)//''=='CRE-AB')
   !< ASTRING = 'AB-++CRE-++CRE-AB+'
   !< CALL ASTRING%SPLIT(TOKENS=STRINGS, SEP='+')
   !< TEST_PASSED(2) = (STRINGS(1)//''=='AB-'.AND.STRINGS(2)//''=='CRE-'.AND.STRINGS(3)//''=='CRE-AB')
   !< ASTRING = 'AB-++CRE-++CRE-AB'
   !< CALL ASTRING%SPLIT(TOKENS=STRINGS, SEP='+')
   !< TEST_PASSED(3) = (STRINGS(1)//''=='AB-'.AND.STRINGS(2)//''=='CRE-'.AND.STRINGS(3)//''=='CRE-AB')
   !< ASTRING = 'HELLO '//NEW_LINE('A')//'WORLD!'
   !< CALL ASTRING%SPLIT(TOKENS=STRINGS, SEP=NEW_LINE('A'))
   !< TEST_PASSED(4) = (STRINGS(1)//''=='HELLO '.AND.STRINGS(2)//''=='WORLD!')
   !< ASTRING = 'HELLO WORLD!'
   !< CALL ASTRING%SPLIT(TOKENS=STRINGS)
   !< TEST_PASSED(5) = (STRINGS(1)//''=='HELLO'.AND.STRINGS(2)//''=='WORLD!')
   !< ASTRING = '+AB-'
   !< CALL ASTRING%SPLIT(TOKENS=STRINGS, SEP='+')
   !< TEST_PASSED(6) = (STRINGS(1)//''=='AB-')
   !< ASTRING = '+AB-'
   !< CALL ASTRING%SPLIT(TOKENS=STRINGS, SEP='-')
   !< TEST_PASSED(7) = (STRINGS(1)//''=='+AB')
   !< ASTRING = '+AB-+CD-'
   !< CALL ASTRING%SPLIT(TOKENS=STRINGS, SEP='+')
   !< TEST_PASSED(8) = (STRINGS(1)//''=='AB-'.AND.STRINGS(2)//''=='CD-')
   !< ASTRING = 'AB-+CD-+'
   !< CALL ASTRING%SPLIT(TOKENS=STRINGS, SEP='+')
   !< TEST_PASSED(9) = (STRINGS(1)//''=='AB-'.AND.STRINGS(2)//''=='CD-')
   !< ASTRING = '+AB-+CD-+'
   !< CALL ASTRING%SPLIT(TOKENS=STRINGS, SEP='+')
   !< TEST_PASSED(10) = (STRINGS(1)//''=='AB-'.AND.STRINGS(2)//''=='CD-')
   !< ASTRING = '1-2-3-4-5-6-7-8'
   !< CALL ASTRING%SPLIT(TOKENS=STRINGS, SEP='-', MAX_TOKENS=3)
   !< TEST_PASSED(11) = (STRINGS(1)//''=='1'.AND.STRINGS(2)//''=='2'.AND.STRINGS(3)//''=='3'.AND.STRINGS(4)//''=='4-5-6-7-8')
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF           !< THE STRING.
   TYPE(STRING), ALLOCATABLE, INTENT(OUT)          :: TOKENS(:)      !< TOKENS SUBSTRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN), OPTIONAL :: SEP            !< SEPARATOR.
   INTEGER,                   INTENT(IN), OPTIONAL :: MAX_TOKENS     !< FIX THE MAXIMUM NUMBER OF RETURNED TOKENS.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE          :: SEP_           !< SEPARATOR, DEFAULT VALUE.
   INTEGER                                         :: NO             !< NUMBER OF OCCURRENCES OF SEP.
   INTEGER                                         :: T              !< CHARACTER COUNTER.
   TYPE(STRING)                                    :: TEMPORARY      !< TEMPORARY STORAGE.
   TYPE(STRING), ALLOCATABLE                       :: TEMP_TOKS(:,:) !< TEMPORARY TOKENS SUBSTRING.

   IF (ALLOCATED(SELF%RAW)) THEN
     SEP_ = SPACE ; IF (PRESENT(SEP)) SEP_ = SEP

     TEMPORARY = SELF%UNIQUE(SEP_)
     NO = TEMPORARY%COUNT(SEP_)

     IF (NO>0) THEN
       IF (PRESENT(MAX_TOKENS)) THEN
         IF (MAX_TOKENS < NO.AND.MAX_TOKENS > 0) NO = MAX_TOKENS
       ENDIF
       ALLOCATE(TEMP_TOKS(3, NO))
       TEMP_TOKS(:, 1) = TEMPORARY%PARTITION(SEP_)
       IF (NO>1) THEN
         DO T=2, NO
           TEMP_TOKS(:, T) = TEMP_TOKS(3, T-1)%PARTITION(SEP_)
         ENDDO
       ENDIF

       IF (TEMP_TOKS(1, 1)%RAW/=''.AND.TEMP_TOKS(3, NO)%RAW/='') THEN
         ALLOCATE(TOKENS(NO+1))
         DO T=1, NO
           IF (T==NO) THEN
             TOKENS(T  ) = TEMP_TOKS(1, T)
             TOKENS(T+1) = TEMP_TOKS(3, T)
           ELSE
             TOKENS(T) = TEMP_TOKS(1, T)
           ENDIF
         ENDDO
       ELSEIF (TEMP_TOKS(1, 1)%RAW/='') THEN
         ALLOCATE(TOKENS(NO))
         DO T=1, NO
           TOKENS(T) = TEMP_TOKS(1, T)
         ENDDO
       ELSEIF (TEMP_TOKS(3, NO)%RAW/='') THEN
         ALLOCATE(TOKENS(NO))
         DO T=1, NO-1
           TOKENS(T) = TEMP_TOKS(1, T+1)
         ENDDO
         TOKENS(NO) = TEMP_TOKS(3, NO)
       ELSE
         ALLOCATE(TOKENS(NO-1))
         DO T=2, NO
           TOKENS(T-1) = TEMP_TOKS(1, T)
         ENDDO
       ENDIF

     ELSE
       ALLOCATE(TOKENS(1))
       TOKENS(1) = SELF
     ENDIF
   ENDIF
   ENDSUBROUTINE SPLIT

   PURE SUBROUTINE SPLIT_CHUNKED(SELF, TOKENS, CHUNKS, SEP)
   !< RETURN A LIST OF SUBSTRING IN THE STRING, USING SEP AS THE DELIMITER STRING, CHUNKED (MEMORY-EFFICIENT) ALGORITHM.
   !<
   !< @NOTE MULTIPLE SUBSEQUENT SEPARATORS ARE COLLAPSED TO ONE OCCURRENCE.
   !<
   !< @NOTE THE SPLIT IS PERFORMED IN CHUNKS OF `#CHUNKS` TO AVOID EXCESSIVE MEMORY CONSUMPTION.
   !<
   !<```FORTRAN
   !< TYPE(STRING)              :: ASTRING
   !< TYPE(STRING), ALLOCATABLE :: STRINGS(:)
   !< LOGICAL                   :: TEST_PASSED(1)
   !< ASTRING = '-1-2-3-4-5-6-7-8-'
   !< CALL ASTRING%SPLIT_CHUNKED(TOKENS=STRINGS, SEP='-', CHUNKS=3)
   !< TEST_PASSED(1) = (STRINGS(1)//''=='1'.AND.STRINGS(2)//''=='2'.AND.STRINGS(3)//''=='3'.AND.STRINGS(4)//''=='4'.AND. &
   !<                   STRINGS(5)//''=='5'.AND.STRINGS(6)//''=='6'.AND.STRINGS(7)//''=='7'.AND.STRINGS(8)//''=='8')
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF      !< THE STRING.
   TYPE(STRING), ALLOCATABLE, INTENT(OUT)          :: TOKENS(:) !< TOKENS SUBSTRING.
   INTEGER,                   INTENT(IN)           :: CHUNKS    !< NUMBER OF CHUNKS.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN), OPTIONAL :: SEP       !< SEPARATOR.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE          :: SEP_      !< SEPARATOR, DEFAULT VALUE.
   INTEGER                                         :: NT        !< NUMBER OF ACTUAL TOKENS.
   INTEGER                                         :: T         !< COUNTER.
   LOGICAL                                         :: ISOK

   IF (ALLOCATED(SELF%RAW)) THEN
     SEP_ = SPACE ; IF (PRESENT(SEP)) SEP_ = SEP

     NT = SELF%COUNT(SEP_)
     IF (SELF%START_WITH(PREFIX=SEP_)) NT = NT - 1
     IF (SELF%END_WITH(SUFFIX=SEP_)) NT = NT - 1
     T = 0
     CALL SELF%SPLIT(TOKENS=TOKENS, SEP=SEP_, MAX_TOKENS=CHUNKS)
     DO
       T = SIZE(TOKENS, DIM=1)
       IF (T > NT) EXIT
       CALL SPLIT_LAST_TOKEN(TOKENS=TOKENS, MAX_TOKENS=CHUNKS,ISOK=ISOK)
       IF(ISOK)THEN
       ELSE
            EXIT
       ENDIF
     ENDDO

     T = SIZE(TOKENS, DIM=1)
     IF (TOKENS(T)%COUNT(SEP_) > 0) THEN
        CALL SPLIT_LAST_TOKEN(TOKENS=TOKENS,ISOK=ISOK)
     ENDIF
   ENDIF

   CONTAINS
      PURE SUBROUTINE SPLIT_LAST_TOKEN(TOKENS, MAX_TOKENS,ISOK)
      !< SPLIT LAST TOKEN.
      TYPE(STRING), ALLOCATABLE, INTENT(INOUT)        :: TOKENS(:)      !< TOKENS SUBSTRING.
      INTEGER,                   INTENT(IN), OPTIONAL :: MAX_TOKENS     !< MAX TOKENS RETURNED.
      TYPE(STRING), ALLOCATABLE                       :: TOKENS_(:)     !< TEMPORARY TOKENS.
      TYPE(STRING), ALLOCATABLE                       :: TOKENS_SWAP(:) !< SWAP TOKENS.
      INTEGER                                         :: NT_            !< NUMBER OF LAST CREATED TOKENS.
      LOGICAL,INTENT(OUT)                             :: ISOK

      ISOK=.TRUE.
      CALL TOKENS(T)%SPLIT(TOKENS=TOKENS_, SEP=SEP_, MAX_TOKENS=MAX_TOKENS)
      IF (ALLOCATED(TOKENS_)) THEN
        NT_ = SIZE(TOKENS_, DIM=1)
        IF (NT_ >= 1) THEN
          ALLOCATE(TOKENS_SWAP(1:T-1+NT_))
          TOKENS_SWAP(1:T-1) = TOKENS(1:T-1)
          TOKENS_SWAP(T:)    = TOKENS_(:)
          CALL MOVE_ALLOC(FROM=TOKENS_SWAP, TO=TOKENS)
        ENDIF
        IF (NT_ == 1) THEN
            ISOK=.FALSE.
        END IF
        DEALLOCATE(TOKENS_)
      ENDIF
      ENDSUBROUTINE SPLIT_LAST_TOKEN
   ENDSUBROUTINE SPLIT_CHUNKED

   ELEMENTAL FUNCTION STARTCASE(SELF, SEP)
   !< RETURN A STRING WITH ALL WORDS CAPITALIZED, E.G. TITLE CASE.
   !<
   !< @NOTE MULTIPLE SUBSEQUENT SEPARATORS ARE COLLAPSED TO ONE OCCURENCE.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.'
   !< TEST_PASSED(1) = ASTRING%STARTCASE()//''=='THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.'
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF      !< THE STRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN), OPTIONAL :: SEP       !< SEPARATOR.
   TYPE(STRING)                                    :: STARTCASE !< START CASE STRING.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE          :: SEP_      !< SEPARATOR, DEFAULT VALUE.
   TYPE(STRING), ALLOCATABLE                       :: TOKENS(:) !< STRING TOKENS.

   IF (ALLOCATED(SELF%RAW)) THEN
      SEP_ = SPACE ; IF (PRESENT(SEP)) SEP_ = SEP
      CALL SELF%SPLIT(TOKENS=TOKENS, SEP=SEP_)
      TOKENS = TOKENS%CAPITALIZE()
      STARTCASE = STARTCASE%JOIN(ARRAY=TOKENS, SEP=SEP_)
   ENDIF
   ENDFUNCTION STARTCASE

   ELEMENTAL FUNCTION STRIP(SELF, REMOVE_NULLS)
   !< RETURN A COPY OF THE STRING WITH THE LEADING AND TRAILING CHARACTERS REMOVED.
   !<
   !< @NOTE MULTIPLE SUBSEQUENT SEPARATORS ARE COLLAPSED TO ONE OCCURENCE.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = '  HELLO WORLD!   '
   !< TEST_PASSED(1) = ASTRING%STRIP()//''=='HELLO WORLD!'
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN)           :: SELF         !< THE STRING.
   LOGICAL,       INTENT(IN), OPTIONAL :: REMOVE_NULLS !< REMOVE NULL CHARACTERS AT THE END.
   TYPE(STRING)                        :: STRIP        !< THE STRIPPED STRING.
   INTEGER                             :: C            !< COUNTER.

   IF (ALLOCATED(SELF%RAW)) THEN
      STRIP = SELF%ADJUSTL()
      STRIP = STRIP%TRIM()
      IF (PRESENT(REMOVE_NULLS)) THEN
         IF (REMOVE_NULLS) THEN
            C = INDEX(SELF%RAW, CHAR(0))
            IF (C>0) STRIP%RAW = STRIP%RAW(1:C-1)
         ENDIF
      ENDIF
   ENDIF
   ENDFUNCTION STRIP

   ELEMENTAL FUNCTION SWAPCASE(SELF)
   !< RETURN A COPY OF THE STRING WITH UPPERCASE CHARACTERS CONVERTED TO LOWERCASE AND VICE VERSA.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = '  HELLO WORLD!   '
   !< TEST_PASSED(1) = ASTRING%SWAPCASE()//''=='  HELLO WORLD!   '
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF     !< THE STRING.
   TYPE(STRING)              :: SWAPCASE !< UPPER CASE STRING.
   INTEGER                   :: N1       !< CHARACTERS COUNTER.
   INTEGER                   :: N2       !< CHARACTERS COUNTER.

   IF (ALLOCATED(SELF%RAW)) THEN
      SWAPCASE = SELF
      DO N1=1, LEN(SELF%RAW)
         N2 = INDEX(UPPER_ALPHABET, SELF%RAW(N1:N1))
         IF (N2>0) THEN
            SWAPCASE%RAW(N1:N1) = LOWER_ALPHABET(N2:N2)
         ELSE
            N2 = INDEX(LOWER_ALPHABET, SELF%RAW(N1:N1))
            IF (N2>0) SWAPCASE%RAW(N1:N1) = UPPER_ALPHABET(N2:N2)
         ENDIF
      ENDDO
   ENDIF
   ENDFUNCTION SWAPCASE

   FUNCTION TEMPNAME(SELF, IS_FILE, PREFIX, PATH)
   !< RETURN A SAFE TEMPORARY NAME SUITABLE FOR TEMPORARY FILE OR DIRECTORIES.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: TMPNAME
   !< LOGICAL                       :: TEST_PASSED(5)
   !< TMPNAME = ASTRING%TEMPNAME()
   !< INQUIRE(FILE=TMPNAME, EXIST=TEST_PASSED(1))
   !< TEST_PASSED(1) = .NOT.TEST_PASSED(1)
   !< TMPNAME = ASTRING%TEMPNAME(IS_FILE=.FALSE.)
   !< INQUIRE(FILE=TMPNAME, EXIST=TEST_PASSED(2))
   !< TEST_PASSED(2) = .NOT.TEST_PASSED(2)
   !< TMPNAME = ASTRING%TEMPNAME(PATH='./')
   !< INQUIRE(FILE=TMPNAME, EXIST=TEST_PASSED(3))
   !< TEST_PASSED(3) = .NOT.TEST_PASSED(3)
   !< ASTRING = 'ME-'
   !< TMPNAME = ASTRING%TEMPNAME()
   !< INQUIRE(FILE=TMPNAME, EXIST=TEST_PASSED(4))
   !< TEST_PASSED(4) = .NOT.TEST_PASSED(4)
   !< TMPNAME = ASTRING%TEMPNAME(PREFIX='YOU-')
   !< INQUIRE(FILE=TMPNAME, EXIST=TEST_PASSED(5))
   !< TEST_PASSED(5) = .NOT.TEST_PASSED(5)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN)           :: SELF                   !< THE STRING.
   LOGICAL,       INTENT(IN), OPTIONAL :: IS_FILE                !< TRUE IF TEMPNAME SHOULD BE USED FOR FILE (THE DEFAULT).
   CHARACTER(*),  INTENT(IN), OPTIONAL :: PREFIX                 !< NAME PREFIX, OTHERWISE SELF IS USED (IF ALLOCATED).
   CHARACTER(*),  INTENT(IN), OPTIONAL :: PATH                   !< PATH WHERE FILE/DIRECTORY SHOULD BE USED, DEFAULT `./`.
   CHARACTER(LEN=:), ALLOCATABLE       :: TEMPNAME               !< SAFE (UNIQUE) TEMPORARY NAME.
   LOGICAL                             :: IS_FILE_               !< TRUE IF TEMPNAME SHOULD BE USED FOR FILE (THE DEFAULT).
   CHARACTER(LEN=:), ALLOCATABLE       :: PREFIX_                !< NAME PREFIX, OTHERWISE SELF IS USED (IF ALLOCATED).
   CHARACTER(LEN=:), ALLOCATABLE       :: PATH_                  !< PATH WHERE FILE/DIRECTORY SHOULD BE USED, DEFAULT `./`.
   LOGICAL, SAVE                       :: IS_INITIALIZED=.FALSE. !< STATUS OF RANDOM SEED INITIALIZATION.
   REAL(R4P)                           :: RANDOM_REAL            !< RANDOM NUMBER (REAL).
   INTEGER(I4P)                        :: RANDOM_INTEGER         !< RANDOM NUMBER (INTEGER).
   LOGICAL                             :: IS_HOLD                !< FLAG TO CHECK IF A SAFE TEMPNAME HAS BEEN FOUND.

   IS_FILE_ = .TRUE. ; IF (PRESENT(IS_FILE)) IS_FILE_ = IS_FILE
   PATH_ = '' ; IF (PRESENT(PATH)) PATH_ = PATH
   PREFIX_ = ''
   IF (PRESENT(PREFIX)) THEN
      PREFIX_ = PREFIX
   ELSEIF (ALLOCATED(SELF%RAW)) THEN
      PREFIX_ = SELF%RAW
   ENDIF
   IF (.NOT.IS_INITIALIZED) THEN
      CALL RANDOM_SEED
      IS_INITIALIZED = .TRUE.
   ENDIF
   TEMPNAME = REPEAT(' ', LEN(PATH_) + LEN(PREFIX_) + 10) ! [PATH_] + [PREFIX_] + 6 RANDOM CHARS + [.TMP]
   DO
      CALL RANDOM_NUMBER(RANDOM_REAL)
      RANDOM_INTEGER = TRANSFER(RANDOM_REAL, RANDOM_INTEGER)
      RANDOM_INTEGER = IAND(RANDOM_INTEGER, 16777215_I4P)
      IF (IS_FILE_)  THEN
         WRITE(TEMPNAME, '(A,Z6.6,A)') PATH_//PREFIX_, RANDOM_INTEGER, '.TMP'
      ELSE
         WRITE(TEMPNAME, '(A,Z6.6)') PATH_//PREFIX_, RANDOM_INTEGER
         TEMPNAME = TRIM(TEMPNAME)
      ENDIF
      INQUIRE(FILE=TEMPNAME, EXIST=IS_HOLD)
      IF (.NOT.IS_HOLD) EXIT
   ENDDO
   ENDFUNCTION TEMPNAME

   ELEMENTAL FUNCTION TO_INTEGER_I1P(SELF, KIND) RESULT(TO_NUMBER)
   !< CAST STRING TO INTEGER (I1P).
   !<
   !<```FORTRAN
   !< USE PENF
   !< TYPE(STRING) :: ASTRING
   !< INTEGER(I1P) :: INTEGER_
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = '127'
   !< INTEGER_ = ASTRING%TO_NUMBER(KIND=1_I1P)
   !< TEST_PASSED(1) = INTEGER_==127_I1P
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF      !< THE STRING.
   INTEGER(I1P),  INTENT(IN) :: KIND      !< MOLD PARAMETER FOR KIND DETECTION.
   INTEGER(I1P)              :: TO_NUMBER !< THE NUMBER INTO THE STRING.

   IF (ALLOCATED(SELF%RAW)) THEN
     IF (SELF%IS_INTEGER()) READ(SELF%RAW, *) TO_NUMBER
   ENDIF
   IF (KIND.EQ.-1) THEN
   ENDIF
   ENDFUNCTION TO_INTEGER_I1P

#ifndef _NVF
   ELEMENTAL FUNCTION TO_INTEGER_I2P(SELF, KIND) RESULT(TO_NUMBER)
   !< CAST STRING TO INTEGER (I2P).
   !<
   !<```FORTRAN
   !< USE PENF
   !< TYPE(STRING) :: ASTRING
   !< INTEGER(I2P) :: INTEGER_
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = '127'
   !< INTEGER_ = ASTRING%TO_NUMBER(KIND=1_I2P)
   !< TEST_PASSED(1) = INTEGER_==127_I2P
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF      !< THE STRING.
   INTEGER(I2P),  INTENT(IN) :: KIND      !< MOLD PARAMETER FOR KIND DETECTION.
   INTEGER(I2P)              :: TO_NUMBER !< THE NUMBER INTO THE STRING.

   IF (ALLOCATED(SELF%RAW)) THEN
     IF (SELF%IS_INTEGER()) READ(SELF%RAW, *) TO_NUMBER
   ENDIF
   IF (KIND.EQ.-1) THEN
   ENDIF
   ENDFUNCTION TO_INTEGER_I2P
#endif

   ELEMENTAL FUNCTION TO_INTEGER_I4P(SELF, KIND) RESULT(TO_NUMBER)
   !< CAST STRING TO INTEGER (I4P).
   !<
   !<```FORTRAN
   !< USE PENF
   !< TYPE(STRING) :: ASTRING
   !< INTEGER(I4P) :: INTEGER_
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = '127'
   !< INTEGER_ = ASTRING%TO_NUMBER(KIND=1_I4P)
   !< TEST_PASSED(1) = INTEGER_==127_I4P
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF      !< THE STRING.
   INTEGER(I4P),  INTENT(IN) :: KIND      !< MOLD PARAMETER FOR KIND DETECTION.
   INTEGER(I4P)              :: TO_NUMBER !< THE NUMBER INTO THE STRING.

   IF (ALLOCATED(SELF%RAW)) THEN
     IF (SELF%IS_INTEGER()) READ(SELF%RAW, *) TO_NUMBER
   ENDIF
   IF (KIND.EQ.-1) THEN
   ENDIF
   ENDFUNCTION TO_INTEGER_I4P

   ELEMENTAL FUNCTION TO_INTEGER_I8P(SELF, KIND) RESULT(TO_NUMBER)
   !< CAST STRING TO INTEGER (I8P).
   !<
   !<```FORTRAN
   !< USE PENF
   !< TYPE(STRING) :: ASTRING
   !< INTEGER(I8P) :: INTEGER_
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = '127'
   !< INTEGER_ = ASTRING%TO_NUMBER(KIND=1_I8P)
   !< TEST_PASSED(1) = INTEGER_==127_I8P
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF      !< THE STRING.
   INTEGER(I8P),  INTENT(IN) :: KIND      !< MOLD PARAMETER FOR KIND DETECTION.
   INTEGER(I8P)              :: TO_NUMBER !< THE NUMBER INTO THE STRING.

   IF (ALLOCATED(SELF%RAW)) THEN
     IF (SELF%IS_INTEGER()) READ(SELF%RAW, *) TO_NUMBER
   ENDIF
   IF (KIND.EQ.-1) THEN
   ENDIF
   ENDFUNCTION TO_INTEGER_I8P

   ELEMENTAL FUNCTION TO_REAL_R4P(SELF, KIND) RESULT(TO_NUMBER)
   !< CAST STRING TO REAL (R4P).
   !<
   !<```FORTRAN
   !< USE PENF
   !< TYPE(STRING) :: ASTRING
   !< REAL(R4P)    :: REAL_
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = '3.4E9'
   !< REAL_ = ASTRING%TO_NUMBER(KIND=1._R4P)
   !< TEST_PASSED(1) = REAL_==3.4E9_R4P
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF      !< THE STRING.
   REAL(R4P),     INTENT(IN) :: KIND      !< MOLD PARAMETER FOR KIND DETECTION.
   REAL(R4P)                 :: TO_NUMBER !< THE NUMBER INTO THE STRING.

   IF (ALLOCATED(SELF%RAW)) THEN
     IF (SELF%IS_REAL()) READ(SELF%RAW, *) TO_NUMBER
   ENDIF
   IF (KIND.EQ.-1) THEN
   ENDIF
   ENDFUNCTION TO_REAL_R4P

   ELEMENTAL FUNCTION TO_REAL_R8P(SELF, KIND) RESULT(TO_NUMBER)
   !< CAST STRING TO REAL (R8P).
   !<
   !<```FORTRAN
   !< USE PENF
   !< TYPE(STRING) :: ASTRING
   !< REAL(R8P)    :: REAL_
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = '3.4E9'
   !< REAL_ = ASTRING%TO_NUMBER(KIND=1._R8P)
   !< TEST_PASSED(1) = REAL_==3.4E9_R8P
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF      !< THE STRING.
   REAL(R8P),     INTENT(IN) :: KIND      !< MOLD PARAMETER FOR KIND DETECTION.
   REAL(R8P)                 :: TO_NUMBER !< THE NUMBER INTO THE STRING.

   IF (ALLOCATED(SELF%RAW)) THEN
     IF (SELF%IS_REAL()) READ(SELF%RAW, *) TO_NUMBER
   ENDIF
   IF (KIND.EQ.-1) THEN
   ENDIF
   ENDFUNCTION TO_REAL_R8P

   ELEMENTAL FUNCTION TO_REAL_R16P(SELF, KIND) RESULT(TO_NUMBER)
   !< CAST STRING TO REAL (R16P).
   !<
   !<```FORTRAN
   !< USE PENF
   !< TYPE(STRING) :: ASTRING
   !< REAL(R16P)   :: REAL_
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = '3.4E9'
   !< REAL_ = ASTRING%TO_NUMBER(KIND=1._R16P)
   !< TEST_PASSED(1) = REAL_==3.4E9_R16P
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF      !< THE STRING.
   REAL(R16P),    INTENT(IN) :: KIND      !< MOLD PARAMETER FOR KIND DETECTION.
   REAL(R16P)                :: TO_NUMBER !< THE NUMBER INTO THE STRING.

   IF (ALLOCATED(SELF%RAW)) THEN
     IF (SELF%IS_REAL()) READ(SELF%RAW, *) TO_NUMBER
   ENDIF
   IF (KIND.EQ.-1) THEN
   ENDIF
   ENDFUNCTION TO_REAL_R16P

   ELEMENTAL FUNCTION UNESCAPE(SELF, TO_UNESCAPE, UNESC) RESULT(UNESCAPED)
   !< UNESCAPE DOUBLE BACKSLASHES (OR CUSTOM ESCAPED CHARACTER).
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(2)
   !< ASTRING = '^\\S \\D+\\S*'
   !< TEST_PASSED(1) = (ASTRING%UNESCAPE(TO_UNESCAPE='\')//''=='^\S \D+\S*')
   !< TEST_PASSED(2) = (ASTRING%UNESCAPE(TO_UNESCAPE='S')//''=='^\S \\D+\S*')
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF        !< THE STRING.
   CHARACTER(KIND=CK, LEN=1), INTENT(IN)           :: TO_UNESCAPE !< CHARACTER TO BE UNESCAPED.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN), OPTIONAL :: UNESC       !< CHARACTER USED TO UNESCAPE.
   TYPE(STRING)                                    :: UNESCAPED   !< ESCAPED STRING.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE          :: UNESC_      !< CHARACTER TO UNESCAPE, LOCAL VARIABLE.
   INTEGER                                         :: C           !< CHARACTER COUNTER.

   IF (ALLOCATED(SELF%RAW)) THEN
      UNESC_ = '' ; IF (PRESENT(UNESC)) UNESC_ = UNESC
      UNESCAPED%RAW = ''
      C = 1
      DO
         IF (C>LEN(SELF%RAW)) EXIT
         IF (C==LEN(SELF%RAW)) THEN
            UNESCAPED%RAW = UNESCAPED%RAW//SELF%RAW(C:C)
            EXIT
         ELSE
            IF (SELF%RAW(C:C+1)==BACKSLASH//TO_UNESCAPE) THEN
               UNESCAPED%RAW = UNESCAPED%RAW//TO_UNESCAPE
               C = C + 2
            ELSE
               UNESCAPED%RAW = UNESCAPED%RAW//SELF%RAW(C:C)
               C = C + 1
            ENDIF
         ENDIF
      ENDDO
   ENDIF
   ENDFUNCTION UNESCAPE

   ELEMENTAL FUNCTION UNIQUE(SELF, SUBSTRING) RESULT(UNIQ)
   !< REDUCE TO ONE (UNIQUE) MULTIPLE (SEQUENTIAL) OCCURRENCES OF A SUBSTRING INTO A STRING.
   !<
   !< FOR EXAMPLE THE STRING ' AB-CRE-CRE-AB' IS REDUCE TO 'AB-CRE-AB' IF THE SUBSTRING IS '-CRE'.
   !< @NOTE EVENTUAL MULTIPLE TRAILING WHITE SPACE ARE NOT REDUCED TO ONE OCCURRENCE.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = '+++AB-++CRE-++CRE-AB+++++'
   !< TEST_PASSED(1) = ASTRING%UNIQUE(SUBSTRING='+')//''=='+AB-+CRE-+CRE-AB+'
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF       !< THE STRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN), OPTIONAL :: SUBSTRING  !< SUBSTRING WHICH MULTIPLE OCCURENCES MUST BE REDUCED TO ONE.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE          :: SUBSTRING_ !< SUBSTRING, DEFAULT VALUE.
   TYPE(STRING)                                    :: UNIQ       !< STRING PARSED.
#ifdef _NVF
   CHARACTER(9999)                                 :: NVF_BUG  !< WORK AROUND FOR NVFORTRAN BUG.
#endif

   IF (ALLOCATED(SELF%RAW)) THEN
     SUBSTRING_ = SPACE ; IF (PRESENT(SUBSTRING)) SUBSTRING_ = SUBSTRING

     UNIQ = SELF
     DO
#ifdef _NVF
       NVF_BUG = SUBSTRING_
       IF (.NOT.UNIQ%INDEX(REPEAT(TRIM(NVF_BUG), 2))>0) EXIT
       UNIQ = UNIQ%REPLACE(OLD=REPEAT(TRIM(NVF_BUG), 2), NEW=SUBSTRING_)
#else
       IF (.NOT.UNIQ%INDEX(REPEAT(SUBSTRING_, 2))>0) EXIT
       UNIQ = UNIQ%REPLACE(OLD=REPEAT(SUBSTRING_, 2), NEW=SUBSTRING_)
#endif
     ENDDO
   ENDIF
   ENDFUNCTION UNIQUE

   ELEMENTAL FUNCTION UPPER(SELF)
   !< RETURN A STRING WITH ALL UPPERCASE CHARACTERS.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = 'HELLO WORLD!'
   !< TEST_PASSED(1) = ASTRING%UPPER()//''=='HELLO WORLD!'
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF  !< THE STRING.
   TYPE(STRING)              :: UPPER !< UPPER CASE STRING.
   INTEGER                   :: N1    !< CHARACTERS COUNTER.
   INTEGER                   :: N2    !< CHARACTERS COUNTER.

   IF (ALLOCATED(SELF%RAW)) THEN
      UPPER = SELF
      DO N1=1, LEN(SELF%RAW)
         N2 = INDEX(LOWER_ALPHABET, SELF%RAW(N1:N1))
         IF (N2>0) UPPER%RAW(N1:N1) = UPPER_ALPHABET(N2:N2)
      ENDDO
   ENDIF
   ENDFUNCTION UPPER

   SUBROUTINE WRITE_FILE(SELF, FILE, FORM, IOSTAT, IOMSG)
   !< WRITE A SINGLE STRING STREAM INTO FILE.
   !<
   !< @NOTE FOR UNFORMATTED READ ONLY `ACCESS='STREAM'` IS SUPPORTED WITH NEW_LINE AS LINE TERMINATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING)              :: ASTRING
   !< TYPE(STRING)              :: ANOTHERSTRING
   !< TYPE(STRING), ALLOCATABLE :: STRINGS(:)
   !< TYPE(STRING)              :: LINE(3)
   !< INTEGER                   :: IOSTAT
   !< CHARACTER(LEN=99)         :: IOMSG
   !< INTEGER                   :: SCRATCH
   !< INTEGER                   :: L
   !< LOGICAL                   :: TEST_PASSED(8)
   !< LINE(1) = ' HELLO WORLD!   '
   !< LINE(2) = 'HOW ARE YOU?  '
   !< LINE(3) = '   ALL SAY: "FINE THANKS"'
   !< ANOTHERSTRING = ANOTHERSTRING%JOIN(ARRAY=LINE, SEP=NEW_LINE('A'))
   !< CALL ANOTHERSTRING%WRITE_FILE(FILE='WRITE_FILE_TEST.TMP', IOSTAT=IOSTAT, IOMSG=IOMSG)
   !< CALL ASTRING%READ_FILE(FILE='WRITE_FILE_TEST.TMP', IOSTAT=IOSTAT, IOMSG=IOMSG)
   !< CALL ASTRING%SPLIT(TOKENS=STRINGS, SEP=NEW_LINE('A'))
   !< TEST_PASSED(1) = (SIZE(STRINGS, DIM=1)==SIZE(LINE, DIM=1))
   !< DO L=1, SIZE(STRINGS, DIM=1)
   !<   TEST_PASSED(L+1) = (STRINGS(L)==LINE(L))
   !< ENDDO
   !< CALL ANOTHERSTRING%WRITE_FILE(FILE='WRITE_FILE_TEST.TMP', FORM='UNFORMATTED', IOSTAT=IOSTAT, IOMSG=IOMSG)
   !< CALL ASTRING%READ_FILE(FILE='WRITE_FILE_TEST.TMP', FORM='UNFORMATTED', IOSTAT=IOSTAT, IOMSG=IOMSG)
   !< CALL ASTRING%SPLIT(TOKENS=STRINGS, SEP=NEW_LINE('A'))
   !< TEST_PASSED(5) = (SIZE(STRINGS, DIM=1)==SIZE(LINE, DIM=1))
   !< DO L=1, SIZE(STRINGS, DIM=1)
   !<   TEST_PASSED(L+5) = (STRINGS(L)==LINE(L))
   !< ENDDO
   !< OPEN(NEWUNIT=SCRATCH, FILE='WRITE_FILE_TEST.TMP')
   !< CLOSE(UNIT=SCRATCH, STATUS='DELETE')
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),    INTENT(IN)              :: SELF    !< THE STRING.
   CHARACTER(LEN=*), INTENT(IN)              :: FILE    !< FILE NAME.
   CHARACTER(LEN=*), INTENT(IN),    OPTIONAL :: FORM    !< FORMAT OF UNIT.
   INTEGER,          INTENT(OUT),   OPTIONAL :: IOSTAT  !< IO STATUS CODE.
   CHARACTER(LEN=*), INTENT(INOUT), OPTIONAL :: IOMSG   !< IO STATUS MESSAGE.
   TYPE(STRING)                              :: FORM_   !< FORMAT OF UNIT, LOCAL VARIABLE.
   INTEGER                                   :: IOSTAT_ !< IO STATUS CODE, LOCAL VARIABLE.
   CHARACTER(LEN=:), ALLOCATABLE             :: IOMSG_  !< IO STATUS MESSAGE, LOCAL VARIABLE.
   INTEGER                                   :: UNIT    !< LOGICAL UNIT.

   IOMSG_ = REPEAT(' ', 99) ; IF (PRESENT(IOMSG)) IOMSG_ = IOMSG
   FORM_ = 'FORMATTED' ; IF (PRESENT(FORM)) FORM_ = FORM ; FORM_ = FORM_%UPPER()
   SELECT CASE(FORM_%CHARS())
   CASE('FORMATTED')
      OPEN(NEWUNIT=UNIT, FILE=FILE, ACTION='WRITE', IOMSG=IOMSG_, IOSTAT=IOSTAT_, ERR=10)
   CASE('UNFORMATTED')
      OPEN(NEWUNIT=UNIT, FILE=FILE, ACTION='WRITE', FORM='UNFORMATTED', ACCESS='STREAM', IOMSG=IOMSG_, IOSTAT=IOSTAT_, ERR=10)
   ENDSELECT
   CALL SELF%WRITE_LINES(UNIT=UNIT, FORM=FORM, IOMSG=IOMSG_, IOSTAT=IOSTAT_)
   10 CLOSE(UNIT)
   IF (PRESENT(IOSTAT)) IOSTAT = IOSTAT_
   IF (PRESENT(IOMSG)) IOMSG = IOMSG_
   ENDSUBROUTINE WRITE_FILE

   SUBROUTINE WRITE_LINE(SELF, UNIT, FORM, IOSTAT, IOMSG)
   !< WRITE LINE (RECORD) TO A CONNECTED UNIT.
   !<
   !< @NOTE IF THE CONNECTED UNIT IS UNFORMATTED A `NEW_LINE()` CHARACTER IS ADDED AT THE END (IF NECESSARY) TO MARK THE END OF
   !< LINE.
   !<
   !< @NOTE THERE IS NO DOCTESTS, THIS BEING TESTED BY MEANS OF [[STRING:WRITE_FILE]] DOCTESTS.
   CLASS(STRING),    INTENT(IN)              :: SELF    !< THE STRING.
   INTEGER,          INTENT(IN)              :: UNIT    !< LOGICAL UNIT.
   CHARACTER(LEN=*), INTENT(IN),    OPTIONAL :: FORM    !< FORMAT OF UNIT.
   INTEGER,          INTENT(OUT),   OPTIONAL :: IOSTAT  !< IO STATUS CODE.
   CHARACTER(LEN=*), INTENT(INOUT), OPTIONAL :: IOMSG   !< IO STATUS MESSAGE.
   TYPE(STRING)                              :: FORM_   !< FORMAT OF UNIT, LOCAL VARIABLE.
   INTEGER                                   :: IOSTAT_ !< IO STATUS CODE, LOCAL VARIABLE.
   CHARACTER(LEN=:), ALLOCATABLE             :: IOMSG_  !< IO STATUS MESSAGE, LOCAL VARIABLE.

   IOSTAT_ = 0
   IOMSG_ = REPEAT(' ', 99) ; IF (PRESENT(IOMSG)) IOMSG_ = IOMSG
   IF (ALLOCATED(SELF%RAW)) THEN
      FORM_ = 'FORMATTED' ; IF (PRESENT(FORM)) FORM_ = FORM ; FORM_ = FORM_%UPPER()
      SELECT CASE(FORM_%CHARS())
      CASE('FORMATTED')
         WRITE(UNIT, "(A)", IOSTAT=IOSTAT_, IOMSG=IOMSG_) SELF%RAW
      CASE('UNFORMATTED')
         IF (SELF%END_WITH(NEW_LINE('A'))) THEN
            WRITE(UNIT, IOSTAT=IOSTAT_, IOMSG=IOMSG_) SELF%RAW
         ELSE
            WRITE(UNIT, IOSTAT=IOSTAT_, IOMSG=IOMSG_) SELF%RAW//NEW_LINE('A')
         ENDIF
      ENDSELECT
   ENDIF
   IF (PRESENT(IOSTAT)) IOSTAT = IOSTAT_
   IF (PRESENT(IOMSG)) IOMSG = IOMSG_
   ENDSUBROUTINE WRITE_LINE

   SUBROUTINE WRITE_LINES(SELF, UNIT, FORM, IOSTAT, IOMSG)
   !< WRITE LINES (RECORDS) TO A CONNECTED UNIT.
   !<
   !< THIS METHOD CHECKS IF SELF CONTAINS MORE THAN ONE LINE (RECORDS) AND WRITES THEM AS LINES (RECORDS).
   !<
   !< @NOTE IF THE CONNECTED UNIT IS UNFORMATTED A `NEW_LINE()` CHARACTER IS ADDED AT THE END (IF NECESSARY) TO MARK THE END OF
   !< LINE.
   !<
   !< @NOTE THERE IS NO DOCTESTS, THIS BEING TESTED BY MEANS OF [[STRING:WRITE_FILE]] DOCTESTS.
   CLASS(STRING),    INTENT(IN)              :: SELF     !< THE STRING.
   INTEGER,          INTENT(IN)              :: UNIT     !< LOGICAL UNIT.
   CHARACTER(LEN=*), INTENT(IN),    OPTIONAL :: FORM     !< FORMAT OF UNIT.
   INTEGER,          INTENT(OUT),   OPTIONAL :: IOSTAT   !< IO STATUS CODE.
   CHARACTER(LEN=*), INTENT(INOUT), OPTIONAL :: IOMSG    !< IO STATUS MESSAGE.
   TYPE(STRING), ALLOCATABLE                 :: LINES(:) !< LINES.
   INTEGER                                   :: L        !< COUNTER.

   IF (ALLOCATED(SELF%RAW)) THEN
      CALL SELF%SPLIT(TOKENS=LINES, SEP=NEW_LINE('A'))
      DO L=1, SIZE(LINES, DIM=1)
         CALL LINES(L)%WRITE_LINE(UNIT=UNIT, FORM=FORM, IOSTAT=IOSTAT, IOMSG=IOMSG)
      ENDDO
   ENDIF
   ENDSUBROUTINE WRITE_LINES

   ! INQUIRE
   ELEMENTAL FUNCTION END_WITH(SELF, SUFFIX, START, END, IGNORE_NULL_EOF)
   !< RETURN TRUE IF A STRING ENDS WITH A SPECIFIED SUFFIX.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(5)
   !< ASTRING = 'HELLO WORLD!'
   !< TEST_PASSED(1) = ASTRING%END_WITH(SUFFIX='LD!').EQV..TRUE.
   !< TEST_PASSED(2) = ASTRING%END_WITH(SUFFIX='LD!').EQV..FALSE.
   !< TEST_PASSED(3) = ASTRING%END_WITH(SUFFIX='ORLD!', START=5).EQV..TRUE.
   !< TEST_PASSED(4) = ASTRING%END_WITH(SUFFIX='ORLD!', START=8, END=12).EQV..TRUE.
   !< TEST_PASSED(5) = ASTRING%END_WITH(SUFFIX='!').EQV..TRUE.
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF             !< THE STRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)           :: SUFFIX           !< SEARCHED SUFFIX.
   INTEGER,                   INTENT(IN), OPTIONAL :: START            !< START POSITION INTO THE STRING.
   INTEGER,                   INTENT(IN), OPTIONAL :: END              !< END POSITION INTO THE STRING.
   LOGICAL,                   INTENT(IN), OPTIONAL :: IGNORE_NULL_EOF  !< IGNORE NULL CHARACTER AT THE END OF FILE.
   LOGICAL                                         :: END_WITH         !< RESULT OF THE TEST.
   INTEGER                                         :: START_           !< START POSITION INTO THE STRING, LOCAL VARIABLE.
   INTEGER                                         :: END_             !< END POSITION INTO THE STRING, LOCAL VARIABLE.
   LOGICAL                                         :: IGNORE_NULL_EOF_ !< IGNORE NULL CHARACTER AT THE END OF FILE, LOCAL VARIABLE.

   END_WITH = .FALSE.
   IF (ALLOCATED(SELF%RAW)) THEN
      START_           = 1             ; IF (PRESENT(START))           START_           = START
      END_             = LEN(SELF%RAW) ; IF (PRESENT(END))             END_             = END
      IGNORE_NULL_EOF_ = .FALSE.       ; IF (PRESENT(IGNORE_NULL_EOF)) IGNORE_NULL_EOF_ = IGNORE_NULL_EOF
      IF (IGNORE_NULL_EOF_.AND.(SELF%RAW(END_:END_) == CHAR(0))) END_ = END_ - 1
      IF (LEN(SUFFIX) <= LEN(SELF%RAW(START_:END_))) THEN
         END_WITH = SELF%RAW(END_-LEN(SUFFIX)+1:END_) == SUFFIX
      ENDIF
   ENDIF
   ENDFUNCTION END_WITH

   ELEMENTAL FUNCTION IS_ALLOCATED(SELF)
   !< RETURN TRUE IF THE STRING IS ALLOCATED.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(2)
   !< TEST_PASSED(1) = ASTRING%IS_ALLOCATED().EQV..FALSE.
   !< ASTRING = 'HELLO'
   !< TEST_PASSED(2) = ASTRING%IS_ALLOCATED().EQV..TRUE.
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF     !< THE STRING.
   LOGICAL                   :: IS_ALLOCATED !< RESULT OF THE TEST.

   IS_ALLOCATED = ALLOCATED(SELF%RAW)
   ENDFUNCTION IS_ALLOCATED

   ELEMENTAL FUNCTION IS_DIGIT(SELF)
   !< RETURN TRUE IF ALL CHARACTERS IN THE STRING ARE DIGITS.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(2)
   !< ASTRING = '   -1212112.3 '
   !< TEST_PASSED(1) = ASTRING%IS_DIGIT().EQV..FALSE.
   !< ASTRING = '12121123'
   !< TEST_PASSED(2) = ASTRING%IS_DIGIT().EQV..TRUE.
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF     !< THE STRING.
   LOGICAL                   :: IS_DIGIT !< RESULT OF THE TEST.
   INTEGER                   :: C        !< CHARACTER COUNTER.

   IS_DIGIT = .FALSE.
   IF (ALLOCATED(SELF%RAW)) THEN
      DO C=1, LEN(SELF%RAW)
         SELECT CASE (SELF%RAW(C:C))
         CASE ('0':'9')
            IS_DIGIT = .TRUE.
         CASE DEFAULT
            IS_DIGIT = .FALSE.
            EXIT
         END SELECT
      ENDDO
   ENDIF
   ENDFUNCTION IS_DIGIT

   ELEMENTAL FUNCTION IS_INTEGER(SELF, ALLOW_SPACES)
   !< RETURN TRUE IF THE STRING CONTAINS AN INTEGER.
   !<
   !< THE REGULAR EXPRESSION IS `\S*[\+\-]?\D+([EE]\+?\D+)?\S*`. THE PARSE ALGORITHM IS DONE IN STAGES:
   !<
   !< | S0  | S1      | S2  | S3   | S4  | S5  | S6  |
   !< |-----|---------|-----|------|-----|-----|-----|
   !< |`\S*`|`[\+\-]?`|`\D+`|`[EE]`|`\+?`|`\D+`|`\S*`|
   !<
   !< EXIT ON STAGES-PARSING RESULTS IN:
   !<
   !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 |
   !< |----|----|----|----|----|----|----|
   !< |  F |  F |  T |  F |  F |  T |  T |
   !<
   !< @NOTE THIS IMPLEMENTATION IS COURTESY OF
   !< [TOMEDUNN](HTTPS://GITHUB.COM/TOMEDUNN/FORTRAN-STRING-UTILITY-MODULE/BLOB/MASTER/SRC/STRING_UTILITY_MODULE.F90#L294)
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(6)
   !< ASTRING = '   -1212112 '
   !< TEST_PASSED(1) = ASTRING%IS_INTEGER().EQV..TRUE.
   !< ASTRING = '   -1212112'
   !< TEST_PASSED(2) = ASTRING%IS_INTEGER(ALLOW_SPACES=.FALSE.).EQV..FALSE.
   !< ASTRING = '-1212112   '
   !< TEST_PASSED(3) = ASTRING%IS_INTEGER(ALLOW_SPACES=.FALSE.).EQV..FALSE.
   !< ASTRING = '+2E20'
   !< TEST_PASSED(4) = ASTRING%IS_INTEGER().EQV..TRUE.
   !< ASTRING = ' -2E13 '
   !< TEST_PASSED(5) = ASTRING%IS_INTEGER().EQV..TRUE.
   !< ASTRING = ' -2 E13 '
   !< TEST_PASSED(6) = ASTRING%IS_INTEGER().EQV..FALSE.
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN)           :: SELF          !< THE STRING.
   LOGICAL,       INTENT(IN), OPTIONAL :: ALLOW_SPACES  !< ALLOW LEADING-TRAILING SPACES.
   LOGICAL                             :: IS_INTEGER    !< RESULT OF THE TEST.
   LOGICAL                             :: ALLOW_SPACES_ !< ALLOW LEADING-TRAILING SPACES, LOCAL VARIABLE.
   INTEGER                             :: STAGE         !< STAGES COUNTER.
   INTEGER                             :: C             !< CHARACTER COUNTER.

   IF (ALLOCATED(SELF%RAW)) THEN
      ALLOW_SPACES_ = .TRUE. ; IF (PRESENT(ALLOW_SPACES)) ALLOW_SPACES_ = ALLOW_SPACES
      STAGE = 0
      IS_INTEGER = .TRUE.
      DO C=1, LEN(SELF%RAW)
         SELECT CASE(SELF%RAW(C:C))
         CASE(SPACE, TAB)
            SELECT CASE(STAGE)
            CASE(0, 6)
               IS_INTEGER = ALLOW_SPACES_
            CASE(2, 5)
               IS_INTEGER = ALLOW_SPACES_
               STAGE = 6
            CASE DEFAULT
               IS_INTEGER = .FALSE.
            ENDSELECT
         CASE('-')
            SELECT CASE(STAGE)
            CASE(0)
               STAGE = 1
            CASE DEFAULT
               IS_INTEGER = .FALSE.
            END SELECT
         CASE('+')
            SELECT CASE(STAGE)
            CASE(0)
               STAGE = 1
            CASE(3)
               STAGE = 4
            CASE DEFAULT
               IS_INTEGER = .FALSE.
            ENDSELECT
         CASE('0':'9')
            SELECT CASE(STAGE)
            CASE(0:1)
               STAGE = 2
            CASE(3:4)
               STAGE = 5
            CASE DEFAULT
               CONTINUE
            ENDSELECT
         CASE ('e','E')
            SELECT CASE(STAGE)
            CASE(2)
               STAGE = 3
            CASE DEFAULT
               IS_INTEGER = .FALSE.
            ENDSELECT
         CASE DEFAULT
            IS_INTEGER = .FALSE.
         ENDSELECT
         IF (.NOT.IS_INTEGER) EXIT
      ENDDO
   ENDIF
   IF (IS_INTEGER) THEN
      SELECT CASE(STAGE)
      CASE(2, 5, 6)
         IS_INTEGER = .TRUE.
      CASE DEFAULT
         IS_INTEGER = .FALSE.
      END SELECT
   ENDIF
   ENDFUNCTION IS_INTEGER

   ELEMENTAL FUNCTION IS_LOWER(SELF)
   !< RETURN TRUE IF ALL CHARACTERS IN THE STRING ARE LOWERCASE.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(3)
   !< ASTRING = ' HELLO WORLD'
   !< TEST_PASSED(1) = ASTRING%IS_LOWER().EQV..FALSE.
   !< ASTRING = ' HELLO WORLD'
   !< TEST_PASSED(2) = ASTRING%IS_LOWER().EQV..FALSE.
   !< ASTRING = ' HELLO WORLD'
   !< TEST_PASSED(3) = ASTRING%IS_LOWER().EQV..TRUE.
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF     !< THE STRING.
   LOGICAL                   :: IS_LOWER !< RESULT OF THE TEST.
   INTEGER                   :: C        !< CHARACTER COUNTER.

   IS_LOWER = .FALSE.
   IF (ALLOCATED(SELF%RAW)) THEN
      IS_LOWER = .TRUE.
      DO C=1, LEN(SELF%RAW)
         IF (INDEX(UPPER_ALPHABET, SELF%RAW(C:C))>0) THEN
            IS_LOWER = .FALSE.
            EXIT
         ENDIF
      ENDDO
   ENDIF
   ENDFUNCTION IS_LOWER

   ELEMENTAL FUNCTION IS_NUMBER(SELF, ALLOW_SPACES)
   !< RETURN TRUE IF THE STRING CONTAINS A NUMBER (REAL OR INTEGER).
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(7)
   !< ASTRING = '   -1212112 '
   !< TEST_PASSED(1) = ASTRING%IS_NUMBER().EQV..TRUE.
   !< ASTRING = '   -121.2112 '
   !< TEST_PASSED(2) = ASTRING%IS_NUMBER().EQV..TRUE.
   !< ASTRING = '   -1212112'
   !< TEST_PASSED(3) = ASTRING%IS_NUMBER(ALLOW_SPACES=.FALSE.).EQV..FALSE.
   !< ASTRING = '-12121.12   '
   !< TEST_PASSED(4) = ASTRING%IS_NUMBER(ALLOW_SPACES=.FALSE.).EQV..FALSE.
   !< ASTRING = '+2E20'
   !< TEST_PASSED(5) = ASTRING%IS_NUMBER().EQV..TRUE.
   !< ASTRING = ' -2.4E13 '
   !< TEST_PASSED(6) = ASTRING%IS_NUMBER().EQV..TRUE.
   !< ASTRING = ' -2 E13 '
   !< TEST_PASSED(7) = ASTRING%IS_NUMBER().EQV..FALSE.
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN)           :: SELF         !< THE STRING.
   LOGICAL,       INTENT(IN), OPTIONAL :: ALLOW_SPACES !< ALLOW LEADING-TRAILING SPACES.
   LOGICAL                             :: IS_NUMBER    !< RESULT OF THE TEST.

   IS_NUMBER = (SELF%IS_INTEGER(ALLOW_SPACES=ALLOW_SPACES).OR.SELF%IS_REAL(ALLOW_SPACES=ALLOW_SPACES))
   ENDFUNCTION IS_NUMBER

   ELEMENTAL FUNCTION IS_REAL(SELF, ALLOW_SPACES)
   !< RETURN TRUE IF THE STRING CONTAINS A REAL.
   !<
   !< THE REGULAR EXPRESSION IS `\S*[\+\-]?\D*(|\.?\D*([DEDE][\+\-]?\D+)?)\S*`. THE PARSE ALGORITHM IS DONE IN STAGES:
   !<
   !< | S0  | S1      | S2  | S3  | S4  | S5     | S6      | S7  | S8  |
   !< |-----|---------|-----|-----|-----|--------|---------|-----|-----|
   !< |`\S*`|`[\+\-]?`|`\D*`|`\.?`|`\D*`|`[DEDE]`|`[\+\-]?`|`\D*`|`\S*`|
   !<
   !< EXIT ON STAGES-PARSING RESULTS IN:
   !<
   !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7 | S8 |
   !< |----|----|----|----|----|----|----|----|----|
   !  |  F |  F |  T |  T |  T |  F |  F |  T |  T |
   !<
   !< @NOTE THIS IMPLEMENTATION IS COURTESY OF
   !< [TOMEDUNN](HTTPS://GITHUB.COM/TOMEDUNN/FORTRAN-STRING-UTILITY-MODULE/BLOB/MASTER/SRC/STRING_UTILITY_MODULE.F90#L614)
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(6)
   !< ASTRING = '   -1212112.D0 '
   !< TEST_PASSED(1) = ASTRING%IS_REAL().EQV..TRUE.
   !< ASTRING = '   -1212112.D0'
   !< TEST_PASSED(2) = ASTRING%IS_REAL(ALLOW_SPACES=.FALSE.).EQV..FALSE.
   !< ASTRING = '-1212112.D0   '
   !< TEST_PASSED(3) = ASTRING%IS_REAL(ALLOW_SPACES=.FALSE.).EQV..FALSE.
   !< ASTRING = '+2.E20'
   !< TEST_PASSED(4) = ASTRING%IS_REAL().EQV..TRUE.
   !< ASTRING = ' -2.01E13 '
   !< TEST_PASSED(5) = ASTRING%IS_REAL().EQV..TRUE.
   !< ASTRING = ' -2.01 E13 '
   !< TEST_PASSED(6) = ASTRING%IS_REAL().EQV..FALSE.
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN)           :: SELF              !< THE STRING.
   LOGICAL,       INTENT(IN), OPTIONAL :: ALLOW_SPACES      !< ALLOW LEADING-TRAILING SPACES.
   LOGICAL                             :: IS_REAL           !< RESULT OF THE TEST.
   LOGICAL                             :: ALLOW_SPACES_     !< ALLOW LEADING-TRAILING SPACES, LOCAL VARIABLE.
   LOGICAL                             :: HAS_LEADING_DIGIT !< CHECK THE PRESENCE OF LEADING DIGITS.
   INTEGER                             :: STAGE             !< STAGES COUNTER.
   INTEGER                             :: C                 !< CHARACTER COUNTER.

   IF (ALLOCATED(SELF%RAW)) THEN
      ALLOW_SPACES_ = .TRUE. ; IF (PRESENT(ALLOW_SPACES)) ALLOW_SPACES_ = ALLOW_SPACES
      STAGE = 0
      IS_REAL = .TRUE.
      HAS_LEADING_DIGIT = .FALSE.
      DO C=1, LEN(SELF%RAW)
         SELECT CASE(SELF%RAW(C:C))
         CASE(SPACE, TAB)
            SELECT CASE(STAGE)
            CASE(0, 8)
               IS_REAL = ALLOW_SPACES_
               CONTINUE
            CASE(2:4, 7)
               IS_REAL = ALLOW_SPACES_
               STAGE = 8
            CASE DEFAULT
               IS_REAL = .FALSE.
            ENDSELECT
         CASE('+', '-')
            SELECT CASE(STAGE)
            CASE(0)
               STAGE = 1
            CASE(5)
               STAGE = 6
            CASE DEFAULT
               IS_REAL = .FALSE.
            ENDSELECT
         CASE('0':'9')
            SELECT CASE(STAGE)
            CASE(0:1)
               STAGE = 2
               HAS_LEADING_DIGIT = .TRUE.
            CASE(3)
               STAGE = 4
            CASE(5:6)
               STAGE = 7
            CASE DEFAULT
               CONTINUE
            ENDSELECT
         CASE('.')
            SELECT CASE(STAGE)
            CASE(0:2)
               STAGE = 3
            CASE DEFAULT
               IS_REAL = .FALSE.
            ENDSELECT
         CASE('e','E','d','D')
            SELECT CASE(STAGE)
            CASE(2:4)
               STAGE = 5
            CASE DEFAULT
               IS_REAL = .FALSE.
            ENDSELECT
         CASE DEFAULT
            IS_REAL = .FALSE.
         ENDSELECT
         IF (.NOT.IS_REAL) EXIT
      ENDDO
   ENDIF
   IF (IS_REAL) THEN
      SELECT CASE(STAGE)
      CASE(2, 4, 7, 8)
         IS_REAL = .TRUE.
      CASE(3)
         IS_REAL = HAS_LEADING_DIGIT
      CASE DEFAULT
         IS_REAL = .FALSE.
      ENDSELECT
   ENDIF
   ENDFUNCTION IS_REAL

   ELEMENTAL FUNCTION IS_UPPER(SELF)
   !< RETURN TRUE IF ALL CHARACTERS IN THE STRING ARE UPPERCASE.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(3)
   !< ASTRING = ' HELLO WORLD'
   !< TEST_PASSED(1) = ASTRING%IS_UPPER().EQV..FALSE.
   !< ASTRING = ' HELLO WORLD'
   !< TEST_PASSED(2) = ASTRING%IS_UPPER().EQV..TRUE.
   !< ASTRING = ' HELLO WORLD'
   !< TEST_PASSED(3) = ASTRING%IS_UPPER().EQV..FALSE.
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: SELF     !< THE STRING.
   LOGICAL                   :: IS_UPPER !< RESULT OF THE TEST.
   INTEGER                   :: C        !< CHARACTER COUNTER.

   IS_UPPER = .FALSE.
   IF (ALLOCATED(SELF%RAW)) THEN
      IS_UPPER = .TRUE.
      DO C=1, LEN(SELF%RAW)
         IF (INDEX(LOWER_ALPHABET, SELF%RAW(C:C))>0) THEN
            IS_UPPER = .FALSE.
            EXIT
         ENDIF
      ENDDO
   ENDIF
   ENDFUNCTION IS_UPPER

   ELEMENTAL FUNCTION START_WITH(SELF, PREFIX, START, END)
   !< RETURN TRUE IF A STRING STARTS WITH A SPECIFIED PREFIX.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(4)
   !< ASTRING = 'HELLO WORLD!'
   !< TEST_PASSED(1) = ASTRING%START_WITH(PREFIX='HELLO').EQV..TRUE.
   !< TEST_PASSED(2) = ASTRING%START_WITH(PREFIX='HELL').EQV..FALSE.
   !< TEST_PASSED(3) = ASTRING%START_WITH(PREFIX='LLO WOR', START=3).EQV..TRUE.
   !< TEST_PASSED(4) = ASTRING%START_WITH(PREFIX='LO W', START=4, END=7).EQV..TRUE.
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)           :: SELF       !< THE STRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)           :: PREFIX     !< SEARCHED PREFIX.
   INTEGER,                   INTENT(IN), OPTIONAL :: START      !< START POSITION INTO THE STRING.
   INTEGER,                   INTENT(IN), OPTIONAL :: END        !< END POSITION INTO THE STRING.
   LOGICAL                                         :: START_WITH !< RESULT OF THE TEST.
   INTEGER                                         :: START_     !< START POSITION INTO THE STRING, LOCAL VARIABLE.
   INTEGER                                         :: END_       !< END POSITION INTO THE STRING, LOCAL VARIABLE.

   START_WITH = .FALSE.
   IF (ALLOCATED(SELF%RAW)) THEN
      START_ = 1             ; IF (PRESENT(START)) START_ = START
      END_   = LEN(SELF%RAW) ; IF (PRESENT(END))   END_   = END
      IF (LEN(PREFIX)<=LEN(SELF%RAW(START_:END_))) THEN
         START_WITH = INDEX(SELF%RAW(START_:END_), PREFIX)==1
      ENDIF
   ENDIF
   ENDFUNCTION START_WITH

   ! PRIVATE METHODS

   ! ASSIGNMENTS
   PURE SUBROUTINE STRING_ASSIGN_STRING(LHS, RHS)
   !< ASSIGNMENT OPERATOR FROM STRING INPUT.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< TYPE(STRING) :: ANOTHERSTRING
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = 'HELLO'
   !< ANOTHERSTRING = ASTRING
   !< TEST_PASSED(1) = ASTRING%CHARS()==ANOTHERSTRING%CHARS()
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(INOUT) :: LHS !< LEFT HAND SIDE.
   TYPE(STRING),  INTENT(IN)    :: RHS !< RIGHT HAND SIDE.

   IF (ALLOCATED(RHS%RAW)) LHS%RAW = RHS%RAW
   ENDSUBROUTINE STRING_ASSIGN_STRING

   PURE SUBROUTINE STRING_ASSIGN_CHARACTER(LHS, RHS)
   !< ASSIGNMENT OPERATOR FROM CHARACTER INPUT.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = 'HELLO'
   !< TEST_PASSED(1) = ASTRING%CHARS()=='HELLO'
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(INOUT) :: LHS !< LEFT HAND SIDE.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)    :: RHS !< RIGHT HAND SIDE.

   LHS%RAW = RHS
   ENDSUBROUTINE STRING_ASSIGN_CHARACTER

   PURE SUBROUTINE STRING_ASSIGN_INTEGER_I1P(LHS, RHS)
   !< ASSIGNMENT OPERATOR FROM INTEGER INPUT.
   !<
   !<```FORTRAN
   !< USE PENF
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = 127_I1P
   !< TEST_PASSED(1) = ASTRING%TO_NUMBER(KIND=1_I1P)==127_I1P
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(INOUT) :: LHS !< LEFT HAND SIDE.
   INTEGER(I1P),  INTENT(IN)    :: RHS !< RIGHT HAND SIDE.

   LHS%RAW = TRIM(STR(RHS))
   ENDSUBROUTINE STRING_ASSIGN_INTEGER_I1P

   PURE SUBROUTINE STRING_ASSIGN_INTEGER_I2P(LHS, RHS)
   !< ASSIGNMENT OPERATOR FROM INTEGER INPUT.
   !<
   !<```FORTRAN
   !< USE PENF
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = 127_I2P
   !< TEST_PASSED(1) = ASTRING%TO_NUMBER(KIND=1_I2P)==127_I2P
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(INOUT) :: LHS !< LEFT HAND SIDE.
   INTEGER(I2P),  INTENT(IN)    :: RHS !< RIGHT HAND SIDE.

   LHS%RAW = TRIM(STR(RHS))
   ENDSUBROUTINE STRING_ASSIGN_INTEGER_I2P

   PURE SUBROUTINE STRING_ASSIGN_INTEGER_I4P(LHS, RHS)
   !< ASSIGNMENT OPERATOR FROM INTEGER INPUT.
   !<
   !<```FORTRAN
   !< USE PENF
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = 127_I4P
   !< TEST_PASSED(1) = ASTRING%TO_NUMBER(KIND=1_I4P)==127_I4P
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(INOUT) :: LHS !< LEFT HAND SIDE.
   INTEGER(I4P),  INTENT(IN)    :: RHS !< RIGHT HAND SIDE.

   LHS%RAW = TRIM(STR(RHS))
   ENDSUBROUTINE STRING_ASSIGN_INTEGER_I4P

   PURE SUBROUTINE STRING_ASSIGN_INTEGER_I8P(LHS, RHS)
   !< ASSIGNMENT OPERATOR FROM INTEGER INPUT.
   !<
   !<```FORTRAN
   !< USE PENF
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = 127_I8P
   !< TEST_PASSED(1) = ASTRING%TO_NUMBER(KIND=1_I8P)==127_I8P
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(INOUT) :: LHS !< LEFT HAND SIDE.
   INTEGER(I8P),  INTENT(IN)    :: RHS !< RIGHT HAND SIDE.

   LHS%RAW = TRIM(STR(RHS))
   ENDSUBROUTINE STRING_ASSIGN_INTEGER_I8P

   PURE SUBROUTINE STRING_ASSIGN_REAL_R4P(LHS, RHS)
   !< ASSIGNMENT OPERATOR FROM REAL INPUT.
   !<
   !<```FORTRAN
   !< USE PENF
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = 3.021E6_R4P
   !< TEST_PASSED(1) = ASTRING%TO_NUMBER(KIND=1._R4P)==3.021E6_R4P
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(INOUT) :: LHS !< LEFT HAND SIDE.
   REAL(R4P),     INTENT(IN)    :: RHS !< RIGHT HAND SIDE.

   LHS%RAW = TRIM(STR(RHS))
   ENDSUBROUTINE STRING_ASSIGN_REAL_R4P

   PURE SUBROUTINE STRING_ASSIGN_REAL_R8P(LHS, RHS)
   !< ASSIGNMENT OPERATOR FROM REAL INPUT.
   !<
   !<```FORTRAN
   !< USE PENF
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = 3.021E6_R8P
   !< TEST_PASSED(1) = ASTRING%TO_NUMBER(KIND=1._R8P)==3.021E6_R8P
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(INOUT) :: LHS !< LEFT HAND SIDE.
   REAL(R8P),     INTENT(IN)    :: RHS !< RIGHT HAND SIDE.

   LHS%RAW = TRIM(STR(RHS))
   ENDSUBROUTINE STRING_ASSIGN_REAL_R8P

   PURE SUBROUTINE STRING_ASSIGN_REAL_R16P(LHS, RHS)
   !< ASSIGNMENT OPERATOR FROM REAL INPUT.
   !<
   !<```FORTRAN
   !< USE PENF
   !< TYPE(STRING) :: ASTRING
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = 3.021E6_R8P
   !< TEST_PASSED(1) = ASTRING%TO_NUMBER(KIND=1._R8P)==3.021E6_R8P
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(INOUT) :: LHS !< LEFT HAND SIDE.
   REAL(R16P),    INTENT(IN)    :: RHS !< RIGHT HAND SIDE.

   LHS%RAW = TRIM(STR(RHS))
   ENDSUBROUTINE STRING_ASSIGN_REAL_R16P

   ! CONTATENATION OPERATORS
   PURE FUNCTION STRING_CONCAT_STRING(LHS, RHS) RESULT(CONCAT)
   !< CONCATENATION WITH STRING.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< TYPE(STRING) :: ANOTHERSTRING
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = 'HELLO '
   !< ANOTHERSTRING = 'BYE BYE'
   !< TEST_PASSED(1) = ASTRING//ANOTHERSTRING=='HELLO BYE BYE'
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN)              :: LHS    !< LEFT HAND SIDE.
   TYPE(STRING),  INTENT(IN)              :: RHS    !< RIGHT HAND SIDE.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE :: CONCAT !< CONCATENATED STRING.

   CONCAT = ''
   IF (ALLOCATED(LHS%RAW)) CONCAT = LHS%RAW
   IF (ALLOCATED(RHS%RAW)) CONCAT = CONCAT//RHS%RAW
   ENDFUNCTION STRING_CONCAT_STRING

   PURE FUNCTION STRING_CONCAT_CHARACTER(LHS, RHS) RESULT(CONCAT)
   !< CONCATENATION WITH CHARACTER.
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: ACHARACTER
   !< LOGICAL                       :: TEST_PASSED(1)
   !< ASTRING = 'HELLO '
   !< ACHARACTER = 'WORLD!'
   !< TEST_PASSED(1) = ASTRING//ACHARACTER=='HELLO WORLD!'
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)  :: LHS    !< LEFT HAND SIDE.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)  :: RHS    !< RIGHT HAND SIDE.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE :: CONCAT !< CONCATENATED STRING.

   IF (ALLOCATED(LHS%RAW)) THEN
      CONCAT = LHS%RAW//RHS
   ELSE
      CONCAT = RHS
   ENDIF
   ENDFUNCTION STRING_CONCAT_CHARACTER

   PURE FUNCTION CHARACTER_CONCAT_STRING(LHS, RHS) RESULT(CONCAT)
   !< CONCATENATION WITH CHARACTER (INVERTED).
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: ACHARACTER
   !< LOGICAL                       :: TEST_PASSED(1)
   !< ASTRING = 'HELLO '
   !< ACHARACTER = 'WORLD!'
   !< TEST_PASSED(1) = ACHARACTER//ASTRING=='WORLD!HELLO '
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)  :: LHS    !< LEFT HAND SIDE.
   CLASS(STRING),             INTENT(IN)  :: RHS    !< RIGHT HAND SIDE.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE :: CONCAT !< CONCATENATED STRING.

   IF (ALLOCATED(RHS%RAW)) THEN
      CONCAT = LHS//RHS%RAW
   ELSE
      CONCAT = LHS
   ENDIF
   ENDFUNCTION CHARACTER_CONCAT_STRING

   ELEMENTAL FUNCTION STRING_CONCAT_STRING_STRING(LHS, RHS) RESULT(CONCAT)
   !< CONCATENATION WITH STRING.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< TYPE(STRING) :: ANOTHERSTRING
   !< TYPE(STRING) :: YETANOTHERSTRING
   !< LOGICAL      :: TEST_PASSED(1)
   !< ASTRING = 'HELLO '
   !< ANOTHERSTRING = 'BYE BYE'
   !< YETANOTHERSTRING = ASTRING.CAT.ANOTHERSTRING
   !< TEST_PASSED(1) = YETANOTHERSTRING%CHARS()=='HELLO BYE BYE'
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN)              :: LHS       !< LEFT HAND SIDE.
   TYPE(STRING),  INTENT(IN)              :: RHS       !< RIGHT HAND SIDE.
   TYPE(STRING)                           :: CONCAT    !< CONCATENATED STRING.
   CHARACTER(KIND=CK, LEN=:), ALLOCATABLE :: TEMPORARY !< TEMPORARY CONCATENATED STRING.

   TEMPORARY = ''
   IF (ALLOCATED(LHS%RAW)) TEMPORARY = LHS%RAW
   IF (ALLOCATED(RHS%RAW)) TEMPORARY = TEMPORARY//RHS%RAW
   IF (TEMPORARY/='') CONCAT%RAW = TEMPORARY
   ENDFUNCTION STRING_CONCAT_STRING_STRING

   ELEMENTAL FUNCTION STRING_CONCAT_CHARACTER_STRING(LHS, RHS) RESULT(CONCAT)
   !< CONCATENATION WITH CHARACTER.
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< TYPE(STRING)                  :: YETANOTHERSTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: ACHARACTER
   !< LOGICAL                       :: TEST_PASSED(1)
   !< ASTRING = 'HELLO '
   !< ACHARACTER = 'WORLD!'
   !< YETANOTHERSTRING = ASTRING.CAT.ACHARACTER
   !< TEST_PASSED(1) = YETANOTHERSTRING%CHARS()=='HELLO WORLD!'
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN)  :: LHS    !< LEFT HAND SIDE.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)  :: RHS    !< RIGHT HAND SIDE.
   TYPE(STRING)                           :: CONCAT !< CONCATENATED STRING.

   IF (ALLOCATED(LHS%RAW)) THEN
      CONCAT%RAW = LHS%RAW//RHS
   ELSE
      CONCAT%RAW = RHS
   ENDIF
   ENDFUNCTION STRING_CONCAT_CHARACTER_STRING

   ELEMENTAL FUNCTION CHARACTER_CONCAT_STRING_STRING(LHS, RHS) RESULT(CONCAT)
   !< CONCATENATION WITH CHARACTER (INVERTED).
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< TYPE(STRING)                  :: YETANOTHERSTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: ACHARACTER
   !< LOGICAL                       :: TEST_PASSED(1)
   !< ASTRING = 'HELLO '
   !< ACHARACTER = 'WORLD!'
   !< YETANOTHERSTRING = ACHARACTER.CAT.ASTRING
   !< TEST_PASSED(1) = YETANOTHERSTRING%CHARS()=='WORLD!HELLO '
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)  :: LHS    !< LEFT HAND SIDE.
   CLASS(STRING),             INTENT(IN)  :: RHS    !< RIGHT HAND SIDE.
   TYPE(STRING)                           :: CONCAT !< CONCATENATED STRING.

   IF (ALLOCATED(RHS%RAW)) THEN
     CONCAT%RAW = LHS//RHS%RAW
   ELSE
     CONCAT%RAW = LHS
   ENDIF
   ENDFUNCTION CHARACTER_CONCAT_STRING_STRING

   ! LOGICAL OPERATORS
   ELEMENTAL FUNCTION STRING_EQ_STRING(LHS, RHS) RESULT(IS_IT)
   !< EQUAL TO STRING LOGICAL OPERATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< TYPE(STRING) :: ANOTHERSTRING
   !< LOGICAL      :: TEST_PASSED(2)
   !< ASTRING = '  ONE '
   !< ANOTHERSTRING = 'TWO'
   !< TEST_PASSED(1) = ((ASTRING==ANOTHERSTRING).EQV..FALSE.)
   !< ASTRING = 'THE SAME '
   !< ANOTHERSTRING = 'THE SAME '
   !< TEST_PASSED(2) = ((ASTRING==ANOTHERSTRING).EQV..TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: LHS   !< LEFT HAND SIDE.
   TYPE(STRING),  INTENT(IN) :: RHS   !< RIGHT HAND SIDE.
   LOGICAL                   :: IS_IT !< OPREATOR TEST RESULT.

   IS_IT = LHS%RAW == RHS%RAW
   ENDFUNCTION STRING_EQ_STRING

   ELEMENTAL FUNCTION STRING_EQ_CHARACTER(LHS, RHS) RESULT(IS_IT)
   !< EQUAL TO CHARACTER LOGICAL OPERATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: ACHARACTER
   !< LOGICAL                       :: TEST_PASSED(2)
   !< ASTRING = '  ONE '
   !< ACHARACTER = 'THREE'
   !< TEST_PASSED(1) = ((ASTRING==ACHARACTER).EQV..FALSE.)
   !< ASTRING = 'THE SAME '
   !< ACHARACTER = 'THE SAME '
   !< TEST_PASSED(2) = ((ASTRING==ACHARACTER).EQV..TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN) :: LHS   !< LEFT HAND SIDE.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN) :: RHS   !< RIGHT HAND SIDE.
   LOGICAL                               :: IS_IT !< OPREATOR TEST RESULT.

   IS_IT = LHS%RAW == RHS
   ENDFUNCTION STRING_EQ_CHARACTER

   ELEMENTAL FUNCTION CHARACTER_EQ_STRING(LHS, RHS) RESULT(IS_IT)
   !< EQUAL TO CHARACTER (INVERTED) LOGICAL OPERATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: ACHARACTER
   !< LOGICAL                       :: TEST_PASSED(2)
   !< ASTRING = '  ONE '
   !< ACHARACTER = 'THREE'
   !< TEST_PASSED(1) = ((ACHARACTER==ASTRING).EQV..FALSE.)
   !< ASTRING = 'THE SAME '
   !< ACHARACTER = 'THE SAME '
   !< TEST_PASSED(2) = ((ACHARACTER==ASTRING).EQV..TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CHARACTER(KIND=CK, LEN=*), INTENT(IN) :: LHS   !< LEFT HAND SIDE.
   CLASS(STRING),             INTENT(IN) :: RHS   !< RIGHT HAND SIDE.
   LOGICAL                               :: IS_IT !< OPREATOR TEST RESULT.

   IS_IT = RHS%RAW == LHS
   ENDFUNCTION CHARACTER_EQ_STRING

   ELEMENTAL FUNCTION STRING_NE_STRING(LHS, RHS) RESULT(IS_IT)
   !< NOT EQUAL TO STRING LOGICAL OPERATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< TYPE(STRING) :: ANOTHERSTRING
   !< LOGICAL      :: TEST_PASSED(2)
   !< ASTRING = '  ONE '
   !< ANOTHERSTRING = 'TWO'
   !< TEST_PASSED(1) = ((ASTRING/=ANOTHERSTRING).EQV..TRUE.)
   !< ASTRING = 'THE SAME '
   !< ANOTHERSTRING = 'THE SAME '
   !< TEST_PASSED(2) = ((ASTRING/=ANOTHERSTRING).EQV..FALSE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: LHS   !< LEFT HAND SIDE.
   TYPE(STRING),  INTENT(IN) :: RHS   !< RIGHT HAND SIDE.
   LOGICAL                   :: IS_IT !< OPREATOR TEST RESULT.

   IS_IT = LHS%RAW /= RHS%RAW
   ENDFUNCTION STRING_NE_STRING

   ELEMENTAL FUNCTION STRING_NE_CHARACTER(LHS, RHS) RESULT(IS_IT)
   !< NOT EQUAL TO CHARACTER LOGICAL OPERATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: ACHARACTER
   !< LOGICAL                       :: TEST_PASSED(2)
   !< ASTRING = '  ONE '
   !< ACHARACTER = 'THREE'
   !< TEST_PASSED(1) = ((ASTRING/=ACHARACTER).EQV..TRUE.)
   !< ASTRING = 'THE SAME '
   !< ACHARACTER = 'THE SAME '
   !< TEST_PASSED(2) = ((ASTRING/=ACHARACTER).EQV..FALSE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN) :: LHS   !< LEFT HAND SIDE.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN) :: RHS   !< RIGHT HAND SIDE.
   LOGICAL                               :: IS_IT !< OPREATOR TEST RESULT.

   IS_IT = LHS%RAW /= RHS
   ENDFUNCTION STRING_NE_CHARACTER

   ELEMENTAL FUNCTION CHARACTER_NE_STRING(LHS, RHS) RESULT(IS_IT)
   !< NOT EQUAL TO CHARACTER (INVERTED) LOGICAL OPERATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: ACHARACTER
   !< LOGICAL                       :: TEST_PASSED(2)
   !< ASTRING = '  ONE '
   !< ACHARACTER = 'THREE'
   !< TEST_PASSED(1) = ((ACHARACTER/=ASTRING).EQV..TRUE.)
   !< ASTRING = 'THE SAME '
   !< ACHARACTER = 'THE SAME '
   !< TEST_PASSED(2) = ((ACHARACTER/=ASTRING).EQV..FALSE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CHARACTER(KIND=CK, LEN=*), INTENT(IN) :: LHS   !< LEFT HAND SIDE.
   CLASS(STRING),             INTENT(IN) :: RHS   !< RIGHT HAND SIDE.
   LOGICAL                               :: IS_IT !< OPREATOR TEST RESULT.

   IS_IT = RHS%RAW /= LHS
   ENDFUNCTION CHARACTER_NE_STRING

   ELEMENTAL FUNCTION STRING_LT_STRING(LHS, RHS) RESULT(IS_IT)
   !< LOWER THAN TO STRING LOGICAL OPERATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< TYPE(STRING) :: ANOTHERSTRING
   !< LOGICAL      :: TEST_PASSED(2)
   !< ASTRING = 'ONE'
   !< ANOTHERSTRING = 'ONE'
   !< TEST_PASSED(1) = ((ASTRING<ANOTHERSTRING).EQV..FALSE.)
   !< ASTRING = 'ONE'
   !< ANOTHERSTRING = 'ONE'
   !< TEST_PASSED(2) = ((ASTRING<ANOTHERSTRING).EQV..TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: LHS   !< LEFT HAND SIDE.
   TYPE(STRING),  INTENT(IN) :: RHS   !< RIGHT HAND SIDE.
   LOGICAL                   :: IS_IT !< OPREATOR TEST RESULT.

   IS_IT = LHS%RAW < RHS%RAW
   ENDFUNCTION STRING_LT_STRING

   ELEMENTAL FUNCTION STRING_LT_CHARACTER(LHS, RHS) RESULT(IS_IT)
   !< LOWER THAN TO CHARACTER LOGICAL OPERATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: ACHARACTER
   !< LOGICAL                       :: TEST_PASSED(2)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(1) = ((ASTRING<ACHARACTER).EQV..FALSE.)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(2) = ((ASTRING<ACHARACTER).EQV..TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN) :: LHS   !< LEFT HAND SIDE.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN) :: RHS   !< RIGHT HAND SIDE.
   LOGICAL                               :: IS_IT !< OPREATOR TEST RESULT.

   IS_IT = LHS%RAW < RHS
   ENDFUNCTION STRING_LT_CHARACTER

   ELEMENTAL FUNCTION CHARACTER_LT_STRING(LHS, RHS) RESULT(IS_IT)
   !< LOWER THAN TO CHARACTER (INVERTED) LOGICAL OPERATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: ACHARACTER
   !< LOGICAL                       :: TEST_PASSED(2)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(1) = ((ACHARACTER<ASTRING).EQV..TRUE.)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(2) = ((ACHARACTER<ASTRING).EQV..FALSE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CHARACTER(KIND=CK, LEN=*), INTENT(IN) :: LHS   !< LEFT HAND SIDE.
   CLASS(STRING),             INTENT(IN) :: RHS   !< RIGHT HAND SIDE.
   LOGICAL                               :: IS_IT !< OPREATOR TEST RESULT.

   IS_IT = LHS < RHS%RAW
   ENDFUNCTION CHARACTER_LT_STRING

   ELEMENTAL FUNCTION STRING_LE_STRING(LHS, RHS) RESULT(IS_IT)
   !< LOWER EQUAL THAN TO STRING LOGICAL OPERATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< TYPE(STRING) :: ANOTHERSTRING
   !< LOGICAL      :: TEST_PASSED(3)
   !< ASTRING = 'ONE'
   !< ANOTHERSTRING = 'ONE'
   !< TEST_PASSED(1) = ((ASTRING<=ANOTHERSTRING).EQV..FALSE.)
   !< ASTRING = 'ONE'
   !< ANOTHERSTRING = 'ONE'
   !< TEST_PASSED(2) = ((ASTRING<=ANOTHERSTRING).EQV..TRUE.)
   !< ASTRING = 'ONE'
   !< ANOTHERSTRING = 'ONE'
   !< TEST_PASSED(3) = ((ASTRING<=ANOTHERSTRING).EQV..TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: LHS   !< LEFT HAND SIDE.
   TYPE(STRING),  INTENT(IN) :: RHS   !< RIGHT HAND SIDE.
   LOGICAL                   :: IS_IT !< OPREATOR TEST RESULT.

   IS_IT = LHS%RAW <= RHS%RAW
   ENDFUNCTION STRING_LE_STRING

   ELEMENTAL FUNCTION STRING_LE_CHARACTER(LHS, RHS) RESULT(IS_IT)
   !< LOWER EQUAL THAN TO CHARACTER LOGICAL OPERATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: ACHARACTER
   !< LOGICAL                       :: TEST_PASSED(3)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(1) = ((ASTRING<=ACHARACTER).EQV..FALSE.)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(2) = ((ASTRING<=ACHARACTER).EQV..TRUE.)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(3) = ((ASTRING<=ACHARACTER).EQV..TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN) :: LHS   !< LEFT HAND SIDE.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN) :: RHS   !< RIGHT HAND SIDE.
   LOGICAL                               :: IS_IT !< OPREATOR TEST RESULT.

   IS_IT = LHS%RAW <= RHS
   ENDFUNCTION STRING_LE_CHARACTER

   ELEMENTAL FUNCTION CHARACTER_LE_STRING(LHS, RHS) RESULT(IS_IT)
   !< LOWER EQUAL THAN TO CHARACTER (INVERTED) LOGICAL OPERATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: ACHARACTER
   !< LOGICAL                       :: TEST_PASSED(3)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(1) = ((ACHARACTER<=ASTRING).EQV..TRUE.)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(2) = ((ACHARACTER<=ASTRING).EQV..FALSE.)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(3) = ((ACHARACTER<=ASTRING).EQV..TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CHARACTER(KIND=CK, LEN=*), INTENT(IN) :: LHS   !< LEFT HAND SIDE.
   CLASS(STRING),             INTENT(IN) :: RHS   !< RIGHT HAND SIDE.
   LOGICAL                               :: IS_IT !< OPREATOR TEST RESULT.

   IS_IT = LHS <= RHS%RAW
   ENDFUNCTION CHARACTER_LE_STRING

   ELEMENTAL FUNCTION STRING_GE_STRING(LHS, RHS) RESULT(IS_IT)
   !< GREATER EQUAL THAN TO STRING LOGICAL OPERATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< TYPE(STRING) :: ANOTHERSTRING
   !< LOGICAL      :: TEST_PASSED(3)
   !< ASTRING = 'ONE'
   !< ANOTHERSTRING = 'ONE'
   !< TEST_PASSED(1) = ((ASTRING>=ANOTHERSTRING).EQV..TRUE.)
   !< ASTRING = 'ONE'
   !< ANOTHERSTRING = 'ONE'
   !< TEST_PASSED(2) = ((ASTRING>=ANOTHERSTRING).EQV..FALSE.)
   !< ASTRING = 'ONE'
   !< ANOTHERSTRING = 'ONE'
   !< TEST_PASSED(3) = ((ASTRING>=ANOTHERSTRING).EQV..TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: LHS   !< LEFT HAND SIDE.
   TYPE(STRING),  INTENT(IN) :: RHS   !< RIGHT HAND SIDE.
   LOGICAL                   :: IS_IT !< OPREATOR TEST RESULT.

   IS_IT = LHS%RAW >= RHS%RAW
   ENDFUNCTION STRING_GE_STRING

   ELEMENTAL FUNCTION STRING_GE_CHARACTER(LHS, RHS) RESULT(IS_IT)
   !< GREATER EQUAL THAN TO CHARACTER LOGICAL OPERATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: ACHARACTER
   !< LOGICAL                       :: TEST_PASSED(3)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(1) = ((ASTRING>=ACHARACTER).EQV..TRUE.)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(2) = ((ASTRING>=ACHARACTER).EQV..FALSE.)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(3) = ((ASTRING>=ACHARACTER).EQV..TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN) :: LHS   !< LEFT HAND SIDE.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN) :: RHS   !< RIGHT HAND SIDE.
   LOGICAL                               :: IS_IT !< OPREATOR TEST RESULT.

   IS_IT = LHS%RAW >= RHS
   ENDFUNCTION STRING_GE_CHARACTER

   ELEMENTAL FUNCTION CHARACTER_GE_STRING(LHS, RHS) RESULT(IS_IT)
   !< GREATER EQUAL THAN TO CHARACTER (INVERTED) LOGICAL OPERATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: ACHARACTER
   !< LOGICAL                       :: TEST_PASSED(3)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(1) = ((ACHARACTER>=ASTRING).EQV..FALSE.)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(2) = ((ACHARACTER>=ASTRING).EQV..TRUE.)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(3) = ((ACHARACTER>=ASTRING).EQV..TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CHARACTER(KIND=CK, LEN=*), INTENT(IN) :: LHS   !< LEFT HAND SIDE.
   CLASS(STRING),             INTENT(IN) :: RHS   !< RIGHT HAND SIDE.
   LOGICAL                               :: IS_IT !< OPREATOR TEST RESULT.

   IS_IT = LHS >= RHS%RAW
   ENDFUNCTION CHARACTER_GE_STRING

   ELEMENTAL FUNCTION STRING_GT_STRING(LHS, RHS) RESULT(IS_IT)
   !< GREATER THAN TO STRING LOGICAL OPERATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING) :: ASTRING
   !< TYPE(STRING) :: ANOTHERSTRING
   !< LOGICAL      :: TEST_PASSED(2)
   !< ASTRING = 'ONE'
   !< ANOTHERSTRING = 'ONE'
   !< TEST_PASSED(1) = ((ASTRING>ANOTHERSTRING).EQV..TRUE.)
   !< ASTRING = 'ONE'
   !< ANOTHERSTRING = 'ONE'
   !< TEST_PASSED(2) = ((ASTRING>ANOTHERSTRING).EQV..FALSE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING), INTENT(IN) :: LHS   !< LEFT HAND SIDE.
   TYPE(STRING),  INTENT(IN) :: RHS   !< RIGHT HAND SIDE.
   LOGICAL                   :: IS_IT !< OPREATOR TEST RESULT.

   IS_IT = LHS%RAW > RHS%RAW
   ENDFUNCTION STRING_GT_STRING

   ELEMENTAL FUNCTION STRING_GT_CHARACTER(LHS, RHS) RESULT(IS_IT)
   !< GREATER THAN TO CHARACTER LOGICAL OPERATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: ACHARACTER
   !< LOGICAL                       :: TEST_PASSED(2)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(1) = ((ASTRING>ACHARACTER).EQV..TRUE.)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(2) = ((ASTRING>ACHARACTER).EQV..FALSE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CLASS(STRING),             INTENT(IN) :: LHS   !< LEFT HAND SIDE.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN) :: RHS   !< RIGHT HAND SIDE.
   LOGICAL                               :: IS_IT !< OPREATOR TEST RESULT.

   IS_IT = LHS%RAW > RHS
   ENDFUNCTION STRING_GT_CHARACTER

   ELEMENTAL FUNCTION CHARACTER_GT_STRING(LHS, RHS) RESULT(IS_IT)
   !< GREATER THAN TO CHARACTER (INVERTED) LOGICAL OPERATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING)                  :: ASTRING
   !< CHARACTER(LEN=:), ALLOCATABLE :: ACHARACTER
   !< LOGICAL                       :: TEST_PASSED(2)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(1) = ((ACHARACTER>ASTRING).EQV..FALSE.)
   !< ASTRING = 'ONE'
   !< ACHARACTER = 'ONE'
   !< TEST_PASSED(2) = ((ACHARACTER>ASTRING).EQV..TRUE.)
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CHARACTER(KIND=CK, LEN=*), INTENT(IN) :: LHS   !< LEFT HAND SIDE.
   CLASS(STRING),             INTENT(IN) :: RHS   !< RIGHT HAND SIDE.
   LOGICAL                               :: IS_IT !< OPREATOR TEST RESULT.

   IS_IT = LHS > RHS%RAW
   ENDFUNCTION CHARACTER_GT_STRING

   ! IO
   SUBROUTINE READ_FORMATTED(DTV, UNIT, IOTYPE, V_LIST, IOSTAT, IOMSG)
   !< FORMATTED INPUT.
   !<
   !< @BUG CHANGE TEMPORARY ACKS: FIND A MORE PRECISE LENGTH OF THE INPUT STRING AND AVOID THE TRIMMING!
   !<
   !< @BUG READ LISTDIRECTED WITH AND WITHOUT DELIMITERS DOES NOT WORK.
   CLASS(STRING),             INTENT(INOUT) :: DTV         !< THE STRING.
   INTEGER,                   INTENT(IN)    :: UNIT        !< LOGICAL UNIT.
   CHARACTER(LEN=*),          INTENT(IN)    :: IOTYPE      !< EDIT DESCRIPTOR.
   INTEGER,                   INTENT(IN)    :: V_LIST(:)   !< EDIT DESCRIPTOR LIST.
   INTEGER,                   INTENT(OUT)   :: IOSTAT      !< IO STATUS CODE.
   CHARACTER(LEN=*),          INTENT(INOUT) :: IOMSG       !< IO STATUS MESSAGE.
   CHARACTER(LEN=LEN(IOMSG))                :: LOCAL_IOMSG !< LOCAL VARIANT OF IOMSG, SO IT DOESN'T GET INAPPROPRIATELY REDEFINED.
   CHARACTER(KIND=CK, LEN=1)                :: DELIM       !< STRING DELIMITER, IF ANY.
   CHARACTER(KIND=CK, LEN=100)              :: TEMPORARY   !< TEMPORARY STORAGE STRING.
   IF (V_LIST(1).EQ.0) THEN
   ENDIF
   IF (IOTYPE == 'LISTDIRECTED') THEN
      CALL GET_NEXT_NON_BLANK_CHARACTER_ANY_RECORD(UNIT=UNIT, CH=DELIM, IOSTAT=IOSTAT, IOMSG=IOMSG)
      IF (IOSTAT/=0) RETURN
      IF (DELIM=='"'.OR.DELIM=="'") THEN
         CALL DTV%READ_DELIMITED(UNIT=UNIT, DELIM=DELIM, IOSTAT=IOSTAT, IOMSG=LOCAL_IOMSG)
      ELSE
         ! STEP BACK BEFORE THE NON-BLANK
         READ(UNIT, "(TL1)", IOSTAT=IOSTAT, IOMSG=IOMSG)
         IF (IOSTAT /= 0) RETURN
         CALL DTV%READ_UNDELIMITED_LISTDIRECTED(UNIT=UNIT, IOSTAT=IOSTAT, IOMSG=LOCAL_IOMSG)
      ENDIF
      IF (IS_IOSTAT_EOR(IOSTAT)) THEN
         ! SUPPRESS IOSTAT_EOR
         IOSTAT = 0
      ELSEIF (IOSTAT /= 0) THEN
         IOMSG = LOCAL_IOMSG
      ENDIF
      RETURN
   ELSE
      READ(UNIT, "(A)", IOSTAT=IOSTAT, IOMSG=IOMSG)TEMPORARY
      DTV%RAW = TRIM(TEMPORARY)
   ENDIF
   ENDSUBROUTINE READ_FORMATTED

   SUBROUTINE READ_DELIMITED(DTV, UNIT, DELIM, IOSTAT, IOMSG)
   !< READ A DELIMITED STRING FROM A UNIT CONNECTED FOR FORMATTED INPUT.
   !<
   !< IF THE CLOSING DELIMITER IS FOLLOWED BY END OF RECORD, THEN WE RETURN END OF RECORD.
   !<
   !< @NOTE THIS DOES NOT NEED A DOCTEST, IT BEING TESTED BY [[STRING::READ_FORMATTED]].
   CLASS(STRING),             INTENT(OUT)   :: DTV       !< THE STRING.
   INTEGER,                   INTENT(IN)    :: UNIT      !< LOGICAL UNIT.
   CHARACTER(KIND=CK, LEN=1), INTENT(IN)    :: DELIM     !< STRING DELIMITER.
   INTEGER,                   INTENT(OUT)   :: IOSTAT    !< IO STATUS CODE.
   CHARACTER(KIND=CK, LEN=*), INTENT(INOUT) :: IOMSG     !< IO STATUS MESSAGE.
   CHARACTER(KIND=CK, LEN=1)                :: CH        !< A CHARACTER READ.
   LOGICAL                                  :: WAS_DELIM !< INDICATES THAT THE LAST CHARACTER READ WAS A DELIMITER.

   WAS_DELIM = .FALSE.
   DTV%RAW = ''
   DO
      READ(UNIT, "(A)", IOSTAT=IOSTAT, IOMSG=IOMSG) CH
      IF (IS_IOSTAT_EOR(IOSTAT)) THEN
         IF (WAS_DELIM) THEN
           ! END OF DELIMITED STRING FOLLOWED BY END OF RECORD IS END OF THE STRING. PASS BACK THE
           ! END OF RECORD CONDITION TO THE CALLER
           RETURN
         ELSE
           ! END OF RECORD WITHOUT TERMINATING DELIMITER - MOVE ALONG
           CYCLE
         ENDIF
      ELSEIF (IOSTAT /= 0) THEN
        RETURN
      ENDIF
      IF (CH == DELIM) THEN
         IF (WAS_DELIM) THEN
            ! DOUBLED DELIMITER IS ONE DELIMITER IN THE VALUE
            DTV%RAW = DTV%RAW // CH
            WAS_DELIM = .FALSE.
         ELSE
            ! NEED TO TEST NEXT CHARACTER TO SEE WHAT IS HAPPENING
            WAS_DELIM = .TRUE.
         ENDIF
      ELSEIF (WAS_DELIM) THEN
         ! THE PREVIOUS CHARACTER WAS ACTUALLY THE DELIMITER FOR THE END OF THE STRING. PUT BACK THIS CHARACTER
         READ(UNIT, "(TL1)", IOSTAT=IOSTAT, IOMSG=IOMSG)
         RETURN
      ELSE
         DTV%RAW = DTV%RAW // CH
      ENDIF
   ENDDO
   ENDSUBROUTINE READ_DELIMITED

  SUBROUTINE READ_UNDELIMITED_LISTDIRECTED(DTV, UNIT, IOSTAT, IOMSG)
  !< READ AN UNDELIMITED (NO LEADING APOSTROPHE OR DOUBLE QUOTE) CHARACTER VALUE ACCORDING TO THE RULES FOR LIST DIRECTED INPUT.
  !<
  !< A BLANK, COMMA/SEMICOLON (DEPENDING ON THE DECIMAL MODE), SLASH OR END OF RECORD TERMINATES THE STRING.
  !<
  !< IF INPUT IS TERMINATED BY END OF RECORD, THEN THIS PROCEDURE RETURNS AN END-OF-RECORD CONDITION.
  CLASS(STRING),    INTENT(INOUT) :: DTV           !< THE STRING.
  INTEGER,          INTENT(IN)    :: UNIT          !< LOGICAL UNIT.
  INTEGER,          INTENT(OUT)   :: IOSTAT        !< IO STATUS CODE.
  CHARACTER(LEN=*), INTENT(INOUT) :: IOMSG         !< IO STATUS MESSAGE.
  LOGICAL                         :: DECIMAL_POINT !<TRUE IF DECIMAL=POINT IN EFFECT.

  CALL GET_DECIMAL_MODE(UNIT=UNIT, DECIMAL_POINT=DECIMAL_POINT, IOSTAT=IOSTAT, IOMSG=IOMSG)
  IF (IOSTAT /= 0) RETURN
  CALL DTV%READ_UNDELIMITED(UNIT=UNIT, TERMINATORS=' '//'/'//MERGE(CK_',', CK_';', DECIMAL_POINT), IOSTAT=IOSTAT, IOMSG=IOMSG)
  ENDSUBROUTINE READ_UNDELIMITED_LISTDIRECTED

  SUBROUTINE READ_UNDELIMITED(DTV, UNIT, TERMINATORS, IOSTAT, IOMSG)
  !< READ AN UNDELIMITED STRING UP UNTIL END OF RECORD OR A CHARACTER FROM A SET OF TERMINATORS IS ENCOUNTERED.
  !<
  !< IF A TERMINATOR IS ENCOUNTERED, THE FILE POSITION WILL BE AT THAT TERMINATING CHARACTER. IF END OF RECORD IS ENCOUNTERED, THE
  !< FILE REMAINS AT END OF RECORD.
  CLASS(STRING),             INTENT(INOUT) :: DTV         !< THE STRING.
  INTEGER,                   INTENT(IN)    :: UNIT        !< LOGICAL UNIT.
  CHARACTER(KIND=CK, LEN=*), INTENT(IN)    :: TERMINATORS !< CHARACTERS THAT ARE CONSIDERED TO TERMINATE THE STRING.
                                                          !< BLANKS IN THIS STRING ARE MEANINGFUL.
  INTEGER,                   INTENT(OUT)   :: IOSTAT      !< IO STATUS CODE.
  CHARACTER(LEN=*),          INTENT(INOUT) :: IOMSG       !< IO STATUS MESSAGE.
  CHARACTER(KIND=CK, LEN=1)                :: CH          !< A CHARACTER READ.

  DTV%RAW = ''
  DO
    READ(UNIT, "(A)", IOSTAT=IOSTAT, IOMSG=IOMSG) CH
    IF (IS_IOSTAT_EOR(IOSTAT)) THEN
      ! END OF RECORD JUST MEANS END OF STRING. WE PASS ON THE CONDITION
      RETURN
    ELSEIF (IOSTAT /= 0) THEN
      ! SOMETHING ODD HAPPENED
      RETURN
    ENDIF
    IF (SCAN(CH, TERMINATORS) /= 0) THEN
      ! CHANGE THE FILE POSITION SO THAT THE NEXT READ SEES THE TERMINATOR
      READ(UNIT, "(TL1)", IOSTAT=IOSTAT, IOMSG=IOMSG)
      IF (IOSTAT /= 0) RETURN
      IOSTAT = 0
      RETURN
    ENDIF
    ! WE GOT A CHARACTER - APPEND IT
    DTV%RAW = DTV%RAW // CH
  ENDDO
  ENDSUBROUTINE READ_UNDELIMITED

   SUBROUTINE WRITE_FORMATTED(DTV, UNIT, IOTYPE, V_LIST, IOSTAT, IOMSG)
   !< FORMATTED OUTPUT.
   CLASS(STRING),             INTENT(IN)    :: DTV       !< THE STRING.
   INTEGER,                   INTENT(IN)    :: UNIT      !< LOGICAL UNIT.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)    :: IOTYPE    !< EDIT DESCRIPTOR.
   INTEGER,                   INTENT(IN)    :: V_LIST(:) !< EDIT DESCRIPTOR LIST.
   INTEGER,                   INTENT(OUT)   :: IOSTAT    !< IO STATUS CODE.
   CHARACTER(KIND=CK, LEN=*), INTENT(INOUT) :: IOMSG     !< IO STATUS MESSAGE.
   IF (IOTYPE=="") THEN
   ENDIF
   IF (V_LIST(1).EQ.0) THEN
   ENDIF
   IF (ALLOCATED(DTV%RAW)) THEN
     WRITE(UNIT, "(A)", IOSTAT=IOSTAT, IOMSG=IOMSG)DTV%RAW
   ELSE
     WRITE(UNIT, "(A)", IOSTAT=IOSTAT, IOMSG=IOMSG)''
   ENDIF
   ENDSUBROUTINE WRITE_FORMATTED

   SUBROUTINE READ_UNFORMATTED(DTV, UNIT, IOSTAT, IOMSG)
   !< UNFORMATTED INPUT.
   !<
   !< @BUG CHANGE TEMPORARY ACKS: FIND A MORE PRECISE LENGTH OF THE INPUT STRING AND AVOID THE TRIMMING!
   CLASS(STRING),             INTENT(INOUT) :: DTV       !< THE STRING.
   INTEGER,                   INTENT(IN)    :: UNIT      !< LOGICAL UNIT.
   INTEGER,                   INTENT(OUT)   :: IOSTAT    !< IO STATUS CODE.
   CHARACTER(KIND=CK, LEN=*), INTENT(INOUT) :: IOMSG     !< IO STATUS MESSAGE.
   CHARACTER(KIND=CK, LEN=100)              :: TEMPORARY !< TEMPORARY STORAGE STRING.

   READ(UNIT, IOSTAT=IOSTAT, IOMSG=IOMSG)TEMPORARY
   DTV%RAW = TRIM(TEMPORARY)
   ENDSUBROUTINE READ_UNFORMATTED

   SUBROUTINE WRITE_UNFORMATTED(DTV, UNIT, IOSTAT, IOMSG)
   !< UNFORMATTED OUTPUT.
   CLASS(STRING),             INTENT(IN)    :: DTV    !< THE STRING.
   INTEGER,                   INTENT(IN)    :: UNIT   !< LOGICAL UNIT.
   INTEGER,                   INTENT(OUT)   :: IOSTAT !< IO STATUS CODE.
   CHARACTER(KIND=CK, LEN=*), INTENT(INOUT) :: IOMSG  !< IO STATUS MESSAGE.

   IF (ALLOCATED(DTV%RAW)) THEN
     WRITE(UNIT, IOSTAT=IOSTAT, IOMSG=IOMSG)DTV%RAW
   ELSE
     WRITE(UNIT, IOSTAT=IOSTAT, IOMSG=IOMSG)''
   ENDIF
   ENDSUBROUTINE WRITE_UNFORMATTED

   ! MISCELLANEA
   ELEMENTAL FUNCTION REPLACE_ONE_OCCURRENCE(SELF, OLD, NEW) RESULT(REPLACED)
   !< RETURN A STRING WITH THE FIRST OCCURRENCE OF SUBSTRING OLD REPLACED BY NEW.
   !<
   !< @NOTE THE DOCTEST IS NOT NECESSARY, THIS BEING TESTED BY [[STRING:REPLACE]].
   CLASS(STRING),             INTENT(IN)  :: SELF      !< THE STRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)  :: OLD       !< OLD SUBSTRING.
   CHARACTER(KIND=CK, LEN=*), INTENT(IN)  :: NEW       !< NEW SUBSTRING.
   TYPE(STRING)                           :: REPLACED  !< THE STRING WITH OLD REPLACED BY NEW.
   INTEGER                                :: POS       !< POSITION FROM WHICH REPLACE OLD.

   IF (ALLOCATED(SELF%RAW)) THEN
      REPLACED = SELF
      POS = INDEX(STRING=SELF%RAW, SUBSTRING=OLD)
      IF (POS>0) THEN
         IF (POS==1) THEN
            REPLACED%RAW = NEW//SELF%RAW(LEN(OLD)+1:)
         ELSE
            REPLACED%RAW = SELF%RAW(1:POS-1)//NEW//SELF%RAW(POS+LEN(OLD):)
         ENDIF
      ENDIF
   ENDIF
   ENDFUNCTION REPLACE_ONE_OCCURRENCE

   ! NON TYPE-BOUND-PROCEDURES
   SUBROUTINE GET_DELIMITER_MODE(UNIT, DELIM, IOSTAT, IOMSG)
   !< GET THE DELIM CHANGEABLE CONNECTION MODE FOR THE GIVEN UNIT.
   !<
   !< IF THE UNIT IS CONNECTED TO AN INTERNAL FILE, THEN THE DEFAULT VALUE OF NONE IS ALWAYS RETURNED.
   USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY : IOSTAT_INQUIRE_INTERNAL_UNIT
   INTEGER,                   INTENT(IN)    :: UNIT         !< THE UNIT FOR THE CONNECTION.
   CHARACTER(LEN=1, KIND=CK), INTENT(OUT)   :: DELIM        !< REPRESENTS THE VALUE OF THE DELIM MODE.
   INTEGER,                   INTENT(OUT)   :: IOSTAT       !< IOSTAT ERROR CODE, NON-ZERO ON ERROR.
   CHARACTER(*),              INTENT(INOUT) :: IOMSG        !< IOMSG EXPLANATORY MESSAGE - ONLY DEFINED IF IOSTAT IS NON-ZERO.
   CHARACTER(10)                            :: DELIM_BUFFER !< BUFFER FOR INQUIRE ABOUT DELIM, SIZED FOR APOSTROHPE.
   CHARACTER(LEN(IOMSG))                    :: LOCAL_IOMSG  !< LOCAL VARIANT OF IOMSG, SO IT DOESN'T GET INAPPROPRIATELY REDEFINED.

   ! GET THE STRING REPRESENTATION OF THE CHANGEABLE MODE
   INQUIRE(UNIT, DELIM=DELIM_BUFFER, IOSTAT=IOSTAT, IOMSG=LOCAL_IOMSG)
   IF (IOSTAT == IOSTAT_INQUIRE_INTERNAL_UNIT) THEN
      ! NO WAY OF DETERMINING THE DELIM MODE FOR AN INTERNAL FILE
      IOSTAT = 0
      DELIM = ''
      RETURN
   ELSEIF (IOSTAT /= 0) THEN
      IOMSG = LOCAL_IOMSG
      RETURN
   ENDIF
   ! INTERPRET THE DELIM STRING
   IF (DELIM_BUFFER == 'QUOTE') THEN
      DELIM = '"'
   ELSEIF (DELIM_BUFFER == 'APOSTROPHE') THEN
      DELIM = ''''
   ELSE
      DELIM = '"'
   ENDIF
   ENDSUBROUTINE GET_DELIMITER_MODE

   SUBROUTINE GET_NEXT_NON_BLANK_CHARACTER_THIS_RECORD(UNIT, CH, IOSTAT, IOMSG)
   !< GET THE NEXT NON-BLANK CHARACTER IN THE CURRENT RECORD.
   INTEGER,                   INTENT(IN)    :: UNIT   !< LOGICAL UNIT.
   CHARACTER(KIND=CK, LEN=1), INTENT(OUT)   :: CH     !< THE NON-BLANK CHARACTER READ. NOT VALID IF IOSTAT IS NON-ZERO.
   INTEGER,                   INTENT(OUT)   :: IOSTAT !< IO STATUS CODE.
   CHARACTER(KIND=CK, LEN=*), INTENT(INOUT) :: IOMSG  !< IO STATUS MESSAGE.

   DO
      ! WE SPCIFY NON-ADVANCING, JUST IN CASE WE WANT THIS CALLABLE OUTSIDE THE CONTEXT OF A CHILD INPUT STATEMENT
      ! THE PAD SPECIFIER SIMPLY SAVES THE NEED FOR THE READ STATEMENT TO DEFINE CH IF EOR IS HIT
      ! READ(UNIT, "(A)", IOSTAT=IOSTAT, IOMSG=IOMSG, ADVANCE='NO') CH
      ! ...BUT THAT CAUSES IFORT TO BLOW UP AT RUNTIME
      READ(UNIT, "(A)", IOSTAT=IOSTAT, IOMSG=IOMSG, PAD='NO') CH
      IF (IOSTAT /= 0) RETURN
      IF (CH /= '') EXIT
   ENDDO
   ENDSUBROUTINE GET_NEXT_NON_BLANK_CHARACTER_THIS_RECORD

   SUBROUTINE GET_NEXT_NON_BLANK_CHARACTER_ANY_RECORD(UNIT, CH, IOSTAT, IOMSG)
   !< GET THE NEXT NON-BLANK CHARACTER, ADVANCING RECORDS IF NECESSARY.
   INTEGER,                   INTENT(IN)    :: UNIT        !< LOGICAL UNIT.
   CHARACTER(KIND=CK, LEN=1), INTENT(OUT)   :: CH          !< THE NON-BLANK CHARACTER READ. NOT VALID IF IOSTAT IS NON-ZERO.
   INTEGER,                   INTENT(OUT)   :: IOSTAT      !< IO STATUS CODE.
   CHARACTER(KIND=CK, LEN=*), INTENT(INOUT) :: IOMSG       !< IO STATUS MESSAGE.
   CHARACTER(LEN(IOMSG))                    :: LOCAL_IOMSG !< LOCAL VARIANT OF IOMSG, SO IT DOESN'T GET INAPPROPRIATELY REDEFINED.

   DO
      CALL GET_NEXT_NON_BLANK_CHARACTER_THIS_RECORD(UNIT=UNIT, CH=CH, IOSTAT=IOSTAT, IOMSG=LOCAL_IOMSG)
      IF (IS_IOSTAT_EOR(IOSTAT)) THEN
         ! TRY AGAIN ON THE NEXT RECORD
         READ (UNIT, "(/)", IOSTAT=IOSTAT, IOMSG=IOMSG)
         IF (IOSTAT /= 0) RETURN
      ELSEIF (IOSTAT /= 0) THEN
         ! SOME SORT OF PROBLEM
         IOMSG = LOCAL_IOMSG
         RETURN
      ELSE
         ! GOT IT
         EXIT
      ENDIF
   ENDDO
   ENDSUBROUTINE GET_NEXT_NON_BLANK_CHARACTER_ANY_RECORD

   SUBROUTINE GET_DECIMAL_MODE(UNIT, DECIMAL_POINT, IOSTAT, IOMSG)
   !< GET THE DECIMAL CHANGEABLE CONNECTION MODE FOR THE GIVEN UNIT.
   !<
   !< IF THE UNIT IS CONNECTED TO AN INTERNAL FILE, THEN THE DEFAULT VALUE OF DECIMAL IS ALWAYS RETURNED. THIS MAY NOT BE THE
   !< ACTUAL VALUE IN FORCE AT THE TIME OF THE CALL TO THIS PROCEDURE.
   USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY : IOSTAT_INQUIRE_INTERNAL_UNIT
   INTEGER,                   INTENT(IN)    :: UNIT           !< LOGICAL UNIT.
   LOGICAL,                   INTENT(OUT)   :: DECIMAL_POINT  !< TRUE IF THE DECIMAL MODE IS POINT, FALSE OTHERWISE.
   INTEGER,                   INTENT(OUT)   :: IOSTAT         !< IO STATUS CODE.
   CHARACTER(KIND=CK, LEN=*), INTENT(INOUT) :: IOMSG          !< IO STATUS MESSAGE.
   CHARACTER(5)                             :: DECIMAL_BUFFER !< BUFFER FOR INQUIRE ABOUT DECIMAL, SIZED FOR POINT OR COMMA.
   CHARACTER(LEN(IOMSG))                    :: LOCAL_IOMSG    !< LOCAL IOMSG, SO IT DOESN'T GET INAPPROPRIATELY REDEFINED.

   INQUIRE(UNIT, DECIMAL=DECIMAL_BUFFER, IOSTAT=IOSTAT, IOMSG=LOCAL_IOMSG)
   IF (IOSTAT == IOSTAT_INQUIRE_INTERNAL_UNIT) THEN
      ! NO WAY OF DETERMINING THE DECIMAL MODE FOR AN INTERNAL FILE
      IOSTAT = 0
      DECIMAL_POINT = .TRUE.
      RETURN
   ELSE IF (IOSTAT /= 0) THEN
      IOMSG = LOCAL_IOMSG
      RETURN
   ENDIF
   DECIMAL_POINT = DECIMAL_BUFFER == 'POINT'
   ENDSUBROUTINE GET_DECIMAL_MODE
ENDMODULE STRINGIFOR_STRING_T




!< STRINGIFOR, STRINGS FORTRAN MANIPULATOR WITH STEROIDS.

MODULE STRINGIFOR
!< STRINGIFOR, STRINGS FORTRAN MANIPULATOR WITH STEROIDS.
USE PENF, ONLY : I1P, I2P, I4P, I8P, R4P, R8P, R16P
! USE STRINGIFOR_STRING_T, ONLY : ADJUSTL, ADJUSTR, COUNT, INDEX, LEN, LEN_TRIM, REPEAT, SCAN, TRIM, VERIFY, CK, STRING
USE STRINGIFOR_STRING_T, ONLY : ADJUSTL, ADJUSTR, COUNT, INDEX, LEN_TRIM, REPEAT, SCAN, TRIM, VERIFY, CK, GLOB, STRING, STRJOIN

IMPLICIT NONE
PRIVATE
SAVE
! EXPOSE STINGIFOR OBJECTS
PUBLIC :: CK
PUBLIC :: GLOB
PUBLIC :: STRJOIN
PUBLIC :: STRING
! EXPOSE STINGIFOR OVERLOADED BUILTINS AND OPERATORS
! PUBLIC :: ADJUSTL, ADJUSTR, COUNT, INDEX, LEN, LEN_TRIM, REPEAT, SCAN, TRIM, VERIFY
PUBLIC :: ADJUSTL, ADJUSTR, COUNT, INDEX, LEN_TRIM, REPEAT, SCAN, TRIM, VERIFY
! EXPOSE STINGIFOR NEW PROCEDURES
PUBLIC :: READ_FILE, READ_LINES, WRITE_FILE, WRITE_LINES
! EXPOSE PENF KINDS
PUBLIC :: I1P, I2P, I4P, I8P, R4P, R8P, R16P

CONTAINS
   SUBROUTINE READ_FILE(FILE, LINES, FORM, IOSTAT, IOMSG)
   !< READ A FILE AS A SINGLE STRING STREAM.
   !<
   !< THE LINES ARE RETURNED AS AN ARRAY OF STRINGS THAT ARE READ UNTIL THE EOF IS REACHED.
   !< THE LINE IS READ AS AN ASCII STREAM READ UNTIL THE EOR IS REACHED.
   !<
   !< @NOTE FOR UNFORMATTED READ ONLY `ACCESS='STREAM'` IS SUPPORTED WITH NEW_LINE AS LINE TERMINATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING)              :: ASTRING
   !< TYPE(STRING), ALLOCATABLE :: STRINGS(:)
   !< TYPE(STRING)              :: LINE(3)
   !< INTEGER                   :: IOSTAT
   !< CHARACTER(LEN=99)         :: IOMSG
   !< INTEGER                   :: SCRATCH
   !< INTEGER                   :: L
   !< LOGICAL                   :: TEST_PASSED(8)
   !< LINE(1) = ' HELLO WORLD!   '
   !< LINE(2) = 'HOW ARE YOU?  '
   !< LINE(3) = '   ALL SAY: "FINE THANKS"'
   !< OPEN(NEWUNIT=SCRATCH, FILE='READ_FILE_TEST.TMP')
   !< WRITE(SCRATCH, "(A)") LINE(1)%CHARS()
   !< WRITE(SCRATCH, "(A)") LINE(2)%CHARS()
   !< WRITE(SCRATCH, "(A)") LINE(3)%CHARS()
   !< CLOSE(SCRATCH)
   !< CALL READ_FILE(FILE='READ_FILE_TEST.TMP', LINES=STRINGS, IOSTAT=IOSTAT, IOMSG=IOMSG)
   !< TEST_PASSED(1) = (SIZE(STRINGS, DIM=1)==SIZE(LINE, DIM=1))
   !< DO L=1, SIZE(STRINGS, DIM=1)
   !<   TEST_PASSED(L+1) = (STRINGS(L)==LINE(L))
   !< ENDDO
   !< OPEN(NEWUNIT=SCRATCH, FILE='READ_FILE_TEST.TMP', FORM='UNFORMATTED', ACCESS='STREAM')
   !< WRITE(SCRATCH) LINE(1)%CHARS()//NEW_LINE('A')
   !< WRITE(SCRATCH) LINE(2)%CHARS()//NEW_LINE('A')
   !< WRITE(SCRATCH) LINE(3)%CHARS()//NEW_LINE('A')
   !< CLOSE(SCRATCH)
   !< CALL READ_FILE(FILE='READ_FILE_TEST.TMP', LINES=STRINGS, FORM='UNFORMATTED', IOSTAT=IOSTAT, IOMSG=IOMSG)
   !< TEST_PASSED(5) = (SIZE(STRINGS, DIM=1)==SIZE(LINE, DIM=1))
   !< DO L=1, SIZE(STRINGS, DIM=1)
   !<   TEST_PASSED(L+5) = (STRINGS(L)==LINE(L))
   !< ENDDO
   !< OPEN(NEWUNIT=SCRATCH, FILE='READ_FILE_TEST.TMP', FORM='UNFORMATTED', ACCESS='STREAM')
   !< CLOSE(SCRATCH, STATUS='DELETE')
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CHARACTER(LEN=*), INTENT(IN)               :: FILE       !< FILE NAME.
   TYPE(STRING),     INTENT(OUT), ALLOCATABLE :: LINES(:)   !< THE LINES.
   CHARACTER(LEN=*), INTENT(IN),    OPTIONAL  :: FORM       !< FORMAT OF UNIT.
   INTEGER,          INTENT(OUT),   OPTIONAL  :: IOSTAT     !< IO STATUS CODE.
   CHARACTER(LEN=*), INTENT(INOUT), OPTIONAL  :: IOMSG      !< IO STATUS MESSAGE.
   TYPE(STRING)                               :: FORM_      !< FORMAT OF UNIT, LOCAL VARIABLE.
   INTEGER                                    :: IOSTAT_    !< IO STATUS CODE, LOCAL VARIABLE.
   CHARACTER(LEN=:), ALLOCATABLE              :: IOMSG_     !< IO STATUS MESSAGE, LOCAL VARIABLE.
   INTEGER                                    :: UNIT       !< LOGICAL UNIT.
   LOGICAL                                    :: DOES_EXIST !< CHECK IF FILE EXIST.

   IOMSG_ = REPEAT(' ', 99) ; IF (PRESENT(IOMSG)) IOMSG_ = IOMSG
   INQUIRE(FILE=FILE, IOMSG=IOMSG_, IOSTAT=IOSTAT_, EXIST=DOES_EXIST)
   IF (DOES_EXIST) THEN
      FORM_ = 'FORMATTED' ; IF (PRESENT(FORM)) FORM_ = FORM ; FORM_ = FORM_%UPPER()
      SELECT CASE(FORM_%CHARS())
      CASE('FORMATTED')
         OPEN(NEWUNIT=UNIT, FILE=FILE, STATUS='OLD', ACTION='READ', IOMSG=IOMSG_, IOSTAT=IOSTAT_, ERR=10)
      CASE('UNFORMATTED')
         OPEN(NEWUNIT=UNIT, FILE=FILE, STATUS='OLD', ACTION='READ', FORM='UNFORMATTED', ACCESS='STREAM', &
              IOMSG=IOMSG_, IOSTAT=IOSTAT_, ERR=10)
      ENDSELECT
      CALL READ_LINES(UNIT=UNIT, LINES=LINES, FORM=FORM, IOMSG=IOMSG_, IOSTAT=IOSTAT_)
      10 CLOSE(UNIT)
   ENDIF
   IF (PRESENT(IOSTAT)) IOSTAT = IOSTAT_
   IF (PRESENT(IOMSG)) IOMSG = IOMSG_
   ENDSUBROUTINE READ_FILE

   SUBROUTINE READ_LINES(UNIT, LINES, FORM, IOSTAT, IOMSG)
   !< READ LINES (RECORDS) FROM A CONNECTED-FORMATTED UNIT.
   !<
   !< @NOTE THE CONNECTED UNIT IS REWINDED. AT A SUCCESSFUL EXIT CURRENT RECORD IS AT EOF, AT THE BEGINNING OTHERWISE.
   !<
   !< THE LINES ARE RETURNED AS AN ARRAY OF STRINGS THAT ARE READ UNTIL THE EOF IS REACHED.
   !< THE LINE IS READ AS AN ASCII STREAM READ UNTIL THE EOR IS REACHED.
   !<
   !< @NOTE FOR UNFORMATTED READ ONLY `ACCESS='STREAM'` IS SUPPORTED WITH NEW_LINE AS LINE TERMINATOR.
   !<
   !< @NOTE THERE IS NO DOCTESTS, THIS BEING TESTED BY MEANS OF [[READ_FILE]] DOCTESTS.
   INTEGER,          INTENT(IN)               :: UNIT     !< LOGICAL UNIT.
   TYPE(STRING),     INTENT(OUT), ALLOCATABLE :: LINES(:) !< THE LINES.
   CHARACTER(LEN=*), INTENT(IN),    OPTIONAL  :: FORM     !< FORMAT OF UNIT.
   INTEGER,          INTENT(OUT),   OPTIONAL  :: IOSTAT   !< IO STATUS CODE.
   CHARACTER(LEN=*), INTENT(INOUT), OPTIONAL  :: IOMSG    !< IO STATUS MESSAGE.
   TYPE(STRING)                               :: FORM_    !< FORMAT OF UNIT, LOCAL VARIABLE.
   INTEGER                                    :: IOSTAT_  !< IO STATUS CODE, LOCAL VARIABLE.
   CHARACTER(LEN=:), ALLOCATABLE              :: IOMSG_   !< IO STATUS MESSAGE, LOCAL VARIABLE.
   CHARACTER(KIND=CK, LEN=1)                  :: CH       !< CHARACTER STORAGE.
   INTEGER                                    :: L        !< COUNTER.

   FORM_ = 'FORMATTED' ; IF (PRESENT(FORM)) FORM_ = FORM ; FORM_ = FORM_%UPPER()
   IOMSG_ = REPEAT(' ', 99) ; IF (PRESENT(IOMSG)) IOMSG_ = IOMSG
   REWIND(UNIT)
   SELECT CASE(FORM_%CHARS())
   CASE('FORMATTED')
      L = 0
      DO
         READ(UNIT, *, ERR=10, END=10)
         L = L + 1
      ENDDO
   CASE('UNFORMATTED')
      L = 0
      DO
         READ(UNIT, ERR=10, END=10) CH
         IF (CH==NEW_LINE('A')) L = L + 1
      ENDDO
   ENDSELECT
   10 REWIND(UNIT)
   IF (L>0) THEN
      ALLOCATE(LINES(1:L))
      L = 1
      IOSTAT_ = 0
      DO
         CALL LINES(L)%READ_LINE(UNIT=UNIT, FORM=FORM, IOSTAT=IOSTAT_, IOMSG=IOMSG_)
         IF ((IOSTAT_/=0.AND..NOT.IS_IOSTAT_EOR(IOSTAT_)).OR.(L>=SIZE(LINES, DIM=1))) THEN
            EXIT
         ENDIF
         L = L + 1
      ENDDO
   ENDIF
   IF (PRESENT(IOSTAT)) IOSTAT = IOSTAT_
   IF (PRESENT(IOMSG)) IOMSG = IOMSG_
   ENDSUBROUTINE READ_LINES

   SUBROUTINE WRITE_FILE(FILE, LINES, FORM, IOSTAT, IOMSG)
   !< WRITE A SINGLE STRING STREAM INTO FILE.
   !<
   !< @NOTE FOR UNFORMATTED READ ONLY `ACCESS='STREAM'` IS SUPPORTED WITH NEW_LINE AS LINE TERMINATOR.
   !<
   !<```FORTRAN
   !< TYPE(STRING)              :: ASTRING
   !< TYPE(STRING)              :: ANOTHERSTRING
   !< TYPE(STRING), ALLOCATABLE :: STRINGS(:)
   !< TYPE(STRING)              :: LINE(3)
   !< INTEGER                   :: IOSTAT
   !< CHARACTER(LEN=99)         :: IOMSG
   !< INTEGER                   :: SCRATCH
   !< INTEGER                   :: L
   !< LOGICAL                   :: TEST_PASSED(8)
   !< LINE(1) = ' HELLO WORLD!   '
   !< LINE(2) = 'HOW ARE YOU?  '
   !< LINE(3) = '   ALL SAY: "FINE THANKS"'
   !< ANOTHERSTRING = ANOTHERSTRING%JOIN(ARRAY=LINE, SEP=NEW_LINE('A'))
   !< CALL WRITE_FILE(FILE='WRITE_FILE_TEST.TMP', LINES=LINE, IOSTAT=IOSTAT, IOMSG=IOMSG)
   !< CALL ASTRING%READ_FILE(FILE='WRITE_FILE_TEST.TMP', IOSTAT=IOSTAT, IOMSG=IOMSG)
   !< CALL ASTRING%SPLIT(TOKENS=STRINGS, SEP=NEW_LINE('A'))
   !< TEST_PASSED(1) = (SIZE(STRINGS, DIM=1)==SIZE(LINE, DIM=1))
   !< DO L=1, SIZE(STRINGS, DIM=1)
   !<   TEST_PASSED(L+1) = (STRINGS(L)==LINE(L))
   !< ENDDO
   !< CALL WRITE_FILE(FILE='WRITE_FILE_TEST.TMP', LINES=LINE, FORM='UNFORMATTED', IOSTAT=IOSTAT, IOMSG=IOMSG)
   !< CALL ASTRING%READ_FILE(FILE='WRITE_FILE_TEST.TMP', FORM='UNFORMATTED', IOSTAT=IOSTAT, IOMSG=IOMSG)
   !< CALL ASTRING%SPLIT(TOKENS=STRINGS, SEP=NEW_LINE('A'))
   !< TEST_PASSED(5) = (SIZE(STRINGS, DIM=1)==SIZE(LINE, DIM=1))
   !< DO L=1, SIZE(STRINGS, DIM=1)
   !<   TEST_PASSED(L+5) = (STRINGS(L)==LINE(L))
   !< ENDDO
   !< OPEN(NEWUNIT=SCRATCH, FILE='WRITE_FILE_TEST.TMP')
   !< CLOSE(SCRATCH, STATUS='DELETE')
   !< PRINT '(L1)', ALL(TEST_PASSED)
   !<```
   !=> T <<<
   CHARACTER(LEN=*), INTENT(IN)              :: FILE      !< FILE NAME.
   TYPE(STRING),     INTENT(IN)              :: LINES(1:) !< THE LINES.
   CHARACTER(LEN=*), INTENT(IN),    OPTIONAL :: FORM      !< FORMAT OF UNIT.
   INTEGER,          INTENT(OUT),   OPTIONAL :: IOSTAT    !< IO STATUS CODE.
   CHARACTER(LEN=*), INTENT(INOUT), OPTIONAL :: IOMSG     !< IO STATUS MESSAGE.
   TYPE(STRING)                              :: FORM_     !< FORMAT OF UNIT, LOCAL VARIABLE.
   INTEGER                                   :: IOSTAT_   !< IO STATUS CODE, LOCAL VARIABLE.
   CHARACTER(LEN=:), ALLOCATABLE             :: IOMSG_    !< IO STATUS MESSAGE, LOCAL VARIABLE.
   INTEGER                                   :: UNIT      !< LOGICAL UNIT.

   IOMSG_ = REPEAT(' ', 99) ; IF (PRESENT(IOMSG)) IOMSG_ = IOMSG
   FORM_ = 'FORMATTED' ; IF (PRESENT(FORM)) FORM_ = FORM ; FORM_ = FORM_%UPPER()
   SELECT CASE(FORM_%CHARS())
   CASE('FORMATTED')
      OPEN(NEWUNIT=UNIT, FILE=FILE, ACTION='WRITE', IOMSG=IOMSG_, IOSTAT=IOSTAT_, ERR=10)
   CASE('UNFORMATTED')
      OPEN(NEWUNIT=UNIT, FILE=FILE, ACTION='WRITE', FORM='UNFORMATTED', ACCESS='STREAM', IOMSG=IOMSG_, IOSTAT=IOSTAT_, ERR=10)
   ENDSELECT
   CALL WRITE_LINES(UNIT=UNIT, LINES=LINES, FORM=FORM, IOMSG=IOMSG_, IOSTAT=IOSTAT_)
   10 CLOSE(UNIT)
   IF (PRESENT(IOSTAT)) IOSTAT = IOSTAT_
   IF (PRESENT(IOMSG)) IOMSG = IOMSG_
   ENDSUBROUTINE WRITE_FILE

   SUBROUTINE WRITE_LINES(UNIT, LINES, FORM, IOSTAT, IOMSG)
   !< WRITE LINES (RECORDS) TO A CONNECTED-FORMATTED UNIT.
   !<
   !< @NOTE THERE IS NO DOCTESTS, THIS BEING TESTED BY MEANS OF [[WRITE_FILE]] DOCTESTS.
   INTEGER,          INTENT(IN)              :: UNIT      !< LOGICAL UNIT.
   TYPE(STRING),     INTENT(IN)              :: LINES(1:) !< THE LINES.
   CHARACTER(LEN=*), INTENT(IN),    OPTIONAL :: FORM      !< FORMAT OF UNIT.
   INTEGER,          INTENT(OUT),   OPTIONAL :: IOSTAT    !< IO STATUS CODE.
   CHARACTER(LEN=*), INTENT(INOUT), OPTIONAL :: IOMSG     !< IO STATUS MESSAGE.
   INTEGER                                   :: L         !< COUNTER.

   DO L=1, SIZE(LINES, DIM=1)
      CALL LINES(L)%WRITE_LINE(UNIT=UNIT, FORM=FORM, IOSTAT=IOSTAT, IOMSG=IOMSG)
   ENDDO
   ENDSUBROUTINE WRITE_LINES
ENDMODULE STRINGIFOR





!< FOXY XML TAG CLASS.
MODULE FOXY_XML_TAG
!< FOXY XML TAG CLASS.
USE PENF
USE STRINGIFOR

IMPLICIT NONE
PRIVATE
PUBLIC :: XML_TAG

TYPE :: XML_TAG
  !< XML TAG CLASS.
  !<
  !< A VALID XML TAG MUST HAVE THE FOLLOWING SYNTAX FOR A TAG WITHOUT A CONTENT (WITH ONLY ATTRIBUTES):
  !<```XML
  !<   <TAG_NAME ATT#1_NAME="ATT#1_VAL" ATT#2_NAME="ATT#2_VAL"... ATT#NT_NAME="ATT#NT_VAL"/>
  !<```
  !< WHILE A TAG WITH A CONTENT MUST HAVE THE FOLLOWING SYNTAX:
  !<```XML
  !<   <TAG_NAME ATT#1_NAME="ATT#1_VAL" ATT#2_NAME="ATT#2_VAL"... ATT#NT_NAME="ATT#NT_VAL">TAG_CONTENT</TAG_NAME>
  !<```
  !<
  !< IT IS WORTH NOTING THAT THE SYNTAX IS CASE SENSITIVE AND THAT THE ATTRIBUTES ARE OPTIONAL. EACH ATTRIBUTE NAME MUST BE FOLLOWED
  !< BY '="' WITHOUT ANY ADDITIONAL WHITE SPACES AND ITS VALUE MUST BE TERMINED BY '"'. EACH ATTRIBUTE IS SEPARATED BY ONE OR MORE
  !< WHITE SPACES.
  PRIVATE
  TYPE(STRING)              :: TAG_NAME                !< TAG NAME.
  TYPE(STRING)              :: TAG_CONTENT             !< TAG CONTENT.
  TYPE(STRING), ALLOCATABLE :: ATTRIBUTE(:,:)          !< ATTRIBUTES NAMES/VALUES PAIRS, [1:2, 1:].
  INTEGER(I4P)              :: ATTRIBUTES_NUMBER=0     !< NUMBER OF DEFINED ATTRIBUTES.
  INTEGER(I4P)              :: INDENT=0                !< NUMBER OF INDENT-WHITE-SPACES.
  LOGICAL                   :: IS_SELF_CLOSING=.FALSE. !< SELF CLOSING TAG FLAG.
  CONTAINS
    ! PUBLIC METHODS
    GENERIC               :: ADD_ATTRIBUTES =>        &
                             ADD_SINGLE_ATTRIBUTE,    &
                             ADD_MULTIPLE_ATTRIBUTES, &
                             ADD_STREAM_ATTRIBUTES       !< ADD ATTRIBUTES NAME/VALUE PAIRS.
    PROCEDURE, PASS(SELF) :: ATTRIBUTES                  !< RETURN ATTRIBUTES NAME/VALUE PAIRS AS STRING.
    PROCEDURE, PASS(SELF) :: GET_CONTENT                 !< RETURN TAG CONTENT.
    GENERIC               :: DELETE_ATTRIBUTES =>     &
                             DELETE_SINGLE_ATTRIBUTE, &
                             DELETE_MULTIPLE_ATTRIBUTES  !< DELETE ATTRIBUTES NAME/VALUE PAIRS.
    PROCEDURE, PASS(SELF) :: DELETE_CONTENT              !< DELETE TAG CONENT.
    PROCEDURE, PASS(SELF) :: END_TAG                     !< RETURN `</TAG_NAME>` END TAG.
    PROCEDURE, PASS(SELF) :: CUSTOMFREE                        !< FREE DYNAMIC MEMORY.
    PROCEDURE, PASS(SELF) :: IS_ATTRIBUTE_PRESENT        !< RETURN .TRUE. IT THE QUERIED ATTRIBUTE NAME IS DEFINED.
    PROCEDURE, PASS(SELF) :: IS_PARSED                   !< CHECK IS TAG IS CORRECTLY PARSED, I.E. ITS *TAG_NAME* IS ALLOCATED.
    PROCEDURE, PASS(SELF) :: NAME                        !< RETURN TAG NAME.
    PROCEDURE, PASS(SELF) :: PARSE                       !< PARSE THE TAG CONTAINED INTO A SOURCE STRING.
    PROCEDURE, PASS(SELF) :: SELF_CLOSING_TAG            !< RETURN `<TAG_NAME.../>` SELF CLOSING TAG.
    PROCEDURE, PASS(SELF) :: SET                         !< SET TAG DATA.
    PROCEDURE, PASS(SELF) :: START_TAG                   !< RETURN `<TAG_NAME...>` START TAG.
    PROCEDURE, PASS(SELF) :: STRINGIFY                   !< CONVERT THE WHOLE TAG INTO A STRING.
    PROCEDURE, PASS(SELF) :: WRITE => WRITE_TAG          !< WRITE TAG TO UNIT FILE.
    GENERIC               :: ASSIGNMENT(=) => ASSIGN_TAG !< ASSIGNMENT OPERATOR OVERLOADING.
    ! PRIVATE METHODS
    PROCEDURE, PASS(SELF), PRIVATE :: ADD_SINGLE_ATTRIBUTE       !< ADD ONE ATTRIBUTE NAME/VALUE PAIR.
    PROCEDURE, PASS(SELF), PRIVATE :: ADD_MULTIPLE_ATTRIBUTES    !< ADD LIST OF ATTRIBUTES NAME/VALUE PAIRS.
    PROCEDURE, PASS(SELF), PRIVATE :: ADD_STREAM_ATTRIBUTES      !< ADD LIST OF ATTRIBUTES NAME/VALUE PAIRS PASSED AS STREAM.
    PROCEDURE, PASS(SELF), PRIVATE :: ALLOC_ATTRIBUTES           !< ALLOCATE (PREPARE FOR FILLING) DYNAMIC MEMORY OF ATTRIBUTES.
    PROCEDURE, PASS(SELF), PRIVATE :: DELETE_SINGLE_ATTRIBUTE    !< DELETE ONE ATTRIBUTE NAME/VALUE PAIR.
    PROCEDURE, PASS(SELF), PRIVATE :: DELETE_MULTIPLE_ATTRIBUTES !< DELETE LIST OF ATTRIBUTES NAME/VALUE PAIRS.
    PROCEDURE, PASS(SELF), PRIVATE :: GET                        !< GET THE TAG VALUE AND ATTRIBUTES FROM SOURCE.
    PROCEDURE, PASS(SELF), PRIVATE :: GET_VALUE                  !< GET THE TAG VALUE FROM SOURCE AFTER TAG_NAME HAS BEEN SET.
    PROCEDURE, PASS(SELF), PRIVATE :: GET_ATTRIBUTES             !< GET THE ATTRIBUTES VALUES FROM SOURCE.
    PROCEDURE, PASS(SELF), PRIVATE :: PARSE_TAG_NAME             !< PARSE THE TAG NAME CONTAINED INTO A STRING.
    PROCEDURE, PASS(SELF), PRIVATE :: PARSE_ATTRIBUTES_NAMES     !< PARSE THE TAG ATTRIBUTES NAMES CONTAINED INTO A STRING.
    PROCEDURE, PASS(SELF), PRIVATE :: SEARCH                     !< SEARCH TAG NAMED *TAG_NAME* INTO A STRING.
    ! OPERATORS
    PROCEDURE, PASS(LHS), PRIVATE :: ASSIGN_TAG !< ASSIGNMENT BETWEEN TWO TAGS.
#if (__GNUC__ < 9)
    FINAL                         :: FINALIZE   !< FREE DYNAMIC MEMORY WHEN FINALIZING.
#endif
ENDTYPE XML_TAG

INTERFACE XML_TAG
  !< OVERLOAD *XML_TAG* WITH CREATOR PROCEDURES.
  MODULE PROCEDURE CREATE_TAG_FLAT, CREATE_TAG_NESTED
ENDINTERFACE
CONTAINS
  ! CREATOR PROCEDURES OVERLOADING *XML_TAG* NAME
  PURE FUNCTION CREATE_TAG_FLAT(NAME, ATTRIBUTE, ATTRIBUTES, ATTRIBUTES_STREAM, SANITIZE_ATTRIBUTES_VALUE, CONTENT, INDENT, &
                                IS_CONTENT_INDENTED, IS_SELF_CLOSING) RESULT(TAG)
  !< RETURN AN INSTANCE OF XML TAG.
  !<
  !< ATTRIBUTES ARE PASSED BY ARRAY.
  CHARACTER(*), INTENT(IN)           :: NAME                      !< TAG NAME.
  CHARACTER(*), INTENT(IN), OPTIONAL :: ATTRIBUTE(1:)             !< ATTRIBUTE NAME/VALUE PAIR [1:2].
  CHARACTER(*), INTENT(IN), OPTIONAL :: ATTRIBUTES(1:,1:)         !< ATTRIBUTES LIST OF NAME/VALUE PAIRS [1:2,1:].
  CHARACTER(*), INTENT(IN), OPTIONAL :: ATTRIBUTES_STREAM         !< ATTRIBUTES LIST OF NAME/VALUE PAIRS AS SINGLE STREAM.
  LOGICAL,      INTENT(IN), OPTIONAL :: SANITIZE_ATTRIBUTES_VALUE !< SANITIZE ATTRIBUTES VALUE.
  CHARACTER(*), INTENT(IN), OPTIONAL :: CONTENT                   !< TAG VALUE.
  INTEGER(I4P), INTENT(IN), OPTIONAL :: INDENT                    !< NUMBER OF INDENT-WHITE-SPACES.
  LOGICAL,      INTENT(IN), OPTIONAL :: IS_CONTENT_INDENTED       !< ACTIVATE CONTENT INDENTATION.
  LOGICAL,      INTENT(IN), OPTIONAL :: IS_SELF_CLOSING           !< THE TAG IS SELF CLOSING.
  TYPE(XML_TAG)                      :: TAG                       !< XML TAG.

  CALL TAG%SET(NAME=NAME, ATTRIBUTE=ATTRIBUTE, ATTRIBUTES=ATTRIBUTES, ATTRIBUTES_STREAM=ATTRIBUTES_STREAM, &
               SANITIZE_ATTRIBUTES_VALUE=SANITIZE_ATTRIBUTES_VALUE, CONTENT=CONTENT,                       &
               INDENT=INDENT, IS_CONTENT_INDENTED=IS_CONTENT_INDENTED, IS_SELF_CLOSING=IS_SELF_CLOSING)
  ENDFUNCTION CREATE_TAG_FLAT

  PURE FUNCTION CREATE_TAG_NESTED(NAME, CONTENT, ATTRIBUTE, ATTRIBUTES, ATTRIBUTES_STREAM, SANITIZE_ATTRIBUTES_VALUE, INDENT, &
                                  IS_CONTENT_INDENTED) RESULT(TAG)
  !< RETURN AN INSTANCE OF XML TAG WITH VALUE BEING A NESTED TAG.
  !<
  !< ATTRIBUTES ARE PASSED BY ARRAY.
  CHARACTER(*),  INTENT(IN)           :: NAME                      !< TAG NAME.
  TYPE(XML_TAG), INTENT(IN)           :: CONTENT                   !< TAG VALUE AS NESTED TAG..
  CHARACTER(*),  INTENT(IN), OPTIONAL :: ATTRIBUTE(1:)             !< ATTRIBUTE NAME/VALUE PAIR [1:2].
  CHARACTER(*),  INTENT(IN), OPTIONAL :: ATTRIBUTES(1:,1:)         !< ATTRIBUTES LIST OF NAME/VALUE PAIRS [1:2,1:].
  CHARACTER(*),  INTENT(IN), OPTIONAL :: ATTRIBUTES_STREAM         !< ATTRIBUTES LIST OF NAME/VALUE PAIRS AS SINGLE STREAM.
  LOGICAL,       INTENT(IN), OPTIONAL :: SANITIZE_ATTRIBUTES_VALUE !< SANITIZE ATTRIBUTES VALUE.
  INTEGER(I4P),  INTENT(IN), OPTIONAL :: INDENT                    !< NUMBER OF INDENT-WHITE-SPACES.
  LOGICAL,       INTENT(IN), OPTIONAL :: IS_CONTENT_INDENTED       !< ACTIVATE VALUE INDENTATION.
  TYPE(XML_TAG)                       :: TAG                       !< XML TAG.

  CALL TAG%SET(NAME=NAME, ATTRIBUTE=ATTRIBUTE, ATTRIBUTES=ATTRIBUTES, CONTENT=CONTENT%STRINGIFY(),                      &
               SANITIZE_ATTRIBUTES_VALUE=SANITIZE_ATTRIBUTES_VALUE, ATTRIBUTES_STREAM=ATTRIBUTES_STREAM, INDENT=INDENT, &
               IS_CONTENT_INDENTED=IS_CONTENT_INDENTED)
  ENDFUNCTION CREATE_TAG_NESTED

  ! PUBLIC METHODS
  PURE FUNCTION ATTRIBUTES(SELF) RESULT(ATT_)
  !< RETURN ATTRIBUTES NAME/VALUE PAIRS AS STRING.
  CLASS(XML_TAG), INTENT(IN)    :: SELF !< XML TAG.
  CHARACTER(LEN=:), ALLOCATABLE :: ATT_ !< THE ATTRIBUTES STRING.
  INTEGER(I4P)                  :: A    !< COUNTER.

  IF (SELF%ATTRIBUTES_NUMBER>0) THEN
    ATT_ = ''
    DO A=1, SELF%ATTRIBUTES_NUMBER
      ATT_ = ATT_//' '//SELF%ATTRIBUTE(1, A)//'="'//SELF%ATTRIBUTE(2, A)//'"'
    ENDDO
    ATT_ = TRIM(ADJUSTL(ATT_))
  ENDIF
  ENDFUNCTION ATTRIBUTES

  PURE SUBROUTINE GET_CONTENT(SELF, NAME, CONTENT)
  !< RETURN TAG CONTENT OF SELF (OR ITS NESTED TAGS) IF NAMED *NAME*.
  !<
  !< @NOTE IF THERE IS NO VALUE, THE *CONTENT* STRING IS RETURNED DEALLOCATED.
  CLASS(XML_TAG),                INTENT(IN)  :: SELF    !< XML TAG.
  CHARACTER(*),                  INTENT(IN)  :: NAME    !< SEARCHED TAG NAME.
  CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT) :: CONTENT !< TAG CONTENT.
  TYPE(XML_TAG)                              :: TAG     !< DUMMY XML TAG.

  IF (ALLOCATED(CONTENT)) DEALLOCATE(CONTENT)
  IF (SELF%TAG_NAME%IS_ALLOCATED()) THEN
    IF (SELF%TAG_NAME==NAME) THEN
      IF (SELF%TAG_CONTENT%IS_ALLOCATED()) CONTENT = SELF%TAG_CONTENT%CHARS()
    ELSE
      IF (SELF%TAG_CONTENT%IS_ALLOCATED()) THEN
        CALL TAG%SEARCH(TAG_NAME=NAME, SOURCE=SELF%TAG_CONTENT%CHARS())
        IF (TAG%TAG_CONTENT%IS_ALLOCATED()) CONTENT = TAG%TAG_CONTENT%CHARS()
      ENDIF
    ENDIF
  ENDIF
  ENDSUBROUTINE GET_CONTENT

  PURE FUNCTION END_TAG(SELF, IS_INDENTED) RESULT(TAG_)
  !< RETURN `</TAG_NAME>` END TAG.
  CLASS(XML_TAG), INTENT(IN)           :: SELF        !< XML TAG.
  LOGICAL,        INTENT(IN), OPTIONAL :: IS_INDENTED !< ACTIVATE CONTENT INDENTATION.
  CHARACTER(LEN=:), ALLOCATABLE        :: TAG_        !< THE END TAG STRING.

  TAG_ = '</'//SELF%TAG_NAME//'>'
  IF (PRESENT(IS_INDENTED)) THEN
    IF (IS_INDENTED) TAG_ = REPEAT(' ', SELF%INDENT)//TAG_
  ENDIF
  ENDFUNCTION END_TAG

  ELEMENTAL SUBROUTINE CUSTOMFREE(SELF)
  !< FREE DYNAMIC MEMORY.
  CLASS(XML_TAG), INTENT(INOUT) :: SELF !< XML TAG.

  CALL SELF%TAG_NAME%CUSTOMFREE
  CALL SELF%TAG_CONTENT%CUSTOMFREE
  IF (ALLOCATED(SELF%ATTRIBUTE)) THEN
    CALL SELF%ATTRIBUTE%CUSTOMFREE
    DEALLOCATE(SELF%ATTRIBUTE)
  ENDIF
  SELF%ATTRIBUTES_NUMBER = 0
  SELF%INDENT = 0
  SELF%IS_SELF_CLOSING = .FALSE.
  ENDSUBROUTINE CUSTOMFREE

  ELEMENTAL FUNCTION IS_PARSED(SELF)
  !< CHECK IS TAG IS CORRECTLY PARSED, I.E. ITS *TAG_NAME* IS ALLOCATED.
  CLASS(XML_TAG), INTENT(IN) :: SELF      !< XML TAG.
  LOGICAL                    :: IS_PARSED !< RESULT OF CHECK.

  IS_PARSED = SELF%TAG_NAME%IS_ALLOCATED()
  ENDFUNCTION IS_PARSED

  PURE FUNCTION NAME(SELF)
  !< RETURN TAG NAME.
  CLASS(XML_TAG), INTENT(IN)    :: SELF !< XML TAG.
  CHARACTER(LEN=:), ALLOCATABLE :: NAME !< XML TAG NAME.

  NAME = SELF%TAG_NAME%CHARS()
  ENDFUNCTION NAME

  ELEMENTAL SUBROUTINE PARSE(SELF, SOURCE, TSTART, TEND)
  !< PARSE THE TAG CONTAINED INTO A SOURCE STRING.
  !<
  !< IT IS ASSUMED THAT THE FIRST TAG CONTAINED INTO THE SOURCE STRING IS PARSED, THE OTHERS EVENTUALLY PRESENT ARE OMITTED.
  !< VALID SYNTAX ARE:
  !< + `<TAG_NAME ATT1="ATT1 VAL" ATT2="ATT2 VAL"...>...</TAG_NAME>`
  !< + `<TAG_NAME ATT1="ATT1 VAL" ATT2="ATT2 VAL".../>`
  !< @NOTE INSIDE THE ATTRIBUTES VALUE THE SYMBOLS `<` AND `>` ARE NOT ALLOWED.
  CLASS(XML_TAG),         INTENT(INOUT) :: SELF      !< XML TAG.
  CHARACTER(*),           INTENT(IN)    :: SOURCE    !< STRING CONTAINING THE INPUT.
  INTEGER(I4P), OPTIONAL, INTENT(OUT)   :: TSTART    !< STARTING INDEX OF TAG INSIDE THE STRING.
  INTEGER(I4P), OPTIONAL, INTENT(OUT)   :: TEND      !< ENDING INDEX OF TAG INSIDE THE STRING.
  INTEGER(I4P)                          :: TSTARTD   !< STARTING INDEX OF TAG INSIDE THE STRING.
  INTEGER(I4P)                          :: TENDD     !< ENDING INDEX OF TAG INSIDE THE STRING.

  TSTARTD = 0
  TENDD   = 0
  CALL SELF%PARSE_TAG_NAME(SOURCE=SOURCE, TSTART=TSTARTD, TEND=TENDD)
  IF (SELF%TAG_NAME%IS_ALLOCATED()) THEN
    IF (INDEX(STRING=SOURCE(TSTARTD:TENDD), SUBSTRING='=')>0) CALL SELF%PARSE_ATTRIBUTES_NAMES(SOURCE=SOURCE(TSTARTD:TENDD))
    IF (INDEX(STRING=SOURCE, SUBSTRING='</'//SELF%TAG_NAME//'>')>0) &
      TENDD = INDEX(STRING=SOURCE, SUBSTRING='</'//SELF%TAG_NAME//'>') + LEN('</'//SELF%TAG_NAME//'>') - 1
    CALL SELF%GET(SOURCE=SOURCE(TSTARTD:TENDD))
  ENDIF
  IF (PRESENT(TSTART)) TSTART = TSTARTD
  IF (PRESENT(TEND  )) TEND   = TENDD
  ENDSUBROUTINE PARSE

  PURE SUBROUTINE SET(SELF, NAME, ATTRIBUTE, ATTRIBUTES, ATTRIBUTES_STREAM, SANITIZE_ATTRIBUTES_VALUE, CONTENT, &
                      INDENT, IS_CONTENT_INDENTED, IS_SELF_CLOSING)
  !< SET TAG DATA.
  CLASS(XML_TAG), INTENT(INOUT)        :: SELF                      !< XML TAG.
  CHARACTER(*),   INTENT(IN), OPTIONAL :: NAME                      !< TAG NAME.
  CHARACTER(*),   INTENT(IN), OPTIONAL :: ATTRIBUTE(1:)             !< ATTRIBUTE NAME/VALUE PAIR [1:2].
  CHARACTER(*),   INTENT(IN), OPTIONAL :: ATTRIBUTES(1:,1:)         !< ATTRIBUTES LIST OF NAME/VALUE PAIRS [1:2,1:].
  CHARACTER(*),   INTENT(IN), OPTIONAL :: ATTRIBUTES_STREAM         !< ATTRIBUTES LIST OF NAME/VALUE PAIRS AS SINGLE STREAM.
  LOGICAL,        INTENT(IN), OPTIONAL :: SANITIZE_ATTRIBUTES_VALUE !< SANITIZE ATTRIBUTES VALUE.
  CHARACTER(*),   INTENT(IN), OPTIONAL :: CONTENT                   !< TAG VALUE.
  INTEGER(I4P),   INTENT(IN), OPTIONAL :: INDENT                    !< NUMBER OF INDENT-WHITE-SPACES.
  LOGICAL,        INTENT(IN), OPTIONAL :: IS_CONTENT_INDENTED       !< ACTIVATE VALUE INDENTATION.
  LOGICAL,        INTENT(IN), OPTIONAL :: IS_SELF_CLOSING           !< THE TAG IS SELF CLOSING.
  LOGICAL                              :: IS_CONTENT_INDENTED_      !< ACTIVATE VALUE INDENTATION.

  IF (PRESENT(NAME)) SELF%TAG_NAME = NAME
  IF (PRESENT(ATTRIBUTE)) CALL SELF%ADD_SINGLE_ATTRIBUTE(ATTRIBUTE=ATTRIBUTE, SANITIZE_VALUE=SANITIZE_ATTRIBUTES_VALUE)
  IF (PRESENT(ATTRIBUTES)) CALL SELF%ADD_MULTIPLE_ATTRIBUTES(ATTRIBUTES=ATTRIBUTES, SANITIZE_VALUES=SANITIZE_ATTRIBUTES_VALUE)
  IF (PRESENT(ATTRIBUTES_STREAM)) CALL SELF%ADD_STREAM_ATTRIBUTES(ATTRIBUTES_STREAM=ATTRIBUTES_STREAM, &
                                                                  SANITIZE_VALUES=SANITIZE_ATTRIBUTES_VALUE)
  IF (PRESENT(INDENT)) SELF%INDENT = INDENT
  IF (PRESENT(CONTENT)) THEN
    IS_CONTENT_INDENTED_ = .FALSE. ; IF (PRESENT(IS_CONTENT_INDENTED)) IS_CONTENT_INDENTED_ = IS_CONTENT_INDENTED
    IF (IS_CONTENT_INDENTED_) THEN
      SELF%TAG_CONTENT = NEW_LINE('A')//REPEAT(' ', SELF%INDENT+2)//CONTENT//NEW_LINE('A')
    ELSE
      SELF%TAG_CONTENT = CONTENT
    ENDIF
  ENDIF
  IF (PRESENT(IS_SELF_CLOSING)) SELF%IS_SELF_CLOSING = IS_SELF_CLOSING
  ENDSUBROUTINE SET

  PURE FUNCTION SELF_CLOSING_TAG(SELF, IS_INDENTED) RESULT(TAG_)
  !< RETURN `<TAG_NAME.../>` SELF CLOSING TAG.
  CLASS(XML_TAG), INTENT(IN)           :: SELF        !< XML TAG.
  LOGICAL,        INTENT(IN), OPTIONAL :: IS_INDENTED !< FLAG TO CHECK IF TAG IS INDENTED.
  CHARACTER(LEN=:), ALLOCATABLE        :: TAG_        !< THE SELF CLOSING TAG STRING.

  TAG_ = '<'//SELF%TAG_NAME
  IF (SELF%ATTRIBUTES_NUMBER>0) TAG_ = TAG_//' '//SELF%ATTRIBUTES()
  TAG_ = TAG_//'/>'
  IF (PRESENT(IS_INDENTED)) THEN
    IF (IS_INDENTED) TAG_ = REPEAT(' ', SELF%INDENT)//TAG_
  ENDIF
  ENDFUNCTION SELF_CLOSING_TAG

  PURE FUNCTION START_TAG(SELF, IS_INDENTED) RESULT(TAG_)
  !< RETURN `<TAG_NAME...>` START TAG.
  CLASS(XML_TAG), INTENT(IN)           :: SELF        !< XML TAG.
  LOGICAL,        INTENT(IN), OPTIONAL :: IS_INDENTED !< FLAG TO CHECK IF TAG IS INDENTED.
  CHARACTER(LEN=:), ALLOCATABLE        :: TAG_        !< THE START TAG STRING.

  TAG_ = '<'//SELF%TAG_NAME
  IF (SELF%ATTRIBUTES_NUMBER>0) TAG_ = TAG_//' '//SELF%ATTRIBUTES()
  TAG_ = TAG_//'>'
  IF (PRESENT(IS_INDENTED)) THEN
    IF (IS_INDENTED) TAG_ = REPEAT(' ', SELF%INDENT)//TAG_
  ENDIF
  ENDFUNCTION START_TAG

  PURE FUNCTION STRINGIFY(SELF, IS_INDENTED, IS_CONTENT_INDENTED, ONLY_START, ONLY_CONTENT, ONLY_END) RESULT(STRINGED)
  !< CONVERT THE WHOLE TAG INTO A STRING.
  CLASS(XML_TAG), INTENT(IN)           :: SELF                 !< XML TAG.
  LOGICAL,        INTENT(IN), OPTIONAL :: IS_INDENTED          !< ACTIVATE CONTENT INDENTATION.
  LOGICAL,        INTENT(IN), OPTIONAL :: IS_CONTENT_INDENTED  !< ACTIVATE CONTENT INDENTATION.
  LOGICAL,        INTENT(IN), OPTIONAL :: ONLY_START           !< WRITE ONLY START TAG.
  LOGICAL,        INTENT(IN), OPTIONAL :: ONLY_CONTENT         !< WRITE ONLY CONTENT.
  LOGICAL,        INTENT(IN), OPTIONAL :: ONLY_END             !< WRITE ONLY END TAG.
  CHARACTER(LEN=:), ALLOCATABLE        :: STRINGED             !< OUTPUT STRING CONTAINING THE WHOLE TAG.
  LOGICAL                              :: IS_CONTENT_INDENTED_ !< ACTIVATE CONTENT INDENTATION.
  LOGICAL                              :: ONLY_START_          !< WRITE ONLY START TAG.
  LOGICAL                              :: ONLY_CONTENT_        !< WRITE ONLY CONTENT.
  LOGICAL                              :: ONLY_END_            !< WRITE ONLY END TAG.

  IS_CONTENT_INDENTED_ = .FALSE. ; IF (PRESENT(IS_CONTENT_INDENTED)) IS_CONTENT_INDENTED_ = IS_CONTENT_INDENTED
  ONLY_START_ = .FALSE. ; IF (PRESENT(ONLY_START)) ONLY_START_ = ONLY_START
  ONLY_CONTENT_ = .FALSE. ; IF (PRESENT(ONLY_CONTENT)) ONLY_CONTENT_ = ONLY_CONTENT
  ONLY_END_ = .FALSE. ; IF (PRESENT(ONLY_END)) ONLY_END_ = ONLY_END
  IF (ONLY_START_) THEN
    STRINGED = SELF%START_TAG(IS_INDENTED=IS_INDENTED)
  ELSEIF (ONLY_CONTENT_) THEN
    IF (SELF%TAG_CONTENT%IS_ALLOCATED()) THEN
      IF (IS_CONTENT_INDENTED_) THEN
        STRINGED = REPEAT(' ', SELF%INDENT+2)//SELF%TAG_CONTENT
      ELSE
        STRINGED = SELF%TAG_CONTENT%CHARS()
      ENDIF
    ENDIF
  ELSEIF (ONLY_END_) THEN
    STRINGED = SELF%END_TAG(IS_INDENTED=IS_INDENTED)
  ELSE
    STRINGED = ''
    IF (SELF%TAG_NAME%IS_ALLOCATED()) THEN
      IF (SELF%IS_SELF_CLOSING) THEN
        STRINGED = SELF%SELF_CLOSING_TAG(IS_INDENTED=IS_INDENTED)
      ELSE
        STRINGED = SELF%START_TAG(IS_INDENTED=IS_INDENTED)
        IF (SELF%TAG_CONTENT%IS_ALLOCATED()) THEN
          IF (IS_CONTENT_INDENTED_) THEN
            STRINGED = STRINGED//NEW_LINE('A')//REPEAT(' ', SELF%INDENT+2)//&
                       SELF%TAG_CONTENT//NEW_LINE('A')//REPEAT(' ', SELF%INDENT)
          ELSE
            STRINGED = STRINGED//SELF%TAG_CONTENT
          ENDIF
        ENDIF
        STRINGED = STRINGED//SELF%END_TAG()
      ENDIF
    ENDIF
  ENDIF
  ENDFUNCTION STRINGIFY

  SUBROUTINE WRITE_TAG(SELF, UNIT, IS_INDENTED, IS_CONTENT_INDENTED, FORM, END_RECORD, ONLY_START, ONLY_CONTENT, ONLY_END, &
                       IOSTAT, IOMSG)
  !< WRITE TAG TO UNIT FILE.
  CLASS(XML_TAG), INTENT(IN)            :: SELF                !< XML TAG.
  INTEGER(I4P),   INTENT(IN)            :: UNIT                !< FILE UNIT.
  LOGICAL,        INTENT(IN),  OPTIONAL :: IS_INDENTED         !< ACTIVATE CONTENT INDENTATION.
  LOGICAL,        INTENT(IN),  OPTIONAL :: IS_CONTENT_INDENTED !< ACTIVATE CONTENT INDENTATION.
  CHARACTER(*),   INTENT(IN),  OPTIONAL :: FORM                !< FORMAT.
  CHARACTER(*),   INTENT(IN),  OPTIONAL :: END_RECORD          !< ENDING RECORD.
  LOGICAL,        INTENT(IN),  OPTIONAL :: ONLY_START          !< WRITE ONLY START TAG.
  LOGICAL,        INTENT(IN),  OPTIONAL :: ONLY_CONTENT        !< WRITE ONLY CONTENT.
  LOGICAL,        INTENT(IN),  OPTIONAL :: ONLY_END            !< WRITE ONLY END TAG.
  INTEGER(I4P),   INTENT(OUT), OPTIONAL :: IOSTAT              !< IO STATUS.
  CHARACTER(*),   INTENT(OUT), OPTIONAL :: IOMSG               !< IO MESSAGE.
  TYPE(STRING)                          :: FORM_               !< FORMAT.
  TYPE(STRING)                          :: END_RECORD_         !< ENDING RECORD.
  INTEGER(I4P)                          :: IOSTAT_             !< IO STATUS.
  CHARACTER(500)                        :: IOMSG_              !< IO MESSAGE.

  FORM_ = 'UNFORMATTED'
  IF (PRESENT(FORM)) THEN
    FORM_ = FORM
    FORM_ = FORM_%UPPER()
  ENDIF
  END_RECORD_ = '' ; IF (PRESENT(END_RECORD)) END_RECORD_ = END_RECORD
  SELECT CASE(FORM_%CHARS())
  CASE('UNFORMATTED')
    WRITE(UNIT=UNIT, IOSTAT=IOSTAT_, IOMSG=IOMSG_)SELF%STRINGIFY(IS_INDENTED=IS_INDENTED,                 &
                                                                 IS_CONTENT_INDENTED=IS_CONTENT_INDENTED, &
                                                                 ONLY_START=ONLY_START,                   &
                                                                 ONLY_CONTENT=ONLY_CONTENT,               &
                                                                 ONLY_END=ONLY_END)//END_RECORD_
  CASE('FORMATTED')
    WRITE(UNIT=UNIT, FMT='(A)', IOSTAT=IOSTAT_, IOMSG=IOMSG_)SELF%STRINGIFY(IS_INDENTED=IS_INDENTED,                 &
                                                                            IS_CONTENT_INDENTED=IS_CONTENT_INDENTED, &
                                                                            ONLY_START=ONLY_START,                   &
                                                                            ONLY_CONTENT=ONLY_CONTENT,               &
                                                                            ONLY_END=ONLY_END)//END_RECORD_
  ENDSELECT
  IF (PRESENT(IOSTAT)) IOSTAT = IOSTAT_
  IF (PRESENT(IOMSG)) IOMSG = IOMSG_
  ENDSUBROUTINE WRITE_TAG

  ! PRIVATE METHODS
  PURE FUNCTION IS_ATTRIBUTE_PRESENT(SELF, NAME) RESULT(IS_PRESENT)
  !< RETURN .TRUE. IT THE QUERIED ATTRIBUTE NAME IS DEFINED, .FALSE. OTHERWISE.
  CLASS(XML_TAG), INTENT(IN) :: SELF       !< XML TAG.
  CHARACTER(*),   INTENT(IN) :: NAME       !< ATTRIBUTE NAME.
  LOGICAL                    :: IS_PRESENT !< INQUIRE RESULT.
  INTEGER(I4P)               :: A          !< COUNTER.

  IS_PRESENT = .FALSE.
  IF (SELF%ATTRIBUTES_NUMBER>0) THEN
    DO A=1, SELF%ATTRIBUTES_NUMBER
      IF (SELF%ATTRIBUTE(1, A)==NAME) THEN
        IS_PRESENT = .TRUE.
        EXIT
      ENDIF
    ENDDO
  ENDIF
  ENDFUNCTION IS_ATTRIBUTE_PRESENT

  PURE SUBROUTINE ADD_SINGLE_ATTRIBUTE(SELF, ATTRIBUTE, SANITIZE_VALUE)
  !< ADD ONE ATTRIBUTE NAME/VALUE PAIR.
  !<
  !< @NOTE LEADING AND TRAILING WHITE SPACES ARE TRIMMED OUT BY ATTRIBUTE'S NAME.
  CLASS(XML_TAG), INTENT(INOUT)        :: SELF               !< XML TAG.
  CHARACTER(*),   INTENT(IN)           :: ATTRIBUTE(1:)      !< ATTRIBUTE NAME/VALUE PAIR [1:2].
  LOGICAL,        INTENT(IN), OPTIONAL :: SANITIZE_VALUE     !< SANITIZE ATTRIBUTE VALUE.
  TYPE(STRING), ALLOCATABLE            :: NEW_ATTRIBUTE(:,:) !< TEMPORARY STORAGE FOR ATTRIBUTES.
  LOGICAL                              :: SANITIZE_VALUE_    !< SANITIZE ATTRIBUTE VALUE.
  LOGICAL                              :: IS_UPDATED         !< FLAG TO CHECK IF THE ATTRIBUTE HAS BEEN UPDETED.
  INTEGER(I4P)                         :: A                  !< COUNTER.

  SANITIZE_VALUE_ = .FALSE. ; IF (PRESENT(SANITIZE_VALUE)) SANITIZE_VALUE_ = SANITIZE_VALUE
  IF (SELF%ATTRIBUTES_NUMBER>0) THEN
    IS_UPDATED = .FALSE.
    UPDATE_IF_ALREADY_PRESENT: DO A=1, SELF%ATTRIBUTES_NUMBER
      IF (SELF%ATTRIBUTE(1, A)==ATTRIBUTE(1)) THEN
        IF (SANITIZE_VALUE_) THEN
          SELF%ATTRIBUTE(2, A) = TRIM(ADJUSTL(ATTRIBUTE(2)))
        ELSE
          SELF%ATTRIBUTE(2, A) = ATTRIBUTE(2)
        ENDIF
        IS_UPDATED = .TRUE.
        EXIT UPDATE_IF_ALREADY_PRESENT
      ENDIF
    ENDDO UPDATE_IF_ALREADY_PRESENT
    IF (.NOT.IS_UPDATED) THEN
      ALLOCATE(NEW_ATTRIBUTE(1:2, 1:SELF%ATTRIBUTES_NUMBER+1))
      NEW_ATTRIBUTE(1:2, 1:SELF%ATTRIBUTES_NUMBER) = SELF%ATTRIBUTE
      NEW_ATTRIBUTE(1, SELF%ATTRIBUTES_NUMBER+1) = TRIM(ADJUSTL(ATTRIBUTE(1)))
      IF (SANITIZE_VALUE_) THEN
        NEW_ATTRIBUTE(2, SELF%ATTRIBUTES_NUMBER+1) = TRIM(ADJUSTL(ATTRIBUTE(2)))
      ELSE
        NEW_ATTRIBUTE(2, SELF%ATTRIBUTES_NUMBER+1) = ATTRIBUTE(2)
      ENDIF
      CALL MOVE_ALLOC(FROM=NEW_ATTRIBUTE, TO=SELF%ATTRIBUTE)
      SELF%ATTRIBUTES_NUMBER = SELF%ATTRIBUTES_NUMBER + 1
    ENDIF
  ELSE
    CALL SELF%ALLOC_ATTRIBUTES(NA=1)
    SELF%ATTRIBUTE(1, 1) = TRIM(ADJUSTL(ATTRIBUTE(1)))
    IF (SANITIZE_VALUE_) THEN
      SELF%ATTRIBUTE(2, 1) = TRIM(ADJUSTL(ATTRIBUTE(2)))
    ELSE
      SELF%ATTRIBUTE(2, 1) = ATTRIBUTE(2)
    ENDIF
  ENDIF
  ENDSUBROUTINE ADD_SINGLE_ATTRIBUTE

  PURE SUBROUTINE ADD_MULTIPLE_ATTRIBUTES(SELF, ATTRIBUTES, SANITIZE_VALUES)
  !< ADD LIST OF ATTRIBUTES NAME/VALUE PAIRS.
  CLASS(XML_TAG), INTENT(INOUT)        :: SELF              !< XML TAG.
  CHARACTER(*),   INTENT(IN)           :: ATTRIBUTES(1:,1:) !< ATTRIBUTE NAME/VALUE PAIR LIST [1:2,1:].
  LOGICAL,        INTENT(IN), OPTIONAL :: SANITIZE_VALUES   !< SANITIZE ATTRIBUTE VALUES.
  INTEGER(I4P)                         :: A                 !< COUNTER.

  DO A=1, SIZE(ATTRIBUTES, DIM=2)
    ! NOT EFFICIENT: MANY REALLOCATION, BUT SAFE
    CALL SELF%ADD_SINGLE_ATTRIBUTE(ATTRIBUTE=ATTRIBUTES(1:,A), SANITIZE_VALUE=SANITIZE_VALUES)
  ENDDO
  ENDSUBROUTINE ADD_MULTIPLE_ATTRIBUTES

  PURE SUBROUTINE ADD_STREAM_ATTRIBUTES(SELF, ATTRIBUTES_STREAM, SANITIZE_VALUES)
  !< ADD LIST OF ATTRIBUTES NAME/VALUE PAIRS PASSED AS STREAM.
  !<
  !< @NOTE THE CHARACTER `=` CANNOT COMPARE INTO THE ATTRIBUTES NAMES OF VALUES.
  CLASS(XML_TAG), INTENT(INOUT)        :: SELF              !< XML TAG.
  CHARACTER(*),   INTENT(IN)           :: ATTRIBUTES_STREAM !< ATTRIBUTE NAME/VALUE PAIR LIST PASSED AS STREAM.
  LOGICAL,        INTENT(IN), OPTIONAL :: SANITIZE_VALUES   !< SANITIZE ATTRIBUTE VALUES.
  TYPE(STRING)                         :: ATTRIBUTES_STRING !< ATTRIBUTE NAME/VALUE PAIR LIST AS STRING.
  TYPE(STRING)                         :: TOKENS(1:3)       !< ATTRIBUTES TOKENIZED BY `=`.
  TYPE(STRING)                         :: ATTRIBUTE(1:2)    !< ATTRIBUTE NAME/VALUE PAIR.
  LOGICAL                              :: CONTINUE_TO_PARSE !< SENTINEL TO STOP ATTRIBUTES STREAM PARSING.
  INTEGER(I4P)                         :: MAX_CHARS         !< COUNTER.

  ATTRIBUTES_STRING = ATTRIBUTES_STREAM
  CONTINUE_TO_PARSE = .TRUE.
  DO WHILE(CONTINUE_TO_PARSE)
    TOKENS = ATTRIBUTES_STRING%PARTITION(SEP='=')
    ATTRIBUTE(1) = TRIM(ADJUSTL(TOKENS(1)))
    IF (ATTRIBUTE(1)/='') THEN
      TOKENS(3) = TOKENS(3)%SLICE(ISTART=TOKENS(3)%INDEX('"')+1, IEND=TOKENS(3)%LEN())
      ATTRIBUTE(2) = TOKENS(3)%SLICE(ISTART=1, IEND=TOKENS(3)%INDEX('"')-1)
      TOKENS(3) = TOKENS(3)%SLICE(ISTART=TOKENS(3)%INDEX('"')+1, IEND=TOKENS(3)%LEN())
      MAX_CHARS = MAX(ATTRIBUTE(1)%LEN(), ATTRIBUTE(2)%LEN())
      ATTRIBUTE(1) = ATTRIBUTE(1)%FILL(WIDTH=MAX_CHARS, RIGHT=.TRUE., FILLING_CHAR=' ')
      ATTRIBUTE(2) = ATTRIBUTE(2)%FILL(WIDTH=MAX_CHARS, RIGHT=.TRUE., FILLING_CHAR=' ')
      CALL SELF%ADD_SINGLE_ATTRIBUTE(ATTRIBUTE=[ATTRIBUTE(1)//'', ATTRIBUTE(2)//''], SANITIZE_VALUE=SANITIZE_VALUES)
      IF (TOKENS(3)%INDEX('=')>0) THEN
        ATTRIBUTES_STRING = TOKENS(3)
      ELSE
        CONTINUE_TO_PARSE = .FALSE.
      ENDIF
    ELSE
      CONTINUE_TO_PARSE = .FALSE.
    ENDIF
  ENDDO
  ENDSUBROUTINE ADD_STREAM_ATTRIBUTES

  ELEMENTAL SUBROUTINE ALLOC_ATTRIBUTES(SELF, NA)
  !< ALLOCATE (PREPARE FOR FILLING) DYNAMIC MEMORY OF ATTRIBUTES.
  CLASS(XML_TAG),    INTENT(INOUT) :: SELF     !< XML TAG.
  INTEGER(I4P),      INTENT(IN)    :: NA       !< NUMBER OF ATTRIBUTES.

  IF (ALLOCATED(SELF%ATTRIBUTE)) THEN
    CALL SELF%ATTRIBUTE%CUSTOMFREE
    DEALLOCATE(SELF%ATTRIBUTE)
  ENDIF
  ALLOCATE(SELF%ATTRIBUTE(1:2, 1:NA))
  SELF%ATTRIBUTES_NUMBER = NA
  ENDSUBROUTINE ALLOC_ATTRIBUTES

  PURE SUBROUTINE DELETE_CONTENT(SELF)
  !< DELETE TAG CONTENT.
  CLASS(XML_TAG), INTENT(INOUT) :: SELF !< XML TAG.

  CALL SELF%TAG_CONTENT%CUSTOMFREE
  ENDSUBROUTINE DELETE_CONTENT

  PURE SUBROUTINE DELETE_SINGLE_ATTRIBUTE(SELF, NAME)
  !< DELETE ONE ATTRIBUTE NAME/VALUE PAIR.
  CLASS(XML_TAG), INTENT(INOUT) :: SELF               !< XML TAG.
  CHARACTER(*),   INTENT(IN)    :: NAME               !< ATTRIBUTE NAME.
  TYPE(STRING), ALLOCATABLE     :: NEW_ATTRIBUTE(:,:) !< TEMPORARY STORAGE FOR ATTRIBUTES.
  INTEGER(I4P)                  :: A                  !< COUNTER.

  IF (SELF%ATTRIBUTES_NUMBER>0) THEN
    SEARCH_TAG: DO A=1, SELF%ATTRIBUTES_NUMBER
      IF (SELF%ATTRIBUTE(1, A)==NAME) THEN
        IF (SELF%ATTRIBUTES_NUMBER>1) THEN
          ALLOCATE(NEW_ATTRIBUTE(1:2, 1:SELF%ATTRIBUTES_NUMBER-1))
          IF (A==1) THEN
            NEW_ATTRIBUTE(:, A:) = SELF%ATTRIBUTE(:, A+1:)
          ELSEIF (A==SELF%ATTRIBUTES_NUMBER) THEN
            NEW_ATTRIBUTE(:, :A-1) = SELF%ATTRIBUTE(:, :A-1)
          ELSE
            NEW_ATTRIBUTE(:, :A-1) = SELF%ATTRIBUTE(:, :A-1)
            NEW_ATTRIBUTE(:, A:) = SELF%ATTRIBUTE(:, A+1:)
          ENDIF
          CALL MOVE_ALLOC(FROM=NEW_ATTRIBUTE, TO=SELF%ATTRIBUTE)
        ELSE
          CALL SELF%ATTRIBUTE%CUSTOMFREE
          DEALLOCATE(SELF%ATTRIBUTE)
        ENDIF
        SELF%ATTRIBUTES_NUMBER = SELF%ATTRIBUTES_NUMBER - 1
        EXIT SEARCH_TAG
      ENDIF
    ENDDO SEARCH_TAG
  ENDIF
  ENDSUBROUTINE DELETE_SINGLE_ATTRIBUTE

  PURE SUBROUTINE DELETE_MULTIPLE_ATTRIBUTES(SELF, NAME)
  !< DELETE LIST OF ATTRIBUTES NAME/VALUE PAIRS.
  CLASS(XML_TAG), INTENT(INOUT) :: SELF     !< XML TAG.
  CHARACTER(*),   INTENT(IN)    :: NAME(1:) !< ATTRIBUTES NAMES.
  INTEGER(I4P)                  :: A        !< COUNTER.

  DO A=1, SIZE(NAME, DIM=1)
    CALL SELF%DELETE_SINGLE_ATTRIBUTE(NAME=NAME(A))
  ENDDO
  ENDSUBROUTINE DELETE_MULTIPLE_ATTRIBUTES

  ELEMENTAL SUBROUTINE GET(SELF, SOURCE)
  !< GET THE TAG CONTENT AND ATTRIBUTES FROM SOURCE AFTER TAG_NAME AND ATTRIBUTES NAMES HAVE BEEN SET.
  CLASS(XML_TAG), INTENT(INOUT) :: SELF   !< XML TAG.
  CHARACTER(*),   INTENT(IN)    :: SOURCE !< STRING CONTAINING DATA.

  CALL SELF%GET_VALUE(SOURCE=SOURCE)
  CALL SELF%GET_ATTRIBUTES(SOURCE=SOURCE)
  ! CALL SELF%GET_NESTED()
  ENDSUBROUTINE GET

  ELEMENTAL SUBROUTINE GET_ATTRIBUTES(SELF, SOURCE)
  !< GET THE ATTRIBUTES VALUES FROM SOURCE AFTER TAG_NAME AND ATTRIBUTES NAMES HAVE BEEN SET.
  CLASS(XML_TAG), INTENT(INOUT) :: SELF   !< XML TAG.
  CHARACTER(*),   INTENT(IN)    :: SOURCE !< STRING CONTAINING DATA.
  INTEGER                       :: A      !< COUNTER.
  INTEGER                       :: C1     !< COUNTER.
  INTEGER                       :: C2     !< COUNTER.

  IF (INDEX(STRING=SOURCE, SUBSTRING='<'//SELF%TAG_NAME)>0) THEN
    IF (SELF%ATTRIBUTES_NUMBER>0) THEN ! PARSING ATTRIBUTES
      DO A=1, SELF%ATTRIBUTES_NUMBER
        C1 = INDEX(STRING=SOURCE, SUBSTRING=SELF%ATTRIBUTE(1, A)//'="') + SELF%ATTRIBUTE(1, A)%LEN() + 2
        IF (C1>SELF%ATTRIBUTE(1, A)%LEN() + 2) THEN
          C2 = INDEX(STRING=SOURCE(C1:), SUBSTRING='"')
          IF (C2>0) THEN
            SELF%ATTRIBUTE(2, A) = SOURCE(C1:C1+C2-2)
          ELSE
            CALL SELF%ATTRIBUTE(2, A)%CUSTOMFREE
          ENDIF
        ELSE
          CALL SELF%ATTRIBUTE(2, A)%CUSTOMFREE
        ENDIF
      ENDDO
    ENDIF
  ENDIF
  ENDSUBROUTINE GET_ATTRIBUTES

  ELEMENTAL SUBROUTINE GET_VALUE(SELF, SOURCE)
  !< GET THE TAG VALUE FROM SOURCE AFTER TAG_NAME HAS BEEN SET.
  CLASS(XML_TAG), INTENT(INOUT) :: SELF   !< XML TAG.
  CHARACTER(*),   INTENT(IN)    :: SOURCE !< STRING CONTAINING DATA.
  INTEGER                       :: C1     !< COUNTER.
  INTEGER                       :: C2     !< COUNTER.

  CALL SELF%TAG_CONTENT%CUSTOMFREE
  SELF%IS_SELF_CLOSING = .FALSE.
  IF (INDEX(STRING=SOURCE, SUBSTRING='<'//SELF%TAG_NAME)>0) THEN
    C2 = INDEX(STRING=SOURCE, SUBSTRING='</'//SELF%TAG_NAME//'>')
    IF (C2>0) THEN ! PARSING TAG VALUE
      C1 = INDEX(STRING=SOURCE, SUBSTRING='>')
      IF (C1+1<C2-1) SELF%TAG_CONTENT = SOURCE(C1+1:C2-1)
    ELSE
      SELF%IS_SELF_CLOSING = .TRUE.
    ENDIF
  ENDIF
  ENDSUBROUTINE GET_VALUE

  ELEMENTAL SUBROUTINE PARSE_ATTRIBUTES_NAMES(SELF, SOURCE)
  !< PARSE THE TAG ATTRIBUTES NAMES CONTAINED INTO A STRING.
  !<
  !< VALID SYNTAX IS:
  !< + `ATT1="ATT1 VAL" ATT2="ATT2 VAL"...`
  !< @NOTE INSIDE THE ATTRIBUTES VALUE THE SYMBOLS `<` AND `>` ARE NOT ALLOWED.
  CLASS(XML_TAG), INTENT(INOUT) :: SELF   !< XML TAG.
  CHARACTER(*),   INTENT(IN)    :: SOURCE !< STRING CONTAINING THE INPUT.
  CHARACTER(LEN=:), ALLOCATABLE :: ATT    !< DUMMY STRING FOR PARSING FILE.
  INTEGER(I4P)                  :: C      !< COUNTER.
  INTEGER(I4P)                  :: S      !< COUNTER.
  INTEGER(I4P)                  :: A      !< COUNTER.
  INTEGER(I4P)                  :: NA     !< COUNTER.

  NA = 0
  C = 1
  ATT_COUNT: DO WHILE(C<=LEN(SOURCE))
    IF (SOURCE(C:C)=='=') NA = NA + 1
    C = C + 1
  ENDDO ATT_COUNT
  IF (NA>0) THEN
    CALL SELF%ALLOC_ATTRIBUTES(NA=NA)
    C = INDEX(STRING=SOURCE, SUBSTRING=' ')
    ATT = SOURCE(C:)
    C = 1
    A = 1
    ATT_SEARCH: DO WHILE(C<=LEN(ATT))
      IF (ATT(C:C)=='=') THEN
        S = MAX(0, INDEX(STRING=ATT, SUBSTRING=' '))
        SELF%ATTRIBUTE(1, A) = TRIM(ADJUSTL(ATT(S+1:C-1)))
        ATT = ATT(C+1:)
        C = 1
        A = A + 1
      ENDIF
      C = C + 1
    ENDDO ATT_SEARCH
  ENDIF
  ENDSUBROUTINE PARSE_ATTRIBUTES_NAMES

  ELEMENTAL SUBROUTINE PARSE_TAG_NAME(SELF, SOURCE, TSTART, TEND)
  !< PARSE THE TAG NAME CONTAINED INTO A STRING.
  !<
  !< IT IS ASSUMED THAT THE FIRST TAG CONTAINED INTO THE SOURCE IS PARSED, THE OTHERS EVENTUALLY PRESENT ARE OMITTED.
  !< VALID SYNTAX ARE:
  !< + `<TAG_NAME ATT1="ATT1 VAL" ATT2="ATT2 VAL"...>...</TAG_NAME>`
  !< + `<TAG_NAME ATT1="ATT1 VAL" ATT2="ATT2 VAL".../>`
  !< @NOTE INSIDE THE ATTRIBUTES VALUE THE SYMBOLS `<` AND `>` ARE NOT ALLOWED.
  CLASS(XML_TAG),         INTENT(INOUT) :: SELF    !< XML TAG.
  CHARACTER(*),           INTENT(IN)    :: SOURCE  !< STRING CONTAINING THE INPUT.
  INTEGER(I4P), OPTIONAL, INTENT(OUT)   :: TSTART  !< STARTING INDEX OF TAG INSIDE THE SOURCE.
  INTEGER(I4P), OPTIONAL, INTENT(OUT)   :: TEND    !< ENDING INDEX OF TAG INSIDE THE SOURCE.
  INTEGER(I4P)                          :: TSTARTD !< STARTING INDEX OF TAG INSIDE THE SOURCE.
  INTEGER(I4P)                          :: TENDD   !< ENDING INDEX OF TAG INSIDE THE SOURCE.
  CHARACTER(LEN=1)                      :: C1      !< DUMMY STRING FOR PARSING FILE.
  CHARACTER(LEN=:), ALLOCATABLE         :: C2      !< DUMMY STRING FOR PARSING FILE.
  INTEGER(I4P)                          :: C       !< COUNTER.
  INTEGER(I4P)                          :: S       !< COUNTER.

  TSTARTD = 0
  TENDD   = 0
  C = 1
  TAG_SEARCH: DO WHILE(C<=LEN(SOURCE))
    C1 = SOURCE(C:C)
    IF (C1=='<') THEN
      TSTARTD = C
      C2 = C1
      TAG_NAME: DO WHILE(C<LEN(SOURCE))
        C = C + 1 ; C1 = SOURCE(C:C)
        C2 = C2//C1
        IF (C1=='>') THEN
          TENDD = C
          EXIT TAG_NAME
        ENDIF
      ENDDO TAG_NAME
      S = INDEX(STRING=C2, SUBSTRING=' ')
      IF (S>0) THEN ! THERE ARE ATTRIBUTES
        SELF%TAG_NAME = C2(2:S-1)
      ELSE
        IF (INDEX(STRING=C2, SUBSTRING='/>')>0) THEN ! SELF CLOSING TAG
          SELF%TAG_NAME = C2(2:LEN(C2)-2)
        ELSE
          SELF%TAG_NAME = C2(2:LEN(C2)-1)
        ENDIF
      ENDIF
      EXIT TAG_SEARCH
    ENDIF
    C = C + 1
  ENDDO TAG_SEARCH
  IF (PRESENT(TSTART)) TSTART = TSTARTD
  IF (PRESENT(TEND  )) TEND   = TENDD
  ENDSUBROUTINE PARSE_TAG_NAME

  ELEMENTAL SUBROUTINE SEARCH(SELF, TAG_NAME, SOURCE, TSTART, TEND)
  !< SEARCH TAG NAMED *TAG_NAME* INTO A STRING AND, IN CASE IT IS FOUND, STORE INTO SELF.
  !<
  !< @NOTE IF *TAG_NAME* IS NOT FOUND, SELF IS RETURNED EMPTY.
  CLASS(XML_TAG),         INTENT(INOUT) :: SELF     !< XML TAG.
  CHARACTER(*),           INTENT(IN)    :: TAG_NAME !< SEARCHED TAG NAME.
  CHARACTER(*),           INTENT(IN)    :: SOURCE   !< STRING CONTAINING THE INPUT.
  INTEGER(I4P), OPTIONAL, INTENT(OUT)   :: TSTART   !< STARTING INDEX OF TAG INSIDE THE SOURCE.
  INTEGER(I4P), OPTIONAL, INTENT(OUT)   :: TEND     !< ENDING INDEX OF TAG INSIDE THE SOURCE.
  TYPE(XML_TAG)                         :: TAG      !< DUMMY XML TAG.
  INTEGER(I4P)                          :: TSTART_  !< STARTING INDEX OF TAG INSIDE THE SOURCE, LOCAL VARIABLE.
  INTEGER(I4P)                          :: TEND_    !< ENDING INDEX OF TAG INSIDE THE SOURCE, LOCAL VARIABLE.
  LOGICAL                               :: FOUND    !< FLAG FOR INQUIRING SEARCH RESULT.
  INTEGER(I4P)                          :: TSTART_C !< STARTING INDEX OF TAG INSIDE THE CURRENT SLICE OF SOURCE.
  INTEGER(I4P)                          :: TEND_C   !< STARTING INDEX OF TAG INSIDE THE CURRENT SLICE OF SOURCE.
  INTEGER(I4P)                          :: I

  IF (I.EQ.-1) THEN
  ENDIF
  CALL SELF%CUSTOMFREE
  SELF%TAG_NAME = TAG_NAME
  TSTART_ = 1
  TEND_   = 0
  FOUND = .FALSE.
  TSTART_C = 0
  TEND_C = 0
  TAG_SEARCH: DO
    CALL TAG%PARSE(SOURCE=SOURCE(TEND_ + 1:), TSTART=TSTART_C, TEND=TEND_C)
    TSTART_ = TSTART_ + TEND_
    TEND_ = TEND_ + TEND_C
    IF (TSTART_C==0.AND.TEND_C==0) THEN
      EXIT TAG_SEARCH ! NO TAG FOUND
    ELSE
      IF (TAG%TAG_NAME%IS_ALLOCATED()) THEN
        IF (TAG%TAG_NAME==SELF%TAG_NAME) THEN
          FOUND = .TRUE.
        ENDIF
      ENDIF
    ENDIF
    IF (FOUND) EXIT TAG_SEARCH
  ENDDO TAG_SEARCH
  IF (FOUND) THEN
    SELF = TAG
  ELSE
    CALL SELF%CUSTOMFREE
  ENDIF
  IF (PRESENT(TSTART)) TSTART = TSTART_
  IF (PRESENT(TEND  )) TEND   = TEND_
  ENDSUBROUTINE SEARCH

  ! ASSIGNMENT (=)
  ELEMENTAL SUBROUTINE ASSIGN_TAG(LHS, RHS)
  !< ASSIGNMENT BETWEEN TWO TAGS.
  CLASS(XML_TAG), INTENT(INOUT) :: LHS !< LEFT HAND SIDE.
  TYPE(XML_TAG),  INTENT(IN)    :: RHS !< RIGHT HAND SIDE.
  INTEGER(I4P)                  :: A   !< COUNTER.

  CALL LHS%CUSTOMFREE
  IF (RHS%TAG_NAME%IS_ALLOCATED()) LHS%TAG_NAME = RHS%TAG_NAME
  IF (RHS%TAG_CONTENT%IS_ALLOCATED()) LHS%TAG_CONTENT = RHS%TAG_CONTENT
  IF (RHS%ATTRIBUTES_NUMBER>0) THEN
    ALLOCATE(LHS%ATTRIBUTE(1:2, 1:RHS%ATTRIBUTES_NUMBER))
    DO A=1, RHS%ATTRIBUTES_NUMBER
      LHS%ATTRIBUTE(1:2, A) = RHS%ATTRIBUTE(1:2, A)
    ENDDO
  ENDIF
  LHS%ATTRIBUTES_NUMBER = RHS%ATTRIBUTES_NUMBER
  LHS%INDENT = RHS%INDENT
  LHS%IS_SELF_CLOSING = RHS%IS_SELF_CLOSING
  ENDSUBROUTINE ASSIGN_TAG

  ! FINALIZE
  ELEMENTAL SUBROUTINE FINALIZE(TAG)
  !< FREE DYNAMIC MEMORY WHEN FINALIZING.
  TYPE(XML_TAG), INTENT(INOUT) :: TAG !< XML TAG.

  CALL TAG%CUSTOMFREE
  ENDSUBROUTINE FINALIZE
ENDMODULE FOXY_XML_TAG






!< FOXY XML FILE CLASS.
MODULE FOXY_XML_FILE
!< FOXY XML FILE CLASS.
USE FOXY_XML_TAG, ONLY : XML_TAG
USE PENF

IMPLICIT NONE
PRIVATE

TYPE, PUBLIC:: XML_FILE
  !< XML FILE CLASS.
  !<
  !< @TODO THE "DELETE" FACILITY IS INCOMPLETE: NESTED TAGS ARE NOT TAKEN INTO ACCOUNT. BETTER SUPPORT WILL WITH THE
  !< "DOM" FACILITY.
  PRIVATE
  INTEGER(I4P)               :: NT = 0 !< NUMBER OF XML TAGS.
  TYPE(XML_TAG), ALLOCATABLE :: TAG(:) !< XML TAGS ARRAY.
  CONTAINS
    ! PUBLIC METHODS
    PROCEDURE :: CUSTOMFREE       !< FREE DYNAMIC MEMORY.
    PROCEDURE :: PARSE      !< PARSE XML DATA FROM STRING OR FILE.
    PROCEDURE :: CONTENT    !< RETURN TAG CONTENT OF TAG NAMED *NAME*.
    PROCEDURE :: STRINGIFY  !< CONVERT THE WHOLE FILE DATA INTO A STRING.
    PROCEDURE :: ADD_TAG    !< ADD TAG TO XML FILE.
    PROCEDURE :: DELETE_TAG !< ADD TAG FROM XML FILE.
    FINAL     :: FINALIZE   !< FREE DYNAMIC MEMORY WHEN FINALIZING.
    ! PRIVATE METHODS
    PROCEDURE, PRIVATE :: PARSE_FROM_STRING !< PARSE XML DATA FROM STRING.
ENDTYPE XML_FILE
CONTAINS
  ! PUBLIC METHODS
  ELEMENTAL SUBROUTINE CUSTOMFREE(SELF)
  !< FREE DYNAMIC MEMORY.
  CLASS(XML_FILE), INTENT(INOUT) :: SELF !< XML FILE.

  IF (ALLOCATED(SELF%TAG)) THEN
    CALL SELF%TAG%CUSTOMFREE
    DEALLOCATE(SELF%TAG)
    SELF%NT = 0
  ENDIF
  ENDSUBROUTINE CUSTOMFREE

  SUBROUTINE FINALIZE(FILE)
  !< FREE DYNAMIC MEMORY WHEN FINALIZING.
  TYPE(XML_FILE), INTENT(INOUT) :: FILE !< XML FILE.

  CALL FILE%CUSTOMFREE
  ENDSUBROUTINE FINALIZE

  SUBROUTINE PARSE(SELF, STRING, FILENAME)
  !< PARSE XML DATA FROM STRING OR FILE.
  !<
  !< @NOTE SELF DATA ARE FREE BEFORE TRYING TO PARSE NEW XML DATA: ALL PREVIOUSLY PARSED DATA ARE LOST.
  CLASS(XML_FILE),        INTENT(INOUT) :: SELF     !< XML FILE.
  CHARACTER(*), OPTIONAL, INTENT(IN)    :: STRING   !< STRING CONTAINING XML DATA.
  CHARACTER(*), OPTIONAL, INTENT(IN)    :: FILENAME !< FILE NAME CONTAINING XML DATA.
  CHARACTER(LEN=:), ALLOCATABLE         :: SOURCE   !< STRING CONTAINING XML DATA.

  CALL SELF%CUSTOMFREE
  IF (PRESENT(STRING)) THEN
    CALL SELF%PARSE_FROM_STRING(SOURCE_STRING=STRING)
  ELSEIF (PRESENT(FILENAME)) THEN
    SOURCE = LOAD_FILE_AS_STREAM(FILENAME=FILENAME, FAST_READ=.TRUE.)
    CALL SELF%PARSE_FROM_STRING(SOURCE_STRING=SOURCE)
  ENDIF
  ENDSUBROUTINE PARSE

  PURE FUNCTION CONTENT(SELF, NAME)
  !< RETURN TAG CONTENT OF TAG NAMED *NAME*.
  !<
  !< @NOTE IF THERE IS NO VALUE, THE *TAG_CONTENT* STRING IS RETURNED EMPTY, BUT ALLOCATED.
  CLASS(XML_FILE), INTENT(IN)   :: SELF    !< XML FILE.
  CHARACTER(*),    INTENT(IN)   :: NAME    !< TAG NAME.
  CHARACTER(LEN=:), ALLOCATABLE :: CONTENT !< TAG CONTENT.
  INTEGER(I4P)                  :: T       !< COUNTER.

  IF (ALLOCATED(CONTENT)) DEALLOCATE(CONTENT)
  IF (SELF%NT>0) THEN
    DO T=1, SELF%NT
      CALL SELF%TAG(T)%GET_CONTENT(NAME=NAME, CONTENT=CONTENT)
      IF (ALLOCATED(CONTENT)) EXIT
    ENDDO
  ENDIF
  IF (.NOT.ALLOCATED(CONTENT)) CONTENT = ''
  ENDFUNCTION CONTENT

  PURE FUNCTION STRINGIFY(SELF) RESULT(STRING)
  !< CONVERT THE WHOLE FILE DATA INTO A STRING.
  CLASS(XML_FILE), INTENT(IN)   :: SELF       !< XML FILE.
  CHARACTER(LEN=:), ALLOCATABLE :: STRING     !< OUTPUT STRING CONTAINING THE WHOLE XML FILE.
  CHARACTER(LEN=:), ALLOCATABLE :: TAG_STRING !< OUTPUT STRING CONTAINING THE CURRENT TAG.
  INTEGER(I4P)                  :: T          !< COUNTER.

  STRING = ''
  IF (SELF%NT>0) THEN
    DO T=1, SELF%NT - 1
      TAG_STRING = SELF%TAG(T)%STRINGIFY()
      STRING = STRING//TAG_STRING//NEW_LINE('A')
    ENDDO
    TAG_STRING = SELF%TAG(SELF%NT)%STRINGIFY()
    STRING = STRING//TAG_STRING
  ENDIF
  ENDFUNCTION STRINGIFY

  ELEMENTAL SUBROUTINE ADD_TAG(SELF, TAG)
  !< ADD TAG TO XML FILE.
  CLASS(XML_FILE), INTENT(INOUT) :: SELF       !< XML FILE.
  TYPE(XML_TAG),   INTENT(IN)    :: TAG        !< XML TAG.
  TYPE(XML_TAG), ALLOCATABLE     :: TAG_NEW(:) !< NEW (EXTENDED) TAGS ARRAY.

  IF (SELF%NT>0_I4P) THEN
    ALLOCATE(TAG_NEW(1:SELF%NT + 1))
    TAG_NEW(1:SELF%NT) = SELF%TAG(1:SELF%NT)
    TAG_NEW(SELF%NT + 1) = TAG
  ELSE
    ALLOCATE(TAG_NEW(1:1))
    TAG_NEW(1) = TAG
  ENDIF
  CALL MOVE_ALLOC(FROM=TAG_NEW, TO=SELF%TAG)
  SELF%NT = SELF%NT + 1
  ENDSUBROUTINE ADD_TAG

  ELEMENTAL SUBROUTINE DELETE_TAG(SELF, NAME)
  !< DELETE TAG FROM XML FILE.
  CLASS(XML_FILE), INTENT(INOUT) :: SELF       !< XML FILE.
  CHARACTER(*),    INTENT(IN)    :: NAME       !< XML TAG NAME.
  TYPE(XML_TAG), ALLOCATABLE     :: TAG_NEW(:) !< NEW (EXTENDED) TAGS ARRAY.
  INTEGER(I4P)                   :: T          !< COUNTER.

  IF (SELF%NT>0_I4P) THEN
    DO T=1, SELF%NT
      IF (NAME==SELF%TAG(T)%NAME()) THEN
        ALLOCATE(TAG_NEW(1:SELF%NT - 1))
        IF (T==1) THEN
          TAG_NEW(T:) = SELF%TAG(T+1:)
        ELSEIF (T==SELF%NT) THEN
          TAG_NEW(:T-1) = SELF%TAG(:T-1)
        ELSE
          TAG_NEW(:T-1) = SELF%TAG(:T-1)
          TAG_NEW(T:) = SELF%TAG(T+1:)
        ENDIF
        CALL MOVE_ALLOC(FROM=TAG_NEW, TO=SELF%TAG)
        SELF%NT = SELF%NT - 1
        EXIT
      ENDIF
    ENDDO
  ENDIF
  ENDSUBROUTINE DELETE_TAG

  ! PRIVATE METHODS
  SUBROUTINE PARSE_FROM_STRING(SELF, SOURCE_STRING)
  !< PARSE XML DATA FROM STRING.
  CLASS(XML_FILE), INTENT(INOUT) :: SELF          !< XML FILE.
  CHARACTER(*),    INTENT(IN)    :: SOURCE_STRING !< STRING CONTAINING XML DATA.
  TYPE(XML_TAG)                  :: TAG           !< DUMMY XML TAG.
  INTEGER(I4P)                   :: TSTART        !< COUNTER FOR TRACKING STRING PARSING.
  INTEGER(I4P)                   :: TEND          !< COUNTER FOR TRACKING STRING PARSING.

  TSTART = 1
  TEND = 0
  DO WHILE(TSTART<LEN(SOURCE_STRING))
    CALL TAG%CUSTOMFREE
    CALL TAG%PARSE(SOURCE=SOURCE_STRING(TSTART:), TEND=TEND)
    IF (TEND==0) EXIT
    IF (TAG%IS_PARSED()) CALL SELF%ADD_TAG(TAG)
    TSTART = TSTART + TEND
  ENDDO
  ENDSUBROUTINE PARSE_FROM_STRING

  ! NON TBP
  FUNCTION LOAD_FILE_AS_STREAM(FILENAME, DELIMITER_START, DELIMITER_END, FAST_READ, IOSTAT, IOMSG) RESULT(STREAM)
  !< LOAD FILE CONTENTS AND STORE AS SINGLE CHARACTERS STREAM.
  CHARACTER(*),           INTENT(IN)  :: FILENAME        !< FILE NAME.
  CHARACTER(*), OPTIONAL, INTENT(IN)  :: DELIMITER_START !< DELIMITER FROM WHICH START THE STREAM.
  CHARACTER(*), OPTIONAL, INTENT(IN)  :: DELIMITER_END   !< DELIMITER TO WHICH END THE STREAM.
  LOGICAL,      OPTIONAL, INTENT(IN)  :: FAST_READ       !< FLAG FOR ACTIVATING EFFICIENT READING WITH ONE SINGLE READ.
  INTEGER(I4P), OPTIONAL, INTENT(OUT) :: IOSTAT          !< IO ERROR.
  CHARACTER(*), OPTIONAL, INTENT(OUT) :: IOMSG           !< IO ERROR MESSAGE.
  CHARACTER(LEN=:), ALLOCATABLE       :: STREAM          !< OUTPUT STRING CONTAINING THE FILE DATA AS A SINGLE STREAM.
  LOGICAL                             :: IS_FILE         !< FLAG FOR INQUIRING THE PRESENCE OF THE FILE.
  INTEGER(I4P)                        :: UNIT            !< UNIT FILE.
  INTEGER(I4P)                        :: IOSTATD         !< IO ERROR.
  CHARACTER(500)                      :: IOMSGD          !< IO ERROR MESSAGE.
  CHARACTER(1)                        :: C1              !< SINGLE CHARACTER.
  CHARACTER(LEN=:), ALLOCATABLE       :: STRING          !< DUMMY STRING.
  LOGICAL                             :: CSTART          !< FLAG FOR STREAM CAPTURING TRIGGING.
  LOGICAL                             :: CEND            !< FLAG FOR STREAM CAPTURING TRIGGING.
  LOGICAL                             :: FAST            !< FLAG FOR ACTIVATING EFFICIENT READING WITH ONE SINGLE READ.
  INTEGER(I4P)                        :: FILESIZE        !< SIZE OF THE FILE FOR FAST READING.

  FAST = .FALSE. ; IF (PRESENT(FAST_READ)) FAST = FAST_READ
  ! INQUIRE FILE EXISTANCE
  INQUIRE(FILE=ADJUSTL(TRIM(FILENAME)), EXIST=IS_FILE, IOSTAT=IOSTATD, IOMSG=IOMSGD)
  IF (.NOT.IS_FILE) THEN
    IF (PRESENT(IOSTAT)) IOSTAT = IOSTATD
    IF (PRESENT(IOMSG )) IOMSG  = IOMSGD
    RETURN
  ENDIF
  ! OPEN FILE
  OPEN(NEWUNIT=UNIT, FILE=ADJUSTL(TRIM(FILENAME)), ACCESS='STREAM', FORM='UNFORMATTED', IOSTAT=IOSTATD, IOMSG=IOMSGD)
  IF (IOSTATD/=0) THEN
    IF (PRESENT(IOSTAT)) IOSTAT = IOSTATD
    IF (PRESENT(IOMSG )) IOMSG  = IOMSGD
    RETURN
  ENDIF
  ! LOADG DATA
  STREAM = ''
  IF (PRESENT(DELIMITER_START).AND.PRESENT(DELIMITER_END)) THEN
    ! LOAD ONLY DATA INSIDE DELIMITER_START AND DELIMITER_END
    STRING = ''
    MAIN_READ_LOOP: DO
      READ(UNIT=UNIT, IOSTAT=IOSTATD, IOMSG=IOMSGD, END=10)C1
      IF (C1==DELIMITER_START(1:1)) THEN
        CSTART = .TRUE.
        STRING = C1
        START_READ_LOOP: DO WHILE(LEN(STRING)<LEN(DELIMITER_START))
          READ(UNIT=UNIT, IOSTAT=IOSTATD, IOMSG=IOMSGD, END=10)C1
          STRING = STRING//C1
          IF (.NOT.(INDEX(STRING=DELIMITER_START, SUBSTRING=STRING)>0)) THEN
            CSTART = .FALSE.
            EXIT START_READ_LOOP
          ENDIF
        ENDDO START_READ_LOOP
        IF (CSTART) THEN
          CEND = .FALSE.
          STREAM = STRING
          DO WHILE(.NOT.CEND)
            READ(UNIT=UNIT, IOSTAT=IOSTATD, IOMSG=IOMSGD, END=10)C1
            IF (C1==DELIMITER_END(1:1)) THEN ! MAYBE THE END
              STRING = C1
              END_READ_LOOP: DO WHILE(LEN(STRING)<LEN(DELIMITER_END))
                READ(UNIT=UNIT, IOSTAT=IOSTATD, IOMSG=IOMSGD, END=10)C1
                STRING = STRING//C1
                IF (.NOT.(INDEX(STRING=DELIMITER_END, SUBSTRING=STRING)>0)) THEN
                  STREAM = STREAM//STRING
                  EXIT END_READ_LOOP
                ELSEIF (LEN(STRING)==LEN(DELIMITER_END)) THEN
                  CEND = .TRUE.
                  STREAM = STREAM//STRING
                  EXIT MAIN_READ_LOOP
                ENDIF
              ENDDO END_READ_LOOP
            ELSE
              STREAM = STREAM//C1
            ENDIF
          ENDDO
        ENDIF
      ENDIF
    ENDDO MAIN_READ_LOOP
  ELSE
    ! LOAD ALL DATA
    IF (FAST) THEN
      ! LOAD FAST
      INQUIRE(FILE=ADJUSTL(TRIM(FILENAME)), SIZE=FILESIZE, IOSTAT=IOSTATD, IOMSG=IOMSGD)
      IF (IOSTATD==0) THEN
        IF (ALLOCATED(STREAM)) DEALLOCATE(STREAM)
        ALLOCATE(CHARACTER(LEN=FILESIZE):: STREAM)
        READ(UNIT=UNIT, IOSTAT=IOSTATD, IOMSG=IOMSGD, END=10)STREAM
      ENDIF
    ELSE
      ! LOAD SLOW, ONE CHARACTER LOOP
      READ_LOOP: DO
        READ(UNIT=UNIT,IOSTAT=IOSTATD,IOMSG=IOMSGD,END=10)C1
        STREAM = STREAM//C1
      ENDDO READ_LOOP
    ENDIF
  ENDIF
  10 CLOSE(UNIT)
  IF (PRESENT(IOSTAT)) IOSTAT = IOSTATD
  IF (PRESENT(IOMSG))  IOMSG  = IOMSGD
  ENDFUNCTION LOAD_FILE_AS_STREAM
ENDMODULE FOXY_XML_FILE







!< FOXY, FORTRAN XML PARSER FOR POOR PEOPLE
MODULE FOXY
!< FOXY, FORTRAN XML PARSER FOR POOR PEOPLE
USE FOXY_XML_FILE, ONLY : XML_FILE
USE FOXY_XML_TAG, ONLY : XML_TAG
USE PENF

IMPLICIT NONE
PRIVATE
PUBLIC :: I1P, I2P, I4P, I8P, R4P, R8P
PUBLIC :: XML_FILE
PUBLIC :: XML_TAG
ENDMODULE FOXY






!< VTK_FORTRAN PARAMETERS.
MODULE VTK_FORTRAN_PARAMETERS
!< VTK_FORTRAN PARAMETERS.
USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY : OUTPUT_UNIT, ERROR_UNIT
USE PENF

IMPLICIT NONE
PRIVATE
SAVE
PUBLIC :: STDERR
PUBLIC :: STDOUT
PUBLIC :: END_REC

INTEGER(I4P), PARAMETER :: STDERR = ERROR_UNIT  !< STANDARD ERROR UNIT.
INTEGER(I4P), PARAMETER :: STDOUT = OUTPUT_UNIT !< STANDARD OUTPUT UNIT.
CHARACTER(1), PARAMETER :: END_REC = CHAR(10)   !< END-CHARACTER FOR BINARY-RECORD FINALIZE.
ENDMODULE VTK_FORTRAN_PARAMETERS


!< VTK FILE ABSTRACT XML WRITER.
MODULE VTKF_FILE_XML_WRITER_ABSTRACT
!< VTK FILE ABSTRACT XML WRITER.
USE FOXY
USE PENF
USE STRINGIFOR
USE VTK_FORTRAN_PARAMETERS

IMPLICIT NONE
PRIVATE
PUBLIC :: XML_WRITER_ABSTRACT

TYPE, ABSTRACT :: XML_WRITER_ABSTRACT
  !< VTK FILE ABSTRACT XML WRITER.
  TYPE(STRING)  :: FORMAT_CH                       !< OUTPUT FORMAT, STRING CODE.
  TYPE(STRING)  :: TOPOLOGY                        !< MESH TOPOLOGY.
  INTEGER(I4P)  :: INDENT=0_I4P                    !< INDENT COUNT.
  INTEGER(I8P)  :: IOFFSET=0_I8P                   !< OFFSET COUNT.
  INTEGER(I4P)  :: XML=0_I4P                       !< XML LOGICAL UNIT.
  INTEGER(I4P)  :: VTM_BLOCK(1:2)=[-1_I4P, -1_I4P] !< BLOCK INDEXES.
  INTEGER(I4P)  :: ERROR=0_I4P                     !< IO ERROR STATUS.
  TYPE(XML_TAG) :: TAG                             !< XML TAGS HANDLER.
  LOGICAL       :: IS_VOLATILE=.FALSE.             !< FLAG TO CHECK VOLATILE WRITER.
  TYPE(STRING)  :: XML_VOLATILE                    !< XML FILE VOLATILE (NOT A PHYSICAL FILE).
  CONTAINS
    ! PUBLIC METHODS (SOME DEFERRED)
    PROCEDURE,                                 PASS(SELF) :: CLOSE_XML_FILE               !< CLOSE XML FILE.
    PROCEDURE,                                 PASS(SELF) :: OPEN_XML_FILE                !< OPEN XML FILE.
    PROCEDURE,                                 PASS(SELF) :: CUSTOMFREE                         !< FREE ALLOCATED MEMORY.
    PROCEDURE,                                 PASS(SELF) :: GET_XML_VOLATILE             !< RETURN THE XML VOLATILE STRING FILE.
    PROCEDURE,                                 PASS(SELF) :: WRITE_CONNECTIVITY           !< WRITE CONNECTIVITY.
    PROCEDURE,                                 PASS(SELF) :: W_DATA_LOCATION_TAG !< WRITE DATAARRAY LOCATION TAG.
    PROCEDURE,                                 PASS(SELF) :: W_DATA_TAG          !< WRITE DATAARRAY TAG.
    PROCEDURE,                                 PASS(SELF) :: W_DATA_TAG_APPENDED !< WRITE DATAARRAY APPENDED TAG.
    PROCEDURE,                                 PASS(SELF) :: WRITE_END_TAG                !< WRITE `</TAG_NAME>` END TAG.
    PROCEDURE,                                 PASS(SELF) :: WRITE_HEADER_TAG             !< WRITE HEADER TAG.
    PROCEDURE,                                 PASS(SELF) :: WRITE_PARALLEL_OPEN_BLOCK    !< WRITE PARALLEL OPEN BLOCK.
    PROCEDURE,                                 PASS(SELF) :: WRITE_PARALLEL_CLOSE_BLOCK   !< WRITE PARALLEL CLOSE BLOCK.
    PROCEDURE,                                 PASS(SELF) :: WRITE_PARALLEL_DATAARRAY     !< WRITE PARALLEL DATAARRAY.
    PROCEDURE,                                 PASS(SELF) :: WRITE_PARALLEL_GEO           !< WRITE PARALLEL GEO.
    PROCEDURE,                                 PASS(SELF) :: WRITE_SELF_CLOSING_TAG       !< WRITE SELF CLOSING TAG.
    PROCEDURE,                                 PASS(SELF) :: WRITE_START_TAG              !< WRITE START TAG.
    PROCEDURE,                                 PASS(SELF) :: WRITE_TAG                    !< WRITE TAG.
    PROCEDURE,                                 PASS(SELF) :: WRITE_TOPOLOGY_TAG           !< WRITE TOPOLOGY TAG.
    PROCEDURE(INITIALIZE_INTERFACE), DEFERRED, PASS(SELF) :: INITIALIZE                   !< INITIALIZE WRITER.
    PROCEDURE(FINALIZE_INTERFACE),   DEFERRED, PASS(SELF) :: FINALIZE                     !< FINALIZE WRITER.
    GENERIC :: W_DATA =>          &
               W_DATA1_RANK1_R8P, &
               W_DATA1_RANK1_R4P, &
               W_DATA1_RANK1_I8P, &
               W_DATA1_RANK1_I4P, &
               W_DATA1_RANK1_I2P, &
               W_DATA1_RANK1_I1P, &
               W_DATA3_RANK1_R8P, &
               W_DATA3_RANK1_R4P, &
               W_DATA3_RANK1_I8P, &
               W_DATA3_RANK1_I4P, &
               W_DATA3_RANK1_I2P, &
               W_DATA3_RANK1_I1P, &
               W_DATA_LOCATION_TAG !< WRITE DATA (ARRAY).
    GENERIC :: WRITE_FIELDDATA =>      &
               WRITE_FIELDDATA1_RANK0, &
               WRITE_FIELDDATA_TAG !< WRITE FIELDDATA TAG.
    GENERIC :: WRITE_GEO =>                    &
               WRITE_GEO_STRG_DATA3_RANK1_R8P, &
               WRITE_GEO_STRG_DATA3_RANK1_R4P, &
               WRITE_GEO_RECT_DATA3_RANK1_R8P, &
               WRITE_GEO_RECT_DATA3_RANK1_R4P, &
               WRITE_GEO_UNST_DATA3_RANK1_R8P, &
               WRITE_GEO_UNST_DATA3_RANK1_R4P !< WRITE MESH.
    GENERIC :: WRITE_PARALLEL_BLOCK_FILES =>     &
               WRITE_PARALLEL_BLOCK_FILE,        &
               WRITE_PARALLEL_BLOCK_FILES_ARRAY, &
               WRITE_PARALLEL_BLOCK_FILES_STRING !< WRITE BLOCK LIST OF FILES.
    GENERIC :: WRITE_PIECE =>              &
               WRITE_PIECE_START_TAG,      &
               WRITE_PIECE_START_TAG_UNST, &
               WRITE_PIECE_END_TAG !< WRITE PIECE START/END TAG.
    ! DEFERRED METHODS
    PROCEDURE(W_DATA1_RANK1_R8P_INTERFACE), DEFERRED, PASS(SELF) :: W_DATA1_RANK1_R8P !< DATA 1, RANK 1, R8P.
    PROCEDURE(W_DATA1_RANK1_R4P_INTERFACE), DEFERRED, PASS(SELF) :: W_DATA1_RANK1_R4P !< DATA 1, RANK 1, R4P.
    PROCEDURE(W_DATA1_RANK1_I8P_INTERFACE), DEFERRED, PASS(SELF) :: W_DATA1_RANK1_I8P !< DATA 1, RANK 1, I8P.
    PROCEDURE(W_DATA1_RANK1_I4P_INTERFACE), DEFERRED, PASS(SELF) :: W_DATA1_RANK1_I4P !< DATA 1, RANK 1, I4P.
    PROCEDURE(W_DATA1_RANK1_I2P_INTERFACE), DEFERRED, PASS(SELF) :: W_DATA1_RANK1_I2P !< DATA 1, RANK 1, I2P.
    PROCEDURE(W_DATA1_RANK1_I1P_INTERFACE), DEFERRED, PASS(SELF) :: W_DATA1_RANK1_I1P !< DATA 1, RANK 1, I1P.
    PROCEDURE(W_DATA3_RANK1_R8P_INTERFACE), DEFERRED, PASS(SELF) :: W_DATA3_RANK1_R8P !< DATA 3, RANK 1, R8P.
    PROCEDURE(W_DATA3_RANK1_R4P_INTERFACE), DEFERRED, PASS(SELF) :: W_DATA3_RANK1_R4P !< DATA 3, RANK 1, R4P.
    PROCEDURE(W_DATA3_RANK1_I8P_INTERFACE), DEFERRED, PASS(SELF) :: W_DATA3_RANK1_I8P !< DATA 3, RANK 1, I8P.
    PROCEDURE(W_DATA3_RANK1_I4P_INTERFACE), DEFERRED, PASS(SELF) :: W_DATA3_RANK1_I4P !< DATA 3, RANK 1, I4P.
    PROCEDURE(W_DATA3_RANK1_I2P_INTERFACE), DEFERRED, PASS(SELF) :: W_DATA3_RANK1_I2P !< DATA 3, RANK 1, I2P.
    PROCEDURE(W_DATA3_RANK1_I1P_INTERFACE), DEFERRED, PASS(SELF) :: W_DATA3_RANK1_I1P !< DATA 3, RANK 1, I1P.
    PROCEDURE(W_DATA_APPENDED_INTERFACE),   DEFERRED, PASS(SELF) :: W_DATA_APPENDED   !< WRITE APPENDED.
    ! PRIVATE METHODS
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_FIELDDATA1_RANK0            !< WRITE FIELDDATA TAG (DATA 1, RANK 0, R8P).
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_FIELDDATA_TAG               !< WRITE FIELDDATA TAG.
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_GEO_STRG_DATA3_RANK1_R8P    !< WRITE **STRUCTUREDGRID** MESH (DATA 3, RANK 1, R8P).
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_GEO_STRG_DATA3_RANK1_R4P    !< WRITE **STRUCTUREDGRID** MESH (DATA 3, RANK 1, R4P).
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_GEO_RECT_DATA3_RANK1_R8P    !< WRITE **RECTILINEARGRID** MESH (DATA 3, RANK 1, R8P).
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_GEO_RECT_DATA3_RANK1_R4P    !< WRITE **RECTILINEARGRID** MESH (DATA 3, RANK 1, R4P).
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_GEO_UNST_DATA3_RANK1_R8P    !< WRITE **UNSTRUCTUREDGRID** MESH (DATA 3, RANK 1, R8P).
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_GEO_UNST_DATA3_RANK1_R4P    !< WRITE **UNSTRUCTUREDGRID** MESH (DATA 3, RANK 1, R4P).
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_GEO_POLY_DATA3_RANK1_R8P    !< WRITE **POLYDATA** MESH (DATA 3, RANK 1, R8P).
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_GEO_POLY_DATA3_RANK1_R4P    !< WRITE **POLYDATA** MESH (DATA 3, RANK 1, R4P).
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_PIECE_START_TAG             !< WRITE `<PIECE ...>` START TAG.
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_PIECE_START_TAG_UNST        !< WRITE `<PIECE ...>` START TAG FOR UNSTRUCTURED TOPOLOGY.
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_PIECE_END_TAG               !< WRITE `</PIECE>` END TAG.
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_PARALLEL_BLOCK_FILE         !< WRITE SINGLE FILE THAT BELONG TO THE CURRENT BLOCK.
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_PARALLEL_BLOCK_FILES_ARRAY  !< WRITE BLOCK LIST OF FILES (ARRAY INPUT).
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_PARALLEL_BLOCK_FILES_STRING !< WRITE BLOCK LIST OF FILES (STRING INPUT).
ENDTYPE XML_WRITER_ABSTRACT

ABSTRACT INTERFACE
  FUNCTION INITIALIZE_INTERFACE(SELF, FORMAT, FILENAME, MESH_TOPOLOGY, NX1, NX2, NY1, NY2, NZ1, NZ2, &
                                IS_VOLATILE, MESH_KIND) RESULT(ERROR)
  !< INITIALIZE WRITER.
  IMPORT :: XML_WRITER_ABSTRACT, I4P
  CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF          !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: FORMAT        !< FILE FORMAT: ASCII.
  CHARACTER(*),               INTENT(IN)           :: FILENAME      !< FILE NAME.
  CHARACTER(*),               INTENT(IN)           :: MESH_TOPOLOGY !< MESH TOPOLOGY.
  INTEGER(I4P),               INTENT(IN), OPTIONAL :: NX1           !< INITIAL NODE OF X AXIS.
  INTEGER(I4P),               INTENT(IN), OPTIONAL :: NX2           !< FINAL NODE OF X AXIS.
  INTEGER(I4P),               INTENT(IN), OPTIONAL :: NY1           !< INITIAL NODE OF Y AXIS.
  INTEGER(I4P),               INTENT(IN), OPTIONAL :: NY2           !< FINAL NODE OF Y AXIS.
  INTEGER(I4P),               INTENT(IN), OPTIONAL :: NZ1           !< INITIAL NODE OF Z AXIS.
  INTEGER(I4P),               INTENT(IN), OPTIONAL :: NZ2           !< FINAL NODE OF Z AXIS.
  CHARACTER(*),               INTENT(IN), OPTIONAL :: MESH_KIND     !< KIND OF MESH DATA: FLOAT64, FLOAT32, ECC.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_VOLATILE   !< FLAG TO CHECK VOLATILE WRITER.
  INTEGER(I4P)                                     :: ERROR         !< ERROR STATUS.
  ENDFUNCTION INITIALIZE_INTERFACE

   FUNCTION FINALIZE_INTERFACE(SELF) RESULT(ERROR)
   !< FINALIZE WRITER.
   IMPORT :: XML_WRITER_ABSTRACT, I4P
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF  !< WRITER.
   INTEGER(I4P)                              :: ERROR !< ERROR STATUS.
   ENDFUNCTION FINALIZE_INTERFACE

  FUNCTION W_DATA1_RANK1_R8P_INTERFACE(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (R8P).
  IMPORT :: XML_WRITER_ABSTRACT, I4P, R8P
  CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  REAL(R8P),                  INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  ENDFUNCTION W_DATA1_RANK1_R8P_INTERFACE

  FUNCTION W_DATA1_RANK1_R4P_INTERFACE(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (R4P).
  IMPORT :: XML_WRITER_ABSTRACT, I4P, R4P
  CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  REAL(R4P),                  INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  ENDFUNCTION W_DATA1_RANK1_R4P_INTERFACE

  FUNCTION W_DATA1_RANK1_I8P_INTERFACE(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (I8P).
  IMPORT :: XML_WRITER_ABSTRACT, I4P, I8P
  CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I8P),               INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  ENDFUNCTION W_DATA1_RANK1_I8P_INTERFACE

  FUNCTION W_DATA1_RANK1_I4P_INTERFACE(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (I4P).
  IMPORT :: XML_WRITER_ABSTRACT, I4P
  CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I4P),               INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  ENDFUNCTION W_DATA1_RANK1_I4P_INTERFACE

  FUNCTION W_DATA1_RANK1_I2P_INTERFACE(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (I2P).
  IMPORT :: XML_WRITER_ABSTRACT, I2P, I4P
  CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I2P),               INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  ENDFUNCTION W_DATA1_RANK1_I2P_INTERFACE

  FUNCTION W_DATA1_RANK1_I1P_INTERFACE(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (I1P).
  IMPORT :: XML_WRITER_ABSTRACT, I1P, I4P
  CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I1P),               INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  ENDFUNCTION W_DATA1_RANK1_I1P_INTERFACE

  FUNCTION W_DATA3_RANK1_R8P_INTERFACE(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (R8P).
  IMPORT :: XML_WRITER_ABSTRACT, I4P, R8P
  CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  REAL(R8P),                  INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
  REAL(R8P),                  INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
  REAL(R8P),                  INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  ENDFUNCTION W_DATA3_RANK1_R8P_INTERFACE

  FUNCTION W_DATA3_RANK1_R4P_INTERFACE(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (R4P).
  IMPORT :: XML_WRITER_ABSTRACT, I4P, R4P
  CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  REAL(R4P),                  INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
  REAL(R4P),                  INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
  REAL(R4P),                  INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  ENDFUNCTION W_DATA3_RANK1_R4P_INTERFACE

  FUNCTION W_DATA3_RANK1_I8P_INTERFACE(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (I8P).
  IMPORT :: XML_WRITER_ABSTRACT, I4P, I8P
  CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I8P),               INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
  INTEGER(I8P),               INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
  INTEGER(I8P),               INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  ENDFUNCTION W_DATA3_RANK1_I8P_INTERFACE

  FUNCTION W_DATA3_RANK1_I4P_INTERFACE(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (I4P).
  IMPORT :: XML_WRITER_ABSTRACT, I4P
  CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I4P),               INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
  INTEGER(I4P),               INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
  INTEGER(I4P),               INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  ENDFUNCTION W_DATA3_RANK1_I4P_INTERFACE

  FUNCTION W_DATA3_RANK1_I2P_INTERFACE(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (I2P).
  IMPORT :: XML_WRITER_ABSTRACT, I2P, I4P
  CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I2P),               INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
  INTEGER(I2P),               INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
  INTEGER(I2P),               INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  ENDFUNCTION W_DATA3_RANK1_I2P_INTERFACE

  FUNCTION W_DATA3_RANK1_I1P_INTERFACE(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (I1P).
  IMPORT :: XML_WRITER_ABSTRACT, I1P, I4P
  CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I1P),               INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
  INTEGER(I1P),               INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
  INTEGER(I1P),               INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  ENDFUNCTION W_DATA3_RANK1_I1P_INTERFACE

  SUBROUTINE W_DATA_APPENDED_INTERFACE(SELF)
  !< WRITE `<APPENDEDDATA...>...</APPENDEDDATA>` TAG.
  IMPORT :: XML_WRITER_ABSTRACT
  CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF !< WRITER.
  ENDSUBROUTINE W_DATA_APPENDED_INTERFACE
ENDINTERFACE
CONTAINS
   ! FILES METHODS
   SUBROUTINE CLOSE_XML_FILE(SELF)
   !< CLOSE XML FILE.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF !< WRITER.

   IF (.NOT.SELF%IS_VOLATILE) CLOSE(UNIT=SELF%XML, IOSTAT=SELF%ERROR)
   ENDSUBROUTINE CLOSE_XML_FILE

   SUBROUTINE OPEN_XML_FILE(SELF, FILENAME)
   !< OPEN XML FILE.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF     !< WRITER.
   CHARACTER(*),               INTENT(IN)    :: FILENAME !< FILE NAME.

   IF (.NOT.SELF%IS_VOLATILE) THEN
      OPEN(NEWUNIT=SELF%XML,             &
           FILE=TRIM(ADJUSTL(FILENAME)), &
           FORM='UNFORMATTED',           &
           ACCESS='STREAM',              &
           ACTION='WRITE',               &
           STATUS='REPLACE',             &
           IOSTAT=SELF%ERROR)
   ELSE
      SELF%XML_VOLATILE = ''
   ENDIF
   ENDSUBROUTINE OPEN_XML_FILE

   ELEMENTAL SUBROUTINE CUSTOMFREE(SELF)
   !ELEMENTAL SUBROUTINE FREE(SELF, ERROR)
   !< FREE ALLOCATED MEMORY.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)         :: SELF  !< WRITER.
   !INTEGER(I4P),               INTENT(OUT), OPTIONAL :: ERROR !< ERROR STATUS.

   CALL SELF%FORMAT_CH%CUSTOMFREE
   CALL SELF%TOPOLOGY%CUSTOMFREE
   SELF%INDENT=0_I4P
   SELF%IOFFSET=0_I8P
   SELF%XML=0_I4P
   SELF%VTM_BLOCK(1:2)=[-1_I4P, -1_I4P]
   SELF%ERROR=0_I4P
   CALL SELF%TAG%CUSTOMFREE
   SELF%IS_VOLATILE=.FALSE.
   CALL SELF%XML_VOLATILE%CUSTOMFREE
   ENDSUBROUTINE CUSTOMFREE

   PURE SUBROUTINE GET_XML_VOLATILE(SELF, XML_VOLATILE)
   !PURE SUBROUTINE GET_XML_VOLATILE(SELF, XML_VOLATILE, ERROR)
   !< RETURN THE EVENTUAL XML VOLATILE STRING FILE.
   CLASS(XML_WRITER_ABSTRACT), INTENT(IN)               :: SELF         !< WRITER.
   CHARACTER(LEN=:),           INTENT(OUT), ALLOCATABLE :: XML_VOLATILE !< XML VOLATILE FILE.
   !INTEGER(I4P),               INTENT(OUT), OPTIONAL    :: ERROR        !< ERROR STATUS.

   IF (SELF%IS_VOLATILE) THEN
      XML_VOLATILE = SELF%XML_VOLATILE%RAW
   ENDIF
   ENDSUBROUTINE GET_XML_VOLATILE

   ! TAG METHODS
   SUBROUTINE WRITE_END_TAG(SELF, NAME)
   !< WRITE `</TAG_NAME>` END TAG.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF !< WRITER.
   CHARACTER(*),               INTENT(IN)    :: NAME !< TAG NAME.

   SELF%INDENT = SELF%INDENT - 2
   SELF%TAG = XML_TAG(NAME=NAME, INDENT=SELF%INDENT)
   IF (.NOT.SELF%IS_VOLATILE) THEN
      CALL SELF%TAG%WRITE(UNIT=SELF%XML, IOSTAT=SELF%ERROR, IS_INDENTED=.TRUE., END_RECORD=END_REC, ONLY_END=.TRUE.)
   ELSE
      SELF%XML_VOLATILE = SELF%XML_VOLATILE//SELF%TAG%STRINGIFY(IS_INDENTED=.TRUE., ONLY_END=.TRUE.)//END_REC
   ENDIF
   ENDSUBROUTINE WRITE_END_TAG

   SUBROUTINE WRITE_HEADER_TAG(SELF)
   !< WRITE HEADER TAG.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF   !< WRITER.
   TYPE(STRING)                              :: BUFFER !< BUFFER STRING.

   BUFFER = '<?xml version="1.0"?>'//END_REC
   IF (ENDIAN==ENDIANL) THEN
      BUFFER = BUFFER//'<VTKFile type="'//SELF%TOPOLOGY//'" version="1.0" byte_order="LittleEndian">'
   ELSE
      BUFFER = BUFFER//'<VTKFile type="'//SELF%TOPOLOGY//'" version="1.0" byte_order="BigEndian">'
   ENDIF
   IF (.NOT.SELF%IS_VOLATILE) THEN
      WRITE(UNIT=SELF%XML, IOSTAT=SELF%ERROR)BUFFER//END_REC
   ELSE
      SELF%XML_VOLATILE = SELF%XML_VOLATILE//BUFFER//END_REC
   ENDIF
   SELF%INDENT = 2
   ENDSUBROUTINE WRITE_HEADER_TAG

   SUBROUTINE WRITE_SELF_CLOSING_TAG(SELF, NAME, ATTRIBUTES)
   !< WRITE `<TAG_NAME.../>` SELF CLOSING TAG.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF       !< WRITER.
   CHARACTER(*),               INTENT(IN)           :: NAME       !< TAG NAME.
   CHARACTER(*),               INTENT(IN), OPTIONAL :: ATTRIBUTES !< TAG ATTRIBUTES.

   SELF%TAG = XML_TAG(NAME=NAME, ATTRIBUTES_STREAM=ATTRIBUTES, SANITIZE_ATTRIBUTES_VALUE=.TRUE., INDENT=SELF%INDENT, &
                      IS_SELF_CLOSING=.TRUE.)
   IF (.NOT.SELF%IS_VOLATILE) THEN
      CALL SELF%TAG%WRITE(UNIT=SELF%XML, IOSTAT=SELF%ERROR, IS_INDENTED=.TRUE., END_RECORD=END_REC)
   ELSE
      SELF%XML_VOLATILE = SELF%XML_VOLATILE//SELF%TAG%STRINGIFY(IS_INDENTED=.TRUE.)//END_REC
   ENDIF
   ENDSUBROUTINE WRITE_SELF_CLOSING_TAG

   SUBROUTINE WRITE_START_TAG(SELF, NAME, ATTRIBUTES)
   !< WRITE `<TAG_NAME...>` START TAG.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF       !< WRITER.
   CHARACTER(*),               INTENT(IN)           :: NAME       !< TAG NAME.
   CHARACTER(*),               INTENT(IN), OPTIONAL :: ATTRIBUTES !< TAG ATTRIBUTES.

   SELF%TAG = XML_TAG(NAME=NAME, ATTRIBUTES_STREAM=ATTRIBUTES, SANITIZE_ATTRIBUTES_VALUE=.TRUE., INDENT=SELF%INDENT)
   IF (.NOT.SELF%IS_VOLATILE) THEN
      CALL SELF%TAG%WRITE(UNIT=SELF%XML, IOSTAT=SELF%ERROR, IS_INDENTED=.TRUE., END_RECORD=END_REC, ONLY_START=.TRUE.)
   ELSE
      SELF%XML_VOLATILE = SELF%XML_VOLATILE//SELF%TAG%STRINGIFY(IS_INDENTED=.TRUE., ONLY_START=.TRUE.)//END_REC
   ENDIF
   SELF%INDENT = SELF%INDENT + 2
   ENDSUBROUTINE WRITE_START_TAG

   SUBROUTINE WRITE_TAG(SELF, NAME, ATTRIBUTES, CONTENT)
   !< WRITE `<TAG_NAME...>...</TAG_NAME>` TAG.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF       !< WRITER.
   CHARACTER(*),               INTENT(IN)           :: NAME       !< TAG NAME.
   CHARACTER(*),               INTENT(IN), OPTIONAL :: ATTRIBUTES !< TAG ATTRIBUTES.
   CHARACTER(*),               INTENT(IN), OPTIONAL :: CONTENT    !< TAG CONTENT.

   SELF%TAG = XML_TAG(NAME=NAME, ATTRIBUTES_STREAM=ATTRIBUTES, SANITIZE_ATTRIBUTES_VALUE=.TRUE., CONTENT=CONTENT, &
                      INDENT=SELF%INDENT)
   IF (.NOT.SELF%IS_VOLATILE) THEN
      CALL SELF%TAG%WRITE(UNIT=SELF%XML, IOSTAT=SELF%ERROR, IS_INDENTED=.TRUE., IS_CONTENT_INDENTED=.TRUE., END_RECORD=END_REC)
   ELSE
      SELF%XML_VOLATILE = SELF%XML_VOLATILE//SELF%TAG%STRINGIFY(IS_INDENTED=.TRUE., IS_CONTENT_INDENTED=.TRUE.)//END_REC
   ENDIF
   ENDSUBROUTINE WRITE_TAG

   SUBROUTINE WRITE_TOPOLOGY_TAG(SELF, NX1, NX2, NY1, NY2, NZ1, NZ2, MESH_KIND)
   !< WRITE XML TOPOLOGY TAG.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF      !< WRITER.
   INTEGER(I4P),               INTENT(IN), OPTIONAL :: NX1       !< INITIAL NODE OF X AXIS.
   INTEGER(I4P),               INTENT(IN), OPTIONAL :: NX2       !< FINAL NODE OF X AXIS.
   INTEGER(I4P),               INTENT(IN), OPTIONAL :: NY1       !< INITIAL NODE OF Y AXIS.
   INTEGER(I4P),               INTENT(IN), OPTIONAL :: NY2       !< FINAL NODE OF Y AXIS.
   INTEGER(I4P),               INTENT(IN), OPTIONAL :: NZ1       !< INITIAL NODE OF Z AXIS.
   INTEGER(I4P),               INTENT(IN), OPTIONAL :: NZ2       !< FINAL NODE OF Z AXIS.
   CHARACTER(*),               INTENT(IN), OPTIONAL :: MESH_KIND !< KIND OF MESH DATA: FLOAT64, FLOAT32, ECC.
   TYPE(STRING)                                     :: BUFFER    !< BUFFER STRING.

   BUFFER = ''
   SELECT CASE(SELF%TOPOLOGY%CHARS())
   CASE('RectilinearGrid', 'StructuredGrid','ImageData')
      BUFFER = 'WholeExtent="'//                             &
               TRIM(STR(N=NX1))//' '//TRIM(STR(N=NX2))//' '//&
               TRIM(STR(N=NY1))//' '//TRIM(STR(N=NY2))//' '//&
               TRIM(STR(N=NZ1))//' '//TRIM(STR(N=NZ2))//'"'
   CASE('PRectilinearGrid', 'PStructuredGrid','PImageData')
      BUFFER = 'WholeExtent="'//                             &
               TRIM(STR(N=NX1))//' '//TRIM(STR(N=NX2))//' '//&
               TRIM(STR(N=NY1))//' '//TRIM(STR(N=NY2))//' '//&
               TRIM(STR(N=NZ1))//' '//TRIM(STR(N=NZ2))//'" GhostLevel="#"'
   CASE('PUnstructuredGrid','PPolyData')
      BUFFER = 'GhostLevel="0"'
   ENDSELECT
   CALL SELF%WRITE_START_TAG(NAME=SELF%TOPOLOGY%CHARS(), ATTRIBUTES=BUFFER%CHARS())
   ! PARALLEL TOPOLOGIES PECULIARS
   SELECT CASE(SELF%TOPOLOGY%CHARS())
   CASE('PRectilinearGrid')
      IF (.NOT.PRESENT(MESH_KIND)) THEN
         SELF%ERROR = 1
         RETURN
      ENDIF
      CALL SELF%WRITE_START_TAG(NAME='PCoordinates')
      CALL SELF%WRITE_SELF_CLOSING_TAG(NAME='PDataArray', ATTRIBUTES='type="'//TRIM(MESH_KIND)//'"')
      CALL SELF%WRITE_SELF_CLOSING_TAG(NAME='PDataArray', ATTRIBUTES='type="'//TRIM(MESH_KIND)//'"')
      CALL SELF%WRITE_SELF_CLOSING_TAG(NAME='PDataArray', ATTRIBUTES='type="'//TRIM(MESH_KIND)//'"')
      CALL SELF%WRITE_END_TAG(NAME='PCoordinates')
   CASE('PStructuredGrid', 'PUnstructuredGrid','PPolyData')
      IF (.NOT.PRESENT(MESH_KIND)) THEN
         SELF%ERROR = 1
         RETURN
      ENDIF
      CALL SELF%WRITE_START_TAG(NAME='PPoints')
      CALL SELF%WRITE_SELF_CLOSING_TAG(NAME='PDataArray', &
                                       ATTRIBUTES='type="'//TRIM(MESH_KIND)//'" NumberOfComponents="3" NAME="POINTS"')
      CALL SELF%WRITE_END_TAG(NAME='PPoints')
   ENDSELECT
   ENDSUBROUTINE WRITE_TOPOLOGY_TAG

   ! W_DATA
   SUBROUTINE W_DATA_TAG(SELF, DATA_TYPE, NUMBER_OF_COMPONENTS, DATA_NAME, DATA_CONTENT, IS_TUPLES)
   !< WRITE `<DATAARRAY...>...</DATAARRAY>` TAG.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF                 !< WRITER.
   CHARACTER(*),               INTENT(IN)           :: DATA_TYPE            !< TYPE OF DATAARRAY.
   INTEGER(I4P),               INTENT(IN)           :: NUMBER_OF_COMPONENTS !< NUMBER OF DATAARRAY COMPONENTS.
   CHARACTER(*),               INTENT(IN)           :: DATA_NAME            !< DATA NAME.
   CHARACTER(*),               INTENT(IN), OPTIONAL :: DATA_CONTENT         !< DATA CONTENT.
   LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES            !< USE "NUMBEROFTUPLES".
   TYPE(STRING)                                     :: TAG_ATTRIBUTES       !< TAG ATTRIBUTES.
   LOGICAL                                          :: IS_TUPLES_           !< USE "NUMBEROFTUPLES".

   IS_TUPLES_ = .FALSE.
   IF (PRESENT(IS_TUPLES)) IS_TUPLES_ = IS_TUPLES
   IF (IS_TUPLES_) THEN
      TAG_ATTRIBUTES = 'type="'//TRIM(ADJUSTL(DATA_TYPE))//             &
        '" NumberOfTuples="'//TRIM(STR(NUMBER_OF_COMPONENTS, .TRUE.))// &
        '" Name="'//TRIM(ADJUSTL(DATA_NAME))//                          &
        '" format="'//SELF%FORMAT_CH//'"'
   ELSE
      TAG_ATTRIBUTES = 'type="'//TRIM(ADJUSTL(DATA_TYPE))//                 &
        '" NumberOfComponents="'//TRIM(STR(NUMBER_OF_COMPONENTS, .TRUE.))// &
        '" Name="'//TRIM(ADJUSTL(DATA_NAME))//                              &
        '" format="'//SELF%FORMAT_CH//'"'
   ENDIF
   CALL SELF%WRITE_TAG(NAME='DataArray', ATTRIBUTES=TAG_ATTRIBUTES%CHARS(), CONTENT=DATA_CONTENT)
   ENDSUBROUTINE W_DATA_TAG

   SUBROUTINE W_DATA_TAG_APPENDED(SELF, DATA_TYPE, NUMBER_OF_COMPONENTS, DATA_NAME, IS_TUPLES)
   !< WRITE `<DATAARRAY.../>` TAG.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF                 !< WRITER.
   CHARACTER(*),               INTENT(IN)           :: DATA_TYPE            !< TYPE OF DATAARRAY.
   INTEGER(I4P),               INTENT(IN)           :: NUMBER_OF_COMPONENTS !< NUMBER OF DATAARRAY COMPONENTS.
   CHARACTER(*),               INTENT(IN)           :: DATA_NAME            !< DATA NAME.
   LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES            !< USE "NUMBEROFTUPLES".
   TYPE(STRING)                                     :: TAG_ATTRIBUTES       !< TAG ATTRIBUTES.
   LOGICAL                                          :: IS_TUPLES_           !< USE "NUMBEROFTUPLES".

   IS_TUPLES_ = .FALSE.
   IF (PRESENT(IS_TUPLES)) IS_TUPLES_ = IS_TUPLES
   IF (IS_TUPLES_) THEN
      TAG_ATTRIBUTES =  'type="'//TRIM(ADJUSTL(DATA_TYPE))//            &
        '" NumberOfTuples="'//TRIM(STR(NUMBER_OF_COMPONENTS, .TRUE.))// &
        '" Name="'//TRIM(ADJUSTL(DATA_NAME))//                          &
        '" format="'//SELF%FORMAT_CH//                                  &
        '" offset="'//TRIM(STR(SELF%IOFFSET, .TRUE.))//'"'
   ELSE
      TAG_ATTRIBUTES = 'type="'//TRIM(ADJUSTL(DATA_TYPE))//                 &
        '" NumberOfComponents="'//TRIM(STR(NUMBER_OF_COMPONENTS, .TRUE.))// &
        '" Name="'//TRIM(ADJUSTL(DATA_NAME))//                              &
        '" format="'//SELF%FORMAT_CH//                                      &
        '" offset="'//TRIM(STR(SELF%IOFFSET, .TRUE.))//'"'
   ENDIF
   CALL SELF%WRITE_SELF_CLOSING_TAG(NAME='DataArray', ATTRIBUTES=TAG_ATTRIBUTES%CHARS())
   ENDSUBROUTINE W_DATA_TAG_APPENDED

   FUNCTION W_DATA_LOCATION_TAG(SELF, LOCATION, ACTION) RESULT(ERROR)
   !< WRITE `<[/]POINTDATA>` OR `<[/]CELLDATA>` OPEN/CLOSE TAG.
   !<
   !< @NOTE **MUST** BE CALLED BEFORE SAVING THE DATA RELATED TO GEOMETRIC MESH, THIS FUNCTION INITIALIZES THE
   !< SAVING OF DATA VARIABLES INDICATING THE *LOCATION* (NODE OR CELL CENTERED) OF VARIABLES THAT WILL BE SAVED.
   !<
   !< @NOTE A SINGLE FILE CAN CONTAIN BOTH CELL AND NODE CENTERED VARIABLES. IN THIS CASE THE VTK_DAT_XML FUNCTION MUST BE
   !< CALLED TWO TIMES, BEFORE SAVING CELL-CENTERED VARIABLES AND BEFORE SAVING NODE-CENTERED VARIABLES.
   !<
   !<### EXAMPLES OF USAGE
   !<
   !<#### OPENING NODE PIECE
   !<```FORTRAN
   !< ERROR = VTK%W_DATA('NODE','OPEN')
   !<```
   !<
   !<#### CLOSING NODE PIECE
   !<```FORTRAN
   !< ERROR = VTK%W_DATA('NODE','CLOSE')
   !<```
   !<
   !<#### OPENING CELL PIECE
   !<```FORTRAN
   !< ERROR = VTK%W_DATA('CELL','OPEN')
   !<```
   !<
   !<#### CLOSING CELL PIECE
   !<```FORTRAN
   !< ERROR = VTK%W_DATA('CELL','CLOSE')
   !<```
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF      !< WRITER.
   CHARACTER(*),               INTENT(IN)    :: LOCATION  !< LOCATION OF VARIABLES: **CELL** OR **NODE** CENTERED.
   CHARACTER(*),               INTENT(IN)    :: ACTION    !< ACTION: **OPEN** OR **CLOSE** TAG.
   INTEGER(I4P)                              :: ERROR     !< ERROR STATUS.
   TYPE(STRING)                              :: LOCATION_ !< LOCATION STRING.
   TYPE(STRING)                              :: ACTION_   !< ACTION STRING.

   LOCATION_ = TRIM(ADJUSTL(LOCATION)) ; LOCATION_ = LOCATION_%UPPER()
   ACTION_ = TRIM(ADJUSTL(ACTION)) ; ACTION_ = ACTION_%UPPER()
   SELECT CASE(LOCATION_%CHARS())
   CASE('CELL')
      LOCATION_ = 'CellData'
   CASE('NODE')
      LOCATION_ = 'PointData'
   ENDSELECT
   SELECT CASE(SELF%TOPOLOGY%CHARS())
   CASE('PRectilinearGrid', 'PStructuredGrid', 'PUnstructuredGrid','PPolyData')
      LOCATION_ = 'P'//LOCATION_
   ENDSELECT
   SELECT CASE(ACTION_%CHARS())
   CASE('OPEN')
      CALL SELF%WRITE_START_TAG(NAME=LOCATION_%CHARS())
   CASE('CLOSE')
      CALL SELF%WRITE_END_TAG(NAME=LOCATION_%CHARS())
   ENDSELECT
   ERROR = SELF%ERROR
   ENDFUNCTION W_DATA_LOCATION_TAG

   ! WRITE_FIELDDATA METHODS
   FUNCTION WRITE_FIELDDATA1_RANK0(SELF, DATA_NAME, X) RESULT(ERROR)
   !< WRITE `<DATAARRAY... NUMBEROFTUPLES="..."...>...</DATAARRAY>` TAG (R8P).
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF      !< WRITER.
   CHARACTER(*),               INTENT(IN)    :: DATA_NAME !< DATA NAME.
   CLASS(*),                   INTENT(IN)    :: X         !< DATA VARIABLE.
   INTEGER(I4P)                              :: ERROR     !< ERROR STATUS.

   SELECT TYPE(X)
   TYPE IS(REAL(R8P))
      SELF%ERROR = SELF%W_DATA(DATA_NAME=DATA_NAME, X=[X], IS_TUPLES=.TRUE.)
   TYPE IS(REAL(R4P))
      SELF%ERROR = SELF%W_DATA(DATA_NAME=DATA_NAME, X=[X], IS_TUPLES=.TRUE.)
   TYPE IS(INTEGER(I8P))
      SELF%ERROR = SELF%W_DATA(DATA_NAME=DATA_NAME, X=[X], IS_TUPLES=.TRUE.)
   TYPE IS(INTEGER(I4P))
      SELF%ERROR = SELF%W_DATA(DATA_NAME=DATA_NAME, X=[X], IS_TUPLES=.TRUE.)
   TYPE IS(INTEGER(I2P))
      SELF%ERROR = SELF%W_DATA(DATA_NAME=DATA_NAME, X=[X], IS_TUPLES=.TRUE.)
   TYPE IS(INTEGER(I1P))
      SELF%ERROR = SELF%W_DATA(DATA_NAME=DATA_NAME, X=[X], IS_TUPLES=.TRUE.)
   ENDSELECT
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_FIELDDATA1_RANK0

   FUNCTION WRITE_FIELDDATA_TAG(SELF, ACTION) RESULT(ERROR)
   !< WRITE `<FIELDDATA>`/`</FIELDDATA>` START/END TAG.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF      !< WRITER.
   CHARACTER(*),               INTENT(IN)    :: ACTION    !< ACTION: **OPEN** OR **CLOSE** TAG.
   INTEGER(I4P)                              :: ERROR     !< ERROR STATUS.
   TYPE(STRING)                              :: ACTION_   !< ACTION STRING.

   ACTION_ = TRIM(ADJUSTL(ACTION)) ; ACTION_ = ACTION_%UPPER()
   SELECT CASE(ACTION_%CHARS())
   CASE('OPEN')
      CALL SELF%WRITE_START_TAG(NAME='FieldData')
   CASE('CLOSE')
      CALL SELF%WRITE_END_TAG(NAME='FieldData')
   ENDSELECT
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_FIELDDATA_TAG

   ! WRITE_PIECE METHODS
   FUNCTION WRITE_PIECE_START_TAG(SELF, NX1, NX2, NY1, NY2, NZ1, NZ2) RESULT(ERROR)
   !< WRITE `<PIECE ...>` START TAG.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF           !< WRITER.
   INTEGER(I4P),               INTENT(IN)    :: NX1            !< INITIAL NODE OF X AXIS.
   INTEGER(I4P),               INTENT(IN)    :: NX2            !< FINAL NODE OF X AXIS.
   INTEGER(I4P),               INTENT(IN)    :: NY1            !< INITIAL NODE OF Y AXIS.
   INTEGER(I4P),               INTENT(IN)    :: NY2            !< FINAL NODE OF Y AXIS.
   INTEGER(I4P),               INTENT(IN)    :: NZ1            !< INITIAL NODE OF Z AXIS.
   INTEGER(I4P),               INTENT(IN)    :: NZ2            !< FINAL NODE OF Z AXIS.
   INTEGER(I4P)                              :: ERROR          !< ERROR STATUS.
   TYPE(STRING)                              :: TAG_ATTRIBUTES !< TAG ATTRIBUTES.

   TAG_ATTRIBUTES = 'Extent="'//TRIM(STR(N=NX1))//' '//TRIM(STR(N=NX2))//' '// &
                                TRIM(STR(N=NY1))//' '//TRIM(STR(N=NY2))//' '// &
                                TRIM(STR(N=NZ1))//' '//TRIM(STR(N=NZ2))//'"'
   CALL SELF%WRITE_START_TAG(NAME='Piece', ATTRIBUTES=TAG_ATTRIBUTES%CHARS())
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_PIECE_START_TAG

   FUNCTION WRITE_PIECE_START_TAG_UNST(SELF, NP, NC) RESULT(ERROR)
   !< WRITE `<PIECE ...>` START TAG FOR UNSTRUCTURED TOPOLOGY.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF           !< WRITER.
   INTEGER(I4P),               INTENT(IN)    :: NP             !< NUMBER OF POINTS.
   INTEGER(I4P),               INTENT(IN)    :: NC             !< NUMBER OF CELLS.
   INTEGER(I4P)                              :: ERROR          !< ERROR STATUS.
   TYPE(STRING)                              :: TAG_ATTRIBUTES !< TAG ATTRIBUTES.

   TAG_ATTRIBUTES = 'NumberOfPoints="'//TRIM(STR(N=NP))//'" NumberOfCells="'//TRIM(STR(N=NC))//'"'
   CALL SELF%WRITE_START_TAG(NAME='Piece', ATTRIBUTES=TAG_ATTRIBUTES%CHARS())
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_PIECE_START_TAG_UNST

   FUNCTION WRITE_PIECE_END_TAG(SELF) RESULT(ERROR)
   !< WRITE `</PIECE>` END TAG.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF  !< WRITER.
   INTEGER(I4P)                              :: ERROR !< ERROR STATUS.

   CALL SELF%WRITE_END_TAG(NAME='Piece')
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_PIECE_END_TAG

   ! WRITE_GEO_RECT METHODS
   FUNCTION WRITE_GEO_RECT_DATA3_RANK1_R8P(SELF, X, Y, Z) RESULT(ERROR)
   !< WRITE MESH WITH **RECTILINEARGRID** TOPOLOGY (DATA 3, RANK 1, R8P).
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF  !< WRITER.
   REAL(R8P),                  INTENT(IN)    :: X(1:) !< X COORDINATES.
   REAL(R8P),                  INTENT(IN)    :: Y(1:) !< Y COORDINATES.
   REAL(R8P),                  INTENT(IN)    :: Z(1:) !< Z COORDINATES.
   INTEGER(I4P)                              :: ERROR !< ERROR STATUS.

   CALL SELF%WRITE_START_TAG(NAME='Coordinates')
   ERROR = SELF%W_DATA(DATA_NAME='X', X=X)
   ERROR = SELF%W_DATA(DATA_NAME='Y', X=Y)
   ERROR = SELF%W_DATA(DATA_NAME='Z', X=Z)
   CALL SELF%WRITE_END_TAG(NAME='Coordinates')
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_GEO_RECT_DATA3_RANK1_R8P

   FUNCTION WRITE_GEO_RECT_DATA3_RANK1_R4P(SELF, X, Y, Z) RESULT(ERROR)
   !< WRITE MESH WITH **RECTILINEARGRID** TOPOLOGY (DATA 3, RANK 1, R4P).
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF  !< WRITER.
   REAL(R4P),                  INTENT(IN)    :: X(1:) !< X COORDINATES.
   REAL(R4P),                  INTENT(IN)    :: Y(1:) !< Y COORDINATES.
   REAL(R4P),                  INTENT(IN)    :: Z(1:) !< Z COORDINATES.
   INTEGER(I4P)                              :: ERROR !< ERROR STATUS.

   CALL SELF%WRITE_START_TAG(NAME='Coordinates')
   ERROR = SELF%W_DATA(DATA_NAME='X', X=X)
   ERROR = SELF%W_DATA(DATA_NAME='Y', X=Y)
   ERROR = SELF%W_DATA(DATA_NAME='Z', X=Z)
   CALL SELF%WRITE_END_TAG(NAME='Coordinates')
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_GEO_RECT_DATA3_RANK1_R4P

   ! WRITE_GEO_STRG METHODS
   FUNCTION WRITE_GEO_STRG_DATA3_RANK1_R8P(SELF, N, X, Y, Z) RESULT(ERROR)
   !< WRITE MESH WITH **STRUCTUREDGRID** TOPOLOGY (DATA 3, RANK 1, R8P).
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF  !< WRITER.
   INTEGER(I4P),               INTENT(IN)    :: N     !< NUMBER OF NODES.
   REAL(R8P),                  INTENT(IN)    :: X(1:) !< X COORDINATES.
   REAL(R8P),                  INTENT(IN)    :: Y(1:) !< Y COORDINATES.
   REAL(R8P),                  INTENT(IN)    :: Z(1:) !< Z COORDINATES.
   INTEGER(I4P)                              :: ERROR !< ERROR STATUS.

   IF ((N/=SIZE(X, DIM=1)).OR.(N/=SIZE(Y, DIM=1)).OR.(N/=SIZE(Z, DIM=1))) THEN
      SELF%ERROR = 1
      RETURN
   ENDIF
   CALL SELF%WRITE_START_TAG(NAME='Points')
   ERROR = SELF%W_DATA(DATA_NAME='Points', X=X, Y=Y, Z=Z)
   CALL SELF%WRITE_END_TAG(NAME='Points')
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_GEO_STRG_DATA3_RANK1_R8P

   FUNCTION WRITE_GEO_STRG_DATA3_RANK1_R4P(SELF, N, X, Y, Z) RESULT(ERROR)
   !< WRITE MESH WITH **STRUCTUREDGRID** TOPOLOGY (DATA 3, RANK 1, R4P).
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF  !< WRITER.
   INTEGER(I4P),               INTENT(IN)    :: N     !< NUMBER OF NODES.
   REAL(R4P),                  INTENT(IN)    :: X(1:) !< X COORDINATES.
   REAL(R4P),                  INTENT(IN)    :: Y(1:) !< Y COORDINATES.
   REAL(R4P),                  INTENT(IN)    :: Z(1:) !< Z COORDINATES.
   INTEGER(I4P)                              :: ERROR !< ERROR STATUS.

   IF ((N/=SIZE(X, DIM=1)).OR.(N/=SIZE(Y, DIM=1)).OR.(N/=SIZE(Z, DIM=1))) THEN
      SELF%ERROR = 1
      RETURN
   ENDIF
   CALL SELF%WRITE_START_TAG(NAME='Points')
   ERROR = SELF%W_DATA(DATA_NAME='Points', X=X, Y=Y, Z=Z)
   CALL SELF%WRITE_END_TAG(NAME='Points')
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_GEO_STRG_DATA3_RANK1_R4P

   ! WRITE_GEO_UNST METHODS
   FUNCTION WRITE_GEO_UNST_DATA3_RANK1_R8P(SELF, NP, NC, X, Y, Z) RESULT(ERROR)
   !< WRITE MESH WITH **UNSTRUCTUREDGRID** TOPOLOGY (DATA 3, RANK 1, R8P).
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF  !< WRITER.
   INTEGER(I4P),               INTENT(IN)    :: NP    !< NUMBER OF POINTS.
   INTEGER(I4P),               INTENT(IN)    :: NC    !< NUMBER OF CELLS.
   REAL(R8P),                  INTENT(IN)    :: X(1:) !< X COORDINATES.
   REAL(R8P),                  INTENT(IN)    :: Y(1:) !< Y COORDINATES.
   REAL(R8P),                  INTENT(IN)    :: Z(1:) !< Z COORDINATES.
   INTEGER(I4P)                              :: ERROR !< ERROR STATUS.

   IF ((NP/=SIZE(X, DIM=1)).OR.(NP/=SIZE(Y, DIM=1)).OR.(NP/=SIZE(Z, DIM=1))) THEN
      SELF%ERROR = 1
      RETURN
   ENDIF
   IF (NC.EQ.-1) THEN
   ENDIF
   CALL SELF%WRITE_START_TAG(NAME='Points')
   ERROR = SELF%W_DATA(DATA_NAME='Points', X=X, Y=Y, Z=Z)
   CALL SELF%WRITE_END_TAG(NAME='Points')
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_GEO_UNST_DATA3_RANK1_R8P

   FUNCTION WRITE_GEO_UNST_DATA3_RANK1_R4P(SELF, NP, NC, X, Y, Z) RESULT(ERROR)
   !< WRITE MESH WITH **UNSTRUCTUREDGRID** TOPOLOGY (DATA 3, RANK 1, R4P).
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF  !< WRITER.
   INTEGER(I4P),               INTENT(IN)    :: NP    !< NUMBER OF POINTS.
   INTEGER(I4P),               INTENT(IN)    :: NC    !< NUMBER OF CELLS.
   REAL(R4P),                  INTENT(IN)    :: X(1:) !< X COORDINATES.
   REAL(R4P),                  INTENT(IN)    :: Y(1:) !< Y COORDINATES.
   REAL(R4P),                  INTENT(IN)    :: Z(1:) !< Z COORDINATES.
   INTEGER(I4P)                              :: ERROR !< ERROR STATUS.

   IF ((NP/=SIZE(X, DIM=1)).OR.(NP/=SIZE(Y, DIM=1)).OR.(NP/=SIZE(Z, DIM=1))) THEN
      SELF%ERROR = 1
      RETURN
   ENDIF
   IF (NC.EQ.-1) THEN
   ENDIF
   CALL SELF%WRITE_START_TAG(NAME='Points')
   ERROR = SELF%W_DATA(DATA_NAME='Points', X=X, Y=Y, Z=Z)
   CALL SELF%WRITE_END_TAG(NAME='Points')
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_GEO_UNST_DATA3_RANK1_R4P

   ! WRITE_GEO_POLY METHODS
   FUNCTION WRITE_GEO_POLY_DATA3_RANK1_R8P(SELF, NP, NC, X, Y, Z) RESULT(ERROR)
   !< WRITE MESH WITH **POLYDATA** TOPOLOGY (DATA 3, RANK 1, R8P).
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF  !< WRITER.
   INTEGER(I4P),               INTENT(IN)    :: NP    !< NUMBER OF POINTS.
   INTEGER(I4P),               INTENT(IN)    :: NC    !< NUMBER OF CELLS.
   REAL(R8P),                  INTENT(IN)    :: X(1:) !< X COORDINATES.
   REAL(R8P),                  INTENT(IN)    :: Y(1:) !< Y COORDINATES.
   REAL(R8P),                  INTENT(IN)    :: Z(1:) !< Z COORDINATES.
   INTEGER(I4P)                              :: ERROR !< ERROR STATUS.

   IF ((NP/=SIZE(X, DIM=1)).OR.(NP/=SIZE(Y, DIM=1)).OR.(NP/=SIZE(Z, DIM=1))) THEN
      SELF%ERROR = 1
      ERROR = 1
      RETURN
   ENDIF
   IF (NC.EQ.-1) THEN
   ENDIF
   CALL SELF%WRITE_START_TAG(NAME='Points')
   ERROR = SELF%W_DATA(DATA_NAME='Points', X=X, Y=Y, Z=Z)
   CALL SELF%WRITE_END_TAG(NAME='Points')
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_GEO_POLY_DATA3_RANK1_R8P

   FUNCTION WRITE_GEO_POLY_DATA3_RANK1_R4P(SELF, NP, NC, X, Y, Z) RESULT(ERROR)
   !< WRITE MESH WITH **POLYDATA** TOPOLOGY (DATA 3, RANK 1, R4P).
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF  !< WRITER.
   INTEGER(I4P),               INTENT(IN)    :: NP    !< NUMBER OF POINTS.
   INTEGER(I4P),               INTENT(IN)    :: NC    !< NUMBER OF CELLS.
   REAL(R4P),                  INTENT(IN)    :: X(1:) !< X COORDINATES.
   REAL(R4P),                  INTENT(IN)    :: Y(1:) !< Y COORDINATES.
   REAL(R4P),                  INTENT(IN)    :: Z(1:) !< Z COORDINATES.
   INTEGER(I4P)                              :: ERROR !< ERROR STATUS.

   IF ((NP/=SIZE(X, DIM=1)).OR.(NP/=SIZE(Y, DIM=1)).OR.(NP/=SIZE(Z, DIM=1))) THEN
      SELF%ERROR = 1
      RETURN
   ENDIF
   IF (NC.EQ.-1) THEN
   ENDIF
   CALL SELF%WRITE_START_TAG(NAME='Points')
   ERROR = SELF%W_DATA(DATA_NAME='Points', X=X, Y=Y, Z=Z)
   CALL SELF%WRITE_END_TAG(NAME='Points')
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_GEO_POLY_DATA3_RANK1_R4P

   FUNCTION WRITE_CONNECTIVITY(SELF, NC, CONNECTIVITY, OFFSET, VTKC_TYPE, FACE, FACEOFFSET) RESULT(ERROR)
   !< WRITE MESH CONNECTIVITY.
   !<
   !< **MUST** BE USED WHEN UNSTRUCTURED GRID IS USED, IT SAVES THE CONNECTIVITY OF THE UNSTRUCTURED GIRD.
   !< @NOTE THE VECTOR **CONNECT** MUST FOLLOW THE VTK-XML STANDARD. IT IS PASSED AS *ASSUMED-SHAPE ARRAY*
   !< BECAUSE ITS DIMENSIONS IS RELATED TO THE MESH DIMENSIONS IN A COMPLEX WAY. ITS DIMENSIONS CAN BE CALCULATED BY THE FOLLOWING
   !< EQUATION: \(DC = \SUM\LIMITS_{I = 1}^{NC} {NVERTEX_I }\).
   !< NOTE THAT THIS EQUATION IS DIFFERENT FROM THE LEGACY ONE. THE XML CONNECTIVITY CONVENTION IS QUITE DIFFERENT FROM THE
   !< LEGACY STANDARD.
   !< AS AN EXAMPLE SUPPOSE WE HAVE A MESH COMPOSED BY 2 CELLS, ONE HEXAHEDRON (8 VERTICES) AND ONE PYRAMID WITH
   !< SQUARE BASIS (5 VERTICES) AND SUPPOSE THAT THE BASIS OF PYRAMID IS CONSTITUTE BY A FACE OF THE HEXAHEDRON AND SO THE TWO CELLS
   !< SHARE 4 VERTICES. THE ABOVE EQUATION GIVES \(DC=8+5=13\). THE CONNECTIVITY VECTOR FOR THIS MESH CAN BE:
   !<
   !<##### FIRST CELL
   !<+ CONNECT(1)  = 0 IDENTIFICATION FLAG OF \(1^\CIRC\) VERTEX OF FIRST CELL
   !<+ CONNECT(2)  = 1 IDENTIFICATION FLAG OF \(2^\CIRC\) VERTEX OF FIRST CELL
   !<+ CONNECT(3)  = 2 IDENTIFICATION FLAG OF \(3^\CIRC\) VERTEX OF FIRST CELL
   !<+ CONNECT(4)  = 3 IDENTIFICATION FLAG OF \(4^\CIRC\) VERTEX OF FIRST CELL
   !<+ CONNECT(5)  = 4 IDENTIFICATION FLAG OF \(5^\CIRC\) VERTEX OF FIRST CELL
   !<+ CONNECT(6)  = 5 IDENTIFICATION FLAG OF \(6^\CIRC\) VERTEX OF FIRST CELL
   !<+ CONNECT(7)  = 6 IDENTIFICATION FLAG OF \(7^\CIRC\) VERTEX OF FIRST CELL
   !<+ CONNECT(8)  = 7 IDENTIFICATION FLAG OF \(8^\CIRC\) VERTEX OF FIRST CELL
   !<
   !<##### SECOND CELL
   !<+ CONNECT(9 ) = 0 IDENTIFICATION FLAG OF \(1^\CIRC\) VERTEX OF SECOND CELL
   !<+ CONNECT(10) = 1 IDENTIFICATION FLAG OF \(2^\CIRC\) VERTEX OF SECOND CELL
   !<+ CONNECT(11) = 2 IDENTIFICATION FLAG OF \(3^\CIRC\) VERTEX OF SECOND CELL
   !<+ CONNECT(12) = 3 IDENTIFICATION FLAG OF \(4^\CIRC\) VERTEX OF SECOND CELL
   !<+ CONNECT(13) = 8 IDENTIFICATION FLAG OF \(5^\CIRC\) VERTEX OF SECOND CELL
   !<
   !< THEREFORE THIS CONNECTIVITY VECTOR CONVENTION IS MORE SIMPLE THAN THE LEGACY CONVENTION, NOW WE MUST CREATE ALSO THE
   !< *OFFSET* VECTOR THAT CONTAINS THE DATA NOW MISSING IN THE *CONNECT* VECTOR. THE OFFSET
   !< VECTOR FOR THIS MESH CAN BE:
   !<
   !<##### FIRST CELL
   !<+ OFFSET(1) = 8  => SUMM OF NODES OF \(1^\CIRC\) CELL
   !<
   !<##### SECOND CELL
   !<+ OFFSET(2) = 13 => SUMM OF NODES OF \(1^\CIRC\) AND \(2^\CIRC\) CELLS
   !<
   !< THE VALUE OF EVERY CELL-OFFSET CAN BE CALCULATED BY THE FOLLOWING EQUATION: \(OFFSET_C=\SUM\LIMITS_{I=1}^{C}{NVERTEX_I}\)
   !< WHERE \(OFFSET_C\) IS THE VALUE OF \(C^{TH}\) CELL AND \(NVERTEX_I\) IS THE NUMBER OF VERTICES OF \(I^{TH}\) CELL.
   !< THE FUNCTION VTK_CON_XML DOES NOT CALCULATE THE CONNECTIVITY AND OFFSET VECTORS: IT WRITES THE CONNECTIVITY AND OFFSET
   !< VECTORS CONFORMING THE VTK-XML STANDARD, BUT DOES NOT CALCULATE THEM.
   !< THE VECTOR VARIABLE *CELL\_TYPE* MUST CONFORM THE VTK-XML STANDARD (SEE THE FILE VTK-STANDARD AT THE
   !< KITWARE HOMEPAGE) THAT IS THE SAME OF THE LEGACY STANDARD. IT CONTAINS THE
   !< *TYPE* OF EACH CELLS. FOR THE ABOVE EXAMPLE THIS VECTOR IS:
   !<
   !<##### FIRST CELL
   !<+ CELL\_TYPE(1) = 12 HEXAHEDRON TYPE OF FIRST CELL
   !<
   !<##### SECOND CELL
   !<+ CELL\_TYPE(2) = 14 PYRAMID TYPE OF SECOND CELL
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF             !< WRITER.
   INTEGER(I4P),               INTENT(IN)    :: NC               !< NUMBER OF CELLS.
   INTEGER(I4P),               INTENT(IN)    :: CONNECTIVITY(1:) !< MESH CONNECTIVITY.
   INTEGER(I4P),               INTENT(IN)    :: OFFSET(1:)       !< CELL OFFSET.
   INTEGER(I4P),   OPTIONAL,   INTENT(IN)    :: FACE(1:)         !< FACE COMPOSING THE POLYHEDRA.
   INTEGER(I4P),   OPTIONAL,   INTENT(IN)    :: FACEOFFSET(1:)   !< FACE OFFSET.
   INTEGER(I1P),               INTENT(IN)    :: VTKC_TYPE(1:)    !< VTK CELL TYPE.
   INTEGER(I4P)                              :: ERROR            !< ERROR STATUS.

   CALL SELF%WRITE_START_TAG(NAME='Cells')
   ERROR = SELF%W_DATA(DATA_NAME='connectivity', X=CONNECTIVITY)
   ERROR = SELF%W_DATA(DATA_NAME='offsets', X=OFFSET)
   ERROR = SELF%W_DATA(DATA_NAME='types', X=VTKC_TYPE)
   CALL SELF%WRITE_END_TAG(NAME='Cells')

   IF (NC.EQ.-1) THEN
   ENDIF
   !< ADD FACES AND FACEOFFSETS TO THE CELL BLOCK FOR POLYHEDRA. IF THE CELL IS NOT A POLYHEDRON, ITS OFFSET MUST BE SET TO -1.
   IF(PRESENT(FACE).AND. PRESENT(FACEOFFSET)) THEN
        ERROR = SELF%W_DATA(DATA_NAME='Faces', X=FACE)
        ERROR = SELF%W_DATA(DATA_NAME='FaceOffsets', X=FACEOFFSET)
   ENDIF
   ENDFUNCTION WRITE_CONNECTIVITY

   ! WRITE_PARALLEL METHODS
   FUNCTION WRITE_PARALLEL_OPEN_BLOCK(SELF, NAME) RESULT(ERROR)
   !< WRITE A BLOCK (OPEN) CONTAINER.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF   !< WRITER.
   CHARACTER(*),               INTENT(IN), OPTIONAL :: NAME   !< BLOCK NAME.
   INTEGER(I4P)                                     :: ERROR  !< ERROR STATUS.
   TYPE(STRING)                                     :: BUFFER !< BUFFER STRING.

   SELF%VTM_BLOCK = SELF%VTM_BLOCK + 1
   IF (PRESENT(NAME)) THEN
      BUFFER = 'Index="'//TRIM(STR((SELF%VTM_BLOCK(1) + SELF%VTM_BLOCK(2)),.TRUE.))//'" Name="'//TRIM(ADJUSTL(NAME))//'"'
   ELSE
      BUFFER = 'Index="'//TRIM(STR((SELF%VTM_BLOCK(1) + SELF%VTM_BLOCK(2)),.TRUE.))//'"'
   ENDIF
   CALL SELF%WRITE_START_TAG(NAME='Block', ATTRIBUTES=BUFFER%CHARS())
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_PARALLEL_OPEN_BLOCK

   FUNCTION WRITE_PARALLEL_CLOSE_BLOCK(SELF) RESULT(ERROR)
   !< CLOSE A BLOCK CONTAINER.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT) :: SELF  !< WRITER.
   INTEGER(I4P)                              :: ERROR !< ERROR STATUS.

   SELF%VTM_BLOCK(2) = -1
   CALL SELF%WRITE_END_TAG(NAME='Block')
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_PARALLEL_CLOSE_BLOCK

   FUNCTION WRITE_PARALLEL_DATAARRAY(SELF, DATA_NAME, DATA_TYPE, NUMBER_OF_COMPONENTS) RESULT(ERROR)
   !< WRITE PARALLEL (PARTITIONED) VTK-XML DATAARRAY INFO.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF                 !< WRITER.
   CHARACTER(*),               INTENT(IN)           :: DATA_NAME            !< DATA NAME.
   CHARACTER(*),               INTENT(IN)           :: DATA_TYPE            !< TYPE OF DATAARRAY.
   INTEGER(I4P),               INTENT(IN), OPTIONAL :: NUMBER_OF_COMPONENTS !< NUMBER OF DATAARRAY COMPONENTS.
   INTEGER(I4P)                                     :: ERROR                !< ERROR STATUS.
   TYPE(STRING)                                     :: BUFFER               !< BUFFER STRING.

   IF (PRESENT(NUMBER_OF_COMPONENTS)) THEN
      BUFFER = 'type="'//TRIM(ADJUSTL(DATA_TYPE))//'" Name="'//TRIM(ADJUSTL(DATA_NAME))//&
               '" NumberOfComponents="'//TRIM(STR(NUMBER_OF_COMPONENTS, .TRUE.))//'"'
   ELSE
      BUFFER = 'type="'//TRIM(ADJUSTL(DATA_TYPE))//'" Name="'//TRIM(ADJUSTL(DATA_NAME))//'"'
   ENDIF
   CALL SELF%WRITE_SELF_CLOSING_TAG(NAME='PDataArray', ATTRIBUTES=BUFFER%CHARS())
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_PARALLEL_DATAARRAY

   FUNCTION WRITE_PARALLEL_GEO(SELF, SOURCE, NX1, NX2, NY1, NY2, NZ1, NZ2) RESULT(ERROR)
   !< WRITE PARALLEL (PARTITIONED) VTK-XML GEO SOURCE FILE.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF   !< WRITER.
   CHARACTER(*),               INTENT(IN)           :: SOURCE !< SOURCE FILE NAME CONTAINING THE PIECE DATA.
   INTEGER(I4P),               INTENT(IN), OPTIONAL :: NX1    !< INITIAL NODE OF X AXIS.
   INTEGER(I4P),               INTENT(IN), OPTIONAL :: NX2    !< FINAL NODE OF X AXIS.
   INTEGER(I4P),               INTENT(IN), OPTIONAL :: NY1    !< INITIAL NODE OF Y AXIS.
   INTEGER(I4P),               INTENT(IN), OPTIONAL :: NY2    !< FINAL NODE OF Y AXIS.
   INTEGER(I4P),               INTENT(IN), OPTIONAL :: NZ1    !< INITIAL NODE OF Z AXIS.
   INTEGER(I4P),               INTENT(IN), OPTIONAL :: NZ2    !< FINAL NODE OF Z AXIS.
   INTEGER(I4P)                                     :: ERROR  !< ERROR STATUS.
   TYPE(STRING)                                     :: BUFFER !< BUFFER STRING.

   SELECT CASE (SELF%TOPOLOGY%CHARS())
   CASE('PRectilinearGrid', 'PStructuredGrid')
      BUFFER = 'Extent="'// &
               TRIM(STR(N=NX1))//' '//TRIM(STR(N=NX2))//' '// &
               TRIM(STR(N=NY1))//' '//TRIM(STR(N=NY2))//' '// &
               TRIM(STR(N=NZ1))//' '//TRIM(STR(N=NZ2))//'" Source="'//TRIM(ADJUSTL(SOURCE))//'"'
   CASE('PUnstructuredGrid','PPolyData')
      BUFFER = 'Source="'//TRIM(ADJUSTL(SOURCE))//'"'
   ENDSELECT
   CALL SELF%WRITE_SELF_CLOSING_TAG(NAME='Piece', ATTRIBUTES=BUFFER%CHARS())
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_PARALLEL_GEO

   FUNCTION WRITE_PARALLEL_BLOCK_FILE(SELF, FILE_INDEX, FILENAME, NAME) RESULT(ERROR)
   !< WRITE SINGLE FILE THAT BELONG TO THE CURRENT BLOCK.
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF       !< WRITER.
   INTEGER(I4P),               INTENT(IN)           :: FILE_INDEX !< INDEX OF FILE IN THE LIST.
   CHARACTER(*),               INTENT(IN)           :: FILENAME   !< WRAPPED FILE NAMES.
   CHARACTER(*),               INTENT(IN), OPTIONAL :: NAME       !< NAMES ATTRIBUTED TO WRAPPED FILE.
   INTEGER(I4P)                                     :: ERROR      !< ERROR STATUS.

   IF (PRESENT(NAME)) THEN
      CALL SELF%WRITE_SELF_CLOSING_TAG(NAME='Dataset',                                      &
                                       ATTRIBUTES='Index="'//TRIM(STR(FILE_INDEX, .TRUE.))//&
                                                 '" File="'//TRIM(ADJUSTL(FILENAME))//      &
                                                 '" Name="'//TRIM(ADJUSTL(NAME))//'"')
   ELSE
      CALL SELF%WRITE_SELF_CLOSING_TAG(NAME='Dataset',                                       &
                                       ATTRIBUTES='Index="'//TRIM(STR(FILE_INDEX, .TRUE.))// &
                                                 '" File="'//TRIM(ADJUSTL(FILENAME))//'"')
   ENDIF
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_PARALLEL_BLOCK_FILE

   FUNCTION WRITE_PARALLEL_BLOCK_FILES_ARRAY(SELF, FILENAMES, NAMES) RESULT(ERROR)
   !< WRITE LIST OF FILES THAT BELONG TO THE CURRENT BLOCK (LIST PASSED AS RANK 1 ARRAY).
   !<
   !<#### EXAMPLE OF USAGE: 3 FILES BLOCKS
   !<```FORTRAN
   !< ERROR = VTM%WRITE_FILES_LIST_OF_BLOCK(FILENAMES=['FILE_1.VTS','FILE_2.VTS','FILE_3.VTU'])
   !<```
   !<
   !<#### EXAMPLE OF USAGE: 3 FILES BLOCKS WITH CUSTOM NAME
   !<```FORTRAN
   !< ERROR = VTM%WRITE_FILES_LIST_OF_BLOCK(FILENAMES=['FILE_1.VTS','FILE_2.VTS','FILE_3.VTU'],&
   !<                                       NAMES=['BLOCK-BAR','BLOCK-FOO','BLOCK-BAZ'])
   !<```
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF         !< WRITER.
   CHARACTER(*),               INTENT(IN)           :: FILENAMES(:) !< LIST OF VTK-XML WRAPPED FILE NAMES.
   CHARACTER(*),               INTENT(IN), OPTIONAL :: NAMES(:)     !< LIST NAMES ATTRIBUTED TO WRAPPED FILES.
   INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
   INTEGER(I4P)                                     :: F            !< FILE COUNTER.

   IF (PRESENT(NAMES)) THEN
      IF (SIZE(NAMES, DIM=1)==SIZE(FILENAMES, DIM=1)) THEN
         DO F=1, SIZE(FILENAMES, DIM=1)
            CALL SELF%WRITE_SELF_CLOSING_TAG(NAME='Dataset',                                     &
                                             ATTRIBUTES='Index="'//TRIM(STR(F-1, .TRUE.))//      &
                                                       '" File="'//TRIM(ADJUSTL(FILENAMES(F)))// &
                                                       '" Name="'//TRIM(ADJUSTL(NAMES(F)))//'"')
         ENDDO
      ENDIF
   ELSE
      DO F=1,SIZE(FILENAMES, DIM=1)
         CALL SELF%WRITE_SELF_CLOSING_TAG(NAME='Dataset',                                &
                                          ATTRIBUTES='Index="'//TRIM(STR(F-1, .TRUE.))// &
                                                    '" File="'//TRIM(ADJUSTL(FILENAMES(F)))//'"')
      ENDDO
   ENDIF
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_PARALLEL_BLOCK_FILES_ARRAY

   FUNCTION WRITE_PARALLEL_BLOCK_FILES_STRING(SELF, FILENAMES, NAMES, DELIMITER) RESULT(ERROR)
   !< WRITE LIST OF FILES THAT BELONG TO THE CURRENT BLOCK (LIST PASSED AS SINGLE STRING).
   !<
   !<#### EXAMPLE OF USAGE: 3 FILES BLOCKS
   !<```FORTRAN
   !< ERROR = VTM%WRITE_FILES_LIST_OF_BLOCK(FILENAMES='FILE_1.VTS FILE_2.VTS FILE_3.VTU')
   !<```
   !<
   !<#### EXAMPLE OF USAGE: 3 FILES BLOCKS WITH CUSTOM NAME
   !<```FORTRAN
   !< ERROR = VTM%WRITE_FILES_LIST_OF_BLOCK(FILENAMES='FILE_1.VTS FILE_2.VTS FILE_3.VTU',&
   !<                                       NAMES='BLOCK-BAR BLOCK-FOO BLOCK-BAZ')
   !<```
   CLASS(XML_WRITER_ABSTRACT), INTENT(INOUT)        :: SELF          !< WRITER.
   CHARACTER(*),               INTENT(IN)           :: FILENAMES     !< LIST OF VTK-XML WRAPPED FILE NAMES.
   CHARACTER(*),               INTENT(IN), OPTIONAL :: NAMES         !< LIST NAMES ATTRIBUTED TO WRAPPED FILES.
   CHARACTER(*),               INTENT(IN), OPTIONAL :: DELIMITER     !< DELIMITER CHARACTER.
   INTEGER(I4P)                                     :: ERROR         !< ERROR STATUS.
   TYPE(STRING), ALLOCATABLE                        :: FILENAMES_(:) !< LIST OF VTK-XML WRAPPED FILE NAMES.
   TYPE(STRING), ALLOCATABLE                        :: NAMES_(:)     !< LIST NAMES ATTRIBUTED TO WRAPPED FILES.
   TYPE(STRING)                                     :: DELIMITER_    !< DELIMITER CHARACTER.
   TYPE(STRING)                                     :: BUFFER        !< A STRING BUFFER.
   INTEGER(I4P)                                     :: F             !< FILE COUNTER.

   DELIMITER_ = ' ' ; IF (PRESENT(DELIMITER)) DELIMITER_ = DELIMITER
   BUFFER = FILENAMES
   CALL BUFFER%SPLIT(TOKENS=FILENAMES_, SEP=DELIMITER_%CHARS())
   IF (PRESENT(NAMES)) THEN
      BUFFER = NAMES
      CALL BUFFER%SPLIT(TOKENS=NAMES_, SEP=DELIMITER_%CHARS())
      IF (SIZE(NAMES_, DIM=1)==SIZE(FILENAMES_, DIM=1)) THEN
         DO F=1, SIZE(FILENAMES_, DIM=1)
            CALL SELF%WRITE_SELF_CLOSING_TAG(NAME='Dataset',                                      &
                                             ATTRIBUTES='Index="'//TRIM(STR(F-1, .TRUE.))//       &
                                                       '" File="'//TRIM(ADJUSTL(FILENAMES_(F)))// &
                                                       '" Name="'//TRIM(ADJUSTL(NAMES_(F)))//'"')
         ENDDO
      ENDIF
   ELSE
      DO F=1,SIZE(FILENAMES_, DIM=1)
         CALL SELF%WRITE_SELF_CLOSING_TAG(NAME='Dataset',                               &
                                          ATTRIBUTES='Index="'//TRIM(STR(F-1,.TRUE.))// &
                                                    '" File="'//TRIM(ADJUSTL(FILENAMES_(F)))//'"')
      ENDDO
   ENDIF
   ERROR = SELF%ERROR
   ENDFUNCTION WRITE_PARALLEL_BLOCK_FILES_STRING
ENDMODULE VTKF_FILE_XML_WRITER_ABSTRACT



!< DATAARRAY ENCODER, CODECS: "ASCII", "BASE64".
MODULE VTK_FORTRAN_DATAARRAY_ENCODER
!< VTK FILE XML WRITER, ASCII LOCAL.
USE BEFOR64
USE PENF

IMPLICIT NONE
PRIVATE
PUBLIC :: ENCODE_ASCII_DATAARRAY
PUBLIC :: ENCODE_BINARY_DATAARRAY

INTERFACE ENCODE_ASCII_DATAARRAY
  !< ASCII DATAARRAY ENCODER.
  MODULE PROCEDURE ENCODE_ASCII_DATAARRAY1_RANK1_R8P, &
                   ENCODE_ASCII_DATAARRAY1_RANK1_R4P, &
                   ENCODE_ASCII_DATAARRAY1_RANK1_I8P, &
                   ENCODE_ASCII_DATAARRAY1_RANK1_I4P, &
                   ENCODE_ASCII_DATAARRAY1_RANK1_I2P, &
                   ENCODE_ASCII_DATAARRAY1_RANK1_I1P, &
                   ENCODE_ASCII_DATAARRAY3_RANK1_R8P, &
                   ENCODE_ASCII_DATAARRAY3_RANK1_R4P, &
                   ENCODE_ASCII_DATAARRAY3_RANK1_I8P, &
                   ENCODE_ASCII_DATAARRAY3_RANK1_I4P, &
                   ENCODE_ASCII_DATAARRAY3_RANK1_I2P, &
                   ENCODE_ASCII_DATAARRAY3_RANK1_I1P
ENDINTERFACE ENCODE_ASCII_DATAARRAY
INTERFACE ENCODE_BINARY_DATAARRAY
  !< BINARY (BASE64) DATAARRAY ENCODER.
  MODULE PROCEDURE ENCODE_BINARY_DATAARRAY1_RANK1_R8P, &
                   ENCODE_BINARY_DATAARRAY1_RANK1_R4P, &
                   ENCODE_BINARY_DATAARRAY1_RANK1_I8P, &
                   ENCODE_BINARY_DATAARRAY1_RANK1_I4P, &
                   ENCODE_BINARY_DATAARRAY1_RANK1_I2P, &
                   ENCODE_BINARY_DATAARRAY1_RANK1_I1P, &
                   ENCODE_BINARY_DATAARRAY3_RANK1_R8P, &
                   ENCODE_BINARY_DATAARRAY3_RANK1_R4P, &
                   ENCODE_BINARY_DATAARRAY3_RANK1_I8P, &
                   ENCODE_BINARY_DATAARRAY3_RANK1_I4P, &
                   ENCODE_BINARY_DATAARRAY3_RANK1_I2P, &
                   ENCODE_BINARY_DATAARRAY3_RANK1_I1P
ENDINTERFACE ENCODE_BINARY_DATAARRAY
CONTAINS
  !< ASCII ENCODER
  FUNCTION ENCODE_ASCII_DATAARRAY1_RANK1_R16P(X) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 1 COMPONENTS OF RANK 1 (R8P).
  REAL(R16P),      INTENT(IN)   :: X(1:) !< DATA VARIABLE.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I4P)                  :: N     !< COUNTER.
  INTEGER(I4P)                  :: L     !< LENGTH
  INTEGER(I4P)                  :: SP    !< STRING POINTER
  INTEGER(I4P)                  :: SIZE_N!< DIMENSION SIZE

  SIZE_N = SIZE(X,DIM=1)
  L = DR16P+1
  SP = 0
  CODE = REPEAT(' ',L*SIZE_N)
  DO N = 1,SIZE_N
      CODE(SP+1:SP+L) = STR(N=X(N))
      SP = SP + L
  ENDDO
  ENDFUNCTION ENCODE_ASCII_DATAARRAY1_RANK1_R16P

  FUNCTION ENCODE_ASCII_DATAARRAY1_RANK1_R8P(X) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 1 COMPONENTS OF RANK 1 (R8P).
  REAL(R8P),       INTENT(IN)   :: X(1:) !< DATA VARIABLE.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I4P)                  :: N     !< COUNTER.
  INTEGER(I4P)                  :: L     !< LENGTH
  INTEGER(I4P)                  :: SP    !< STRING POINTER
  INTEGER(I4P)                  :: SIZE_N!< DIMENSION SIZE

  SIZE_N = SIZE(X,DIM=1)
  L = DR8P+1
  SP = 0
  CODE = REPEAT(' ',L*SIZE_N)
  DO N = 1,SIZE_N
      CODE(SP+1:SP+L) = STR(N=X(N))
      SP = SP + L
  ENDDO
  ENDFUNCTION ENCODE_ASCII_DATAARRAY1_RANK1_R8P

  FUNCTION ENCODE_ASCII_DATAARRAY1_RANK1_R4P(X) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 1 COMPONENTS OF RANK 1 (R4P).
  REAL(R4P),       INTENT(IN)   :: X(1:) !< DATA VARIABLE.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I4P)                  :: N     !< COUNTER.
  INTEGER(I4P)                  :: L     !< LENGTH
  INTEGER(I4P)                  :: SP    !< STRING POINTER
  INTEGER(I4P)                  :: SIZE_N!< DIMENSION SIZE

  SIZE_N = SIZE(X,DIM=1)
  L = DR4P+1
  SP = 0
  CODE = REPEAT(' ',L*SIZE_N)
  DO N = 1,SIZE_N
      CODE(SP+1:SP+L) = STR(N=X(N))
      SP = SP + L
  ENDDO
  ENDFUNCTION ENCODE_ASCII_DATAARRAY1_RANK1_R4P

  FUNCTION ENCODE_ASCII_DATAARRAY1_RANK1_I8P(X) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 1 COMPONENTS OF RANK 1 (I8P).
  INTEGER(I8P),    INTENT(IN)   :: X(1:) !< DATA VARIABLE.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I4P)                  :: N     !< COUNTER.
  INTEGER(I4P)                  :: L     !< LENGTH
  INTEGER(I4P)                  :: SP    !< STRING POINTER
  INTEGER(I4P)                  :: SIZE_N!< DIMENSION SIZE

  SIZE_N = SIZE(X,DIM=1)
  L = DI8P+1
  SP = 0
  CODE = REPEAT(' ',L*SIZE_N)
  DO N = 1,SIZE_N
      CODE(SP+1:SP+L) = STR(N=X(N))
      SP = SP + L
  ENDDO
  ENDFUNCTION ENCODE_ASCII_DATAARRAY1_RANK1_I8P

  FUNCTION ENCODE_ASCII_DATAARRAY1_RANK1_I4P(X) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 1 COMPONENTS OF RANK 1 (I4P).
  INTEGER(I4P),    INTENT(IN)   :: X(1:) !< DATA VARIABLE.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I4P)                  :: N     !< COUNTER.
  INTEGER(I4P)                  :: L     !< LENGTH
  INTEGER(I4P)                  :: SP    !< STRING POINTER
  INTEGER(I4P)                  :: SIZE_N!< DIMENSION SIZE

  SIZE_N = SIZE(X,DIM=1)
  L = DI4P+1
  SP = 0
  CODE = REPEAT(' ',L*SIZE_N)
  DO N = 1,SIZE_N
      CODE(SP+1:SP+L) = STR(N=X(N))
      SP = SP + L
  ENDDO
  ENDFUNCTION ENCODE_ASCII_DATAARRAY1_RANK1_I4P

  FUNCTION ENCODE_ASCII_DATAARRAY1_RANK1_I2P(X) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 1 COMPONENTS OF RANK 1 (I2P).
  INTEGER(I2P),    INTENT(IN)   :: X(1:) !< DATA VARIABLE.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I4P)                  :: N     !< COUNTER.
  INTEGER(I4P)                  :: L     !< LENGTH
  INTEGER(I4P)                  :: SP    !< STRING POINTER
  INTEGER(I4P)                  :: SIZE_N!< DIMENSION SIZE

  SIZE_N = SIZE(X,DIM=1)
  L = DI2P+1
  SP = 0
  CODE = REPEAT(' ',L*SIZE_N)
  DO N = 1,SIZE_N
      CODE(SP+1:SP+L) = STR(N=X(N))
      SP = SP + L
  ENDDO
  ENDFUNCTION ENCODE_ASCII_DATAARRAY1_RANK1_I2P

  FUNCTION ENCODE_ASCII_DATAARRAY1_RANK1_I1P(X) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 1 COMPONENTS OF RANK 1 (I1P).
  INTEGER(I1P),    INTENT(IN)   :: X(1:) !< DATA VARIABLE.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I4P)                  :: N     !< COUNTER.
  INTEGER(I4P)                  :: L     !< LENGTH
  INTEGER(I4P)                  :: SP    !< STRING POINTER
  INTEGER(I4P)                  :: SIZE_N!< DIMENSION SIZE

  SIZE_N = SIZE(X,DIM=1)
  L = DI1P+1
  SP = 0
  CODE = REPEAT(' ',L*SIZE_N)
  DO N = 1,SIZE_N
      CODE(SP+1:SP+L) = STR(N=X(N))
      SP = SP + L
  ENDDO
  ENDFUNCTION ENCODE_ASCII_DATAARRAY1_RANK1_I1P

  FUNCTION ENCODE_ASCII_DATAARRAY3_RANK1_R16P(X, Y, Z) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 3 COMPONENTS OF RANK 1 (R16P).
  REAL(R16P),      INTENT(IN)   :: X(1:) !< X COMPONENT.
  REAL(R16P),      INTENT(IN)   :: Y(1:) !< Y COMPONENT.
  REAL(R16P),      INTENT(IN)   :: Z(1:) !< Z COMPONENT.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I4P)                  :: N     !< COUNTER.
  INTEGER(I4P)                  :: L     !< LENGTH
  INTEGER(I4P)                  :: SP    !< STRING POINTER
  INTEGER(I4P)                  :: SIZE_N!< DIMENSION 1 SIZE

  SIZE_N = SIZE(X, DIM=1)
  L = DR16P*3 + 2
  SP = 0
  CODE = REPEAT(' ',L*SIZE_N)
  DO N=1, SIZE_N
    CODE(SP+1:SP+L) = STR(N=X(N))//' '//STR(N=Y(N))//' '//STR(N=Z(N))
    SP = SP + L
  ENDDO
  ENDFUNCTION ENCODE_ASCII_DATAARRAY3_RANK1_R16P

  FUNCTION ENCODE_ASCII_DATAARRAY3_RANK1_R8P(X, Y, Z) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 3 COMPONENTS OF RANK 1 (R8P).
  REAL(R8P),       INTENT(IN)   :: X(1:) !< X COMPONENT.
  REAL(R8P),       INTENT(IN)   :: Y(1:) !< Y COMPONENT.
  REAL(R8P),       INTENT(IN)   :: Z(1:) !< Z COMPONENT.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I4P)                  :: N     !< COUNTER.
  INTEGER(I4P)                  :: L     !< LENGTH
  INTEGER(I4P)                  :: SP    !< STRING POINTER
  INTEGER(I4P)                  :: SIZE_N!< DIMENSION 1 SIZE

  SIZE_N = SIZE(X, DIM=1)
  L = DR8P*3 + 2
  SP = 0
  CODE = REPEAT(' ',L*SIZE_N)
  DO N=1, SIZE_N
    CODE(SP+1:SP+L) = STR(N=X(N))//' '//STR(N=Y(N))//' '//STR(N=Z(N))
    SP = SP + L
  ENDDO
  ENDFUNCTION ENCODE_ASCII_DATAARRAY3_RANK1_R8P

  FUNCTION ENCODE_ASCII_DATAARRAY3_RANK1_R4P(X, Y, Z) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 3 COMPONENTS OF RANK 1 (R4P).
  REAL(R4P),       INTENT(IN)   :: X(1:) !< X COMPONENT.
  REAL(R4P),       INTENT(IN)   :: Y(1:) !< Y COMPONENT.
  REAL(R4P),       INTENT(IN)   :: Z(1:) !< Z COMPONENT.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I4P)                  :: N     !< COUNTER.
  INTEGER(I4P)                  :: L     !< LENGTH
  INTEGER(I4P)                  :: SP    !< STRING POINTER
  INTEGER(I4P)                  :: SIZE_N!< DIMENSION 1 SIZE

  SIZE_N = SIZE(X, DIM=1)
  L = DR4P*3 + 2
  SP = 0
  CODE = REPEAT(' ',L*SIZE_N)
  DO N=1, SIZE_N
    CODE(SP+1:SP+L) = STR(N=X(N))//' '//STR(N=Y(N))//' '//STR(N=Z(N))
    SP = SP + L
  ENDDO
  ENDFUNCTION ENCODE_ASCII_DATAARRAY3_RANK1_R4P

  FUNCTION ENCODE_ASCII_DATAARRAY3_RANK1_I8P(X, Y, Z) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 3 COMPONENTS OF RANK 1 (I8P).
  INTEGER(I8P),    INTENT(IN)   :: X(1:) !< X COMPONENT.
  INTEGER(I8P),    INTENT(IN)   :: Y(1:) !< Y COMPONENT.
  INTEGER(I8P),    INTENT(IN)   :: Z(1:) !< Z COMPONENT.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I4P)                  :: N     !< COUNTER.
  INTEGER(I4P)                  :: L     !< LENGTH
  INTEGER(I4P)                  :: SP    !< STRING POINTER
  INTEGER(I4P)                  :: SIZE_N!< DIMENSION 1 SIZE

  SIZE_N = SIZE(X, DIM=1)
  L = DI8P*3 + 2
  SP = 0
  CODE = REPEAT(' ',L*SIZE_N)
  DO N=1, SIZE_N
    CODE(SP+1:SP+L) = STR(N=X(N))//' '//STR(N=Y(N))//' '//STR(N=Z(N))
    SP = SP + L
  ENDDO
  ENDFUNCTION ENCODE_ASCII_DATAARRAY3_RANK1_I8P

  FUNCTION ENCODE_ASCII_DATAARRAY3_RANK1_I4P(X, Y, Z) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 3 COMPONENTS OF RANK 1 (I4P).
  INTEGER(I4P),    INTENT(IN)   :: X(1:) !< X COMPONENT.
  INTEGER(I4P),    INTENT(IN)   :: Y(1:) !< Y COMPONENT.
  INTEGER(I4P),    INTENT(IN)   :: Z(1:) !< Z COMPONENT.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I4P)                  :: N     !< COUNTER.
  INTEGER(I4P)                  :: L     !< LENGTH
  INTEGER(I4P)                  :: SP    !< STRING POINTER
  INTEGER(I4P)                  :: SIZE_N!< DIMENSION 1 SIZE

  SIZE_N = SIZE(X, DIM=1)
  L = DI4P*3 + 2
  SP = 0
  CODE = REPEAT(' ',L*SIZE_N)
  DO N=1, SIZE_N
    CODE(SP+1:SP+L) = STR(N=X(N))//' '//STR(N=Y(N))//' '//STR(N=Z(N))
    SP = SP + L
  ENDDO
  ENDFUNCTION ENCODE_ASCII_DATAARRAY3_RANK1_I4P

  FUNCTION ENCODE_ASCII_DATAARRAY3_RANK1_I2P(X, Y, Z) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 3 COMPONENTS OF RANK 1 (I2P).
  INTEGER(I2P),    INTENT(IN)   :: X(1:) !< X COMPONENT.
  INTEGER(I2P),    INTENT(IN)   :: Y(1:) !< Y COMPONENT.
  INTEGER(I2P),    INTENT(IN)   :: Z(1:) !< Z COMPONENT.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I4P)                  :: N     !< COUNTER.
  INTEGER(I4P)                  :: L     !< LENGTH
  INTEGER(I4P)                  :: SP    !< STRING POINTER
  INTEGER(I4P)                  :: SIZE_N!< DIMENSION 1 SIZE

  SIZE_N = SIZE(X, DIM=1)
  L = DI2P*3 + 2
  SP = 0
  CODE = REPEAT(' ',L*SIZE_N)
  DO N=1, SIZE_N
    CODE(SP+1:SP+L) = STR(N=X(N))//' '//STR(N=Y(N))//' '//STR(N=Z(N))
    SP = SP + L
  ENDDO
  ENDFUNCTION ENCODE_ASCII_DATAARRAY3_RANK1_I2P

  FUNCTION ENCODE_ASCII_DATAARRAY3_RANK1_I1P(X, Y, Z) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 3 COMPONENTS OF RANK 1 (I1P).
  INTEGER(I1P),    INTENT(IN)   :: X(1:) !< X COMPONENT.
  INTEGER(I1P),    INTENT(IN)   :: Y(1:) !< Y COMPONENT.
  INTEGER(I1P),    INTENT(IN)   :: Z(1:) !< Z COMPONENT.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I4P)                  :: N     !< COUNTER.
  INTEGER(I4P)                  :: L     !< LENGTH
  INTEGER(I4P)                  :: SP    !< STRING POINTER
  INTEGER(I4P)                  :: SIZE_N!< DIMENSION 1 SIZE

  SIZE_N = SIZE(X, DIM=1)
  L = DI1P*3 + 2
  SP = 0
  CODE = REPEAT(' ',L*SIZE_N)
  DO N=1, SIZE_N
    CODE(SP+1:SP+L) = STR(N=X(N))//' '//STR(N=Y(N))//' '//STR(N=Z(N))
    SP = SP + L
  ENDDO
  ENDFUNCTION ENCODE_ASCII_DATAARRAY3_RANK1_I1P

  !< BINARY ENCODER
  FUNCTION ENCODE_BINARY_DATAARRAY1_RANK1_R8P(X) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 1 COMPONENTS OF RANK 1 (R8P).
  REAL(R8P), INTENT(IN)         :: X(1:) !< DATA VARIABLE.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I1P),     ALLOCATABLE :: XP(:) !< PACKED DATA.
  INTEGER(I4P)                  :: NN    !< NUMBER OF ELEMENTS.

  NN = SIZE(X, DIM=1)
  CALL PACK_DATA(A1=[INT(NN*BYR8P, I4P)], A2=RESHAPE(X, [NN]), PACKED=XP)
  CALL B64_ENCODE(N=XP, CODE=CODE)
  ENDFUNCTION ENCODE_BINARY_DATAARRAY1_RANK1_R8P

  FUNCTION ENCODE_BINARY_DATAARRAY1_RANK1_R4P(X) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 1 COMPONENTS OF RANK 1 (R4P).
  REAL(R4P), INTENT(IN)         :: X(1:) !< DATA VARIABLE.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I1P),     ALLOCATABLE :: XP(:) !< PACKED DATA.
  INTEGER(I4P)                  :: NN    !< NUMBER OF ELEMENTS.

  NN = SIZE(X, DIM=1)
  CALL PACK_DATA(A1=[INT(NN*BYR4P, I4P)], A2=RESHAPE(X, [NN]), PACKED=XP)
  CALL B64_ENCODE(N=XP, CODE=CODE)
  ENDFUNCTION ENCODE_BINARY_DATAARRAY1_RANK1_R4P

  FUNCTION ENCODE_BINARY_DATAARRAY1_RANK1_I8P(X) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 1 COMPONENTS OF RANK 1 (I8P).
  INTEGER(I8P), INTENT(IN)      :: X(1:) !< DATA VARIABLE.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I1P),     ALLOCATABLE :: XP(:) !< PACKED DATA.
  INTEGER(I4P)                  :: NN    !< NUMBER OF ELEMENTS.

  NN = SIZE(X, DIM=1)
  CALL PACK_DATA(A1=[INT(NN*BYI8P, I4P)], A2=RESHAPE(X, [NN]), PACKED=XP)
  CALL B64_ENCODE(N=XP, CODE=CODE)
  ENDFUNCTION ENCODE_BINARY_DATAARRAY1_RANK1_I8P

  FUNCTION ENCODE_BINARY_DATAARRAY1_RANK1_I4P(X) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 1 COMPONENTS OF RANK 1 (I4P).
  INTEGER(I4P), INTENT(IN)      :: X(1:) !< DATA VARIABLE.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I1P),     ALLOCATABLE :: XP(:) !< PACKED DATA.
  INTEGER(I4P)                  :: NN    !< NUMBER OF ELEMENTS.

  NN = SIZE(X, DIM=1)
  XP = TRANSFER([INT(NN*BYI4P, I4P), RESHAPE(X, [NN])], XP)
  CALL B64_ENCODE(N=XP, CODE=CODE)
  ENDFUNCTION ENCODE_BINARY_DATAARRAY1_RANK1_I4P

  FUNCTION ENCODE_BINARY_DATAARRAY1_RANK1_I2P(X) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 1 COMPONENTS OF RANK 1 (I2P).
  INTEGER(I2P), INTENT(IN)      :: X(1:) !< DATA VARIABLE.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I1P),     ALLOCATABLE :: XP(:) !< PACKED DATA.
  INTEGER(I4P)                  :: NN    !< NUMBER OF ELEMENTS.

  NN = SIZE(X, DIM=1)
  CALL PACK_DATA(A1=[INT(NN*BYI2P, I4P)], A2=RESHAPE(X, [NN]), PACKED=XP)
  CALL B64_ENCODE(N=XP, CODE=CODE)
  ENDFUNCTION ENCODE_BINARY_DATAARRAY1_RANK1_I2P

  FUNCTION ENCODE_BINARY_DATAARRAY1_RANK1_I1P(X) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 1 COMPONENTS OF RANK 1 (I1P).
  INTEGER(I1P), INTENT(IN)      :: X(1:) !< DATA VARIABLE.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE  !< ENCODED BASE64 DATAARRAY.
  INTEGER(I1P),     ALLOCATABLE :: XP(:) !< PACKED DATA.
  INTEGER(I4P)                  :: NN    !< NUMBER OF ELEMENTS.

  NN = SIZE(X, DIM=1)
  CALL PACK_DATA(A1=[INT(NN*BYI1P, I4P)], A2=RESHAPE(X, [NN]), PACKED=XP)
  CALL B64_ENCODE(N=XP, CODE=CODE)
  ENDFUNCTION ENCODE_BINARY_DATAARRAY1_RANK1_I1P

  FUNCTION ENCODE_BINARY_DATAARRAY3_RANK1_R8P(X, Y, Z) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 3 COMPONENTS OF RANK 1 (R8P).
  REAL(R8P),    INTENT(IN)      :: X(1:)  !< X COMPONENT.
  REAL(R8P),    INTENT(IN)      :: Y(1:)  !< Y COMPONENT.
  REAL(R8P),    INTENT(IN)      :: Z(1:)  !< Z COMPONENT.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE   !< ENCODED BASE64 DATAARRAY.
  INTEGER(I1P),     ALLOCATABLE :: XYZ(:) !< PACKED DATA.
  INTEGER(I4P)                  :: NN     !< NUMBER OF ELEMENTS.
  INTEGER(I4P)                  :: N      !< COUNTER.

  NN = SIZE(X, DIM=1)
  CALL PACK_DATA(A1=[INT(3*NN*BYR8P, I4P)], A2=[(X(N), Y(N), Z(N), N=1, NN)], PACKED=XYZ)
  CALL B64_ENCODE(N=XYZ, CODE=CODE)
  ENDFUNCTION ENCODE_BINARY_DATAARRAY3_RANK1_R8P

  FUNCTION ENCODE_BINARY_DATAARRAY3_RANK1_R4P(X, Y, Z) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 3 COMPONENTS OF RANK 1 (R4P).
  REAL(R4P),    INTENT(IN)      :: X(1:)  !< X COMPONENT.
  REAL(R4P),    INTENT(IN)      :: Y(1:)  !< Y COMPONENT.
  REAL(R4P),    INTENT(IN)      :: Z(1:)  !< Z COMPONENT.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE   !< ENCODED BASE64 DATAARRAY.
  INTEGER(I1P),     ALLOCATABLE :: XYZ(:) !< PACKED DATA.
  INTEGER(I4P)                  :: NN     !< NUMBER OF ELEMENTS.
  INTEGER(I4P)                  :: N      !< COUNTER.

  NN = SIZE(X, DIM=1)
  CALL PACK_DATA(A1=[INT(3*NN*BYR4P, I4P)], A2=[(X(N), Y(N), Z(N), N=1, NN)], PACKED=XYZ)
  CALL B64_ENCODE(N=XYZ, CODE=CODE)
  ENDFUNCTION ENCODE_BINARY_DATAARRAY3_RANK1_R4P

  FUNCTION ENCODE_BINARY_DATAARRAY3_RANK1_I8P(X, Y, Z) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 3 COMPONENTS OF RANK 1 (I8P).
  INTEGER(I8P), INTENT(IN)      :: X(1:)  !< X COMPONENT.
  INTEGER(I8P), INTENT(IN)      :: Y(1:)  !< Y COMPONENT.
  INTEGER(I8P), INTENT(IN)      :: Z(1:)  !< Z COMPONENT.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE   !< ENCODED BASE64 DATAARRAY.
  INTEGER(I1P),     ALLOCATABLE :: XYZ(:) !< PACKED DATA.
  INTEGER(I4P)                  :: NN     !< NUMBER OF ELEMENTS.
  INTEGER(I4P)                  :: N      !< COUNTER.

  NN = SIZE(X, DIM=1)
  CALL PACK_DATA(A1=[INT(3*NN*BYI8P, I4P)], A2=[(X(N), Y(N), Z(N), N=1, NN)], PACKED=XYZ)
  CALL B64_ENCODE(N=XYZ, CODE=CODE)
  ENDFUNCTION ENCODE_BINARY_DATAARRAY3_RANK1_I8P

  FUNCTION ENCODE_BINARY_DATAARRAY3_RANK1_I4P(X, Y, Z) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 3 COMPONENTS OF RANK 1 (I4P).
  INTEGER(I4P), INTENT(IN)      :: X(1:)  !< X COMPONENT.
  INTEGER(I4P), INTENT(IN)      :: Y(1:)  !< Y COMPONENT.
  INTEGER(I4P), INTENT(IN)      :: Z(1:)  !< Z COMPONENT.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE   !< ENCODED BASE64 DATAARRAY.
  INTEGER(I1P),     ALLOCATABLE :: XYZ(:) !< PACKED DATA.
  INTEGER(I4P)                  :: NN     !< NUMBER OF ELEMENTS.
  INTEGER(I4P)                  :: N      !< COUNTER.

  NN = SIZE(X, DIM=1)
  XYZ = TRANSFER([INT(3*NN*BYI4P, I4P), [(X(N), Y(N), Z(N), N=1, NN)]], XYZ)
  CALL B64_ENCODE(N=XYZ, CODE=CODE)
  ENDFUNCTION ENCODE_BINARY_DATAARRAY3_RANK1_I4P

  FUNCTION ENCODE_BINARY_DATAARRAY3_RANK1_I2P(X, Y, Z) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 3 COMPONENTS OF RANK 1 (I2P).
  INTEGER(I2P), INTENT(IN)      :: X(1:)  !< X COMPONENT.
  INTEGER(I2P), INTENT(IN)      :: Y(1:)  !< Y COMPONENT.
  INTEGER(I2P), INTENT(IN)      :: Z(1:)  !< Z COMPONENT.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE   !< ENCODED BASE64 DATAARRAY.
  INTEGER(I1P),     ALLOCATABLE :: XYZ(:) !< PACKED DATA.
  INTEGER(I4P)                  :: NN     !< NUMBER OF ELEMENTS.
  INTEGER(I4P)                  :: N      !< COUNTER.

  NN = SIZE(X, DIM=1)
  CALL PACK_DATA(A1=[INT(3*NN*BYI2P, I4P)], A2=[(X(N), Y(N), Z(N), N=1, NN)], PACKED=XYZ)
  CALL B64_ENCODE(N=XYZ, CODE=CODE)
  ENDFUNCTION ENCODE_BINARY_DATAARRAY3_RANK1_I2P

  FUNCTION ENCODE_BINARY_DATAARRAY3_RANK1_I1P(X, Y, Z) RESULT(CODE)
  !< ENCODE (BASE64) A DATAARRAY WITH 3 COMPONENTS OF RANK 1 (I1P).
  INTEGER(I1P), INTENT(IN)      :: X(1:)  !< X COMPONENT.
  INTEGER(I1P), INTENT(IN)      :: Y(1:)  !< Y COMPONENT.
  INTEGER(I1P), INTENT(IN)      :: Z(1:)  !< Z COMPONENT.
  CHARACTER(LEN=:), ALLOCATABLE :: CODE   !< ENCODED BASE64 DATAARRAY.
  INTEGER(I1P),     ALLOCATABLE :: XYZ(:) !< PACKED DATA.
  INTEGER(I4P)                  :: NN     !< NUMBER OF ELEMENTS.
  INTEGER(I4P)                  :: N      !< COUNTER.

  NN = SIZE(X, DIM=1)
  CALL PACK_DATA(A1=[INT(3*NN*BYI1P, I4P)], A2=[(X(N), Y(N), Z(N), N=1, NN)], PACKED=XYZ)
  CALL B64_ENCODE(N=XYZ, CODE=CODE)
  ENDFUNCTION ENCODE_BINARY_DATAARRAY3_RANK1_I1P

ENDMODULE VTK_FORTRAN_DATAARRAY_ENCODER



!< VTK FILE XML WRITER, ASCII LOCAL.
MODULE VTKF_FILE_XML_WRITER_ASCII_LOCAL
!< VTK FILE XML WRITER, ASCII LOCAL.
USE PENF
USE STRINGIFOR
USE VTK_FORTRAN_DATAARRAY_ENCODER
USE VTKF_FILE_XML_WRITER_ABSTRACT

IMPLICIT NONE
PRIVATE
PUBLIC :: XML_WRITER_ASCII_LOCAL

TYPE, EXTENDS(XML_WRITER_ABSTRACT) :: XML_WRITER_ASCII_LOCAL
  !< VTK FILE XML WRITER, ASCII LOCAL.
  CONTAINS
    ! DEFERRED METHODS
    PROCEDURE, PASS(SELF) :: INITIALIZE                 !< INITIALIZE WRITER.
    PROCEDURE, PASS(SELF) :: FINALIZE                   !< FINALIZE WRITER.
    PROCEDURE, PASS(SELF) :: W_DATA1_RANK1_R8P !< WRITE DATAARRAY 1, RANK 1, R8P.
    PROCEDURE, PASS(SELF) :: W_DATA1_RANK1_R4P !< WRITE DATAARRAY 1, RANK 1, R4P.
    PROCEDURE, PASS(SELF) :: W_DATA1_RANK1_I8P !< WRITE DATAARRAY 1, RANK 1, I8P.
    PROCEDURE, PASS(SELF) :: W_DATA1_RANK1_I4P !< WRITE DATAARRAY 1, RANK 1, I4P.
    PROCEDURE, PASS(SELF) :: W_DATA1_RANK1_I2P !< WRITE DATAARRAY 1, RANK 1, I2P.
    PROCEDURE, PASS(SELF) :: W_DATA1_RANK1_I1P !< WRITE DATAARRAY 1, RANK 1, I1P.
    PROCEDURE, PASS(SELF) :: W_DATA3_RANK1_R8P !< WRITE DATAARRAY 3, RANK 1, R8P.
    PROCEDURE, PASS(SELF) :: W_DATA3_RANK1_R4P !< WRITE DATAARRAY 3, RANK 1, R4P.
    PROCEDURE, PASS(SELF) :: W_DATA3_RANK1_I8P !< WRITE DATAARRAY 3, RANK 1, I8P.
    PROCEDURE, PASS(SELF) :: W_DATA3_RANK1_I4P !< WRITE DATAARRAY 3, RANK 1, I4P.
    PROCEDURE, PASS(SELF) :: W_DATA3_RANK1_I2P !< WRITE DATAARRAY 3, RANK 1, I2P.
    PROCEDURE, PASS(SELF) :: W_DATA3_RANK1_I1P !< WRITE DATAARRAY 3, RANK 1, I1P.
    PROCEDURE, PASS(SELF) :: W_DATA_APPENDED   !< WRITE APPENDED.
ENDTYPE XML_WRITER_ASCII_LOCAL
CONTAINS
  FUNCTION INITIALIZE(SELF, FORMAT, FILENAME, MESH_TOPOLOGY, NX1, NX2, NY1, NY2, NZ1, NZ2, &
                      IS_VOLATILE, MESH_KIND) RESULT(ERROR)
  !< INITIALIZE WRITER.
  CLASS(XML_WRITER_ASCII_LOCAL), INTENT(INOUT)        :: SELF          !< WRITER.
  CHARACTER(*),                  INTENT(IN)           :: FORMAT        !< FILE FORMAT: ASCII.
  CHARACTER(*),                  INTENT(IN)           :: FILENAME      !< FILE NAME.
  CHARACTER(*),                  INTENT(IN)           :: MESH_TOPOLOGY !< MESH TOPOLOGY.
  INTEGER(I4P),                  INTENT(IN), OPTIONAL :: NX1           !< INITIAL NODE OF X AXIS.
  INTEGER(I4P),                  INTENT(IN), OPTIONAL :: NX2           !< FINAL NODE OF X AXIS.
  INTEGER(I4P),                  INTENT(IN), OPTIONAL :: NY1           !< INITIAL NODE OF Y AXIS.
  INTEGER(I4P),                  INTENT(IN), OPTIONAL :: NY2           !< FINAL NODE OF Y AXIS.
  INTEGER(I4P),                  INTENT(IN), OPTIONAL :: NZ1           !< INITIAL NODE OF Z AXIS.
  INTEGER(I4P),                  INTENT(IN), OPTIONAL :: NZ2           !< FINAL NODE OF Z AXIS.
  CHARACTER(*),                  INTENT(IN), OPTIONAL :: MESH_KIND     !< KIND OF MESH DATA: FLOAT64, FLOAT32, ECC.
  LOGICAL,                       INTENT(IN), OPTIONAL :: IS_VOLATILE   !< FLAG TO CHECK VOLATILE WRITER.
  INTEGER(I4P)                                        :: ERROR         !< ERROR STATUS.
  IF (IS_VOLATILE) THEN
  ENDIF
  SELF%TOPOLOGY = TRIM(ADJUSTL(MESH_TOPOLOGY))
  SELF%FORMAT_CH = FORMAT
  SELF%FORMAT_CH = SELF%FORMAT_CH%LOWER()
  CALL SELF%OPEN_XML_FILE(FILENAME=FILENAME)
  CALL SELF%WRITE_HEADER_TAG
  CALL SELF%WRITE_TOPOLOGY_TAG(NX1=NX1, NX2=NX2, NY1=NY1, NY2=NY2, NZ1=NZ1, NZ2=NZ2, MESH_KIND=MESH_KIND)
  ERROR = SELF%ERROR
  ENDFUNCTION INITIALIZE

   FUNCTION FINALIZE(SELF) RESULT(ERROR)
   !< FINALIZE WRITER.
   CLASS(XML_WRITER_ASCII_LOCAL), INTENT(INOUT) :: SELF  !< WRITER.
   INTEGER(I4P)                                 :: ERROR !< ERROR STATUS.

   CALL SELF%WRITE_END_TAG(NAME=SELF%TOPOLOGY%CHARS())
   CALL SELF%WRITE_END_TAG(NAME='VTKFile')
   CALL SELF%CLOSE_XML_FILE
   ERROR = SELF%ERROR
   ENDFUNCTION FINALIZE

  ! W_DATA METHODS
  FUNCTION W_DATA1_RANK1_R8P(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (R8P).
  CLASS(XML_WRITER_ASCII_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),                  INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  REAL(R8P),                     INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
  LOGICAL,                       INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                        :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                        :: N_COMPONENTS !< NUMBER OF COMPONENTS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: CODE         !< DATA VARIABLE ENCODED, ASCII OR BASE64 CODEC.

  DATA_TYPE = 'Float64'
  N_COMPONENTS = 1
  CODE = ENCODE_ASCII_DATAARRAY(X=X)
  CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                IS_TUPLES=IS_TUPLES)
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA1_RANK1_R8P

  FUNCTION W_DATA1_RANK1_R4P(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (R4P).
  CLASS(XML_WRITER_ASCII_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),                  INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  REAL(R4P),                     INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
  LOGICAL,                       INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                        :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                        :: N_COMPONENTS !< NUMBER OF COMPONENTS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: CODE         !< DATA VARIABLE ENCODED, ASCII OR BASE64 CODEC.

  DATA_TYPE = 'Float32'
  N_COMPONENTS = 1
  CODE = ENCODE_ASCII_DATAARRAY(X=X)
  CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                IS_TUPLES=IS_TUPLES)
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA1_RANK1_R4P

  FUNCTION W_DATA1_RANK1_I8P(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (I8P).
  CLASS(XML_WRITER_ASCII_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),                  INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I8P),                  INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
  LOGICAL,                       INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                        :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                        :: N_COMPONENTS !< NUMBER OF COMPONENTS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: CODE         !< DATA VARIABLE ENCODED, ASCII OR BASE64 CODEC.

  DATA_TYPE = 'Int64'
  N_COMPONENTS = 1
  CODE = ENCODE_ASCII_DATAARRAY(X=X)
  CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                IS_TUPLES=IS_TUPLES)
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA1_RANK1_I8P

  FUNCTION W_DATA1_RANK1_I4P(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (I4P).
  CLASS(XML_WRITER_ASCII_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),                  INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I4P),                  INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
  LOGICAL,                       INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                        :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                        :: N_COMPONENTS !< NUMBER OF COMPONENTS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: CODE         !< DATA VARIABLE ENCODED, ASCII OR BASE64 CODEC.

  DATA_TYPE = 'Int32'
  N_COMPONENTS = 1
  CODE = ENCODE_ASCII_DATAARRAY(X=X)
  CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                IS_TUPLES=IS_TUPLES)
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA1_RANK1_I4P

  FUNCTION W_DATA1_RANK1_I2P(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (I2P).
  CLASS(XML_WRITER_ASCII_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),                  INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I2P),                  INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
  LOGICAL,                       INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                        :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                        :: N_COMPONENTS !< NUMBER OF COMPONENTS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: CODE         !< DATA VARIABLE ENCODED, ASCII OR BASE64 CODEC.

  DATA_TYPE = 'Int16'
  N_COMPONENTS = 1
  CODE = ENCODE_ASCII_DATAARRAY(X=X)
  CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                IS_TUPLES=IS_TUPLES)
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA1_RANK1_I2P

  FUNCTION W_DATA1_RANK1_I1P(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (I1P).
  CLASS(XML_WRITER_ASCII_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),                  INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I1P),                  INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
  LOGICAL,                       INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                        :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                        :: N_COMPONENTS !< NUMBER OF COMPONENTS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: CODE         !< DATA VARIABLE ENCODED, ASCII OR BASE64 CODEC.

  DATA_TYPE = 'Int8'
  N_COMPONENTS = 1
  CODE = ENCODE_ASCII_DATAARRAY(X=X)
  CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                IS_TUPLES=IS_TUPLES)
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA1_RANK1_I1P

  FUNCTION W_DATA3_RANK1_R8P(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (R8P).
  CLASS(XML_WRITER_ASCII_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),                  INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  REAL(R8P),                     INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
  REAL(R8P),                     INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
  REAL(R8P),                     INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
  LOGICAL,                       INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                        :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                        :: N_COMPONENTS !< NUMBER OF COMPONENTS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: CODE         !< DATA VARIABLE ENCODED, ASCII OR BASE64 CODEC.

  DATA_TYPE = 'Float64'
  N_COMPONENTS = 3
  CODE = ENCODE_ASCII_DATAARRAY(X=X, Y=Y, Z=Z)
  CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                IS_TUPLES=IS_TUPLES)
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA3_RANK1_R8P

  FUNCTION W_DATA3_RANK1_R4P(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (R4P).
  CLASS(XML_WRITER_ASCII_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),                  INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  REAL(R4P),                     INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
  REAL(R4P),                     INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
  REAL(R4P),                     INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
  LOGICAL,                       INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                        :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                        :: N_COMPONENTS !< NUMBER OF COMPONENTS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: CODE         !< DATA VARIABLE ENCODED, ASCII OR BASE64 CODEC.

  DATA_TYPE = 'Float32'
  N_COMPONENTS = 3
  CODE = ENCODE_ASCII_DATAARRAY(X=X, Y=Y, Z=Z)
  CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                IS_TUPLES=IS_TUPLES)
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA3_RANK1_R4P

  FUNCTION W_DATA3_RANK1_I8P(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (I8P).
  CLASS(XML_WRITER_ASCII_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),                  INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I8P),                  INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
  INTEGER(I8P),                  INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
  INTEGER(I8P),                  INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
  LOGICAL,                       INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                        :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                        :: N_COMPONENTS !< NUMBER OF COMPONENTS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: CODE         !< DATA VARIABLE ENCODED, ASCII OR BASE64 CODEC.

  DATA_TYPE = 'Int64'
  N_COMPONENTS = 3
  CODE = ENCODE_ASCII_DATAARRAY(X=X, Y=Y, Z=Z)
  CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                IS_TUPLES=IS_TUPLES)
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA3_RANK1_I8P

  FUNCTION W_DATA3_RANK1_I4P(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (I4P).
  CLASS(XML_WRITER_ASCII_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),                  INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I4P),                  INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
  INTEGER(I4P),                  INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
  INTEGER(I4P),                  INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
  LOGICAL,                       INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                        :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                        :: N_COMPONENTS !< NUMBER OF COMPONENTS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: CODE         !< DATA VARIABLE ENCODED, ASCII OR BASE64 CODEC.

  DATA_TYPE = 'Int32'
  N_COMPONENTS = 3
  CODE = ENCODE_ASCII_DATAARRAY(X=X, Y=Y, Z=Z)
  CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                IS_TUPLES=IS_TUPLES)
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA3_RANK1_I4P

  FUNCTION W_DATA3_RANK1_I2P(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (I2P).
  CLASS(XML_WRITER_ASCII_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),                  INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I2P),                  INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
  INTEGER(I2P),                  INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
  INTEGER(I2P),                  INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
  LOGICAL,                       INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                        :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                        :: N_COMPONENTS !< NUMBER OF COMPONENTS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: CODE         !< DATA VARIABLE ENCODED, ASCII OR BASE64 CODEC.

  DATA_TYPE = 'Int16'
  N_COMPONENTS = 3
  CODE = ENCODE_ASCII_DATAARRAY(X=X, Y=Y, Z=Z)
  CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                IS_TUPLES=IS_TUPLES)
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA3_RANK1_I2P

  FUNCTION W_DATA3_RANK1_I1P(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (I1P).
  CLASS(XML_WRITER_ASCII_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),                  INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I1P),                  INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
  INTEGER(I1P),                  INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
  INTEGER(I1P),                  INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
  LOGICAL,                       INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
  INTEGER(I4P)                                        :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                        :: N_COMPONENTS !< NUMBER OF COMPONENTS.
  CHARACTER(LEN=:), ALLOCATABLE                       :: CODE         !< DATA VARIABLE ENCODED, ASCII OR BASE64 CODEC.

  DATA_TYPE = 'Int8'
  N_COMPONENTS = 3
  CODE = ENCODE_ASCII_DATAARRAY(X=X, Y=Y, Z=Z)
  CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                IS_TUPLES=IS_TUPLES)
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA3_RANK1_I1P

  SUBROUTINE W_DATA_APPENDED(SELF)
  !< DO NOTHING, ASCII DATA CANNOT BE APPENDED.
  CLASS(XML_WRITER_ASCII_LOCAL), INTENT(INOUT) :: SELF !< WRITER.
  INTEGER(I4P)                                        :: ERROR        !< ERROR STATUS.
  ERROR = SELF%ERROR
  ENDSUBROUTINE W_DATA_APPENDED
ENDMODULE VTKF_FILE_XML_WRITER_ASCII_LOCAL






!< VTK FILE XML WRITER, APPENDED.
MODULE VTKF_FILE_XML_WRITER_APPENDED
!< VTK FILE XML WRITER, APPENDED.
USE PENF
USE STRINGIFOR
USE VTK_FORTRAN_DATAARRAY_ENCODER
USE VTK_FORTRAN_PARAMETERS
USE VTKF_FILE_XML_WRITER_ABSTRACT

IMPLICIT NONE
PRIVATE
PUBLIC :: XML_WRITER_APPENDED

TYPE, EXTENDS(XML_WRITER_ABSTRACT) :: XML_WRITER_APPENDED
  !< VTK FILE XML WRITER, APPENDED.
  TYPE(STRING) :: ENCODING      !< APPENDED DATA ENCODING: "RAW" OR "BASE64".
  INTEGER(I4P) :: SCRATCH=0_I4P !< SCRATCH LOGICAL UNIT.
  CONTAINS
    ! DEFERRED METHODS
    PROCEDURE, PASS(SELF) :: INITIALIZE                 !< INITIALIZE WRITER.
    PROCEDURE, PASS(SELF) :: FINALIZE                   !< FINALIZE WRITER.
    PROCEDURE, PASS(SELF) :: W_DATA1_RANK1_R8P !< WRITE DATAARRAY 1, RANK 1, R8P.
    PROCEDURE, PASS(SELF) :: W_DATA1_RANK1_R4P !< WRITE DATAARRAY 1, RANK 1, R4P.
    PROCEDURE, PASS(SELF) :: W_DATA1_RANK1_I8P !< WRITE DATAARRAY 1, RANK 1, I8P.
    PROCEDURE, PASS(SELF) :: W_DATA1_RANK1_I4P !< WRITE DATAARRAY 1, RANK 1, I4P.
    PROCEDURE, PASS(SELF) :: W_DATA1_RANK1_I2P !< WRITE DATAARRAY 1, RANK 1, I2P.
    PROCEDURE, PASS(SELF) :: W_DATA1_RANK1_I1P !< WRITE DATAARRAY 1, RANK 1, I1P.
    PROCEDURE, PASS(SELF) :: W_DATA3_RANK1_R8P !< WRITE DATAARRAY 3, RANK 1, R8P.
    PROCEDURE, PASS(SELF) :: W_DATA3_RANK1_R4P !< WRITE DATAARRAY 3, RANK 1, R4P.
    PROCEDURE, PASS(SELF) :: W_DATA3_RANK1_I8P !< WRITE DATAARRAY 3, RANK 1, I8P.
    PROCEDURE, PASS(SELF) :: W_DATA3_RANK1_I4P !< WRITE DATAARRAY 3, RANK 1, I4P.
    PROCEDURE, PASS(SELF) :: W_DATA3_RANK1_I2P !< WRITE DATAARRAY 3, RANK 1, I2P.
    PROCEDURE, PASS(SELF) :: W_DATA3_RANK1_I1P !< WRITE DATAARRAY 3, RANK 1, I1P.
    PROCEDURE, PASS(SELF) :: W_DATA_APPENDED   !< WRITE APPENDED.
    ! PRIVATE METHODS
    PROCEDURE, PASS(SELF), PRIVATE :: IOFFSET_UPDATE     !< UPDATE IOFFSET COUNT.
    PROCEDURE, PASS(SELF), PRIVATE :: OPEN_SCRATCH_FILE  !< OPEN SCRATCH FILE.
    PROCEDURE, PASS(SELF), PRIVATE :: CLOSE_SCRATCH_FILE !< CLOSE SCRATCH FILE.
    GENERIC, PRIVATE :: WRITE_ON_SCRATCH_DATAARRAY =>          &
                        WRITE_ON_SCRATCH_DATAARRAY1_RANK1,     &
                        WRITE_ON_SCRATCH_DATAARRAY3_RANK1_R8P, &
                        WRITE_ON_SCRATCH_DATAARRAY3_RANK1_R4P, &
                        WRITE_ON_SCRATCH_DATAARRAY3_RANK1_I8P, &
                        WRITE_ON_SCRATCH_DATAARRAY3_RANK1_I4P, &
                        WRITE_ON_SCRATCH_DATAARRAY3_RANK1_I2P, &
                        WRITE_ON_SCRATCH_DATAARRAY3_RANK1_I1P
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_ON_SCRATCH_DATAARRAY1_RANK1     !< WRITE DATAARRAY, DATA 1 RANK 1.
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_ON_SCRATCH_DATAARRAY3_RANK1_R8P !< WRITE DATAARRAY, COMP 3 RANK 1, R8P.
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_ON_SCRATCH_DATAARRAY3_RANK1_R4P !< WRITE DATAARRAY, COMP 3 RANK 1, R4P.
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_ON_SCRATCH_DATAARRAY3_RANK1_I8P !< WRITE DATAARRAY, COMP 3 RANK 1, I8P.
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_ON_SCRATCH_DATAARRAY3_RANK1_I4P !< WRITE DATAARRAY, COMP 3 RANK 1, I4P.
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_ON_SCRATCH_DATAARRAY3_RANK1_I2P !< WRITE DATAARRAY, COMP 3 RANK 1, I2P.
    PROCEDURE, PASS(SELF), PRIVATE :: WRITE_ON_SCRATCH_DATAARRAY3_RANK1_I1P !< WRITE DATAARRAY, COMP 3 RANK 1, I1P.
ENDTYPE XML_WRITER_APPENDED
CONTAINS
  FUNCTION INITIALIZE(SELF, FORMAT, FILENAME, MESH_TOPOLOGY, NX1, NX2, NY1, NY2, NZ1, NZ2, &
                      IS_VOLATILE, MESH_KIND) RESULT(ERROR)
  !< INITIALIZE WRITER.
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT)        :: SELF          !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: FORMAT        !< FILE FORMAT: ASCII.
  CHARACTER(*),               INTENT(IN)           :: FILENAME      !< FILE NAME.
  CHARACTER(*),               INTENT(IN)           :: MESH_TOPOLOGY !< MESH TOPOLOGY.
  INTEGER(I4P),               INTENT(IN), OPTIONAL :: NX1           !< INITIAL NODE OF X AXIS.
  INTEGER(I4P),               INTENT(IN), OPTIONAL :: NX2           !< FINAL NODE OF X AXIS.
  INTEGER(I4P),               INTENT(IN), OPTIONAL :: NY1           !< INITIAL NODE OF Y AXIS.
  INTEGER(I4P),               INTENT(IN), OPTIONAL :: NY2           !< FINAL NODE OF Y AXIS.
  INTEGER(I4P),               INTENT(IN), OPTIONAL :: NZ1           !< INITIAL NODE OF Z AXIS.
  INTEGER(I4P),               INTENT(IN), OPTIONAL :: NZ2           !< FINAL NODE OF Z AXIS.
  CHARACTER(*),               INTENT(IN), OPTIONAL :: MESH_KIND     !< KIND OF MESH DATA: FLOAT64, FLOAT32, ECC.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_VOLATILE   !< FLAG TO CHECK VOLATILE WRITER.
  INTEGER(I4P)                                     :: ERROR         !< ERROR STATUS.
  IF (IS_VOLATILE) THEN
  ENDIF
  SELF%TOPOLOGY = TRIM(ADJUSTL(MESH_TOPOLOGY))
  SELF%FORMAT_CH = 'appended'
  SELF%ENCODING = FORMAT
  SELF%ENCODING = SELF%ENCODING%UPPER()
  SELECT CASE(SELF%ENCODING%CHARS())
  CASE('raw')
    SELF%ENCODING = 'raw'
  CASE('binary-appended')
    SELF%ENCODING = 'base64'
  ENDSELECT
  CALL SELF%OPEN_XML_FILE(FILENAME=FILENAME)
  CALL SELF%WRITE_HEADER_TAG
  CALL SELF%WRITE_TOPOLOGY_TAG(NX1=NX1, NX2=NX2, NY1=NY1, NY2=NY2, NZ1=NZ1, NZ2=NZ2, MESH_KIND=MESH_KIND)
  SELF%IOFFSET = 0
  CALL SELF%OPEN_SCRATCH_FILE
  ERROR = SELF%ERROR
  ENDFUNCTION INITIALIZE

   FUNCTION FINALIZE(SELF) RESULT(ERROR)
   !< FINALIZE WRITER.
   CLASS(XML_WRITER_APPENDED), INTENT(INOUT) :: SELF  !< WRITER.
   INTEGER(I4P)                              :: ERROR !< ERROR STATUS.

   CALL SELF%WRITE_END_TAG(NAME=SELF%TOPOLOGY%CHARS())
   CALL SELF%W_DATA_APPENDED
   CALL SELF%WRITE_END_TAG(NAME='VTKFile')
   CALL SELF%CLOSE_XML_FILE
   CALL SELF%CLOSE_SCRATCH_FILE
   ERROR = SELF%ERROR
   ENDFUNCTION FINALIZE

  ELEMENTAL SUBROUTINE IOFFSET_UPDATE(SELF, N_BYTE)
  !< UPDATE IOFFSET COUNT.
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT) :: SELF  !< WRITER.
  INTEGER(I4P),               INTENT(IN)    :: N_BYTE !< NUMBER OF BYTES SAVED.

  IF (SELF%ENCODING=='raw') THEN
    SELF%IOFFSET = SELF%IOFFSET + BYI4P + N_BYTE
  ELSE
    SELF%IOFFSET = SELF%IOFFSET + ((N_BYTE + BYI4P + 2_I4P)/3_I4P)*4_I4P
  ENDIF
  ENDSUBROUTINE IOFFSET_UPDATE

  SUBROUTINE OPEN_SCRATCH_FILE(SELF)
  !< OPEN SCRATCH FILE.
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT) :: SELF  !< WRITER.

  OPEN(NEWUNIT=SELF%SCRATCH, &
       FORM='UNFORMATTED',   &
       ACCESS='STREAM',      &
       ACTION='READWRITE',   &
       STATUS='SCRATCH',     &
       IOSTAT=SELF%ERROR)
  ENDSUBROUTINE OPEN_SCRATCH_FILE

  SUBROUTINE CLOSE_SCRATCH_FILE(SELF)
  !< CLOSE SCRATCH FILE.
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT) :: SELF  !< WRITER.

  CLOSE(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)
  ENDSUBROUTINE CLOSE_SCRATCH_FILE

  ! W_DATA METHODS
  FUNCTION W_DATA1_RANK1_R8P(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (R8P).
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  REAL(R8P),                  INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                    :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                     :: N_COMPONENTS !< NUMBER OF COMPONENTS.

  DATA_TYPE = 'Float64'
  N_COMPONENTS = 1
  CALL SELF%W_DATA_TAG_APPENDED(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, &
                                         IS_TUPLES=IS_TUPLES)
  CALL SELF%IOFFSET_UPDATE(N_BYTE=SELF%WRITE_ON_SCRATCH_DATAARRAY(X=X))
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA1_RANK1_R8P

  FUNCTION W_DATA1_RANK1_R4P(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (R4P).
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  REAL(R4P),                  INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                    :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                     :: N_COMPONENTS !< NUMBER OF COMPONENTS.

  DATA_TYPE = 'Float32'
  N_COMPONENTS = 1
  CALL SELF%W_DATA_TAG_APPENDED(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, &
                                         IS_TUPLES=IS_TUPLES)
  CALL SELF%IOFFSET_UPDATE(N_BYTE=SELF%WRITE_ON_SCRATCH_DATAARRAY(X=X))
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA1_RANK1_R4P

  FUNCTION W_DATA1_RANK1_I8P(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (I8P).
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I8P),               INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                    :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                     :: N_COMPONENTS !< NUMBER OF COMPONENTS.

  DATA_TYPE = 'Int64'
  N_COMPONENTS = 1
  CALL SELF%W_DATA_TAG_APPENDED(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, &
                                         IS_TUPLES=IS_TUPLES)
  CALL SELF%IOFFSET_UPDATE(N_BYTE=SELF%WRITE_ON_SCRATCH_DATAARRAY(X=X))
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA1_RANK1_I8P

  FUNCTION W_DATA1_RANK1_I4P(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (I4P).
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I4P),               INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                    :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                     :: N_COMPONENTS !< NUMBER OF COMPONENTS.

  DATA_TYPE = 'Int32'
  N_COMPONENTS = 1
  CALL SELF%W_DATA_TAG_APPENDED(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, &
                                         IS_TUPLES=IS_TUPLES)
  CALL SELF%IOFFSET_UPDATE(N_BYTE=SELF%WRITE_ON_SCRATCH_DATAARRAY(X=X))
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA1_RANK1_I4P

  FUNCTION W_DATA1_RANK1_I2P(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (I2P).
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I2P),               INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                    :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                     :: N_COMPONENTS !< NUMBER OF COMPONENTS.

  DATA_TYPE = 'Int16'
  N_COMPONENTS = 1
  CALL SELF%W_DATA_TAG_APPENDED(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, &
                                         IS_TUPLES=IS_TUPLES)
  CALL SELF%IOFFSET_UPDATE(N_BYTE=SELF%WRITE_ON_SCRATCH_DATAARRAY(X=X))
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA1_RANK1_I2P

  FUNCTION W_DATA1_RANK1_I1P(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (I1P).
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I1P),               INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                    :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                     :: N_COMPONENTS !< NUMBER OF COMPONENTS.

  DATA_TYPE = 'Int8'
  N_COMPONENTS = 1
  CALL SELF%W_DATA_TAG_APPENDED(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, &
                                         IS_TUPLES=IS_TUPLES)
  CALL SELF%IOFFSET_UPDATE(N_BYTE=SELF%WRITE_ON_SCRATCH_DATAARRAY(X=X))
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA1_RANK1_I1P

  FUNCTION W_DATA3_RANK1_R8P(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (R8P).
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  REAL(R8P),                  INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
  REAL(R8P),                  INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
  REAL(R8P),                  INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD "NUMBEROFCOMPONENTS" ATTRIBUTE.
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                    :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                     :: N_COMPONENTS !< NUMBER OF COMPONENTS.

  DATA_TYPE = 'Float64'
  N_COMPONENTS = 3
  CALL SELF%W_DATA_TAG_APPENDED(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, &
                                         IS_TUPLES=IS_TUPLES)
  CALL SELF%IOFFSET_UPDATE(N_BYTE=SELF%WRITE_ON_SCRATCH_DATAARRAY(X=X, Y=Y, Z=Z))
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA3_RANK1_R8P

  FUNCTION W_DATA3_RANK1_R4P(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (R4P).
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  REAL(R4P),                  INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
  REAL(R4P),                  INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
  REAL(R4P),                  INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                    :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                     :: N_COMPONENTS !< NUMBER OF COMPONENTS.

  DATA_TYPE = 'Float32'
  N_COMPONENTS = 3
  CALL SELF%W_DATA_TAG_APPENDED(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, &
                                         IS_TUPLES=IS_TUPLES)
  CALL SELF%IOFFSET_UPDATE(N_BYTE=SELF%WRITE_ON_SCRATCH_DATAARRAY(X=X, Y=Y, Z=Z))
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA3_RANK1_R4P

  FUNCTION W_DATA3_RANK1_I8P(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (I8P).
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I8P),               INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
  INTEGER(I8P),               INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
  INTEGER(I8P),               INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                    :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                     :: N_COMPONENTS !< NUMBER OF COMPONENTS.

  DATA_TYPE = 'Int64'
  N_COMPONENTS = 3
  CALL SELF%W_DATA_TAG_APPENDED(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, &
                                         IS_TUPLES=IS_TUPLES)
  CALL SELF%IOFFSET_UPDATE(N_BYTE=SELF%WRITE_ON_SCRATCH_DATAARRAY(X=X, Y=Y, Z=Z))
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA3_RANK1_I8P

  FUNCTION W_DATA3_RANK1_I4P(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (I4P).
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I4P),               INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
  INTEGER(I4P),               INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
  INTEGER(I4P),               INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                    :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                     :: N_COMPONENTS !< NUMBER OF COMPONENTS.

  DATA_TYPE = 'Int32'
  N_COMPONENTS = 3
  CALL SELF%W_DATA_TAG_APPENDED(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, &
                                         IS_TUPLES=IS_TUPLES)
  CALL SELF%IOFFSET_UPDATE(N_BYTE=SELF%WRITE_ON_SCRATCH_DATAARRAY(X=X, Y=Y, Z=Z))
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA3_RANK1_I4P

  FUNCTION W_DATA3_RANK1_I2P(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (I2P).
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I2P),               INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
  INTEGER(I2P),               INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
  INTEGER(I2P),               INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                    :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                     :: N_COMPONENTS !< NUMBER OF COMPONENTS.

  DATA_TYPE = 'Int16'
  N_COMPONENTS = 3
  CALL SELF%W_DATA_TAG_APPENDED(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, &
                                         IS_TUPLES=IS_TUPLES)
  CALL SELF%IOFFSET_UPDATE(N_BYTE=SELF%WRITE_ON_SCRATCH_DATAARRAY(X=X, Y=Y, Z=Z))
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA3_RANK1_I2P

  FUNCTION W_DATA3_RANK1_I1P(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
  !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (I1P).
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT)        :: SELF         !< WRITER.
  CHARACTER(*),               INTENT(IN)           :: DATA_NAME    !< DATA NAME.
  INTEGER(I1P),               INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
  INTEGER(I1P),               INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
  INTEGER(I1P),               INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
  LOGICAL,                    INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES".
  INTEGER(I4P)                                     :: ERROR        !< ERROR STATUS.
  CHARACTER(LEN=:), ALLOCATABLE                    :: DATA_TYPE    !< DATA TYPE.
  INTEGER(I4P)                                     :: N_COMPONENTS !< NUMBER OF COMPONENTS.

  DATA_TYPE = 'Int8'
  N_COMPONENTS = 3
  CALL SELF%W_DATA_TAG_APPENDED(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, &
                                         IS_TUPLES=IS_TUPLES)
  CALL SELF%IOFFSET_UPDATE(N_BYTE=SELF%WRITE_ON_SCRATCH_DATAARRAY(X=X, Y=Y, Z=Z))
  ERROR = SELF%ERROR
  ENDFUNCTION W_DATA3_RANK1_I1P

  SUBROUTINE W_DATA_APPENDED(SELF)
  !< DO NOTHING, ASCII DATA CANNOT BE APPENDED.
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT) :: SELF              !< WRITER.
  TYPE(STRING)                              :: TAG_ATTRIBUTES    !< TAG ATTRIBUTES.
  INTEGER(I4P)                              :: N_BYTE            !< BYTES COUNT.
  CHARACTER(LEN=2)                          :: DATAARRAY_TYPE    !< DATAARRAY TYPE = R8,R4,I8,I4,I2,I1.
  INTEGER(I4P)                              :: DATAARRAY_DIM     !< DATAARRAY DIMENSION.
  REAL(R8P),    ALLOCATABLE                 :: DATAARRAY_R8P(:)  !< DATAARRAY BUFFER OF R8P.
  REAL(R4P),    ALLOCATABLE                 :: DATAARRAY_R4P(:)  !< DATAARRAY BUFFER OF R4P.
  INTEGER(I8P), ALLOCATABLE                 :: DATAARRAY_I8P(:)  !< DATAARRAY BUFFER OF I8P.
  INTEGER(I4P), ALLOCATABLE                 :: DATAARRAY_I4P(:)  !< DATAARRAY BUFFER OF I4P.
  INTEGER(I2P), ALLOCATABLE                 :: DATAARRAY_I2P(:)  !< DATAARRAY BUFFER OF I2P.
  INTEGER(I1P), ALLOCATABLE                 :: DATAARRAY_I1P(:)  !< DATAARRAY BUFFER OF I1P.
  TAG_ATTRIBUTES=""
  CALL SELF%WRITE_START_TAG(NAME='AppendedData', ATTRIBUTES='encoding="'//SELF%ENCODING%CHARS()//'"')
  WRITE(UNIT=SELF%XML, IOSTAT=SELF%ERROR)'_'
  ENDFILE(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)
  REWIND(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)
  DO
    CALL READ_DATAARRAY_FROM_SCRATCH
    IF (SELF%ERROR==0) CALL W_DATA_ON_XML
    IF (IS_IOSTAT_END(SELF%ERROR)) EXIT
  ENDDO
  CLOSE(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)
  WRITE(UNIT=SELF%XML, IOSTAT=SELF%ERROR)END_REC
  CALL SELF%WRITE_END_TAG(NAME='AppendedData')
  CONTAINS
    SUBROUTINE READ_DATAARRAY_FROM_SCRATCH
    !< READ THE CURRENT DATAARAY FROM SCRATCH FILE.

    READ(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR, END=10)N_BYTE, DATAARRAY_TYPE, DATAARRAY_DIM
    SELECT CASE(DATAARRAY_TYPE)
    CASE('R8')
      IF (ALLOCATED(DATAARRAY_R8P)) DEALLOCATE(DATAARRAY_R8P) ; ALLOCATE(DATAARRAY_R8P(1:DATAARRAY_DIM))
      READ(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)DATAARRAY_R8P
    CASE('R4')
      IF (ALLOCATED(DATAARRAY_R4P)) DEALLOCATE(DATAARRAY_R4P) ; ALLOCATE(DATAARRAY_R4P(1:DATAARRAY_DIM))
      READ(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)DATAARRAY_R4P
    CASE('I8')
      IF (ALLOCATED(DATAARRAY_I8P)) DEALLOCATE(DATAARRAY_I8P) ; ALLOCATE(DATAARRAY_I8P(1:DATAARRAY_DIM))
      READ(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)DATAARRAY_I8P
    CASE('I4')
      IF (ALLOCATED(DATAARRAY_I4P)) DEALLOCATE(DATAARRAY_I4P) ; ALLOCATE(DATAARRAY_I4P(1:DATAARRAY_DIM))
      READ(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)DATAARRAY_I4P
    CASE('I2')
      IF (ALLOCATED(DATAARRAY_I2P)) DEALLOCATE(DATAARRAY_I2P) ; ALLOCATE(DATAARRAY_I2P(1:DATAARRAY_DIM))
      READ(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)DATAARRAY_I2P
    CASE('I1')
      IF (ALLOCATED(DATAARRAY_I1P)) DEALLOCATE(DATAARRAY_I1P) ; ALLOCATE(DATAARRAY_I1P(1:DATAARRAY_DIM))
      READ(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)DATAARRAY_I1P
    CASE DEFAULT
      SELF%ERROR = 1
      WRITE (STDERR,'(A)')' ERROR: BAD DATAARRAY_TYPE = '//DATAARRAY_TYPE
      WRITE (STDERR,'(A)')' BYTES = '//TRIM(STR(N=N_BYTE))
      WRITE (STDERR,'(A)')' DATAARRAY DIMENSION = '//TRIM(STR(N=DATAARRAY_DIM))
    ENDSELECT
    10 RETURN
    ENDSUBROUTINE READ_DATAARRAY_FROM_SCRATCH

    SUBROUTINE W_DATA_ON_XML
    !< WRITE THE CURRENT DATAARAY ON XML FILE.
    CHARACTER(LEN=:), ALLOCATABLE  :: CODE !< DATAARRAY ENCODED WITH BASE64 CODEC.

    IF (SELF%ENCODING=='raw') THEN
      SELECT CASE(DATAARRAY_TYPE)
      CASE('R8')
        WRITE(UNIT=SELF%XML, IOSTAT=SELF%ERROR)N_BYTE, DATAARRAY_R8P
        DEALLOCATE(DATAARRAY_R8P)
      CASE('R4')
        WRITE(UNIT=SELF%XML, IOSTAT=SELF%ERROR)N_BYTE, DATAARRAY_R4P
        DEALLOCATE(DATAARRAY_R4P)
      CASE('I8')
        WRITE(UNIT=SELF%XML, IOSTAT=SELF%ERROR)N_BYTE, DATAARRAY_I8P
        DEALLOCATE(DATAARRAY_I8P)
      CASE('I4')
        WRITE(UNIT=SELF%XML, IOSTAT=SELF%ERROR)N_BYTE, DATAARRAY_I4P
        DEALLOCATE(DATAARRAY_I4P)
      CASE('I2')
        WRITE(UNIT=SELF%XML, IOSTAT=SELF%ERROR)N_BYTE, DATAARRAY_I2P
        DEALLOCATE(DATAARRAY_I2P)
      CASE('I1')
        WRITE(UNIT=SELF%XML, IOSTAT=SELF%ERROR)N_BYTE, DATAARRAY_I1P
        DEALLOCATE(DATAARRAY_I1P)
      ENDSELECT
    ELSE
      SELECT CASE(DATAARRAY_TYPE)
      CASE('R8')
        CODE = ENCODE_BINARY_DATAARRAY(X=DATAARRAY_R8P)
        WRITE(UNIT=SELF%XML, IOSTAT=SELF%ERROR)CODE
      CASE('R4')
        CODE = ENCODE_BINARY_DATAARRAY(X=DATAARRAY_R4P)
        WRITE(UNIT=SELF%XML, IOSTAT=SELF%ERROR)CODE
      CASE('I8')
        CODE = ENCODE_BINARY_DATAARRAY(X=DATAARRAY_I8P)
        WRITE(UNIT=SELF%XML, IOSTAT=SELF%ERROR)CODE
      CASE('I4')
        CODE = ENCODE_BINARY_DATAARRAY(X=DATAARRAY_I4P)
        WRITE(UNIT=SELF%XML, IOSTAT=SELF%ERROR)CODE
      CASE('I2')
        CODE = ENCODE_BINARY_DATAARRAY(X=DATAARRAY_I2P)
        WRITE(UNIT=SELF%XML, IOSTAT=SELF%ERROR)CODE
      CASE('I1')
        CODE = ENCODE_BINARY_DATAARRAY(X=DATAARRAY_I1P)
        WRITE(UNIT=SELF%XML, IOSTAT=SELF%ERROR)CODE
      ENDSELECT
    ENDIF
    ENDSUBROUTINE W_DATA_ON_XML
  ENDSUBROUTINE W_DATA_APPENDED

  ! WRITE_ON_SCRATCH_DATAARRAY METHODS
  FUNCTION WRITE_ON_SCRATCH_DATAARRAY1_RANK1(SELF, X) RESULT(N_BYTE)
  !< WRITE A DATAARRAY WITH 1 COMPONENTS OF RANK 1.
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT) :: SELF   !< WRITER.
  CLASS(*),                   INTENT(IN)    :: X(1:)  !< DATA VARIABLE.
  INTEGER(I4P)                              :: N_BYTE !< NUMBER OF BYTES
  INTEGER(I4P)                              :: NN     !< NUMBER OF ELEMENTS.

  NN = SIZE(X, DIM=1)
  SELECT TYPE(X)
  TYPE IS(REAL(R8P))
    N_BYTE = INT(NN*BYR8P,I4P)
    WRITE(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)N_BYTE, 'R8', NN
    WRITE(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)X
  TYPE IS(REAL(R4P))
    N_BYTE = INT(NN*BYR4P,I4P)
    WRITE(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)N_BYTE, 'R4', NN
    WRITE(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)X
  TYPE IS(INTEGER(I8P))
    N_BYTE = INT(NN*BYI8P,I4P)
    WRITE(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)N_BYTE, 'I8', NN
    WRITE(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)X
  TYPE IS(INTEGER(I4P))
    N_BYTE = INT(NN*BYI4P,I4P)
    WRITE(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)N_BYTE, 'I4', NN
    WRITE(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)X
  TYPE IS(INTEGER(I2P))
    N_BYTE = INT(NN*BYI2P,I4P)
    WRITE(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)N_BYTE, 'I2', NN
    WRITE(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)X
  TYPE IS(INTEGER(I1P))
    N_BYTE = INT(NN*BYI1P,I4P)
    WRITE(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)N_BYTE, 'I1', NN
    WRITE(UNIT=SELF%SCRATCH, IOSTAT=SELF%ERROR)X
  ENDSELECT
  ENDFUNCTION WRITE_ON_SCRATCH_DATAARRAY1_RANK1

  FUNCTION WRITE_ON_SCRATCH_DATAARRAY3_RANK1_R8P(SELF, X, Y, Z) RESULT(N_BYTE)
  !< WRITE A DATAARRAY WITH 3 COMPONENTS OF RANK 1 (R8P).
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT) :: SELF   !< WRITER.
  REAL(R8P),                  INTENT(IN)    :: X(1:)  !< X COMPONENT.
  REAL(R8P),                  INTENT(IN)    :: Y(1:)  !< Y COMPONENT.
  REAL(R8P),                  INTENT(IN)    :: Z(1:)  !< Z COMPONENT.
  INTEGER(I4P)                              :: N_BYTE !< NUMBER OF BYTES
  INTEGER(I4P)                              :: N      !< COUNTER.

  N_BYTE = SELF%WRITE_ON_SCRATCH_DATAARRAY(X=[(X(N), Y(N), Z(N), N=1,SIZE(X, DIM=1))])
  ENDFUNCTION WRITE_ON_SCRATCH_DATAARRAY3_RANK1_R8P

  FUNCTION WRITE_ON_SCRATCH_DATAARRAY3_RANK1_R4P(SELF, X, Y, Z) RESULT(N_BYTE)
  !< WRITE A DATAARRAY WITH 3 COMPONENTS OF RANK 1 (R4P).
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT) :: SELF   !< WRITER.
  REAL(R4P),                  INTENT(IN)    :: X(1:)  !< X COMPONENT.
  REAL(R4P),                  INTENT(IN)    :: Y(1:)  !< Y COMPONENT.
  REAL(R4P),                  INTENT(IN)    :: Z(1:)  !< Z COMPONENT.
  INTEGER(I4P)                              :: N_BYTE !< NUMBER OF BYTES
  INTEGER(I4P)                              :: N      !< COUNTER.

  N_BYTE = SELF%WRITE_ON_SCRATCH_DATAARRAY(X=[(X(N), Y(N), Z(N), N=1,SIZE(X, DIM=1))])
  ENDFUNCTION WRITE_ON_SCRATCH_DATAARRAY3_RANK1_R4P

  FUNCTION WRITE_ON_SCRATCH_DATAARRAY3_RANK1_I8P(SELF, X, Y, Z) RESULT(N_BYTE)
  !< WRITE A DATAARRAY WITH 3 COMPONENTS OF RANK 1 (I8P).
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT) :: SELF   !< WRITER.
  INTEGER(I8P),               INTENT(IN)    :: X(1:)  !< X COMPONENT.
  INTEGER(I8P),               INTENT(IN)    :: Y(1:)  !< Y COMPONENT.
  INTEGER(I8P),               INTENT(IN)    :: Z(1:)  !< Z COMPONENT.
  INTEGER(I4P)                              :: N_BYTE !< NUMBER OF BYTES
  INTEGER(I4P)                              :: N      !< COUNTER.

  N_BYTE = SELF%WRITE_ON_SCRATCH_DATAARRAY(X=[(X(N), Y(N), Z(N), N=1,SIZE(X, DIM=1))])
  ENDFUNCTION WRITE_ON_SCRATCH_DATAARRAY3_RANK1_I8P

  FUNCTION WRITE_ON_SCRATCH_DATAARRAY3_RANK1_I4P(SELF, X, Y, Z) RESULT(N_BYTE)
  !< WRITE A DATAARRAY WITH 3 COMPONENTS OF RANK 1 (I4P).
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT) :: SELF   !< WRITER.
  INTEGER(I4P),               INTENT(IN)    :: X(1:)  !< X COMPONENT.
  INTEGER(I4P),               INTENT(IN)    :: Y(1:)  !< Y COMPONENT.
  INTEGER(I4P),               INTENT(IN)    :: Z(1:)  !< Z COMPONENT.
  INTEGER(I4P)                              :: N_BYTE !< NUMBER OF BYTES
  INTEGER(I4P)                              :: N      !< COUNTER.

  N_BYTE = SELF%WRITE_ON_SCRATCH_DATAARRAY(X=[(X(N), Y(N), Z(N), N=1,SIZE(X, DIM=1))])
  ENDFUNCTION WRITE_ON_SCRATCH_DATAARRAY3_RANK1_I4P

  FUNCTION WRITE_ON_SCRATCH_DATAARRAY3_RANK1_I2P(SELF, X, Y, Z) RESULT(N_BYTE)
  !< WRITE A DATAARRAY WITH 3 COMPONENTS OF RANK 1 (I2P).
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT) :: SELF   !< WRITER.
  INTEGER(I2P),               INTENT(IN)    :: X(1:)  !< X COMPONENT.
  INTEGER(I2P),               INTENT(IN)    :: Y(1:)  !< Y COMPONENT.
  INTEGER(I2P),               INTENT(IN)    :: Z(1:)  !< Z COMPONENT.
  INTEGER(I4P)                              :: N_BYTE !< NUMBER OF BYTES
  INTEGER(I4P)                              :: N      !< COUNTER.

  N_BYTE = SELF%WRITE_ON_SCRATCH_DATAARRAY(X=[(X(N), Y(N), Z(N), N=1,SIZE(X, DIM=1))])
  ENDFUNCTION WRITE_ON_SCRATCH_DATAARRAY3_RANK1_I2P

  FUNCTION WRITE_ON_SCRATCH_DATAARRAY3_RANK1_I1P(SELF, X, Y, Z) RESULT(N_BYTE)
  !< WRITE A DATAARRAY WITH 3 COMPONENTS OF RANK 1 (I1P).
  CLASS(XML_WRITER_APPENDED), INTENT(INOUT) :: SELF   !< WRITER.
  INTEGER(I1P),               INTENT(IN)    :: X(1:)  !< X COMPONENT.
  INTEGER(I1P),               INTENT(IN)    :: Y(1:)  !< Y COMPONENT.
  INTEGER(I1P),               INTENT(IN)    :: Z(1:)  !< Z COMPONENT.
  INTEGER(I4P)                              :: N_BYTE !< NUMBER OF BYTES
  INTEGER(I4P)                              :: N      !< COUNTER.

  N_BYTE = SELF%WRITE_ON_SCRATCH_DATAARRAY(X=[(X(N), Y(N), Z(N), N=1,SIZE(X, DIM=1))])
  ENDFUNCTION WRITE_ON_SCRATCH_DATAARRAY3_RANK1_I1P

ENDMODULE VTKF_FILE_XML_WRITER_APPENDED




!< VTK FILE XML WRITER, BINARY LOCAL.
MODULE VTKF_FILE_XML_WRITER_BINARY_LOCAL
!< VTK FILE XML WRITER, BINARY LOCAL.
!<
!< THIS WRITER IS (CURRENTLY) THE ONLY ONE ABLE ALSO TO CREATE A *VOLATILE* FILE (ENABLING VOLATILE OPTION).
!< INSTEAD OF SAVING DATA INTO A REAL FILE ON THE SYSTEM, THIS WRITER CAN SAVE DATA INTO A (VOLATILE) CHARACTERS STRING THAT CAN BE
!< USED ALSO ON (SLAVE) PROCESSES THAT HAVE NOT ACCESS TO FILESYSTEM: THE VOLATILE STRING CAN BE EASILY SENT TO OTHER (MASTER)
!< PROCESSES HAVING ACCESS TO FILESYTEM. THE VOLATILE WRITER MODE IS DESIGNED TO FACILITATE THE USE OF THE LIBRARY IN PARALLEL
!< ENVINROMENTS WEHERE NOT ALL PROCESSES/THREADS HAVE ACCESS TO FILESYSTEM.
USE PENF
USE STRINGIFOR
USE VTK_FORTRAN_DATAARRAY_ENCODER
USE VTKF_FILE_XML_WRITER_ABSTRACT

IMPLICIT NONE
PRIVATE
PUBLIC :: XML_WRITER_BINARY_LOCAL

TYPE, EXTENDS(XML_WRITER_ABSTRACT) :: XML_WRITER_BINARY_LOCAL
   !< VTK FILE XML WRITER, BINARY LOCAL.
   CONTAINS
      ! DEFERRED METHODS
      PROCEDURE, PASS(SELF) :: INITIALIZE                 !< INITIALIZE WRITER.
      PROCEDURE, PASS(SELF) :: FINALIZE                   !< FINALIZE WRITER.
      PROCEDURE, PASS(SELF) :: W_DATA1_RANK1_R8P !< WRITE DATAARRAY 1, RANK 1, R8P.
      PROCEDURE, PASS(SELF) :: W_DATA1_RANK1_R4P !< WRITE DATAARRAY 1, RANK 1, R4P.
      PROCEDURE, PASS(SELF) :: W_DATA1_RANK1_I8P !< WRITE DATAARRAY 1, RANK 1, I8P.
      PROCEDURE, PASS(SELF) :: W_DATA1_RANK1_I4P !< WRITE DATAARRAY 1, RANK 1, I4P.
      PROCEDURE, PASS(SELF) :: W_DATA1_RANK1_I2P !< WRITE DATAARRAY 1, RANK 1, I2P.
      PROCEDURE, PASS(SELF) :: W_DATA1_RANK1_I1P !< WRITE DATAARRAY 1, RANK 1, I1P.
      PROCEDURE, PASS(SELF) :: W_DATA3_RANK1_R8P !< WRITE DATAARRAY 3, RANK 1, R8P.
      PROCEDURE, PASS(SELF) :: W_DATA3_RANK1_R4P !< WRITE DATAARRAY 3, RANK 1, R4P.
      PROCEDURE, PASS(SELF) :: W_DATA3_RANK1_I8P !< WRITE DATAARRAY 3, RANK 1, I8P.
      PROCEDURE, PASS(SELF) :: W_DATA3_RANK1_I4P !< WRITE DATAARRAY 3, RANK 1, I4P.
      PROCEDURE, PASS(SELF) :: W_DATA3_RANK1_I2P !< WRITE DATAARRAY 3, RANK 1, I2P.
      PROCEDURE, PASS(SELF) :: W_DATA3_RANK1_I1P !< WRITE DATAARRAY 3, RANK 1, I1P.
      PROCEDURE, PASS(SELF) :: W_DATA_APPENDED   !< WRITE APPENDED.
ENDTYPE XML_WRITER_BINARY_LOCAL
CONTAINS
   FUNCTION INITIALIZE(SELF, FORMAT, FILENAME, MESH_TOPOLOGY, NX1, NX2, NY1, NY2, NZ1, NZ2, &
                       IS_VOLATILE, MESH_KIND) RESULT(ERROR)
   !< INITIALIZE WRITER.
   CLASS(XML_WRITER_BINARY_LOCAL), INTENT(INOUT)        :: SELF          !< WRITER.
   CHARACTER(*),                   INTENT(IN)           :: FORMAT        !< FILE FORMAT: BINARY.
   CHARACTER(*),                   INTENT(IN)           :: FILENAME      !< FILE NAME.
   CHARACTER(*),                   INTENT(IN)           :: MESH_TOPOLOGY !< MESH TOPOLOGY.
   INTEGER(I4P),                   INTENT(IN), OPTIONAL :: NX1           !< INITIAL NODE OF X AXIS.
   INTEGER(I4P),                   INTENT(IN), OPTIONAL :: NX2           !< FINAL NODE OF X AXIS.
   INTEGER(I4P),                   INTENT(IN), OPTIONAL :: NY1           !< INITIAL NODE OF Y AXIS.
   INTEGER(I4P),                   INTENT(IN), OPTIONAL :: NY2           !< FINAL NODE OF Y AXIS.
   INTEGER(I4P),                   INTENT(IN), OPTIONAL :: NZ1           !< INITIAL NODE OF Z AXIS.
   INTEGER(I4P),                   INTENT(IN), OPTIONAL :: NZ2           !< FINAL NODE OF Z AXIS.
   CHARACTER(*),                   INTENT(IN), OPTIONAL :: MESH_KIND     !< KIND OF MESH DATA: FLOAT64, FLOAT32, ECC.
   LOGICAL,                        INTENT(IN), OPTIONAL :: IS_VOLATILE   !< FLAG TO CHECK VOLATILE WRITER.
   INTEGER(I4P)                                         :: ERROR         !< ERROR STATUS.

   SELF%IS_VOLATILE = .FALSE. ; IF (PRESENT(IS_VOLATILE)) SELF%IS_VOLATILE = IS_VOLATILE
   SELF%TOPOLOGY = TRIM(ADJUSTL(MESH_TOPOLOGY))
   SELF%FORMAT_CH = FORMAT
   SELF%FORMAT_CH = SELF%FORMAT_CH%LOWER()
   CALL SELF%OPEN_XML_FILE(FILENAME=FILENAME)
   CALL SELF%WRITE_HEADER_TAG
   CALL SELF%WRITE_TOPOLOGY_TAG(NX1=NX1, NX2=NX2, NY1=NY1, NY2=NY2, NZ1=NZ1, NZ2=NZ2, MESH_KIND=MESH_KIND)
   ERROR = SELF%ERROR
   ENDFUNCTION INITIALIZE

   FUNCTION FINALIZE(SELF) RESULT(ERROR)
   !< FINALIZE WRITER.
   CLASS(XML_WRITER_BINARY_LOCAL), INTENT(INOUT) :: SELF  !< WRITER.
   INTEGER(I4P)                                  :: ERROR !< ERROR STATUS.

   CALL SELF%WRITE_END_TAG(NAME=SELF%TOPOLOGY%CHARS())
   CALL SELF%WRITE_END_TAG(NAME='VTKFile')
   CALL SELF%CLOSE_XML_FILE
   ERROR = SELF%ERROR
   ENDFUNCTION FINALIZE

   ! W_DATA METHODS
   FUNCTION W_DATA1_RANK1_R8P(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
   !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (R8P).
   CLASS(XML_WRITER_BINARY_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
   CHARACTER(*),                   INTENT(IN)           :: DATA_NAME    !< DATA NAME.
   REAL(R8P),                      INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
   LOGICAL,                        INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
   INTEGER(I4P)                                         :: ERROR        !< ERROR STATUS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: DATA_TYPE    !< DATA TYPE.
   INTEGER(I4P)                                         :: N_COMPONENTS !< NUMBER OF COMPONENTS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: CODE         !< DATA VARIABLE ENCODED, BINARY OR BASE64 CODEC.

   DATA_TYPE = 'Float64'
   N_COMPONENTS = 1
   CODE = ENCODE_BINARY_DATAARRAY(X=X)
   CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                 IS_TUPLES=IS_TUPLES)
   ERROR = SELF%ERROR
   ENDFUNCTION W_DATA1_RANK1_R8P

   FUNCTION W_DATA1_RANK1_R4P(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
   !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (R4P).
   CLASS(XML_WRITER_BINARY_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
   CHARACTER(*),                   INTENT(IN)           :: DATA_NAME    !< DATA NAME.
   REAL(R4P),                      INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
   LOGICAL,                        INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
   INTEGER(I4P)                                         :: ERROR        !< ERROR STATUS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: DATA_TYPE    !< DATA TYPE.
   INTEGER(I4P)                                         :: N_COMPONENTS !< NUMBER OF COMPONENTS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: CODE         !< DATA VARIABLE ENCODED, BINARY OR BASE64 CODEC.

   DATA_TYPE = 'Float32'
   N_COMPONENTS = 1
   CODE = ENCODE_BINARY_DATAARRAY(X=X)
   CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                 IS_TUPLES=IS_TUPLES)
   ERROR = SELF%ERROR
   ENDFUNCTION W_DATA1_RANK1_R4P

   FUNCTION W_DATA1_RANK1_I8P(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
   !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (I8P).
   CLASS(XML_WRITER_BINARY_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
   CHARACTER(*),                   INTENT(IN)           :: DATA_NAME    !< DATA NAME.
   INTEGER(I8P),                   INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
   LOGICAL,                        INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
   INTEGER(I4P)                                         :: ERROR        !< ERROR STATUS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: DATA_TYPE    !< DATA TYPE.
   INTEGER(I4P)                                         :: N_COMPONENTS !< NUMBER OF COMPONENTS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: CODE         !< DATA VARIABLE ENCODED, BINARY OR BASE64 CODEC.

   DATA_TYPE = 'Int64'
   N_COMPONENTS = 1
   CODE = ENCODE_BINARY_DATAARRAY(X=X)
   CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                 IS_TUPLES=IS_TUPLES)
   ERROR = SELF%ERROR
   ENDFUNCTION W_DATA1_RANK1_I8P

   FUNCTION W_DATA1_RANK1_I4P(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
   !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (I4P).
   CLASS(XML_WRITER_BINARY_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
   CHARACTER(*),                   INTENT(IN)           :: DATA_NAME    !< DATA NAME.
   INTEGER(I4P),                   INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
   LOGICAL,                        INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
   INTEGER(I4P)                                         :: ERROR        !< ERROR STATUS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: DATA_TYPE    !< DATA TYPE.
   INTEGER(I4P)                                         :: N_COMPONENTS !< NUMBER OF COMPONENTS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: CODE         !< DATA VARIABLE ENCODED, BINARY OR BASE64 CODEC.

   DATA_TYPE = 'Int32'
   N_COMPONENTS = 1
   CODE = ENCODE_BINARY_DATAARRAY(X=X)
   CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                 IS_TUPLES=IS_TUPLES)
   ERROR = SELF%ERROR
   ENDFUNCTION W_DATA1_RANK1_I4P

   FUNCTION W_DATA1_RANK1_I2P(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
   !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (I2P).
   CLASS(XML_WRITER_BINARY_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
   CHARACTER(*),                   INTENT(IN)           :: DATA_NAME    !< DATA NAME.
   INTEGER(I2P),                   INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
   LOGICAL,                        INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
   INTEGER(I4P)                                         :: ERROR        !< ERROR STATUS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: DATA_TYPE    !< DATA TYPE.
   INTEGER(I4P)                                         :: N_COMPONENTS !< NUMBER OF COMPONENTS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: CODE         !< DATA VARIABLE ENCODED, BINARY OR BASE64 CODEC.

   DATA_TYPE = 'Int16'
   N_COMPONENTS = 1
   CODE = ENCODE_BINARY_DATAARRAY(X=X)
   CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                 IS_TUPLES=IS_TUPLES)
   ERROR = SELF%ERROR
   ENDFUNCTION W_DATA1_RANK1_I2P

   FUNCTION W_DATA1_RANK1_I1P(SELF, DATA_NAME, X, IS_TUPLES) RESULT(ERROR)
   !< WRITE `<DATAARRAY... NumberOfComponents="1"...>...</DATAARRAY>` TAG (I1P).
   CLASS(XML_WRITER_BINARY_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
   CHARACTER(*),                   INTENT(IN)           :: DATA_NAME    !< DATA NAME.
   INTEGER(I1P),                   INTENT(IN)           :: X(1:)        !< DATA VARIABLE.
   LOGICAL,                        INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
   INTEGER(I4P)                                         :: ERROR        !< ERROR STATUS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: DATA_TYPE    !< DATA TYPE.
   INTEGER(I4P)                                         :: N_COMPONENTS !< NUMBER OF COMPONENTS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: CODE         !< DATA VARIABLE ENCODED, BINARY OR BASE64 CODEC.

   DATA_TYPE = 'Int8'
   N_COMPONENTS = 1
   CODE = ENCODE_BINARY_DATAARRAY(X=X)
   CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                 IS_TUPLES=IS_TUPLES)
   ERROR = SELF%ERROR
   ENDFUNCTION W_DATA1_RANK1_I1P

   FUNCTION W_DATA3_RANK1_R8P(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
   !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (R8P).
   CLASS(XML_WRITER_BINARY_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
   CHARACTER(*),                   INTENT(IN)           :: DATA_NAME    !< DATA NAME.
   REAL(R8P),                      INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
   REAL(R8P),                      INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
   REAL(R8P),                      INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
   LOGICAL,                        INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
   INTEGER(I4P)                                         :: ERROR        !< ERROR STATUS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: DATA_TYPE    !< DATA TYPE.
   INTEGER(I4P)                                         :: N_COMPONENTS !< NUMBER OF COMPONENTS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: CODE         !< DATA VARIABLE ENCODED, BINARY OR BASE64 CODEC.

   DATA_TYPE = 'Float64'
   N_COMPONENTS = 3
   CODE = ENCODE_BINARY_DATAARRAY(X=X, Y=Y, Z=Z)
   CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                 IS_TUPLES=IS_TUPLES)
   ERROR = SELF%ERROR
   ENDFUNCTION W_DATA3_RANK1_R8P

   FUNCTION W_DATA3_RANK1_R4P(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
   !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (R4P).
   CLASS(XML_WRITER_BINARY_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
   CHARACTER(*),                   INTENT(IN)           :: DATA_NAME    !< DATA NAME.
   REAL(R4P),                      INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
   REAL(R4P),                      INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
   REAL(R4P),                      INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
   LOGICAL,                        INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
   INTEGER(I4P)                                         :: ERROR        !< ERROR STATUS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: DATA_TYPE    !< DATA TYPE.
   INTEGER(I4P)                                         :: N_COMPONENTS !< NUMBER OF COMPONENTS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: CODE         !< DATA VARIABLE ENCODED, BINARY OR BASE64 CODEC.

   DATA_TYPE = 'Float32'
   N_COMPONENTS = 3
   CODE = ENCODE_BINARY_DATAARRAY(X=X, Y=Y, Z=Z)
   CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                 IS_TUPLES=IS_TUPLES)
   ERROR = SELF%ERROR
   ENDFUNCTION W_DATA3_RANK1_R4P

   FUNCTION W_DATA3_RANK1_I8P(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
   !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (I8P).
   CLASS(XML_WRITER_BINARY_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
   CHARACTER(*),                   INTENT(IN)           :: DATA_NAME    !< DATA NAME.
   INTEGER(I8P),                   INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
   INTEGER(I8P),                   INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
   INTEGER(I8P),                   INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
   LOGICAL,                        INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
   INTEGER(I4P)                                         :: ERROR        !< ERROR STATUS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: DATA_TYPE    !< DATA TYPE.
   INTEGER(I4P)                                         :: N_COMPONENTS !< NUMBER OF COMPONENTS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: CODE         !< DATA VARIABLE ENCODED, BINARY OR BASE64 CODEC.

   DATA_TYPE = 'Int64'
   N_COMPONENTS = 3
   CODE = ENCODE_BINARY_DATAARRAY(X=X, Y=Y, Z=Z)
   CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                 IS_TUPLES=IS_TUPLES)
   ERROR = SELF%ERROR
   ENDFUNCTION W_DATA3_RANK1_I8P

   FUNCTION W_DATA3_RANK1_I4P(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
   !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (I4P).
   CLASS(XML_WRITER_BINARY_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
   CHARACTER(*),                   INTENT(IN)           :: DATA_NAME    !< DATA NAME.
   INTEGER(I4P),                   INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
   INTEGER(I4P),                   INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
   INTEGER(I4P),                   INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
   LOGICAL,                        INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
   INTEGER(I4P)                                         :: ERROR        !< ERROR STATUS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: DATA_TYPE    !< DATA TYPE.
   INTEGER(I4P)                                         :: N_COMPONENTS !< NUMBER OF COMPONENTS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: CODE         !< DATA VARIABLE ENCODED, BINARY OR BASE64 CODEC.

   DATA_TYPE = 'Int32'
   N_COMPONENTS = 3
   CODE = ENCODE_BINARY_DATAARRAY(X=X, Y=Y, Z=Z)
   CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                 IS_TUPLES=IS_TUPLES)
   ERROR = SELF%ERROR
   ENDFUNCTION W_DATA3_RANK1_I4P

   FUNCTION W_DATA3_RANK1_I2P(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
   !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (I2P).
   CLASS(XML_WRITER_BINARY_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
   CHARACTER(*),                   INTENT(IN)           :: DATA_NAME    !< DATA NAME.
   INTEGER(I2P),                   INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
   INTEGER(I2P),                   INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
   INTEGER(I2P),                   INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
   LOGICAL,                        INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
   INTEGER(I4P)                                         :: ERROR        !< ERROR STATUS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: DATA_TYPE    !< DATA TYPE.
   INTEGER(I4P)                                         :: N_COMPONENTS !< NUMBER OF COMPONENTS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: CODE         !< DATA VARIABLE ENCODED, BINARY OR BASE64 CODEC.

   DATA_TYPE = 'Int16'
   N_COMPONENTS = 3
   CODE = ENCODE_BINARY_DATAARRAY(X=X, Y=Y, Z=Z)
   CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                 IS_TUPLES=IS_TUPLES)
   ERROR = SELF%ERROR
   ENDFUNCTION W_DATA3_RANK1_I2P

   FUNCTION W_DATA3_RANK1_I1P(SELF, DATA_NAME, X, Y, Z, IS_TUPLES) RESULT(ERROR)
   !< WRITE `<DATAARRAY... NumberOfComponents="3"...>...</DATAARRAY>` TAG (I1P).
   CLASS(XML_WRITER_BINARY_LOCAL), INTENT(INOUT)        :: SELF         !< WRITER.
   CHARACTER(*),                   INTENT(IN)           :: DATA_NAME    !< DATA NAME.
   INTEGER(I1P),                   INTENT(IN)           :: X(1:)        !< X COMPONENT OF DATA VARIABLE.
   INTEGER(I1P),                   INTENT(IN)           :: Y(1:)        !< Y COMPONENT OF DATA VARIABLE.
   INTEGER(I1P),                   INTENT(IN)           :: Z(1:)        !< Z COMPONENT OF DATA VARIABLE.
   LOGICAL,                        INTENT(IN), OPTIONAL :: IS_TUPLES    !< USE "NUMBEROFTUPLES" INSTEAD OF "NUMBEROFCOMPONENTS".
   INTEGER(I4P)                                         :: ERROR        !< ERROR STATUS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: DATA_TYPE    !< DATA TYPE.
   INTEGER(I4P)                                         :: N_COMPONENTS !< NUMBER OF COMPONENTS.
   CHARACTER(LEN=:), ALLOCATABLE                        :: CODE         !< DATA VARIABLE ENCODED, BINARY OR BASE64 CODEC.

   DATA_TYPE = 'Int8'
   N_COMPONENTS = 3
   CODE = ENCODE_BINARY_DATAARRAY(X=X, Y=Y, Z=Z)
   CALL SELF%W_DATA_TAG(DATA_TYPE=DATA_TYPE, NUMBER_OF_COMPONENTS=N_COMPONENTS, DATA_NAME=DATA_NAME, DATA_CONTENT=CODE, &
                                 IS_TUPLES=IS_TUPLES)
   ERROR = SELF%ERROR
   ENDFUNCTION W_DATA3_RANK1_I1P

   SUBROUTINE W_DATA_APPENDED(SELF)
   !< DO NOTHING, BINARY LOCAL IS NOT APPENDED.
   CLASS(XML_WRITER_BINARY_LOCAL), INTENT(INOUT) :: SELF !< WRITER.
   INTEGER(I4P)                                         :: ERROR        !< ERROR STATUS.
   ERROR = SELF%ERROR
   ENDSUBROUTINE W_DATA_APPENDED
ENDMODULE VTKF_FILE_XML_WRITER_BINARY_LOCAL





!< VTM FILE CLASS.
MODULE VTK_FORTRAN_VTM_FILE
!< VTM FILE CLASS.
USE BEFOR64
USE PENF
USE STRINGIFOR
USE VTKF_FILE_XML_WRITER_ABSTRACT
USE VTKF_FILE_XML_WRITER_ASCII_LOCAL

IMPLICIT NONE
PRIVATE
PUBLIC :: VTM_FILE

TYPE :: VTM_FILE
   !< VTM FILE CLASS.
   CLASS(XML_WRITER_ABSTRACT), ALLOCATABLE, PUBLIC :: XML_WRITER      !< XML WRITER.
   INTEGER(I4P), ALLOCATABLE                       :: SCRATCH_UNIT(:) !< SCRATCH UNITS FOR VERY LARGE LIST OF NAMED BLOCKS.
   CONTAINS
      ! PUBLIC METHODS
      PROCEDURE, PASS(SELF) :: INITIALIZE          !< INITIALIZE FILE.
      PROCEDURE, PASS(SELF) :: FINALIZE            !< FINALIZE FILE.
      GENERIC               :: WRITE_BLOCK =>      &
                               WRITE_BLOCK_ARRAY,  &
                               WRITE_BLOCK_STRING, &
                               WRITE_BLOCK_SCRATCH !< WRITE ONE BLOCK DATASET.
      ! PRIVATE METHODS
      PROCEDURE, PASS(SELF), PRIVATE :: WRITE_BLOCK_ARRAY  !< WRITE ONE BLOCK DATASET (ARRAY INPUT).
      PROCEDURE, PASS(SELF), PRIVATE :: WRITE_BLOCK_STRING !< WRITE ONE BLOCK DATASET (STRING INPUT).
      ! SCRATCH FILES METHODS``
      PROCEDURE, PASS(SELF), PRIVATE :: PARSE_SCRATCH_FILES !< PARSE SCRATCH FILES.
      PROCEDURE, PASS(SELF), PRIVATE :: WRITE_BLOCK_SCRATCH !< WRITE ONE BLOCK DATASET ON SCRATCH FILES.
ENDTYPE VTM_FILE
CONTAINS
  ! PUBLIC METHODS
  FUNCTION INITIALIZE(SELF, FILENAME, SCRATCH_UNITS_NUMBER) RESULT(ERROR)
  !< INITIALIZE FILE (WRITER).
  CLASS(VTM_FILE), INTENT(INOUT)        :: SELF                  !< VTM FILE.
  CHARACTER(*),    INTENT(IN)           :: FILENAME              !< FILE NAME OF OUTPUT VTM FILE.
  INTEGER(I4P),    INTENT(IN), OPTIONAL :: SCRATCH_UNITS_NUMBER  !< NUMBER OF SCRATCH UNITS FOR VERY LARGE LIST OF NAMED BLOCKS.
  INTEGER(I4P)                          :: SCRATCH_UNITS_NUMBER_ !< NUMBER OF SCRATCH UNITS FOR VERY LARGE LIST OF NAMED BLOCKS.
  INTEGER(I4P)                          :: ERROR                 !< ERROR STATUS.

  IF (.NOT.IS_INITIALIZED) CALL PENF_INIT
  IF (.NOT.IS_B64_INITIALIZED) CALL B64_INIT
  SCRATCH_UNITS_NUMBER_ = 0_I4P ; IF (PRESENT(SCRATCH_UNITS_NUMBER)) SCRATCH_UNITS_NUMBER_ = SCRATCH_UNITS_NUMBER
  ERROR = SELF%FINALIZE()
  IF (ALLOCATED(SELF%XML_WRITER)) DEALLOCATE(SELF%XML_WRITER)
  ALLOCATE(XML_WRITER_ASCII_LOCAL :: SELF%XML_WRITER)
  ERROR = SELF%XML_WRITER%INITIALIZE(FORMAT='ascii', FILENAME=FILENAME, MESH_TOPOLOGY='VTKMULTIBLOCKDATASET')
  IF (SCRATCH_UNITS_NUMBER_>0_I4P) ALLOCATE(SELF%SCRATCH_UNIT(SCRATCH_UNITS_NUMBER_))
  ENDFUNCTION INITIALIZE

  FUNCTION FINALIZE(SELF) RESULT(ERROR)
  !< FINALIZE FILE (WRITER).
  CLASS(VTM_FILE), INTENT(INOUT) :: SELF  !< VTM FILE.
  INTEGER(I4P)                   :: ERROR !< ERROR STATUS.

  ERROR = 1
  IF (ALLOCATED(SELF%SCRATCH_UNIT)) THEN
     ERROR = SELF%PARSE_SCRATCH_FILES()
     DEALLOCATE(SELF%SCRATCH_UNIT)
  ENDIF
  IF (ALLOCATED(SELF%XML_WRITER)) ERROR = SELF%XML_WRITER%FINALIZE()
  ENDFUNCTION FINALIZE

  ! PRIVATE METHODS
  FUNCTION WRITE_BLOCK_ARRAY(SELF, FILENAMES, NAMES, NAME) RESULT(ERROR)
  !< WRITE ONE BLOCK DATASET (ARRAY INPUT).
  !<
  !<#### EXAMPLE OF USAGE: 3 FILES BLOCKS
  !<```FORTRAN
  !< ERROR = VTM%WRITE_BLOCK(FILENAMES=['FILE_1.VTS', 'FILE_2.VTS', 'FILE_3.VTU'], NAME='MY_BLOCK')
  !<```
  !<
  !<#### EXAMPLE OF USAGE: 3 FILES BLOCKS WITH CUSTOM NAME
  !<```FORTRAN
  !< ERROR = VTM%WRITE_BLOCK(FILENAMES=['FILE_1.VTS', 'FILE_2.VTS', 'FILE_3.VTU'], &
  !<                         NAMES=['BLOCK-BAR', 'BLOCK-FOO', 'BLOCK-BAZ'], NAME='MY_BLOCK')
  !<```
  CLASS(VTM_FILE), INTENT(INOUT)        :: SELF          !< VTM FILE.
  CHARACTER(*),    INTENT(IN)           :: FILENAMES(1:) !< FILE NAMES OF VTK FILES GROUPED INTO CURRENT BLOCK.
  CHARACTER(*),    INTENT(IN), OPTIONAL :: NAMES(1:)     !< AUXILIARY NAMES ATTRIBUTED TO EACH FILES.
  CHARACTER(*),    INTENT(IN), OPTIONAL :: NAME          !< BLOCK NAME
  INTEGER(I4P)                          :: ERROR         !< ERROR STATUS.

  ERROR = SELF%XML_WRITER%WRITE_PARALLEL_OPEN_BLOCK(NAME=NAME)
  ERROR = SELF%XML_WRITER%WRITE_PARALLEL_BLOCK_FILES(FILENAMES=FILENAMES, NAMES=NAMES)
  ERROR = SELF%XML_WRITER%WRITE_PARALLEL_CLOSE_BLOCK()
  ENDFUNCTION WRITE_BLOCK_ARRAY

   FUNCTION WRITE_BLOCK_STRING(SELF, ACTION, FILENAMES, NAMES, NAME) RESULT(ERROR)
   !< WRITE ONE BLOCK DATASET (STRING INPUT).
   !<
   !<#### EXAMPLE OF USAGE: 3 FILES BLOCKS
   !<```FORTRAN
   !< ERROR = VTM%WRITE_BLOCK(FILENAMES='FILE_1.VTS FILE_2.VTS FILE_3.VTU', NAME='MY_BLOCK')
   !<```
   !<
   !<#### EXAMPLE OF USAGE: 3 FILES BLOCKS WITH CUSTOM NAME
   !<```FORTRAN
   !< ERROR = VTM%WRITE_BLOCK(FILENAMES='FILE_1.VTS FILE_2.VTS FILE_3.VTU', NAMES='BLOCK-BAR BLOCK-FOO BLOCK-BAZ', NAME='MY_BLOCK')
   !<```
   CLASS(VTM_FILE), INTENT(INOUT)        :: SELF      !< VTM FILE.
   CHARACTER(*),    INTENT(IN), OPTIONAL :: ACTION    !< ACTION: [OPEN, CLOSE, WRITE].
   CHARACTER(*),    INTENT(IN), OPTIONAL :: FILENAMES !< FILE NAMES OF VTK FILES GROUPED INTO CURRENT BLOCK.
   CHARACTER(*),    INTENT(IN), OPTIONAL :: NAMES     !< AUXILIARY NAMES ATTRIBUTED TO EACH FILES.
   CHARACTER(*),    INTENT(IN), OPTIONAL :: NAME      !< BLOCK NAME
   INTEGER(I4P)                          :: ERROR     !< ERROR STATUS.
   TYPE(STRING)                          :: ACTION_   !< ACTION STRING.

   IF (PRESENT(ACTION)) THEN
      ACTION_ = TRIM(ADJUSTL(ACTION)) ; ACTION_ = ACTION_%UPPER()
      SELECT CASE(ACTION_%CHARS())
      CASE('OPEN')
         ERROR = SELF%XML_WRITER%WRITE_PARALLEL_OPEN_BLOCK(NAME=NAME)
      CASE('CLOSE')
         ERROR = SELF%XML_WRITER%WRITE_PARALLEL_CLOSE_BLOCK()
      CASE('WRITE')
         IF (PRESENT(FILENAMES)) ERROR = SELF%XML_WRITER%WRITE_PARALLEL_BLOCK_FILES(FILENAMES=FILENAMES, NAMES=NAMES)
      ENDSELECT
   ELSE
      ERROR = SELF%XML_WRITER%WRITE_PARALLEL_OPEN_BLOCK(NAME=NAME)
      ERROR = SELF%XML_WRITER%WRITE_PARALLEL_BLOCK_FILES(FILENAMES=FILENAMES, NAMES=NAMES)
      ERROR = SELF%XML_WRITER%WRITE_PARALLEL_CLOSE_BLOCK()
   ENDIF
   ENDFUNCTION WRITE_BLOCK_STRING

   ! SCRATCH FILES METHODS
   FUNCTION PARSE_SCRATCH_FILES(SELF) RESULT(ERROR)
   !< PARSE SCRATCH FILES.
   CLASS(VTM_FILE), INTENT(INOUT) :: SELF     !< VTM FILE.
   INTEGER(I4P)                   :: ERROR    !< ERROR STATUS.
   CHARACTER(9999)                :: FILENAME !< FILE NAME OF VTK FILE GROUPED INTO CURRENT BLOCK.
   CHARACTER(9999)                :: NAME     !< BLOCK NAME
   INTEGER(I4P)                   :: S, F     !< COUNTER.

   IF (ALLOCATED(SELF%SCRATCH_UNIT)) THEN
      DO S=1, SIZE(SELF%SCRATCH_UNIT, DIM=1)
         ! REWIND SCRATCH FILE
         REWIND(SELF%SCRATCH_UNIT(S))
         ! WRITE GROUP NAME
         F = 0_I4P
         READ(SELF%SCRATCH_UNIT(S), IOSTAT=ERROR, FMT=*) NAME
         ERROR = SELF%WRITE_BLOCK(ACTION='OPEN', NAME=TRIM(ADJUSTL(NAME)))
         ! WRITE GROUP FILENAMES
         PARSE_FILE_LOOP : DO
            READ(SELF%SCRATCH_UNIT(S), IOSTAT=ERROR, FMT=*) FILENAME
            IF (IS_IOSTAT_END(ERROR)) EXIT PARSE_FILE_LOOP
            ERROR = SELF%XML_WRITER%WRITE_PARALLEL_BLOCK_FILES(FILE_INDEX=F,                     &
                                                               FILENAME=TRIM(ADJUSTL(FILENAME)), &
                                                               NAME=TRIM(ADJUSTL(FILENAME)))
            F = F + 1_I4P
         ENDDO PARSE_FILE_LOOP
         ! CLOSE GROUP
         ERROR = SELF%WRITE_BLOCK(ACTION='CLOSE')
         ! CLOSE SCRATCH FILE
         CLOSE(SELF%SCRATCH_UNIT(S))
      ENDDO
   ENDIF
   ENDFUNCTION PARSE_SCRATCH_FILES

   FUNCTION WRITE_BLOCK_SCRATCH(SELF, SCRATCH, ACTION, FILENAME, NAME) RESULT(ERROR)
   !< WRITE ONE BLOCK DATASET ON SCRATCH FILES.
   CLASS(VTM_FILE), INTENT(INOUT)        :: SELF     !< VTM FILE.
   INTEGER(I4P),    INTENT(IN)           :: SCRATCH  !< SCRATCH UNIT.
   CHARACTER(*),    INTENT(IN)           :: ACTION   !< ACTION: [OPEN, WRITE].
   CHARACTER(*),    INTENT(IN), OPTIONAL :: FILENAME !< FILE NAME OF VTK FILE GROUPED INTO CURRENT BLOCK.
   CHARACTER(*),    INTENT(IN), OPTIONAL :: NAME     !< BLOCK NAME
   INTEGER(I4P)                          :: ERROR    !< ERROR STATUS.
   TYPE(STRING)                          :: ACTION_  !< ACTION STRING.
   TYPE(STRING)                          :: NAME_    !< BLOCK NAME, LOCAL VARIABLE

   ACTION_ = TRIM(ADJUSTL(ACTION)) ; ACTION_ = ACTION_%UPPER()
   SELECT CASE(ACTION_%CHARS())
   CASE('OPEN')
     OPEN(NEWUNIT=SELF%SCRATCH_UNIT(SCRATCH), &
          FORM='FORMATTED',                   &
          ACTION='READWRITE',                 &
          STATUS='SCRATCH',                   &
          IOSTAT=ERROR)
      NAME_ = '' ; IF (PRESENT(NAME)) NAME_ = TRIM(ADJUSTL(NAME))
      WRITE(SELF%SCRATCH_UNIT(SCRATCH), IOSTAT=ERROR, FMT='(A)') NAME_%CHARS()
   CASE('WRITE')
      IF (PRESENT(FILENAME)) WRITE(SELF%SCRATCH_UNIT(SCRATCH), IOSTAT=ERROR, FMT='(A)') TRIM(FILENAME)
   ENDSELECT
   ENDFUNCTION WRITE_BLOCK_SCRATCH
ENDMODULE VTK_FORTRAN_VTM_FILE




!< VTK FILE CLASS.
MODULE VTK_FORTRAN_VTK_FILE
!< VTK FILE CLASS.
USE BEFOR64
USE PENF
USE STRINGIFOR
USE VTKF_FILE_XML_WRITER_ABSTRACT
USE VTKF_FILE_XML_WRITER_APPENDED
USE VTKF_FILE_XML_WRITER_ASCII_LOCAL
USE VTKF_FILE_XML_WRITER_BINARY_LOCAL

IMPLICIT NONE
PRIVATE
PUBLIC :: VTK_FILE

TYPE :: VTK_FILE
  !< VTK FILE CLASS.
  PRIVATE
  CLASS(XML_WRITER_ABSTRACT), ALLOCATABLE, PUBLIC :: XML_WRITER !< XML WRITER.
  CONTAINS
    PROCEDURE, PASS(SELF) :: GET_XML_VOLATILE !< RETURN THE EVENTUAL XML VOLATILE STRING FILE.
    PROCEDURE, PASS(SELF) :: INITIALIZE       !< INITIALIZE FILE.
    PROCEDURE, PASS(SELF) :: FINALIZE         !< FINALIZE FILE.
    PROCEDURE, PASS(SELF) :: CUSTOMFREE             !< FREE ALLOCATED MEMORY.
ENDTYPE VTK_FILE
CONTAINS
   PURE SUBROUTINE GET_XML_VOLATILE(SELF, XML_VOLATILE, ERROR)
   !< RETURN THE EVENTUAL XML VOLATILE STRING FILE.
   CLASS(VTK_FILE),  INTENT(IN)               :: SELF         !< VTK FILE.
   CHARACTER(LEN=:), INTENT(OUT), ALLOCATABLE :: XML_VOLATILE !< XML VOLATILE FILE.
   INTEGER(I4P),     INTENT(OUT), OPTIONAL    :: ERROR !< ERROR STATUS.
   IF (ERROR.EQ.-1) THEN
   ENDIF
   CALL SELF%XML_WRITER%GET_XML_VOLATILE(XML_VOLATILE=XML_VOLATILE) !, ERROR=ERROR)
   ENDSUBROUTINE GET_XML_VOLATILE

   FUNCTION INITIALIZE(SELF, FORMAT, FILENAME, MESH_TOPOLOGY, IS_VOLATILE, NX1, NX2, NY1, NY2, NZ1, NZ2) RESULT(ERROR)
   !< INITIALIZE FILE (WRITER).
   !<
   !< @NOTE THIS FUNCTION MUST BE THE FIRST TO BE CALLED.
   !<
   !<### SUPPORTED OUTPUT FORMATS ARE (THE PASSED SPECIFIER VALUE IS CASE INSENSITIVE):
   !<
   !<- ASCII: DATA ARE SAVED IN ASCII FORMAT;
   !<- BINARY: DATA ARE SAVED IN BASE64 ENCODED FORMAT;
   !<- RAW: DATA ARE SAVED IN RAW-BINARY FORMAT IN THE APPENDED TAG OF THE XML FILE;
   !<- BINARY-APPENDED: DATA ARE SAVED IN BASE64 ENCODED FORMAT IN THE APPENDED TAG OF THE XML FILE.
   !<
   !<### SUPPORTED TOPOLOGIES ARE:
   !<
   !<- RECTILINEARGRID;
   !<- STRUCTUREDGRID;
   !<- UNSTRUCTUREDGRID.
   !<- POLYDATA
   !<
   !<### EXAMPLE OF USAGE
   !<
   !<```FORTRAN
   !< TYPE(VTK_FILE) :: VTK
   !< INTEGER(I4P)   :: NX1, NX2, NY1, NY2, NZ1, NZ2
   !< ...
   !< ERROR = VTK%INITIALIZE('binary','XML_RECT_BINARY.VTR','RectilinearGrid',NX1=NX1,NX2=NX2,NY1=NY1,NY2=NY2,NZ1=NZ1,NZ2=NZ2)
   !< ...
   !<```
   !< @NOTE THE FILE EXTENSION IS NECESSARY IN THE FILE NAME. THE XML STANDARD HAS DIFFERENT EXTENSIONS FOR EACH
   !< DIFFERENT TOPOLOGIES (E.G. *VTR* FOR RECTILINEAR TOPOLOGY). SEE THE VTK-STANDARD FILE FOR MORE INFORMATION.
   CLASS(VTK_FILE), INTENT(INOUT)        :: SELF          !< VTK FILE.
   CHARACTER(*),    INTENT(IN)           :: FORMAT        !< FILE FORMAT: ASCII, BINARY, RAW OR BINARY-APPENDED.
   CHARACTER(*),    INTENT(IN)           :: FILENAME      !< FILE NAME.
   CHARACTER(*),    INTENT(IN)           :: MESH_TOPOLOGY !< MESH TOPOLOGY.
   LOGICAL,         INTENT(IN), OPTIONAL :: IS_VOLATILE   !< FLAG TO CHECK VOLATILE WRITER.
   INTEGER(I4P),    INTENT(IN), OPTIONAL :: NX1           !< INITIAL NODE OF X AXIS.
   INTEGER(I4P),    INTENT(IN), OPTIONAL :: NX2           !< FINAL NODE OF X AXIS.
   INTEGER(I4P),    INTENT(IN), OPTIONAL :: NY1           !< INITIAL NODE OF Y AXIS.
   INTEGER(I4P),    INTENT(IN), OPTIONAL :: NY2           !< FINAL NODE OF Y AXIS.
   INTEGER(I4P),    INTENT(IN), OPTIONAL :: NZ1           !< INITIAL NODE OF Z AXIS.
   INTEGER(I4P),    INTENT(IN), OPTIONAL :: NZ2           !< FINAL NODE OF Z AXIS.
   INTEGER(I4P)                          :: ERROR         !< ERROR STATUS.
   TYPE(STRING)                          :: FFORMAT       !< FILE FORMAT.

   IF (.NOT.IS_INITIALIZED) CALL PENF_INIT
   IF (.NOT.IS_B64_INITIALIZED) CALL B64_INIT
   FFORMAT = TRIM(ADJUSTL(FORMAT))
   FFORMAT = FFORMAT%UPPER()
   IF (ALLOCATED(SELF%XML_WRITER)) DEALLOCATE(SELF%XML_WRITER)
   SELECT CASE(FFORMAT%CHARS())
   CASE('ascii')
      ALLOCATE(XML_WRITER_ASCII_LOCAL :: SELF%XML_WRITER)
   CASE('binary-appended', 'raw')
      ALLOCATE(XML_WRITER_APPENDED :: SELF%XML_WRITER)
   CASE('binary')
      ALLOCATE(XML_WRITER_BINARY_LOCAL :: SELF%XML_WRITER)
   CASE DEFAULT
      ERROR = 1
   ENDSELECT
   ERROR = SELF%XML_WRITER%INITIALIZE(FORMAT=FORMAT, FILENAME=FILENAME, MESH_TOPOLOGY=MESH_TOPOLOGY, &
                                      IS_VOLATILE=IS_VOLATILE,                                       &
                                      NX1=NX1, NX2=NX2, NY1=NY1, NY2=NY2, NZ1=NZ1, NZ2=NZ2)
   ENDFUNCTION INITIALIZE

   FUNCTION FINALIZE(SELF) RESULT(ERROR)
   !< FINALIZE FILE (WRITER).
   CLASS(VTK_FILE), INTENT(INOUT)  :: SELF  !< VTK FILE.
   INTEGER(I4P)                    :: ERROR !< ERROR STATUS.
   CHARACTER(LEN=:),           ALLOCATABLE :: XML_VOLATILE !< XML VOLATILE FILE.

   ERROR = 1
   IF (ALLOCATED(SELF%XML_WRITER)) ERROR = SELF%XML_WRITER%FINALIZE()
   IF (ALLOCATED(XML_VOLATILE)) THEN
   ENDIF
   ENDFUNCTION FINALIZE

   ELEMENTAL SUBROUTINE CUSTOMFREE(SELF, ERROR)
   !< FREE ALLOCATED MEMORY.
   CLASS(VTK_FILE), INTENT(INOUT)         :: SELF  !< VTK FILE.
   INTEGER(I4P),    INTENT(OUT), OPTIONAL :: ERROR !< ERROR STATUS.
   IF (ERROR.EQ.-1) THEN
   ENDIF
   IF (ALLOCATED(SELF%XML_WRITER)) CALL SELF%XML_WRITER%CUSTOMFREE() !ERROR=ERROR)
   ENDSUBROUTINE CUSTOMFREE
ENDMODULE VTK_FORTRAN_VTK_FILE



!< PARALLEL (PARTIONED) VTK FILE CLASS.
MODULE VTK_FORTRAN_PVTK_FILE
!< PARALLEL (PARTIONED) VTK FILE CLASS.
USE BEFOR64
USE PENF
USE VTKF_FILE_XML_WRITER_ABSTRACT
USE VTKF_FILE_XML_WRITER_ASCII_LOCAL

IMPLICIT NONE
PRIVATE
PUBLIC :: PVTK_FILE

TYPE :: PVTK_FILE
  !< VTK PARALLEL (PARTIONED) FILE CLASS.
  PRIVATE
  CLASS(XML_WRITER_ABSTRACT), ALLOCATABLE, PUBLIC :: XML_WRITER !< XML WRITER.
  CONTAINS
    PROCEDURE, PASS(SELF) :: INITIALIZE !< INITIALIZE FILE.
    PROCEDURE, PASS(SELF) :: FINALIZE   !< FINALIZE FILE.
ENDTYPE PVTK_FILE
CONTAINS
  FUNCTION INITIALIZE(SELF, FILENAME, MESH_TOPOLOGY, MESH_KIND, NX1, NX2, NY1, NY2, NZ1, NZ2) RESULT(ERROR)
  !< INITIALIZE FILE (WRITER).
  !<
  !< @NOTE THIS FUNCTION MUST BE THE FIRST TO BE CALLED.
  !<
  !<### SUPPORTED TOPOLOGIES ARE:
  !<
  !<- PRECTILINEARGRID;
  !<- PSTRUCTUREDGRID;
  !<- PUNSTRUCTUREDGRID.
  !<- PPOLYDATA
  !<
  !<### EXAMPLE OF USAGE
  !<
  !<```FORTRAN
  !< TYPE(PVTK_FILE) :: PVTK
  !< INTEGER(I4P)    :: NX1, NX2, NY1, NY2, NZ1, NZ2
  !< ...
  !< ERROR = PVTK%INITIALIZE('XML_RECT_BINARY.PVTR','PRectilinearGrid',NX1=NX1,NX2=NX2,NY1=NY1,NY2=NY2,NZ1=NZ1,NZ2=NZ2)
  !< ...
  !<```
  !< @NOTE THE FILE EXTENSION IS NECESSARY IN THE FILE NAME. THE XML STANDARD HAS DIFFERENT EXTENSIONS FOR EACH
  !< DIFFERENT TOPOLOGIES (E.G. *PVTR* FOR RECTILINEAR TOPOLOGY). SEE THE VTK-STANDARD FILE FOR MORE INFORMATION.
  CLASS(PVTK_FILE), INTENT(INOUT)         :: SELF          !< VTK FILE.
  CHARACTER(*),     INTENT(IN)            :: FILENAME      !< FILE NAME.
  CHARACTER(*),     INTENT(IN)            :: MESH_TOPOLOGY !< MESH TOPOLOGY.
  CHARACTER(*),     INTENT(IN)            :: MESH_KIND     !< KIND OF MESH DATA: FLOAT64, FLOAT32, ECC.
  INTEGER(I4P),     INTENT(IN),  OPTIONAL :: NX1           !< INITIAL NODE OF X AXIS.
  INTEGER(I4P),     INTENT(IN),  OPTIONAL :: NX2           !< FINAL NODE OF X AXIS.
  INTEGER(I4P),     INTENT(IN),  OPTIONAL :: NY1           !< INITIAL NODE OF Y AXIS.
  INTEGER(I4P),     INTENT(IN),  OPTIONAL :: NY2           !< FINAL NODE OF Y AXIS.
  INTEGER(I4P),     INTENT(IN),  OPTIONAL :: NZ1           !< INITIAL NODE OF Z AXIS.
  INTEGER(I4P),     INTENT(IN),  OPTIONAL :: NZ2           !< FINAL NODE OF Z AXIS.
  INTEGER(I4P)                            :: ERROR         !< ERROR STATUS.

  IF (.NOT.IS_INITIALIZED) CALL PENF_INIT
  IF (.NOT.IS_B64_INITIALIZED) CALL B64_INIT
  IF (ALLOCATED(SELF%XML_WRITER)) DEALLOCATE(SELF%XML_WRITER)
  ALLOCATE(XML_WRITER_ASCII_LOCAL :: SELF%XML_WRITER)
  ERROR = SELF%XML_WRITER%INITIALIZE(FORMAT='ascii', FILENAME=FILENAME, MESH_TOPOLOGY=MESH_TOPOLOGY, &
                                     NX1=NX1, NX2=NX2, NY1=NY1, NY2=NY2, NZ1=NZ1, NZ2=NZ2, MESH_KIND=MESH_KIND)
  ENDFUNCTION INITIALIZE

  FUNCTION FINALIZE(SELF) RESULT(ERROR)
  !< FINALIZE FILE (WRITER).
  CLASS(PVTK_FILE), INTENT(INOUT) :: SELF  !< VTK FILE.
  INTEGER(I4P)                    :: ERROR !< ERROR STATUS.

  ERROR = 1
  IF (ALLOCATED(SELF%XML_WRITER)) ERROR = SELF%XML_WRITER%FINALIZE()
  ENDFUNCTION FINALIZE
ENDMODULE VTK_FORTRAN_PVTK_FILE




!< VTK_FORTRAN, PURE FORTRAN (2003+) LIBRARY TO PARSE AND EMITT VTK FILES.
MODULE VTK_FORTRAN
!< VTK_FORTRAN, PURE FORTRAN (2003+) LIBRARY TO PARSE AND EMITT VTK FILES.
USE PENF
USE VTK_FORTRAN_PVTK_FILE, ONLY : PVTK_FILE
USE VTK_FORTRAN_VTK_FILE, ONLY : VTK_FILE
USE VTK_FORTRAN_VTM_FILE, ONLY : VTM_FILE

IMPLICIT NONE
PRIVATE
PUBLIC :: PVTK_FILE
PUBLIC :: VTK_FILE
PUBLIC :: VTM_FILE

ENDMODULE VTK_FORTRAN





























!> \brief Routines for handling vtk output

MODULE VTK_FDS_INTERFACE

USE MESH_VARIABLES
USE GLOBAL_CONSTANTS
USE MESH_POINTERS
USE OUTPUT_DATA
USE VTK_FORTRAN, ONLY : VTK_FILE, PVTK_FILE
USE HDF5
USE MPI_F08
USE COMPLEX_GEOMETRY, ONLY : WRITE_GEOM,WRITE_GEOM_ALL,CC_FGSC,CC_IDCF,CC_IDCC,CC_UNKZ,CC_UNKF,CC_FTYPE_RCGAS,&
                             CC_FTYPE_CFGAS,CC_FTYPE_CFINB,CC_SOLID,FCELL,CC_CGSC,CC_CUTCFE,TRIANGULATE,&
                             CC_VGSC,CC_GASPHASE,MAKE_UNIQUE_VERT_ARRAY,AVERAGE_FACE_VALUES

IMPLICIT NONE (TYPE,EXTERNAL)
PRIVATE

PUBLIC BUILD_VTK_GAS_PHASE_GEOMETRY,BUILD_VTK_SOLID_PHASE_GEOMETRY,BUILD_VTK_SLICE_GEOMETRY,&
       WRITE_VTK_SL3D_WRAPPER,WRITE_VTK_SM3D_WRAPPER,WRITE_VTK_BNDF_WRAPPER,&
       WRITE_VTK_PART_WRAPPER,WRITE_PARAVIEW_STATE_FILE,&
       DEALLOCATE_VTK_GAS_PHASE_GEOMETRY,BUILD_VTK_GEOM_GEOMETRY,WRITE_VTK_GEOM_FILE,&
       WRITE_VTKHDF_GEOM_FILE,WRITE_VTKHDF_RECT_GAS_FILE,ADD_3F32_DATA_TO_VTKHDF_RECT_GAS_FILE,&
       ADD_1F32_DATA_TO_VTKHDF_RECT_GAS_FILE,INITIALIZE_VTKHDF_SLCF,INITIALIZE_VTKHDF_FILES,&
       WRITE_VTKHDF_SLICE_DATA_FILE,WRITE_VTKHDF_SLICE_CELL_FILE,ADD_DATA_TO_SMOKE3D_VTKHDF_FILE,&
       WRITE_VTKHDF_BNDF_CELL_FILE,PARALLEL_INIT_F32,PARALLEL_WRITE_F32,CLOSE_VTKHDF,OPEN_VTKHDF,&
       CLOSE_PART_VTKHDF,OPEN_PART_VTKHDF,PARALLEL_INIT_I32,PARALLEL_WRITE_I32

CONTAINS


SUBROUTINE WRITE_VTK_SL3D_WRAPPER(T,NMESHES,IFMT)
INTEGER, INTENT(IN) :: NMESHES,IFMT
REAL(EB), INTENT(IN) :: T
INTEGER :: I,NQT,IQ,ITM,ITM1,NM
REAL(FB) :: STIME
REAL(EB) :: TT
TYPE(PVTK_FILE)          :: A_PVTK_FILE       !< A parallel (partioned) VTK file.
INTEGER  :: VTK_ERROR                    !< IO Error status.
CHARACTER(200) :: TMP_FILE

! Generate FILENAME
STIME = REAL(T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR,FB)
TT   = T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR
ITM  = INT(TT)
ITM1 = NINT(ABS(TT-ITM)*100)
IF (ITM1==100) THEN
   ITM = ITM+1
   ITM1 = 0
ENDIF

UNIQUE_SLICE_LOOP: DO I = 1,MESHES(1)%N_UNIQUE_SLCF
   IF ((IFMT == 0).AND.(MESHES(1)%UNIQUE_SLICE_IS_SL3D(I))) CYCLE UNIQUE_SLICE_LOOP
   IF ((IFMT == 1).AND.(.NOT.MESHES(1)%UNIQUE_SLICE_IS_SL3D(I))) CYCLE UNIQUE_SLICE_LOOP
   WRITE(FN_SL3D_VTK(I,NMESHES+1),'(A,A,A,A,I8.8,I2.2,A)') TRIM(RESULTS_DIR)//TRIM(CHID),'_',&
                                     TRIM(MESHES(1)%UNIQUE_SLICE_NAMES(I)),'_',ITM,ITM1,'.pvtu'
   VTK_ERROR = A_PVTK_FILE%INITIALIZE(FILENAME=FN_SL3D_VTK(I,NMESHES+1), MESH_TOPOLOGY='PUnstructuredGrid',&
                                      MESH_KIND='Float32')
   VTK_ERROR = A_PVTK_FILE%XML_WRITER%W_DATA(LOCATION='NODE',ACTION='OPEN')
   ! Add PointData arrays
   NQT = MESHES(1)%N_SLCF_VTK
   QUANTITY_LOOP2: DO IQ=1,NQT
      IF (MESHES(1)%ALL_SLICE_NAMES(IQ).NE.MESHES(1)%UNIQUE_SLICE_NAMES(I)) CYCLE QUANTITY_LOOP2
      VTK_ERROR = A_PVTK_FILE%XML_WRITER%WRITE_PARALLEL_DATAARRAY(DATA_NAME=TRIM(MESHES(1)%ALL_SLICE_QUANTITIES(IQ)), &
                                                              DATA_TYPE='Float32', NUMBER_OF_COMPONENTS=1)
   ENDDO QUANTITY_LOOP2
   VTK_ERROR = A_PVTK_FILE%XML_WRITER%W_DATA(LOCATION='NODE',ACTION='CLOSE')
   MESH_LOOP2: DO NM=1,NMESHES
      IF (MESHES(NM)%EMPTY_UNIQUE_SLICE(I)) CYCLE MESH_LOOP2
      WRITE(TMP_FILE,'(A,A,A,A,I0,A,I8.8,I2.2,A)') TRIM(CHID),'_',TRIM(MESHES(1)%UNIQUE_SLICE_NAMES(I)),&
                                     '_',NM,'_',ITM,ITM1,'.vtu'
      VTK_ERROR = A_PVTK_FILE%XML_WRITER%WRITE_PARALLEL_GEO(SOURCE=TMP_FILE)
   ENDDO MESH_LOOP2
   VTK_ERROR = A_PVTK_FILE%FINALIZE()
ENDDO UNIQUE_SLICE_LOOP

END SUBROUTINE WRITE_VTK_SL3D_WRAPPER













SUBROUTINE WRITE_VTK_SM3D_WRAPPER(T,NMESHES)
INTEGER, INTENT(IN) :: NMESHES
REAL(EB), INTENT(IN) :: T
INTEGER :: I,ITM,ITM1,N
REAL(FB) :: STIME
REAL(EB) :: TT
TYPE(SMOKE3D_TYPE), POINTER :: S3
TYPE(PVTK_FILE)          :: A_PVTK_FILE       !< A parallel (partioned) VTK file.
INTEGER  :: VTK_ERROR                    !< IO Error status.
CHARACTER(200) :: TMP_FILE

! Generate FILENAME
STIME = REAL(T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR,FB)
TT   = T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR
ITM  = INT(TT)
ITM1 = NINT(ABS(TT-ITM)*100)
IF (ITM1==100) THEN
   ITM = ITM+1
   ITM1 = 0
ENDIF
WRITE(FN_SMOKE3D_VTK(NMESHES+1),'(A,A,A,A,A,I8.8,I2.2,A)') "",TRIM(RESULTS_DIR)//TRIM(CHID),'_','SM3D',&
                                 '_',ITM,ITM1,'.pvtu'
VTK_ERROR = A_PVTK_FILE%INITIALIZE(FILENAME=FN_SMOKE3D_VTK(NMESHES+1), MESH_TOPOLOGY='PUnstructuredGrid',&
                                   MESH_KIND='Float32')
! Add PointData arrays
VTK_ERROR = A_PVTK_FILE%XML_WRITER%W_DATA(LOCATION='NODE',ACTION='OPEN')
DATA_FILE_LOOP2: DO N=1,N_SMOKE3D
   S3 => SMOKE3D_FILE(N)
   !VTK_ERROR = A_PVTK_FILE%XML_WRITER%WRITE_PARALLEL_DATAARRAY(DATA_NAME=TRIM(S3%SMOKEVIEW_LABEL(1:30)), &
   !                                                        DATA_TYPE='Float32', NUMBER_OF_COMPONENTS=1)
   VTK_ERROR = A_PVTK_FILE%XML_WRITER%WRITE_PARALLEL_DATAARRAY(DATA_NAME=TRIM(S3%SMOKEVIEW_LABEL(1:30)), &
                                                           DATA_TYPE='Int8', NUMBER_OF_COMPONENTS=1)
ENDDO DATA_FILE_LOOP2
VTK_ERROR = A_PVTK_FILE%XML_WRITER%W_DATA(LOCATION='NODE',ACTION='CLOSE')

DO I=1,NMESHES
   WRITE(TMP_FILE,'(A,A,I0,A,I8.8,I2.2,A)') TRIM(CHID),'_SM3D_',I,'_',ITM,ITM1,'.vtu'
   VTK_ERROR = A_PVTK_FILE%XML_WRITER%WRITE_PARALLEL_GEO(SOURCE=TMP_FILE)
ENDDO

VTK_ERROR = A_PVTK_FILE%FINALIZE()
END SUBROUTINE WRITE_VTK_SM3D_WRAPPER



SUBROUTINE WRITE_VTK_BNDF_WRAPPER(T,NMESHES)
INTEGER, INTENT(IN) :: NMESHES
REAL(EB), INTENT(IN) :: T
TYPE(BOUNDARY_FILE_TYPE), POINTER :: BF
INTEGER :: I,IQ,ITM,ITM1
REAL(FB) :: STIME
REAL(EB) :: TT
TYPE(PVTK_FILE)          :: A_PVTK_FILE       !< A parallel (partioned) VTK file.
INTEGER  :: VTK_ERROR                    !< IO Error status.
CHARACTER(200) :: TMP_FILE

! Generate FILENAME
STIME = REAL(T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR,FB)
TT   = T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR
ITM  = INT(TT)
ITM1 = NINT(ABS(TT-ITM)*100)
IF (ITM1==100) THEN
   ITM = ITM+1
   ITM1 = 0
ENDIF
WRITE(FN_BNDF_VTK(NMESHES+1),'(A,A,A,I8.8,I2.2,A)') "",TRIM(RESULTS_DIR)//TRIM(CHID),'_BNDF_',ITM,ITM1,'.pvtu'
VTK_ERROR = A_PVTK_FILE%INITIALIZE(FILENAME=FN_BNDF_VTK(NMESHES+1), MESH_TOPOLOGY='PUnstructuredGrid',&
                                   MESH_KIND='Float32')
! Add PointData arrays
VTK_ERROR = A_PVTK_FILE%XML_WRITER%W_DATA(LOCATION='NODE',ACTION='OPEN')
QUANTITY_LOOP2: DO IQ=1,N_BNDF
   BF => BOUNDARY_FILE(IQ)
   IF (.NOT.BF%CELL_CENTERED) THEN
      VTK_ERROR = A_PVTK_FILE%XML_WRITER%WRITE_PARALLEL_DATAARRAY(DATA_NAME=TRIM(BF%SMOKEVIEW_LABEL(1:30)), &
                                                           DATA_TYPE='Float32', NUMBER_OF_COMPONENTS=1)
   ENDIF
ENDDO QUANTITY_LOOP2
VTK_ERROR = A_PVTK_FILE%XML_WRITER%W_DATA(LOCATION='NODE',ACTION='CLOSE')
! Add CellData arrays
VTK_ERROR = A_PVTK_FILE%XML_WRITER%W_DATA(LOCATION='CELL',ACTION='OPEN')
QUANTITY_LOOP3: DO IQ=1,N_BNDF
   BF => BOUNDARY_FILE(IQ)
   IF (BF%CELL_CENTERED) THEN
      VTK_ERROR = A_PVTK_FILE%XML_WRITER%WRITE_PARALLEL_DATAARRAY(DATA_NAME=TRIM(BF%SMOKEVIEW_LABEL(1:30)), &
                                                           DATA_TYPE='Float32', NUMBER_OF_COMPONENTS=1)
   ENDIF
ENDDO QUANTITY_LOOP3
VTK_ERROR = A_PVTK_FILE%XML_WRITER%W_DATA(LOCATION='CELL',ACTION='CLOSE')

DO I=1,NMESHES
   CALL POINT_TO_MESH(I)
   IF (N_PATCH > 0) THEN
      WRITE(TMP_FILE,'(A,A,I0,A,I8.8,I2.2,A)') TRIM(CHID),'_BNDF_',I,'_',ITM,ITM1,'.vtu'
      VTK_ERROR = A_PVTK_FILE%XML_WRITER%WRITE_PARALLEL_GEO(SOURCE=TMP_FILE)
   ENDIF
ENDDO

VTK_ERROR = A_PVTK_FILE%FINALIZE()
END SUBROUTINE WRITE_VTK_BNDF_WRAPPER



SUBROUTINE WRITE_VTK_PART_WRAPPER(T,NMESHES)
INTEGER, INTENT(IN) :: NMESHES
REAL(EB), INTENT(IN) :: T
TYPE (LAGRANGIAN_PARTICLE_CLASS_TYPE), POINTER :: LPC
INTEGER :: I,ITM,ITM1,N,NN
REAL(FB) :: STIME
REAL(EB) :: TT
TYPE(PVTK_FILE)          :: A_PVTK_FILE       !< A parallel (partioned) VTK file.
!INTEGER(IB8)  :: VTK_ERROR=0_IB8                    !< IO Error status.
INTEGER :: VTK_ERROR
CHARACTER(200) :: TMP_FILE

! Generate FILENAME
STIME = REAL(T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR,FB)
TT   = T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR
ITM  = INT(TT)
ITM1 = NINT(ABS(TT-ITM)*100)
IF (ITM1==100) THEN
   ITM = ITM+1
   ITM1 = 0
ENDIF

DO N=1,N_LAGRANGIAN_CLASSES
   LPC => LAGRANGIAN_PARTICLE_CLASS(N)
   WRITE(FN_PART_VTK(N,NMESHES+1),'(A,A,A,A,A,I8.8,I2.2,A)') "",TRIM(RESULTS_DIR)//TRIM(CHID),'_PART_',TRIM(LPC%ID),&
                                  '_',ITM,ITM1,'.pvtp'
   VTK_ERROR = A_PVTK_FILE%INITIALIZE(FILENAME=FN_PART_VTK(N,NMESHES+1), MESH_TOPOLOGY='PPolyData',&
                                      MESH_KIND='Float64')
   VTK_ERROR = A_PVTK_FILE%XML_WRITER%W_DATA(LOCATION='NODE',ACTION='OPEN')
   VTK_ERROR = A_PVTK_FILE%XML_WRITER%WRITE_PARALLEL_DATAARRAY(DATA_NAME="TAG", DATA_TYPE='Int32', NUMBER_OF_COMPONENTS=1)
   VTK_ERROR = A_PVTK_FILE%XML_WRITER%WRITE_PARALLEL_DATAARRAY(DATA_NAME="COLOR", DATA_TYPE='Float32', NUMBER_OF_COMPONENTS=3)
   ! Add PointData arrays
   DO NN=1,LPC%N_QUANTITIES
      VTK_ERROR = A_PVTK_FILE%XML_WRITER%WRITE_PARALLEL_DATAARRAY(DATA_NAME=TRIM(LPC%SMOKEVIEW_LABEL(NN)), &
                                                              DATA_TYPE='Float64', NUMBER_OF_COMPONENTS=1)
   ENDDO
   VTK_ERROR = A_PVTK_FILE%XML_WRITER%W_DATA(LOCATION='NODE',ACTION='CLOSE')

   DO I=1,NMESHES
      WRITE(TMP_FILE,'(A,A,A,A,I0,A,I8.8,I2.2,A)') TRIM(CHID),'_PART_',TRIM(LPC%ID),'_',I,'_',ITM,ITM1,'.vtp'
      VTK_ERROR = A_PVTK_FILE%XML_WRITER%WRITE_PARALLEL_GEO(SOURCE=TMP_FILE)
   ENDDO
   VTK_ERROR = A_PVTK_FILE%FINALIZE()
ENDDO

END SUBROUTINE WRITE_VTK_PART_WRAPPER




SUBROUTINE BUILD_VTK_GAS_PHASE_GEOMETRY(NM, &
                                        NC, NP, X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)

INTEGER :: NX, NY, NZ, NC, NP, I, J, K, IFACT, JFACT, KFACT
REAL(FB), ALLOCATABLE, DIMENSION(:) :: X_PTS, Y_PTS, Z_PTS
INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
INTEGER, INTENT(IN) :: NM

NX = SIZE(MESHES(NM)%X)
NY = SIZE(MESHES(NM)%Y)
NZ = SIZE(MESHES(NM)%Z)

NP = NX*NY*NZ
NC = (NX-1)*(NY-1)*(NZ-1)

! Fill point data
ALLOCATE(X_PTS(NP))
ALLOCATE(Y_PTS(NP))
ALLOCATE(Z_PTS(NP))
IFACT = 1
DO K = 0, NZ-1
   DO J = 0, NY-1
      DO I = 0, NX-1
         X_PTS(IFACT)=REAL(MESHES(NM)%X(I),FB)
         Y_PTS(IFACT)=REAL(MESHES(NM)%Y(J),FB)
         Z_PTS(IFACT)=REAL(MESHES(NM)%Z(K),FB)
         IFACT = IFACT + 1
      ENDDO
   ENDDO
ENDDO

! Fill cell data
ALLOCATE(CONNECT(NC*8))
DO I = 1, NX-1
   IFACT = (I-1)
   DO J = 1, NY-1
      JFACT = (J-1)*(NX-1)
      DO K = 1, NZ-1
         KFACT = (K - 1)*(NY-1)*(NX-1)
         CONNECT((IFACT+JFACT+KFACT)*8+1) = (K-1)*(NY*NX) + (J-1)*NX + I-1
         CONNECT((IFACT+JFACT+KFACT)*8+2) = (K-1)*(NY*NX) + (J-1)*NX + I
         CONNECT((IFACT+JFACT+KFACT)*8+3) = (K-1)*(NY*NX) + (J)*NX + I-1
         CONNECT((IFACT+JFACT+KFACT)*8+4) = (K-1)*(NY*NX) + (J)*NX + I
         CONNECT((IFACT+JFACT+KFACT)*8+5) = (K)*(NY*NX) + (J-1)*NX + I-1
         CONNECT((IFACT+JFACT+KFACT)*8+6) = (K)*(NY*NX) + (J-1)*NX + I
         CONNECT((IFACT+JFACT+KFACT)*8+7) = (K)*(NY*NX) + (J)*NX + I-1
         CONNECT((IFACT+JFACT+KFACT)*8+8) = (K)*(NY*NX) + (J)*NX + I
      ENDDO
   ENDDO
ENDDO

ALLOCATE(OFFSETS(NC))
ALLOCATE(VTKC_TYPE(NC))

DO I=1,NC
   OFFSETS(I) = (I)*8_IB32
   VTKC_TYPE(I) = 11_IB8
ENDDO

ENDSUBROUTINE BUILD_VTK_GAS_PHASE_GEOMETRY


SUBROUTINE BUILD_VTK_GAS_PHASE_GEOMETRY2(NM, &
                                        NC, NP, VERTICES, CONNECT, OFFSETS, VTKC_TYPE)

INTEGER :: NX, NY, NZ, NC, NP, I, J, K, IFACT, JFACT, KFACT
REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: VERTICES
INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
INTEGER, INTENT(IN) :: NM

NX = SIZE(MESHES(NM)%X)
NY = SIZE(MESHES(NM)%Y)
NZ = SIZE(MESHES(NM)%Z)

NP = NX*NY*NZ
NC = (NX-1)*(NY-1)*(NZ-1)

! Fill point data
ALLOCATE(VERTICES(3,NP))
IFACT = 1
DO K = 0, NZ-1
   DO J = 0, NY-1
      DO I = 0, NX-1
         VERTICES(1, IFACT)=REAL(MESHES(NM)%X(I),FB)
         VERTICES(2, IFACT)=REAL(MESHES(NM)%Y(J),FB)
         VERTICES(3,IFACT)=REAL(MESHES(NM)%Z(K),FB)
         IFACT = IFACT + 1
      ENDDO
   ENDDO
ENDDO

! Fill cell data
ALLOCATE(CONNECT(NC*8))
DO I = 1, NX-1
   IFACT = (I-1)
   DO J = 1, NY-1
      JFACT = (J-1)*(NX-1)
      DO K = 1, NZ-1
         KFACT = (K - 1)*(NY-1)*(NX-1)
         CONNECT((IFACT+JFACT+KFACT)*8+1) = (K-1)*(NY*NX) + (J-1)*NX + I-1
         CONNECT((IFACT+JFACT+KFACT)*8+2) = (K-1)*(NY*NX) + (J-1)*NX + I
         CONNECT((IFACT+JFACT+KFACT)*8+3) = (K-1)*(NY*NX) + (J)*NX + I-1
         CONNECT((IFACT+JFACT+KFACT)*8+4) = (K-1)*(NY*NX) + (J)*NX + I
         CONNECT((IFACT+JFACT+KFACT)*8+5) = (K)*(NY*NX) + (J-1)*NX + I-1
         CONNECT((IFACT+JFACT+KFACT)*8+6) = (K)*(NY*NX) + (J-1)*NX + I
         CONNECT((IFACT+JFACT+KFACT)*8+7) = (K)*(NY*NX) + (J)*NX + I-1
         CONNECT((IFACT+JFACT+KFACT)*8+8) = (K)*(NY*NX) + (J)*NX + I
      ENDDO
   ENDDO
ENDDO

ALLOCATE(OFFSETS(NC+1))
ALLOCATE(VTKC_TYPE(NC))

OFFSETS(1) = 0
DO I=1,NC
   OFFSETS(I+1) = (I)*8_IB32
   VTKC_TYPE(I) = 11_IB8
ENDDO

ENDSUBROUTINE BUILD_VTK_GAS_PHASE_GEOMETRY2



SUBROUTINE BUILD_VTK_SLICE_GEOMETRY(NM, SL, &
                                        NC, NP, X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)

INTEGER :: NX, NY, NZ, NC, NP, I, J, K, IFACT, JFACT, KFACT
INTEGER :: I1,I2,J1,J2,K1,K2,L1,L2,N1,N2
REAL(FB), ALLOCATABLE, DIMENSION(:) :: X_PTS, Y_PTS, Z_PTS
INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
INTEGER, INTENT(IN) :: NM
TYPE(SLICE_TYPE), POINTER, INTENT(IN) :: SL

I1  = SL%I1
I2  = SL%I2
J1  = SL%J1
J2  = SL%J2
K1  = SL%K1
K2  = SL%K2

NX = I2 + 1 - I1
NY = J2 + 1 - J1
NZ = K2 + 1 - K1

NP = NX*NY*NZ
NC = MAX((NX-1),1)*MAX((NY-1),1)*MAX((NZ-1),1)

! Fill point data
ALLOCATE(X_PTS(NP))
ALLOCATE(Y_PTS(NP))
ALLOCATE(Z_PTS(NP))
IF (I2-I1==0 .OR. J2-J1==0 .OR. K2-K1==0) THEN
   IFACT = 1
   IF (I2-I1==0) THEN
      DO K = K1, K2
         DO J = J1, J2
            X_PTS(IFACT)=REAL(MESHES(NM)%X(I1),FB)
            Y_PTS(IFACT)=REAL(MESHES(NM)%Y(J),FB)
            Z_PTS(IFACT)=REAL(MESHES(NM)%Z(K),FB)
            IFACT = IFACT + 1
         ENDDO
      ENDDO
   ELSEIF (J2-J1==0) THEN
      DO K = K1, K2
         DO I = I1, I2
            X_PTS(IFACT)=REAL(MESHES(NM)%X(I),FB)
            Y_PTS(IFACT)=REAL(MESHES(NM)%Y(J1),FB)
            Z_PTS(IFACT)=REAL(MESHES(NM)%Z(K),FB)
            IFACT = IFACT + 1
         ENDDO
      ENDDO
   ELSEIF (K2-K1==0) THEN
      DO J = J1, J2
         DO I = I1, I2
            X_PTS(IFACT)=REAL(MESHES(NM)%X(I),FB)
            Y_PTS(IFACT)=REAL(MESHES(NM)%Y(J),FB)
            Z_PTS(IFACT)=REAL(MESHES(NM)%Z(K1),FB)
            IFACT = IFACT + 1
         ENDDO
      ENDDO
   ENDIF
ELSE
   IFACT = 1
   DO K = K1, K2
      DO J = J1, J2
         DO I = I1, I2
            X_PTS(IFACT)=REAL(MESHES(NM)%X(I),FB)
            Y_PTS(IFACT)=REAL(MESHES(NM)%Y(J),FB)
            Z_PTS(IFACT)=REAL(MESHES(NM)%Z(K),FB)
            IFACT = IFACT + 1
         ENDDO
      ENDDO
   ENDDO
ENDIF

! Fill cell data
ALLOCATE(OFFSETS(NC))
ALLOCATE(VTKC_TYPE(NC))
IF (I2-I1==0 .OR. J2-J1==0 .OR. K2-K1==0) THEN
   !2-D slice
   ALLOCATE(CONNECT(NC*4))
   
   IF (I2-I1==0) THEN
      L1=J1 ; L2=J2
      N1=K1 ; N2=K2;
   ELSEIF (J2-J1==0) THEN
      L1=I1 ; L2=I2
      N1=K1 ; N2=K2;
   ELSEIF (K2-K1==0) THEN
      L1=I1 ; L2=I2
      N1=J1 ; N2=J2;
   ENDIF
   
   IFACT = 0
   DO I = 1, (L2-L1)
      DO J = 1, (N2-N1)
         CONNECT((IFACT)*4+1) = (L2-L1+1)*(J-1)+(I-1)
         CONNECT((IFACT)*4+2) = (L2-L1+1)*(J-1)+(I)
         CONNECT((IFACT)*4+3) = (L2-L1+1)*(J)+(I-1)
         CONNECT((IFACT)*4+4) = (L2-L1+1)*(J)+(I)
         IFACT = IFACT+1
      ENDDO
   ENDDO

   DO I=1,NC
      OFFSETS(I) = (I)*4_IB32
      VTKC_TYPE(I) = 8_IB8
   ENDDO
   
ELSE
   !3-D slice
   ALLOCATE(CONNECT(NC*8))
   DO I = 1, NX-1
      IFACT = (I-1)
      DO J = 1, NY-1
         JFACT = (J-1)*(NX-1)
         DO K = 1, NZ-1
            KFACT = (K - 1)*(NY-1)*(NX-1)
            CONNECT((IFACT+JFACT+KFACT)*8+1) = (K-1)*(NY*NX) + (J-1)*NX + I-1
            CONNECT((IFACT+JFACT+KFACT)*8+2) = (K-1)*(NY*NX) + (J-1)*NX + I
            CONNECT((IFACT+JFACT+KFACT)*8+3) = (K-1)*(NY*NX) + (J)*NX + I-1
            CONNECT((IFACT+JFACT+KFACT)*8+4) = (K-1)*(NY*NX) + (J)*NX + I
            CONNECT((IFACT+JFACT+KFACT)*8+5) = (K)*(NY*NX) + (J-1)*NX + I-1
            CONNECT((IFACT+JFACT+KFACT)*8+6) = (K)*(NY*NX) + (J-1)*NX + I
            CONNECT((IFACT+JFACT+KFACT)*8+7) = (K)*(NY*NX) + (J)*NX + I-1
            CONNECT((IFACT+JFACT+KFACT)*8+8) = (K)*(NY*NX) + (J)*NX + I
         ENDDO
      ENDDO
   ENDDO
   
   DO I=1,NC
      OFFSETS(I) = (I)*8_IB32
      VTKC_TYPE(I) = 11_IB8
   ENDDO
   
ENDIF
         
ENDSUBROUTINE BUILD_VTK_SLICE_GEOMETRY


SUBROUTINE BUILD_VTK_SLICE_GEOMETRY2(NM, SL, &
                                        NC, NP, VERTICES, CONNECT, OFFSETS, VTKC_TYPE)

INTEGER :: NX, NY, NZ, NC, NP, I, J, K, IFACT, JFACT, KFACT
INTEGER :: I1,I2,J1,J2,K1,K2,L1,L2,N1,N2
REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: VERTICES
INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
INTEGER, INTENT(IN) :: NM
TYPE(SLICE_TYPE), POINTER, INTENT(IN) :: SL

I1  = SL%I1
I2  = SL%I2
J1  = SL%J1
J2  = SL%J2
K1  = SL%K1
K2  = SL%K2

NX = I2 + 1 - I1
NY = J2 + 1 - J1
NZ = K2 + 1 - K1

NP = NX*NY*NZ
NC = MAX((NX-1),1)*MAX((NY-1),1)*MAX((NZ-1),1)

! Fill point data
ALLOCATE(VERTICES(3,NP))
IF (I2-I1==0 .OR. J2-J1==0 .OR. K2-K1==0) THEN
   IFACT = 1
   IF (I2-I1==0) THEN
      DO K = K1, K2
         DO J = J1, J2
            VERTICES(1,IFACT)=REAL(MESHES(NM)%X(I1),FB)
            VERTICES(2,IFACT)=REAL(MESHES(NM)%Y(J),FB)
            VERTICES(3,IFACT)=REAL(MESHES(NM)%Z(K),FB)
            IFACT = IFACT + 1
         ENDDO
      ENDDO
   ELSEIF (J2-J1==0) THEN
      DO K = K1, K2
         DO I = I1, I2
            VERTICES(1,IFACT)=REAL(MESHES(NM)%X(I),FB)
            VERTICES(2,IFACT)=REAL(MESHES(NM)%Y(J1),FB)
            VERTICES(3,IFACT)=REAL(MESHES(NM)%Z(K),FB)
            IFACT = IFACT + 1
         ENDDO
      ENDDO
   ELSEIF (K2-K1==0) THEN
      DO J = J1, J2
         DO I = I1, I2
            VERTICES(1,IFACT)=REAL(MESHES(NM)%X(I),FB)
            VERTICES(2,IFACT)=REAL(MESHES(NM)%Y(J),FB)
            VERTICES(3,IFACT)=REAL(MESHES(NM)%Z(K1),FB)
            IFACT = IFACT + 1
         ENDDO
      ENDDO
   ENDIF
ELSE
   IFACT = 1
   DO K = K1, K2
      DO J = J1, J2
         DO I = I1, I2
            VERTICES(1,IFACT)=REAL(MESHES(NM)%X(I),FB)
            VERTICES(2,IFACT)=REAL(MESHES(NM)%Y(J),FB)
            VERTICES(3,IFACT)=REAL(MESHES(NM)%Z(K),FB)
            IFACT = IFACT + 1
         ENDDO
      ENDDO
   ENDDO
ENDIF

! Fill cell data
ALLOCATE(OFFSETS(NC+1))
ALLOCATE(VTKC_TYPE(NC))
IF (I2-I1==0 .OR. J2-J1==0 .OR. K2-K1==0) THEN
   !2-D slice
   ALLOCATE(CONNECT(NC*4))
   
   IF (I2-I1==0) THEN
      L1=J1 ; L2=J2
      N1=K1 ; N2=K2;
   ELSEIF (J2-J1==0) THEN
      L1=I1 ; L2=I2
      N1=K1 ; N2=K2;
   ELSEIF (K2-K1==0) THEN
      L1=I1 ; L2=I2
      N1=J1 ; N2=J2;
   ENDIF
   
   IFACT = 0
   DO I = 1, (L2-L1)
      DO J = 1, (N2-N1)
         CONNECT((IFACT)*4+1) = (L2-L1+1)*(J-1)+(I-1)
         CONNECT((IFACT)*4+2) = (L2-L1+1)*(J-1)+(I)
         CONNECT((IFACT)*4+3) = (L2-L1+1)*(J)+(I-1)
         CONNECT((IFACT)*4+4) = (L2-L1+1)*(J)+(I)
         IFACT = IFACT+1
      ENDDO
   ENDDO
   OFFSETS(1) = 0
   DO I=1,NC
      OFFSETS(I+1) = (I)*4_IB32
      VTKC_TYPE(I) = 8_IB8
   ENDDO
   
ELSE
   !3-D slice
   ALLOCATE(CONNECT(NC*8))
   DO I = 1, NX-1
      IFACT = (I-1)
      DO J = 1, NY-1
         JFACT = (J-1)*(NX-1)
         DO K = 1, NZ-1
            KFACT = (K - 1)*(NY-1)*(NX-1)
            CONNECT((IFACT+JFACT+KFACT)*8+1) = (K-1)*(NY*NX) + (J-1)*NX + I-1
            CONNECT((IFACT+JFACT+KFACT)*8+2) = (K-1)*(NY*NX) + (J-1)*NX + I
            CONNECT((IFACT+JFACT+KFACT)*8+3) = (K-1)*(NY*NX) + (J)*NX + I-1
            CONNECT((IFACT+JFACT+KFACT)*8+4) = (K-1)*(NY*NX) + (J)*NX + I
            CONNECT((IFACT+JFACT+KFACT)*8+5) = (K)*(NY*NX) + (J-1)*NX + I-1
            CONNECT((IFACT+JFACT+KFACT)*8+6) = (K)*(NY*NX) + (J-1)*NX + I
            CONNECT((IFACT+JFACT+KFACT)*8+7) = (K)*(NY*NX) + (J)*NX + I-1
            CONNECT((IFACT+JFACT+KFACT)*8+8) = (K)*(NY*NX) + (J)*NX + I
         ENDDO
      ENDDO
   ENDDO
   
   OFFSETS(1) = 0
   DO I=1,NC
      OFFSETS(I+1) = (I)*8_IB32
      VTKC_TYPE(I) = 11_IB8
   ENDDO
   
ENDIF
         
ENDSUBROUTINE BUILD_VTK_SLICE_GEOMETRY2


SUBROUTINE BUILD_VTK_SOLID_PHASE_GEOMETRY(NM, PA, &
                                          NCELLS, NPOINTS, X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)

INTEGER :: NX,NY,NZ,NCELLS,NPOINTS,I,J,K,IFACT,L1,L2,N1,N2
REAL(FB), ALLOCATABLE, DIMENSION(:) :: X_PTS, Y_PTS, Z_PTS
INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
INTEGER, INTENT(IN) :: NM
TYPE(PATCH_TYPE), POINTER, INTENT(IN) :: PA

! Fill point data
SELECT CASE(ABS(PA%IOR))
   CASE(1) ; L1=PA%JG1 ; L2=PA%JG2 ; N1=PA%KG1 ; N2=PA%KG2 ; NX=1; NY=(L2-L1); NZ=(N2-N1)
   CASE(2) ; L1=PA%IG1 ; L2=PA%IG2 ; N1=PA%KG1 ; N2=PA%KG2 ; NX=(L2-L1); NY=1; NZ=(N2-N1)
   CASE(3) ; L1=PA%IG1 ; L2=PA%IG2 ; N1=PA%JG1 ; N2=PA%JG2 ; NX=(L2-L1); NY=(N2-N1); NZ=1
END SELECT
NPOINTS = (L2-L1+2)*(N2-N1+2)
NCELLS = (L2-L1+1)*(N2-N1+1)
ALLOCATE(X_PTS(NPOINTS))
ALLOCATE(Y_PTS(NPOINTS))
ALLOCATE(Z_PTS(NPOINTS))
ALLOCATE(CONNECT(NCELLS*4))
ALLOCATE(OFFSETS(NCELLS))
ALLOCATE(VTKC_TYPE(NCELLS))
IFACT = 1
SELECT CASE(ABS(PA%IOR))
   CASE(1)
      DO K = PA%K1,PA%K2
         DO J = PA%J1,PA%J2
            X_PTS(IFACT)=REAL(MESHES(NM)%X(PA%I1),FB)
            Y_PTS(IFACT)=REAL(MESHES(NM)%Y(J),FB)
            Z_PTS(IFACT)=REAL(MESHES(NM)%Z(K),FB)
            IFACT = IFACT + 1
         ENDDO
      ENDDO
   CASE(2)
      DO K = PA%K1,PA%K2
         DO I = PA%I1,PA%I2
            X_PTS(IFACT)=REAL(MESHES(NM)%X(I),FB)
            Y_PTS(IFACT)=REAL(MESHES(NM)%Y(PA%J1),FB)
            Z_PTS(IFACT)=REAL(MESHES(NM)%Z(K),FB)
            IFACT = IFACT + 1
         ENDDO
      ENDDO
   CASE(3)
      DO J = PA%J1,PA%J2
         DO I = PA%I1,PA%I2
            X_PTS(IFACT)=REAL(MESHES(NM)%X(I),FB)
            Y_PTS(IFACT)=REAL(MESHES(NM)%Y(J),FB)
            Z_PTS(IFACT)=REAL(MESHES(NM)%Z(PA%K1),FB)
            IFACT = IFACT + 1
         ENDDO
      ENDDO
END SELECT

! Fill cell data

IFACT = 0
DO I = 1, (L2-L1+1)
   DO J = 1, (N2-N1+1)
      CONNECT((IFACT)*4+1) = (L2-L1+2)*(J-1)+(I-1)
      CONNECT((IFACT)*4+2) = (L2-L1+2)*(J-1)+(I)
      CONNECT((IFACT)*4+3) = (L2-L1+2)*(J)+(I-1)
      CONNECT((IFACT)*4+4) = (L2-L1+2)*(J)+(I)
      IFACT = IFACT+1
   ENDDO
ENDDO

DO I=1,NCELLS
   OFFSETS(I) = (I)*4_IB32
   VTKC_TYPE(I) = 8_IB8
ENDDO

ENDSUBROUTINE BUILD_VTK_SOLID_PHASE_GEOMETRY


SUBROUTINE BUILD_VTK_GEOM_GEOMETRY(VERTS, FACES, NCELLS, NPOINTS,&
                                   X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)

!INTEGER :: NX,NY,NZ,NCELLS,NPOINTS,I,J,K,IFACT,JFACT,KFACT,L,L1,L2,N,N1,N2

REAL(FB), ALLOCATABLE, DIMENSION(:), INTENT(IN) :: VERTS
INTEGER, ALLOCATABLE, DIMENSION(:), INTENT(IN) :: FACES
REAL(FB), ALLOCATABLE, DIMENSION(:) :: X_PTS, Y_PTS, Z_PTS
INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
INTEGER :: I
INTEGER :: NPOINTS, NCELLS, NFACES

NPOINTS = SIZE(VERTS)/3
NCELLS = SIZE(FACES)/3
NFACES = SIZE(FACES)

ALLOCATE(X_PTS(NPOINTS))
ALLOCATE(Y_PTS(NPOINTS))
ALLOCATE(Z_PTS(NPOINTS))
ALLOCATE(CONNECT(NCELLS*3))
ALLOCATE(OFFSETS(NCELLS))
ALLOCATE(VTKC_TYPE(NCELLS))

DO I=1,NPOINTS
   X_PTS(I) = VERTS((I-1)*3+1)
   Y_PTS(I) = VERTS((I-1)*3+2)
   Z_PTS(I) = VERTS((I-1)*3+3)
ENDDO

DO I=1,NCELLS
   OFFSETS(I) = (I)*3_IB32
   VTKC_TYPE(I) = 5_IB8
   CONNECT(3*(I-1)+1) = FACES(3*(I-1)+1)-1
   CONNECT(3*(I-1)+2) = FACES(3*(I-1)+2)-1
   CONNECT(3*(I-1)+3) = FACES(3*(I-1)+3)-1
ENDDO

ENDSUBROUTINE BUILD_VTK_GEOM_GEOMETRY




SUBROUTINE DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)

REAL(FB), DIMENSION(:), ALLOCATABLE :: X_PTS, Y_PTS, Z_PTS
INTEGER(IB32), DIMENSION(:), ALLOCATABLE :: CONNECT, OFFSETS
INTEGER(IB8), DIMENSION(:), ALLOCATABLE :: VTKC_TYPE

DEALLOCATE(VTKC_TYPE)
DEALLOCATE(OFFSETS)
DEALLOCATE(CONNECT)
DEALLOCATE(X_PTS)
DEALLOCATE(Y_PTS)
DEALLOCATE(Z_PTS)

ENDSUBROUTINE DEALLOCATE_VTK_GAS_PHASE_GEOMETRY


SUBROUTINE WRITE_VTK_GEOM_FILE
   ! Parts of this subroutine use content from stack overflow
   ! Original question: https://stackoverflow.com/questions/34144786
   ! User whos answer is integrated: https://stackoverflow.com/users/4621823/chw21
   !character(len=*), parameter :: fname = 'fds.stl'
   INTEGER :: I,IFACT,J,N,NM,FACES(6, 4) !,GEOM_VERTICES_IDS(1,3)
   REAL(FB) :: XB(6)
   !REAL(FB) :: GEOM_VERTICES(3,3)
   INTEGER(IB8) :: COLOR(3) !, ONE
   INTEGER(IB32) :: NFACES,NVERTS
   REAL(FB), DIMENSION(:,:), ALLOCATABLE :: COLORS
   REAL(FB), DIMENSION(:,:), ALLOCATABLE :: VERTICES
   INTEGER(IB32), DIMENSION(:,:), ALLOCATABLE :: FACES_OUT
   REAL(FB), DIMENSION(:), ALLOCATABLE :: X_PTS, Y_PTS, Z_PTS
   INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
   INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
   INTEGER :: NPOINTS, NCELLS !, NFACES
   TYPE(VTK_FILE)          :: A_VTK_FILE       !< A parallel (partioned) VTK file.
   TYPE(PVTK_FILE)          :: A_PVTK_FILE       !< A parallel (partioned) VTK file.
   TYPE (MESH_TYPE), POINTER :: M
   TYPE (GEOMETRY_TYPE), POINTER :: G=>NULL()
   TYPE (OBSTRUCTION_TYPE), POINTER :: OB=>NULL()
   INTEGER  :: VTK_ERROR                    !< IO Error status.
   CHARACTER(200) :: TMP_FILE
   !TYPE (SURFACE_TYPE),POINTER :: SF=>NULL()

   COLOR = INT((/0,0,0/),IB8)
   
   FACES(1,:) = (/0,3,4,7/)
   FACES(2,:) = (/1,2,5,6/)
   FACES(3,:) = (/0,1,4,5/)
   FACES(4,:) = (/2,3,6,7/)
   FACES(5,:) = (/0,3,1,2/)
   FACES(6,:) = (/4,7,5,6/)
   
   IF (MY_RANK==0) THEN
      WRITE(FN_OBST_VTK(NMESHES+1),'(A,A,A)') "",TRIM(CHID),'_GEOM.pvtu'
      VTK_ERROR = A_PVTK_FILE%INITIALIZE(FILENAME=FN_OBST_VTK(NMESHES+1), MESH_TOPOLOGY='PUnstructuredGrid',&
                                      MESH_KIND='Float32')
      VTK_ERROR = A_PVTK_FILE%XML_WRITER%W_DATA(LOCATION='CELL',ACTION='OPEN')
      VTK_ERROR = A_PVTK_FILE%XML_WRITER%WRITE_PARALLEL_DATAARRAY(DATA_NAME='Color', &
                                                              DATA_TYPE='Float32', NUMBER_OF_COMPONENTS=3)
      VTK_ERROR = A_PVTK_FILE%XML_WRITER%W_DATA(LOCATION='CELL',ACTION='CLOSE')
      DO NM=1,NMESHES
         WRITE(TMP_FILE,'(A,A,A,I0,A)') "",TRIM(RESULTS_DIR)//TRIM(CHID),'_OBST_',NM,'.vtu'
         VTK_ERROR = A_PVTK_FILE%XML_WRITER%WRITE_PARALLEL_GEO(SOURCE=TMP_FILE)
      ENDDO
      DO I= 1,N_GEOMETRY
         WRITE(TMP_FILE,'(A,A,A,I0,A)') "",TRIM(RESULTS_DIR)//TRIM(CHID),'_GEOM_',I,'.vtu'
         VTK_ERROR = A_PVTK_FILE%XML_WRITER%WRITE_PARALLEL_GEO(SOURCE=TMP_FILE)
      ENDDO
      VTK_ERROR = A_PVTK_FILE%FINALIZE()
   ENDIF
   
   MESH_LOOP: DO NM=1,NMESHES
      IF (PROCESS(NM)/=MY_RANK) CYCLE MESH_LOOP
      WRITE(FN_OBST_VTK(NM),'(A,A,A,I0,A)') "",TRIM(RESULTS_DIR)//TRIM(CHID),'_OBST_',NM,'.vtu'
      IF (VTK_BINARY) THEN
         VTK_ERROR = A_VTK_FILE%INITIALIZE(FORMAT='raw', FILENAME=FN_OBST_VTK(NM), MESH_TOPOLOGY='UnstructuredGrid')
      ELSE
         VTK_ERROR = A_VTK_FILE%INITIALIZE(FORMAT='ascii', FILENAME=FN_OBST_VTK(NM), MESH_TOPOLOGY='UnstructuredGrid')
      ENDIF ! do not change capitalization on mesh topology
      M => MESHES(NM)
      ! Output OBST geometry data
      NPOINTS = M%N_OBST*8
      NCELLS = M%N_OBST*6
      ALLOCATE(COLORS(NCELLS,3))
      ALLOCATE(FACES_OUT(NCELLS,4))
      ALLOCATE(VERTICES(NPOINTS,3))
      ALLOCATE(X_PTS(NPOINTS))
      ALLOCATE(Y_PTS(NPOINTS))
      ALLOCATE(Z_PTS(NPOINTS))
      ALLOCATE(OFFSETS(NCELLS))
      ALLOCATE(CONNECT(NCELLS*4))
      ALLOCATE(VTKC_TYPE(NCELLS))
      DO N=1,M%N_OBST
         OB=>M%OBSTRUCTION(N)
         XB(:) = REAL((/OB%X1,OB%X2,OB%Y1,OB%Y2,OB%Z1,OB%Z2/),FB)
         IF (OB%RGB(1)==-1) THEN
            COLORS((N-1)*6+1,1:3) = REAL(SURFACE(OB%SURF_INDEX(-1))%RGB,FB)/255._FB
            COLORS((N-1)*6+2,1:3) = REAL(SURFACE(OB%SURF_INDEX(1))%RGB,FB)/255._FB
            COLORS((N-1)*6+3,1:3) = REAL(SURFACE(OB%SURF_INDEX(-2))%RGB,FB)/255._FB
            COLORS((N-1)*6+4,1:3) = REAL(SURFACE(OB%SURF_INDEX(2))%RGB,FB)/255._FB
            COLORS((N-1)*6+5,1:3) = REAL(SURFACE(OB%SURF_INDEX(-3))%RGB,FB)/255._FB
            COLORS((N-1)*6+6,1:3) = REAL(SURFACE(OB%SURF_INDEX(3))%RGB,FB)/255._FB
         ELSE
            COLORS((N-1)*6+1,1:3) = REAL(OB%RGB,FB)/255._FB
            COLORS((N-1)*6+2,1:3) = REAL(OB%RGB,FB)/255._FB
            COLORS((N-1)*6+3,1:3) = REAL(OB%RGB,FB)/255._FB
            COLORS((N-1)*6+4,1:3) = REAL(OB%RGB,FB)/255._FB
            COLORS((N-1)*6+5,1:3) = REAL(OB%RGB,FB)/255._FB
            COLORS((N-1)*6+6,1:3) = REAL(OB%RGB,FB)/255._FB
         ENDIF
         VERTICES((N-1)*8+1:N*8,1:3) = GET_VERTICES(XB)
         X_PTS((N-1)*8+1:N*8) = VERTICES((N-1)*8+1:N*8,1)
         Y_PTS((N-1)*8+1:N*8) = VERTICES((N-1)*8+1:N*8,2)
         Z_PTS((N-1)*8+1:N*8) = VERTICES((N-1)*8+1:N*8,3)
         FACES_OUT((N-1)*6+1:N*6,1:4) = FACES + (N-1)*8
      END DO
      IFACT = 0
      DO I = 1, NCELLS
         DO J = 1, 4
            CONNECT((IFACT)*4+J) = FACES_OUT(I, J)
         ENDDO
         IFACT = IFACT+1
      ENDDO
      
      DO I=1,NCELLS
         OFFSETS(I) = (I)*4_IB32
         VTKC_TYPE(I) = 8_IB8
      ENDDO
      VTK_ERROR = A_VTK_FILE%XML_WRITER%WRITE_PIECE(NP=NPOINTS, NC=NCELLS)
      VTK_ERROR = A_VTK_FILE%XML_WRITER%WRITE_GEO(NP=NPOINTS, NC=NCELLS, X=X_PTS, Y=Y_PTS, Z=Z_PTS)
      VTK_ERROR = A_VTK_FILE%XML_WRITER%WRITE_CONNECTIVITY(NC=NCELLS, CONNECTIVITY=CONNECT, OFFSET=OFFSETS, VTKC_TYPE=VTKC_TYPE)
      VTK_ERROR = A_VTK_FILE%XML_WRITER%W_DATA(LOCATION='CELL', ACTION='OPEN')
      VTK_ERROR = A_VTK_FILE%XML_WRITER%W_DATA(DATA_NAME='Color', X=COLORS(:,1),Y=COLORS(:,2),Z=COLORS(:,3))
      VTK_ERROR = A_VTK_FILE%XML_WRITER%W_DATA(LOCATION='CELL', ACTION='CLOSE')
      DEALLOCATE(COLORS)
      DEALLOCATE(FACES_OUT)
      DEALLOCATE(VERTICES)
      DEALLOCATE(X_PTS)
      DEALLOCATE(Y_PTS)
      DEALLOCATE(Z_PTS)
      DEALLOCATE(OFFSETS)
      DEALLOCATE(CONNECT)
      DEALLOCATE(VTKC_TYPE)
      VTK_ERROR = A_VTK_FILE%XML_WRITER%WRITE_PIECE()
      VTK_ERROR = A_VTK_FILE%FINALIZE()
   ENDDO MESH_LOOP
   
   ! Output GEOM geometry data
   IF ((N_GEOMETRY > 0).AND.(MY_RANK==0)) THEN
      NFACES = 0
      NVERTS = 0
      DO I= 1,N_GEOMETRY
         G=>GEOMETRY(I)
         NFACES = NFACES + G%N_FACES
         NVERTS = NVERTS + G%N_VERTS
      ENDDO
      IF (NVERTS>0 .AND. NFACES>0) THEN
         DO I= 1,N_GEOMETRY
            WRITE(FN_GEOM_VTK(I),'(A,A,A,I0,A)') "",TRIM(RESULTS_DIR)//TRIM(CHID),'_GEOM_',I,'.vtu'
            IF (VTK_BINARY) THEN
               VTK_ERROR = A_VTK_FILE%INITIALIZE(FORMAT='raw', FILENAME=FN_GEOM_VTK(I), MESH_TOPOLOGY='UnstructuredGrid')
            ELSE
               VTK_ERROR = A_VTK_FILE%INITIALIZE(FORMAT='ascii', FILENAME=FN_GEOM_VTK(I), MESH_TOPOLOGY='UnstructuredGrid')
            ENDIF ! do not change capitalization on mesh topology
            G=>GEOMETRY(I)
            ALLOCATE(X_PTS(G%N_VERTS))
            ALLOCATE(Y_PTS(G%N_VERTS))
            ALLOCATE(Z_PTS(G%N_VERTS))
            ALLOCATE(OFFSETS(G%N_FACES))
            ALLOCATE(CONNECT(G%N_FACES*3))
            ALLOCATE(VTKC_TYPE(G%N_FACES))
            DO J=1,G%N_VERTS
               X_PTS(J) = REAL(G%VERTS((J-1)*3+1),FB)
               Y_PTS(J) = REAL(G%VERTS((J-1)*3+2),FB)
               Z_PTS(J) = REAL(G%VERTS((J-1)*3+3),FB)
            ENDDO

            DO J=1,G%N_FACES
               OFFSETS(J) = (J)*3_IB32
               VTKC_TYPE(J) = 5_IB8
               CONNECT(3*(J-1)+1) = G%FACES(3*(J-1)+1)-1
               CONNECT(3*(J-1)+2) = G%FACES(3*(J-1)+2)-1
               CONNECT(3*(J-1)+3) = G%FACES(3*(J-1)+3)-1
            ENDDO
            
            VTK_ERROR = A_VTK_FILE%XML_WRITER%WRITE_PIECE(NP=G%N_VERTS, NC=G%N_FACES)
            VTK_ERROR = A_VTK_FILE%XML_WRITER%WRITE_GEO(NP=G%N_VERTS, NC=G%N_FACES, X=X_PTS, Y=Y_PTS, Z=Z_PTS)
            VTK_ERROR = A_VTK_FILE%XML_WRITER%WRITE_CONNECTIVITY(NC=G%N_FACES, CONNECTIVITY=CONNECT, OFFSET=OFFSETS, &
                                                                 VTKC_TYPE=VTKC_TYPE)
            CALL DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)
            ALLOCATE(COLORS(NFACES,3))
            DO J= 1,G%N_FACES
               IF (G%RGB(1)==-1) THEN
                  COLORS(J,1:3) = REAL(SURFACE(G%SURFS(J))%RGB,FB)/255._FB
               ELSE
                  COLORS(J,1:3) = REAL(G%RGB,FB)/255._FB
               ENDIF
            ENDDO
            VTK_ERROR = A_VTK_FILE%XML_WRITER%W_DATA(LOCATION='CELL', ACTION='OPEN')
            VTK_ERROR = A_VTK_FILE%XML_WRITER%W_DATA(DATA_NAME='Color', X=COLORS(:,1),Y=COLORS(:,2),Z=COLORS(:,3))
            VTK_ERROR = A_VTK_FILE%XML_WRITER%W_DATA(LOCATION='CELL', ACTION='CLOSE')
            VTK_ERROR = A_VTK_FILE%XML_WRITER%WRITE_PIECE()
            VTK_ERROR = A_VTK_FILE%FINALIZE()
            DEALLOCATE(COLORS)
         ENDDO
      ENDIF
   ENDIF


CONTAINS

   FUNCTION GET_VERTICES(XB)
      REAL(FB), INTENT(IN) :: XB(6)
      REAL(FB) :: GET_VERTICES(8,3)
      GET_VERTICES(1,:) = (/XB(1),XB(3),XB(5)/)
      GET_VERTICES(2,:) = (/XB(2),XB(3),XB(5)/)
      GET_VERTICES(3,:) = (/XB(2),XB(4),XB(5)/)
      GET_VERTICES(4,:) = (/XB(1),XB(4),XB(5)/)
      GET_VERTICES(5,:) = (/XB(1),XB(3),XB(6)/)
      GET_VERTICES(6,:) = (/XB(2),XB(3),XB(6)/)
      GET_VERTICES(7,:) = (/XB(2),XB(4),XB(6)/)
      GET_VERTICES(8,:) = (/XB(1),XB(4),XB(6)/)
   END FUNCTION GET_VERTICES

END SUBROUTINE WRITE_VTK_GEOM_FILE


SUBROUTINE ADD_ATTR(filename, dsetname, aname)

  CHARACTER(LEN=200), INTENT(IN) :: filename, dsetname, aname
  
  INTEGER(HID_T) :: file_id       ! File identifier
  INTEGER(HID_T) :: dset_id       ! Dataset identifier
  INTEGER(HID_T) :: attr_id       ! Attribute identifier
  INTEGER(HID_T) :: aspace_id     ! Attribute Dataspace identifier
  INTEGER(HID_T) :: atype_id      ! Attribute Dataspace identifier
  INTEGER(HSIZE_T), DIMENSION(1) :: adims = (/2/) ! Attribute dimension
  INTEGER     ::   arank = 1                      ! Attribute rank
  INTEGER(SIZE_T) :: attrlen    ! Length of the attribute string

  INTEGER(HID_T), DIMENSION(2) ::  attr_data  ! Attribute data

  INTEGER     ::   error ! Error flag
  INTEGER(HSIZE_T), DIMENSION(1) :: data_dims

  !
  ! Initialize attribute's data
  !
  attr_data(1) = 2
  attr_data(2) = 2
  !attrlen = 80
  !
  ! Initialize FORTRAN interface.
  !
  CALL h5open_f(error)
  !
  ! Open an existing file.
  !
  CALL h5fopen_f (filename, H5F_ACC_RDWR_F, file_id, error)
  !
  ! Open an existing dataset.
  !
  CALL h5dopen_f(file_id, dsetname, dset_id, error)
  !
  ! Create scalar data space for the attribute.
  !
  CALL h5screate_simple_f(arank, adims, aspace_id, error)
  !
  ! Create datatype for the attribute.
  !
  CALL h5tcopy_f(H5T_STD_I64LE, atype_id, error)
  CALL h5tset_size_f(atype_id, attrlen, error)
  !
  ! Create dataset attribute.
  !
  CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
  !
  ! Write the attribute data.
  !
  data_dims(1) = 2
  CALL h5awrite_f(attr_id, atype_id, attr_data, data_dims, error)
  !
  ! Close the attribute.
  !
  CALL h5aclose_f(attr_id, error)
  !
  ! Close the attribute datatype.
  !
  CALL h5tclose_f(atype_id, error)
  !
  ! Terminate access to the data space.
  !
  CALL h5sclose_f(aspace_id, error)
  !
  ! End access to the dataset and release resources used by it.
  !
  CALL h5dclose_f(dset_id, error)
  !
  ! Close the file.
  !
  CALL h5fclose_f(file_id, error)
  !
  ! Close FORTRAN interface.
  !
  CALL h5close_f(error)

END SUBROUTINE ADD_ATTR

SUBROUTINE CREATE_OPEN_PART_VTKHDF(FILENAME,&
                       FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   CHARACTER(*), INTENT(IN) :: FILENAME
   INTEGER(HID_T), INTENT(OUT) :: FILE_ID, PLIST_ID       ! Identifiers
   INTEGER(HID_T), INTENT(OUT) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER  :: ERROR                    !< IO Error status.
   INTEGER(KIND=MPI_INTEGER_KIND) :: MPI_SIZE, MPI_RANK, MPIERROR
   INTEGER(HID_T) :: DSET_ID, CRP_LIST
   
   CALL MPI_COMM_SIZE(MPI_COMM_WORLD, MPI_SIZE, MPIERROR)
   CALL MPI_COMM_RANK(MPI_COMM_WORLD, MPI_RANK, MPIERROR)
   
   ! Initialize HDF5 interface
   CALL H5OPEN_F(ERROR) ! Initialize FORTRAN interface
   
   ! Setup file access property list with parallel I/O access.
   CALL H5PCREATE_F(H5P_FILE_ACCESS_F, PLIST_ID, ERROR)
   CALL H5PSET_FAPL_MPIO_F(PLIST_ID, MPI_COMM_WORLD, MPI_INFO_NULL, ERROR)
   
   ! Create the file collectively.
   CALL H5FCREATE_F(FILENAME, H5F_ACC_TRUNC_F, FILE_ID, ERROR, ACCESS_PRP = PLIST_ID)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
   ! Create VTKHDF groups
   CALL H5GCREATE_F(FILE_ID, "VTKHDF", GROUP_ID1, ERROR)
   !CALL H5GCREATE_F(FILE_ID, "VTKHDF/Vertices", GROUP_ID2, ERROR)
   !CALL H5GCREATE_F(FILE_ID, "VTKHDF/Vertices/Connectivity", GROUP_ID2, ERROR)
   !CALL H5GCREATE_F(FILE_ID, "VTKHDF/Vertices/Offsets", GROUP_ID3, ERROR)
   GROUP_ID2 = 0
   GROUP_ID3 = 0
   CALL H5GCREATE_F(FILE_ID, "VTKHDF/PointData", GROUP_ID4, ERROR)
   
   ! Create empty groups
   CALL H5GCREATE_F(FILE_ID, "VTKHDF/Vertices", GROUP_ID3, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("NumberOfCells"), CRP_LIST, 1,&
      INT8((/NMESHES/)),INT8((/NMESHES/)), DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("NumberOfConnectivityIds"), CRP_LIST, 1,&
      INT8((/NMESHES/)),INT8((/NMESHES/)), DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("Offsets"), CRP_LIST, 1,&
      INT8((/NMESHES/)),INT8((/NMESHES/)), DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("Connectivity"), CRP_LIST, 1,&
      INT8((/NMESHES/)),INT8((/NMESHES/)), DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL H5GCLOSE_F(GROUP_ID3, ERROR)
   
   CALL H5GCREATE_F(FILE_ID, "VTKHDF/Lines", GROUP_ID3, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("NumberOfCells"), CRP_LIST, 1,&
      INT8((/NMESHES/)),INT8((/NMESHES/)), DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("NumberOfConnectivityIds"), CRP_LIST, 1,&
      INT8((/NMESHES/)),INT8((/NMESHES/)), DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("Offsets"), CRP_LIST, 1,&
      INT8((/NMESHES/)),INT8((/NMESHES/)), DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("Connectivity"), CRP_LIST, 1,&
      INT8((/NMESHES/)),INT8((/NMESHES/)), DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL H5GCLOSE_F(GROUP_ID3, ERROR)
   
   CALL H5GCREATE_F(FILE_ID, "VTKHDF/Polygons", GROUP_ID3, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("NumberOfCells"), CRP_LIST, 1,&
      INT8((/NMESHES/)),INT8((/NMESHES/)), DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("NumberOfConnectivityIds"), CRP_LIST, 1,&
      INT8((/NMESHES/)),INT8((/NMESHES/)), DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("Offsets"), CRP_LIST, 1,&
      INT8((/NMESHES/)),INT8((/NMESHES/)), DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("Connectivity"), CRP_LIST, 1,&
      INT8((/NMESHES/)),INT8((/NMESHES/)), DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL H5GCLOSE_F(GROUP_ID3, ERROR)
   
   CALL H5GCREATE_F(FILE_ID, "VTKHDF/Strips", GROUP_ID3, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("NumberOfCells"), CRP_LIST, 1,&
      INT8((/NMESHES/)),INT8((/NMESHES/)), DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("NumberOfConnectivityIds"), CRP_LIST, 1,&
      INT8((/NMESHES/)),INT8((/NMESHES/)), DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("Offsets"), CRP_LIST, 1,&
      INT8((/NMESHES/)),INT8((/NMESHES/)), DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL PARALLEL_INIT_I32(GROUP_ID3, TRIM("Connectivity"), CRP_LIST, 1,&
      INT8((/NMESHES/)),INT8((/NMESHES/)), DSET_ID, PLIST_ID)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL H5GCLOSE_F(GROUP_ID3, ERROR)
   
   ! Add VTKHDF header information
   CALL ADD_VERSION(GROUP_ID1,(/INT8(2)/),1,"Version",INT8((/2,2/)))
   CALL ADD_TYPE(GROUP_ID1,(/INT8(1)/),"Type","PolyData",INT8(8))

END SUBROUTINE CREATE_OPEN_PART_VTKHDF

SUBROUTINE OPEN_PART_VTKHDF(FILENAME,&
                       FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   CHARACTER(*), INTENT(IN) :: FILENAME
   INTEGER(HID_T), INTENT(OUT) :: FILE_ID, PLIST_ID       ! Identifiers
   INTEGER(HID_T), INTENT(OUT) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER  :: ERROR                    !< IO Error status.
   INTEGER(KIND=MPI_INTEGER_KIND) :: MPI_SIZE, MPI_RANK, MPIERROR
   
   CALL MPI_COMM_SIZE(MPI_COMM_WORLD, MPI_SIZE, MPIERROR)
   CALL MPI_COMM_RANK(MPI_COMM_WORLD, MPI_RANK, MPIERROR)
   
   ! Initialize HDF5 interface
   CALL H5OPEN_F(ERROR) ! Initialize FORTRAN interface
   
   ! Setup file access property list with parallel I/O access.
   CALL H5PCREATE_F(H5P_FILE_ACCESS_F, PLIST_ID, ERROR)
   CALL H5PSET_FAPL_MPIO_F(PLIST_ID, MPI_COMM_WORLD, MPI_INFO_NULL, ERROR)
   
   ! Create the file collectively.
   CALL H5FOPEN_F(FILENAME, H5F_ACC_RDWR_F, FILE_ID, ERROR, ACCESS_PRP = PLIST_ID)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
   ! Create VTKHDF groups
   CALL H5GOPEN_F(FILE_ID, "VTKHDF", GROUP_ID1, ERROR)
   GROUP_ID2 = 0
   !CALL H5GOPEN_F(FILE_ID, "VTKHDF/Vertices", GROUP_ID2, ERROR)
   GROUP_ID3 = 0
   !CALL H5GOPEN_F(FILE_ID, "VTKHDF/FieldData", GROUP_ID3, ERROR)
   CALL H5GOPEN_F(FILE_ID, "VTKHDF/PointData", GROUP_ID4, ERROR)

END SUBROUTINE OPEN_PART_VTKHDF

SUBROUTINE CLOSE_PART_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   INTEGER(HID_T), INTENT(IN) :: FILE_ID, GROUP_ID1,GROUP_ID4
   INTEGER(HID_T) :: GROUP_ID2,GROUP_ID3
   INTEGER  :: ERROR                    !< IO Error status.
   CALL H5GCLOSE_F(GROUP_ID4, ERROR)
   !CALL H5GCLOSE_F(GROUP_ID3, ERROR)
   !CALL H5GCLOSE_F(GROUP_ID2, ERROR)
   CALL H5GCLOSE_F(GROUP_ID1, ERROR)
   GROUP_ID2 = 0
   GROUP_ID3 = 0
   
   CALL MPI_BARRIER(MPI_COMM_WORLD, ERROR)
   CALL H5FCLOSE_F(FILE_ID, ERROR)
   CALL H5CLOSE_F(ERROR)
END SUBROUTINE CLOSE_PART_VTKHDF

SUBROUTINE CREATE_OPEN_VTKHDF(FILENAME,&
                       FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   CHARACTER(*), INTENT(IN) :: FILENAME
   INTEGER(HID_T), INTENT(OUT) :: FILE_ID, PLIST_ID       ! Identifiers
   INTEGER(HID_T), INTENT(OUT) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER  :: ERROR                    !< IO Error status.
   INTEGER(KIND=MPI_INTEGER_KIND) :: MPI_SIZE, MPI_RANK, MPIERROR
   
   CALL MPI_COMM_SIZE(MPI_COMM_WORLD, MPI_SIZE, MPIERROR)
   CALL MPI_COMM_RANK(MPI_COMM_WORLD, MPI_RANK, MPIERROR)
   
   ! Initialize HDF5 interface
   CALL H5OPEN_F(ERROR) ! Initialize FORTRAN interface
   
   ! Setup file access property list with parallel I/O access.
   CALL H5PCREATE_F(H5P_FILE_ACCESS_F, PLIST_ID, ERROR)
   CALL H5PSET_FAPL_MPIO_F(PLIST_ID, MPI_COMM_WORLD, MPI_INFO_NULL, ERROR)
   
   ! Create the file collectively.
   CALL H5FCREATE_F(FILENAME, H5F_ACC_TRUNC_F, FILE_ID, ERROR, ACCESS_PRP = PLIST_ID)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
   ! Create VTKHDF groups
   CALL H5GCREATE_F(FILE_ID, "VTKHDF", GROUP_ID1, ERROR)
   CALL H5GCREATE_F(FILE_ID, "VTKHDF/CellData", GROUP_ID2, ERROR)
   CALL H5GCREATE_F(FILE_ID, "VTKHDF/FieldData", GROUP_ID3, ERROR)
   CALL H5GCREATE_F(FILE_ID, "VTKHDF/PointData", GROUP_ID4, ERROR)
   
   ! Add VTKHDF header information
   CALL ADD_VERSION(GROUP_ID1,(/INT8(2)/),1,"Version",INT8((/2,2/)))
   CALL ADD_TYPE(GROUP_ID1,(/INT8(1)/),"Type","UnstructuredGrid",INT8(16))

END SUBROUTINE CREATE_OPEN_VTKHDF


SUBROUTINE OPEN_VTKHDF(FILENAME,&
                       FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   CHARACTER(*), INTENT(IN) :: FILENAME
   INTEGER(HID_T), INTENT(OUT) :: FILE_ID, PLIST_ID       ! Identifiers
   INTEGER(HID_T), INTENT(OUT) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER  :: ERROR                    !< IO Error status.
   INTEGER(KIND=MPI_INTEGER_KIND) :: MPI_SIZE, MPI_RANK, MPIERROR
   
   CALL MPI_COMM_SIZE(MPI_COMM_WORLD, MPI_SIZE, MPIERROR)
   CALL MPI_COMM_RANK(MPI_COMM_WORLD, MPI_RANK, MPIERROR)
   
   ! Initialize HDF5 interface
   CALL H5OPEN_F(ERROR) ! Initialize FORTRAN interface
   
   ! Setup file access property list with parallel I/O access.
   CALL H5PCREATE_F(H5P_FILE_ACCESS_F, PLIST_ID, ERROR)
   CALL H5PSET_FAPL_MPIO_F(PLIST_ID, MPI_COMM_WORLD, MPI_INFO_NULL, ERROR)
   
   ! Create the file collectively.
   CALL H5FOPEN_F(FILENAME, H5F_ACC_RDWR_F, FILE_ID, ERROR, ACCESS_PRP = PLIST_ID)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
   ! Create VTKHDF groups
   CALL H5GOPEN_F(FILE_ID, "VTKHDF", GROUP_ID1, ERROR)
   CALL H5GOPEN_F(FILE_ID, "VTKHDF/CellData", GROUP_ID2, ERROR)
   CALL H5GOPEN_F(FILE_ID, "VTKHDF/FieldData", GROUP_ID3, ERROR)
   CALL H5GOPEN_F(FILE_ID, "VTKHDF/PointData", GROUP_ID4, ERROR)

END SUBROUTINE OPEN_VTKHDF


SUBROUTINE CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   INTEGER(HID_T), INTENT(IN) :: FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4
   INTEGER  :: ERROR                    !< IO Error status.
   CALL H5GCLOSE_F(GROUP_ID4, ERROR)
   CALL H5GCLOSE_F(GROUP_ID3, ERROR)
   CALL H5GCLOSE_F(GROUP_ID2, ERROR)
   CALL H5GCLOSE_F(GROUP_ID1, ERROR)
   
   CALL MPI_BARRIER(MPI_COMM_WORLD, ERROR)
   CALL H5FCLOSE_F(FILE_ID, ERROR)
   CALL H5CLOSE_F(ERROR)
END SUBROUTINE CLOSE_VTKHDF



SUBROUTINE ADD_3F32_DATA_TO_VTKHDF_RECT_GAS_FILE(FILENAME, DATANAME, DATA)
   CHARACTER(*), INTENT(IN) :: FILENAME, DATANAME
   REAL(FB), DIMENSION(*), INTENT(IN) :: DATA
   INTEGER(HID_T) :: FILE_ID, PLIST_ID, CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: DSET_ID    ! Dataset identifiers
   INTEGER :: NPOINTS_TOTAL, NCELLS_TOTAL, NOFFSETS_TOTAL
   INTEGER :: NPOINTS, NCELLS
   INTEGER :: NCONN_TOTAL, NPIECES
   INTEGER :: NOFFSETS_ACCUM, NCONN_ACCUM, NPIECES_ACCUM, NCELLS_ACCUM, NPOINTS_ACCUM !, NFACES
   INTEGER :: NCONN_MAX, NOFFSETS_MAX, NCELLS_MAX, NPOINTS_MAX
   INTEGER :: NM, ERROR
   !TYPE (MESH_TYPE), POINTER :: M
   !REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: VERTICES
   !INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
   !INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
   INTEGER, DIMENSION(1:N_MPI_PROCESSES) :: MESHES_PER_PROCESS
   INTEGER :: N_WRITTEN=0
   
   DO NM=1,N_MPI_PROCESSES
      MESHES_PER_PROCESS(NM) = 0
   ENDDO
   
   NPOINTS_TOTAL=0
   NCELLS_TOTAL=0
   NCELLS_ACCUM=0
   NPOINTS_ACCUM=0
   NOFFSETS_TOTAL=0
   NOFFSETS_ACCUM = 0
   NCONN_TOTAL = 0
   NPIECES = 0
   NCONN_ACCUM = 0
   NPIECES_ACCUM = 0
   NCELLS_MAX = 0
   NPOINTS_MAX = 0
   NCONN_MAX = 0
   NOFFSETS_MAX = 0
   
   MESH_LOOP_HDF_COUNT: DO NM=1,NMESHES
      NPOINTS = MESHES(NM)%NP
      NCELLS = MESHES(NM)%NC
      NPOINTS_TOTAL = NPOINTS_TOTAL + NPOINTS !+ NVERTS*3
      NCELLS_TOTAL = NCELLS_TOTAL + NCELLS !+ NFACES*3
      NOFFSETS_TOTAL = NOFFSETS_TOTAL + NCELLS + 1
      NCONN_TOTAL = NCONN_TOTAL + NCELLS*8
      NPIECES = NPIECES + 1
      NCELLS_MAX = MAX(NCELLS_MAX,NCELLS)
      NPOINTS_MAX = MAX(NPOINTS_MAX,NPOINTS)
      NOFFSETS_MAX = MAX(NOFFSETS_MAX,NCELLS + 1)
      NCONN_MAX = MAX(NCONN_MAX,NCELLS*8)
      MESHES_PER_PROCESS(PROCESS(NM)+1) = MESHES_PER_PROCESS(PROCESS(NM)+1) + 1
   ENDDO MESH_LOOP_HDF_COUNT
   
   ! Initialize HDF5 datafiles
   CALL OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
   ! Data Quantity
   CALL PARALLEL_INIT_F32(GROUP_ID2, TRIM(DATANAME), CRP_LIST, 2,&
      INT8((/3,NCELLS_MAX/)),INT8((/3,NCELLS_TOTAL/)), DSET_ID, PLIST_ID) ! Color

   MESH_LOOP_HDF: DO NM=1,NMESHES
      NCELLS = MESHES(NM)%NC
      NPOINTS = MESHES(NM)%NP
      IF (PROCESS(NM)/=MY_RANK) THEN
         NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
         NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
         NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS + 1
         NCONN_ACCUM = NCONN_ACCUM + NCELLS*8
         NPIECES_ACCUM = NPIECES_ACCUM+1
         CYCLE MESH_LOOP_HDF
      ENDIF
      N_WRITTEN = N_WRITTEN + 1
      
      ! Write data to file
      CALL PARALLEL_WRITE_F32(2, INT8((/3,NCELLS/)), DSET_ID,&
         PLIST_ID, INT8((/0,NCELLS_ACCUM/)), INT8((/3,NCELLS/)), DATA)
         
      NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
      NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
      NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS + 1
      NCONN_ACCUM = NCONN_ACCUM + NCELLS*8
      NPIECES_ACCUM = NPIECES_ACCUM+1
   ENDDO MESH_LOOP_HDF
   
   ! Write fake data in processes that have less meshes than max process
   DO NM=1,MAXVAL(MESHES_PER_PROCESS)
      IF (N_WRITTEN < MAXVAL(MESHES_PER_PROCESS)) THEN
         NCELLS = 0
         NPOINTS = 0
         CALL PARALLEL_WRITE_F32(2, INT8((/3,NCELLS/)), DSET_ID,&
            PLIST_ID, INT8((/0,NCELLS_ACCUM/)), INT8((/3,NCELLS/)), (/0._FB,0._FB/))
         N_WRITTEN = N_WRITTEN + 1
      ENDIF
   ENDDO
   
   ! Close HDF5 datasets
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   
   ! Close VTKHDF interface
   CALL CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
END SUBROUTINE ADD_3F32_DATA_TO_VTKHDF_RECT_GAS_FILE

SUBROUTINE ADD_1F32_DATA_TO_VTKHDF_RECT_GAS_FILE(FILENAME, DATANAME, DATA)
   CHARACTER(*), INTENT(IN) :: FILENAME, DATANAME
   REAL(FB), DIMENSION(*), INTENT(IN) :: DATA
   INTEGER(HID_T) :: FILE_ID, PLIST_ID, CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: DSET_ID    ! Dataset identifiers
   INTEGER :: NPOINTS_TOTAL, NCELLS_TOTAL, NOFFSETS_TOTAL
   INTEGER :: NPOINTS, NCELLS
   INTEGER :: NCONN_TOTAL, NPIECES
   INTEGER :: NOFFSETS_ACCUM, NCONN_ACCUM, NPIECES_ACCUM, NCELLS_ACCUM, NPOINTS_ACCUM !, NFACES
   INTEGER :: NCONN_MAX, NOFFSETS_MAX, NCELLS_MAX, NPOINTS_MAX
   INTEGER :: NM, ERROR
   !TYPE (MESH_TYPE), POINTER :: M
   !REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: VERTICES
   !INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
   !INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
   INTEGER, DIMENSION(1:N_MPI_PROCESSES) :: MESHES_PER_PROCESS
   INTEGER :: N_WRITTEN=0
   
   DO NM=1,N_MPI_PROCESSES
      MESHES_PER_PROCESS(NM) = 0
   ENDDO
   
   NPOINTS_TOTAL=0
   NCELLS_TOTAL=0
   NCELLS_ACCUM=0
   NPOINTS_ACCUM=0
   NOFFSETS_TOTAL=0
   NOFFSETS_ACCUM = 0
   NCONN_TOTAL = 0
   NPIECES = 0
   NCONN_ACCUM = 0
   NPIECES_ACCUM = 0
   NCELLS_MAX = 0
   NPOINTS_MAX = 0
   NCONN_MAX = 0
   NOFFSETS_MAX = 0
   
   MESH_LOOP_HDF_COUNT: DO NM=1,NMESHES
      NCELLS = MESHES(NM)%NC
      NPOINTS = MESHES(NM)%NP
      NPOINTS_TOTAL = NPOINTS_TOTAL + NPOINTS !+ NVERTS*3
      NCELLS_TOTAL = NCELLS_TOTAL + NCELLS !+ NFACES*3
      NOFFSETS_TOTAL = NOFFSETS_TOTAL + NCELLS + 1
      NCONN_TOTAL = NCONN_TOTAL + NCELLS*8
      NPIECES = NPIECES + 1
      NCELLS_MAX = MAX(NCELLS_MAX,NCELLS)
      NPOINTS_MAX = MAX(NPOINTS_MAX,NPOINTS)
      NOFFSETS_MAX = MAX(NOFFSETS_MAX,NCELLS + 1)
      NCONN_MAX = MAX(NCONN_MAX,NCELLS*8)
      MESHES_PER_PROCESS(PROCESS(NM)+1) = MESHES_PER_PROCESS(PROCESS(NM)+1) + 1
   ENDDO MESH_LOOP_HDF_COUNT
   
   ! Initialize HDF5 datafiles
   CALL OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
   ! Data Quantity
   
   CALL PARALLEL_INIT_F32(GROUP_ID4, TRIM(DATANAME), CRP_LIST, 1,&
      INT8((/NPOINTS_MAX/)),INT8((/NPOINTS_TOTAL/)), DSET_ID, PLIST_ID) ! Color
   
   MESH_LOOP_HDF: DO NM=1,NMESHES
      NCELLS = MESHES(NM)%NC
      NPOINTS = MESHES(NM)%NP
      IF (PROCESS(NM)/=MY_RANK) THEN
         NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
         NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
         NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS + 1
         NCONN_ACCUM = NCONN_ACCUM + NCELLS*8
         NPIECES_ACCUM = NPIECES_ACCUM+1
         CYCLE MESH_LOOP_HDF
      ENDIF
      N_WRITTEN = N_WRITTEN + 1
      
      ! Write data to file
      CALL PARALLEL_WRITE_F32(1, INT8((/NPOINTS/)), DSET_ID,&
         PLIST_ID, INT8((/NPOINTS_ACCUM/)), INT8((/NPOINTS/)), DATA)
         
      NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
      NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
      NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS + 1
      NCONN_ACCUM = NCONN_ACCUM + NCELLS*8
      NPIECES_ACCUM = NPIECES_ACCUM+1
   ENDDO MESH_LOOP_HDF
   
   ! Write fake data in processes that have less meshes than max process
   DO NM=1,MAXVAL(MESHES_PER_PROCESS)
      IF (N_WRITTEN < MAXVAL(MESHES_PER_PROCESS)) THEN
         NCELLS = 0
         NPOINTS = 0
         CALL PARALLEL_WRITE_F32(1, INT8((/NPOINTS/)), DSET_ID,&
            PLIST_ID, INT8((/NPOINTS_ACCUM/)), INT8((/NPOINTS/)), (/0._FB/))
         N_WRITTEN = N_WRITTEN + 1
      ENDIF
   ENDDO
   
   ! Close HDF5 datasets
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
   ! Close VTKHDF interface
   CALL CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
END SUBROUTINE ADD_1F32_DATA_TO_VTKHDF_RECT_GAS_FILE




SUBROUTINE ADD_DATA_TO_SMOKE3D_VTKHDF_FILE(FILENAME, DATANAME, DATA, NM_IN, FAKE_WRITE)
   CHARACTER(*), INTENT(IN) :: FILENAME, DATANAME
   REAL(FB), DIMENSION(*), INTENT(IN) :: DATA
   INTEGER, INTENT(IN) :: NM_IN
   LOGICAL, INTENT(IN) :: FAKE_WRITE
   INTEGER(HID_T) :: FILE_ID, PLIST_ID, CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: DSET_ID    ! Dataset identifiers
   INTEGER :: NPOINTS_TOTAL, NCELLS_TOTAL, NOFFSETS_TOTAL
   INTEGER :: NPOINTS, NCELLS
   INTEGER :: NCONN_TOTAL, NPIECES
   INTEGER :: NOFFSETS_ACCUM, NCONN_ACCUM, NPIECES_ACCUM, NCELLS_ACCUM, NPOINTS_ACCUM !, NFACES
   INTEGER :: NCONN_MAX, NOFFSETS_MAX, NCELLS_MAX, NPOINTS_MAX
   INTEGER :: NM,ERROR
   !TYPE (MESH_TYPE), POINTER :: M
   !REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: VERTICES
   !INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
   !INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
   INTEGER, DIMENSION(1:N_MPI_PROCESSES) :: MESHES_PER_PROCESS
   INTEGER :: N_WRITTEN
   
   DO NM=1,N_MPI_PROCESSES
      MESHES_PER_PROCESS(NM) = 0
   ENDDO
   
   NPOINTS_TOTAL=0
   NCELLS_TOTAL=0
   NCELLS_ACCUM=0
   NPOINTS_ACCUM=0
   NOFFSETS_TOTAL=0
   NOFFSETS_ACCUM = 0
   NCONN_TOTAL = 0
   NPIECES = 0
   NCONN_ACCUM = 0
   NPIECES_ACCUM = 0
   NCELLS_MAX = 0
   NPOINTS_MAX = 0
   NCONN_MAX = 0
   NOFFSETS_MAX = 0
   N_WRITTEN = 0
   
   MESH_LOOP_HDF_COUNT: DO NM=1,NMESHES
      NCELLS = MESHES(NM)%NC
      NPOINTS = MESHES(NM)%NP
      NPOINTS_TOTAL = NPOINTS_TOTAL + NPOINTS !+ NVERTS*3
      NCELLS_TOTAL = NCELLS_TOTAL + NCELLS !+ NFACES*3
      NOFFSETS_TOTAL = NOFFSETS_TOTAL + NCELLS + 1
      NCONN_TOTAL = NCONN_TOTAL + NCELLS*8
      NPIECES = NPIECES + 1
      NCELLS_MAX = MAX(NCELLS_MAX,NCELLS)
      NPOINTS_MAX = MAX(NPOINTS_MAX,NPOINTS)
      NOFFSETS_MAX = MAX(NOFFSETS_MAX,NCELLS + 1)
      NCONN_MAX = MAX(NCONN_MAX,NCELLS*8)
      MESHES_PER_PROCESS(PROCESS(NM)+1) = MESHES_PER_PROCESS(PROCESS(NM)+1) + 1
   ENDDO MESH_LOOP_HDF_COUNT
   
   ! Initialize HDF5 datafiles
   CALL OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
   ! Data Quantity
   
   CALL PARALLEL_INIT_F32(GROUP_ID4, TRIM(DATANAME), CRP_LIST, 1,&
      INT8((/NPOINTS_MAX/)),INT8((/NPOINTS_TOTAL/)), DSET_ID, PLIST_ID) ! Color
   
   MESH_LOOP_HDF: DO NM=1,NMESHES
      NCELLS = MESHES(NM)%NC
      NPOINTS = MESHES(NM)%NP
      IF (NM_IN/=NM) THEN
         NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
         NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
         NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS + 1
         NCONN_ACCUM = NCONN_ACCUM + NCELLS*8
         NPIECES_ACCUM = NPIECES_ACCUM+1
         CYCLE MESH_LOOP_HDF
      ENDIF
      
      ! Write data to file
      IF (.NOT.FAKE_WRITE) THEN
         CALL PARALLEL_WRITE_F32(1, INT8((/NPOINTS/)), DSET_ID,&
            PLIST_ID, INT8((/NPOINTS_ACCUM/)), INT8((/NPOINTS/)), DATA)
      ELSE
         CALL PARALLEL_WRITE_F32(1, INT8((/0/)), DSET_ID,&
            PLIST_ID, INT8((/NPOINTS_ACCUM/)), INT8((/0/)), DATA)
      ENDIF
         
      NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
      NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
      NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS + 1
      NCONN_ACCUM = NCONN_ACCUM + NCELLS*8
      NPIECES_ACCUM = NPIECES_ACCUM+1
   ENDDO MESH_LOOP_HDF
   
   ! Close HDF5 datasets
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
   ! Close VTKHDF interface
   CALL CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
END SUBROUTINE ADD_DATA_TO_SMOKE3D_VTKHDF_FILE



SUBROUTINE WRITE_VTKHDF_RECT_GAS_FILE(FILENAME)
   CHARACTER(*), INTENT(IN) :: FILENAME
   INTEGER(HID_T) :: FILE_ID, PLIST_ID, CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: DSET_ID_CON, DSET_ID_NCELLS, DSET_ID_NCON    ! Dataset identifiers
   INTEGER(HID_T) :: DSET_ID_NPTS, DSET_ID_OFF, DSET_ID_PTS, DSET_ID_TYP       ! Dataset identifiers
   INTEGER :: NPOINTS_TOTAL, NCELLS_TOTAL, NOFFSETS_TOTAL
   INTEGER :: NPOINTS, NCELLS
   INTEGER :: NCONN_TOTAL, NPIECES
   INTEGER :: NOFFSETS_ACCUM, NCONN_ACCUM, NPIECES_ACCUM, NCELLS_ACCUM, NPOINTS_ACCUM !, NFACES
   INTEGER :: NCONN_MAX, NOFFSETS_MAX, NCELLS_MAX, NPOINTS_MAX
   INTEGER :: NM, ERROR
   TYPE (MESH_TYPE), POINTER :: M
   REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: VERTICES
   INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
   INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
   INTEGER, DIMENSION(1:N_MPI_PROCESSES) :: MESHES_PER_PROCESS
   INTEGER :: N_WRITTEN
   
   DO NM=1,N_MPI_PROCESSES
      MESHES_PER_PROCESS(NM) = 0
   ENDDO
   
   NPOINTS_TOTAL=0
   NCELLS_TOTAL=0
   NCELLS_ACCUM=0
   NPOINTS_ACCUM=0
   NOFFSETS_TOTAL=0
   NOFFSETS_ACCUM = 0
   NCONN_TOTAL = 0
   NPIECES = 0
   NCONN_ACCUM = 0
   NPIECES_ACCUM = 0
   NCELLS_MAX = 0
   NPOINTS_MAX = 0
   NCONN_MAX = 0
   NOFFSETS_MAX = 0
   N_WRITTEN=0
   
   MESH_LOOP_HDF_COUNT: DO NM=1,NMESHES
      NCELLS = MESHES(NM)%NC
      NPOINTS = MESHES(NM)%NP
      NPOINTS_TOTAL = NPOINTS_TOTAL + NPOINTS !+ NVERTS*3
      NCELLS_TOTAL = NCELLS_TOTAL + NCELLS !+ NFACES*3
      NOFFSETS_TOTAL = NOFFSETS_TOTAL + NCELLS + 1
      NCONN_TOTAL = NCONN_TOTAL + NCELLS*8
      NPIECES = NPIECES + 1
      NCELLS_MAX = MAX(NCELLS_MAX,NCELLS)
      NPOINTS_MAX = MAX(NPOINTS_MAX,NPOINTS)
      NOFFSETS_MAX = MAX(NOFFSETS_MAX,NCELLS + 1)
      NCONN_MAX = MAX(NCONN_MAX,NCELLS*8)
      MESHES_PER_PROCESS(PROCESS(NM)+1) = MESHES_PER_PROCESS(PROCESS(NM)+1) + 1
   ENDDO MESH_LOOP_HDF_COUNT
   
   ! Initialize HDF5 datafiles
   CALL CREATE_OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Connectivity"), CRP_LIST, 1,&
      INT8((/NCONN_MAX/)),INT8((/NCONN_TOTAL/)), DSET_ID_CON, PLIST_ID) ! Connectivity
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfCells"), CRP_LIST, 1,&
      INT8((/NPIECES/)), INT8((/NPIECES/)), DSET_ID_NCELLS, PLIST_ID) ! NumberOfCells
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfPoints"), CRP_LIST, 1,&
      INT8((/NPIECES/)),INT8((/NPIECES/)), DSET_ID_NPTS, PLIST_ID) ! NumberOfPoints
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfConnectivityIds"), CRP_LIST, 1,&
      INT8((/NPIECES/)), INT8((/NPIECES/)), DSET_ID_NCON, PLIST_ID) ! NumberOfConnectivityIds
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Offsets"), CRP_LIST, 1,&
      INT8((/NOFFSETS_MAX/)),INT8((/NOFFSETS_TOTAL/)), DSET_ID_OFF, PLIST_ID) ! Offsets
   CALL PARALLEL_INIT_F32(GROUP_ID1, TRIM("Points"), CRP_LIST, 2,&
      INT8((/3, NPOINTS_MAX/)),INT8((/3, NPOINTS_TOTAL/)), DSET_ID_PTS, PLIST_ID) ! Points
   CALL PARALLEL_INIT_U8(GROUP_ID1, TRIM("Types"), CRP_LIST, 1,&
      INT8((/NCELLS_MAX/)),INT8((/NCELLS_TOTAL/)), DSET_ID_TYP, PLIST_ID) ! Types

   MESH_LOOP_HDF: DO NM=1,NMESHES
      NCELLS = MESHES(NM)%NC
      NPOINTS = MESHES(NM)%NP
      IF (PROCESS(NM)/=MY_RANK) THEN
         NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
         NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
         NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS + 1
         NCONN_ACCUM = NCONN_ACCUM + NCELLS*8
         NPIECES_ACCUM = NPIECES_ACCUM+1
         CYCLE MESH_LOOP_HDF
      ENDIF
      N_WRITTEN = N_WRITTEN+1
      M => MESHES(NM)
      CALL BUILD_VTK_GAS_PHASE_GEOMETRY2(NM, NCELLS, NPOINTS, VERTICES, CONNECT, OFFSETS, VTKC_TYPE)
      
      ! Write connectivity data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/NCELLS*8/)), DSET_ID_CON,&
         PLIST_ID, INT8((/NCELLS_ACCUM*8/)), INT8((/NCELLS*8/)), CONNECT)
      
      ! Write number of cells data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCELLS,&
         PLIST_ID, INT8((/NM-1/)), INT8((/1/)), (/NCELLS/))
      
      ! Write number of points data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NPTS,&
         PLIST_ID, INT8((/NM-1/)), INT8((/1/)), (/NPOINTS/))
      
      ! Write NumberOfConnectivityIds data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCON,&
         PLIST_ID, INT8((/NM-1/)), INT8((/1/)), (/NCELLS*8/))
      
      ! Write offsets data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/NCELLS+1/)), DSET_ID_OFF,&
         PLIST_ID, INT8((/NOFFSETS_ACCUM/)), INT8((/NCELLS+1/)), OFFSETS)
      
      ! Write point data to file
      CALL PARALLEL_WRITE_F32(2, INT8((/3, NPOINTS/)), DSET_ID_PTS,&
         PLIST_ID, INT8((/0,NPOINTS_ACCUM/)), INT8((/3,NPOINTS/)), VERTICES)
      
      ! Write types data to file
      CALL PARALLEL_WRITE_U8(1, INT8((/NCELLS/)), DSET_ID_TYP,&
         PLIST_ID, INT8((/NCELLS_ACCUM/)), INT8((/NCELLS/)), VTKC_TYPE)
      
      !DEALLOCATE(COLORS)
      !DEALLOCATE(FACES_OUT)
      DEALLOCATE(VERTICES)
      DEALLOCATE(OFFSETS)
      DEALLOCATE(CONNECT)
      DEALLOCATE(VTKC_TYPE)
      NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
      NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
      NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS + 1
      NCONN_ACCUM = NCONN_ACCUM + NCELLS*8
      NPIECES_ACCUM = NPIECES_ACCUM+1
   ENDDO MESH_LOOP_HDF
   
   
   ! Write fake data in processes that have less meshes than max process
   DO NM=1,MAXVAL(MESHES_PER_PROCESS)
      IF (N_WRITTEN < MAXVAL(MESHES_PER_PROCESS)) THEN
         NCELLS = 0
         NPOINTS = 0
         ALLOCATE(CONNECT(NCELLS))
         ALLOCATE(OFFSETS(NCELLS))
         ALLOCATE(VERTICES(3,NCELLS))
         ALLOCATE(VTKC_TYPE(NCELLS))
         ! Write connectivity data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/NCELLS*8/)), DSET_ID_CON,&
            PLIST_ID, INT8((/NCELLS_ACCUM*8/)), INT8((/NCELLS*8/)), CONNECT)
         
         ! Write number of cells data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_NCELLS,&
            PLIST_ID, INT8((/0/)), INT8((/0/)), (/NCELLS/))
         
         ! Write number of points data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_NPTS,&
            PLIST_ID, INT8((/0/)), INT8((/0/)), (/NPOINTS/))
         
         ! Write NumberOfConnectivityIds data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_NCON,&
            PLIST_ID, INT8((/0/)), INT8((/0/)), (/NCELLS*8/))
         
         ! Write offsets data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_OFF,&
            PLIST_ID, INT8((/0/)), INT8((/0/)), OFFSETS)
         
         ! Write point data to file
         CALL PARALLEL_WRITE_F32(2, INT8((/3, NPOINTS/)), DSET_ID_PTS,&
            PLIST_ID, INT8((/0,0/)), INT8((/3,NPOINTS/)), (/0._FB,0._FB,0._FB/))
         
         ! Write types data to file
         CALL PARALLEL_WRITE_U8(1, INT8((/NCELLS/)), DSET_ID_TYP,&
            PLIST_ID, INT8((/NCELLS_ACCUM/)), INT8((/NCELLS/)), VTKC_TYPE)
         
         !DEALLOCATE(COLORS)
         !DEALLOCATE(FACES_OUT)
         DEALLOCATE(VERTICES)
         DEALLOCATE(OFFSETS)
         DEALLOCATE(CONNECT)
         DEALLOCATE(VTKC_TYPE)
         N_WRITTEN = N_WRITTEN + 1
      ENDIF
   ENDDO
   
   
   ! Close HDF5 datasets
   CALL H5DCLOSE_F(DSET_ID_CON, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCELLS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NPTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCON, ERROR)
   CALL H5DCLOSE_F(DSET_ID_OFF, ERROR)
   CALL H5DCLOSE_F(DSET_ID_PTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_TYP, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
   ! Close VTKHDF interface
   CALL CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
END SUBROUTINE WRITE_VTKHDF_RECT_GAS_FILE

SUBROUTINE INITIALIZE_VTKHDF_FILES(T)
   REAL(EB), INTENT(IN) :: T
   INTEGER :: II, ERROR
   ! Initialize slice hdfs
   DO II=1,MESHES(1)%N_UNIQUE_SLCF
      CALL INITIALIZE_VTKHDF_SLCF(T,II)
   ENDDO
   CALL MPI_BARRIER(MPI_COMM_WORLD, ERROR)
   ! Initialize smoke3d hdfs
   CALL INITIALIZE_VTKHDF_SMOKE3D(T)
   CALL MPI_BARRIER(MPI_COMM_WORLD, ERROR)
   ! Initialize bndf hdfs
   CALL INITIALIZE_VTKHDF_BNDF_STEP1(T)
   CALL INITIALIZE_VTKHDF_BNDF_STEP2(T)
   ! Initialize part hdfs
   CALL INITIALIZE_VTKHDF_PART(T)
END SUBROUTINE INITIALIZE_VTKHDF_FILES

SUBROUTINE INITIALIZE_VTKHDF_SMOKE3D(T)
   REAL(EB), INTENT(IN) :: T
   INTEGER :: ITM, ITM1
   CHARACTER(200) :: FILENAME
   REAL(EB) :: TT
   TT   = T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR
   ITM  = INT(TT)
   ITM1 = NINT(ABS(TT-ITM)*100)
   IF (ITM1==100) THEN
      ITM = ITM+1
      ITM1 = 0
   ENDIF
   WRITE(FILENAME,'(A,A,A,I8.8,I2.2,A)') "",TRIM(RESULTS_DIR)//TRIM(CHID),'_SM3D_',ITM,ITM1,'.vtkhdf'
   CALL WRITE_VTKHDF_RECT_GAS_FILE(FILENAME)
END SUBROUTINE INITIALIZE_VTKHDF_SMOKE3D

SUBROUTINE INITIALIZE_VTKHDF_SLCF(T,II)
   INTEGER, INTENT(IN) :: II
   INTEGER(HID_T) :: FILE_ID, PLIST_ID, CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: DSET_ID_NCELLS, DSET_ID_NCON, DSET_ID_NPTS    ! Dataset identifiers
   INTEGER :: NPOINTS, NCELLS, IQ, NQT
   INTEGER :: NM, ERROR, ITM, ITM1, NX, NY, NZ, NCONNECTIONS
   TYPE(SLICE_TYPE), POINTER :: SL
   REAL(EB), INTENT(IN) :: T
   REAL(EB) :: TT
   REAL(FB) :: STIME
   CHARACTER(200) :: FILENAME, SLCFNAME
   INTEGER, DIMENSION(1:N_MPI_PROCESSES) :: MESHES_PER_PROCESS
   INTEGER :: N_WRITTEN
   
   DO NM=1,N_MPI_PROCESSES
      MESHES_PER_PROCESS(NM) = 0
   ENDDO
   DO NM=1,NMESHES
      MESHES_PER_PROCESS(PROCESS(NM)+1) = MESHES_PER_PROCESS(PROCESS(NM)+1) + 1
   ENDDO
   
   SLCFNAME = TRIM(MESHES(1)%UNIQUE_SLICE_NAMES(II))
   STIME = REAL(T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR,FB)
   TT   = T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR
   ITM  = INT(TT)
   ITM1 = NINT(ABS(TT-ITM)*100)
   IF (ITM1==100) THEN
      ITM = ITM+1
      ITM1 = 0
   ENDIF
   WRITE(FILENAME,'(A,A,A,A,I8.8,I2.2,A)') TRIM(RESULTS_DIR)//TRIM(CHID),'_',&
                         TRIM(SLCFNAME),'_',ITM,ITM1,'.vtkhdf'
   ! Initialize file
   CALL CREATE_OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfCells"), CRP_LIST, 1,&
      INT8((/NMESHES/)), INT8((/NMESHES/)), DSET_ID_NCELLS, PLIST_ID) ! NumberOfCells
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfPoints"), CRP_LIST, 1,&
      INT8((/NMESHES/)),INT8((/NMESHES/)), DSET_ID_NPTS, PLIST_ID) ! NumberOfPoints
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfConnectivityIds"), CRP_LIST, 1,&
      INT8((/NMESHES/)), INT8((/NMESHES/)), DSET_ID_NCON, PLIST_ID) ! NumberOfConnectivityIds
   
   NQT = MESHES(1)%N_UNIQUE_SLCF
   ! Fill metadata
   N_WRITTEN=0
   MESH_LOOP: DO NM=1,NMESHES
      CALL POINT_TO_MESH(NM)
      IF (PROCESS(NM)/=MY_RANK) CYCLE MESH_LOOP
      NCELLS = 0
      NPOINTS = 0
      IF (MESHES(NM)%EMPTY_UNIQUE_SLICE(II)) THEN
         NCELLS = 0
         NPOINTS = 0
         NCONNECTIONS = 0
      ELSE
         QUANTITY_LOOP: DO IQ=1,MESHES(1)%N_SLCF_VTK
            SL => SLICE(IQ)
            !WRITE(*,*) "RANK ", MY_RANK, " MESH ", NM, " S1 ", TRIM(SL%SLCF_NAME), " S2 ", TRIM(SLCFNAME)
            IF (TRIM(SL%SLCF_NAME).NE.TRIM(SLCFNAME)) CYCLE QUANTITY_LOOP
            NX = SL%I2 + 1 - SL%I1
            NY = SL%J2 + 1 - SL%J1
            NZ = SL%K2 + 1 - SL%K1
            IF (SL%I2-SL%I1==0 .OR. SL%J2-SL%J1==0 .OR. SL%K2-SL%K1==0) THEN
               NCONNECTIONS=4 ! 2-D slice
            ELSE
               NCONNECTIONS=8 ! 3-D slice
            ENDIF
            NPOINTS = NX*NY*NZ
            NCELLS = MAX((NX-1),1)*MAX((NY-1),1)*MAX((NZ-1),1)
            EXIT
         ENDDO QUANTITY_LOOP
      ENDIF
      ! Write number of cells data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCELLS,&
         PLIST_ID, INT8((/NM-1/)), INT8((/1/)), (/NCELLS/))
      
      ! Write number of points data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NPTS,&
         PLIST_ID, INT8((/NM-1/)), INT8((/1/)), (/NPOINTS/))
      
      ! Write NumberOfConnectivityIds data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCON,&
         PLIST_ID, INT8((/NM-1/)), INT8((/1/)), (/NCELLS*NCONNECTIONS/))
      
      N_WRITTEN = N_WRITTEN + 1
   ENDDO MESH_LOOP
   
   ! Write fake data in processes that have less meshes than max process
   DO NM=1,MAXVAL(MESHES_PER_PROCESS)
      IF (N_WRITTEN < MAXVAL(MESHES_PER_PROCESS)) THEN
         NCELLS = 0
         NPOINTS = 0
         CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCELLS,&
            PLIST_ID, INT8((/NM-1/)), INT8((/1/)), (/NCELLS/))
      
         ! Write number of points data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NPTS,&
            PLIST_ID, INT8((/NM-1/)), INT8((/1/)), (/NPOINTS/))
      
         ! Write NumberOfConnectivityIds data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCON,&
            PLIST_ID, INT8((/NM-1/)), INT8((/1/)), (/NCELLS*NCONNECTIONS/))
         N_WRITTEN = N_WRITTEN + 1
      ENDIF
   ENDDO
   
   ! Close VTKHDF interface
   CALL MPI_BARRIER(MPI_COMM_WORLD, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCELLS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NPTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCON, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   CALL CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
END SUBROUTINE INITIALIZE_VTKHDF_SLCF







SUBROUTINE INITIALIZE_VTKHDF_PART(T)
   INTEGER(HID_T) :: FILE_ID, PLIST_ID, CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: DSET_ID_NPTS    ! Dataset identifiers    DSET_ID_NCELLS, DSET_ID_NCON, 
   INTEGER :: IP, N, NM, NPLIM, ERROR, ITM, ITM1
   REAL(EB), INTENT(IN) :: T
   CHARACTER(200) :: FILENAME
   INTEGER, DIMENSION(1:N_MPI_PROCESSES) :: MESHES_PER_PROCESS
   INTEGER :: N_WRITTEN
   TYPE (LAGRANGIAN_PARTICLE_TYPE), POINTER :: LP=>NULL()
   TYPE(LAGRANGIAN_PARTICLE_CLASS_TYPE), POINTER :: LPC=>NULL()
   REAL(FB) :: STIME

   DO NM=1,N_MPI_PROCESSES
      MESHES_PER_PROCESS(NM) = 0
   ENDDO
   DO NM=1,NMESHES
      MESHES_PER_PROCESS(PROCESS(NM)+1) = MESHES_PER_PROCESS(PROCESS(NM)+1) + 1
   ENDDO

   ! Initialize file
   STIME = REAL(T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR,FB)
   ITM  = INT(STIME)
   ITM1 = NINT(ABS(STIME-ITM)*100)
   IF (ITM1==100) THEN
      ITM = ITM+1
      ITM1 = 0
   ENDIF
   
   LAGRANGIAN_PARTICLE_CLASS_LOOP: DO N=1,N_LAGRANGIAN_CLASSES
      LPC => LAGRANGIAN_PARTICLE_CLASS(N)
      WRITE(FILENAME,'(A,A,A,A,A,I8.8,I2.2,A)') "",TRIM(RESULTS_DIR)//TRIM(CHID),&
         '_PART_',TRIM(LPC%ID),'_',ITM,ITM1,'.vtkhdf'
      CALL CREATE_OPEN_PART_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
      CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfPoints"), CRP_LIST, 1,&
         INT8((/NMESHES/)),INT8((/NMESHES/)), DSET_ID_NPTS, PLIST_ID) ! NumberOfPoints
      
      ! Fill metadata
      N_WRITTEN=0
      MESH_LOOP: DO NM=1,NMESHES
         CALL POINT_TO_MESH(NM)
         IF (PROCESS(NM)/=MY_RANK) CYCLE MESH_LOOP
         ! Count number of particles of class N in mesh NM
         NPLIM = 0
         DO IP=1,NLP
            LP=>LAGRANGIAN_PARTICLE(IP)
            IF (LP%SHOW .AND. LP%CLASS_INDEX==N) NPLIM = NPLIM + 1
            !IF (LP%CLASS_INDEX==N) NPLIM = NPLIM + 1
         ENDDO
         ! Write number of points data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NPTS, PLIST_ID, INT8((/NM-1/)), INT8((/1/)), (/NPLIM/))
         N_WRITTEN = N_WRITTEN + 1
      ENDDO MESH_LOOP
   
      ! Write fake data in processes that have less meshes than max process
      DO NM=1,MAXVAL(MESHES_PER_PROCESS)
         IF (N_WRITTEN < MAXVAL(MESHES_PER_PROCESS)) THEN
            CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_NPTS, PLIST_ID, INT8((/NM-1/)), INT8((/0/)), (/0/))
            N_WRITTEN = N_WRITTEN + 1
         ENDIF
      ENDDO
      
      ! Close VTKHDF interface
      CALL MPI_BARRIER(MPI_COMM_WORLD, ERROR)
      CALL H5FFLUSH_F(FILE_ID,H5F_SCOPE_GLOBAL_F,ERROR)
      CALL H5DCLOSE_F(DSET_ID_NPTS, ERROR)
      CALL H5PCLOSE_F(PLIST_ID, ERROR)
      CALL CLOSE_PART_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   ENDDO LAGRANGIAN_PARTICLE_CLASS_LOOP

END SUBROUTINE INITIALIZE_VTKHDF_PART























SUBROUTINE WRITE_VTKHDF_GEOM_FILE()
   INTEGER(HID_T) :: FILE_ID, PLIST_ID, CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: DSET_ID_NCELLS, DSET_ID_NCON, DSET_ID_NPTS, DSET_ID    ! Dataset identifiers
   INTEGER(HID_T) :: DSET_ID_CON, DSET_ID_OFF, DSET_ID_PTS, DSET_ID_TYP
   INTEGER :: IP, II, LAST_OFFSET_VALUE
   INTEGER :: NFACES, NFACES_CUTCELLS, NVERTS, NVERTS_CUTCELLS
   INTEGER :: NM, NMNM, NM1, NM2, ERROR, PA_NCELLS, PA_NPOINTS
   CHARACTER(200) :: FILENAME
   INTEGER, DIMENSION(1:N_MPI_PROCESSES) :: MESHES_PER_PROCESS
   INTEGER :: N_WRITTEN, I
   TYPE(PATCH_TYPE), POINTER :: PA
   INTEGER, ALLOCATABLE, DIMENSION(:) :: LOCATIONS,FACES,SURFIND,GEOMIND
   REAL(FB), ALLOCATABLE, DIMENSION(:) :: VERTS
   REAL(FB), ALLOCATABLE, DIMENSION(:) :: X_PTS, Y_PTS, Z_PTS
   INTEGER :: NCELLS_ACCUM, NCELLS_MAX, NCELLS_TOTAL, NCELLS_START
   INTEGER :: NCONN_ACCUM, NCONN_MAX, NCONN_TOTAL, NCONN_START
   INTEGER :: NOFFSETS_ACCUM, NOFFSETS_MAX, NOFFSETS_TOTAL, NOFFSETS_START
   INTEGER :: NPOINTS_ACCUM, NPOINTS_MAX, NPOINTS_TOTAL, NPOINTS_START
   INTEGER(IB32), DIMENSION(1:2*NMESHES) :: NCELLS, NPOINTS, NCONNECTIONS
   INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS, ALL_CONNECT, ALL_OFFSETS
   INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE, ALL_VTKC_TYPE
   REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: VERTICES, ALL_VERTICES, COLORS, ALL_COLORS
   TYPE(MESH_TYPE), POINTER :: M !=>NULL()
   TYPE(OBSTRUCTION_TYPE), POINTER :: OB !=>NULL()
   REAL(FB) :: COLOR(3)

   DO NM=1,N_MPI_PROCESSES
      MESHES_PER_PROCESS(NM) = 0
   ENDDO
   DO NM=1,NMESHES
      MESHES_PER_PROCESS(PROCESS(NM)+1) = MESHES_PER_PROCESS(PROCESS(NM)+1) + 1
   ENDDO

   ! Initialize file
   WRITE(FILENAME,'(A,A,A)') "",TRIM(CHID),'_GEOM.vtkhdf'
   CALL CREATE_OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
   ! 2*NMESHES arrays. odds include OBST patches, evens include GEOM patches
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfCells"), CRP_LIST, 1,&
      INT8((/2*NMESHES/)), INT8((/2*NMESHES/)), DSET_ID_NCELLS, PLIST_ID) ! NumberOfCells
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfPoints"), CRP_LIST, 1,&
      INT8((/2*NMESHES/)),INT8((/2*NMESHES/)), DSET_ID_NPTS, PLIST_ID) ! NumberOfPoints
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfConnectivityIds"), CRP_LIST, 1,&
      INT8((/2*NMESHES/)), INT8((/2*NMESHES/)), DSET_ID_NCON, PLIST_ID) ! NumberOfConnectivityIds
   
   ! Fill metadata
   N_WRITTEN=0
   MESH_LOOP: DO NM=1,NMESHES
      CALL POINT_TO_MESH(NM)
      M => MESHES(NM)
      IF (PROCESS(NM)/=MY_RANK) CYCLE MESH_LOOP
      NCELLS_ACCUM = 0
      NPOINTS_ACCUM = 0
      NCONN_ACCUM = 0
      ! Count OBST patch info
      IF (MESHES(NM)%N_PATCH>0) THEN
         PATCH_LOOP1: DO IP=1,N_PATCH
            PA => PATCH(IP)
            IF (PA%OBST_INDEX<=0) CYCLE PATCH_LOOP1
            !INTERPOLATED_BOUNDARY
            ! Initialize piece
            CALL BUILD_VTK_SOLID_PHASE_GEOMETRY(NM, PA, NCELLS(NM), NPOINTS(NM),&
               X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)
            NCONN_ACCUM = NCONN_ACCUM + NCELLS(NM)*4
            NCELLS_ACCUM = NCELLS_ACCUM + NCELLS(NM)
            NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS(NM)
            CALL DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)
         ENDDO PATCH_LOOP1
      ENDIF
      
      ! Write number of cells data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCELLS,&
         PLIST_ID, INT8((/2*(NM-1)/)), INT8((/1/)), (/NCELLS_ACCUM/))
      
      ! Write number of points data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NPTS,&
         PLIST_ID, INT8((/2*(NM-1)/)), INT8((/1/)), (/NPOINTS_ACCUM/))
      
      ! Write NumberOfConnectivityIds data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCON,&
         PLIST_ID, INT8((/2*(NM-1)/)), INT8((/1/)), (/NCONN_ACCUM/))
      
      ! Count GEOM patch info
      NCELLS_ACCUM = 0
      NPOINTS_ACCUM = 0
      NCONN_ACCUM = 0
      IF (MESHES(NM)%N_INTERNAL_CFACE_CELLS>0) THEN
         CALL GET_GEOMSIZES_DUP('INBOUND_FACES',0,0,0,0,0,0,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS)
         IF (NVERTS>0 .AND. NFACES>0) THEN
            ALLOCATE(VERTS(3*NVERTS))
            ALLOCATE(FACES(3*NFACES))
            ALLOCATE(LOCATIONS(NFACES))
            ALLOCATE(SURFIND(NFACES))
            ALLOCATE(GEOMIND(NFACES))
            CALL GET_GEOMINFO_DUP('INBOUND_FACES',0,0,0,0,0,0,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS,&
                              VERTS,FACES,LOCATIONS,SURFIND=SURFIND,GEOMIND=GEOMIND)
            CALL BUILD_VTK_GEOM_GEOMETRY(VERTS, FACES, NCELLS(NM), NPOINTS(NM), X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)
            DEALLOCATE(VERTS)
            DEALLOCATE(FACES)
            DEALLOCATE(LOCATIONS)
            DEALLOCATE(SURFIND)
            DEALLOCATE(GEOMIND)
            
            CALL DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)
            
            NCONN_ACCUM = NCONN_ACCUM + NCELLS(NM)*3
            NCELLS_ACCUM = NCELLS_ACCUM + NCELLS(NM)
            NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS(NM)
         ENDIF
      ENDIF
      
      ! Write number of cells data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCELLS,&
         PLIST_ID, INT8((/2*(NM-1)+1/)), INT8((/1/)), (/NCELLS_ACCUM/))
      
      ! Write number of points data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NPTS,&
         PLIST_ID, INT8((/2*(NM-1)+1/)), INT8((/1/)), (/NPOINTS_ACCUM/))
      
      ! Write NumberOfConnectivityIds data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCON,&
         PLIST_ID, INT8((/2*(NM-1)+1/)), INT8((/1/)), (/NCONN_ACCUM/))
      
      N_WRITTEN = N_WRITTEN + 1
   ENDDO MESH_LOOP
   
   ! Write fake data in processes that have less meshes than max process
   DO NM=1,MAXVAL(MESHES_PER_PROCESS)
      IF (N_WRITTEN < MAXVAL(MESHES_PER_PROCESS)) THEN
         
         DO I=1,2 ! Loop through 2x to write empty twice per mesh
            CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_NCELLS,&
               PLIST_ID, INT8((/NM-1/)), INT8((/0/)), (/0/))
         
            ! Write number of points data to file
            CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_NPTS,&
               PLIST_ID, INT8((/NM-1/)), INT8((/0/)), (/0/))
         
            ! Write NumberOfConnectivityIds data to file
            CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_NCON,&
               PLIST_ID, INT8((/NM-1/)), INT8((/0/)), (/0/))
         ENDDO
            
         N_WRITTEN = N_WRITTEN + 1
      ENDIF
   ENDDO
   
   ! Close VTKHDF interface
   CALL MPI_BARRIER(MPI_COMM_WORLD, ERROR)
   !CALL H5FFLUSH_F(FILE_ID,H5F_SCOPE_GLOBAL_F,ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCELLS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NPTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCON, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   CALL CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
   ! Reopen VTKHDF INTERFACE
   CALL OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
   ! Read number of cells
   CALL H5DOPEN_F(GROUP_ID1, "NumberOfCells", DSET_ID_NCELLS, ERROR)
   CALL H5DREAD_F(DSET_ID_NCELLS, H5T_STD_I32LE, NCELLS, INT((/2*NMESHES/),HSIZE_T), ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCELLS, ERROR)
   
   ! Read number of points
   CALL H5DOPEN_F(GROUP_ID1, "NumberOfPoints", DSET_ID_NPTS, ERROR)
   CALL H5DREAD_F(DSET_ID_NPTS, H5T_STD_I32LE, NPOINTS, INT((/2*NMESHES/),HSIZE_T), ERROR)
   CALL H5DCLOSE_F(DSET_ID_NPTS, ERROR)
   
   ! Read number of connections
   CALL H5DOPEN_F(GROUP_ID1, "NumberOfConnectivityIds", DSET_ID_NCON, ERROR)
   CALL H5DREAD_F(DSET_ID_NCON, H5T_STD_I32LE, NCONNECTIONS, INT((/2*NMESHES/),HSIZE_T), ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCON, ERROR)
   
   NPOINTS_TOTAL=0
   NCELLS_TOTAL=0
   NCELLS_ACCUM=0
   NPOINTS_ACCUM=0
   NOFFSETS_TOTAL=0
   NOFFSETS_ACCUM = 0
   NCONN_TOTAL = 0
   NCONN_ACCUM = 0
   NCELLS_MAX = 0
   NPOINTS_MAX = 0
   NCONN_MAX = 0
   NOFFSETS_MAX = 0
   NPOINTS_START = 0
   
   MESH_LOOP_HDF_COUNT: DO NMNM=1,2*NMESHES
      NPOINTS_TOTAL = NPOINTS_TOTAL + NPOINTS(NMNM)
      NCELLS_TOTAL = NCELLS_TOTAL + NCELLS(NMNM)
      NOFFSETS_TOTAL = NOFFSETS_TOTAL + NCELLS(NMNM) + 1
      NCONN_TOTAL = NCONN_TOTAL + NCONNECTIONS(NMNM)
      NCELLS_MAX = MAX(NCELLS_MAX,NCELLS(NMNM))
      NPOINTS_MAX = MAX(NPOINTS_MAX,NPOINTS(NMNM))
      NOFFSETS_MAX = MAX(NOFFSETS_MAX,NCELLS(NMNM) + 1)
      NCONN_MAX = MAX(NCONN_MAX,NCONNECTIONS(NMNM))
   ENDDO MESH_LOOP_HDF_COUNT
   
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Connectivity"), CRP_LIST, 1,&
      INT8((/NCONN_MAX/)),INT8((/NCONN_TOTAL/)), DSET_ID_CON, PLIST_ID) ! Connectivity
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Offsets"), CRP_LIST, 1,&
      INT8((/NOFFSETS_MAX/)),INT8((/NOFFSETS_TOTAL/)), DSET_ID_OFF, PLIST_ID) ! Offsets
   CALL PARALLEL_INIT_F32(GROUP_ID1, TRIM("Points"), CRP_LIST, 2,&
      INT8((/3, NPOINTS_MAX/)),INT8((/3, NPOINTS_TOTAL/)), DSET_ID_PTS, PLIST_ID) ! Points
   CALL PARALLEL_INIT_U8(GROUP_ID1, TRIM("Types"), CRP_LIST, 1,&
      INT8((/NCELLS_MAX/)),INT8((/NCELLS_TOTAL/)), DSET_ID_TYP, PLIST_ID) ! Types
   
   CALL POINT_TO_MESH(1)
   CALL PARALLEL_INIT_F32(GROUP_ID2, "Color", CRP_LIST, 2, INT8((/3,NCELLS_MAX/)),INT8((/3,NCELLS_TOTAL/)), DSET_ID, PLIST_ID) ! Data
   
   ! Fill metadata
   N_WRITTEN=0
   MESH_LOOP_HDF: DO NM=1,NMESHES
      NM1 = 2*NM-1
      NM2 = 2*NM
      NPOINTS_START = NPOINTS_ACCUM
      NCELLS_START = NCELLS_ACCUM
      NCONN_START = NCONN_ACCUM
      NOFFSETS_START = NOFFSETS_ACCUM
      LAST_OFFSET_VALUE = 0
      IF (PROCESS(NM)/=MY_RANK) THEN
         NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS(NM1) + NPOINTS(NM2)
         NCELLS_ACCUM = NCELLS_ACCUM + NCELLS(NM1) + NCELLS(NM2)
         NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS(NM1)+1
         NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS(NM2)+1
         NCONN_ACCUM = NCONN_ACCUM + NCONNECTIONS(NM1) + NCONNECTIONS(NM2)
         CYCLE MESH_LOOP_HDF
      ENDIF
      CALL POINT_TO_MESH(NM)
      
      ! Build OBST boundary geometry
      IF (MESHES(NM)%N_PATCH>0) THEN
         ALLOCATE(ALL_VERTICES(3,NPOINTS(NM1)))
         ALLOCATE(ALL_CONNECT(NCONNECTIONS(NM1)))
         ALLOCATE(ALL_OFFSETS(NCELLS(NM1)+1))
         ALLOCATE(ALL_VTKC_TYPE(NCELLS(NM1)))
         ALLOCATE(ALL_COLORS(3,NCELLS(NM1)))
         ALL_OFFSETS(NOFFSETS_ACCUM-NOFFSETS_START+1) = 0
         PATCH_LOOP2: DO IP=1,N_PATCH
            PA => PATCH(IP)
            IF (PA%OBST_INDEX<=0) CYCLE PATCH_LOOP2
            M => MESHES(NM)
            IF (PA%OBST_INDEX > 0) THEN
               OB=>M%OBSTRUCTION(PA%OBST_INDEX)
               IF (OB%RGB(1)==-1) THEN
                  SELECT CASE(PA%IOR)
                     CASE (-1)
                        COLOR = REAL(SURFACE(OB%SURF_INDEX(-1))%RGB,FB)/255._FB
                     CASE (1)
                        COLOR = REAL(SURFACE(OB%SURF_INDEX(1))%RGB,FB)/255._FB
                     CASE (-2)
                        COLOR = REAL(SURFACE(OB%SURF_INDEX(-2))%RGB,FB)/255._FB
                     CASE (2)
                        COLOR = REAL(SURFACE(OB%SURF_INDEX(2))%RGB,FB)/255._FB
                     CASE (-3)
                        COLOR = REAL(SURFACE(OB%SURF_INDEX(-3))%RGB,FB)/255._FB
                     CASE (3)
                        COLOR = REAL(SURFACE(OB%SURF_INDEX(3))%RGB,FB)/255._FB
                  ENDSELECT
               ELSE
                  COLOR = REAL(OB%RGB,FB)/255._FB
               ENDIF
            ELSE
               COLOR = REAL((/0.5,0.5,0.5/))
            ENDIF
               
            ! Initialize piece
            CALL BUILD_VTK_SOLID_PHASE_GEOMETRY(NM, PA, PA_NCELLS, PA_NPOINTS,&
               X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)
            ALLOCATE(VERTICES(3,PA_NPOINTS))
            DO II=1,PA_NPOINTS
               VERTICES(1:3,II) = (/X_PTS(II),Y_PTS(II),Z_PTS(II)/)
            ENDDO
            ALLOCATE(COLORS(3,PA_NCELLS))
            DO II=1,PA_NCELLS
               COLORS(1:3,II) = COLOR
            ENDDO
            ALL_VERTICES(:,NPOINTS_ACCUM-NPOINTS_START+1:NPOINTS_ACCUM-NPOINTS_START+PA_NPOINTS) = VERTICES
            ALL_CONNECT(NCONN_ACCUM-NCONN_START+1:NCONN_ACCUM-NCONN_START+PA_NCELLS*4) = CONNECT + NPOINTS_ACCUM-NPOINTS_START
            OFFSETS = OFFSETS + LAST_OFFSET_VALUE
            LAST_OFFSET_VALUE = OFFSETS(SIZE(OFFSETS))
            ALL_OFFSETS(NOFFSETS_ACCUM-NOFFSETS_START+2:NOFFSETS_ACCUM-NOFFSETS_START+PA_NCELLS+1) = OFFSETS
            ALL_VTKC_TYPE(NCELLS_ACCUM-NCELLS_START+1:NCELLS_ACCUM-NCELLS_START+PA_NCELLS) = VTKC_TYPE
            ALL_COLORS(:,NCELLS_ACCUM-NCELLS_START+1:NCELLS_ACCUM-NCELLS_START+PA_NCELLS) = COLORS
            NCONN_ACCUM = NCONN_ACCUM + PA_NCELLS*4
            NCELLS_ACCUM = NCELLS_ACCUM + PA_NCELLS
            NPOINTS_ACCUM = NPOINTS_ACCUM + PA_NPOINTS
            NOFFSETS_ACCUM = NOFFSETS_ACCUM + PA_NCELLS
            CALL DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)
            DEALLOCATE(VERTICES)
            DEALLOCATE(COLORS)
         ENDDO PATCH_LOOP2
         
         ! Write connectivity data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/NCONNECTIONS(NM1)/)), DSET_ID_CON,&
            PLIST_ID, INT8((/NCONN_START/)), INT8((/NCONNECTIONS(NM1)/)), ALL_CONNECT)
            
         ! Write offsets data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/NCELLS(NM1)+1/)), DSET_ID_OFF,&
            PLIST_ID, INT8((/NOFFSETS_START/)), INT8((/NCELLS(NM1)+1/)), ALL_OFFSETS)
         
         ! Write point data to file
         CALL PARALLEL_WRITE_F32(2, INT8((/3, NPOINTS(NM1)/)), DSET_ID_PTS,&
            PLIST_ID, INT8((/0,NPOINTS_START/)), INT8((/3,NPOINTS(NM1)/)), ALL_VERTICES)
         
         ! Write types data to file
         CALL PARALLEL_WRITE_U8(1, INT8((/NCELLS(NM1)/)), DSET_ID_TYP,&
            PLIST_ID, INT8((/NCELLS_START/)), INT8((/NCELLS(NM1)/)), ALL_VTKC_TYPE)
         
         ! Write color data to file
         CALL PARALLEL_WRITE_F32(2, INT8((/3, NCELLS(NM1)/)), DSET_ID,&
            PLIST_ID, INT8((/0,NCELLS_START/)), INT8((/3,NCELLS(NM1)/)), ALL_COLORS)
         
         DEALLOCATE(ALL_VERTICES)
         DEALLOCATE(ALL_CONNECT)
         DEALLOCATE(ALL_OFFSETS)
         DEALLOCATE(ALL_VTKC_TYPE)
         DEALLOCATE(ALL_COLORS)
         N_WRITTEN = N_WRITTEN + 1
      ENDIF
      ! Build GEOM patch geometry
      IF ((MESHES(NM)%N_INTERNAL_CFACE_CELLS>0).AND.(.TRUE.)) THEN
         NPOINTS_START = NPOINTS_ACCUM
         NCELLS_START = NCELLS_ACCUM
         NCONN_START = NCONN_ACCUM
         NOFFSETS_START = NOFFSETS_ACCUM
         CALL GET_GEOMSIZES_DUP('INBOUND_FACES',0,0,0,0,0,0,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS)
         IF (NVERTS>0 .AND. NFACES>0) THEN
            ALLOCATE(ALL_OFFSETS(NCELLS(NM2)+1))
            ALLOCATE(VERTS(3*NVERTS))
            ALLOCATE(FACES(3*NFACES))
            ALLOCATE(LOCATIONS(NFACES))
            ALLOCATE(SURFIND(NFACES))
            ALLOCATE(GEOMIND(NFACES))
            CALL GET_GEOMINFO_DUP('INBOUND_FACES',0,0,0,0,0,0,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS,&
                              VERTS,FACES,LOCATIONS,SURFIND=SURFIND,GEOMIND=GEOMIND)
            CALL BUILD_VTK_GEOM_GEOMETRY(VERTS, FACES, PA_NCELLS, PA_NPOINTS, X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)
            ALLOCATE(VERTICES(3,PA_NPOINTS))
            DO II=1,PA_NPOINTS
               VERTICES(1:3,II) = (/X_PTS(II),Y_PTS(II),Z_PTS(II)/)
            ENDDO
            ALLOCATE(COLORS(3,PA_NCELLS))
            DO II=1,PA_NCELLS
               COLOR = REAL(SURFACE(SURFIND(II))%RGB,FB)/255._FB
               COLORS(1:3,II) = COLOR
            ENDDO
            
            ALL_OFFSETS(1) = 0
            ALL_OFFSETS(2:NCELLS(NM2)+1) = OFFSETS
            NCONN_ACCUM = NCONN_ACCUM + PA_NCELLS*3
            NCELLS_ACCUM = NCELLS_ACCUM + PA_NCELLS
            NPOINTS_ACCUM = NPOINTS_ACCUM + PA_NPOINTS
            NOFFSETS_ACCUM = NOFFSETS_ACCUM + PA_NCELLS + 1
            
            ! Write connectivity data to file
            CALL PARALLEL_WRITE_I32(1, INT8((/NCONNECTIONS(NM2)/)), DSET_ID_CON,&
               PLIST_ID, INT8((/NCONN_START/)), INT8((/NCONNECTIONS(NM2)/)), CONNECT)
               
            ! Write offsets data to file
            CALL PARALLEL_WRITE_I32(1, INT8((/NCELLS(NM2)+1/)), DSET_ID_OFF,&
               PLIST_ID, INT8((/NOFFSETS_START+1/)), INT8((/NCELLS(NM2)+1/)), ALL_OFFSETS)
            
            ! Write point data to file
            CALL PARALLEL_WRITE_F32(2, INT8((/3, NPOINTS(NM2)/)), DSET_ID_PTS,&
               PLIST_ID, INT8((/0,NPOINTS_START/)), INT8((/3,NPOINTS(NM2)/)), VERTICES)
            
            ! Write types data to file
            CALL PARALLEL_WRITE_U8(1, INT8((/NCELLS(NM2)/)), DSET_ID_TYP,&
               PLIST_ID, INT8((/NCELLS_START/)), INT8((/NCELLS(NM2)/)), VTKC_TYPE)
            
            ! Write color data to file
            CALL PARALLEL_WRITE_F32(2, INT8((/3, NCELLS(NM2)/)), DSET_ID,&
               PLIST_ID, INT8((/0,NCELLS_START/)), INT8((/3,NCELLS(NM2)/)), COLORS)
            
            DEALLOCATE(VERTS)
            DEALLOCATE(FACES)
            DEALLOCATE(LOCATIONS)
            DEALLOCATE(SURFIND)
            DEALLOCATE(GEOMIND)
            DEALLOCATE(VERTICES)
            DEALLOCATE(ALL_OFFSETS)
            DEALLOCATE(COLORS)
            CALL DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)
            N_WRITTEN = N_WRITTEN + 1
         ENDIF
      ENDIF
   ENDDO MESH_LOOP_HDF
   
   ! Write fake data in processes that have less meshes than max process
   DO NM=1,MAXVAL(MESHES_PER_PROCESS)*2
      IF (N_WRITTEN < MAXVAL(MESHES_PER_PROCESS)*2) THEN
      
         ! Write connectivity data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_CON, PLIST_ID, INT8((/0/)), INT8((/0/)), (/0/))
            
         ! Write offsets data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_OFF, PLIST_ID, INT8((/0/)), INT8((/0/)), (/0/))
         
         ! Write point data to file
         CALL PARALLEL_WRITE_F32(2, INT8((/3, 0/)), DSET_ID_PTS, PLIST_ID, INT8((/0,0/)), INT8((/3,0/)), REAL((/0,0,0/)))
         
         ! Write types data to file
         CALL PARALLEL_WRITE_U8(1, INT8((/0/)), DSET_ID_TYP, PLIST_ID, INT8((/0/)), INT8((/0/)), (/0_IB8/))
         
         ! Write color data to file
         CALL PARALLEL_WRITE_F32(2, INT8((/3, 0/)), DSET_ID, PLIST_ID, INT8((/0,0/)), INT8((/3,0/)), REAL((/0,0,0/)))
         
         N_WRITTEN = N_WRITTEN + 1
      ENDIF
   ENDDO
   
   ! Close VTKHDF interface
   CALL MPI_BARRIER(MPI_COMM_WORLD, ERROR)
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL H5DCLOSE_F(DSET_ID_CON, ERROR)
   CALL H5DCLOSE_F(DSET_ID_OFF, ERROR)
   CALL H5DCLOSE_F(DSET_ID_PTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_TYP, ERROR)
   CALL CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)

END SUBROUTINE WRITE_VTKHDF_GEOM_FILE









































































SUBROUTINE INITIALIZE_VTKHDF_BNDF_STEP1(T)
   INTEGER(HID_T) :: FILE_ID, PLIST_ID, CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: DSET_ID_NCELLS, DSET_ID_NCON, DSET_ID_NPTS    ! Dataset identifiers
   INTEGER :: NPOINTS, NCELLS, IP, NPOINTS_ACCUM, NCELLS_ACCUM, NCONNECTIONS_ACCUM
   INTEGER :: NFACES, NFACES_CUTCELLS, NVERTS, NVERTS_CUTCELLS
   INTEGER :: NM, ERROR, ITM, ITM1, NCONNECTIONS
   REAL(EB), INTENT(IN) :: T
   CHARACTER(200) :: FILENAME
   INTEGER, DIMENSION(1:N_MPI_PROCESSES) :: MESHES_PER_PROCESS
   INTEGER :: N_WRITTEN, I
   TYPE(PATCH_TYPE), POINTER :: PA
   INTEGER, ALLOCATABLE, DIMENSION(:) :: LOCATIONS,FACES,SURFIND,GEOMIND
   REAL(FB), ALLOCATABLE, DIMENSION(:) :: VERTS
   REAL(FB), ALLOCATABLE, DIMENSION(:) :: X_PTS, Y_PTS, Z_PTS
   INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
   INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
   REAL(FB) :: STIME

   DO NM=1,N_MPI_PROCESSES
      MESHES_PER_PROCESS(NM) = 0
   ENDDO
   DO NM=1,NMESHES
      MESHES_PER_PROCESS(PROCESS(NM)+1) = MESHES_PER_PROCESS(PROCESS(NM)+1) + 1
   ENDDO

   ! Initialize file
   STIME = REAL(T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR,FB)
   ITM  = INT(STIME)
   ITM1 = NINT(ABS(STIME-ITM)*100)
   IF (ITM1==100) THEN
      ITM = ITM+1
      ITM1 = 0
   ENDIF
   WRITE(FILENAME,'(A,A,A,I8.8,I2.2,A)') "",TRIM(RESULTS_DIR)//TRIM(CHID),'_BNDF_',ITM,ITM1,'.vtkhdf'
   CALL CREATE_OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
   ! 2*NMESHES arrays. odds include OBST patches, evens include GEOM patches
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfCells"), CRP_LIST, 1,&
      INT8((/2*NMESHES/)), INT8((/2*NMESHES/)), DSET_ID_NCELLS, PLIST_ID) ! NumberOfCells
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfPoints"), CRP_LIST, 1,&
      INT8((/2*NMESHES/)),INT8((/2*NMESHES/)), DSET_ID_NPTS, PLIST_ID) ! NumberOfPoints
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfConnectivityIds"), CRP_LIST, 1,&
      INT8((/2*NMESHES/)), INT8((/2*NMESHES/)), DSET_ID_NCON, PLIST_ID) ! NumberOfConnectivityIds
   
   ! Fill metadata
   N_WRITTEN=0
   MESH_LOOP: DO NM=1,NMESHES
      CALL POINT_TO_MESH(NM)
      IF (PROCESS(NM)/=MY_RANK) CYCLE MESH_LOOP
      NCELLS = 0
      NPOINTS = 0
      NCELLS_ACCUM = 0
      NPOINTS_ACCUM = 0
      NCONNECTIONS_ACCUM = 0
      ! Count OBST patch info
      IF (MESHES(NM)%N_PATCH>0) THEN
         PATCH_LOOP1: DO IP=1,N_PATCH
            PA => PATCH(IP)
            IF (PA%OBST_INDEX<=0) CYCLE PATCH_LOOP1
            ! Initialize piece
            CALL BUILD_VTK_SOLID_PHASE_GEOMETRY(NM, PA, NCELLS, NPOINTS,&
               X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)
            NCONNECTIONS_ACCUM = NCONNECTIONS_ACCUM + NCELLS*4
            NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
            NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
            CALL DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)
         ENDDO PATCH_LOOP1
      ENDIF
      
      ! Write number of cells data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCELLS,&
         PLIST_ID, INT8((/2*(NM-1)/)), INT8((/1/)), (/NCELLS_ACCUM/))
      
      ! Write number of points data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NPTS,&
         PLIST_ID, INT8((/2*(NM-1)/)), INT8((/1/)), (/NPOINTS_ACCUM/))
      
      ! Write NumberOfConnectivityIds data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCON,&
         PLIST_ID, INT8((/2*(NM-1)/)), INT8((/1/)), (/NCONNECTIONS_ACCUM/))
      
      ! Count GEOM patch info
      NCELLS = 0
      NPOINTS = 0
      NCELLS_ACCUM = 0
      NPOINTS_ACCUM = 0
      NCONNECTIONS_ACCUM = 0
      IF (MESHES(NM)%N_INTERNAL_CFACE_CELLS>0) THEN
         CALL GET_GEOMSIZES_DUP('INBOUND_FACES',0,0,0,0,0,0,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS)
         IF (NVERTS>0 .AND. NFACES>0) THEN
            ALLOCATE(VERTS(3*NVERTS))
            ALLOCATE(FACES(3*NFACES))
            ALLOCATE(LOCATIONS(NFACES))
            ALLOCATE(SURFIND(NFACES))
            ALLOCATE(GEOMIND(NFACES))
            CALL GET_GEOMINFO_DUP('INBOUND_FACES',0,0,0,0,0,0,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS,&
                              VERTS,FACES,LOCATIONS,SURFIND=SURFIND,GEOMIND=GEOMIND)
            CALL BUILD_VTK_GEOM_GEOMETRY(VERTS, FACES, NCELLS, NPOINTS, X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)
            DEALLOCATE(VERTS)
            DEALLOCATE(FACES)
            DEALLOCATE(LOCATIONS)
            DEALLOCATE(SURFIND)
            DEALLOCATE(GEOMIND)
            
            CALL DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)
            
            NCONNECTIONS_ACCUM = NCONNECTIONS_ACCUM + NCELLS*3
            NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
            NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
         ENDIF
      ENDIF
      
      ! Write number of cells data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCELLS,&
         PLIST_ID, INT8((/2*(NM-1)+1/)), INT8((/1/)), (/NCELLS_ACCUM/))
      
      ! Write number of points data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NPTS,&
         PLIST_ID, INT8((/2*(NM-1)+1/)), INT8((/1/)), (/NPOINTS_ACCUM/))
      
      ! Write NumberOfConnectivityIds data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCON,&
         PLIST_ID, INT8((/2*(NM-1)+1/)), INT8((/1/)), (/NCONNECTIONS_ACCUM/))
      
      N_WRITTEN = N_WRITTEN + 1
   ENDDO MESH_LOOP
   
   ! Write fake data in processes that have less meshes than max process
   DO NM=1,MAXVAL(MESHES_PER_PROCESS)
      IF (N_WRITTEN < MAXVAL(MESHES_PER_PROCESS)) THEN
         NCELLS = 0
         NPOINTS = 0
         NCONNECTIONS = 0
         
         DO I=1,2 ! Loop through 2x to write empty twice per mesh
            CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_NCELLS,&
               PLIST_ID, INT8((/NM-1/)), INT8((/0/)), (/0/))
         
            ! Write number of points data to file
            CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_NPTS,&
               PLIST_ID, INT8((/NM-1/)), INT8((/0/)), (/0/))
         
            ! Write NumberOfConnectivityIds data to file
            CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_NCON,&
               PLIST_ID, INT8((/NM-1/)), INT8((/0/)), (/0/))
         ENDDO
            
         N_WRITTEN = N_WRITTEN + 1
      ENDIF
   ENDDO
   
   ! Close VTKHDF interface
   CALL MPI_BARRIER(MPI_COMM_WORLD, ERROR)
   !CALL H5FFLUSH_F(FILE_ID,H5F_SCOPE_GLOBAL_F,ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCELLS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NPTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCON, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   CALL CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   

END SUBROUTINE INITIALIZE_VTKHDF_BNDF_STEP1



SUBROUTINE INITIALIZE_VTKHDF_BNDF_STEP2(T)
   INTEGER(HID_T) :: FILE_ID, PLIST_ID, CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: DSET_ID_NCELLS, DSET_ID_NCON, DSET_ID_NPTS, DSET_ID    ! Dataset identifiers
   INTEGER(HID_T) :: DSET_ID_CON, DSET_ID_OFF, DSET_ID_PTS, DSET_ID_TYP       ! Dataset identifiers
   INTEGER :: PA_NPOINTS, PA_NCELLS, II, IP
   INTEGER :: NFACES, NFACES_CUTCELLS, NVERTS, NVERTS_CUTCELLS
   INTEGER :: N, NM, NMNM, NM1, NM2, ERROR, ITM, ITM1
   INTEGER(IB32), DIMENSION(1:2*NMESHES) :: NCELLS, NPOINTS, NCONNECTIONS
   REAL(EB), INTENT(IN) :: T
   CHARACTER(200) :: FILENAME
   INTEGER, DIMENSION(1:N_MPI_PROCESSES) :: MESHES_PER_PROCESS
   INTEGER :: N_WRITTEN
   INTEGER :: NCELLS_ACCUM, NCELLS_MAX, NCELLS_TOTAL, NCELLS_START
   INTEGER :: NCONN_ACCUM, NCONN_MAX, NCONN_TOTAL, NCONN_START
   INTEGER :: NOFFSETS_ACCUM, NOFFSETS_MAX, NOFFSETS_TOTAL, NOFFSETS_START
   INTEGER :: NPOINTS_ACCUM, NPOINTS_MAX, NPOINTS_TOTAL, NPOINTS_START
   TYPE(PATCH_TYPE), POINTER :: PA
   INTEGER, ALLOCATABLE, DIMENSION(:) :: LOCATIONS,FACES,SURFIND,GEOMIND
   REAL(FB), ALLOCATABLE, DIMENSION(:) :: VERTS
   REAL(FB), ALLOCATABLE, DIMENSION(:) :: X_PTS, Y_PTS, Z_PTS
   REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: VERTICES, ALL_VERTICES
   INTEGER(IB32) :: LAST_OFFSET_VALUE
   INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS, ALL_CONNECT, ALL_OFFSETS
   INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE, ALL_VTKC_TYPE
   REAL(FB) :: STIME
   TYPE (BOUNDARY_FILE_TYPE), POINTER :: BF=>NULL()

   DO NM=1,N_MPI_PROCESSES
      MESHES_PER_PROCESS(NM) = 0
   ENDDO
   DO NM=1,NMESHES
      MESHES_PER_PROCESS(PROCESS(NM)+1) = MESHES_PER_PROCESS(PROCESS(NM)+1) + 1
   ENDDO

   ! Initialize file
   STIME = REAL(T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR,FB)
   ITM  = INT(STIME)
   ITM1 = NINT(ABS(STIME-ITM)*100)
   IF (ITM1==100) THEN
      ITM = ITM+1
      ITM1 = 0
   ENDIF
   WRITE(FILENAME,'(A,A,A,I8.8,I2.2,A)') "",TRIM(RESULTS_DIR)//TRIM(CHID),'_BNDF_',ITM,ITM1,'.vtkhdf'
   CALL OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
   ! Read number of cells
   CALL H5DOPEN_F(GROUP_ID1, "NumberOfCells", DSET_ID_NCELLS, ERROR)
   CALL H5DREAD_F(DSET_ID_NCELLS, H5T_STD_I32LE, NCELLS, INT((/2*NMESHES/),HSIZE_T), ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCELLS, ERROR)
   
   ! Read number of points
   CALL H5DOPEN_F(GROUP_ID1, "NumberOfPoints", DSET_ID_NPTS, ERROR)
   CALL H5DREAD_F(DSET_ID_NPTS, H5T_STD_I32LE, NPOINTS, INT((/2*NMESHES/),HSIZE_T), ERROR)
   CALL H5DCLOSE_F(DSET_ID_NPTS, ERROR)
   
   ! Read number of connections
   CALL H5DOPEN_F(GROUP_ID1, "NumberOfConnectivityIds", DSET_ID_NCON, ERROR)
   CALL H5DREAD_F(DSET_ID_NCON, H5T_STD_I32LE, NCONNECTIONS, INT((/2*NMESHES/),HSIZE_T), ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCON, ERROR)
   
   NPOINTS_TOTAL=0
   NCELLS_TOTAL=0
   NCELLS_ACCUM=0
   NPOINTS_ACCUM=0
   NOFFSETS_TOTAL=0
   NOFFSETS_ACCUM = 0
   NCONN_TOTAL = 0
   NCONN_ACCUM = 0
   NCELLS_MAX = 0
   NPOINTS_MAX = 0
   NCONN_MAX = 0
   NOFFSETS_MAX = 0
   NPOINTS_START = 0
   
   MESH_LOOP_HDF_COUNT: DO NMNM=1,2*NMESHES
      NPOINTS_TOTAL = NPOINTS_TOTAL + NPOINTS(NMNM) !+ NVERTS*3
      NCELLS_TOTAL = NCELLS_TOTAL + NCELLS(NMNM) !+ NFACES*3
      NOFFSETS_TOTAL = NOFFSETS_TOTAL + NCELLS(NMNM) + 1
      NCONN_TOTAL = NCONN_TOTAL + NCONNECTIONS(NMNM)
      NCELLS_MAX = MAX(NCELLS_MAX,NCELLS(NMNM))
      NPOINTS_MAX = MAX(NPOINTS_MAX,NPOINTS(NMNM))
      NOFFSETS_MAX = MAX(NOFFSETS_MAX,NCELLS(NMNM) + 1)
      NCONN_MAX = MAX(NCONN_MAX,NCONNECTIONS(NMNM))
   ENDDO MESH_LOOP_HDF_COUNT
   
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Connectivity"), CRP_LIST, 1,&
      INT8((/NCONN_MAX/)),INT8((/NCONN_TOTAL/)), DSET_ID_CON, PLIST_ID) ! Connectivity
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Offsets"), CRP_LIST, 1,&
      INT8((/NOFFSETS_MAX/)),INT8((/NOFFSETS_TOTAL/)), DSET_ID_OFF, PLIST_ID) ! Offsets
   CALL PARALLEL_INIT_F32(GROUP_ID1, TRIM("Points"), CRP_LIST, 2,&
      INT8((/3, NPOINTS_MAX/)),INT8((/3, NPOINTS_TOTAL/)), DSET_ID_PTS, PLIST_ID) ! Points
   CALL PARALLEL_INIT_U8(GROUP_ID1, TRIM("Types"), CRP_LIST, 1,&
      INT8((/NCELLS_MAX/)),INT8((/NCELLS_TOTAL/)), DSET_ID_TYP, PLIST_ID) ! Types
   
   CALL POINT_TO_MESH(1)
   DO N=1,N_BNDF
      BF => BOUNDARY_FILE(N)
      IF (BF%CELL_CENTERED) THEN
         CALL PARALLEL_INIT_F32(GROUP_ID2, BF%SMOKEVIEW_LABEL(1:30), CRP_LIST, 1,&
            INT8((/NCELLS_MAX/)),INT8((/NCELLS_TOTAL/)), DSET_ID, PLIST_ID) ! Data
      ELSE
         CALL PARALLEL_INIT_F32(GROUP_ID4, BF%SMOKEVIEW_LABEL(1:30), CRP_LIST, 1,&
            INT8((/NPOINTS_MAX/)),INT8((/NPOINTS_TOTAL/)), DSET_ID, PLIST_ID) ! Data
      ENDIF
      CALL H5DCLOSE_F(DSET_ID, ERROR)
   ENDDO
   
   ! Fill metadata
   N_WRITTEN=0
   MESH_LOOP_HDF: DO NM=1,NMESHES
      NM1 = 2*NM-1
      NM2 = 2*NM
      NPOINTS_START = NPOINTS_ACCUM
      NCELLS_START = NCELLS_ACCUM
      NCONN_START = NCONN_ACCUM
      NOFFSETS_START = NOFFSETS_ACCUM
      LAST_OFFSET_VALUE = 0
      IF (PROCESS(NM)/=MY_RANK) THEN
         NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS(NM1) + NPOINTS(NM2)
         NCELLS_ACCUM = NCELLS_ACCUM + NCELLS(NM1) + NCELLS(NM2)
         NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS(NM1)+1
         NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS(NM2)+1
         NCONN_ACCUM = NCONN_ACCUM + NCONNECTIONS(NM1) + NCONNECTIONS(NM2)
         CYCLE MESH_LOOP_HDF
      ENDIF
      CALL POINT_TO_MESH(NM)
      
      ! Build OBST boundary geometry
      IF (MESHES(NM)%N_PATCH>0) THEN
         ALLOCATE(ALL_VERTICES(3,NPOINTS(NM1)))
         ALLOCATE(ALL_CONNECT(NCONNECTIONS(NM1)))
         ALLOCATE(ALL_OFFSETS(NCELLS(NM1)+1))
         ALLOCATE(ALL_VTKC_TYPE(NCELLS(NM1)))
         ALL_OFFSETS(NOFFSETS_ACCUM-NOFFSETS_START+1) = 0
         PATCH_LOOP1: DO IP=1,N_PATCH
            PA => PATCH(IP)
            IF (PA%OBST_INDEX<=0) CYCLE PATCH_LOOP1
            ! Initialize piece
            CALL BUILD_VTK_SOLID_PHASE_GEOMETRY(NM, PA, PA_NCELLS, PA_NPOINTS,&
               X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)
            ALLOCATE(VERTICES(3,PA_NPOINTS))
            DO II=1,PA_NPOINTS
               VERTICES(1:3,II) = (/X_PTS(II),Y_PTS(II),Z_PTS(II)/)
            ENDDO
            ALL_VERTICES(:,NPOINTS_ACCUM-NPOINTS_START+1:NPOINTS_ACCUM-NPOINTS_START+PA_NPOINTS) = VERTICES
            ALL_CONNECT(NCONN_ACCUM-NCONN_START+1:NCONN_ACCUM-NCONN_START+PA_NCELLS*4) = CONNECT + NPOINTS_ACCUM-NPOINTS_START
            OFFSETS = OFFSETS + LAST_OFFSET_VALUE
            LAST_OFFSET_VALUE = OFFSETS(SIZE(OFFSETS))
            ALL_OFFSETS(NOFFSETS_ACCUM-NOFFSETS_START+2:NOFFSETS_ACCUM-NOFFSETS_START+PA_NCELLS+1) = OFFSETS
            ALL_VTKC_TYPE(NCELLS_ACCUM-NCELLS_START+1:NCELLS_ACCUM-NCELLS_START+PA_NCELLS) = VTKC_TYPE
            NCONN_ACCUM = NCONN_ACCUM + PA_NCELLS*4
            NCELLS_ACCUM = NCELLS_ACCUM + PA_NCELLS
            NPOINTS_ACCUM = NPOINTS_ACCUM + PA_NPOINTS
            NOFFSETS_ACCUM = NOFFSETS_ACCUM + PA_NCELLS
            CALL DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)
            DEALLOCATE(VERTICES)
         ENDDO PATCH_LOOP1
         
         ! Write connectivity data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/NCONNECTIONS(NM1)/)), DSET_ID_CON,&
            PLIST_ID, INT8((/NCONN_START/)), INT8((/NCONNECTIONS(NM1)/)), ALL_CONNECT)
            
         ! Write offsets data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/NCELLS(NM1)+1/)), DSET_ID_OFF,&
            PLIST_ID, INT8((/NOFFSETS_START/)), INT8((/NCELLS(NM1)+1/)), ALL_OFFSETS)
         
         ! Write point data to file
         CALL PARALLEL_WRITE_F32(2, INT8((/3, NPOINTS(NM1)/)), DSET_ID_PTS,&
            PLIST_ID, INT8((/0,NPOINTS_START/)), INT8((/3,NPOINTS(NM1)/)), ALL_VERTICES)
         
         ! Write types data to file
         CALL PARALLEL_WRITE_U8(1, INT8((/NCELLS(NM1)/)), DSET_ID_TYP,&
            PLIST_ID, INT8((/NCELLS_START/)), INT8((/NCELLS(NM1)/)), ALL_VTKC_TYPE)
         
         DEALLOCATE(ALL_VERTICES)
         DEALLOCATE(ALL_CONNECT)
         DEALLOCATE(ALL_OFFSETS)
         DEALLOCATE(ALL_VTKC_TYPE)
         N_WRITTEN = N_WRITTEN + 1
      ENDIF
      ! Build GEOM patch geometry
      IF ((MESHES(NM)%N_INTERNAL_CFACE_CELLS>0).AND.(.TRUE.)) THEN
         NPOINTS_START = NPOINTS_ACCUM
         NCELLS_START = NCELLS_ACCUM
         NCONN_START = NCONN_ACCUM
         NOFFSETS_START = NOFFSETS_ACCUM
         CALL GET_GEOMSIZES_DUP('INBOUND_FACES',0,0,0,0,0,0,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS)
         IF (NVERTS>0 .AND. NFACES>0) THEN
            ALLOCATE(ALL_OFFSETS(NCELLS(NM2)+1))
            ALLOCATE(VERTS(3*NVERTS))
            ALLOCATE(FACES(3*NFACES))
            ALLOCATE(LOCATIONS(NFACES))
            ALLOCATE(SURFIND(NFACES))
            ALLOCATE(GEOMIND(NFACES))
            CALL GET_GEOMINFO_DUP('INBOUND_FACES',0,0,0,0,0,0,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS,&
                              VERTS,FACES,LOCATIONS,SURFIND=SURFIND,GEOMIND=GEOMIND)
            CALL BUILD_VTK_GEOM_GEOMETRY(VERTS, FACES, PA_NCELLS, PA_NPOINTS, X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)
            ALLOCATE(VERTICES(3,PA_NPOINTS))
            DO II=1,PA_NPOINTS
               VERTICES(1:3,II) = (/X_PTS(II),Y_PTS(II),Z_PTS(II)/)
            ENDDO
            ALL_OFFSETS(1) = 0
            ALL_OFFSETS(2:NCELLS(NM2)+1) = OFFSETS
            NCONN_ACCUM = NCONN_ACCUM + PA_NCELLS*3
            NCELLS_ACCUM = NCELLS_ACCUM + PA_NCELLS
            NPOINTS_ACCUM = NPOINTS_ACCUM + PA_NPOINTS
            NOFFSETS_ACCUM = NOFFSETS_ACCUM + PA_NCELLS + 1
            
            ! Write connectivity data to file
            CALL PARALLEL_WRITE_I32(1, INT8((/NCONNECTIONS(NM2)/)), DSET_ID_CON,&
               PLIST_ID, INT8((/NCONN_START/)), INT8((/NCONNECTIONS(NM2)/)), CONNECT)
               
            ! Write offsets data to file
            CALL PARALLEL_WRITE_I32(1, INT8((/NCELLS(NM2)+1/)), DSET_ID_OFF,&
               PLIST_ID, INT8((/NOFFSETS_START+1/)), INT8((/NCELLS(NM2)+1/)), ALL_OFFSETS)
            
            ! Write point data to file
            CALL PARALLEL_WRITE_F32(2, INT8((/3, NPOINTS(NM2)/)), DSET_ID_PTS,&
               PLIST_ID, INT8((/0,NPOINTS_START/)), INT8((/3,NPOINTS(NM2)/)), VERTICES)
            
            ! Write types data to file
            CALL PARALLEL_WRITE_U8(1, INT8((/NCELLS(NM2)/)), DSET_ID_TYP,&
               PLIST_ID, INT8((/NCELLS_START/)), INT8((/NCELLS(NM2)/)), VTKC_TYPE)
            
            DEALLOCATE(VERTS)
            DEALLOCATE(FACES)
            DEALLOCATE(LOCATIONS)
            DEALLOCATE(SURFIND)
            DEALLOCATE(GEOMIND)
            DEALLOCATE(VERTICES)
            DEALLOCATE(ALL_OFFSETS)
            CALL DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)
            N_WRITTEN = N_WRITTEN + 1
         ENDIF
      ENDIF
   ENDDO MESH_LOOP_HDF
   
   ! Write fake data in processes that have less meshes than max process
   DO NM=1,MAXVAL(MESHES_PER_PROCESS)*2
      IF (N_WRITTEN < MAXVAL(MESHES_PER_PROCESS)*2) THEN
      
         ! Write connectivity data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_CON, PLIST_ID, INT8((/0/)), INT8((/0/)), (/0/))
            
         ! Write offsets data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_OFF, PLIST_ID, INT8((/0/)), INT8((/0/)), (/0/))
         
         ! Write point data to file
         CALL PARALLEL_WRITE_F32(2, INT8((/3, 0/)), DSET_ID_PTS, PLIST_ID, INT8((/0,0/)), INT8((/3,0/)), REAL((/0,0,0/)))
         
         ! Write types data to file
         CALL PARALLEL_WRITE_U8(1, INT8((/0/)), DSET_ID_TYP, PLIST_ID, INT8((/0/)), INT8((/0/)), (/0_IB8/))
         N_WRITTEN = N_WRITTEN + 1
      ENDIF
   ENDDO
   
   ! Close VTKHDF interface
   CALL MPI_BARRIER(MPI_COMM_WORLD, ERROR)
   CALL H5DCLOSE_F(DSET_ID_CON, ERROR)
   CALL H5DCLOSE_F(DSET_ID_OFF, ERROR)
   CALL H5DCLOSE_F(DSET_ID_PTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_TYP, ERROR)
   CALL CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)

END SUBROUTINE INITIALIZE_VTKHDF_BNDF_STEP2











SUBROUTINE WRITE_VTKHDF_BNDF_CELL_FILE(FILENAME,NM,NCELLS,NPOINTS,NCONNECTIONS,FAKE_WRITE)
   CHARACTER(*), INTENT(IN) :: FILENAME
   INTEGER, INTENT(IN) :: NM
   LOGICAL, INTENT(IN) :: FAKE_WRITE
   INTEGER(HID_T) :: FILE_ID, PLIST_ID, CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: DSET_ID_CON, DSET_ID_NCELLS    ! Dataset identifiers
   INTEGER(HID_T) :: DSET_ID_NPTS, DSET_ID_OFF, DSET_ID_PTS, DSET_ID_TYP       ! Dataset identifiers
   INTEGER :: NPOINTS_TOTAL, NCELLS_TOTAL, NOFFSETS_TOTAL
   INTEGER :: NCONN_TOTAL, NPIECES
   INTEGER :: NCONN_ACCUM, NPIECES_ACCUM
   INTEGER :: NCONN_MAX, NOFFSETS_MAX, NCELLS_MAX, NPOINTS_MAX
   INTEGER :: NMNM, ERROR, IP
   TYPE (MESH_TYPE), POINTER :: M
   REAL(FB), ALLOCATABLE, DIMENSION(:) :: X_PTS, Y_PTS, Z_PTS
   REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: VERTICES, ALL_VERTICES
   INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS, ALL_CONNECT, ALL_OFFSETS
   INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE, ALL_VTKC_TYPE
   INTEGER(IB32), DIMENSION(1:NMESHES), INTENT(OUT) :: NCELLS, NPOINTS, NCONNECTIONS
   INTEGER(IB32) :: NCELLS_ACCUM, NPOINTS_ACCUM, NOFFSETS_ACCUM, NCONNECTIONS_ACCUM
   TYPE(PATCH_TYPE), POINTER :: PA
   
   IF (FAKE_WRITE) THEN
   
   ENDIF
   
   CALL OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
   ! Read number of cells
   CALL H5DOPEN_F(GROUP_ID1, "NumberOfCells", DSET_ID_NCELLS, ERROR)
   CALL H5DREAD_F(DSET_ID_NCELLS, H5T_STD_I32LE, NCELLS, INT((/NMESHES/),HSIZE_T), ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCELLS, ERROR)

   ! Read number of points
   CALL H5DOPEN_F(GROUP_ID1, "NumberOfPoints", DSET_ID_NPTS, ERROR)
   CALL H5DREAD_F(DSET_ID_NPTS, H5T_STD_I32LE, NPOINTS, INT((/NMESHES/),HSIZE_T), ERROR)
   CALL H5DCLOSE_F(DSET_ID_NPTS, ERROR)
   
   ! Read number of connections
   CALL H5DOPEN_F(GROUP_ID1, "NumberOfConnectivityIds", DSET_ID_NPTS, ERROR)
   CALL H5DREAD_F(DSET_ID_NPTS, H5T_STD_I32LE, NCONNECTIONS, INT((/NMESHES/),HSIZE_T), ERROR)
   CALL H5DCLOSE_F(DSET_ID_NPTS, ERROR)
   
   NPOINTS_TOTAL=0
   NCELLS_TOTAL=0
   NCELLS_ACCUM=0
   NPOINTS_ACCUM=0
   NOFFSETS_TOTAL=0
   NOFFSETS_ACCUM = 0
   NCONN_TOTAL = 0
   NPIECES = 0
   NCONN_ACCUM = 0
   NPIECES_ACCUM = 0
   NCELLS_MAX = 0
   NPOINTS_MAX = 0
   NCONN_MAX = 0
   NOFFSETS_MAX = 0
   
   MESH_LOOP_HDF_COUNT: DO NMNM=1,NMESHES
      NPOINTS_TOTAL = NPOINTS_TOTAL + NPOINTS(NMNM) !+ NVERTS*3
      NCELLS_TOTAL = NCELLS_TOTAL + NCELLS(NMNM) !+ NFACES*3
      NOFFSETS_TOTAL = NOFFSETS_TOTAL + NCELLS(NMNM) + 1
      NCONN_TOTAL = NCONN_TOTAL + NCONNECTIONS(NMNM)
      NPIECES = NPIECES + 1
      NCELLS_MAX = MAX(NCELLS_MAX,NCELLS(NMNM))
      NPOINTS_MAX = MAX(NPOINTS_MAX,NPOINTS(NMNM))
      NOFFSETS_MAX = MAX(NOFFSETS_MAX,NCELLS(NMNM) + 1)
      NCONN_MAX = MAX(NCONN_MAX,NCONNECTIONS(NMNM))
   ENDDO MESH_LOOP_HDF_COUNT
   
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Connectivity"), CRP_LIST, 1,&
      INT8((/NCONN_MAX/)),INT8((/NCONN_TOTAL/)), DSET_ID_CON, PLIST_ID) ! Connectivity
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Offsets"), CRP_LIST, 1,&
      INT8((/NOFFSETS_MAX/)),INT8((/NOFFSETS_TOTAL/)), DSET_ID_OFF, PLIST_ID) ! Offsets
   CALL PARALLEL_INIT_F32(GROUP_ID1, TRIM("Points"), CRP_LIST, 2,&
      INT8((/3, NPOINTS_MAX/)),INT8((/3, NPOINTS_TOTAL/)), DSET_ID_PTS, PLIST_ID) ! Points
   CALL PARALLEL_INIT_U8(GROUP_ID1, TRIM("Types"), CRP_LIST, 1,&
      INT8((/NCELLS_MAX/)),INT8((/NCELLS_TOTAL/)), DSET_ID_TYP, PLIST_ID) ! Types
   
   ALLOCATE(ALL_CONNECT(NCONNECTIONS(NM)))
   ALLOCATE(ALL_OFFSETS(NCELLS(NM)+1))
   ALLOCATE(ALL_VERTICES(3,NPOINTS(NM)))
   ALLOCATE(ALL_VTKC_TYPE(NCELLS(NM)))
   MESH_LOOP_HDF: DO NMNM=1,NMESHES
      IF (NMNM/=NM) THEN
         NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS(NMNM)
         NCELLS_ACCUM = NCELLS_ACCUM + NCELLS(NMNM)
         !IF (NCELLS(NMNM) > 0) NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS(NMNM) + 1
         NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS(NMNM) + 1
         NCONN_ACCUM = NCONN_ACCUM + NCONNECTIONS(NMNM)
         NPIECES_ACCUM = NPIECES_ACCUM+1
         CYCLE MESH_LOOP_HDF
      ENDIF
      M => MESHES(NM)
      IF (NCELLS(NM)==0) THEN
         ALLOCATE(VERTICES(3,NCELLS(NM)))
         ALLOCATE(OFFSETS(NCELLS(NM)))
         ALLOCATE(VTKC_TYPE(NCELLS(NM)))
         ALLOCATE(CONNECT(NCONNECTIONS(NM)))
      ELSEIF (MESHES(NM)%N_PATCH==0) THEN
         NCELLS(NM) = 0
         NPOINTS(NM) = 0
         NCONNECTIONS(NM) = 0
      ELSE
         PATCH_LOOP1: DO IP=1,N_PATCH
            PA => PATCH(IP)
            ! Initialize piece
            CALL BUILD_VTK_SOLID_PHASE_GEOMETRY(NM, PA, NCELLS(NM), NPOINTS(NM),&
               X_PTS, Y_PTS, Z_PTS, CONNECT, OFFSETS, VTKC_TYPE)
            NCONNECTIONS_ACCUM = NCONNECTIONS_ACCUM + NCONNECTIONS(NM)
            NCELLS_ACCUM = NCELLS_ACCUM + NCELLS(NM)
            NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS(NM)
            CALL DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)
         ENDDO PATCH_LOOP1
      ENDIF
      
      !   QUANTITY_LOOPB: DO IQ=1,N_BNDF
      !      SL => SLICE(IQ)
      !      !IF (TRIM(SL%SLCF_NAME)/=TRIM(SLCFNAME)) CYCLE QUANTITY_LOOPB
      !      CALL BUILD_VTK_SLICE_GEOMETRY2(NM, SL, NC, NP, VERTICES, CONNECT, OFFSETS, VTKC_TYPE)
      !      EXIT
      !   ENDDO QUANTITY_LOOPB
      !ENDIF
      
      IF (NCELLS(NM)>0) THEN
         !WRITE(*,*) "RANK ", MY_RANK, " MESH ", NM, " NCONN_ACCUM ", NCONN_ACCUM, " SZ ", NCELLS(NM)*NCONNECTIONS
      ENDIF
      ! Write connectivity data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/NCONNECTIONS(NM)/)), DSET_ID_CON,&
         PLIST_ID, INT8((/NCONN_ACCUM/)), INT8((/NCONNECTIONS(NM)/)), CONNECT)
         
      ! Write offsets data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/NCELLS(NM)+1/)), DSET_ID_OFF,&
         PLIST_ID, INT8((/NOFFSETS_ACCUM/)), INT8((/NCELLS(NM)+1/)), OFFSETS)
      
      ! Write point data to file
      CALL PARALLEL_WRITE_F32(2, INT8((/3, NPOINTS(NM)/)), DSET_ID_PTS,&
         PLIST_ID, INT8((/0,NPOINTS_ACCUM/)), INT8((/3,NPOINTS(NM)/)), VERTICES)
      
      ! Write types data to file
      CALL PARALLEL_WRITE_U8(1, INT8((/NCELLS(NM)/)), DSET_ID_TYP,&
         PLIST_ID, INT8((/NCELLS_ACCUM/)), INT8((/NCELLS(NM)/)), VTKC_TYPE)
      
      DEALLOCATE(VERTICES)
      DEALLOCATE(OFFSETS)
      DEALLOCATE(CONNECT)
      DEALLOCATE(VTKC_TYPE)
      NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS(NM)
      NCELLS_ACCUM = NCELLS_ACCUM + NCELLS(NM)
      !IF (NCELLS(NM)>0) NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS(NM) + 1
      NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS(NM) + 1
      NCONN_ACCUM = NCONN_ACCUM + NCONNECTIONS(NM)
      NPIECES_ACCUM = NPIECES_ACCUM+1
   ENDDO MESH_LOOP_HDF
   
   CALL MPI_BARRIER(MPI_COMM_WORLD, ERROR)
   
   ! Close HDF5 datasets
   CALL H5DCLOSE_F(DSET_ID_CON, ERROR)
   CALL H5DCLOSE_F(DSET_ID_OFF, ERROR)
   CALL H5DCLOSE_F(DSET_ID_PTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_TYP, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)

   CALL MPI_BARRIER(MPI_COMM_WORLD, ERROR)
   
   ! Close VTKHDF interface
   CALL CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
END SUBROUTINE WRITE_VTKHDF_BNDF_CELL_FILE



























SUBROUTINE GET_GEOMSIZES_DUP(SLICETYPE,I1,I2,J1,J2,K1,K2,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS)

! determine NVERTS and NFACES for one of the following cases
!
! IGNORE_GEOM  - creates a slice file geometry file that ignores immersed geometric objects .  Triangles inside obstacle
!                regions (a solid) are tagged with a 1, triangles outside of obstacle regions (the gas) are tagged
!                with a 0 . Smokeview uses this information to show/hide these two regions
! INCLUDE_GEOM - creates a slice file geometry file that accounts for immersed geometric objects .  If there are no immersed
!                objects present then this slice type is equivalent to the 'IGNORE_GEOM' case.  Triangles completely inside a
!                solid are tagged with a 1, triangles completely in the gas are tagged with a 0 and triangles in a cutcell are
!                with a tagged 2.  As with the IGNORE_GEOM type, Smokeview uses this information to show/hide these regions

   CHARACTER(*), INTENT(IN) :: SLICETYPE
   INTEGER, INTENT(IN) :: I1,I2,J1,J2,K1,K2
   INTEGER, INTENT(OUT) :: NVERTS, NVERTS_CUTCELLS, NFACES, NFACES_CUTCELLS

   INTEGER :: DIR,SLICE
   INTEGER :: I, J, K
   INTEGER :: ICF, IFACE, NVF, ICC, JCC, ICF2, IFACE2, NFC, ICCF

   CHARACTER(LEN=100) :: SLICETYPE_LOCAL

   SLICETYPE_LOCAL=TRIM(SLICETYPE) ! only generate CUTCELLS slice files if the immersed geometry option is turned on
   IF (SLICETYPE=='INCLUDE_GEOM' .AND. .NOT.CC_IBM) SLICETYPE_LOCAL='IGNORE_GEOM'

   NVERTS=0
   NFACES=0
   NVERTS_CUTCELLS=0
   NFACES_CUTCELLS=0
   IF (SLICETYPE_LOCAL=='IGNORE_GEOM') THEN
      CALL GETSLICEDIR_DUP(I1,I2,J1,J2,K1,K2,DIR,SLICE)
      IF (DIR==1) THEN
        NVERTS = (J2 + 1 - J1)*(K2 + 1 - K1)
        NFACES = 2*(J2 - J1)*(K2 - K1)
      ELSE IF (DIR==2) THEN
        NVERTS = (I2 + 1 - I1)*(K2 + 1 - K1)
        NFACES = 2*(I2 - I1)*(K2 - K1)
      ELSE
        NVERTS = (I2 + 1 - I1)*(J2 + 1 - J1)
        NFACES = 2*(I2 - I1)*(J2 - J1)
      ENDIF
   ELSE IF (SLICETYPE_LOCAL=='INCLUDE_GEOM') THEN
      CALL GETSLICEDIR_DUP(I1,I2,J1,J2,K1,K2,DIR,SLICE)
      IF (DIR==1) THEN
         NVERTS = (J2 + 1 - J1)*(K2 + 1 - K1)
         NFACES = 0
         DO K = K1+1, K2
            DO J = J1+1, J2
               IF (ANY(CELL(CELL_INDEX(SLICE:SLICE+1,J,K))%SOLID)) CYCLE
               IF (FCVAR(SLICE,J,K,CC_FGSC,IAXIS) == CC_CUTCFE) THEN
                  ICF = FCVAR(SLICE,J,K,CC_IDCF,IAXIS) ! a cutcell so count number of faces
                  DO IFACE=1,CUT_FACE(ICF)%NFACE+CUT_FACE(ICF)%NSFACE ! Adds also SOLID side faces.
                     NVF=CUT_FACE(ICF)%CFELEM(1,IFACE)
                     NFACES_CUTCELLS = NFACES_CUTCELLS + NVF - 2
                     NVERTS_CUTCELLS = NVERTS_CUTCELLS + NVF
                  ENDDO
               ELSE
                  NFACES = NFACES + 2 ! a gas or solid cell so add 2 to the number of faces
               ENDIF
            ENDDO
         ENDDO
      ELSE IF (DIR==2) THEN
         NVERTS = (I2 + 1 - I1)*(K2 + 1 - K1)
         DO K = K1+1, K2
            DO I = I1+1, I2
               IF(ANY(CELL(CELL_INDEX(I,SLICE:SLICE+1,K))%SOLID)) CYCLE
               IF (FCVAR(I,SLICE,K,CC_FGSC,JAXIS) == CC_CUTCFE) THEN
                  ICF = FCVAR(I,SLICE,K,CC_IDCF,JAXIS)
                  DO IFACE=1,CUT_FACE(ICF)%NFACE+CUT_FACE(ICF)%NSFACE ! Adds also SOLID side faces.
                     NVF=CUT_FACE(ICF)%CFELEM(1,IFACE)
                     NFACES_CUTCELLS = NFACES_CUTCELLS + NVF - 2
                     NVERTS_CUTCELLS = NVERTS_CUTCELLS + NVF
                  ENDDO
               ELSE
                  NFACES = NFACES + 2
               ENDIF
            ENDDO
         ENDDO
      ELSE
         NVERTS = (I2 + 1 - I1)*(J2 + 1 - J1)
         DO I = I1+1, I2
            DO J = J1+1, J2
               IF(ANY(CELL(CELL_INDEX(I,J,SLICE:SLICE+1))%SOLID)) CYCLE
               IF (FCVAR(I,J,SLICE,CC_FGSC,KAXIS) == CC_CUTCFE) THEN
                  ICF = FCVAR(I,J,SLICE,CC_IDCF,KAXIS)
                  DO IFACE=1,CUT_FACE(ICF)%NFACE+CUT_FACE(ICF)%NSFACE ! Adds also SOLID side faces.
                     NVF=CUT_FACE(ICF)%CFELEM(1,IFACE)
                     NFACES_CUTCELLS = NFACES_CUTCELLS + NVF - 2
                     NVERTS_CUTCELLS = NVERTS_CUTCELLS + NVF
                  ENDDO
               ELSE
                  NFACES = NFACES + 2
               ENDIF
            ENDDO
         ENDDO
      ENDIF
   ELSE IF (SLICETYPE_LOCAL=='INBOUND_FACES') THEN
      DO K = 1, KBAR
         DO J = 1, JBAR
            DO I = 1, IBAR
               IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
               IF (CCVAR(I,J,K,CC_IDCF) > 0) THEN ! There are INBOUNDARY cut-faces on this cell:
                  ICF = CCVAR(I,J,K,CC_IDCF)
                  DO IFACE=1,CUT_FACE(ICF)%NFACE ! Adds also SOLID side faces.
                     NVF=CUT_FACE(ICF)%CFELEM(1,IFACE)
                     NFACES_CUTCELLS = NFACES_CUTCELLS + NVF - 2
                     NVERTS_CUTCELLS = NVERTS_CUTCELLS + NVF
                  ENDDO
               ENDIF
            ENDDO
         ENDDO
      ENDDO
   ELSE IF (SLICETYPE_LOCAL=='CUT_CELLS') THEN
      DO K = 1, KBAR
         DO J = 1, JBAR
            DO I = 1, IBAR
               IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
               IF (CCVAR(I,J,K,CC_IDCC) <= 0) CYCLE
               ICC = CCVAR(I,J,K,CC_IDCC)
               DO JCC=1,CUT_CELL(ICC)%NCELL
                  NFC=CUT_CELL(ICC)%CCELEM(1,JCC)
                  ! Loop on faces corresponding to cut-cell ICC2:
                  DO ICCF=1,NFC
                     IFACE=CUT_CELL(ICC)%CCELEM(ICCF+1,JCC)
                     SELECT CASE(CUT_CELL(ICC)%FACE_LIST(1,IFACE))
                     CASE(CC_FTYPE_RCGAS) ! REGULAR GASPHASE
                        NVF = 4
                        NFACES_CUTCELLS = NFACES_CUTCELLS + NVF - 2
                        NVERTS_CUTCELLS = NVERTS_CUTCELLS + NVF
                     CASE(CC_FTYPE_CFGAS)
                        ICF2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
                        IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
                        NVF=CUT_FACE(ICF2)%CFELEM(1,IFACE2)
                        NFACES_CUTCELLS = NFACES_CUTCELLS + NVF - 2
                        NVERTS_CUTCELLS = NVERTS_CUTCELLS + NVF
                     CASE(CC_FTYPE_CFINB)
                        ICF2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
                        IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
                        NVF=CUT_FACE(ICF2)%CFELEM(1,IFACE2)
                        NFACES_CUTCELLS = NFACES_CUTCELLS + NVF - 2
                        NVERTS_CUTCELLS = NVERTS_CUTCELLS + NVF
                     END SELECT
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO
   ENDIF
   NFACES = NFACES + NFACES_CUTCELLS
   NVERTS = NVERTS + NVERTS_CUTCELLS
END SUBROUTINE GET_GEOMSIZES_DUP


SUBROUTINE GETSLICEDIR_DUP(I1,I2,J1,J2,K1,K2,DIR,SLICE)
INTEGER, INTENT(IN) :: I1, I2, J1, J2, K1, K2
INTEGER, INTENT(OUT) :: DIR, SLICE

IF (ABS(K1-K2)<MIN(ABS(I1-I2),ABS(J1-J2))) THEN
   DIR=3
   SLICE = K1
ELSE IF (ABS(J1-J2)<MIN(ABS(I1-I2),ABS(K1-K2))) THEN
   DIR=2
   SLICE = J1
ELSE
   DIR=1
   SLICE = I1
ENDIF
RETURN

END SUBROUTINE GETSLICEDIR_DUP


INTEGER FUNCTION IJK_DUP(I,J,NI)
INTEGER, INTENT(IN) :: I, J, NI
IJK_DUP = I + (J-1)*NI
END FUNCTION IJK_DUP

SUBROUTINE GET_GEOMINFO_DUP(SLICETYPE,I1,I2,J1,J2,K1,K2,NVERTS,NVERTS_CUTCELLS,NFACES,NFACES_CUTCELLS,&
                        VERTS,FACES,LOCATIONS,SURFIND,GEOMIND)

! generate VERTS(1:3*NVERTS) and FACES(1:3*NFACES) arrays

   CHARACTER(*), INTENT(IN) :: SLICETYPE
   INTEGER, INTENT(IN) :: I1,I2,J1,J2,K1,K2
   INTEGER, INTENT(IN) :: NVERTS, NVERTS_CUTCELLS, NFACES, NFACES_CUTCELLS
   INTEGER, INTENT(OUT), DIMENSION(3*NFACES), TARGET :: FACES
   INTEGER, INTENT(OUT), DIMENSION(NFACES) :: LOCATIONS
   INTEGER, OPTIONAL, INTENT(OUT), DIMENSION(NFACES) :: SURFIND,GEOMIND
   REAL(FB), INTENT(OUT), DIMENSION(3*NVERTS), TARGET :: VERTS

   INTEGER :: VERT_OFFSET
   INTEGER, POINTER, DIMENSION(:) :: FACEPTR
   REAL(FB), POINTER, DIMENSION(:) :: VERTPTR

   INTEGER :: DIR, SLICE
   INTEGER :: NI, NJ, NK
   INTEGER :: I, J, K
   INTEGER IFACE, IVERT, IVERTCUT, IFACECUT, IVERTCF, IFACECF
   INTEGER VERTBEG, VERTEND, FACEBEG, FACEEND
   LOGICAL IS_SOLID
   INTEGER :: ICF, NVF, IVCF, IADD, JADD, KADD, X1AXIS
   INTEGER :: II, JJ, KK, ICC, JCC, NFC, ICCF, LOWHIGH, ILH, ICF2, IFACE2
   INTEGER, ALLOCATABLE, DIMENSION(:) :: LOCTYPE

   CHARACTER(LEN=100) :: SLICETYPE_LOCAL

   SLICETYPE_LOCAL=TRIM(SLICETYPE) ! only generate CUTCELLS slice files if the immersed geometry option is turned on
   IF (SLICETYPE=='INCLUDE_GEOM' .AND. .NOT.CC_IBM) SLICETYPE_LOCAL='IGNORE_GEOM'

   LOCATIONS = 0 ! initially assume triangles are in gas and tag with 0
   IF (SLICETYPE_LOCAL=='IGNORE_GEOM') THEN
      NI = I2 + 1 - I1
      NJ = J2 + 1 - J1
      NK = K2 + 1 - K1
      CALL GETSLICEDIR_DUP(I1,I2,J1,J2,K1,K2,DIR,SLICE)
      IVERT = 0
      IFACE = 0
      IF (DIR==1) THEN
         DO K=K1,K2
            DO J=J1,J2
               DO I = SLICE,SLICE
                  IVERT = IVERT + 1
                  VERTS(3*IVERT-2) = XPLT(SLICE)
                  VERTS(3*IVERT-1) = YPLT(J)
                  VERTS(3*IVERT)   = ZPLT(K)
               ENDDO
            ENDDO
         ENDDO
         DO K=1,NK-1
            DO J=1,NJ-1
               IS_SOLID = CELL(CELL_INDEX(SLICE,J+J1,K+K1))%SOLID
               IFACE = IFACE + 1
               IF (IS_SOLID) LOCATIONS(IFACE) = 1 + 16 ! triangle is in a solid so tag with 1
               FACES(3*IFACE-2) = IJK_DUP(  J,  K,NJ)
               FACES(3*IFACE-1) = IJK_DUP(J+1,  K,NJ)
               FACES(3*IFACE)   = IJK_DUP(J+1,K+1,NJ)

               IFACE = IFACE + 1
               IF (IS_SOLID) LOCATIONS(IFACE) = 1 + 4 ! triangle is in a solid so tag with 1
               FACES(3*IFACE-2) = IJK_DUP(  J,  K,NJ)
               FACES(3*IFACE-1) = IJK_DUP(J+1,K+1,NJ)
               FACES(3*IFACE)   = IJK_DUP(  J,K+1,NJ)
            ENDDO
         ENDDO
      ELSE IF (DIR==2) THEN
         DO K=K1,K2
            DO J=SLICE,SLICE
               DO I = I1,I2
                  IVERT = IVERT + 1
                  VERTS(3*IVERT-2) = XPLT(I)
                  VERTS(3*IVERT-1) = YPLT(SLICE)
                  VERTS(3*IVERT)   = ZPLT(K)
               ENDDO
            ENDDO
         ENDDO
         DO K=1,NK-1
            DO I=1,NI-1
               IS_SOLID = CELL(CELL_INDEX(I+I1,SLICE,K+K1))%SOLID
               IFACE = IFACE + 1
               IF (IS_SOLID) LOCATIONS(IFACE) = 1 + 16
               FACES(3*IFACE-2) = IJK_DUP(  I,  K,NI)
               FACES(3*IFACE-1) = IJK_DUP(I+1,  K,NI)
               FACES(3*IFACE)   = IJK_DUP(I+1,K+1,NI)

               IFACE = IFACE + 1
               IF (IS_SOLID) LOCATIONS(IFACE) = 1 + 4
               FACES(3*IFACE-2) = IJK_DUP(  I,  K,NI)
               FACES(3*IFACE-1) = IJK_DUP(I+1,K+1,NI)
               FACES(3*IFACE)   = IJK_DUP(  I,K+1,NI)
            ENDDO
         ENDDO
      ELSE
         DO K=SLICE,SLICE
            DO J=J1,J2
               DO I = I1,I2
                  IVERT = IVERT + 1
                  VERTS(3*IVERT-2) = XPLT(I)
                  VERTS(3*IVERT-1) = YPLT(J)
                  VERTS(3*IVERT)   = ZPLT(SLICE)
               ENDDO
            ENDDO
         ENDDO
         DO J=1,NJ-1
            DO I=1,NI-1
               IS_SOLID = CELL(CELL_INDEX(I+I1,J+J1,SLICE))%SOLID
               IFACE = IFACE + 1
               IF (IS_SOLID) LOCATIONS(IFACE) = 1 + 16
               FACES(3*IFACE-2) = IJK_DUP(  I,  J,NI)
               FACES(3*IFACE-1) = IJK_DUP(I+1,  J,NI)
               FACES(3*IFACE)   = IJK_DUP(I+1,J+1,NI)

               IFACE = IFACE + 1
               IF (IS_SOLID) LOCATIONS(IFACE) = 1 + 4
               FACES(3*IFACE-2) = IJK_DUP(  I,  J,NI)
               FACES(3*IFACE-1) = IJK_DUP(I+1,J+1,NI)
               FACES(3*IFACE)   = IJK_DUP(  I,J+1,NI)
            ENDDO
         ENDDO
      ENDIF
   ELSE IF (SLICETYPE_LOCAL=='INCLUDE_GEOM') THEN
      IVERTCUT=NVERTS-NVERTS_CUTCELLS ! start cutcell counters after 'regular' cells
      IFACECUT=NFACES-NFACES_CUTCELLS
      NI = I2 + 1 - I1
      NJ = J2 + 1 - J1
      NK = K2 + 1 - K1
      CALL GETSLICEDIR_DUP(I1,I2,J1,J2,K1,K2,DIR,SLICE)
      IVERT = 0
      IFACE = 0
      IF (DIR==1) THEN
         DO K=K1,K2
            DO J=J1,J2
               DO I = SLICE,SLICE
                  IVERT = IVERT + 1
                  VERTS(3*IVERT-2) = XPLT(SLICE)
                  VERTS(3*IVERT-1) = YPLT(J)
                  VERTS(3*IVERT)   = ZPLT(K)
               ENDDO
            ENDDO
         ENDDO
         DO K=1,NK-1
            DO J=1,NJ-1
               IF (ANY(CELL(CELL_INDEX(SLICE:SLICE+1,J,K))%SOLID)) CYCLE
               IF (FCVAR(SLICE,J,K,CC_FGSC,IAXIS) == CC_CUTCFE) THEN
                  ICF = FCVAR(SLICE,J,K,CC_IDCF,IAXIS) ! store cutcell faces and vertices
                  DO IFACECF=1,CUT_FACE(ICF)%NFACE+CUT_FACE(ICF)%NSFACE
                     NVF=CUT_FACE(ICF)%CFELEM(1,IFACECF)
                     VERTBEG = IVERTCUT + 1
                     VERTBEG = 3*VERTBEG - 2
                     VERTEND = IVERTCUT + NVF
                     VERTEND = 3*VERTEND
                     DO IVCF=1,NVF
                        IVERTCUT = IVERTCUT + 1
                        IVERTCF=CUT_FACE(ICF)%CFELEM(IVCF+1,IFACECF)
                        VERTS(3*IVERTCUT-2:3*IVERTCUT) = REAL(CUT_FACE(ICF)%XYZVERT(1:3,IVERTCF),FB)
                     ENDDO

                     FACEBEG = 3*(IFACECUT+1) - 2
                     FACEEND = FACEBEG + 3*(NVF-2) - 1
                     FACEPTR(1:3*(NVF-2))        =>FACES(FACEBEG:FACEEND)
                     VERTPTR(1:1+VERTEND-VERTBEG)=>VERTS(VERTBEG:VERTEND)
                     VERT_OFFSET = IVERTCUT - NVF
                     ALLOCATE(LOCTYPE(NVF-2))
                     CALL TRIANGULATE(DIR,VERTPTR,NVF,VERT_OFFSET,FACEPTR,LOCTYPE)
                     DO IVCF = 1, NVF-2 ! for now assume face is convex
                        ! vertex indices 1, 2, ..., NVF
                        ! faces (1,2,3), (1,3,4), ..., (1,NVF-1,NVF)
                        IFACECUT = IFACECUT + 1
                        LOCATIONS(IFACECUT) = 2 + LOCTYPE(IVCF)
                        IF(IFACECF > CUT_FACE(ICF)%NFACE) LOCATIONS(IFACECUT) = 1 + LOCTYPE(IVCF) ! Solid side cut-faces.
! after TRIANGULATE is verified remove the following 3 lines of code (and similar lines in 2 locations below)
!                        FACES(3*IFACECUT-2) = (IVERTCUT-NVF)+1
!                        FACES(3*IFACECUT-1) = (IVERTCUT-NVF)+1+IVCF
!                        FACES(3*IFACECUT)   = (IVERTCUT-NVF)+2+IVCF
                     ENDDO
                     DEALLOCATE(LOCTYPE)
                  ENDDO
               ELSE
                  IFACE = IFACE + 1 ! store solid and gas faces and vertices (2 faces per cell)
                  LOCATIONS(IFACE) = 0 + 16
                  IF ( FCVAR(SLICE,J,K,CC_FGSC,IAXIS) == CC_SOLID) LOCATIONS(IFACE)=1 + 16
                  FACES(3*IFACE-2) = IJK_DUP(  J,  K,NJ)
                  FACES(3*IFACE-1) = IJK_DUP(J+1,  K,NJ)
                  FACES(3*IFACE)   = IJK_DUP(J+1,K+1,NJ)

                  IFACE = IFACE + 1
                  LOCATIONS(IFACE) = 0 + 4
                  IF ( FCVAR(SLICE,J,K,CC_FGSC,IAXIS) == CC_SOLID) LOCATIONS(IFACE)=1 + 4
                  FACES(3*IFACE-2) = IJK_DUP(  J,  K,NJ)
                  FACES(3*IFACE-1) = IJK_DUP(J+1,K+1,NJ)
                  FACES(3*IFACE)   = IJK_DUP(  J,K+1,NJ)
               ENDIF
            ENDDO
         ENDDO
      ELSE IF (DIR==2) THEN
         DO K=K1,K2
            DO J=SLICE,SLICE
               DO I = I1,I2
                  IVERT = IVERT + 1
                  VERTS(3*IVERT-2) = XPLT(I)
                  VERTS(3*IVERT-1) = YPLT(SLICE)
                  VERTS(3*IVERT)   = ZPLT(K)
               ENDDO
            ENDDO
         ENDDO
         DO K=1,NK-1
            DO I=1,NI-1
               IF (ANY(CELL(CELL_INDEX(I,SLICE:SLICE+1,K))%SOLID)) CYCLE
               IF (FCVAR(I,SLICE,K,CC_FGSC,JAXIS) == CC_CUTCFE) THEN
                  ICF = FCVAR(I,SLICE,K,CC_IDCF,JAXIS)
                  DO IFACECF=1,CUT_FACE(ICF)%NFACE+CUT_FACE(ICF)%NSFACE
                     NVF=CUT_FACE(ICF)%CFELEM(1,IFACECF)
                     VERTBEG = IVERTCUT + 1
                     VERTBEG = 3*VERTBEG - 2
                     VERTEND = IVERTCUT + NVF
                     VERTEND = 3*VERTEND
                     DO IVCF=1,NVF
                        IVERTCUT = IVERTCUT + 1
                        IVERTCF=CUT_FACE(ICF)%CFELEM(IVCF+1,IFACECF)
                        VERTS(3*IVERTCUT-2:3*IVERTCUT) = REAL(CUT_FACE(ICF)%XYZVERT(1:3,IVERTCF),FB)
                     ENDDO
                     FACEBEG = 3*(IFACECUT+1) - 2
                     FACEEND = FACEBEG + 3*(NVF-2) - 1
                     FACEPTR(1:3*(NVF-2))        =>FACES(FACEBEG:FACEEND)
                     VERTPTR(1:1+VERTEND-VERTBEG)=>VERTS(VERTBEG:VERTEND)
                     VERT_OFFSET = IVERTCUT - NVF
                     ALLOCATE(LOCTYPE(NVF-2))
                     CALL TRIANGULATE(DIR,VERTPTR,NVF,VERT_OFFSET,FACEPTR,LOCTYPE)
                     DO IVCF = 1, NVF-2 ! for now assume face is convex
                        IFACECUT = IFACECUT + 1
                        LOCATIONS(IFACECUT) = 2 + LOCTYPE(IVCF)
                        IF(IFACECF > CUT_FACE(ICF)%NFACE) LOCATIONS(IFACECUT) = 1 + LOCTYPE(IVCF) ! Solid side cut-faces.
!                        FACES(3*IFACECUT-2) = IVERTCUT-NVF+1
!                        FACES(3*IFACECUT-1) = IVERTCUT-NVF+1+IVCF
!                        FACES(3*IFACECUT)   = IVERTCUT-NVF+1+IVCF+1
                     ENDDO
                     DEALLOCATE(LOCTYPE)
                  ENDDO
               ELSE
                  IFACE = IFACE + 1
                  LOCATIONS(IFACE) = 0 + 16
                  IF ( FCVAR(I,SLICE,K,CC_FGSC,JAXIS) == CC_SOLID) LOCATIONS(IFACE)=1 + 16
                  FACES(3*IFACE-2) = IJK_DUP(  I,  K,NI)
                  FACES(3*IFACE-1) = IJK_DUP(I+1,  K,NI)
                  FACES(3*IFACE)   = IJK_DUP(I+1,K+1,NI)

                  IFACE = IFACE + 1
                  LOCATIONS(IFACE) = 0 + 4
                  IF ( FCVAR(I,SLICE,K,CC_FGSC,JAXIS) == CC_SOLID) LOCATIONS(IFACE)=1 + 4
                  FACES(3*IFACE-2) = IJK_DUP(  I,  K,NI)
                  FACES(3*IFACE-1) = IJK_DUP(I+1,K+1,NI)
                  FACES(3*IFACE)   = IJK_DUP(  I,K+1,NI)
               ENDIF
            ENDDO
         ENDDO
      ELSE
         DO K=SLICE,SLICE
            DO J=J1,J2
               DO I = I1,I2
                  IVERT = IVERT + 1
                  VERTS(3*IVERT-2) = XPLT(I)
                  VERTS(3*IVERT-1) = YPLT(J)
                  VERTS(3*IVERT)   = ZPLT(SLICE)
               ENDDO
            ENDDO
         ENDDO
         DO J=1,NJ-1
            DO I=1,NI-1
               IF (ANY(CELL(CELL_INDEX(I,J,SLICE:SLICE+1))%SOLID)) CYCLE
               IF (FCVAR(I,J,SLICE,CC_FGSC,KAXIS) == CC_CUTCFE) THEN
                  ICF = FCVAR(I,J,SLICE,CC_IDCF,KAXIS)
                  DO IFACECF=1,CUT_FACE(ICF)%NFACE+CUT_FACE(ICF)%NSFACE
                     NVF=CUT_FACE(ICF)%CFELEM(1,IFACECF)
                     VERTBEG = IVERTCUT + 1
                     VERTBEG = 3*VERTBEG - 2
                     VERTEND = IVERTCUT + NVF
                     VERTEND = 3*VERTEND
                     DO IVCF=1,NVF
                        IVERTCUT = IVERTCUT + 1
                        IVERTCF=CUT_FACE(ICF)%CFELEM(IVCF+1,IFACECF)
                        VERTS(3*IVERTCUT-2:3*IVERTCUT) = REAL(CUT_FACE(ICF)%XYZVERT(1:3,IVERTCF),FB)
                     ENDDO
                     FACEBEG = 3*(IFACECUT+1) - 2
                     FACEEND = FACEBEG + 3*(NVF-2) - 1
                     FACEPTR(1:3*(NVF-2))        =>FACES(FACEBEG:FACEEND)
                     VERTPTR(1:1+VERTEND-VERTBEG)=>VERTS(VERTBEG:VERTEND)
                     VERT_OFFSET = IVERTCUT - NVF
                     ALLOCATE(LOCTYPE(NVF-2))
                     CALL TRIANGULATE(DIR,VERTPTR,NVF,VERT_OFFSET,FACEPTR,LOCTYPE)
                     DO IVCF = 1, NVF-2 ! for now assume face is convex
                        IFACECUT = IFACECUT + 1
                        LOCATIONS(IFACECUT) = 2 + LOCTYPE(IVCF)
                        IF(IFACECF > CUT_FACE(ICF)%NFACE) LOCATIONS(IFACECUT) = 1 + LOCTYPE(IVCF) ! Solid side cut-faces.
!                        FACES(3*IFACECUT-2) = IVERTCUT-NVF+1
!                        FACES(3*IFACECUT-1) = IVERTCUT-NVF+1+IVCF
!                        FACES(3*IFACECUT)   = IVERTCUT-NVF+1+IVCF+1
                     ENDDO
                     DEALLOCATE(LOCTYPE)
                  ENDDO
               ELSE
                  IFACE = IFACE + 1
                  LOCATIONS(IFACE) = 0 + 16
                  IF ( FCVAR(I,J,SLICE,CC_FGSC,KAXIS) == CC_SOLID) LOCATIONS(IFACE)=1 + 16
                  FACES(3*IFACE-2) = IJK_DUP(  I,  J,NI)
                  FACES(3*IFACE-1) = IJK_DUP(I+1,  J,NI)
                  FACES(3*IFACE)   = IJK_DUP(I+1,J+1,NI)

                  IFACE = IFACE + 1
                  LOCATIONS(IFACE) = 0 + 4
                  IF ( FCVAR(I,J,SLICE,CC_FGSC,KAXIS) == CC_SOLID) LOCATIONS(IFACE)=1 + 4
                  FACES(3*IFACE-2) = IJK_DUP(  I,  J,NI)
                  FACES(3*IFACE-1) = IJK_DUP(I+1,J+1,NI)
                  FACES(3*IFACE)   = IJK_DUP(  I,J+1,NI)
               ENDIF
            ENDDO
         ENDDO
      ENDIF
   ELSE IF (SLICETYPE_LOCAL=='INBOUND_FACES') THEN
      DIR   = 0
      IVERTCUT=NVERTS-NVERTS_CUTCELLS ! start cutcell counters after 'regular' cells
      IFACECUT=NFACES-NFACES_CUTCELLS
      DO K=1,KBAR
         DO J=1,JBAR
            DO I=1,IBAR
            IF (CELL(CELL_INDEX(I,J,K))%SOLID) CYCLE
            IF (CCVAR(I,J,K,CC_IDCF) > 0) THEN
               ICF = CCVAR(I,J,K,CC_IDCF)
               DO IFACECF=1,CUT_FACE(ICF)%NFACE
                  NVF=CUT_FACE(ICF)%CFELEM(1,IFACECF)
                  VERTBEG = IVERTCUT + 1
                  VERTBEG = 3*VERTBEG - 2
                  VERTEND = IVERTCUT + NVF
                  VERTEND = 3*VERTEND
                  DO IVCF=1,NVF
                     IVERTCUT = IVERTCUT + 1
                     IVERTCF=CUT_FACE(ICF)%CFELEM(IVCF+1,IFACECF)
                     VERTS(3*IVERTCUT-2:3*IVERTCUT) = REAL(CUT_FACE(ICF)%XYZVERT(1:3,IVERTCF),FB)
                  ENDDO
                  IF(PRESENT(SURFIND)) SURFIND(IFACECUT+1:IFACECUT+NVF-2) = CUT_FACE(ICF)%SURF_INDEX(IFACECF)
                  IF(PRESENT(GEOMIND)) GEOMIND(IFACECUT+1:IFACECUT+NVF-2) = CUT_FACE(ICF)%  BODTRI(1,IFACECF)
                  FACEBEG = 3*(IFACECUT+1) - 2
                  FACEEND = FACEBEG + 3*(NVF-2) - 1
                  FACEPTR(1:3*(NVF-2))        =>FACES(FACEBEG:FACEEND)
                  VERTPTR(1:1+VERTEND-VERTBEG)=>VERTS(VERTBEG:VERTEND)
                  VERT_OFFSET = IVERTCUT - NVF
                  ALLOCATE(LOCTYPE(NVF-2))
                  CALL TRIANGULATE(DIR,VERTPTR,NVF,VERT_OFFSET,FACEPTR,LOCTYPE)
                  DO IVCF = 1, NVF-2 ! for now assume face is convex
                     IFACECUT = IFACECUT + 1
                     LOCATIONS(IFACECUT) = 1 + LOCTYPE(IVCF) ! Consider them as SOLID.
                  ENDDO
                  DEALLOCATE(LOCTYPE)
               ENDDO
            ENDIF
            ENDDO
         ENDDO
      ENDDO
   ELSE IF (SLICETYPE_LOCAL=='CUT_CELLS') THEN
      IVERTCUT=NVERTS-NVERTS_CUTCELLS ! start cutcell counters after 'regular' cells
      IFACECUT=NFACES-NFACES_CUTCELLS
      DO KK = 1, KBAR
         DO JJ = 1, JBAR
            DO II = 1, IBAR
               IF (CELL(CELL_INDEX(II,JJ,KK))%SOLID) CYCLE
               IF (CCVAR(II,JJ,KK,CC_IDCC) <= 0) CYCLE
               ICC = CCVAR(II,JJ,KK,CC_IDCC)
               DO JCC=1,CUT_CELL(ICC)%NCELL
                  NFC=CUT_CELL(ICC)%CCELEM(1,JCC)
                  ! Loop on faces corresponding to cut-cell ICC2:
                  DO ICCF=1,NFC
                     IFACE=CUT_CELL(ICC)%CCELEM(ICCF+1,JCC)
                     SELECT CASE(CUT_CELL(ICC)%FACE_LIST(1,IFACE))
                     CASE(CC_FTYPE_RCGAS) ! REGULAR GASPHASE
                        LOWHIGH = CUT_CELL(ICC)%FACE_LIST(2,IFACE)
                        X1AXIS  = CUT_CELL(ICC)%FACE_LIST(3,IFACE)
                        ILH     = LOWHIGH - 1
                        I=II; J=JJ; K=KK;
                        SELECT CASE(X1AXIS)
                        CASE(IAXIS)
                           I=II-FCELL+ILH
                           DO KADD=-1,0
                              DO JADD=-1,0
                                 IVERTCUT = IVERTCUT + 1
                                 VERTS(3*IVERTCUT-2) = REAL(X(I     ),FB)
                                 VERTS(3*IVERTCUT-1) = REAL(Y(J+JADD),FB)
                                 VERTS(3*IVERTCUT)   = REAL(Z(K+KADD),FB)
                              ENDDO
                           ENDDO
                        CASE(JAXIS)
                           J=JJ-FCELL+ILH
                           DO IADD=-1,0
                              DO KADD=-1,0
                                 IVERTCUT = IVERTCUT + 1
                                 VERTS(3*IVERTCUT-2) = REAL(X(I+IADD),FB)
                                 VERTS(3*IVERTCUT-1) = REAL(Y(J     ),FB)
                                 VERTS(3*IVERTCUT)   = REAL(Z(K+KADD),FB)
                              ENDDO
                           ENDDO
                        CASE(KAXIS)
                           K=KK-FCELL+ILH
                           DO JADD=-1,0
                              DO IADD=-1,0
                                 IVERTCUT = IVERTCUT + 1
                                 VERTS(3*IVERTCUT-2) = REAL(X(I+IADD),FB)
                                 VERTS(3*IVERTCUT-1) = REAL(Y(J+JADD),FB)
                                 VERTS(3*IVERTCUT)   = REAL(Z(K     ),FB)
                              ENDDO
                           ENDDO
                        END SELECT
                        IFACECUT = IFACECUT + 1
                        LOCATIONS(IFACECUT) = 0 + 16
                        FACES(3*IFACECUT-2:3*IFACECUT) = (/ IVERTCUT-3, IVERTCUT-2, IVERTCUT   /) ! Local Nodes 1, 2, 4

                        IFACECUT = IFACECUT + 1
                        LOCATIONS(IFACECUT) = 0 + 16
                        FACES(3*IFACECUT-2:3*IFACECUT) = (/ IVERTCUT  , IVERTCUT-1, IVERTCUT-3 /) ! Local Nodes 4, 3, 1
                     CASE(CC_FTYPE_CFGAS)
                        ICF2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
                        IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
                        X1AXIS  = CUT_FACE(ICF2)%IJK(KAXIS+1); DIR = X1AXIS
                        NVF     = CUT_FACE(ICF2)%CFELEM(1,IFACE2)
                        VERTBEG = IVERTCUT + 1
                        VERTBEG = 3*VERTBEG - 2
                        VERTEND = IVERTCUT + NVF
                        VERTEND = 3*VERTEND
                        DO IVCF=1,NVF
                           IVERTCUT = IVERTCUT + 1
                           IVERTCF=CUT_FACE(ICF2)%CFELEM(IVCF+1,IFACE2)
                           VERTS(3*IVERTCUT-2:3*IVERTCUT) = REAL(CUT_FACE(ICF2)%XYZVERT(1:3,IVERTCF),FB)
                        ENDDO
                        FACEBEG = 3*(IFACECUT+1) - 2
                        FACEEND = FACEBEG + 3*(NVF-2) - 1
                        FACEPTR(1:3*(NVF-2))        =>FACES(FACEBEG:FACEEND)
                        VERTPTR(1:1+VERTEND-VERTBEG)=>VERTS(VERTBEG:VERTEND)
                        VERT_OFFSET = IVERTCUT - NVF
                        ALLOCATE(LOCTYPE(NVF-2))
                        CALL TRIANGULATE(DIR,VERTPTR,NVF,VERT_OFFSET,FACEPTR,LOCTYPE)
                        DO IVCF = 1, NVF-2 ! for now assume face is convex
                           IFACECUT = IFACECUT + 1
                           LOCATIONS(IFACECUT) = 2 + LOCTYPE(IVCF)
                           IF(IFACE2 > CUT_FACE(ICF2)%NFACE) LOCATIONS(IFACECUT) = 1 + LOCTYPE(IVCF) ! Solid side.
                        ENDDO
                        DEALLOCATE(LOCTYPE)
                     CASE(CC_FTYPE_CFINB)
                        ICF2    = CUT_CELL(ICC)%FACE_LIST(4,IFACE)
                        IFACE2  = CUT_CELL(ICC)%FACE_LIST(5,IFACE)
                        NVF     = CUT_FACE(ICF2)%CFELEM(1,IFACE2); DIR = 0
                        VERTBEG = IVERTCUT + 1
                        VERTBEG = 3*VERTBEG - 2
                        VERTEND = IVERTCUT + NVF
                        VERTEND = 3*VERTEND
                        DO IVCF=1,NVF
                           IVERTCUT = IVERTCUT + 1
                           IVERTCF=CUT_FACE(ICF2)%CFELEM(IVCF+1,IFACE2)
                           VERTS(3*IVERTCUT-2:3*IVERTCUT) = REAL(CUT_FACE(ICF2)%XYZVERT(1:3,IVERTCF),FB)
                        ENDDO
                        FACEBEG = 3*(IFACECUT+1) - 2
                        FACEEND = FACEBEG + 3*(NVF-2) - 1
                        FACEPTR(1:3*(NVF-2))        =>FACES(FACEBEG:FACEEND)
                        VERTPTR(1:1+VERTEND-VERTBEG)=>VERTS(VERTBEG:VERTEND)
                        VERT_OFFSET = IVERTCUT - NVF
                        ALLOCATE(LOCTYPE(NVF-2))
                        CALL TRIANGULATE(DIR,VERTPTR,NVF,VERT_OFFSET,FACEPTR,LOCTYPE)
                        DO IVCF = 1, NVF-2 ! for now assume face is convex
                           IFACECUT = IFACECUT + 1
                           LOCATIONS(IFACECUT) = 1 + LOCTYPE(IVCF) ! Consider them as SOLID.
                        ENDDO
                        DEALLOCATE(LOCTYPE)
                     END SELECT
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO
   ENDIF
END SUBROUTINE GET_GEOMINFO_DUP




















SUBROUTINE INITIALIZE_VTKHDF_SLCF_OLD(T,II)
   INTEGER, INTENT(IN) :: II
   INTEGER(HID_T) :: FILE_ID, PLIST_ID, CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: DSET_ID_NCELLS, DSET_ID_NCON, DSET_ID_NPTS    ! Dataset identifiers
   INTEGER :: NPOINTS, NCELLS, IQ, NQT
   INTEGER :: NM, ERROR, ITM, ITM1, NX, NY, NZ, NCONNECTIONS
   TYPE(SLICE_TYPE), POINTER :: SL
   REAL(EB), INTENT(IN) :: T
   REAL(EB) :: TT
   REAL(FB) :: STIME
   CHARACTER(200) :: FILENAME,SLCFNAME
   
   SLCFNAME = TRIM(MESHES(1)%UNIQUE_SLICE_NAMES(II))
   
   STIME = REAL(T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR,FB)
   TT   = T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR
   ITM  = INT(TT)
   ITM1 = NINT(ABS(TT-ITM)*100)
   IF (ITM1==100) THEN
      ITM = ITM+1
      ITM1 = 0
   ENDIF
   WRITE(FILENAME,'(A,A,A,A,I8.8,I2.2,A)') TRIM(RESULTS_DIR)//TRIM(CHID),'_',&
                         TRIM(SLCFNAME),'_',ITM,ITM1,'.vtkhdf'
   
   ! Initialize file
   CALL CREATE_OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfCells"), CRP_LIST, 1,&
      INT8((/NMESHES/)), INT8((/NMESHES/)), DSET_ID_NCELLS, PLIST_ID) ! NumberOfCells
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfPoints"), CRP_LIST, 1,&
      INT8((/NMESHES/)),INT8((/NMESHES/)), DSET_ID_NPTS, PLIST_ID) ! NumberOfPoints
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfConnectivityIds"), CRP_LIST, 1,&
      INT8((/NMESHES/)), INT8((/NMESHES/)), DSET_ID_NCON, PLIST_ID) ! NumberOfConnectivityIds
   
   NQT = MESHES(1)%N_SLCF_VTK
   ! Fill metadata
   MESH_LOOP: DO NM=1,NMESHES
      IF (PROCESS(NM)/=MY_RANK) CYCLE MESH_LOOP
      QUANTITY_LOOP: DO IQ=1,NQT
         IF (MESHES(1)%ALL_SLICE_NAMES(IQ).NE.SLCFNAME) CYCLE QUANTITY_LOOP
         IF (MESHES(NM)%EMPTY_UNIQUE_SLICE(IQ)) THEN
            NCELLS = 0
            NPOINTS = 0
         ELSE
            SL => SLICE(IQ)
            NX = SL%I2 + 1 - SL%I1
            NY = SL%J2 + 1 - SL%J1
            NZ = SL%K2 + 1 - SL%K1
            IF (SL%I2-SL%I1==0 .OR. SL%J2-SL%J1==0 .OR. SL%K2-SL%K1==0) THEN
               NCONNECTIONS=4 ! 2-D slice
            ELSE
               NCONNECTIONS=8 ! 3-D slice
            ENDIF
            NPOINTS = NX*NY*NZ
            NCELLS = MAX((NX-1),1)*MAX((NY-1),1)*MAX((NZ-1),1)
         ENDIF
         ! Write number of cells data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCELLS,&
            PLIST_ID, INT8((/NM-1/)), INT8((/1/)), (/NCELLS/))
         
         ! Write number of points data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NPTS,&
            PLIST_ID, INT8((/NM-1/)), INT8((/1/)), (/NPOINTS/))
         
         ! Write NumberOfConnectivityIds data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCON,&
            PLIST_ID, INT8((/NM-1/)), INT8((/1/)), (/NCELLS*NCONNECTIONS/))
         
         CYCLE MESH_LOOP
      ENDDO QUANTITY_LOOP
   ENDDO MESH_LOOP
   ! Close VTKHDF interface
   CALL MPI_BARRIER(MPI_COMM_WORLD, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCELLS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NPTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCON, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   CALL CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
END SUBROUTINE INITIALIZE_VTKHDF_SLCF_OLD





SUBROUTINE WRITE_VTKHDF_SLICE_DATA_FILE(FILENAME,DATASET,NM,NCELLS,NPOINTS,DATA)
   CHARACTER(*), INTENT(IN) :: FILENAME, DATASET
   INTEGER, INTENT(IN) :: NM
   INTEGER(IB32), DIMENSION(1:NMESHES), INTENT(IN) :: NCELLS, NPOINTS
   REAL(FB), DIMENSION(*), INTENT(IN) :: DATA
   INTEGER(HID_T) :: FILE_ID, PLIST_ID, CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: DSET_ID    ! Dataset identifiers
   INTEGER :: NPOINTS_TOTAL, NCELLS_TOTAL
   INTEGER :: NCELLS_MAX, NPOINTS_MAX
   INTEGER :: ERROR, NMNM
   TYPE (MESH_TYPE), POINTER :: M
   INTEGER(IB32), DIMENSION(1:NMESHES) :: NCELLS_ACCUM, NPOINTS_ACCUM
   
   NPOINTS_TOTAL=0
   NCELLS_TOTAL=0
   NCELLS_ACCUM=0
   NPOINTS_ACCUM=0
   NCELLS_MAX = 0
   NPOINTS_MAX = 0
   
   MESH_LOOP_HDF_COUNT: DO NMNM=1,NMESHES
      NPOINTS_TOTAL = NPOINTS_TOTAL + NPOINTS(NMNM) !+ NVERTS*3
      NCELLS_TOTAL = NCELLS_TOTAL + NCELLS(NMNM) !+ NFACES*3
      NCELLS_MAX = MAX(NCELLS_MAX,NCELLS(NMNM))
      NPOINTS_MAX = MAX(NPOINTS_MAX,NPOINTS(NMNM))
   ENDDO MESH_LOOP_HDF_COUNT
   
   CALL OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   CALL PARALLEL_INIT_F32(GROUP_ID4, DATASET, CRP_LIST, 1,&
      INT8((/NPOINTS_MAX/)),INT8((/NPOINTS_TOTAL/)), DSET_ID, PLIST_ID) ! Data
      
   MESH_LOOP_HDF: DO NMNM=1,NMESHES
      IF (NMNM/=NM) THEN
         NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS(NMNM)
         NCELLS_ACCUM = NCELLS_ACCUM + NCELLS(NMNM)
         CYCLE MESH_LOOP_HDF
      ENDIF
      M => MESHES(NM)
      IF (NCELLS(NM)==0) THEN

      ENDIF
      
      ! Write point data to file
      CALL PARALLEL_WRITE_F32(1, INT8((/NPOINTS(NM)/)), DSET_ID,&
         PLIST_ID, INT8((/NPOINTS_ACCUM/)), INT8((/NPOINTS(NM)/)), DATA)
      
      NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS(NM)
      NCELLS_ACCUM = NCELLS_ACCUM + NCELLS(NM)
   ENDDO MESH_LOOP_HDF
   
   ! Close HDF5 datasets
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)

   CALL MPI_BARRIER(MPI_COMM_WORLD, ERROR)
   
   ! Close VTKHDF interface
   CALL CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
END SUBROUTINE WRITE_VTKHDF_SLICE_DATA_FILE


SUBROUTINE WRITE_VTKHDF_SLICE_CELL_FILE(FILENAME,SLCFNAME,SL3D,NM,NCELLS,NPOINTS,NCONNECTIONS)
   CHARACTER(*), INTENT(IN) :: FILENAME, SLCFNAME
   INTEGER, INTENT(IN) :: NM
   LOGICAL, INTENT(IN) :: SL3D
   INTEGER(HID_T) :: FILE_ID, PLIST_ID, CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: DSET_ID_CON, DSET_ID_NCELLS    ! Dataset identifiers
   INTEGER(HID_T) :: DSET_ID_NPTS, DSET_ID_OFF, DSET_ID_PTS, DSET_ID_TYP       ! Dataset identifiers
   INTEGER :: NPOINTS_TOTAL, NCELLS_TOTAL, NOFFSETS_TOTAL
   INTEGER :: NCONN_TOTAL, NPIECES
   INTEGER :: NCONN_ACCUM, NPIECES_ACCUM
   INTEGER :: NCONN_MAX, NOFFSETS_MAX, NCELLS_MAX, NPOINTS_MAX
   INTEGER :: NMNM, ERROR, NC, NP, IQ, NQT
   TYPE (MESH_TYPE), POINTER :: M
   REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: VERTICES
   INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
   INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
   INTEGER(IB32), DIMENSION(1:NMESHES), INTENT(OUT) :: NCELLS, NPOINTS
   INTEGER(IB32), DIMENSION(1:NMESHES) :: NCELLS_ACCUM, NPOINTS_ACCUM, NOFFSETS_ACCUM
   TYPE(SLICE_TYPE), POINTER :: SL
   INTEGER, INTENT(OUT) :: NCONNECTIONS
   
   CALL OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
   ! Read number of cells
   CALL H5DOPEN_F(GROUP_ID1, "NumberOfCells", DSET_ID_NCELLS, ERROR)
   CALL H5DREAD_F(DSET_ID_NCELLS, H5T_STD_I32LE, NCELLS, INT((/NMESHES/),HSIZE_T), ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCELLS, ERROR)

   ! Read number of points
   CALL H5DOPEN_F(GROUP_ID1, "NumberOfPoints", DSET_ID_NPTS, ERROR)
   CALL H5DREAD_F(DSET_ID_NPTS, H5T_STD_I32LE, NPOINTS, INT((/NMESHES/),HSIZE_T), ERROR)
   CALL H5DCLOSE_F(DSET_ID_NPTS, ERROR)
   
   IF (SL3D) THEN
      NCONNECTIONS=8 ! 3-D slice
   ELSE
      NCONNECTIONS=4 ! 2-D slice
   ENDIF
   
   NPOINTS_TOTAL=0
   NCELLS_TOTAL=0
   NCELLS_ACCUM=0
   NPOINTS_ACCUM=0
   NOFFSETS_TOTAL=0
   NOFFSETS_ACCUM = 0
   NCONN_TOTAL = 0
   NPIECES = 0
   NCONN_ACCUM = 0
   NPIECES_ACCUM = 0
   NCELLS_MAX = 0
   NPOINTS_MAX = 0
   NCONN_MAX = 0
   NOFFSETS_MAX = 0
   
   MESH_LOOP_HDF_COUNT: DO NMNM=1,NMESHES
      NPOINTS_TOTAL = NPOINTS_TOTAL + NPOINTS(NMNM) !+ NVERTS*3
      NCELLS_TOTAL = NCELLS_TOTAL + NCELLS(NMNM) !+ NFACES*3
      NOFFSETS_TOTAL = NOFFSETS_TOTAL + NCELLS(NMNM) + 1
      NCONN_TOTAL = NCONN_TOTAL + NCELLS(NMNM)*NCONNECTIONS
      NPIECES = NPIECES + 1
      NCELLS_MAX = MAX(NCELLS_MAX,NCELLS(NMNM))
      NPOINTS_MAX = MAX(NPOINTS_MAX,NPOINTS(NMNM))
      NOFFSETS_MAX = MAX(NOFFSETS_MAX,NCELLS(NMNM) + 1)
      NCONN_MAX = MAX(NCONN_MAX,NCELLS(NMNM)*NCONNECTIONS)
   ENDDO MESH_LOOP_HDF_COUNT
   
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Connectivity"), CRP_LIST, 1,&
      INT8((/NCONN_MAX/)),INT8((/NCONN_TOTAL/)), DSET_ID_CON, PLIST_ID) ! Connectivity
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Offsets"), CRP_LIST, 1,&
      INT8((/NOFFSETS_MAX/)),INT8((/NOFFSETS_TOTAL/)), DSET_ID_OFF, PLIST_ID) ! Offsets
   CALL PARALLEL_INIT_F32(GROUP_ID1, TRIM("Points"), CRP_LIST, 2,&
      INT8((/3, NPOINTS_MAX/)),INT8((/3, NPOINTS_TOTAL/)), DSET_ID_PTS, PLIST_ID) ! Points
   CALL PARALLEL_INIT_U8(GROUP_ID1, TRIM("Types"), CRP_LIST, 1,&
      INT8((/NCELLS_MAX/)),INT8((/NCELLS_TOTAL/)), DSET_ID_TYP, PLIST_ID) ! Types
   
   NQT = MESHES(1)%N_SLCF_VTK
   MESH_LOOP_HDF: DO NMNM=1,NMESHES
      IF (NMNM/=NM) THEN
         NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS(NMNM)
         NCELLS_ACCUM = NCELLS_ACCUM + NCELLS(NMNM)
         !IF (NCELLS(NMNM) > 0) NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS(NMNM) + 1
         NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS(NMNM) + 1
         NCONN_ACCUM = NCONN_ACCUM + NCELLS(NMNM)*NCONNECTIONS
         NPIECES_ACCUM = NPIECES_ACCUM+1
         CYCLE MESH_LOOP_HDF
      ENDIF
      M => MESHES(NM)
      IF (NCELLS(NM)==0) THEN
         ALLOCATE(VERTICES(3,NCELLS(NM)))
         ALLOCATE(OFFSETS(NCELLS(NM)))
         ALLOCATE(VTKC_TYPE(NCELLS(NM)))
         ALLOCATE(CONNECT(NCELLS(NM)*NCONNECTIONS))
      ELSE
         QUANTITY_LOOPB: DO IQ=1,NQT
            SL => SLICE(IQ)
            IF (TRIM(SL%SLCF_NAME)/=TRIM(SLCFNAME)) CYCLE QUANTITY_LOOPB
            CALL BUILD_VTK_SLICE_GEOMETRY2(NM, SL, NC, NP, VERTICES, CONNECT, OFFSETS, VTKC_TYPE)
            EXIT
         ENDDO QUANTITY_LOOPB
      ENDIF
      
      IF (NCELLS(NM)>0) THEN
         !WRITE(*,*) "RANK ", MY_RANK, " MESH ", NM, " NCONN_ACCUM ", NCONN_ACCUM, " SZ ", NCELLS(NM)*NCONNECTIONS
      ENDIF
      ! Write connectivity data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/NCELLS(NM)*NCONNECTIONS/)), DSET_ID_CON,&
         PLIST_ID, INT8((/NCONN_ACCUM/)), INT8((/NCELLS(NM)*NCONNECTIONS/)), CONNECT)
         
      ! Write offsets data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/NCELLS(NM)+1/)), DSET_ID_OFF,&
         PLIST_ID, INT8((/NOFFSETS_ACCUM/)), INT8((/NCELLS(NM)+1/)), OFFSETS)
      
      ! Write point data to file
      CALL PARALLEL_WRITE_F32(2, INT8((/3, NPOINTS(NM)/)), DSET_ID_PTS,&
         PLIST_ID, INT8((/0,NPOINTS_ACCUM/)), INT8((/3,NPOINTS(NM)/)), VERTICES)
      
      ! Write types data to file
      CALL PARALLEL_WRITE_U8(1, INT8((/NCELLS(NM)/)), DSET_ID_TYP,&
         PLIST_ID, INT8((/NCELLS_ACCUM/)), INT8((/NCELLS(NM)/)), VTKC_TYPE)
      
      DEALLOCATE(VERTICES)
      DEALLOCATE(OFFSETS)
      DEALLOCATE(CONNECT)
      DEALLOCATE(VTKC_TYPE)
      NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS(NM)
      NCELLS_ACCUM = NCELLS_ACCUM + NCELLS(NM)
      !IF (NCELLS(NM)>0) NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS(NM) + 1
      NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS(NM) + 1
      NCONN_ACCUM = NCONN_ACCUM + NCELLS(NM)*NCONNECTIONS
      NPIECES_ACCUM = NPIECES_ACCUM+1
   ENDDO MESH_LOOP_HDF
   
   CALL MPI_BARRIER(MPI_COMM_WORLD, ERROR)
   
   ! Close HDF5 datasets
   CALL H5DCLOSE_F(DSET_ID_CON, ERROR)
   CALL H5DCLOSE_F(DSET_ID_OFF, ERROR)
   CALL H5DCLOSE_F(DSET_ID_PTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_TYP, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)

   CALL MPI_BARRIER(MPI_COMM_WORLD, ERROR)
   
   ! Close VTKHDF interface
   CALL CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
END SUBROUTINE WRITE_VTKHDF_SLICE_CELL_FILE





















SUBROUTINE ADD_1F32_DATA_TO_VTKHDF_USTR_GAS_FILE(FILENAME, DATANAME, DATA)
   CHARACTER(*), INTENT(IN) :: FILENAME, DATANAME
   REAL(FB), DIMENSION(*), INTENT(IN) :: DATA
   INTEGER(HID_T) :: FILE_ID, PLIST_ID, CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: DSET_ID    ! Dataset identifiers
   INTEGER :: NPOINTS_TOTAL, NCELLS_TOTAL, NOFFSETS_TOTAL
   INTEGER :: NPOINTS, NCELLS
   INTEGER :: NCONN_TOTAL, NPIECES
   INTEGER :: NOFFSETS_ACCUM, NCONN_ACCUM, NPIECES_ACCUM, NCELLS_ACCUM, NPOINTS_ACCUM !, NFACES
   INTEGER :: NCONN_MAX, NOFFSETS_MAX, NCELLS_MAX, NPOINTS_MAX
   INTEGER :: NM, ERROR
   !TYPE (MESH_TYPE), POINTER :: M
   !REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: VERTICES
   !INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
   !INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
   
   NPOINTS_TOTAL=0
   NCELLS_TOTAL=0
   NCELLS_ACCUM=0
   NPOINTS_ACCUM=0
   NOFFSETS_TOTAL=0
   NOFFSETS_ACCUM = 0
   NCONN_TOTAL = 0
   NPIECES = 0
   NCONN_ACCUM = 0
   NPIECES_ACCUM = 0
   NCELLS_MAX = 0
   NPOINTS_MAX = 0
   NCONN_MAX = 0
   NOFFSETS_MAX = 0
   
   MESH_LOOP_HDF_COUNT: DO NM=1,NMESHES
      NCELLS = MESHES(NM)%NC
      NPOINTS = MESHES(NM)%NP
      NPOINTS_TOTAL = NPOINTS_TOTAL + NPOINTS !+ NVERTS*3
      NCELLS_TOTAL = NCELLS_TOTAL + NCELLS !+ NFACES*3
      NOFFSETS_TOTAL = NOFFSETS_TOTAL + NCELLS + 1
      NCONN_TOTAL = NCONN_TOTAL + NCELLS*8
      NPIECES = NPIECES + 1
      NCELLS_MAX = MAX(NCELLS_MAX,NCELLS)
      NPOINTS_MAX = MAX(NPOINTS_MAX,NPOINTS)
      NOFFSETS_MAX = MAX(NOFFSETS_MAX,NCELLS + 1)
      NCONN_MAX = MAX(NCONN_MAX,NCELLS*8)
   ENDDO MESH_LOOP_HDF_COUNT
   
   ! Initialize HDF5 datafiles
   CALL OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
   ! Data Quantity
   
   CALL PARALLEL_INIT_F32(GROUP_ID4, TRIM(DATANAME), CRP_LIST, 1,&
      INT8((/NPOINTS_MAX/)),INT8((/NPOINTS_TOTAL/)), DSET_ID, PLIST_ID) ! Color
   
   MESH_LOOP_HDF: DO NM=1,NMESHES
      NCELLS = MESHES(NM)%NC
      NPOINTS = MESHES(NM)%NP
      IF (PROCESS(NM)/=MY_RANK) THEN
         NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
         NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
         NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS + 1
         NCONN_ACCUM = NCONN_ACCUM + NCELLS*8
         NPIECES_ACCUM = NPIECES_ACCUM+1
         CYCLE MESH_LOOP_HDF
      ENDIF
      
      ! Write data to file
      CALL PARALLEL_WRITE_F32(1, INT8((/NPOINTS/)), DSET_ID,&
         PLIST_ID, INT8((/NPOINTS_ACCUM/)), INT8((/NPOINTS/)), DATA)
         
      NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
      NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
      NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS + 1
      NCONN_ACCUM = NCONN_ACCUM + NCELLS*8
      NPIECES_ACCUM = NPIECES_ACCUM+1
   ENDDO MESH_LOOP_HDF
   
   ! Close HDF5 datasets
   CALL H5DCLOSE_F(DSET_ID, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
   ! Close VTKHDF interface
   CALL CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
END SUBROUTINE ADD_1F32_DATA_TO_VTKHDF_USTR_GAS_FILE


SUBROUTINE WRITE_VTKHDF_USTR_GAS_FILE(FILENAME)
   CHARACTER(*), INTENT(IN) :: FILENAME
   INTEGER(HID_T) :: FILE_ID, PLIST_ID, CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: DSET_ID_CON, DSET_ID_NCELLS, DSET_ID_NCON    ! Dataset identifiers
   INTEGER(HID_T) :: DSET_ID_NPTS, DSET_ID_OFF, DSET_ID_PTS, DSET_ID_TYP       ! Dataset identifiers
   INTEGER :: NPOINTS_TOTAL, NCELLS_TOTAL, NOFFSETS_TOTAL
   INTEGER :: NPOINTS, NCELLS
   INTEGER :: NCONN_TOTAL, NPIECES
   INTEGER :: NOFFSETS_ACCUM, NCONN_ACCUM, NPIECES_ACCUM, NCELLS_ACCUM, NPOINTS_ACCUM !, NFACES
   INTEGER :: NCONN_MAX, NOFFSETS_MAX, NCELLS_MAX, NPOINTS_MAX
   INTEGER :: NM, ERROR
   TYPE (MESH_TYPE), POINTER :: M
   REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: VERTICES
   INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
   INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
   
   NPOINTS_TOTAL=0
   NCELLS_TOTAL=0
   NCELLS_ACCUM=0
   NPOINTS_ACCUM=0
   NOFFSETS_TOTAL=0
   NOFFSETS_ACCUM = 0
   NCONN_TOTAL = 0
   NPIECES = 0
   NCONN_ACCUM = 0
   NPIECES_ACCUM = 0
   NCELLS_MAX = 0
   NPOINTS_MAX = 0
   NCONN_MAX = 0
   NOFFSETS_MAX = 0
   
   MESH_LOOP_HDF_COUNT: DO NM=1,NMESHES
      NCELLS = MESHES(NM)%NC
      NPOINTS = MESHES(NM)%NP
      NPOINTS_TOTAL = NPOINTS_TOTAL + NPOINTS !+ NVERTS*3
      NCELLS_TOTAL = NCELLS_TOTAL + NCELLS !+ NFACES*3
      NOFFSETS_TOTAL = NOFFSETS_TOTAL + NCELLS + 1
      NCONN_TOTAL = NCONN_TOTAL + NCELLS*8
      NPIECES = NPIECES + 1
      NCELLS_MAX = MAX(NCELLS_MAX,NCELLS)
      NPOINTS_MAX = MAX(NPOINTS_MAX,NPOINTS)
      NOFFSETS_MAX = MAX(NOFFSETS_MAX,NCELLS + 1)
      NCONN_MAX = MAX(NCONN_MAX,NCELLS*8)
   ENDDO MESH_LOOP_HDF_COUNT
   
   ! Initialize HDF5 datafiles
   CALL CREATE_OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Connectivity"), CRP_LIST, 1,&
      INT8((/NCONN_MAX/)),INT8((/NCONN_TOTAL/)), DSET_ID_CON, PLIST_ID) ! Connectivity
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfCells"), CRP_LIST, 1,&
      INT8((/NPIECES/)), INT8((/NPIECES/)), DSET_ID_NCELLS, PLIST_ID) ! NumberOfCells
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfPoints"), CRP_LIST, 1,&
      INT8((/NPIECES/)),INT8((/NPIECES/)), DSET_ID_NPTS, PLIST_ID) ! NumberOfPoints
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfConnectivityIds"), CRP_LIST, 1,&
      INT8((/NPIECES/)), INT8((/NPIECES/)), DSET_ID_NCON, PLIST_ID) ! NumberOfConnectivityIds
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Offsets"), CRP_LIST, 1,&
      INT8((/NOFFSETS_MAX/)),INT8((/NOFFSETS_TOTAL/)), DSET_ID_OFF, PLIST_ID) ! Offsets
   CALL PARALLEL_INIT_F32(GROUP_ID1, TRIM("Points"), CRP_LIST, 2,&
      INT8((/3, NPOINTS_MAX/)),INT8((/3, NPOINTS_TOTAL/)), DSET_ID_PTS, PLIST_ID) ! Points
   CALL PARALLEL_INIT_U8(GROUP_ID1, TRIM("Types"), CRP_LIST, 1,&
      INT8((/NCELLS_MAX/)),INT8((/NCELLS_TOTAL/)), DSET_ID_TYP, PLIST_ID) ! Types

   MESH_LOOP_HDF: DO NM=1,NMESHES
      NCELLS = MESHES(NM)%NC
      NPOINTS = MESHES(NM)%NP
      IF (PROCESS(NM)/=MY_RANK) THEN
         NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
         NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
         NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS + 1
         NCONN_ACCUM = NCONN_ACCUM + NCELLS*8
         NPIECES_ACCUM = NPIECES_ACCUM+1
         CYCLE MESH_LOOP_HDF
      ENDIF
      M => MESHES(NM)
      CALL BUILD_VTK_GAS_PHASE_GEOMETRY2(NM, NCELLS, NPOINTS, VERTICES, CONNECT, OFFSETS, VTKC_TYPE)
      
      ! Write connectivity data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/NCELLS*8/)), DSET_ID_CON,&
         PLIST_ID, INT8((/NCELLS_ACCUM*8/)), INT8((/NCELLS*8/)), CONNECT)
      
      ! Write number of cells data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCELLS,&
         PLIST_ID, INT8((/NM-1/)), INT8((/1/)), (/NCELLS/))
      
      ! Write number of points data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NPTS,&
         PLIST_ID, INT8((/NM-1/)), INT8((/1/)), (/NPOINTS/))
      
      ! Write NumberOfConnectivityIds data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCON,&
         PLIST_ID, INT8((/NM-1/)), INT8((/1/)), (/NCELLS*8/))
      
      ! Write offsets data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/NCELLS+1/)), DSET_ID_OFF,&
         PLIST_ID, INT8((/NOFFSETS_ACCUM/)), INT8((/NCELLS+1/)), OFFSETS)
      
      ! Write point data to file
      CALL PARALLEL_WRITE_F32(2, INT8((/3, NPOINTS/)), DSET_ID_PTS,&
         PLIST_ID, INT8((/0,NPOINTS_ACCUM/)), INT8((/3,NPOINTS/)), VERTICES)
      
      ! Write types data to file
      CALL PARALLEL_WRITE_U8(1, INT8((/NCELLS/)), DSET_ID_TYP,&
         PLIST_ID, INT8((/NCELLS_ACCUM/)), INT8((/NCELLS/)), VTKC_TYPE)
      
      !DEALLOCATE(COLORS)
      !DEALLOCATE(FACES_OUT)
      DEALLOCATE(VERTICES)
      DEALLOCATE(OFFSETS)
      DEALLOCATE(CONNECT)
      DEALLOCATE(VTKC_TYPE)
      NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
      NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
      NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS + 1
      NCONN_ACCUM = NCONN_ACCUM + NCELLS*8
      NPIECES_ACCUM = NPIECES_ACCUM+1
   ENDDO MESH_LOOP_HDF
   
   ! Close HDF5 datasets
   CALL H5DCLOSE_F(DSET_ID_CON, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCELLS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NPTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCON, ERROR)
   CALL H5DCLOSE_F(DSET_ID_OFF, ERROR)
   CALL H5DCLOSE_F(DSET_ID_PTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_TYP, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
   ! Close VTKHDF interface
   CALL CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   
END SUBROUTINE WRITE_VTKHDF_USTR_GAS_FILE


SUBROUTINE WRITE_VTKHDF_GEOM_FILE_OLD
   ! Parts of this subroutine use content from stack overflow
   ! Original question: https://stackoverflow.com/questions/34144786
   ! User whos answer is integrated: https://stackoverflow.com/users/4621823/chw21
   !character(len=*), parameter :: fname = 'fds.stl'
   INTEGER :: I,IFACT,J,N,NM,FACES(6, 4) !,GEOM_VERTICES_IDS(1,3)
   REAL(FB) :: XB(6)
   !REAL(FB) :: GEOM_VERTICES(3,3)
   INTEGER(IB8) :: COLOR(3) !, ONE
   INTEGER(IB32) :: NFACES,NVERTS !,NFACES_CUTCELLS,NVERTS_CUTCELLS
   REAL(FB), DIMENSION(:,:), ALLOCATABLE :: COLORS
   REAL(FB), DIMENSION(:,:), ALLOCATABLE :: VERTICES
   INTEGER(IB32), DIMENSION(:,:), ALLOCATABLE :: FACES_OUT
   REAL(FB), DIMENSION(:), ALLOCATABLE :: X_PTS, Y_PTS, Z_PTS
   INTEGER(IB32), ALLOCATABLE, DIMENSION(:) :: CONNECT, OFFSETS
   INTEGER(IB8), ALLOCATABLE, DIMENSION(:) :: VTKC_TYPE
   INTEGER :: NPOINTS, NCELLS, NPOINTS_TOTAL, NCELLS_TOTAL, NCELLS_ACCUM, NPOINTS_ACCUM
   INTEGER :: NCONN_TOTAL, NPIECES, NCONN_ACCUM, NPIECES_ACCUM
   INTEGER :: NOFFSETS_TOTAL, NOFFSETS_ACCUM !, NFACES
   INTEGER :: NCONN_MAX, NOFFSETS_MAX, NCELLS_MAX, NPOINTS_MAX
   !TYPE(VTK_FILE)          :: A_VTK_FILE       !< A parallel (partioned) VTK file.
   !TYPE(PVTK_FILE)          :: A_PVTK_FILE       !< A parallel (partioned) VTK file.
   TYPE (MESH_TYPE), POINTER :: M
   TYPE (GEOMETRY_TYPE), POINTER :: G=>NULL()
   TYPE (OBSTRUCTION_TYPE), POINTER :: OB=>NULL()
   INTEGER  :: ERROR                    !< IO Error status.
   CHARACTER(200) :: FILENAME
   !TYPE (SURFACE_TYPE),POINTER :: SF=>NULL()
   !INTEGER(KIND=MPI_INTEGER_KIND) :: MPI_SIZE, MPI_RANK, MPIERROR 
   INTEGER(HID_T) :: FILE_ID, PLIST_ID, CRP_LIST       ! Identifiers
   INTEGER(HID_T) :: GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4 ! Group identifier
   INTEGER(HID_T) :: DSET_ID_CLR, DSET_ID_CON, DSET_ID_NCELLS, DSET_ID_NCON    ! Dataset identifiers
   INTEGER(HID_T) :: DSET_ID_NPTS, DSET_ID_OFF, DSET_ID_PTS, DSET_ID_TYP       ! Dataset identifiers
   INTEGER, DIMENSION(1:N_MPI_PROCESSES) :: MESHES_PER_PROCESS
   INTEGER :: N_WRITTEN=0
   
   COLOR = INT((/0,0,0/),IB8)
   
   FACES(1,:) = (/0,3,4,7/)
   FACES(2,:) = (/1,2,5,6/)
   FACES(3,:) = (/0,1,4,5/)
   FACES(4,:) = (/2,3,6,7/)
   FACES(5,:) = (/0,3,1,2/)
   FACES(6,:) = (/4,7,5,6/)
   
   NPOINTS_TOTAL=0
   NCELLS_TOTAL=0
   NCELLS_ACCUM=0
   NPOINTS_ACCUM=0
   NOFFSETS_TOTAL=0
   NOFFSETS_ACCUM = 0
   NCONN_TOTAL = 0
   NPIECES = 0
   NCONN_ACCUM = 0
   NPIECES_ACCUM = 0
   NCELLS_MAX = 0
   NPOINTS_MAX = 0
   NCONN_MAX = 0
   NOFFSETS_MAX = 0
   NVERTS = 0
   NFACES = 0
   
   DO NM=1,N_MPI_PROCESSES
      MESHES_PER_PROCESS(NM) = 0
   ENDDO
   
   MESH_LOOP_HDF_COUNT: DO NM=1,NMESHES
      NPOINTS_TOTAL = NPOINTS_TOTAL + MESHES(NM)%N_OBST*8 !+ NVERTS*3
      NCELLS_TOTAL = NCELLS_TOTAL + MESHES(NM)%N_OBST*6 !+ NFACES*3
      NOFFSETS_TOTAL = NOFFSETS_TOTAL + MESHES(NM)%N_OBST*6 + 1
      NCONN_TOTAL = NCONN_TOTAL + MESHES(NM)%N_OBST*6*4
      NPOINTS_MAX = MAX(NPOINTS_MAX, MESHES(NM)%N_OBST*8)
      NCELLS_MAX = MAX(NCELLS_MAX, MESHES(NM)%N_OBST*6)
      NCONN_MAX = MAX(NCONN_MAX, MESHES(NM)%N_OBST*6*4)
      NOFFSETS_MAX = MAX(NOFFSETS_MAX, MESHES(NM)%N_OBST*6+1)
      NPIECES = NPIECES + 1
      MESHES_PER_PROCESS(PROCESS(NM)+1) = MESHES_PER_PROCESS(PROCESS(NM)+1) + 1
   ENDDO MESH_LOOP_HDF_COUNT
   DO I= 1,N_GEOMETRY
      G=>GEOMETRY(I)
      NPOINTS_TOTAL = NPOINTS_TOTAL + NVERTS
      NCELLS_TOTAL = NCELLS_TOTAL + NFACES
      NOFFSETS_TOTAL = NOFFSETS_TOTAL + NFACES + 1
      NCONN_TOTAL = NCONN_TOTAL + NFACES*3
      NPIECES = NPIECES + 1
   ENDDO
   ! Initialize HDF5 datafiles
   WRITE(FILENAME,'(A,A,A)') "",TRIM(CHID),'_GEOM.vtkhdf'
   CALL CREATE_OPEN_VTKHDF(FILENAME, FILE_ID, PLIST_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   CALL PARALLEL_INIT_F32(GROUP_ID2, TRIM("Color"), CRP_LIST, 2,&
      INT8((/3, NCELLS_MAX/)),INT8((/3, NCELLS_TOTAL/)), DSET_ID_CLR, PLIST_ID) ! Color
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Connectivity"), CRP_LIST, 1,&
      INT8((/NCONN_MAX/)),INT8((/NCONN_TOTAL/)), DSET_ID_CON, PLIST_ID) ! Connectivity
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfCells"), CRP_LIST, 1,&
      INT8((/NPIECES/)),INT8((/NPIECES/)), DSET_ID_NCELLS, PLIST_ID) ! NumberOfCells
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfPoints"), CRP_LIST, 1,&
      INT8((/NPIECES/)),INT8((/NPIECES/)), DSET_ID_NPTS, PLIST_ID) ! NumberOfPoints
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("NumberOfConnectivityIds"), CRP_LIST, 1,&
      INT8((/NPIECES/)),INT8((/NPIECES/)), DSET_ID_NCON, PLIST_ID) ! NumberOfConnectivityIds
   CALL PARALLEL_INIT_I32(GROUP_ID1, TRIM("Offsets"), CRP_LIST, 1,&
      INT8((/NOFFSETS_MAX/)),INT8((/NOFFSETS_TOTAL/)), DSET_ID_OFF, PLIST_ID) ! Offsets
   CALL PARALLEL_INIT_F32(GROUP_ID1, TRIM("Points"), CRP_LIST, 2,&
      INT8((/3, NPOINTS_MAX/)),INT8((/3, NPOINTS_TOTAL/)), DSET_ID_PTS, PLIST_ID) ! Points
   CALL PARALLEL_INIT_U8(GROUP_ID1, TRIM("Types"), CRP_LIST, 1,&
      INT8((/NCELLS_MAX/)),INT8((/NCELLS_TOTAL/)), DSET_ID_TYP, PLIST_ID) ! Types
   
   MESH_LOOP_HDF: DO NM=1,NMESHES
      M => MESHES(NM)
      NPOINTS = M%N_OBST*8
      NCELLS = M%N_OBST*6
      IF (PROCESS(NM)/=MY_RANK) THEN
         NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
         NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
         NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS + 1
         NCONN_ACCUM = NCONN_ACCUM + NCELLS*4
         NPIECES_ACCUM = NPIECES_ACCUM+1
         CYCLE MESH_LOOP_HDF
      ENDIF
      N_WRITTEN = N_WRITTEN+1
      !M => MESHES(NM)
      ! Output OBST geometry data
      NPOINTS = M%N_OBST*8
      NCELLS = M%N_OBST*6
      ALLOCATE(COLORS(3,NCELLS))
      ALLOCATE(FACES_OUT(NCELLS,4))
      ALLOCATE(VERTICES(3,NPOINTS))
      ALLOCATE(OFFSETS(NCELLS+1))
      ALLOCATE(CONNECT(NCELLS*4))
      ALLOCATE(VTKC_TYPE(NCELLS))
      DO N=1,M%N_OBST
         OB=>M%OBSTRUCTION(N)
         XB(:) = REAL((/OB%X1,OB%X2,OB%Y1,OB%Y2,OB%Z1,OB%Z2/),FB)
         IF (OB%RGB(1)==-1) THEN
            COLORS(1:3,(N-1)*6+1) = REAL(SURFACE(OB%SURF_INDEX(-1))%RGB,FB)/255._FB
            COLORS(1:3,(N-1)*6+2) = REAL(SURFACE(OB%SURF_INDEX(1))%RGB,FB)/255._FB
            COLORS(1:3,(N-1)*6+3) = REAL(SURFACE(OB%SURF_INDEX(-2))%RGB,FB)/255._FB
            COLORS(1:3,(N-1)*6+4) = REAL(SURFACE(OB%SURF_INDEX(2))%RGB,FB)/255._FB
            COLORS(1:3,(N-1)*6+5) = REAL(SURFACE(OB%SURF_INDEX(-3))%RGB,FB)/255._FB
            COLORS(1:3,(N-1)*6+6) = REAL(SURFACE(OB%SURF_INDEX(3))%RGB,FB)/255._FB
         ELSE
            COLORS(1:3,(N-1)*6+1) = REAL(OB%RGB,FB)/255._FB
            COLORS(1:3,(N-1)*6+2) = REAL(OB%RGB,FB)/255._FB
            COLORS(1:3,(N-1)*6+3) = REAL(OB%RGB,FB)/255._FB
            COLORS(1:3,(N-1)*6+4) = REAL(OB%RGB,FB)/255._FB
            COLORS(1:3,(N-1)*6+5) = REAL(OB%RGB,FB)/255._FB
            COLORS(1:3,(N-1)*6+6) = REAL(OB%RGB,FB)/255._FB
         ENDIF
         VERTICES(1:3,(N-1)*8+1:N*8) = TRANSPOSE(GET_VERTICES(XB))
         FACES_OUT((N-1)*6+1:N*6,1:4) = FACES + (N-1)*8
      END DO
      IFACT = 0
      DO I = 1, NCELLS
         DO J = 1, 4
            CONNECT((IFACT)*4+J) = FACES_OUT(I, J)
         ENDDO
         IFACT = IFACT+1
      ENDDO
      
      OFFSETS(1) = 0
      DO I=1,NCELLS
         OFFSETS(I+1) = (I)*4_IB32
         VTKC_TYPE(I) = 8_IB8
      ENDDO
      
      ! Write color data to file
      CALL PARALLEL_WRITE_F32(2, INT8((/3, NCELLS/)), DSET_ID_CLR,&
         PLIST_ID, INT8((/0,NCELLS_ACCUM/)), INT8((/3,NCELLS/)), COLORS)
      
      ! Write connectivity data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/NCELLS*4/)), DSET_ID_CON,&
         PLIST_ID, INT8((/NCELLS_ACCUM*4/)), INT8((/NCELLS*4/)), CONNECT)
      
      ! Write number of cells data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCELLS,&
         PLIST_ID, INT8((/NM-1/)), INT8((/1/)), (/NCELLS/))
      
      ! Write number of points data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NPTS,&
         PLIST_ID, INT8((/NM-1/)), INT8((/1/)), (/NPOINTS/))
      
      ! Write NumberOfConnectivityIds data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/1/)), DSET_ID_NCON,&
         PLIST_ID, INT8((/NM-1/)), INT8((/1/)), (/NCELLS*4/))
      
      ! Write offsets data to file
      CALL PARALLEL_WRITE_I32(1, INT8((/NCELLS+1/)), DSET_ID_OFF,&
         PLIST_ID, INT8((/NOFFSETS_ACCUM/)), INT8((/NCELLS+1/)), OFFSETS)
      
      ! Write point data to file
      CALL PARALLEL_WRITE_F32(2, INT8((/3, NPOINTS/)), DSET_ID_PTS,&
         PLIST_ID, INT8((/0,NPOINTS_ACCUM/)), INT8((/3,NPOINTS/)), VERTICES)
      
      ! Write types data to file
      CALL PARALLEL_WRITE_U8(1, INT8((/NCELLS/)), DSET_ID_TYP,&
         PLIST_ID, INT8((/NCELLS_ACCUM/)), INT8((/NCELLS/)), VTKC_TYPE)
      
      DEALLOCATE(COLORS)
      DEALLOCATE(FACES_OUT)
      DEALLOCATE(VERTICES)
      DEALLOCATE(OFFSETS)
      DEALLOCATE(CONNECT)
      DEALLOCATE(VTKC_TYPE)
      NPOINTS_ACCUM = NPOINTS_ACCUM + NPOINTS
      NCELLS_ACCUM = NCELLS_ACCUM + NCELLS
      NOFFSETS_ACCUM = NOFFSETS_ACCUM + NCELLS + 1
      NCONN_ACCUM = NCONN_ACCUM + NCELLS*4
      NPIECES_ACCUM = NPIECES_ACCUM+1
   ENDDO MESH_LOOP_HDF
   
   ! Write fake data in processes that have less meshes than max process
   DO NM=1,MAXVAL(MESHES_PER_PROCESS)
      IF (N_WRITTEN < MAXVAL(MESHES_PER_PROCESS)) THEN
         ALLOCATE(COLORS(3,0))
         ALLOCATE(CONNECT(0))
         ALLOCATE(OFFSETS(0))
         ALLOCATE(VERTICES(3,0))
         ALLOCATE(VTKC_TYPE(0))
         ! Write color data to file
         CALL PARALLEL_WRITE_F32(2, INT8((/3, 0/)), DSET_ID_CLR,&
            PLIST_ID, INT8((/0,0/)), INT8((/3,0/)), COLORS)
         
         ! Write connectivity data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_CON,&
            PLIST_ID, INT8((/0/)), INT8((/0/)), CONNECT)
         
         ! Write number of cells data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_NCELLS,&
            PLIST_ID, INT8((/0/)), INT8((/0/)), (/0/))
         
         ! Write number of points data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_NPTS,&
            PLIST_ID, INT8((/0/)), INT8((/0/)), (/0/))
         
         ! Write NumberOfConnectivityIds data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_NCON,&
            PLIST_ID, INT8((/0/)), INT8((/0/)), (/0/))
         
         ! Write offsets data to file
         CALL PARALLEL_WRITE_I32(1, INT8((/0/)), DSET_ID_OFF,&
            PLIST_ID, INT8((/0/)), INT8((/0/)), OFFSETS)
         
         ! Write point data to file
         CALL PARALLEL_WRITE_F32(2, INT8((/3, 0/)), DSET_ID_PTS,&
            PLIST_ID, INT8((/0,0/)), INT8((/3,0/)), VERTICES)
         
         ! Write types data to file
         CALL PARALLEL_WRITE_U8(1, INT8((/0/)), DSET_ID_TYP,&
            PLIST_ID, INT8((/0/)), INT8((/0/)), VTKC_TYPE)
         DEALLOCATE(COLORS)
         DEALLOCATE(VERTICES)
         DEALLOCATE(OFFSETS)
         DEALLOCATE(CONNECT)
         DEALLOCATE(VTKC_TYPE)
         N_WRITTEN = N_WRITTEN + 1
      ENDIF
   ENDDO
   
   ! Close HDF5 datasets
   CALL H5DCLOSE_F(DSET_ID_CLR, ERROR)
   CALL H5DCLOSE_F(DSET_ID_CON, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCELLS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NPTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_NCON, ERROR)
   CALL H5DCLOSE_F(DSET_ID_OFF, ERROR)
   CALL H5DCLOSE_F(DSET_ID_PTS, ERROR)
   CALL H5DCLOSE_F(DSET_ID_TYP, ERROR)
   CALL H5PCLOSE_F(PLIST_ID, ERROR)
   
   ! Close VTKHDF interface
   CALL CLOSE_VTKHDF(FILE_ID, GROUP_ID1,GROUP_ID2,GROUP_ID3,GROUP_ID4)
   ! Output GEOM geometry data
   IF ((N_GEOMETRY > 0).AND.(MY_RANK==0)) THEN
      NFACES = 0
      NVERTS = 0
      DO I= 1,N_GEOMETRY
         G=>GEOMETRY(I)
         NFACES = NFACES + G%N_FACES
         NVERTS = NVERTS + G%N_VERTS
         
         ALLOCATE(X_PTS(G%N_VERTS))
         ALLOCATE(Y_PTS(G%N_VERTS))
         ALLOCATE(Z_PTS(G%N_VERTS))
         ALLOCATE(OFFSETS(G%N_FACES))
         ALLOCATE(CONNECT(G%N_FACES*3))
         ALLOCATE(VTKC_TYPE(G%N_FACES))
         DO J=1,G%N_VERTS
            X_PTS(J) = REAL(G%VERTS((J-1)*3+1),FB)
            Y_PTS(J) = REAL(G%VERTS((J-1)*3+2),FB)
            Z_PTS(J) = REAL(G%VERTS((J-1)*3+3),FB)
         ENDDO

         DO J=1,G%N_FACES
            OFFSETS(J) = (J)*3_IB32
            VTKC_TYPE(J) = 5_IB8
            CONNECT(3*(J-1)+1) = G%FACES(3*(J-1)+1)-1
            CONNECT(3*(J-1)+2) = G%FACES(3*(J-1)+2)-1
            CONNECT(3*(J-1)+3) = G%FACES(3*(J-1)+3)-1
         ENDDO
         
         ALLOCATE(COLORS(NFACES,3))
         DO J= 1,G%N_FACES
            IF (G%RGB(1)==-1) THEN
               COLORS(J,1:3) = REAL(SURFACE(G%SURFS(J))%RGB,FB)/255._FB
            ELSE
               COLORS(J,1:3) = REAL(G%RGB,FB)/255._FB
            ENDIF
         ENDDO
         
         CALL DEALLOCATE_VTK_GAS_PHASE_GEOMETRY(X_PTS,Y_PTS,Z_PTS,OFFSETS,VTKC_TYPE,CONNECT)
         DEALLOCATE(COLORS)
      ENDDO
   ENDIF


CONTAINS

   FUNCTION GET_VERTICES(XB)
      REAL(FB), INTENT(IN) :: XB(6)
      REAL(FB) :: GET_VERTICES(8,3)
      GET_VERTICES(1,:) = (/XB(1),XB(3),XB(5)/)
      GET_VERTICES(2,:) = (/XB(2),XB(3),XB(5)/)
      GET_VERTICES(3,:) = (/XB(2),XB(4),XB(5)/)
      GET_VERTICES(4,:) = (/XB(1),XB(4),XB(5)/)
      GET_VERTICES(5,:) = (/XB(1),XB(3),XB(6)/)
      GET_VERTICES(6,:) = (/XB(2),XB(3),XB(6)/)
      GET_VERTICES(7,:) = (/XB(2),XB(4),XB(6)/)
      GET_VERTICES(8,:) = (/XB(1),XB(4),XB(6)/)
   END FUNCTION GET_VERTICES

END SUBROUTINE WRITE_VTKHDF_GEOM_FILE_OLD

SUBROUTINE PARALLEL_INIT_F32(GROUP_ID, SNAME, CRP_LIST, RANK, DDIM, CDIM, DSET_ID, PLIST_ID)
   INTEGER(HID_T), INTENT(IN) :: GROUP_ID               ! Memory identifiers
   INTEGER(HID_T), INTENT(INOUT) :: CRP_LIST, PLIST_ID  ! Memory identifiers
   INTEGER, INTENT(IN)     ::   RANK    ! Dataset rank
   INTEGER(HSIZE_T), DIMENSION(*), INTENT(IN) :: CDIM, DDIM
   CHARACTER(LEN=*), INTENT(IN) :: SNAME
   INTEGER(HID_T), INTENT(OUT) :: DSET_ID  ! Memory identifiers
   INTEGER(HID_T) :: DATASPACE
   INTEGER     ::   ERROR ! Error flag
   LOGICAL :: LINK_EXISTS
   CALL H5LEXISTS_F(GROUP_ID, SNAME, LINK_EXISTS, ERROR)
   IF (.NOT.LINK_EXISTS) THEN
      CALL H5SCREATE_SIMPLE_F(RANK, CDIM, DATASPACE, ERROR, CDIM)
      CALL H5PCREATE_F(H5P_DATASET_CREATE_F, CRP_LIST, ERROR)
      CALL H5PSET_DEFLATE_F(CRP_LIST, 9, ERROR)
      CALL H5PSET_CHUNK_F(CRP_LIST, RANK, DDIM, ERROR)
      CALL H5DCREATE_F(GROUP_ID, SNAME, H5T_IEEE_F32LE, DATASPACE, DSET_ID, ERROR, CRP_LIST)
      CALL H5PCREATE_F(H5P_DATASET_XFER_F, PLIST_ID, ERROR)
      CALL H5PSET_DXPL_MPIO_F(PLIST_ID, H5FD_MPIO_COLLECTIVE_F, ERROR)
      CALL H5SCLOSE_F(DATASPACE, ERROR)
   ELSE
      CALL H5DOPEN_F(GROUP_ID, SNAME, DSET_ID, ERROR)
      CALL H5PCREATE_F(H5P_DATASET_XFER_F, PLIST_ID, ERROR)
      CALL H5PSET_DXPL_MPIO_F(PLIST_ID, H5FD_MPIO_COLLECTIVE_F, ERROR)
   ENDIF
END SUBROUTINE PARALLEL_INIT_F32

SUBROUTINE PARALLEL_INIT_I32(GROUP_ID, SNAME, CRP_LIST, RANK, DDIM, CDIM, DSET_ID, PLIST_ID)
   INTEGER(HID_T), INTENT(IN) :: GROUP_ID               ! Memory identifiers
   INTEGER(HID_T), INTENT(INOUT) :: CRP_LIST, PLIST_ID  ! Memory identifiers
   INTEGER, INTENT(IN)     ::   RANK    ! Dataset rank
   INTEGER(HSIZE_T), DIMENSION(*), INTENT(IN) :: CDIM, DDIM
   CHARACTER(LEN=*), INTENT(IN) :: SNAME
   INTEGER(HID_T), INTENT(OUT) :: DSET_ID  ! Memory identifiers
   INTEGER(HID_T) :: DATASPACE
   INTEGER     ::   ERROR ! Error flag
   LOGICAL :: LINK_EXISTS
   CALL H5LEXISTS_F(GROUP_ID, SNAME, LINK_EXISTS, ERROR)
   IF (.NOT.LINK_EXISTS) THEN
      CALL H5SCREATE_SIMPLE_F(RANK, CDIM, DATASPACE, ERROR, CDIM)
      CALL H5PCREATE_F(H5P_DATASET_CREATE_F, CRP_LIST, ERROR)
      CALL H5PSET_DEFLATE_F(CRP_LIST, 9, ERROR)
      CALL H5PSET_CHUNK_F(CRP_LIST, RANK, DDIM, ERROR)
      CALL H5DCREATE_F(GROUP_ID, SNAME, H5T_STD_I32LE, DATASPACE, DSET_ID, ERROR, CRP_LIST)
      CALL H5PCREATE_F(H5P_DATASET_XFER_F, PLIST_ID, ERROR)
      CALL H5PSET_DXPL_MPIO_F(PLIST_ID, H5FD_MPIO_COLLECTIVE_F, ERROR)
      CALL H5SCLOSE_F(DATASPACE, ERROR)
   ELSE
      CALL H5DOPEN_F(GROUP_ID, SNAME, DSET_ID, ERROR)
      CALL H5PCREATE_F(H5P_DATASET_XFER_F, PLIST_ID, ERROR)
      CALL H5PSET_DXPL_MPIO_F(PLIST_ID, H5FD_MPIO_COLLECTIVE_F, ERROR)
   ENDIF
END SUBROUTINE PARALLEL_INIT_I32

SUBROUTINE PARALLEL_INIT_I8(GROUP_ID, SNAME, CRP_LIST, RANK, DDIM, CDIM, DSET_ID, PLIST_ID)
   INTEGER(HID_T), INTENT(IN) :: GROUP_ID               ! Memory identifiers
   INTEGER(HID_T), INTENT(INOUT) :: CRP_LIST, PLIST_ID  ! Memory identifiers
   INTEGER, INTENT(IN)     ::   RANK    ! Dataset rank
   INTEGER(HSIZE_T), DIMENSION(*), INTENT(IN) :: CDIM, DDIM
   CHARACTER(LEN=*), INTENT(IN) :: SNAME
   INTEGER(HID_T), INTENT(OUT) :: DSET_ID  ! Memory identifiers
   INTEGER(HID_T) :: DATASPACE
   INTEGER     ::   ERROR ! Error flag
   LOGICAL :: LINK_EXISTS
   CALL H5LEXISTS_F(GROUP_ID, SNAME, LINK_EXISTS, ERROR)
   IF (.NOT.LINK_EXISTS) THEN
      CALL H5SCREATE_SIMPLE_F(RANK, CDIM, DATASPACE, ERROR, CDIM)
      CALL H5PCREATE_F(H5P_DATASET_CREATE_F, CRP_LIST, ERROR)
      CALL H5PSET_DEFLATE_F(CRP_LIST, 9, ERROR)
      CALL H5PSET_CHUNK_F(CRP_LIST, RANK, DDIM, ERROR)
      CALL H5DCREATE_F(GROUP_ID, SNAME, H5T_STD_I8LE, DATASPACE, DSET_ID, ERROR, CRP_LIST)
      CALL H5PCREATE_F(H5P_DATASET_XFER_F, PLIST_ID, ERROR)
      CALL H5PSET_DXPL_MPIO_F(PLIST_ID, H5FD_MPIO_COLLECTIVE_F, ERROR)
      CALL H5SCLOSE_F(DATASPACE, ERROR)
   ELSE 
      CALL H5DOPEN_F(GROUP_ID, SNAME, DSET_ID, ERROR)
      CALL H5PCREATE_F(H5P_DATASET_XFER_F, PLIST_ID, ERROR)
      CALL H5PSET_DXPL_MPIO_F(PLIST_ID, H5FD_MPIO_COLLECTIVE_F, ERROR)
   ENDIF
END SUBROUTINE PARALLEL_INIT_I8

SUBROUTINE PARALLEL_INIT_U8(GROUP_ID, SNAME, CRP_LIST, RANK, DDIM, CDIM, DSET_ID, PLIST_ID)
   INTEGER(HID_T), INTENT(IN) :: GROUP_ID               ! Memory identifiers
   INTEGER(HID_T), INTENT(INOUT) :: CRP_LIST, PLIST_ID  ! Memory identifiers
   INTEGER, INTENT(IN)     ::   RANK    ! Dataset rank
   INTEGER(HSIZE_T), DIMENSION(*), INTENT(IN) :: CDIM, DDIM
   CHARACTER(LEN=*), INTENT(IN) :: SNAME
   INTEGER(HID_T), INTENT(OUT) :: DSET_ID  ! Memory identifiers
   INTEGER(HID_T) :: DATASPACE
   INTEGER     ::   ERROR ! Error flag
   LOGICAL :: LINK_EXISTS
   CALL H5LEXISTS_F(GROUP_ID, SNAME, LINK_EXISTS, ERROR)
   IF (.NOT.LINK_EXISTS) THEN
      CALL H5SCREATE_SIMPLE_F(RANK, CDIM, DATASPACE, ERROR, CDIM)
      CALL H5PCREATE_F(H5P_DATASET_CREATE_F, CRP_LIST, ERROR)
      CALL H5PSET_DEFLATE_F(CRP_LIST, 9, ERROR)
      CALL H5PSET_CHUNK_F(CRP_LIST, RANK, DDIM, ERROR)
      CALL H5DCREATE_F(GROUP_ID, SNAME, H5T_STD_U8LE, DATASPACE, DSET_ID, ERROR, CRP_LIST)
      CALL H5PCREATE_F(H5P_DATASET_XFER_F, PLIST_ID, ERROR)
      CALL H5PSET_DXPL_MPIO_F(PLIST_ID, H5FD_MPIO_COLLECTIVE_F, ERROR)
      CALL H5SCLOSE_F(DATASPACE, ERROR)
   ELSE 
      CALL H5DOPEN_F(GROUP_ID, SNAME, DSET_ID, ERROR)
      CALL H5PCREATE_F(H5P_DATASET_XFER_F, PLIST_ID, ERROR)
      CALL H5PSET_DXPL_MPIO_F(PLIST_ID, H5FD_MPIO_COLLECTIVE_F, ERROR)
   ENDIF
END SUBROUTINE PARALLEL_INIT_U8

SUBROUTINE PARALLEL_WRITE_F32(RANK, CDIM, DSET_ID,&
   PLIST_ID, OFFSET, COUNT, DATA)
   INTEGER(HID_T), INTENT(IN) :: DSET_ID, PLIST_ID  ! Memory identifiers
   INTEGER, INTENT(IN)     ::   RANK    ! Dataset rank
   INTEGER(HSIZE_T), DIMENSION(*), INTENT(IN) :: CDIM, OFFSET, COUNT ! Attribute dimension
   REAL(FB), DIMENSION(*), INTENT(IN) :: DATA
   INTEGER     ::   ERROR ! Error flag
   INTEGER(HID_T) :: MEMSPACE, DATASPACE
   
   CALL H5SCREATE_SIMPLE_F (RANK, CDIM, MEMSPACE, ERROR)
   CALL H5DGET_SPACE_F(DSET_ID, DATASPACE, ERROR)
   CALL H5SSELECT_HYPERSLAB_F(DATASPACE, H5S_SELECT_SET_F, OFFSET, COUNT, ERROR)
   CALL H5DWRITE_F(DSET_ID, H5T_IEEE_F32LE, DATA, CDIM, ERROR, &
        MEM_SPACE_ID = MEMSPACE, FILE_SPACE_ID = DATASPACE, XFER_PRP = PLIST_ID)
   CALL H5SCLOSE_F(MEMSPACE, ERROR)
   CALL H5SCLOSE_F(DATASPACE, ERROR)
END SUBROUTINE PARALLEL_WRITE_F32

SUBROUTINE PARALLEL_WRITE_I32(RANK, CDIM, DSET_ID,&
   PLIST_ID, OFFSET, COUNT, DATA)
   INTEGER(HID_T), INTENT(IN) :: DSET_ID, PLIST_ID  ! Memory identifiers
   INTEGER, INTENT(IN)     ::   RANK    ! Dataset rank
   INTEGER(HSIZE_T), DIMENSION(*), INTENT(IN) :: CDIM, OFFSET, COUNT ! Attribute dimension
   INTEGER(IB32), DIMENSION(*), INTENT(IN) :: DATA
   INTEGER     ::   ERROR ! Error flag
   INTEGER(HID_T) :: MEMSPACE, DATASPACE
   
   CALL H5SCREATE_SIMPLE_F (RANK, CDIM, MEMSPACE, ERROR)
   CALL H5DGET_SPACE_F(DSET_ID, DATASPACE, ERROR)
   CALL H5SSELECT_HYPERSLAB_F(DATASPACE, H5S_SELECT_SET_F, OFFSET, COUNT, ERROR)
   CALL H5DWRITE_F(DSET_ID, H5T_STD_I32LE, DATA, CDIM, ERROR, &
        MEM_SPACE_ID = MEMSPACE, FILE_SPACE_ID = DATASPACE, XFER_PRP = PLIST_ID)
   CALL H5SCLOSE_F(MEMSPACE, ERROR)
   CALL H5SCLOSE_F(DATASPACE, ERROR)
END SUBROUTINE PARALLEL_WRITE_I32

SUBROUTINE PARALLEL_WRITE_I8(RANK, CDIM, DSET_ID,&
   PLIST_ID, OFFSET, COUNT, DATA)
   INTEGER(HID_T), INTENT(IN) :: DSET_ID, PLIST_ID  ! Memory identifiers
   INTEGER, INTENT(IN)     ::   RANK    ! Dataset rank
   INTEGER(HSIZE_T), DIMENSION(*), INTENT(IN) :: CDIM, OFFSET, COUNT ! Attribute dimension
   INTEGER(IB8), DIMENSION(*), INTENT(IN) :: DATA
   INTEGER     ::   ERROR ! Error flag
   INTEGER(HID_T) :: MEMSPACE, DATASPACE
   
   CALL H5SCREATE_SIMPLE_F (RANK, CDIM, MEMSPACE, ERROR)
   CALL H5DGET_SPACE_F(DSET_ID, DATASPACE, ERROR)
   CALL H5SSELECT_HYPERSLAB_F(DATASPACE, H5S_SELECT_SET_F, OFFSET, COUNT, ERROR)
   CALL H5DWRITE_F(DSET_ID, H5T_STD_I8LE, DATA, CDIM, ERROR, &
        MEM_SPACE_ID = MEMSPACE, FILE_SPACE_ID = DATASPACE, XFER_PRP = PLIST_ID)
   CALL H5SCLOSE_F(MEMSPACE, ERROR)
   CALL H5SCLOSE_F(DATASPACE, ERROR)
END SUBROUTINE PARALLEL_WRITE_I8

SUBROUTINE PARALLEL_WRITE_U8(RANK, CDIM, DSET_ID,&
   PLIST_ID, OFFSET, COUNT, DATA)
   INTEGER(HID_T), INTENT(IN) :: DSET_ID, PLIST_ID  ! Memory identifiers
   INTEGER, INTENT(IN)     ::   RANK    ! Dataset rank
   INTEGER(HSIZE_T), DIMENSION(*), INTENT(IN) :: CDIM, OFFSET, COUNT ! Attribute dimension
   INTEGER(IB8), DIMENSION(*), INTENT(IN) :: DATA
   INTEGER     ::   ERROR ! Error flag
   INTEGER(HID_T) :: MEMSPACE, DATASPACE
   
   CALL H5SCREATE_SIMPLE_F (RANK, CDIM, MEMSPACE, ERROR)
   CALL H5DGET_SPACE_F(DSET_ID, DATASPACE, ERROR)
   CALL H5SSELECT_HYPERSLAB_F(DATASPACE, H5S_SELECT_SET_F, OFFSET, COUNT, ERROR)
   CALL H5DWRITE_F(DSET_ID, H5T_STD_U8LE, DATA, CDIM, ERROR, &
        MEM_SPACE_ID = MEMSPACE, FILE_SPACE_ID = DATASPACE, XFER_PRP = PLIST_ID)
   CALL H5SCLOSE_F(MEMSPACE, ERROR)
   CALL H5SCLOSE_F(DATASPACE, ERROR)
END SUBROUTINE PARALLEL_WRITE_U8

SUBROUTINE ADD_VERSION(GROUP_ID,ADIMS,ARANK,ANAME,ATTR_DATA)
   INTEGER(HID_T) :: ATTR_ID, ASPACE_ID, GROUP_ID             ! Identifiers
   INTEGER(HSIZE_T), DIMENSION(1), INTENT(IN) :: ADIMS        ! Attribute dimension
   INTEGER, INTENT(IN)     ::   ARANK                         ! Attribute rank
   INTEGER :: ERROR                                           ! Error flag
   CHARACTER(LEN=*), INTENT(IN) :: ANAME                      ! Attribute name
   INTEGER(HSIZE_T), DIMENSION(:), INTENT(IN) :: ATTR_DATA(:) ! Attribute data
   
   CALL H5SCREATE_SIMPLE_F(ARANK, ADIMS, ASPACE_ID, ERROR)
   CALL H5ACREATE_F(GROUP_ID, TRIM(ANAME), H5T_STD_I32LE, ASPACE_ID, ATTR_ID, ERROR)
   CALL H5AWRITE_F(ATTR_ID, H5T_STD_I32LE, ATTR_DATA, ADIMS, ERROR)
   CALL H5ACLOSE_F(ATTR_ID, ERROR)
   CALL H5SCLOSE_F(ASPACE_ID, ERROR)
END SUBROUTINE ADD_VERSION

SUBROUTINE ADD_TYPE(GROUP_ID,DATA_DIMS,ANAME,ATTR_DATA,ALEN)
   INTEGER(HID_T) :: ATTR_ID, ASPACE_ID, GROUP_ID, ATYPE_ID   ! Identifiers
   INTEGER(HSIZE_T), DIMENSION(1), INTENT(IN) :: DATA_DIMS    ! Attribute dimension
   INTEGER(SIZE_T), INTENT(IN) :: ALEN     ! Length of the attribute string
   INTEGER     ::   ERROR                                     ! Error flag
   CHARACTER(LEN=*), INTENT(IN) :: ANAME
   CHARACTER(LEN=*), INTENT(IN) :: ATTR_DATA
   
   CALL H5SCREATE_F(H5S_SCALAR_F, ASPACE_ID, ERROR)
   CALL H5TCOPY_F(H5T_NATIVE_CHARACTER, ATYPE_ID, ERROR)
   CALL H5TSET_SIZE_F(ATYPE_ID, ALEN, ERROR)
   CALL H5TSET_STRPAD_F(ATYPE_ID, H5T_STR_NULLPAD_F, ERROR)
   CALL H5ACREATE_F(GROUP_ID, TRIM(ANAME), ATYPE_ID, ASPACE_ID, ATTR_ID, ERROR)
   CALL H5AWRITE_F(ATTR_ID, ATYPE_ID, ATTR_DATA, DATA_DIMS, ERROR)
   CALL H5ACLOSE_F(ATTR_ID, ERROR)
   CALL H5TCLOSE_F(ATYPE_ID, ERROR)
   CALL H5SCLOSE_F(ASPACE_ID, ERROR)
END SUBROUTINE ADD_TYPE



SUBROUTINE WRITE_PARAVIEW_STATE_FILE(NMESHES)
USE OUTPUT_CLOCKS

INTEGER, INTENT(IN) :: NMESHES
TYPE (MESH_TYPE), POINTER :: M
REAL(EB) :: CX,CY,CZ,XMN,XMX,YMN,YMX,ZMN,ZMX
INTEGER :: NM

XMX = -HUGE(EB)
YMX = -HUGE(EB)
ZMX = -HUGE(EB)
XMN = HUGE(EB)
YMN = HUGE(EB)
ZMN = HUGE(EB)
DO NM=1,NMESHES
   CALL POINT_TO_MESH(NM)
   M => MESHES(NM)
   XMX = MAX(XMX, M%XF)
   XMN = MIN(XMN, M%XS)
   YMX = MAX(YMX, M%YF)
   YMN = MIN(YMN, M%YS)
   ZMX = MAX(ZMX, M%ZF)
   ZMN = MIN(ZMN, M%ZS)
ENDDO

CX = (XMX+XMN)/2
CY = (YMX+YMN)/2
CZ = (ZMX+ZMN)/2

OPEN(LU_PARAVIEW,FILE=FN_PARAVIEW,FORM='FORMATTED', STATUS='REPLACE',ACTION='WRITE')
WRITE(LU_PARAVIEW,'(A)') '#Script to import FDS generated data for visualization in Paraview'
WRITE(LU_PARAVIEW,'(A)') 'import os'
WRITE(LU_PARAVIEW,'(A)') 'import glob'
WRITE(LU_PARAVIEW,'(A)') "def writeSeries(files, times, outfile):"
WRITE(LU_PARAVIEW,'(A)') "    with open(outfile, 'w') as f:"
WRITE(LU_PARAVIEW,'(A,A,A,A,A)') '        f.write(',"'",&
                             '{\n  "file-series-version" : "1.0",\n  "files" : [',"'",')'
WRITE(LU_PARAVIEW,'(A)') "        for time, file in zip(times, files):"
WRITE(LU_PARAVIEW,'(A,A,A,A,A)') '            f.write(',"'",'    { "name" : "%s", "time" : %0.2f },\n',&
                              "'",'%(file, time))'
WRITE(LU_PARAVIEW,'(A)') "        f.write('    ]\n  }\n')"
WRITE(LU_PARAVIEW,'(A)') "def parseTimes(files, ext):"
WRITE(LU_PARAVIEW,'(A)') "    times = [float(file.split('_')[-1].split(ext)[0])/100 for file in files]"
WRITE(LU_PARAVIEW,'(A)') "    return times"

WRITE(LU_PARAVIEW,'(A,A,A)') "chid = '",TRIM(CHID),"'"
WRITE(LU_PARAVIEW,'(A)') 'T_Begin = 0.0'
IF (DT_VTK_SPECIFIED > 0) THEN
   WRITE(LU_PARAVIEW,'(A,F15.3)') 'T_End = ',(T_END-T_BEGIN)/DT_VTK_SPECIFIED
ELSE
   WRITE(LU_PARAVIEW,'(A,F15.3)') 'T_End = ',REAL(NFRAMES,FB)
ENDIF

WRITE(LU_PARAVIEW,'(A,F15.3,A,F15.3,A,F15.3,A)') 'CenterOfRotation = [',CX,',',CY,',',CZ,']'
WRITE(LU_PARAVIEW,'(A,F15.3,A,F15.3,A,F15.3,A)') 'CameraFocalPoint = [',CX,',',CY,',',CZ,']'
WRITE(LU_PARAVIEW,'(A)') 'CameraFocalPoint = [x+0.01 if (abs(x) < 0.01) else x for x in CameraFocalPoint]'
WRITE(LU_PARAVIEW,'(A)') 'import paraview'
WRITE(LU_PARAVIEW,'(A)') 'from paraview.simple import *'
WRITE(LU_PARAVIEW,'(A)') 'paraview.simple._DisableFirstRenderCameraReset()'
WRITE(LU_PARAVIEW,'(A)') 'version = paraview.simple.GetParaViewVersion()'
WRITE(LU_PARAVIEW,'(A)') 'version_num = version.major + version.minor/100'
WRITE(LU_PARAVIEW,'(A)') 'if version_num <= 5.11:'
WRITE(LU_PARAVIEW,'(A)') "    piecewisefunction = 'PiecewiseFunction'"
WRITE(LU_PARAVIEW,'(A)') "    axesactor = 'GridAxes3DActor'"
WRITE(LU_PARAVIEW,'(A)') "    gridaxesrep = 'GridAxesRepresentation'"
WRITE(LU_PARAVIEW,'(A)') "    polaraxesrep = 'PolarAxesRepresentation'"
WRITE(LU_PARAVIEW,'(A)') 'else:'
WRITE(LU_PARAVIEW,'(A)') "    piecewisefunction = 'Piecewise Function'"
WRITE(LU_PARAVIEW,'(A)') "    axesactor = 'Grid Axes 3D Actor'"
WRITE(LU_PARAVIEW,'(A)') "    gridaxesrep = 'Grid Axes Representation'"
WRITE(LU_PARAVIEW,'(A)') "    polaraxesrep = 'Polar Axes Representation'"
WRITE(LU_PARAVIEW,'(A)') 'materialLibrary1 = GetMaterialLibrary()'

WRITE(LU_PARAVIEW,'(A)') "renderView1 = CreateView('RenderView')"
WRITE(LU_PARAVIEW,'(A)') "renderView1.AxesGrid = axesactor"
WRITE(LU_PARAVIEW,'(A)') "renderView1.CenterOfRotation = CenterOfRotation"
WRITE(LU_PARAVIEW,'(A)') "renderView1.StereoType = 'Crystal Eyes'"
WRITE(LU_PARAVIEW,'(A)') "renderView1.CameraFocalPoint = CameraFocalPoint"
WRITE(LU_PARAVIEW,'(A)') "renderView1.CameraViewUp = [0.0, 0.0, 1.0]"
WRITE(LU_PARAVIEW,'(A)') "paraview.simple.LoadPalette('WhiteBackground')"
WRITE(LU_PARAVIEW,'(A)') "renderView1.BackEnd = 'OSPRay raycaster'"
WRITE(LU_PARAVIEW,'(A)') "renderView1.OSPRayMaterialLibrary = materialLibrary1"
WRITE(LU_PARAVIEW,'(A)') "SetActiveView(None)"
WRITE(LU_PARAVIEW,'(A)') "layout1 = CreateLayout(name='Layout #1')"
WRITE(LU_PARAVIEW,'(A)') "layout1.AssignView(0, renderView1)"
WRITE(LU_PARAVIEW,'(A)') "SetActiveView(renderView1)"
WRITE(LU_PARAVIEW,'(A)') "# ----------------------------------------------------------------"
WRITE(LU_PARAVIEW,'(A)') "# setup the data processing pipelines"
WRITE(LU_PARAVIEW,'(A)') "# ----------------------------------------------------------------"
WRITE(LU_PARAVIEW,'(A)') "remoteConnection = servermanager.ActiveConnection.IsRemote()"
WRITE(LU_PARAVIEW,'(A)') "if remoteConnection:"
WRITE(LU_PARAVIEW,'(A)') "    indir = r'"//TRIM(WORKING_DIR)//"'"
WRITE(LU_PARAVIEW,'(A)') "    sep = '/'"
WRITE(LU_PARAVIEW,'(A)') "    uri = servermanager.ActiveConnection.GetURI()"
WRITE(LU_PARAVIEW,'(A)') "else:"
WRITE(LU_PARAVIEW,'(A)') "    indir = os.path.dirname(os.path.realpath(__file__))"
WRITE(LU_PARAVIEW,'(A)') "    sep = os.sep"
WRITE(LU_PARAVIEW,'(A)') "    uri = None"
WRITE(LU_PARAVIEW,'(A)') "rdir = r'"//TRIM(RESULTS_DIR)//"'"
WRITE(LU_PARAVIEW,'(A)') "if rdir == '':"
WRITE(LU_PARAVIEW,'(A)') "    namespace=indir+sep+chid"
WRITE(LU_PARAVIEW,'(A)') "else:"
WRITE(LU_PARAVIEW,'(A)') "    namespace=indir+sep+rdir+sep+chid"
WRITE(LU_PARAVIEW,'(A)') "pxm = servermanager.ProxyManager()"
WRITE(LU_PARAVIEW,'(A)') "directory_proxy = pxm.NewProxy('misc', 'ListDirectory')"
WRITE(LU_PARAVIEW,'(A)') "directory_proxy.List(indir+sep+rdir)"
WRITE(LU_PARAVIEW,'(A)') 'if version_num < 5.12:'
WRITE(LU_PARAVIEW,'(A)') "    directory_proxy.UpdatePropertyINFOrmation()"
WRITE(LU_PARAVIEW,'(A)') 'else:'
WRITE(LU_PARAVIEW,'(A)') "    directory_proxy.UpdatePropertyInformation()"
WRITE(LU_PARAVIEW,'(A,A)') "fileList = sorted(servermanager.VectorProperty(",&
                               "directory_proxy,directory_proxy.GetProperty('FileList')))"
WRITE(LU_PARAVIEW,'(A,A)') "directoryList = servermanager.VectorProperty(",&
                               "directory_proxy,directory_proxy.GetProperty('DirectoryList'))"
WRITE(LU_PARAVIEW,'(A)') "directory_proxy_root = pxm.NewProxy('misc', 'ListDirectory')"
WRITE(LU_PARAVIEW,'(A)') "directory_proxy_root.List(indir+sep)"
WRITE(LU_PARAVIEW,'(A)') 'if version_num < 5.12:'
WRITE(LU_PARAVIEW,'(A)') "    directory_proxy_root.UpdatePropertyINFOrmation()"
WRITE(LU_PARAVIEW,'(A)') 'else:'
WRITE(LU_PARAVIEW,'(A)') "    directory_proxy_root.UpdatePropertyInformation()"
WRITE(LU_PARAVIEW,'(A,A)') "fileList_root = sorted(servermanager.VectorProperty(",&
                               "directory_proxy_root,directory_proxy_root.GetProperty('FileList')))"
WRITE(LU_PARAVIEW,'(A,A)') "directoryList_root = servermanager.VectorProperty(",&
                               "directory_proxy_root,directory_proxy_root.GetProperty('DirectoryList'))"

WRITE(LU_PARAVIEW,'(A)') "# add geometry data"
IF(.NOT.VTK_HDF) THEN
   WRITE(LU_PARAVIEW,'(A)') "if chid + '_GEOM.pvtu' in fileList_root:"
   WRITE(LU_PARAVIEW,'(A,A)') "    geom = XMLPartitionedUnstructuredGridReader(registrationName='Geometry',",&
                         "FileName=[indir + sep + chid + '_GEOM.pvtu'])"
ELSE
   WRITE(LU_PARAVIEW,'(A)') "if chid + '_GEOM.vtkhdf' in fileList_root:"
   WRITE(LU_PARAVIEW,'(A,A)') "    geom = VTKHDFReader(registrationName='Geometry',",&
                         "FileName=[indir + sep + chid + '_GEOM.vtkhdf'])"
ENDIF
WRITE(LU_PARAVIEW,'(A)') "    geomDisplay = Show(geom, renderView1, 'UnstructuredGridRepresentation')"
WRITE(LU_PARAVIEW,'(A)') "    geomDisplay.MapScalars = 0"
WRITE(LU_PARAVIEW,'(A)') "    geomDisplay.Representation = 'Surface'"
WRITE(LU_PARAVIEW,'(A)') "    gcOLORTF2D = GetTransferFunction2D('Color')"
WRITE(LU_PARAVIEW,'(A)') "    geomColor = GetColorTransferFunction('Color')"
WRITE(LU_PARAVIEW,'(A)') "    geomColor.TransferFunction2D = gcOLORTF2D"
WRITE(LU_PARAVIEW,'(A)') "    geomColor.RGBPoints = [1.13, 0.23, 0.30, 0.75, 1.13, 0.87, 0.87, 0.87, 1.13, 0.71, 0.02, 0.15]"
WRITE(LU_PARAVIEW,'(A)') "    geomColor.ScalarRangeInitialized = 1.0"
WRITE(LU_PARAVIEW,'(A)') "    geomDisplay.ColorArrayName = ['CELLS', 'Color']"
WRITE(LU_PARAVIEW,'(A)') "    geomDisplay.LookupTable = geomColor"

WRITE(LU_PARAVIEW,'(A)') "# create a new 'STL Reader'"
WRITE(LU_PARAVIEW,'(A)') "if chid + '.stl' in fileList_root:"
WRITE(LU_PARAVIEW,'(A)') "    casestl = STLReader(registrationName='GeometrySTL', FileNames=[indir+sep+chid+'.stl'])"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay = Show(casestl, renderView1, 'GeometryRepresentation')"
WRITE(LU_PARAVIEW,'(A)') "    # trace defaults for the display properties."
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.Representation = 'Surface'"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.ColorArrayName = [None, '']"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.SelectTCoordArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.SelectNormalArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.SelectTangentArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.OSPRayScaleFunction = piecewisefunction"
!WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.Assembly = ''"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.SelectOrientationVectors = 'None'"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.ScaleFactor = 1.5493113040924074"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.SelectScaleArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.GlyphType = 'Arrow'"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.GlyphTableIndexArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.GaussianRadius = 0.07746556520462036"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.SetScaleArray = [None, '']"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.ScaleTransferFunction = piecewisefunction"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.OpacityArray = [None, '']"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.OpacityTransferFunction = piecewisefunction"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.DataAxesGrid = gridaxesrep"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.PolarAxes = polaraxesrep"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.SelectInputVectors = [None, '']"
WRITE(LU_PARAVIEW,'(A)') "    stlDisplay.WriteLog = ''"
WRITE(LU_PARAVIEW,'(A)') "# Load data files"
IF(.NOT.VTK_HDF) THEN
   WRITE(LU_PARAVIEW,'(A,A)') "sm3dFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                               "if ('_SM3D_' in x) and ('.pvtu' in x)]"
   WRITE(LU_PARAVIEW,'(A,A)') "sl2dxFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                               "if ('_X_' in x) and ('.pvtu' in x)]"
   WRITE(LU_PARAVIEW,'(A,A)') "sl2dyFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                               "if ('_Y_' in x) and ('.pvtu' in x)]"
   WRITE(LU_PARAVIEW,'(A,A)') "sl2dzFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                               "if ('_Z_' in x) and ('.pvtu' in x)]"
   WRITE(LU_PARAVIEW,'(A,A)') "sl3dFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                               "if ('_SL3D_' in x) and ('.pvtu' in x)]"
   WRITE(LU_PARAVIEW,'(A,A)') "bndfFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                               "if ('_BNDF_' in x) and ('.pvtu' in x)]"
   WRITE(LU_PARAVIEW,'(A,A)') "partFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                                  "if ('_PART_' in x) and ('.pvtp' in x)]"
ELSE
   WRITE(LU_PARAVIEW,'(A,A)') "sm3dFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                               "if ('_SM3D_' in x) and ('.vtkhdf' in x)]"
   WRITE(LU_PARAVIEW,'(A,A)') "sl2dxFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                               "if ('_X_' in x) and ('.vtkhdf' in x)]"
   WRITE(LU_PARAVIEW,'(A,A)') "sl2dyFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                               "if ('_Y_' in x) and ('.vtkhdf' in x)]"
   WRITE(LU_PARAVIEW,'(A,A)') "sl2dzFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                               "if ('_Z_' in x) and ('.vtkhdf' in x)]"
   WRITE(LU_PARAVIEW,'(A,A)') "sl3dFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                               "if ('_SL3D_' in x) and ('.vtkhdf' in x)]"
   WRITE(LU_PARAVIEW,'(A,A)') "bndfFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                               "if ('_BNDF_' in x) and ('.vtkhdf' in x)]"
   WRITE(LU_PARAVIEW,'(A,A)') "partFiles = [indir+sep+rdir+sep+x for x in fileList ",&
                                  "if ('_PART_' in x) and ('.vtkhdf' in x)]"
ENDIF
!WRITE(LU_PARAVIEW,'(A)') "bndfFiles = sorted(glob.glob(namespace+'_BNDF_*.pvtu'))"
!WRITE(LU_PARAVIEW,'(A)') "sm3dFiles = sorted(glob.glob(namespace+'_SM3D_*.pvtu'))"
!WRITE(LU_PARAVIEW,'(A)') "sl2dxFiles = sorted(glob.glob(namespace+'_X_*.pvtu'))"
!WRITE(LU_PARAVIEW,'(A)') "sl2dyFiles = sorted(glob.glob(namespace+'_Y_*.pvtu'))"
!WRITE(LU_PARAVIEW,'(A)') "sl2dzFiles = sorted(glob.glob(namespace+'_Z_*.pvtu'))"
!WRITE(LU_PARAVIEW,'(A)') "sl3dFiles = sorted(glob.glob(namespace+'_SL3D_*.pvtu'))"
!WRITE(LU_PARAVIEW,'(A)') "partFiles = sorted(glob.glob(namespace+'_PART_*.pvtp'))"

WRITE(LU_PARAVIEW,'(A)') "# Add boundary data"
WRITE(LU_PARAVIEW,'(A)') "if len(bndfFiles) > 0:"
IF (.NOT.VTK_HDF) THEN
   WRITE(LU_PARAVIEW,'(A)') "    if remoteConnection:"
   WRITE(LU_PARAVIEW,'(A,A)') "        BoundaryData = XMLPartitionedUnstructuredGridReader(",&
                                           "registrationName='Boundary', FileName=bndfFiles)"
   WRITE(LU_PARAVIEW,'(A)') "    else:"
   WRITE(LU_PARAVIEW,'(A)') "        bndfFiles = [rdir + x.split(sep)[-1] for x in bndfFiles]"
   WRITE(LU_PARAVIEW,'(A)') "        times = parseTimes(bndfFiles, '.pvtu')"
   WRITE(LU_PARAVIEW,'(A)') "        outname = indir+sep+'bndf.pvtu.series'"
   WRITE(LU_PARAVIEW,'(A)') "        writeSeries(bndfFiles, times, outname)"
   WRITE(LU_PARAVIEW,'(A,A)') "        BoundaryData = XMLPartitionedUnstructuredGridReader(",&
                                           "registrationName='Boundary', FileName=[outname])"
ELSE
   WRITE(LU_PARAVIEW,'(A)') "    if remoteConnection:"
   WRITE(LU_PARAVIEW,'(A,A)') "        BoundaryData = VTKHDFReader(",&
                                           "registrationName='Boundary', FileName=bndfFiles)"
   WRITE(LU_PARAVIEW,'(A)') "    else:"
   WRITE(LU_PARAVIEW,'(A)') "        bndfFiles = [rdir + x.split(sep)[-1] for x in bndfFiles]"
   WRITE(LU_PARAVIEW,'(A)') "        times = parseTimes(bndfFiles, '.vtkhdf')"
   WRITE(LU_PARAVIEW,'(A)') "        outname = indir+sep+'bndf.vtkhdf.series'"
   WRITE(LU_PARAVIEW,'(A)') "        writeSeries(bndfFiles, times, outname)"
   WRITE(LU_PARAVIEW,'(A,A)') "        BoundaryData = VTKHDFReader(",&
                                           "registrationName='Boundary', FileName=[outname])"
ENDIF
WRITE(LU_PARAVIEW,'(A)') "# Add smoke 3d data"
WRITE(LU_PARAVIEW,'(A)') "if len(sm3dFiles) > 0:"
IF (.NOT.VTK_HDF) THEN
   WRITE(LU_PARAVIEW,'(A)') "    if remoteConnection:"
   WRITE(LU_PARAVIEW,'(A,A)') "        sm3dData = XMLPartitionedUnstructuredGridReader(",&
                                        "registrationName='Raw Smoke 3D', FileName=sm3dFiles)"
   WRITE(LU_PARAVIEW,'(A)') "    else:"
   WRITE(LU_PARAVIEW,'(A)') "        sm3dFiles = [rdir + x.split(sep)[-1] for x in sm3dFiles]"
   WRITE(LU_PARAVIEW,'(A)') "        times = parseTimes(sm3dFiles, '.pvtu')"
   WRITE(LU_PARAVIEW,'(A)') "        outname = indir+sep+'sm3d.pvtu.series'"
   WRITE(LU_PARAVIEW,'(A)') "        writeSeries(sm3dFiles, times, outname)"
   WRITE(LU_PARAVIEW,'(A,A)') "        sm3dData = XMLPartitionedUnstructuredGridReader(",&
                                        "registrationName='Raw Smoke 3D', FileName=[outname])"
ELSE
   WRITE(LU_PARAVIEW,'(A)') "    if remoteConnection:"
   WRITE(LU_PARAVIEW,'(A,A)') "        sm3dData = VTKHDFReader(",&
                                        "registrationName='Raw Smoke 3D', FileName=sm3dFiles)"
   WRITE(LU_PARAVIEW,'(A)') "    else:"
   WRITE(LU_PARAVIEW,'(A)') "        sm3dFiles = [rdir + x.split(sep)[-1] for x in sm3dFiles]"
   WRITE(LU_PARAVIEW,'(A)') "        times = parseTimes(sm3dFiles, '.vtkhdf')"
   WRITE(LU_PARAVIEW,'(A)') "        outname = indir+sep+'sm3d.vtkhdf.series'"
   WRITE(LU_PARAVIEW,'(A)') "        writeSeries(sm3dFiles, times, outname)"
   WRITE(LU_PARAVIEW,'(A,A)') "        sm3dData = VTKHDFReader(",&
                                        "registrationName='Raw Smoke 3D', FileName=[outname])"
ENDIF
WRITE(LU_PARAVIEW,'(A)') "    smokeName = None"
WRITE(LU_PARAVIEW,'(A)') "    fireName = None"
WRITE(LU_PARAVIEW,'(A)') "    for s in sm3dData.PointArrayStatus:"
WRITE(LU_PARAVIEW,'(A)') "        if ('smoke' in s.lower() or 'soot' in s.lower()):"
WRITE(LU_PARAVIEW,'(A)') "            smokeName = s"
WRITE(LU_PARAVIEW,'(A)') "        if ('hrrpuv' in s.lower()):"
WRITE(LU_PARAVIEW,'(A)') "            fireName = s"
WRITE(LU_PARAVIEW,'(A)') "# Add 3d slice data"
WRITE(LU_PARAVIEW,'(A)') "if len(sl3dFiles) > 0:"
IF (.NOT.VTK_HDF) THEN
   WRITE(LU_PARAVIEW,'(A)') "    if remoteConnection:"
   WRITE(LU_PARAVIEW,'(A,A)') "        sl3dData = XMLPartitionedUnstructuredGridReader(",&
                                           "registrationName='Raw 3D Slice', FileName=sl3dFiles)"
   WRITE(LU_PARAVIEW,'(A)') "    else:"
   WRITE(LU_PARAVIEW,'(A)') "        sl3dFiles = [rdir + x.split(sep)[-1] for x in sl3dFiles]"
   WRITE(LU_PARAVIEW,'(A)') "        times = parseTimes(sl3dFiles, '.pvtu')"
   WRITE(LU_PARAVIEW,'(A)') "        outname = indir+sep+'sl3d.pvtu.series'"
   WRITE(LU_PARAVIEW,'(A)') "        writeSeries(sl3dFiles, times, outname)"
   WRITE(LU_PARAVIEW,'(A,A)') "        sl3dData = XMLPartitionedUnstructuredGridReader(",&
                                        "registrationName='Raw 3D Slice', FileName=[outname])"
ELSE
   WRITE(LU_PARAVIEW,'(A)') "    if remoteConnection:"
   WRITE(LU_PARAVIEW,'(A,A)') "        sl3dData = VTKHDFReader(",&
                                           "registrationName='Raw 3D Slice', FileName=sl3dFiles)"
   WRITE(LU_PARAVIEW,'(A)') "    else:"
   WRITE(LU_PARAVIEW,'(A)') "        sl3dFiles = [rdir + x.split(sep)[-1] for x in sl3dFiles]"
   WRITE(LU_PARAVIEW,'(A)') "        times = parseTimes(sl3dFiles, '.vtkhdf')"
   WRITE(LU_PARAVIEW,'(A)') "        outname = indir+sep+'sl3d.vtkhdf.series'"
   WRITE(LU_PARAVIEW,'(A)') "        writeSeries(sl3dFiles, times, outname)"
   WRITE(LU_PARAVIEW,'(A,A)') "        sl3dData = VTKHDFReader(",&
                                        "registrationName='Raw 3D Slice', FileName=[outname])"
ENDIF
WRITE(LU_PARAVIEW,'(A,A)') "    sl3dImage = ResampleToImage(",&
                                    "registrationName='Sampled 3D Slice', Input=sl3dData)"
WRITE(LU_PARAVIEW,'(A,A)') "    sl3dSlice = Slice(",&
                                    "registrationName='3D Slice Extraction', Input=sl3dImage)"
WRITE(LU_PARAVIEW,'(A)') "    sl3dSlice.SliceType = 'Plane'"
WRITE(LU_PARAVIEW,'(A)') "    sl3dSlice.HyperTreeGridSlicer = 'Plane'"
WRITE(LU_PARAVIEW,'(A)') "    sl3dSlice.SliceOffsetValues = [0.0]"
!WRITE(LU_PARAVIEW,'(A)') "    sl3dSlice.PointMergeMethod = 'Uniform Binning'"
WRITE(LU_PARAVIEW,'(A)') "    sl3dSlice.SliceType.Origin = CenterOfRotation"
WRITE(LU_PARAVIEW,'(A)') "    sl3dSlice.HyperTreeGridSlicer.Origin = CenterOfRotation"

WRITE(LU_PARAVIEW,'(A)') "# Add 2d slice data"
WRITE(LU_PARAVIEW,'(A,A)') "for sl2dFiles, axis_name in zip([sl2dxFiles,sl2dyFiles,sl2dzFiles],",&
                           "    ['X','Y','Z']):"
WRITE(LU_PARAVIEW,'(A)') "    if len(sl2dFiles) > 0:"
WRITE(LU_PARAVIEW,'(A)') "        slcfTypes = [x.split(chid+'_'+axis_name+'_')[1] for x in sl2dFiles]"
WRITE(LU_PARAVIEW,'(A,A)') "        slcfTypes = [('_'.join(x.split('_')[:-1])).replace('neg_','-')",&
                                        ".replace('pos_','') for x in slcfTypes]"
WRITE(LU_PARAVIEW,'(A)') "        uniqueSlcfTypes = sorted(list(set(slcfTypes)))"
WRITE(LU_PARAVIEW,'(A)') "        for slcfType in uniqueSlcfTypes:"
WRITE(LU_PARAVIEW,'(A)') "            axis=float(slcfType)/100"
IF (.NOT.VTK_HDF) THEN
   WRITE(LU_PARAVIEW,'(A)') "            if remoteConnection:"
   WRITE(LU_PARAVIEW,'(A,A)') "                slcf_files = sorted([x for x,y in zip(sl2dFiles, slcfTypes)",&
                                                   "if y == slcfType])"
   WRITE(LU_PARAVIEW,'(A,A)') "                sl2dData = XMLPartitionedUnstructuredGridReader(",&
                                                   "registrationName='%s=%0.4f'%(axis_name,axis), FileName=slcf_files)"
   WRITE(LU_PARAVIEW,'(A)') "            else:"
   WRITE(LU_PARAVIEW,'(A,A)') "                slcf_files = sorted([rdir + x.split(sep)[-1] for x,y in ",&
                                                   "zip(sl2dFiles, slcfTypes) if y == slcfType])"
   WRITE(LU_PARAVIEW,'(A)') "                times = parseTimes(slcf_files, '.pvtu')"
   WRITE(LU_PARAVIEW,'(A)') "                outname = indir+sep+'sl2d-'+slcfType.replace(' ','-')+'.pvtu.series'"
   WRITE(LU_PARAVIEW,'(A)') "                writeSeries(slcf_files, times, outname)"
   WRITE(LU_PARAVIEW,'(A,A)') "                sl2dData = XMLPartitionedUnstructuredGridReader(",&
                                                   "registrationName='%s=%0.4f'%(axis_name,axis), FileName=[outname])"
ELSE
   WRITE(LU_PARAVIEW,'(A)') "            if remoteConnection:"
   WRITE(LU_PARAVIEW,'(A,A)') "                slcf_files = sorted([x for x,y in zip(sl2dFiles, slcfTypes)",&
                                                   "if y == slcfType])"
   WRITE(LU_PARAVIEW,'(A,A)') "                sl2dData = VTKHDFReader(",&
                                                   "registrationName='%s=%0.4f'%(axis_name,axis), FileName=slcf_files)"
   WRITE(LU_PARAVIEW,'(A)') "            else:"
   WRITE(LU_PARAVIEW,'(A,A)') "                slcf_files = sorted([rdir + x.split(sep)[-1] for x,y in ",&
                                                   "zip(sl2dFiles, slcfTypes) if y == slcfType])"
   WRITE(LU_PARAVIEW,'(A)') "                times = parseTimes(slcf_files, '.vtkhdf')"
   WRITE(LU_PARAVIEW,'(A)') "                outname = indir+sep+'sl2d-'+slcfType.replace(' ','-')+'.vtkhdf.series'"
   WRITE(LU_PARAVIEW,'(A)') "                writeSeries(slcf_files, times, outname)"
   WRITE(LU_PARAVIEW,'(A,A)') "                sl2dData = VTKHDFReader(",&
                                                   "registrationName='%s=%0.4f'%(axis_name,axis), FileName=[outname])"
ENDIF
WRITE(LU_PARAVIEW,'(A)') "# Add particle data"
WRITE(LU_PARAVIEW,'(A)') "if len(partFiles) > 0:"
WRITE(LU_PARAVIEW,'(A)') "    partTypes = [x.split('_PART_')[1] for x in partFiles]"
WRITE(LU_PARAVIEW,'(A)') "    partTypes = ['_'.join(x.split('_')[:-1]) for x in partTypes]"
WRITE(LU_PARAVIEW,'(A)') "    uniquePartTypes = sorted(list(set(partTypes)))"
WRITE(LU_PARAVIEW,'(A)') "    for partType in uniquePartTypes:"
WRITE(LU_PARAVIEW,'(A)') "        partTypeFiles = sorted([x for x,y in zip(partFiles, partTypes) if y == partType])"
IF (.NOT.VTK_HDF) THEN
   WRITE(LU_PARAVIEW,'(A)') "        if remoteConnection:"
   WRITE(LU_PARAVIEW,'(A)') "            partTypeFiles = sorted([x for x,y in zip(partFiles, partTypes) if y == partType])"
   WRITE(LU_PARAVIEW,'(A,A)') "            partData = XMLPartitionedPolydataReader(",&
                                               "registrationName='Particle: '+partType, FileName=partTypeFiles)"
   WRITE(LU_PARAVIEW,'(A)') "        else:"
   WRITE(LU_PARAVIEW,'(A)') "            partTypeFiles = [rdir + x.split(sep)[-1] for x in partTypeFiles]"
   WRITE(LU_PARAVIEW,'(A)') "            times = parseTimes(partTypeFiles, '.pvtp')"
   WRITE(LU_PARAVIEW,'(A)') "            outname = indir+sep+'particles-'+partType.replace(' ','-')+'.pvtp.series'"
   WRITE(LU_PARAVIEW,'(A)') "            outname = os.path.abspath(outname)"
   WRITE(LU_PARAVIEW,'(A)') "            writeSeries(partTypeFiles, times, outname)"
   WRITE(LU_PARAVIEW,'(A,A)') "            partData = XMLPartitionedPolydataReader(",&
                                               "registrationName='Particle: '+partType, FileName=[outname])"
ELSE
   WRITE(LU_PARAVIEW,'(A)') "        if remoteConnection:"
   WRITE(LU_PARAVIEW,'(A)') "            partTypeFiles = sorted([x for x,y in zip(partFiles, partTypes) if y == partType])"
   WRITE(LU_PARAVIEW,'(A,A)') "            partData = VTKHDFReader(",&
                                               "registrationName='Particle: '+partType, FileName=partTypeFiles)"
   WRITE(LU_PARAVIEW,'(A)') "        else:"
   WRITE(LU_PARAVIEW,'(A)') "            partTypeFiles = [rdir + x.split(sep)[-1] for x in partTypeFiles]"
   WRITE(LU_PARAVIEW,'(A)') "            times = parseTimes(partTypeFiles, '.vtkhdf')"
   WRITE(LU_PARAVIEW,'(A)') "            outname = indir+sep+'particles-'+partType.replace(' ','-')+'.vtkhdf.series'"
   WRITE(LU_PARAVIEW,'(A)') "            outname = os.path.abspath(outname)"
   WRITE(LU_PARAVIEW,'(A)') "            writeSeries(partTypeFiles, times, outname)"
   WRITE(LU_PARAVIEW,'(A,A)') "            partData = VTKHDFReader(",&
                                               "registrationName='Particle: '+partType, FileName=[outname])"
ENDIF
WRITE(LU_PARAVIEW,'(A)') "        cOLORTF2D = GetTransferFunction2D('COLOR')"
WRITE(LU_PARAVIEW,'(A)') "        partColor = GetColorTransferFunction('COLOR')"
WRITE(LU_PARAVIEW,'(A)') "        partColor.TransferFunction2D = cOLORTF2D"
WRITE(LU_PARAVIEW,'(A,A)') "        partColor.RGBPoints = [1.13, 0.23, 0.30, 0.75, 1.13, 0.87,",&
                                        " 0.87, 0.87, 1.13, 0.71, 0.02, 0.15]"
WRITE(LU_PARAVIEW,'(A)') "        partColor.ScalarRangeInitialized = 1.0"
WRITE(LU_PARAVIEW,'(A)') "        partDisplay = Show(partData, renderView1, 'GeometryRepresentation')"
WRITE(LU_PARAVIEW,'(A)') "        partDisplay.Representation = 'Point Gaussian'"
WRITE(LU_PARAVIEW,'(A)') "        partDisplay.ColorArrayName = ['POINTS', 'COLOR']"
WRITE(LU_PARAVIEW,'(A)') "        partDisplay.LookupTable = partColor"
WRITE(LU_PARAVIEW,'(A)') "        partDisplay.MapScalars = 0"
WRITE(LU_PARAVIEW,'(A)') "        partDisplay.GaussianRadius = 0.05"
WRITE(LU_PARAVIEW,'(A)') "        partDisplay.ShaderPreset = 'Plain circle'"

WRITE(LU_PARAVIEW,'(A)') "if len(sm3dFiles) > 0:"
WRITE(LU_PARAVIEW,'(A)') "    # ----------------------------------------------------------------"
WRITE(LU_PARAVIEW,'(A)') "    # setup filter for fire 3d data"
WRITE(LU_PARAVIEW,'(A)') "    # ----------------------------------------------------------------"
WRITE(LU_PARAVIEW,'(A)') "    if fireName is not None:"
WRITE(LU_PARAVIEW,'(A)') "        fireImage = ResampleToImage(registrationName='Fire', Input=sm3dData)"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay = Show(fireImage, renderView1, 'UniformGridRepresentation')"
WRITE(LU_PARAVIEW,'(A)') "        # get 2D transfer function for 'HRRPUV'"
WRITE(LU_PARAVIEW,'(A)') "        hRRPUVTF2D = GetTransferFunction2D(fireName, separate=True)"
WRITE(LU_PARAVIEW,'(A)') "        # get color transfer function/color map for 'HRRPUV'"
WRITE(LU_PARAVIEW,'(A)') "        hRRPUVLUT = GetColorTransferFunction(fireName, separate=True)"
WRITE(LU_PARAVIEW,'(A)') "        hRRPUVLUT.TransferFunction2D = hRRPUVTF2D"
WRITE(LU_PARAVIEW,'(A,A)') "        hRRPUVLUT.RGBPoints = [-127.0, 0.0, 0.0, 0.0, -25.4, 0.9, 0.0, 0.0, 76.2, ",&
                                  "0.9, 0.9, 0.0, 127.0, 1.0, 1.0, 1.0]"
WRITE(LU_PARAVIEW,'(A)') "        hRRPUVLUT.ColorSpace = 'RGB'"
WRITE(LU_PARAVIEW,'(A)') "        hRRPUVLUT.NanColor = [0.0, 0.5, 1.0]"
WRITE(LU_PARAVIEW,'(A)') "        hRRPUVLUT.ScalarRangeInitialized = 1.0"
WRITE(LU_PARAVIEW,'(A)') "        # get opacity transfer function/opacity map for 'HRRPUV'"
WRITE(LU_PARAVIEW,'(A)') "        hRRPUVPWF = GetOpacityTransferFunction(fireName, separate=True)"
WRITE(LU_PARAVIEW,'(A)') "        hRRPUVPWF.Points = [-127.0, 0.0, 0.5, 0.0, 127.0, 1.0, 0.5, 0.0]"
WRITE(LU_PARAVIEW,'(A)') "        hRRPUVPWF.ScalarRangeInitialized = 1"
WRITE(LU_PARAVIEW,'(A)') "        # trace defaults for the display properties."
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.Representation = 'Volume'"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.ColorArrayName = ['POINTS', fireName]"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.LookupTable = hRRPUVLUT"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.SelectTCoordArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.SelectNormalArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.SelectTangentArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.OSPRayScaleArray = fireName"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.OSPRayScaleFunction = piecewisefunction"
!WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.Assembly = ''"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.SelectOrientationVectors = 'None'"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.ScaleFactor = 3.0"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.SelectScaleArray = fireName"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.GlyphType = 'Arrow'"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.GlyphTableIndexArray = fireName"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.GaussianRadius = 0.15"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.SetScaleArray = ['POINTS', fireName]"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.ScaleTransferFunction = piecewisefunction"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.OpacityArray = ['POINTS', fireName]"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.OpacityTransferFunction = piecewisefunction"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.DataAxesGrid = gridaxesrep"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.PolarAxes = polaraxesrep"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.ScalarOpacityUnitDistance = 0.44"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.ScalarOpacityFunction = hRRPUVPWF"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.TransferFunction2D = hRRPUVTF2D"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.OpacityArrayName = ['POINTS', fireName]"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.ColorArray2Name = ['POINTS', fireName]"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.SliceFunction = 'Plane'"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.Slice = 49"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.SelectInputVectors = ['POINTS', '']"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.WriteLog = ''"
WRITE(LU_PARAVIEW,'(A)') "        # init the piecewisefunction selected for 'ScaleTransferFunction'"
WRITE(LU_PARAVIEW,'(A,A)') "        fireImageDisplay.ScaleTransferFunction.Points = [-127.0, 0.0, 0.5, 0.0, -127, ",&
                                  "1.0, 0.5, 0.0]"
WRITE(LU_PARAVIEW,'(A)') "        # init the piecewisefunction selected for 'OpacityTransferFunction'"
WRITE(LU_PARAVIEW,'(A,A)') "        fireImageDisplay.OpacityTransferFunction.Points = [-127.0, 0.0, 0.5, 0.0, -127, ",&
                                  "1.0, 0.5, 0.0]"
WRITE(LU_PARAVIEW,'(A)') "        # init the 'Plane' selected for 'SliceFunction'"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.SliceFunction.Origin = CenterOfRotation"
WRITE(LU_PARAVIEW,'(A)') "        fireImageDisplay.UseSeparateColorMap = True"
WRITE(LU_PARAVIEW,'(A)') "    # ----------------------------------------------------------------"
WRITE(LU_PARAVIEW,'(A)') "    # setup filter for smoke 3d data"
WRITE(LU_PARAVIEW,'(A)') "    # ----------------------------------------------------------------"
WRITE(LU_PARAVIEW,'(A)') "    if smokeName is not None:"
WRITE(LU_PARAVIEW,'(A)') "        smokeImage = ResampleToImage(registrationName='Smoke', Input=sm3dData)"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay = Show(smokeImage, renderView1, 'UniformGridRepresentation')"
WRITE(LU_PARAVIEW,'(A)') "        # get 2D transfer function for 'SOOTDENSITY'"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYTF2D = GetTransferFunction2D(smokeName)"
WRITE(LU_PARAVIEW,'(A)') "        # get color transfer function/color map for 'SOOTDENSITY'"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYLUT = GetColorTransferFunction(smokeName)"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYLUT.TransferFunction2D = sOOTDENSITYTF2D"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYLUT.RGBPoints = [-127.0, 0.0, 0.0, 0.0, 127.0, 0.0, 0.0, 0.0]"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYLUT.ColorSpace = 'RGB'"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYLUT.NanColor = [1.0, 0.0, 0.0]"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYLUT.ScalarRangeInitialized = 1.0"
WRITE(LU_PARAVIEW,'(A)') "        # get opacity transfer function/opacity map for 'SOOTDENSITY'"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYPWF = GetOpacityTransferFunction(smokeName)"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYPWF.Points = [-127.0, 0.0, 0.5, 0.0, -126.0, 0.25, 0.5, 0.0, 127.0, 1.0, 0.5, 0.0]"
WRITE(LU_PARAVIEW,'(A)') "        sOOTDENSITYPWF.ScalarRangeInitialized = 1"
WRITE(LU_PARAVIEW,'(A)') "        # trace defaults for the display properties."
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.Representation = 'Volume'"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.ColorArrayName = ['POINTS', smokeName]"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.LookupTable = sOOTDENSITYLUT"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.SelectTCoordArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.SelectNormalArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.SelectTangentArray = 'None'"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.OSPRayScaleArray = smokeName"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.OSPRayScaleFunction = piecewisefunction"
!WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.Assembly = ''"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.SelectOrientationVectors = 'None'"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.ScaleFactor = 3.0"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.SelectScaleArray = smokeName"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.GlyphType = 'Arrow'"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.GlyphTableIndexArray = smokeName"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.GaussianRadius = 0.15"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.SetScaleArray = ['POINTS', smokeName]"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.ScaleTransferFunction = piecewisefunction"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.OpacityArray = ['POINTS', smokeName]"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.OpacityTransferFunction = piecewisefunction"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.DataAxesGrid = gridaxesrep"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.PolarAxes = polaraxesrep"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.ScalarOpacityFunction = sOOTDENSITYPWF"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.ScalarOpacityUnitDistance = 1.2957383373220388"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.OpacityArrayName = ['POINTS', smokeName]"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.SelectInputVectors = [None, '']"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.WriteLog = ''"
WRITE(LU_PARAVIEW,'(A)') "        # init the piecewisefunction selected for 'ScaleTransferFunction'"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.ScaleTransferFunction.Points =[-127.0, 0.0, 0.5, 0.0, -126.0, 1.0, 0.5, 0.0]"
WRITE(LU_PARAVIEW,'(A)') "        # init the piecewisefunction selected for 'OpacityTransferFunction'"
WRITE(LU_PARAVIEW,'(A)') "        smokeImageDisplay.OpacityTransferFunction.Points =[-127.0, 0.0, 0.5, 0.0, -126.0, 1.0, 0.5, 0.0]"

WRITE(LU_PARAVIEW,'(A)') "# ----------------------------------------------------------------"
WRITE(LU_PARAVIEW,'(A)') "# setup animation scene, tracks and keyframes"
WRITE(LU_PARAVIEW,'(A)') "# note: the Get..() functions create a new object, if needed"
WRITE(LU_PARAVIEW,'(A)') "# ----------------------------------------------------------------"

WRITE(LU_PARAVIEW,'(A)') "# get time animation track"
WRITE(LU_PARAVIEW,'(A)') "timeAnimationCue1 = GetTimeTrack()"

WRITE(LU_PARAVIEW,'(A)') "# initialize the animation scene"

WRITE(LU_PARAVIEW,'(A)') "# get the time-keeper"
WRITE(LU_PARAVIEW,'(A)') "timeKeeper1 = GetTimeKeeper()"
WRITE(LU_PARAVIEW,'(A)') "# initialize the timekeeper"
WRITE(LU_PARAVIEW,'(A)') "# initialize the animation track"
WRITE(LU_PARAVIEW,'(A)') "# get animation scene"
WRITE(LU_PARAVIEW,'(A)') "animationScene1 = GetAnimationScene()"

WRITE(LU_PARAVIEW,'(A)') "# initialize the animation scene"
WRITE(LU_PARAVIEW,'(A)') "animationScene1.ViewModules = renderView1"
WRITE(LU_PARAVIEW,'(A)') "animationScene1.Cues = timeAnimationCue1"
WRITE(LU_PARAVIEW,'(A)') "animationScene1.AnimationTime = T_Begin"
!WRITE(LU_PARAVIEW,'(A)') "animationScene1.EndTime = T_End"
WRITE(LU_PARAVIEW,'(A)') "animationScene1.PlayMode = 'Snap To TimeSteps'"

WRITE(LU_PARAVIEW,'(A)') "# ----------------------------------------------------------------"
WRITE(LU_PARAVIEW,'(A)') "# restore active source"
WRITE(LU_PARAVIEW,'(A)') "if len(sm3dFiles) > 0:"
WRITE(LU_PARAVIEW,'(A)') "    SetActiveSource(sm3dData)"
WRITE(LU_PARAVIEW,'(A)') "# ----------------------------------------------------------------"

CLOSE(LU_PARAVIEW)


END SUBROUTINE WRITE_PARAVIEW_STATE_FILE




END MODULE VTK_FDS_INTERFACE



























