MODULE FIRE

! Compute combustion

USE PRECISION_PARAMETERS
USE GLOBAL_CONSTANTS
USE MESH_POINTERS
USE COMP_FUNCTIONS, ONLY: SECOND

IMPLICIT NONE
PRIVATE

PUBLIC COMBUSTION

CONTAINS

SUBROUTINE COMBUSTION(T,DT,NM)

INTEGER, INTENT(IN) :: NM
REAL(EB), INTENT(IN) :: T,DT
REAL(EB) :: TNOW

IF (EVACUATION_ONLY(NM)) RETURN

TNOW=SECOND()

IF (INIT_HRRPUV) RETURN

CALL POINT_TO_MESH(NM)

! Call combustion ODE solver

CALL COMBUSTION_GENERAL(T,DT)

T_USED(10)=T_USED(10)+SECOND()-TNOW

END SUBROUTINE COMBUSTION


SUBROUTINE COMBUSTION_GENERAL(T,DT)

! Generic combustion routine for multi-step reactions

USE PHYSICAL_FUNCTIONS, ONLY: GET_SPECIFIC_GAS_CONSTANT,GET_MASS_FRACTION_ALL,GET_SPECIFIC_HEAT,GET_MOLECULAR_WEIGHT, &
                              GET_SENSIBLE_ENTHALPY_Z,IS_REALIZABLE
INTEGER :: I,J,K,NS,NR,II,JJ,KK,IIG,JJG,KKG,IW,N
REAL(EB), INTENT(IN) :: T,DT
REAL(EB):: ZZ_GET(1:N_TRACKED_SPECIES),DZZ(1:N_TRACKED_SPECIES),CP,H_S_N
LOGICAL :: Q_EXISTS
TYPE (REACTION_TYPE), POINTER :: RN
TYPE (SPECIES_MIXTURE_TYPE), POINTER :: SM
LOGICAL :: DO_REACTION,REALIZABLE

Q          = 0._EB
Q_EXISTS   = .FALSE.

CHI_R = 0._EB
IF (REAC_SOURCE_CHECK) Q_REAC=0._EB

IF (TRANSPORT_UNMIXED_FRACTION .AND. &
    COMPUTE_ZETA_SOURCE_TERM   .AND. &
    TRANSPORT_ZETA_SCHEME==1         ) CALL ZETA_PRODUCTION(DT) ! scheme 1: zeta production before mixing

DO K=1,KBAR
   DO J=1,JBAR
      ILOOP: DO I=1,IBAR
         ! Check to see if a reaction is possible
         IF (SOLID(CELL_INDEX(I,J,K))) CYCLE ILOOP
         ZZ_GET = ZZ(I,J,K,1:N_TRACKED_SPECIES)
         IF (CHECK_REALIZABILITY) THEN
            REALIZABLE=IS_REALIZABLE(ZZ_GET)
            IF (.NOT.REALIZABLE) THEN
               WRITE(LU_ERR,*) I,J,K
               WRITE(LU_ERR,*) ZZ_GET
               WRITE(LU_ERR,*) SUM(ZZ_GET)
               WRITE(LU_ERR,*) 'ERROR: Unrealizable mass fractions input to COMBUSTION_MODEL'
               STOP_STATUS=REALIZABILITY_STOP
            ENDIF
         ENDIF
         CALL CHECK_REACTION
         IF (.NOT.DO_REACTION) CYCLE ILOOP ! Check whether any reactions are possible.
         DZZ = ZZ_GET ! store old ZZ for divergence term
         ! Call combustion integration routine
         CALL COMBUSTION_MODEL(T,DT,I,J,K,ZZ_GET,Q(I,J,K))
         IF (CHECK_REALIZABILITY) THEN
            REALIZABLE=IS_REALIZABLE(ZZ_GET)
            IF (.NOT.REALIZABLE) THEN
               WRITE(LU_ERR,*) ZZ_GET,SUM(ZZ_GET)
               WRITE(LU_ERR,*) 'ERROR: Unrealizable mass fractions after COMBUSTION_MODEL'
               STOP_STATUS=REALIZABILITY_STOP
            ENDIF
         ENDIF
         DZZ = ZZ_GET - DZZ
         ! Update RSUM and ZZ
         DZZ_IF: IF ( ANY(ABS(DZZ) > TWO_EPSILON_EB) ) THEN
            IF (ABS(Q(I,J,K)) > TWO_EPSILON_EB) Q_EXISTS = .TRUE.
               ! Divergence term
               CALL GET_SPECIFIC_HEAT(ZZ_GET,CP,TMP(I,J,K))
               CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_GET,RSUM(I,J,K))
               DO N=1,N_TRACKED_SPECIES
                  SM => SPECIES_MIXTURE(N)
                  CALL GET_SENSIBLE_ENTHALPY_Z(N,TMP(I,J,K),H_S_N)
                  D_SOURCE(I,J,K) = D_SOURCE(I,J,K) + ( SM%RCON/RSUM(I,J,K) - H_S_N/(CP*TMP(I,J,K)) )*DZZ(N)/DT
                  M_DOT_PPP(I,J,K,N) = M_DOT_PPP(I,J,K,N) + RHO(I,J,K)*DZZ(N)/DT
               ENDDO
         ENDIF DZZ_IF
      ENDDO ILOOP
   ENDDO
ENDDO

IF (TRANSPORT_UNMIXED_FRACTION .AND. &
    COMPUTE_ZETA_SOURCE_TERM   .AND. &
    TRANSPORT_ZETA_SCHEME==2         ) CALL ZETA_PRODUCTION(DT) ! scheme 2: zeta production after mixing

IF (.NOT.Q_EXISTS) RETURN

! Set Q in the ghost cell, just for better visualization.

DO IW=1,N_EXTERNAL_WALL_CELLS
   IF (WALL(IW)%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY .AND. WALL(IW)%BOUNDARY_TYPE/=OPEN_BOUNDARY) CYCLE
   II  = WALL(IW)%ONE_D%II
   JJ  = WALL(IW)%ONE_D%JJ
   KK  = WALL(IW)%ONE_D%KK
   IIG = WALL(IW)%ONE_D%IIG
   JJG = WALL(IW)%ONE_D%JJG
   KKG = WALL(IW)%ONE_D%KKG
   Q(II,JJ,KK) = Q(IIG,JJG,KKG)
ENDDO


CONTAINS


SUBROUTINE CHECK_REACTION

! Check whether any reactions are possible.

LOGICAL :: REACTANTS_PRESENT

DO_REACTION = .FALSE.
REACTION_LOOP: DO NR=1,N_REACTIONS
   RN=>REACTION(NR)
   REACTANTS_PRESENT = .TRUE.
   DO NS=1,N_TRACKED_SPECIES
      IF ( RN%NU(NS) < -TWO_EPSILON_EB .AND. ZZ_GET(NS) < ZZ_MIN_GLOBAL ) THEN
         REACTANTS_PRESENT = .FALSE.
         EXIT
      ENDIF
   ENDDO
   DO_REACTION = REACTANTS_PRESENT
   IF (DO_REACTION) EXIT REACTION_LOOP
ENDDO REACTION_LOOP

END SUBROUTINE CHECK_REACTION

END SUBROUTINE COMBUSTION_GENERAL


SUBROUTINE COMBUSTION_MODEL(T,DT,I,J,K,ZZ_GET,Q_OUT)
USE COMP_FUNCTIONS, ONLY: SHUTDOWN
USE MATH_FUNCTIONS, ONLY: EVALUATE_RAMP
USE PHYSICAL_FUNCTIONS, ONLY: LES_FILTER_WIDTH_FUNCTION,GET_AVERAGE_SPECIFIC_HEAT,GET_SPECIFIC_GAS_CONSTANT,GET_ENTHALPY
INTEGER, INTENT(IN) :: I,J,K
REAL(EB), INTENT(IN) :: T,DT
REAL(EB), INTENT(OUT) :: Q_OUT
REAL(EB), INTENT(INOUT) :: ZZ_GET(1:N_TRACKED_SPECIES)
REAL(EB) :: ERR_EST,ERR_TOL,DZZ(1:N_TRACKED_SPECIES),&
            A1(1:N_TRACKED_SPECIES),A2(1:N_TRACKED_SPECIES),A4(1:N_TRACKED_SPECIES),ZETA,ZETA_0,&
            DT_SUB,DT_SUB_NEW,DT_ITER,ZZ_STORE(1:N_TRACKED_SPECIES,1:4),TV(1:3,1:N_TRACKED_SPECIES),CELL_VOLUME,CELL_MASS,&
            ZZ_DIFF(1:3,1:N_TRACKED_SPECIES),ZZ_MIXED(1:N_TRACKED_SPECIES),ZZ_UNMIXED(1:N_TRACKED_SPECIES),&
            ZZ_MIXED_NEW(1:N_TRACKED_SPECIES),TAU_D,TAU_G,TAU_U,TAU_MIX,DELTA,TMP_MIXED,TMP_UNMIXED,DT_SUB_MIN,RHO_HAT,&
            PBAR_0,VEL_RMS,TAU_RES,H1,H2,ZZ_0(1:N_TRACKED_SPECIES),&
            Q_REAC_SUB(1:N_REACTIONS),Q_REAC_1(1:N_REACTIONS),Q_REAC_2(1:N_REACTIONS),Q_REAC_4(1:N_REACTIONS),&
            Q_REAC_SUM(1:N_REACTIONS),CHI_R_SUM,TIME_RAMP_FACTOR,&
            TOTAL_MIXED_MASS_1,TOTAL_MIXED_MASS_2,TOTAL_MIXED_MASS_4,TOTAL_MIXED_MASS,&
            ZETA_1,ZETA_2,ZETA_4,AIT_LOC
INTEGER :: NR,NS,ITER,TVI,RICH_ITER,TIME_ITER,RICH_ITER_MAX
INTEGER, PARAMETER :: TV_ITER_MIN=5
LOGICAL :: TV_FLUCT(1:N_TRACKED_SPECIES),EXTINCT(1:N_REACTIONS)
TYPE(REACTION_TYPE), POINTER :: RN=>NULL()
REAL(EB), PARAMETER :: C_U = 0.4_EB*0.1_EB*SQRT(1.5_EB) ! C_U*C_DEARDORFF/SQRT(2/3)

ZZ_0 = ZZ_GET

DELTA = LES_FILTER_WIDTH_FUNCTION(DX(I),DY(J),DZ(K))
VEL_RMS = 0._EB
IF (FIXED_MIX_TIME>0._EB) THEN
   MIX_TIME(I,J,K)=FIXED_MIX_TIME
ELSE
   TAU_D=0._EB
   DO NR =1,N_REACTIONS
      RN => REACTION(NR)
      TAU_D = MAX(TAU_D,D_Z(MIN(4999,NINT(TMP(I,J,K))),RN%FUEL_SMIX_INDEX))
   ENDDO
   TAU_D = DELTA**2/MAX(TAU_D,TWO_EPSILON_EB) ! FDS Tech Guide (5.21)
   IF (LES) THEN
      TAU_U = C_U*RHO(I,J,K)*DELTA**2/MAX(MU(I,J,K),TWO_EPSILON_EB)     ! FDS Tech Guide (5.22)
      TAU_G = SQRT(2._EB*DELTA/(GRAV+1.E-10_EB))                        ! FDS Tech Guide (5.23)
      MIX_TIME(I,J,K)= MAX(TAU_CHEM,MIN(TAU_D,TAU_U,TAU_G,TAU_FLAME))   ! FDS Tech Guide (5.20)
      VEL_RMS = SQRT(TWTH)*MU(I,J,K)/(RHO(I,J,K)*C_DEARDORFF*DELTA)
   ELSE
      MIX_TIME(I,J,K)= MAX(TAU_CHEM,TAU_D)
   ENDIF
ENDIF

DT_SUB_MIN = DT/REAL(MAX_CHEMISTRY_ITERATIONS,EB)
ZZ_STORE(:,:) = 0._EB
Q_OUT = 0._EB
ITER= 0
DT_ITER = 0._EB
IF (N_FIXED_CHEMISTRY_SUBSTEPS>0) THEN
   DT_SUB = DT/REAL(N_FIXED_CHEMISTRY_SUBSTEPS,EB)
   DT_SUB_NEW = DT_SUB
   RICH_ITER_MAX = 1
ELSE
   DT_SUB = DT
   DT_SUB_NEW = DT
   RICH_ITER_MAX = 5
ENDIF
Q_REAC_SUM(:) = 0._EB
ZZ_UNMIXED = ZZ_GET
ZZ_MIXED = ZZ_GET
A1 = ZZ_GET
A2 = ZZ_GET
A4 = ZZ_GET
IF (TRANSPORT_UNMIXED_FRACTION) THEN
   ZETA_0 = ZZ(I,J,K,ZETA_INDEX)
ELSE
   ZETA_0 = INITIAL_UNMIXED_FRACTION
ENDIF
ZETA = ZETA_0
CELL_VOLUME = DX(I)*DY(J)*DZ(K)
CELL_MASS = RHO(I,J,K)*CELL_VOLUME
RHO_HAT = RHO(I,J,K)
TMP_MIXED = TMP(I,J,K)
TMP_UNMIXED = TMP(I,J,K)
TAU_MIX = MIX_TIME(I,J,K)
TAU_RES = MU(I,J,K)/(RHO(I,J,K)*SC)/MAX(2._EB*KRES(I,J,K),TWO_EPSILON_EB)
EXTINCT(1:N_REACTIONS) = .FALSE.
PBAR_0 = PBAR(K,PRESSURE_ZONE(I,J,K))

IF (REIGNITION_MODEL) THEN
   AIT_LOC = AIT(I,J,K)
ELSE
   AIT_LOC = 1.E20_EB
ENDIF

INTEGRATION_LOOP: DO TIME_ITER = 1,MAX_CHEMISTRY_ITERATIONS

   IF (SUPPRESSION .AND. TIME_ITER==1) CALL GET_EXTINCT(EXTINCT,ZZ_MIXED,TMP_MIXED,TAU_RES,AIT_LOC)

   INTEGRATOR_SELECT: SELECT CASE (COMBUSTION_ODE_SOLVER)

      CASE (EXPLICIT_EULER) ! Simple chemistry

         ! May be used with N_FIXED_CHEMISTRY_SUBSTEPS, but default mode is DT_SUB=DT for fast chemistry

         CALL FIRE_FORWARD_EULER(ZZ_MIXED_NEW,ZZ_MIXED,ZZ_UNMIXED,ZETA,ZETA_0,DT_SUB,TMP_MIXED,TMP_UNMIXED,RHO_HAT,&
                                 CELL_MASS,TAU_MIX,PBAR_0,DELTA,VEL_RMS,EXTINCT,Q_REAC_SUB,TIME_ITER,TOTAL_MIXED_MASS)
         ZETA_0 = ZETA
         ZZ_MIXED = ZZ_MIXED_NEW
         IF (SIMPLE_CHEMISTRY .AND. N_FIXED_CHEMISTRY_SUBSTEPS<0 .AND. TIME_ITER > 1) THEN
            CALL SHUTDOWN('ERROR: Error in Simple Chemistry')
         ENDIF

      CASE (RK2) ! Runge-Kutta 2 stage (use in combination with N_FIXED_CHEMISTRY_SUBSTEPS)

         CALL FIRE_RK2(ZZ_MIXED_NEW,ZZ_MIXED,ZZ_UNMIXED,ZETA,ZETA_0,DT_SUB,1,TMP_MIXED,TMP_UNMIXED,RHO_HAT,&
                       CELL_MASS,TAU_MIX,PBAR_0,DELTA,VEL_RMS,EXTINCT,Q_REAC_SUB,TIME_ITER,TOTAL_MIXED_MASS)
         ZETA_0 = ZETA
         ZZ_MIXED = ZZ_MIXED_NEW

      CASE (RK3) ! Runge-Kutta 3 stage (use in combination with N_FIXED_CHEMISTRY_SUBSTEPS)

         CALL FIRE_RK3(ZZ_MIXED_NEW,ZZ_MIXED,ZZ_UNMIXED,ZETA,ZETA_0,DT_SUB,1,TMP_MIXED,TMP_UNMIXED,RHO_HAT,&
                       CELL_MASS,TAU_MIX,PBAR_0,DELTA,VEL_RMS,EXTINCT,Q_REAC_SUB,TIME_ITER,TOTAL_MIXED_MASS)
         ZETA_0 = ZETA
         ZZ_MIXED = ZZ_MIXED_NEW

      CASE (RK2_RICHARDSON) ! Finite-rate (or mixed finite-rate/fast) chemistry

         ! May be used with N_FIXED_CHEMISTRY_SUBSTEPS, but default mode is to use error estimator and variable DT_SUB

         ERR_TOL = RICHARDSON_ERROR_TOLERANCE
         RICH_EX_LOOP: DO RICH_ITER = 1,RICH_ITER_MAX

            DT_SUB = MIN(DT_SUB_NEW,DT-DT_ITER)

            ! FDS Tech Guide (E.3), (E.4), (E.5)
            CALL FIRE_RK2(A1,ZZ_MIXED,ZZ_UNMIXED,ZETA_1,ZETA_0,DT_SUB,1,TMP_MIXED,TMP_UNMIXED,RHO_HAT,CELL_MASS,TAU_MIX,PBAR_0, &
                          DELTA,VEL_RMS,EXTINCT,Q_REAC_1,TIME_ITER,TOTAL_MIXED_MASS_1)
            CALL FIRE_RK2(A2,ZZ_MIXED,ZZ_UNMIXED,ZETA_2,ZETA_0,DT_SUB,2,TMP_MIXED,TMP_UNMIXED,RHO_HAT,CELL_MASS,TAU_MIX,PBAR_0, &
                          DELTA,VEL_RMS,EXTINCT,Q_REAC_2,TIME_ITER,TOTAL_MIXED_MASS_2)
            CALL FIRE_RK2(A4,ZZ_MIXED,ZZ_UNMIXED,ZETA_4,ZETA_0,DT_SUB,4,TMP_MIXED,TMP_UNMIXED,RHO_HAT,CELL_MASS,TAU_MIX,PBAR_0, &
                          DELTA,VEL_RMS,EXTINCT,Q_REAC_4,TIME_ITER,TOTAL_MIXED_MASS_4)

            ! Species Error Analysis
            ERR_EST = MAXVAL(ABS((4._EB*A4-5._EB*A2+A1)))/45._EB ! FDS Tech Guide (E.7)

            IF (N_FIXED_CHEMISTRY_SUBSTEPS<0) THEN
               DT_SUB_NEW = MIN(MAX(DT_SUB*(ERR_TOL/(ERR_EST+TWO_EPSILON_EB))**(0.25_EB),DT_SUB_MIN),DT-DT_ITER) ! (E.8)
               IF (ERR_EST<ERR_TOL) EXIT RICH_EX_LOOP
            ENDIF

         ENDDO RICH_EX_LOOP

         ZZ_MIXED   = (4._EB*A4-A2)*ONTH ! FDS Tech Guide (E.6)
         Q_REAC_SUB = (4._EB*Q_REAC_4-Q_REAC_2)*ONTH
         ZETA       = (4._EB*ZETA_4-ZETA_2)*ONTH
         ZETA_0     = ZETA

         !! debug
         !ZETA_0 = ZETA
         !ZZ_MIXED = A4
         !Q_REAC_SUB = Q_REAC_4

   END SELECT INTEGRATOR_SELECT

   ZZ_GET = ZETA*ZZ_UNMIXED + (1._EB-ZETA)*ZZ_MIXED ! FDS Tech Guide (5.30)
   IF (TRANSPORT_UNMIXED_FRACTION) ZZ(I,J,K,ZETA_INDEX) = ZETA

   DT_ITER = DT_ITER + DT_SUB
   ITER = ITER + 1
   IF (OUTPUT_CHEM_IT) THEN
      CHEM_SUBIT(I,J,K) = ITER
   ENDIF
   Q_REAC_SUM = Q_REAC_SUM + Q_REAC_SUB

   ! Total Variation (TV) scheme (accelerates integration for finite-rate equilibrium calculations)
   ! See FDS Tech Guide Appendix E

   IF (COMBUSTION_ODE_SOLVER==RK2_RICHARDSON .AND. N_REACTIONS > 1) THEN
      DO NS = 1,N_TRACKED_SPECIES
         DO TVI = 1,3
            ZZ_STORE(NS,TVI)=ZZ_STORE(NS,TVI+1)
         ENDDO
         ZZ_STORE(NS,4) = ZZ_GET(NS)
      ENDDO
      TV_FLUCT(:) = .FALSE.
      IF (ITER >= TV_ITER_MIN) THEN
         SPECIES_LOOP_TV: DO NS = 1,N_TRACKED_SPECIES
            DO TVI = 1,3
               TV(TVI,NS) = ABS(ZZ_STORE(NS,TVI+1)-ZZ_STORE(NS,TVI))
               ZZ_DIFF(TVI,NS) = ZZ_STORE(NS,TVI+1)-ZZ_STORE(NS,TVI)
            ENDDO
            IF (SUM(TV(:,NS)) < ERR_TOL .OR. SUM(TV(:,NS)) >= ABS(2.9_EB*SUM(ZZ_DIFF(:,NS)))) THEN ! FDS Tech Guide (E.10)
               TV_FLUCT(NS) = .TRUE.
            ENDIF
            IF (ALL(TV_FLUCT)) EXIT INTEGRATION_LOOP
         ENDDO SPECIES_LOOP_TV
      ENDIF
   ENDIF

   IF ( DT_ITER > (DT+TWO_EPSILON_EB) ) CALL SHUTDOWN('ERROR: DT_ITER > DT in COMBUSTION_MODEL')
   IF ( DT_ITER > (DT-TWO_EPSILON_EB) ) EXIT INTEGRATION_LOOP

ENDDO INTEGRATION_LOOP

! Compute heat release rate

DZZ = ZZ_GET-ZZ_0
IF (MAXVAL(ABS(DZZ)) > TWO_EPSILON_EB) THEN
   CALL GET_ENTHALPY(DZZ,H1,H_F_REFERENCE_TEMPERATURE)
   CALL GET_ENTHALPY(DZZ,H2,TMP(I,J,K))
   Q_OUT = -RHO(I,J,K)*SUM(SPECIES_MIXTURE%H_F*DZZ)/DT ! FDS Tech Guide (5.14)
ENDIF

! Reaction rate-weighted radiative fraction

IF (SUM(Q_REAC_SUM)>TWO_EPSILON_EB) THEN
   CHI_R_SUM=0._EB
   DO NR=1,N_REACTIONS
      RN=>REACTION(NR)
      TIME_RAMP_FACTOR = EVALUATE_RAMP(T,0._EB,RN%RAMP_CHI_R_INDEX)
      CHI_R_SUM = CHI_R_SUM + Q_REAC_SUM(NR)*RN%CHI_R*TIME_RAMP_FACTOR
   ENDDO
   CHI_R(I,J,K) = CHI_R_SUM/(SUM(Q_REAC_SUM))
ENDIF
CHI_R(I,J,K) = MAX(CHI_R_MIN,MIN(CHI_R_MAX,CHI_R(I,J,K)))

! Store special diagnostic quantities

IF (REAC_SOURCE_CHECK) THEN
   REAC_SOURCE_TERM(I,J,K,:) = RHO(I,J,K)*(ZZ_GET-ZZ_0)/DT
   Q_REAC(I,J,K,:) = Q_REAC_SUM/CELL_VOLUME/DT
ENDIF

END SUBROUTINE COMBUSTION_MODEL


SUBROUTINE FIRE_FORWARD_EULER(ZZ_OUT,ZZ_IN,ZZ_UNMIXED,ZETA_OUT,ZETA_IN,DT_LOC,TMP_MIXED,TMP_UNMIXED,RHO_HAT,CELL_MASS,TAU_MIX,&
                              PBAR_0,DELTA,VEL_RMS,EXTINCT,Q_REAC_LOC,SUB_IT,TOTAL_MIXED_MASS)
USE COMP_FUNCTIONS, ONLY:SHUTDOWN
USE PHYSICAL_FUNCTIONS, ONLY: GET_REALIZABLE_MF,GET_AVERAGE_SPECIFIC_HEAT
REAL(EB), INTENT(IN) :: ZZ_IN(1:N_TRACKED_SPECIES),ZETA_IN,DT_LOC,RHO_HAT,ZZ_UNMIXED(1:N_TRACKED_SPECIES),CELL_MASS,TAU_MIX,&
                        PBAR_0,DELTA,VEL_RMS,TMP_UNMIXED
INTEGER, INTENT(IN) :: SUB_IT
REAL(EB), INTENT(OUT) :: ZZ_OUT(1:N_TRACKED_SPECIES),ZETA_OUT,Q_REAC_LOC(1:N_REACTIONS),TOTAL_MIXED_MASS
REAL(EB), INTENT(INOUT) :: TMP_MIXED
LOGICAL, INTENT(IN) :: EXTINCT(1:N_REACTIONS)
REAL(EB) :: ZZ_0(1:N_TRACKED_SPECIES),ZZ_NEW(1:N_TRACKED_SPECIES),DZZ(1:N_TRACKED_SPECIES),&
            MIXED_MASS(1:N_TRACKED_SPECIES),MIXED_MASS_0(1:N_TRACKED_SPECIES),&
            Q_REAC_OUT(1:N_REACTIONS),TOTAL_MIXED_MASS_0
INTEGER, PARAMETER :: INFINITELY_FAST=1,FINITE_RATE=2

! Determine initial state of mixed reactor zone

TOTAL_MIXED_MASS_0  = (1._EB-ZETA_IN)*CELL_MASS
MIXED_MASS_0  = ZZ_IN*TOTAL_MIXED_MASS_0

! Mixing step

ZETA_OUT = MAX(0._EB,ZETA_IN*EXP(-DT_LOC/TAU_MIX)) ! FDS Tech Guide (5.29)
TOTAL_MIXED_MASS = (1._EB-ZETA_OUT)*CELL_MASS
MIXED_MASS = MAX(0._EB,MIXED_MASS_0 - (ZETA_OUT - ZETA_IN)*ZZ_UNMIXED*CELL_MASS) ! after mixing step, FDS Tech Guide (5.36)
ZZ_0 = MIXED_MASS/MAX(TOTAL_MIXED_MASS,TWO_EPSILON_EB) ! FDS Tech Guide (5.37)

! Enforce realizability on mass fractions

CALL GET_REALIZABLE_MF(ZZ_0)

Q_REAC_LOC(:) = 0._EB

! Removed TEMPERATURE_DEPENDENT_REACTION until other bugs are sorted out
TMP_MIXED = TMP_UNMIXED
IF (ANY(REACTION(:)%FAST_CHEMISTRY)) THEN
   CALL REACTION_RATE(DZZ,ZZ_0,DT_LOC,RHO_HAT,TMP_MIXED,INFINITELY_FAST,PBAR_0,DELTA,VEL_RMS,EXTINCT,Q_REAC_OUT,SUB_IT)
   ZZ_NEW = ZZ_0 + DZZ
   ZZ_0 = ZZ_NEW
   Q_REAC_LOC = Q_REAC_LOC + Q_REAC_OUT*TOTAL_MIXED_MASS
ENDIF
IF (.NOT.ALL(REACTION(:)%FAST_CHEMISTRY)) THEN
   CALL REACTION_RATE(DZZ,ZZ_0,DT_LOC,RHO_HAT,TMP_MIXED,FINITE_RATE,PBAR_0,DELTA,VEL_RMS,EXTINCT,Q_REAC_OUT,SUB_IT)
   ZZ_NEW = ZZ_0 + DZZ
   Q_REAC_LOC = Q_REAC_LOC + Q_REAC_OUT*TOTAL_MIXED_MASS
ENDIF

! Enforce realizability on mass fractions

CALL GET_REALIZABLE_MF(ZZ_NEW)

ZZ_OUT = ZZ_NEW

END SUBROUTINE FIRE_FORWARD_EULER


SUBROUTINE FIRE_RK2(ZZ_OUT,ZZ_IN,ZZ_UNMIXED,ZETA_OUT,ZETA_IN,DT_SUB,N_INC,TMP_MIXED,TMP_UNMIXED,RHO_HAT,CELL_MASS,TAU_MIX,&
                    PBAR_0,DELTA,VEL_RMS,EXTINCT,Q_REAC_OUT,SUB_IT,TOTAL_MIXED_MASS_OUT)

! This function uses RK2 to integrate ZZ_O from t=0 to t=DT_SUB in increments of DT_LOC=DT_SUB/N_INC

REAL(EB), INTENT(IN) :: ZZ_IN(1:N_TRACKED_SPECIES),DT_SUB,ZETA_IN,RHO_HAT,ZZ_UNMIXED(1:N_TRACKED_SPECIES),CELL_MASS,&
                        TAU_MIX,PBAR_0,DELTA,VEL_RMS,TMP_UNMIXED
REAL(EB), INTENT(OUT) :: ZZ_OUT(1:N_TRACKED_SPECIES),ZETA_OUT,Q_REAC_OUT(1:N_REACTIONS),TOTAL_MIXED_MASS_OUT
REAL(EB), INTENT(INOUT) :: TMP_MIXED
INTEGER, INTENT(IN) :: N_INC,SUB_IT
LOGICAL, INTENT(IN) :: EXTINCT(1:N_REACTIONS)
REAL(EB) :: DT_LOC,ZZ_0(1:N_TRACKED_SPECIES),ZZ_1(1:N_TRACKED_SPECIES),ZZ_2(1:N_TRACKED_SPECIES),ZETA_0,ZETA_1,ZETA_2,&
            Q_REAC_1(1:N_REACTIONS),Q_REAC_2(1:N_REACTIONS),TOTAL_MIXED_MASS_0,TOTAL_MIXED_MASS_1,TOTAL_MIXED_MASS_2
INTEGER :: N

DT_LOC = DT_SUB/REAL(N_INC,EB)
ZZ_0 = ZZ_IN
ZETA_0 = ZETA_IN
Q_REAC_OUT(:) = 0._EB
TOTAL_MIXED_MASS_0 = (1._EB-ZETA_0)*CELL_MASS

DO N=1,N_INC

   CALL FIRE_FORWARD_EULER(ZZ_1,ZZ_0,ZZ_UNMIXED,ZETA_1,ZETA_0,DT_LOC,TMP_MIXED,TMP_UNMIXED,RHO_HAT,CELL_MASS,TAU_MIX,&
                           PBAR_0,DELTA,VEL_RMS,EXTINCT,Q_REAC_1,SUB_IT,TOTAL_MIXED_MASS_1)

   CALL FIRE_FORWARD_EULER(ZZ_2,ZZ_1,ZZ_UNMIXED,ZETA_2,ZETA_1,DT_LOC,TMP_MIXED,TMP_UNMIXED,RHO_HAT,CELL_MASS,TAU_MIX,&
                           PBAR_0,DELTA,VEL_RMS,EXTINCT,Q_REAC_2,SUB_IT,TOTAL_MIXED_MASS_2)

   IF (TOTAL_MIXED_MASS_2>TWO_EPSILON_EB) THEN
      ZZ_OUT = 0.5_EB*(ZZ_0*TOTAL_MIXED_MASS_0 + ZZ_2*TOTAL_MIXED_MASS_2)
      TOTAL_MIXED_MASS_OUT = SUM(ZZ_OUT)
      ZZ_OUT = ZZ_OUT/TOTAL_MIXED_MASS_OUT
   ELSE
      ZZ_OUT = ZZ_0
   ENDIF

   ZETA_OUT = MAX(0._EB,1._EB-TOTAL_MIXED_MASS_OUT/CELL_MASS)

   Q_REAC_OUT = Q_REAC_OUT + 0.5_EB*(Q_REAC_1+Q_REAC_2)

   ZZ_0 = ZZ_OUT
   ZETA_0 = ZETA_OUT
   TOTAL_MIXED_MASS_0 = TOTAL_MIXED_MASS_OUT
ENDDO

END SUBROUTINE FIRE_RK2


SUBROUTINE FIRE_RK3(ZZ_OUT,ZZ_IN,ZZ_UNMIXED,ZETA_OUT,ZETA_IN,DT_SUB,N_INC,TMP_MIXED,TMP_UNMIXED,RHO_HAT,CELL_MASS,TAU_MIX,&
                    PBAR_0,DELTA,VEL_RMS,EXTINCT,Q_REAC_OUT,SUB_IT,TOTAL_MIXED_MASS_OUT)

! This function uses SSP RK3.  See Gottlieb, Shu, Tadmor, SIAM Review, 2001.

REAL(EB), INTENT(IN) :: ZZ_IN(1:N_TRACKED_SPECIES),DT_SUB,ZETA_IN,RHO_HAT,ZZ_UNMIXED(1:N_TRACKED_SPECIES),CELL_MASS,&
                        TAU_MIX,PBAR_0,DELTA,VEL_RMS,TMP_UNMIXED
REAL(EB), INTENT(OUT) :: ZZ_OUT(1:N_TRACKED_SPECIES),ZETA_OUT,Q_REAC_OUT(1:N_REACTIONS),TOTAL_MIXED_MASS_OUT
REAL(EB), INTENT(INOUT) :: TMP_MIXED
INTEGER, INTENT(IN) :: N_INC,SUB_IT
LOGICAL, INTENT(IN) :: EXTINCT(1:N_REACTIONS)
REAL(EB) :: DT_LOC,TOTAL_MIXED_MASS_0,TOTAL_MIXED_MASS_1,TOTAL_MIXED_MASS_2,TOTAL_MIXED_MASS_3,&
            ZZ_0(1:N_TRACKED_SPECIES),ZZ_1(1:N_TRACKED_SPECIES),ZZ_2(1:N_TRACKED_SPECIES),ZZ_3(1:N_TRACKED_SPECIES),&
            ZETA_0,ZETA_1,ZETA_2,ZETA_3,&
            Q_REAC_1(1:N_REACTIONS),Q_REAC_2(1:N_REACTIONS),Q_REAC_3(1:N_REACTIONS)
INTEGER :: N

DT_LOC = DT_SUB/REAL(N_INC,EB) ! in principle, multiple increments could be used for Richardson extrapolation
ZZ_0 = ZZ_IN
ZETA_0 = ZETA_IN
Q_REAC_OUT(:) = 0._EB
TOTAL_MIXED_MASS_0 = (1._EB-ZETA_0)*CELL_MASS

INC_LOOP: DO N=1,N_INC

   CALL FIRE_FORWARD_EULER(ZZ_1,ZZ_0,ZZ_UNMIXED,ZETA_1,ZETA_0, DT_LOC, TMP_MIXED,TMP_UNMIXED,RHO_HAT,CELL_MASS,TAU_MIX,&
                           PBAR_0,DELTA,VEL_RMS,EXTINCT,Q_REAC_1,SUB_IT,TOTAL_MIXED_MASS_1)

   CALL FIRE_FORWARD_EULER(ZZ_2,ZZ_1,ZZ_UNMIXED,ZETA_2,ZETA_1, DT_LOC, TMP_MIXED,TMP_UNMIXED,RHO_HAT,CELL_MASS,TAU_MIX,&
                           PBAR_0,DELTA,VEL_RMS,EXTINCT,Q_REAC_2,SUB_IT,TOTAL_MIXED_MASS_2)

   IF (TOTAL_MIXED_MASS_2>TWO_EPSILON_EB) THEN
      ZZ_2 = 0.75_EB*ZZ_0*TOTAL_MIXED_MASS_0 + 0.25_EB*ZZ_2*TOTAL_MIXED_MASS_2
      ZZ_2 = ZZ_2/SUM(ZZ_2)
   ELSE
      ZZ_2 = ZZ_0
   ENDIF

   Q_REAC_2 = 0.25_EB * (Q_REAC_1 + Q_REAC_2)

   ZETA_2 = 0.75_EB*ZETA_0 + 0.25_EB*ZETA_2

   CALL FIRE_FORWARD_EULER(ZZ_3,ZZ_2,ZZ_UNMIXED,ZETA_3,ZETA_2, DT_LOC, TMP_MIXED,TMP_UNMIXED,RHO_HAT,CELL_MASS,TAU_MIX,&
                           PBAR_0,DELTA,VEL_RMS,EXTINCT,Q_REAC_3,SUB_IT,TOTAL_MIXED_MASS_3)

   IF (TOTAL_MIXED_MASS_3>TWO_EPSILON_EB) THEN
      ZZ_OUT = ONTH*ZZ_0*TOTAL_MIXED_MASS_0 + TWTH*ZZ_3*TOTAL_MIXED_MASS_3
      TOTAL_MIXED_MASS_OUT = SUM(ZZ_OUT)
      ZZ_OUT = ZZ_OUT/TOTAL_MIXED_MASS_OUT
   ELSE
      ZZ_OUT = ZZ_0
   ENDIF

   Q_REAC_OUT = Q_REAC_OUT + TWTH * (Q_REAC_2 + Q_REAC_3)

   ZETA_OUT = MAX(0._EB,1._EB-TOTAL_MIXED_MASS_OUT/CELL_MASS)

   ZZ_0 = ZZ_OUT
   ZETA_0 = ZETA_OUT
   TOTAL_MIXED_MASS_0 = TOTAL_MIXED_MASS_OUT

ENDDO INC_LOOP

END SUBROUTINE FIRE_RK3


SUBROUTINE REACTION_RATE(DZZ,ZZ_0,DT_SUB,RHO_0,TMP_0,KINETICS,PBAR_0,DELTA,VEL_RMS,EXTINCT,Q_REAC_OUT,SUB_IT)
USE COMP_FUNCTIONS, ONLY: SHUTDOWN
USE PHYSICAL_FUNCTIONS, ONLY : GET_MASS_FRACTION_ALL,GET_SPECIFIC_GAS_CONSTANT,GET_GIBBS_FREE_ENERGY,GET_MOLECULAR_WEIGHT
REAL(EB), INTENT(OUT) :: DZZ(1:N_TRACKED_SPECIES),Q_REAC_OUT(1:N_REACTIONS)
REAL(EB), INTENT(IN) :: ZZ_0(1:N_TRACKED_SPECIES),DT_SUB,RHO_0,TMP_0,PBAR_0,DELTA,VEL_RMS
INTEGER, INTENT(IN) :: KINETICS,SUB_IT
LOGICAL, INTENT(IN) :: EXTINCT(1:N_REACTIONS)
REAL(EB) :: DZ_F,YY_PRIMITIVE(1:N_SPECIES),DG_RXN,MW,MOLPCM3,DT_TMP(1:N_TRACKED_SPECIES),DT_MIN,DT_LOC,&
            ZZ_TMP(1:N_TRACKED_SPECIES),ZZ_NEW(1:N_TRACKED_SPECIES),Q_REAC_TMP(1:N_REACTIONS),AA,DTHETA
INTEGER :: I,NS,SUB_IT_USE,OUTER_IT
LOGICAL :: REACTANTS_PRESENT
INTEGER, PARAMETER :: INFINITELY_FAST=1,FINITE_RATE=2
TYPE(REACTION_TYPE), POINTER :: RN=>NULL()

ZZ_NEW = ZZ_0
Q_REAC_OUT = 0._EB
Q_REAC_TMP = 0._EB
SUB_IT_USE = SUB_IT ! keep this for debug

KINETICS_SELECT: SELECT CASE(KINETICS)

   CASE(INFINITELY_FAST)

      FAST_REAC_LOOP: DO OUTER_IT=1,N_REACTIONS
         ZZ_TMP = ZZ_NEW
         DZZ = 0._EB
         REACTANTS_PRESENT = .FALSE.
         REACTION_LOOP_1: DO I=1,N_REACTIONS
            IF (EXTINCT(I)) CYCLE REACTION_LOOP_1
            RN => REACTION(I)
            IF (.NOT.RN%FAST_CHEMISTRY) CYCLE REACTION_LOOP_1
            IF (RN%AIR_SMIX_INDEX > -1) THEN
               DZ_F = ZZ_TMP(RN%FUEL_SMIX_INDEX)*ZZ_TMP(RN%AIR_SMIX_INDEX) ! 2nd-order reaction
            ELSE
               DZ_F = ZZ_TMP(RN%FUEL_SMIX_INDEX) ! 1st-order
            ENDIF
            IF (DZ_F > TWO_EPSILON_EB) REACTANTS_PRESENT = .TRUE.
            DTHETA = FLAME_SPEED_FACTOR(ZZ_TMP,DT_LOC,RHO_0,TMP_0,PBAR_0,I,DELTA,VEL_RMS)
            AA = RN%A_PRIME_FAST * RHO_0**RN%RHO_EXPONENT_FAST * DTHETA
            DZZ = DZZ + AA * RN%NU_MW_O_MW_F * DZ_F
            Q_REAC_TMP(I) = RN%HEAT_OF_COMBUSTION * AA * DZ_F
         ENDDO REACTION_LOOP_1
         IF (REACTANTS_PRESENT) THEN
            DT_TMP = HUGE_EB
            DO NS = 1,N_TRACKED_SPECIES
               IF (DZZ(NS) < 0._EB) DT_TMP(NS) = -ZZ_TMP(NS)/DZZ(NS)
            ENDDO
            DT_MIN = MINVAL(DT_TMP)
            ZZ_NEW = ZZ_TMP + DZZ*DT_MIN
            Q_REAC_OUT = Q_REAC_OUT + Q_REAC_TMP*DT_MIN
         ELSE
            EXIT FAST_REAC_LOOP
         ENDIF
      ENDDO FAST_REAC_LOOP
      DZZ = ZZ_NEW - ZZ_0

   CASE(FINITE_RATE)

      DT_LOC = DT_SUB
      SLOW_REAC_LOOP: DO OUTER_IT=1,N_REACTIONS
         ZZ_TMP = ZZ_NEW
         DZZ = 0._EB
         REACTANTS_PRESENT = .FALSE.
         REACTION_LOOP_2: DO I=1,N_REACTIONS
            RN => REACTION(I)
            IF (RN%FAST_CHEMISTRY) CYCLE REACTION_LOOP_2
            IF (ZZ_TMP(RN%FUEL_SMIX_INDEX) < ZZ_MIN_GLOBAL) CYCLE REACTION_LOOP_2
            IF (RN%AIR_SMIX_INDEX > -1) THEN
               IF (ZZ_TMP(RN%AIR_SMIX_INDEX) < ZZ_MIN_GLOBAL) CYCLE REACTION_LOOP_2 ! no expected air
            ENDIF
            CALL GET_MASS_FRACTION_ALL(ZZ_TMP,YY_PRIMITIVE)
            DO NS=1,N_SPECIES
               IF(RN%N_S(NS) > -998._EB .AND. YY_PRIMITIVE(NS) < ZZ_MIN_GLOBAL) CYCLE REACTION_LOOP_2
            ENDDO
            DZ_F = RN%A_PRIME*RHO_0**RN%RHO_EXPONENT*TMP_0**RN%N_T*EXP(-RN%E/(R0*TMP_0)) ! dZ/dt, FDS Tech Guide, Eq. (5.49)
            DO NS=1,N_SPECIES
               IF(RN%N_S(NS) > -998._EB)  DZ_F = YY_PRIMITIVE(NS)**RN%N_S(NS)*DZ_F
            ENDDO
            IF (RN%THIRD_BODY) THEN
               CALL GET_MOLECULAR_WEIGHT(ZZ_TMP,MW)
               MOLPCM3 = RHO_0/MW*0.001_EB ! mol/cm^3
               DZ_F = DZ_F * MOLPCM3
            ENDIF
            IF(RN%REVERSE) THEN ! compute equilibrium constant
               CALL GET_GIBBS_FREE_ENERGY(DG_RXN,RN%NU,TMP_0)
               RN%K = EXP(-DG_RXN/(R0*TMP_0))
               DZ_F = DZ_F/RN%K
            ENDIF
            IF (DZ_F > TWO_EPSILON_EB) REACTANTS_PRESENT = .TRUE.
            Q_REAC_OUT(I) = RN%HEAT_OF_COMBUSTION*DZ_F*DT_LOC
            DZZ = DZZ + RN%NU_MW_O_MW_F*DZ_F*DT_LOC/RN%K
         ENDDO REACTION_LOOP_2
         IF (REACTANTS_PRESENT) THEN
            DT_TMP = HUGE_EB
            DO NS = 1,N_TRACKED_SPECIES
               IF (DZZ(NS) < 0._EB) DT_TMP(NS) = -ZZ_TMP(NS)/DZZ(NS)
            ENDDO
            ! Think of DT_MIN as the fraction of DT_LOC we can take and remain bounded.
            DT_MIN = MIN(1._EB,MINVAL(DT_TMP))
            DT_LOC = DT_LOC*(1._EB-DT_MIN)
            ZZ_NEW = ZZ_TMP + DZZ*DT_MIN
            Q_REAC_OUT = Q_REAC_OUT + Q_REAC_TMP*DT_MIN
            IF (DT_LOC<TWO_EPSILON_EB) EXIT SLOW_REAC_LOOP
         ELSE
            EXIT SLOW_REAC_LOOP
         ENDIF
      ENDDO SLOW_REAC_LOOP
      DZZ = ZZ_NEW - ZZ_0

END SELECT KINETICS_SELECT

END SUBROUTINE REACTION_RATE


SUBROUTINE GET_EXTINCT(EXTINCT,ZZ_MIXED_IN,TMP_MIXED,TAU_RES,AIT_LOC)
LOGICAL, INTENT(INOUT) :: EXTINCT(1:N_REACTIONS)
REAL(EB), INTENT(IN) :: ZZ_MIXED_IN(1:N_TRACKED_SPECIES),TMP_MIXED,TAU_RES,AIT_LOC
LOGICAL :: FUNC_EXTINCT
INTEGER :: I
TYPE(REACTION_TYPE), POINTER :: RN=>NULL()

EXTINCT=.FALSE.
FUNC_EXTINCT=.FALSE.
IF (ANY(REACTION(:)%FAST_CHEMISTRY)) THEN
   SELECT CASE (EXTINCT_MOD)
      CASE(EXTINCTION_1)
         FUNC_EXTINCT = EXTINCT_1(ZZ_MIXED_IN,TMP_MIXED,AIT_LOC)
         EXTINCT      = FUNC_EXTINCT
      CASE(EXTINCTION_2)
         FUNC_EXTINCT = EXTINCT_2(ZZ_MIXED_IN,TMP_MIXED,AIT_LOC)
         EXTINCT      = FUNC_EXTINCT
      CASE(EXTINCTION_3) ! experimental
         EXTINCT      = EXTINCT_3(ZZ_MIXED_IN,TMP_MIXED,AIT_LOC)
      CASE(EXTINCTION_4) ! experimental
         FUNC_EXTINCT = EXTINCT_4(ZZ_MIXED_IN,TMP_MIXED,TAU_RES)
         EXTINCT      = FUNC_EXTINCT
   END SELECT
ENDIF

! Process alternate reactin pathways signaled by ALT_REAC_ID
DO I = 1,N_REACTIONS
   RN => REACTION(I)
   IF (RN%ALT_INDEX>0) THEN
      SELECT CASE (EXTINCT(RN%ALT_INDEX))
         CASE(.TRUE. ); EXTINCT(I)=.FALSE.
         CASE(.FALSE.); EXTINCT(I)=.TRUE.
      END SELECT
   ENDIF
ENDDO

END SUBROUTINE GET_EXTINCT


LOGICAL FUNCTION EXTINCT_1(ZZ_IN,TMP_MIXED,AIT_IN)
USE PHYSICAL_FUNCTIONS,ONLY:GET_AVERAGE_SPECIFIC_HEAT
REAL(EB),INTENT(IN)::ZZ_IN(1:N_TRACKED_SPECIES),TMP_MIXED,AIT_IN
REAL(EB):: Y_O2,Y_O2_CRIT,CPBAR,AIT_LOC
INTEGER :: NR
TYPE(REACTION_TYPE),POINTER :: RN=>NULL()

EXTINCT_1 = .FALSE.
REACTION_LOOP: DO NR=1,N_REACTIONS
   RN => REACTION(NR)
   IF (.NOT.RN%FAST_CHEMISTRY) CYCLE REACTION_LOOP

   IF (AIT_IN < 1.E10_EB) THEN
      AIT_LOC = AIT_IN
   ELSE
      AIT_LOC = RN%AUTO_IGNITION_TEMPERATURE
   ENDIF

   AIT_IF: IF ( TMP_MIXED < AIT_LOC ) THEN
      EXTINCT_1 = .TRUE.
   ELSE AIT_IF
      CALL GET_AVERAGE_SPECIFIC_HEAT(ZZ_IN,CPBAR,TMP_MIXED)
      Y_O2 = ZZ_IN(RN%AIR_SMIX_INDEX)
      Y_O2_CRIT = CPBAR*(RN%CRIT_FLAME_TMP-TMP_MIXED)/RN%EPUMO2
      IF (Y_O2 < Y_O2_CRIT) EXTINCT_1 = .TRUE.
   ENDIF AIT_IF
ENDDO REACTION_LOOP

END FUNCTION EXTINCT_1


LOGICAL FUNCTION EXTINCT_2(ZZ_MIXED_IN,TMP_MIXED,AIT_IN)
USE PHYSICAL_FUNCTIONS,ONLY:GET_SENSIBLE_ENTHALPY
REAL(EB),INTENT(IN) :: ZZ_MIXED_IN(1:N_TRACKED_SPECIES),TMP_MIXED,AIT_IN
REAL(EB):: ZZ_F,ZZ_HAT_F,ZZ_GET_F(1:N_TRACKED_SPECIES),ZZ_A,ZZ_HAT_A,ZZ_GET_A(1:N_TRACKED_SPECIES),ZZ_P,ZZ_HAT_P,&
           ZZ_GET_P(1:N_TRACKED_SPECIES),H_F_0,H_A_0,H_P_0,H_F_N,H_A_N,H_P_N,AIT_LOC
INTEGER :: NR
TYPE(REACTION_TYPE),POINTER :: RN=>NULL()

EXTINCT_2 = .FALSE.
REACTION_LOOP: DO NR=1,N_REACTIONS
   RN => REACTION(NR)
   IF (.NOT.RN%FAST_CHEMISTRY) CYCLE REACTION_LOOP

   IF (AIT_IN < 1.E10_EB) THEN
      AIT_LOC = AIT_IN
   ELSE
      AIT_LOC = RN%AUTO_IGNITION_TEMPERATURE
   ENDIF

   AIT_IF: IF ( TMP_MIXED < AIT_LOC ) THEN
      EXTINCT_2 = .TRUE.
   ELSE AIT_IF
      ZZ_F = ZZ_MIXED_IN(RN%FUEL_SMIX_INDEX)
      ZZ_A = ZZ_MIXED_IN(RN%AIR_SMIX_INDEX)
      ZZ_P = 1._EB - ZZ_F - ZZ_A

      ZZ_HAT_F = MIN(ZZ_F,ZZ_MIXED_IN(RN%AIR_SMIX_INDEX)/RN%S) ! burned fuel, FDS Tech Guide (5.16)
      ZZ_HAT_A = ZZ_HAT_F*RN%S ! FDS Tech Guide (5.17)
      ZZ_HAT_P = (ZZ_HAT_A/(ZZ_A+TWO_EPSILON_EB))*(ZZ_F - ZZ_HAT_F + ZZ_P) ! reactant diluent concentration, FDS Tech Guide (5.18)

      ! "GET" indicates a composition vector.  Below we are building up the masses of the constituents in the various
      ! mixtures.  At this point these composition vectors are not normalized.

      ZZ_GET_F = 0._EB
      ZZ_GET_A = 0._EB
      ZZ_GET_P = ZZ_MIXED_IN

      ZZ_GET_F(RN%FUEL_SMIX_INDEX) = ZZ_HAT_F ! fuel in reactant mixture composition
      ZZ_GET_A(RN%AIR_SMIX_INDEX)  = ZZ_HAT_A ! air  in reactant mixture composition

      ZZ_GET_P(RN%FUEL_SMIX_INDEX) = MAX(ZZ_GET_P(RN%FUEL_SMIX_INDEX)-ZZ_HAT_F,0._EB) ! remove burned fuel from product composition
      ZZ_GET_P(RN%AIR_SMIX_INDEX)  = MAX(ZZ_GET_P(RN%AIR_SMIX_INDEX) -ZZ_A,0._EB) ! remove all air from product composition

      ! Normalize concentrations
      ZZ_GET_F = ZZ_GET_F/(SUM(ZZ_GET_F)+TWO_EPSILON_EB)
      ZZ_GET_A = ZZ_GET_A/(SUM(ZZ_GET_A)+TWO_EPSILON_EB)
      ZZ_GET_P = ZZ_GET_P/(SUM(ZZ_GET_P)+TWO_EPSILON_EB)

      ! Get the specific heat for the fuel and diluent at the current and critical flame temperatures
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET_F,H_F_0,TMP_MIXED)
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET_A,H_A_0,TMP_MIXED)
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET_P,H_P_0,TMP_MIXED)
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET_F,H_F_N,RN%CRIT_FLAME_TMP)
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET_A,H_A_N,RN%CRIT_FLAME_TMP)
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET_P,H_P_N,RN%CRIT_FLAME_TMP)

      ! See if enough energy is released to raise the fuel and required "air" temperatures above the critical flame temp.
      IF ( ZZ_HAT_F*(H_F_0 + RN%HEAT_OF_COMBUSTION) + ZZ_HAT_A*H_A_0 + ZZ_HAT_P*H_P_0 < &
         ZZ_HAT_F*H_F_N  + ZZ_HAT_A*H_A_N + ZZ_HAT_P*H_P_N ) EXTINCT_2 = .TRUE. ! FDS Tech Guide (5.19)
   ENDIF AIT_IF

ENDDO REACTION_LOOP

END FUNCTION EXTINCT_2


FUNCTION EXTINCT_3(ZZ_MIXED_IN,TMP_MIXED,AIT_IN)
USE PHYSICAL_FUNCTIONS,ONLY:GET_SENSIBLE_ENTHALPY

LOGICAL, DIMENSION(1:N_REACTIONS) :: EXTINCT_3
REAL(EB),INTENT(IN) :: ZZ_MIXED_IN(1:N_TRACKED_SPECIES),TMP_MIXED,AIT_IN
REAL(EB):: ZZ_F,ZZ_HAT_F,ZZ_GET_F(1:N_TRACKED_SPECIES),ZZ_A,ZZ_HAT_A,ZZ_GET_A(1:N_TRACKED_SPECIES),ZZ_P,ZZ_HAT_P,&
           ZZ_GET_P(1:N_TRACKED_SPECIES),H_F_0,H_A_0,H_P_0,H_F_N,H_A_N,H_P_N,AIT_LOC
INTEGER :: NR
TYPE(REACTION_TYPE),POINTER :: RN=>NULL()

EXTINCT_3 = .FALSE.
REACTION_LOOP: DO NR=1,N_REACTIONS
   RN => REACTION(NR)
   IF (.NOT.RN%FAST_CHEMISTRY) CYCLE REACTION_LOOP

   IF (AIT_IN < 1.E10_EB) THEN
      AIT_LOC = AIT_IN
   ELSE
      AIT_LOC = RN%AUTO_IGNITION_TEMPERATURE
   ENDIF

   AIT_IF: IF ( TMP_MIXED < AIT_LOC ) THEN
      EXTINCT_3(NR) = .TRUE.
   ELSE AIT_IF
      ZZ_F = ZZ_MIXED_IN(RN%FUEL_SMIX_INDEX)
      ZZ_A = ZZ_MIXED_IN(RN%AIR_SMIX_INDEX)
      ZZ_P = 1._EB - ZZ_F - ZZ_A

      ZZ_HAT_F = MIN(ZZ_F,ZZ_MIXED_IN(RN%AIR_SMIX_INDEX)/RN%S) ! burned fuel, FDS Tech Guide (5.16)
      ZZ_HAT_A = ZZ_HAT_F*RN%S ! FDS Tech Guide (5.17)
      ZZ_HAT_P = (ZZ_HAT_A/(ZZ_A+TWO_EPSILON_EB))*(ZZ_F - ZZ_HAT_F + ZZ_P) ! reactant diluent concentration, FDS Tech Guide (5.18)

      ! "GET" indicates a composition vector.  Below we are building up the masses of the constituents in the various
      ! mixtures.  At this point these composition vectors are not normalized.

      ZZ_GET_F = 0._EB
      ZZ_GET_A = 0._EB
      ZZ_GET_P = ZZ_MIXED_IN

      ZZ_GET_F(RN%FUEL_SMIX_INDEX) = ZZ_HAT_F ! fuel in reactant mixture composition
      ZZ_GET_A(RN%AIR_SMIX_INDEX)  = ZZ_HAT_A ! air  in reactant mixture composition

      ZZ_GET_P(RN%FUEL_SMIX_INDEX) = MAX(ZZ_GET_P(RN%FUEL_SMIX_INDEX)-ZZ_HAT_F,0._EB) ! remove burned fuel from product composition
      ZZ_GET_P(RN%AIR_SMIX_INDEX)  = MAX(ZZ_GET_P(RN%AIR_SMIX_INDEX) -ZZ_A,0._EB) ! remove all air from product composition

      ! Normalize concentrations
      ZZ_GET_F = ZZ_GET_F/(SUM(ZZ_GET_F)+TWO_EPSILON_EB)
      ZZ_GET_A = ZZ_GET_A/(SUM(ZZ_GET_A)+TWO_EPSILON_EB)
      ZZ_GET_P = ZZ_GET_P/(SUM(ZZ_GET_P)+TWO_EPSILON_EB)

      ! Get the specific heat for the fuel and diluent at the current and critical flame temperatures
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET_F,H_F_0,TMP_MIXED)
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET_A,H_A_0,TMP_MIXED)
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET_P,H_P_0,TMP_MIXED)
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET_F,H_F_N,RN%CRIT_FLAME_TMP)
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET_A,H_A_N,RN%CRIT_FLAME_TMP)
      CALL GET_SENSIBLE_ENTHALPY(ZZ_GET_P,H_P_N,RN%CRIT_FLAME_TMP)

      ! See if enough energy is released to raise the fuel and required "air" temperatures above the critical flame temp.
      IF ( ZZ_HAT_F*(H_F_0 + RN%HEAT_OF_COMBUSTION) + ZZ_HAT_A*H_A_0 + ZZ_HAT_P*H_P_0 < &
           ZZ_HAT_F*H_F_N                           + ZZ_HAT_A*H_A_N + ZZ_HAT_P*H_P_N ) THEN
         EXTINCT_3(NR) = .TRUE. ! FDS Tech Guide (5.19)
      ENDIF
   ENDIF AIT_IF

ENDDO REACTION_LOOP

END FUNCTION EXTINCT_3


LOGICAL FUNCTION EXTINCT_4(ZZ_MIXED_IN,TMP_MIXED,TAU_RES)
! Vaidya Sankaran, UTRC, 2014 (experimental)

USE PHYSICAL_FUNCTIONS,ONLY:GET_SENSIBLE_ENTHALPY
REAL(EB),INTENT(IN)::ZZ_MIXED_IN(0:N_TRACKED_SPECIES),TMP_MIXED,TAU_RES
REAL(EB):: ZZ_F,ZZ_HAT_F,ZZ_GET_F(0:N_TRACKED_SPECIES),ZZ_A,ZZ_HAT_A,ZZ_GET_A(0:N_TRACKED_SPECIES),ZZ_P,ZZ_HAT_P,&
           ZZ_GET_P(0:N_TRACKED_SPECIES),H_F_0,H_A_0,H_P_0,H_F_N,H_A_N,H_P_N
INTEGER :: NR,NS
TYPE(REACTION_TYPE),POINTER :: RN=>NULL()

TYPE (SPECIES_MIXTURE_TYPE), POINTER :: SM
REAL(EB) :: TAU_CHEM,YN2,YCO,YH2O,YCO2,addN2,fprod,fN2,fCO2,fH2O,YDIL_NORM
REAL(EB) :: MWN2,MWO2,MWCO,MWCO2,MWH2O
INTEGER  :: IDN2,IDO2,IDCO,IDCO2,IDH2O

EXTINCT_4 = .FALSE.
REACTION_LOOP: DO NR=1,N_REACTIONS
   RN => REACTION(NR)
   IF (.NOT.RN%FAST_CHEMISTRY) CYCLE REACTION_LOOP

   AIT_IF: IF (TMP_MIXED < RN%AUTO_IGNITION_TEMPERATURE) THEN

      EXTINCT_4 = .TRUE.

   ELSE AIT_IF

      ZZ_F = ZZ_MIXED_IN(RN%FUEL_SMIX_INDEX)
      ZZ_A = ZZ_MIXED_IN(RN%AIR_SMIX_INDEX)
      ZZ_P = 1._EB - ZZ_F - ZZ_A

      ZZ_HAT_F = MIN(ZZ_F,ZZ_MIXED_IN(RN%AIR_SMIX_INDEX)/RN%S)             ! burned fuel, FDS Tech Guide (5.16)
      ZZ_HAT_A = ZZ_HAT_F*RN%S                                             ! FDS Tech Guide (5.17)
      ZZ_HAT_P = (ZZ_HAT_A/(ZZ_A+TWO_EPSILON_EB))*(ZZ_F - ZZ_HAT_F + ZZ_P) ! reactant diluent concentration, FDS Tech Guide (5.18)

      MWCO2 = 1.0_EB ; MWH2O = 1.0_EB ; MWCO = 1.0_EB
      YCO2  = 0.0_EB ;  YH2O = 0.0_EB ;  YCO = 0.0_EB
      DO NS = 0,N_TRACKED_SPECIES
         SM => SPECIES_MIXTURE(NS)
         SELECT CASE(TRIM(SM%ID))
            CASE('NITROGEN')
               IDN2 = NS
               MWN2 = SM%MW
               YN2  = ZZ_MIXED_IN(IDN2)
            CASE('OXYGEN')
               IDO2 = NS
               MWO2 = SM%MW
            CASE('CARBON MONOXIDE')
               IDCO = NS
               MWCO = SM%MW
               YCO  = ZZ_MIXED_IN(IDCO)
            CASE('WATER VAPOR')
               IDH2O = NS
               MWH2O = SM%MW
               YH2O  = ZZ_MIXED_IN(IDH2O)
            CASE('CARBON DIOXIDE')
               IDCO2 = NS
               MWCO2 = SM%MW
               YCO2  = ZZ_MIXED_IN(IDCO2)
         END SELECT
      ENDDO

      !Added nitrogen = Total N2 - N2 associated with left over O2 - N2 in the combustion products
      !N2_associated with o2 in AIR = (0.77/0.23)*(ZZ_A)
      !N2_in_comb_prod =   (0.77/0.23)*(ZZ_A + YCO*0.5_EB*MWO2/MWCO + YH2O*0.5_EB*MWO2/MWH2O + YCO2*MWO2/MWCO2)
      ADDN2  = YN2 - (0.77_EB/0.23_EB)*(ZZ_A + YCO*0.5_EB*MWO2/MWCO + YH2O*0.5_EB*MWO2/MWH2O + YCO2*MWO2/MWCO2)
      ADDN2  = MAX(ADDN2,0._EB)

      !fraction of the products+diluent in the reaction zone
      FPROD = (ZZ_HAT_A/(ZZ_A+TWO_EPSILON_EB))
      !fraction of the added nitrogen in the reaction zone
      FN2  = FPROD*ADDN2
      !fraction of the combustion product CO2 in the reaction zone
      FCO2 = FPROD*ZZ_MIXED_IN(IDCO2)
      !fraction of the combustion product H2O in the reaction zone
      FH2O = FPROD*ZZ_MIXED_IN(IDH2O)
      !normalized mass-fraction of N2 and combustion products
      YDIL_NORM = FN2/0.412_EB + FCO2/0.375_EB + FH2O/0.227_EB

      EXT_CRIT_12: IF (YDIL_NORM > 1._EB) THEN

         ! 1st criterion: UTRC, 2014
         EXTINCT_4 = .TRUE.

      ELSE EXT_CRIT_12

         !TAU_RES  = MU(I,J,K)/(0.5_EB*RHO(I,J,K)*(U(I,J,K)**2+V(I,J,K)**2+W(I,J,K)**2))
         TAU_CHEM = 0.069_EB*EXP(2.48_EB*YDIL_NORM)*0.001_EB

         EXT_CRIT_23: IF (TAU_CHEM > TAU_RES) THEN
            ! 2nd criterion: UTRC, 2014
            EXTINCT_4 = .TRUE.
         ELSE EXT_CRIT_23
            ! 3rd criterion based on computed Critical Flame Temperature: UTRC, 2014

            ZZ_GET_F = 0._EB
            ZZ_GET_A = 0._EB
            ZZ_GET_P = ZZ_MIXED_IN

            ZZ_GET_F(RN%FUEL_SMIX_INDEX) = ZZ_HAT_F ! fuel in reactant mixture composition
            ZZ_GET_A(RN%AIR_SMIX_INDEX)  = ZZ_HAT_A ! air  in reactant mixture composition

            ZZ_GET_P(RN%FUEL_SMIX_INDEX) = MAX(ZZ_GET_P(RN%FUEL_SMIX_INDEX)-ZZ_HAT_F,0._EB) ! remove burned fuel from products
            ZZ_GET_P(RN%AIR_SMIX_INDEX)  = MAX(ZZ_GET_P(RN%AIR_SMIX_INDEX) -ZZ_A    ,0._EB) ! remove all air from products

            ! Normalize concentrations
            ZZ_GET_F = ZZ_GET_F/(SUM(ZZ_GET_F)+TWO_EPSILON_EB)
            ZZ_GET_A = ZZ_GET_A/(SUM(ZZ_GET_A)+TWO_EPSILON_EB)
            ZZ_GET_P = ZZ_GET_P/(SUM(ZZ_GET_P)+TWO_EPSILON_EB)

            RN%CRIT_FLAME_TMP=1464.386823_EB*(TAU_RES*1000.0_EB)**(-0.053780_EB)

            ! Equation for water-vapor
            IF(YH2O > 0.0) THEN
             RN%CRIT_FLAME_TMP=(1._EB-YH2O)*RN%CRIT_FLAME_TMP + (YH2O)*1545.118849_EB*(TAU_RES*1000.0_EB)**(-0.033793_EB)
            ENDIF

            IF(RN%CRIT_FLAME_TMP<=1450._EB) RN%CRIT_FLAME_TMP=1450._EB   ! lower limit T_CFT for most hydro-carbons
            IF(RN%CRIT_FLAME_TMP>=1800._EB) RN%CRIT_FLAME_TMP=1800._EB   ! upper limit T_CFT for most hydro-carbons

            ! Get the specific heat for the fuel and diluent at the current and critical flame temperatures
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET_F,H_F_0,TMP_MIXED)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET_A,H_A_0,TMP_MIXED)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET_P,H_P_0,TMP_MIXED)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET_F,H_F_N,RN%CRIT_FLAME_TMP)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET_A,H_A_N,RN%CRIT_FLAME_TMP)
            CALL GET_SENSIBLE_ENTHALPY(ZZ_GET_P,H_P_N,RN%CRIT_FLAME_TMP)

            ! See if enough energy is released to raise the fuel and required "air" temperatures above the critical flame temp
            IF ( ZZ_HAT_F*(H_F_0 + RN%HEAT_OF_COMBUSTION) + ZZ_HAT_A*H_A_0 + ZZ_HAT_P*H_P_0 < &
                 ZZ_HAT_F* H_F_N + ZZ_HAT_A*H_A_N + ZZ_HAT_P*H_P_N ) THEN
               EXTINCT_4 = .TRUE.
            ENDIF

         ENDIF EXT_CRIT_23
      ENDIF EXT_CRIT_12
   ENDIF AIT_IF

ENDDO REACTION_LOOP

END FUNCTION EXTINCT_4


REAL(EB) FUNCTION FLAME_SPEED_FACTOR(ZZ_0,DT_LOC,RHO_0,TMP_0,PBAR_0,NR,DELTA,VEL_RMS)
USE PHYSICAL_FUNCTIONS, ONLY : GET_SENSIBLE_ENTHALPY,GET_SPECIFIC_GAS_CONSTANT,GET_SPECIFIC_HEAT
REAL(EB), INTENT(IN) :: ZZ_0(1:N_TRACKED_SPECIES),RHO_0,TMP_0,PBAR_0,DT_LOC,DELTA,VEL_RMS
INTEGER, INTENT(IN) :: NR
TYPE(REACTION_TYPE),POINTER :: RN=>NULL()
REAL(EB) :: DZ_F,ZZ_B(1:N_TRACKED_SPECIES),TMP_B,H_S_B,RHO_B,H_S_0,RSUM_B,PHI,S_L,S_T,H_NEW,TMP_2,CP_B
INTEGER :: IT
! REAL(EB) :: DPHI ! debug

FLAME_SPEED_FACTOR = 1._EB

RN=>REACTION(NR)
IF (RN%FLAME_SPEED<0._EB) RETURN

! equivalence ratio of unburnt mixture
PHI = RN%S*ZZ_0(RN%FUEL_SMIX_INDEX)/ZZ_0(RN%AIR_SMIX_INDEX)

! burnt composition
DZ_F = MIN(ZZ_0(RN%FUEL_SMIX_INDEX),ZZ_0(RN%AIR_SMIX_INDEX)/RN%S)
ZZ_B = ZZ_0 + RN%NU_MW_O_MW_F*DZ_F
ZZ_B = MIN(1._EB,MAX(0._EB,ZZ_B))

! find burnt zone temperature
CALL GET_SENSIBLE_ENTHALPY(ZZ_0,H_S_0,TMP_0)
H_NEW = H_S_0 + (1._EB-RN%CHI_R)*DZ_F*RN%HEAT_OF_COMBUSTION
TMP_B = TMP_0
TMP_2 = TMP_B

DO IT=1,10
   CALL GET_SENSIBLE_ENTHALPY(ZZ_B,H_S_B,TMP_B)
   CALL GET_SPECIFIC_HEAT(ZZ_B,CP_B,TMP_B)
   TMP_B = TMP_B+(H_NEW - H_S_B)/CP_B
   ! < 10 K error for determining flame speed is sufficient
   IF(ABS(TMP_2-TMP_B)<10._EB) EXIT
   TMP_2 = TMP_B
ENDDO

! compute burnt zone density
CALL GET_SPECIFIC_GAS_CONSTANT(ZZ_B,RSUM_B)
RHO_B = PBAR_0/(RSUM_B*TMP_B)

! get turbulent flame speed

! ! (debug) check laminar flame speed ramp
! PHI = 0._EB
! DPHI = .1_EB
! DO IT=1,20
!    PHI = PHI+DPHI
!    S_L = LAMINAR_FLAME_SPEED(TMP_0,PHI,NR)
!    print *,PHI,S_L
! ENDDO
! stop

S_L = LAMINAR_FLAME_SPEED(TMP_0,PHI,NR)

IF (S_L<TWO_EPSILON_EB) THEN
   FLAME_SPEED_FACTOR = 0._EB
ELSE
   S_T = MAX( S_L, S_L*( 1._EB + RN%TURBULENT_FLAME_SPEED_ALPHA*(VEL_RMS/S_L)**RN%TURBULENT_FLAME_SPEED_EXPONENT ) )
   FLAME_SPEED_FACTOR = RHO_B/RHO_0 * S_T * DT_LOC/DELTA
ENDIF

END FUNCTION FLAME_SPEED_FACTOR


REAL(EB) FUNCTION LAMINAR_FLAME_SPEED(TMP,EQ,NR)
USE MATH_FUNCTIONS, ONLY: EVALUATE_RAMP, INTERPOLATE2D
REAL(EB), INTENT(IN) :: TMP,EQ
INTEGER, INTENT(IN) :: NR
TYPE(REACTION_TYPE),POINTER :: RN=>NULL()

RN=>REACTION(NR)

IF (RN%TABLE_FS_INDEX>0) THEN
   CALL INTERPOLATE2D(RN%TABLE_FS_INDEX,EQ,TMP,LAMINAR_FLAME_SPEED)
ELSE
   LAMINAR_FLAME_SPEED = RN%FLAME_SPEED*(TMP/RN%FLAME_SPEED_TEMPERATURE)**RN%FLAME_SPEED_EXPONENT &
                         *EVALUATE_RAMP(EQ,0._EB,RN%RAMP_FS_INDEX)
ENDIF

END FUNCTION LAMINAR_FLAME_SPEED


SUBROUTINE ZETA_PRODUCTION(DT)
USE MASS, ONLY: SCALAR_FACE_VALUE

REAL(EB), INTENT(IN) :: DT
INTEGER :: I,J,K,IIG,JJG,KKG,IOR,IW,II,JJ,KK
REAL(EB) :: Z_F,DENOM,ZZZ(1:4),DZDX,DZDY,DZDZ
REAL(EB), POINTER, DIMENSION(:,:,:) :: ZFX=>NULL(),ZFY=>NULL(),ZFZ=>NULL(),ZZP=>NULL(),UU=>NULL(),VV=>NULL(),WW=>NULL()
TYPE(WALL_TYPE), POINTER :: WC=>NULL()

ZFX =>WORK1
ZFY =>WORK2
ZFZ =>WORK3
ZZP =>WORK4

UU=>U
VV=>V
WW=>W

!$OMP PARALLEL PRIVATE(ZZZ)
!$OMP DO SCHEDULE(STATIC)
DO K=0,KBP1
   DO J=0,JBP1
      DO I=0,IBP1
         ZZP(I,J,K) = ZZ(I,J,K,REACTION(1)%FUEL_SMIX_INDEX)
      ENDDO
   ENDDO
ENDDO
!$OMP END DO

! Compute scalar face values

!$OMP DO SCHEDULE(STATIC)
DO K=1,KBAR
   DO J=1,JBAR
      DO I=1,IBM1
         ZZZ(1:4) = ZZP(I-1:I+2,J,K)
         ZFX(I,J,K) = SCALAR_FACE_VALUE(UU(I,J,K),ZZZ,FLUX_LIMITER)
      ENDDO
   ENDDO
ENDDO
!$OMP END DO NOWAIT

!$OMP DO SCHEDULE(STATIC)
DO K=1,KBAR
   DO J=1,JBM1
      DO I=1,IBAR
         ZZZ(1:4) = ZZP(I,J-1:J+2,K)
         ZFY(I,J,K) = SCALAR_FACE_VALUE(VV(I,J,K),ZZZ,FLUX_LIMITER)
      ENDDO
   ENDDO
ENDDO
!$OMP END DO NOWAIT

!$OMP DO SCHEDULE(STATIC)
DO K=1,KBM1
   DO J=1,JBAR
      DO I=1,IBAR
         ZZZ(1:4) = ZZP(I,J,K-1:K+2)
         ZFZ(I,J,K) = SCALAR_FACE_VALUE(WW(I,J,K),ZZZ,FLUX_LIMITER)
      ENDDO
   ENDDO
ENDDO
!$OMP END DO
!$OMP END PARALLEL

WALL_LOOP_2: DO IW=1,N_EXTERNAL_WALL_CELLS+N_INTERNAL_WALL_CELLS
   WC=>WALL(IW)
   IF (WC%BOUNDARY_TYPE==NULL_BOUNDARY) CYCLE WALL_LOOP_2

   II  = WC%ONE_D%II
   JJ  = WC%ONE_D%JJ
   KK  = WC%ONE_D%KK
   IIG = WC%ONE_D%IIG
   JJG = WC%ONE_D%JJG
   KKG = WC%ONE_D%KKG
   IOR = WC%ONE_D%IOR

   Z_F = WC%ZZ_F(REACTION(1)%FUEL_SMIX_INDEX)

   SELECT CASE(IOR)
      CASE( 1); ZFX(IIG-1,JJG,KKG) = Z_F
      CASE(-1); ZFX(IIG,JJG,KKG)   = Z_F
      CASE( 2); ZFY(IIG,JJG-1,KKG) = Z_F
      CASE(-2); ZFY(IIG,JJG,KKG)   = Z_F
      CASE( 3); ZFZ(IIG,JJG,KKG-1) = Z_F
      CASE(-3); ZFZ(IIG,JJG,KKG)   = Z_F
   END SELECT

   ! Overwrite first off-wall advective flux if flow is away from the wall and if the face is not also a wall cell

   OFF_WALL_IF_2: IF (WC%BOUNDARY_TYPE/=INTERPOLATED_BOUNDARY .AND. WC%BOUNDARY_TYPE/=OPEN_BOUNDARY) THEN

      OFF_WALL_SELECT_2: SELECT CASE(IOR)
         CASE( 1) OFF_WALL_SELECT_2
            !      ghost          FX/UU(II+1)
            ! ///   II   ///  II+1  |  II+2  | ...
            !                       ^ WALL_INDEX(II+1,+1)
            IF ((UU(II+1,JJ,KK)>0._EB) .AND. .NOT.(WALL_INDEX(CELL_INDEX(II+1,JJ,KK),+1)>0)) THEN
               ZZZ(1:3) = (/Z_F,ZZP(II+1:II+2,JJ,KK)/)
               ZFX(II+1,JJ,KK) = SCALAR_FACE_VALUE(UU(II+1,JJ,KK),ZZZ,FLUX_LIMITER)
            ENDIF
         CASE(-1) OFF_WALL_SELECT_2
            !            FX/UU(II-2)     ghost
            ! ... |  II-2  |  II-1  ///   II   ///
            !              ^ WALL_INDEX(II-1,-1)
            IF ((UU(II-2,JJ,KK)<0._EB) .AND. .NOT.(WALL_INDEX(CELL_INDEX(II-1,JJ,KK),-1)>0)) THEN
               ZZZ(2:4) = (/ZZP(II-2:II-1,JJ,KK),Z_F/)
               ZFX(II-2,JJ,KK) = SCALAR_FACE_VALUE(UU(II-2,JJ,KK),ZZZ,FLUX_LIMITER)
            ENDIF
         CASE( 2) OFF_WALL_SELECT_2
            IF ((VV(II,JJ+1,KK)>0._EB) .AND. .NOT.(WALL_INDEX(CELL_INDEX(II,JJ+1,KK),+2)>0)) THEN
               ZZZ(1:3) = (/Z_F,ZZP(II,JJ+1:JJ+2,KK)/)
               ZFY(II,JJ+1,KK) = SCALAR_FACE_VALUE(VV(II,JJ+1,KK),ZZZ,FLUX_LIMITER)
            ENDIF
         CASE(-2) OFF_WALL_SELECT_2
            IF ((VV(II,JJ-2,KK)<0._EB) .AND. .NOT.(WALL_INDEX(CELL_INDEX(II,JJ-1,KK),-2)>0)) THEN
               ZZZ(2:4) = (/ZZP(II,JJ-2:JJ-1,KK),Z_F/)
               ZFY(II,JJ-2,KK) = SCALAR_FACE_VALUE(VV(II,JJ-2,KK),ZZZ,FLUX_LIMITER)
            ENDIF
         CASE( 3) OFF_WALL_SELECT_2
            IF ((WW(II,JJ,KK+1)>0._EB) .AND. .NOT.(WALL_INDEX(CELL_INDEX(II,JJ,KK+1),+3)>0)) THEN
               ZZZ(1:3) = (/Z_F,ZZP(II,JJ,KK+1:KK+2)/)
               ZFZ(II,JJ,KK+1) = SCALAR_FACE_VALUE(WW(II,JJ,KK+1),ZZZ,FLUX_LIMITER)
            ENDIF
         CASE(-3) OFF_WALL_SELECT_2
            IF ((WW(II,JJ,KK-2)<0._EB) .AND. .NOT.(WALL_INDEX(CELL_INDEX(II,JJ,KK-1),-3)>0)) THEN
               ZZZ(2:4) = (/ZZP(II,JJ,KK-2:KK-1),Z_F/)
               ZFZ(II,JJ,KK-2) = SCALAR_FACE_VALUE(WW(II,JJ,KK-2),ZZZ,FLUX_LIMITER)
            ENDIF
      END SELECT OFF_WALL_SELECT_2

   ENDIF OFF_WALL_IF_2

ENDDO WALL_LOOP_2

! Production term

DO K=1,KBAR
   DO J=1,JBAR
      DO I=1,IBAR
         IF (SOLID(CELL_INDEX(I,J,K))) CYCLE

         DZDX = (ZFX(I,J,K)-ZFX(I-1,J,K))*RDX(I)
         DZDY = (ZFY(I,J,K)-ZFY(I,J-1,K))*RDY(J)
         DZDZ = (ZFZ(I,J,K)-ZFZ(I,J,K-1))*RDZ(K)

         DENOM = RHO(I,J,K)*( ZZP(I,J,K) - ZZP(I,J,K)**2 )

         IF (DENOM>TWO_EPSILON_EB) THEN
            ! scale sgs variance production
            ZETA_SOURCE_TERM(I,J,K) = 2._EB*MU(I,J,K)/SC*( DZDX**2 + DZDY**2 + DZDZ**2 ) / DENOM
         ELSE
            ! cell is pure, unmix
            ZETA_SOURCE_TERM(I,J,K) = (1._EB - ZZ(I,J,K,ZETA_INDEX))/DT
         ENDIF

         ZZ(I,J,K,ZETA_INDEX) = MIN( 1._EB, ZZ(I,J,K,ZETA_INDEX) + DT*ZETA_SOURCE_TERM(I,J,K) )
      ENDDO
   ENDDO
ENDDO

END SUBROUTINE ZETA_PRODUCTION

END MODULE FIRE

